    LeaveCriticalSection(NmpPnpLock);

    return;

}  // NmpWatchForPnpEvents


DWORD
NmpEnablePnpEvents(
    VOID
    )
{
    DWORD   status;


    EnterCriticalSection(NmpPnpLock);

    if (NmpPnpChangeOccurred) {
        status = ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED;
    }
    else {
        NmpPnpEnabled = TRUE;
        status = ERROR_SUCCESS;
    }

    LeaveCriticalSection(NmpPnpLock);

    return(status);

}  // NmpEnablePnpEvents


VOID
NmPostPnpEvent(
    IN  CLUSNET_EVENT_TYPE   EventType,
    IN  DWORD                Context1,
    IN  DWORD                Context2
    )
{
    PNM_PNP_EVENT  event;


    event = ClRtlAllocateBuffer(NmpPnpEventPool);

    if (event != NULL) {
        event->Type = EventType;
        event->Context1 = Context1;
        event->Context2 = Context2;

        ClRtlInsertTailQueue(NmpPnpEventQueue, &(event->Linkage));
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP event.\n"
            );
    }

    return;

} // NmPostPnpEvent


VOID
NmpProcessPnpAddAddressEvent(
    IN LPWSTR   Address
    )
{
    DWORD                status;
    PNM_NETWORK_ENUM     networkEnum;
    PNM_INTERFACE_ENUM2  interfaceEnum;
    DWORD                matchedNetworkCount;
    DWORD                newNetworkCount;
    DWORD                retryCount = 0;


    //
    // We will retry this operation a few times in case multiple nodes
    // race to create a network that has just been powered up.
    //
    do {
        networkEnum = NULL;
        interfaceEnum = NULL;
        matchedNetworkCount = 0;
        newNetworkCount = 0;

        NmpAcquireLock();

        //
        // Obtain the network and interface definitions.
        //
        status = NmpEnumNetworkObjects(&networkEnum);

        if (status == ERROR_SUCCESS) {
            status = NmpEnumInterfaceObjects(&interfaceEnum);

            NmpReleaseLock();

            if (status == ERROR_SUCCESS) {
                //
                // Run the network configuration engine. This will
                // update the cluster database.
                //
                status = NmpConfigureNetworks(
                             NULL,
                             NmLocalNodeIdString,
                             NmLocalNodeName,
                             &networkEnum,
                             &interfaceEnum,
                             NmpClusnetEndpoint,
                             &matchedNetworkCount,
                             &newNetworkCount,
                             TRUE                   // RenameConnectoids
                             );

                if (status == ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Matched %1!u! networks, created %2!u! new "
                        "networks.\n",
                        matchedNetworkCount,
                        newNetworkCount
                        );
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NM] Failed to configure networks & interfaces, "
                        "attempt #%1!u!, status %2!u!.\n",
                        (retryCount + 1),
                        status
                        );
                }

                if (interfaceEnum != NULL) {
                    ClNetFreeInterfaceEnum(interfaceEnum);
                }
            }
            else {
                ClRtlLogPrint(
                    LOG_UNUSUAL, 
                    "[NM] Failed to obtain current interface configuration, "
                    "status %1!u!\n",
                    status
                    );
            }

            if (networkEnum != NULL) {
                ClNetFreeNetworkEnum(networkEnum);
            }
        }
        else {
            NmpReleaseLock();
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] Failed to obtain current network configuration, "
                "status %1!u!\n",
                status
                );
        }

    } while ((status != ERROR_SUCCESS) && (++retryCount <= 3));

    return;

} // NmpProcessPnpAddAddressEvent


VOID
NmpProcessPnpDelAddressEvent(
    IN LPWSTR   Address
    )
{
    PLIST_ENTRY     entry;
    PNM_INTERFACE   netInterface;
    BOOLEAN         networkDeleted;

    //
    // Check if this address corresponds to an interface for
    // the local node.
    //
    NmpAcquireLock();

    for (entry = NmLocalNode->InterfaceList.Flink;
         entry != &(NmLocalNode->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NodeLinkage
                           );

        if (lstrcmpW(
                Address,
                netInterface->Address
                ) == 0
            )
        {
            //
            // Delete the interface from the cluster.
            //
            NmpGlobalDeleteInterface(
                (LPWSTR) OmObjectId(netInterface),
                &networkDeleted
                );
            break;
        }
    }

    if (entry == &(NmLocalNode->InterfaceList)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Deleted address does not correspond to a cluster "
            "interface.\n"
            );
    }

    NmpReleaseLock();

    return;

} // NmpProcessPnpDelAddressEvent


DWORD
NmpPnpWorkerThread(
    LPVOID Context
    )
{
    PLIST_ENTRY     entry;
    PNM_PNP_EVENT   event;
    BOOL            again = TRUE;
    DWORD           status;


    while (again) {
        entry = ClRtlRemoveHeadQueue(NmpPnpEventQueue);

        if (entry == NULL) {
            //
            // Time to exit
            //
            NmpPnpShutdownEvent = NULL;
            break;
        }

        event = CONTAINING_RECORD(entry, NM_PNP_EVENT, Linkage);

        if (event->Type == ClusnetEventNone) {
            //
            // Time to exit
            //
            again = FALSE;
            NmpPnpShutdownEvent = NULL;
        }
        else if (event->Type == ClusnetEventNetInterfaceUp) {
            NmpReportLocalInterfaceStateEvent(
                event->Context1,
                event->Context2,
                ClusterNetInterfaceUp
                );
        }
        else if (event->Type == ClusnetEventNetInterfaceUnreachable) {
            NmpReportLocalInterfaceStateEvent(
                event->Context1,
                event->Context2,
                ClusterNetInterfaceUnreachable
                );
        }
        else if (event->Type == ClusnetEventNetInterfaceFailed) {
            NmpReportLocalInterfaceStateEvent(
                event->Context1,
                event->Context2,
                ClusterNetInterfaceFailed
                );
        }
        else if ( (event->Type == ClusnetEventAddAddress) ||
                  (event->Type == ClusnetEventDelAddress)
                )
        {
            //
            // This is a PnP event.
            //
            EnterCriticalSection(NmpPnpLock);

            if (NmpPnpEnabled) {
                LeaveCriticalSection(NmpPnpLock);

                status = ClRtlTcpipAddressToString(
                             event->Context1,
                             &NmpPnpAddressString
                             );

                if (status == ERROR_SUCCESS) {
                    if (event->Type == ClusnetEventAddAddress) {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Processing PnP add event for address "
                            "%1!ws!.\n",
                            NmpPnpAddressString
                            );

                        NmpProcessPnpAddAddressEvent(NmpPnpAddressString);
                    }
                    else {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Processing PnP delete event for address "
                            "%1!ws!.\n",
                            NmpPnpAddressString
                            );

                        NmpProcessPnpDelAddressEvent(NmpPnpAddressString);
                    }
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NM] Failed to convert PnP address %1!x! to string, "
                        "status %2!u!.\n",
                        event->Context1,
                        status
                        );
                }
            }
            else {
                //
                // We are not ready to handle PnP events yet.
                // Note that something changed. This will cause the join/form
                // process to eventually abort.
                //
                NmpPnpChangeOccurred = TRUE;

                LeaveCriticalSection(NmpPnpLock);

                ClRtlLogPrint(
                    LOG_NOISE, 
                    "[NM] Discarding Pnp notification - handling not "
                    "enabled.\n"
                    );
            }
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Received unknown PnP event type 0x%1!x!.\n",
                event->Type
                );
        }

        ClRtlFreeBuffer(event);
    }

    ClRtlLogPrint(LOG_NOISE, "[NM] Pnp worker thread terminating.\n");

    return(ERROR_SUCCESS);

} // NmpPnpWorkerThread


DWORD
NmpConfigureNetworks(
    IN     RPC_BINDING_HANDLE     JoinSponsorBinding,
    IN     LPWSTR                 LocalNodeId,
    IN     LPWSTR                 LocalNodeName,
    IN     PNM_NETWORK_ENUM *     NetworkEnum,
    IN     PNM_INTERFACE_ENUM2 *  InterfaceEnum,
    IN     LPWSTR                 DefaultEndpoint,
    IN OUT LPDWORD                MatchedNetworkCount,
    IN OUT LPDWORD                NewNetworkCount,
    IN     BOOL                   RenameConnectoids
    )
/*++

Notes:

    Must not be called with the NM lock held.

    RenameConnectoids is TRUE if connectoid names are to be aligned with
    cluster network names. If FALSE, rename the cluster network names to be
    like the connectoid names.

--*/
{
    DWORD                    status;
    CLNET_CONFIG_LISTS       lists;
    PLIST_ENTRY              listEntry;
    PCLNET_CONFIG_ENTRY      configEntry;
    BOOLEAN                  networkDeleted;
    WCHAR                    errorString[12];
    DWORD                    eventCode = 0;
    DWORD                    defaultRole = CL_DEFAULT_NETWORK_ROLE;


    *MatchedNetworkCount = 0;
    *NewNetworkCount = 0;

    ClNetInitializeConfigLists(&lists);

    //
    // Convert the enums to a list
    //
    status = ClNetConvertEnumsToConfigList(
                 NetworkEnum,
                 InterfaceEnum,
                 LocalNodeId,
                 &(lists.InputConfigList),
                 TRUE
                 );

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    //
    // Read the default network role from the database.
    //
    (VOID) DmQueryDword(
               DmClusterParametersKey,
               CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE,
               &defaultRole,
               &defaultRole
               );

    //
    // Run the configuration engine. Existing net names take
    // precedence over connectoid when joining, otherwise change
    // the net name to align with the changed connectoid name.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Running network configuration engine.\n"
        );

    status = ClNetConfigureNetworks(
                 LocalNodeId,
                 LocalNodeName,
                 NmpClusnetEndpoint,
                 defaultRole,
                 RenameConnectoids,
                 &lists,
                 MatchedNetworkCount,
                 NewNetworkCount
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Processing network configuration changes.\n"
        );

    //
    // Process the output - The order is important!
    //
    while (!IsListEmpty(&(lists.DeletedInterfaceList))) {
        listEntry = RemoveHeadList(&(lists.DeletedInterfaceList));
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        status = NmpDeleteInterface(
                     JoinSponsorBinding,
                     configEntry->InterfaceInfo.Id,
                     configEntry->InterfaceInfo.NetworkId,
                     &networkDeleted
                     );

        ClNetFreeConfigEntry(configEntry);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    while (!IsListEmpty(&(lists.UpdatedInterfaceList))) {
        listEntry = RemoveHeadList(&(lists.UpdatedInterfaceList));
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        status = NmpSetInterfaceInfo(
                     JoinSponsorBinding,
                     &(configEntry->InterfaceInfo)
                     );

        if (status == ERROR_SUCCESS && configEntry->UpdateNetworkName) {

            CL_ASSERT(JoinSponsorBinding == NULL);

            //
            // Note: this function must not be called with the NM lock
            // held.
            //
            status = NmpSetNetworkName(
                         &(configEntry->NetworkInfo)
                         );
        }

        ClNetFreeConfigEntry(configEntry);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    while (!IsListEmpty(&(lists.CreatedInterfaceList))) {
        listEntry = RemoveHeadList(&(lists.CreatedInterfaceList));
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        status = NmpCreateInterface(
                     JoinSponsorBinding,
                     &(configEntry->InterfaceInfo)
                     );

        ClNetFreeConfigEntry(configEntry);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    while (!IsListEmpty(&(lists.CreatedNetworkList))) {
        listEntry = RemoveHeadList(&(lists.CreatedNetworkList));
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        status = NmpCreateNetwork(
                     JoinSponsorBinding,
                     &(configEntry->NetworkInfo),
                     &(configEntry->InterfaceInfo)
                     );

        ClNetFreeConfigEntry(configEntry);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    ClNetFreeConfigLists(&lists);

    return(status);

} // NmpConfigureNetworks

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\nmutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nmutil.c

Abstract:

    Miscellaneous utility routines for the Node Manager component.

Author:

    Mike Massa (mikemas) 26-Oct-1996


Revision History:

--*/

#define UNICODE 1

#include "service.h"
#include "nmp.h"
#include <ntlsa.h>
#include <ntmsv1_0.h>

PVOID   NmpClusterKey = NULL;
DWORD   NmpClusterKeyLength = 0;



DWORD
NmpQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    )

/*++

Routine Description:

    Reads a REG_SZ or REG_MULTI_SZ registry value. If the StringBuffer is
    not large enough to hold the data, it is reallocated.

Arguments:

    Key              - Open key for the value to be read.

    ValueName        - Unicode name of the value to be read.

    ValueType        - REG_SZ or REG_MULTI_SZ.

    StringBuffer     - Buffer into which to place the value data.

    StringBufferSize - Pointer to the size of the StringBuffer. This parameter
                       is updated if StringBuffer is reallocated.

    StringSize       - The size of the data returned in StringBuffer, including
                       the terminating null character.

Return Value:

    The status of the registry query.
    
Notes:

    To avoid deadlock with DM, must not be called with NM lock held.

--*/
{
    DWORD    status;
    DWORD    valueType;
    WCHAR   *temp;
    DWORD    oldBufferSize = *StringBufferSize;
    BOOL     noBuffer = FALSE;


    if (*StringBufferSize == 0) {
        noBuffer = TRUE;
    }

    *StringSize = *StringBufferSize;

    status = DmQueryValue( Key,
                           ValueName,
                           &valueType,
                           (LPBYTE) *StringBuffer,
                           StringSize
                         );

    if (status == NO_ERROR) {
        if (!noBuffer ) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        status = ERROR_MORE_DATA;
    }

    if (status == ERROR_MORE_DATA) {
        temp = MIDL_user_allocate(*StringSize);

        if (temp == NULL) {
            *StringSize = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (!noBuffer) {
            MIDL_user_free(*StringBuffer);
        }

        *StringBuffer = temp;
        *StringBufferSize = *StringSize;

        status = DmQueryValue( Key,
                               ValueName,
                               &valueType,
                               (LPBYTE) *StringBuffer,
                               StringSize
                             );

        if (status == NO_ERROR) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                *StringSize = 0;
                return(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return(status);

} // NmpQueryString


//
// Routines to support the common network configuration code.
//
VOID
ClNetPrint(
    IN ULONG  LogLevel,
    IN PCHAR  FormatString,
    ...
    )
{
    CHAR      buffer[256];
    DWORD     bytes;
    va_list   argList;

    va_start(argList, FormatString);

    bytes = FormatMessageA(
                FORMAT_MESSAGE_FROM_STRING,
                FormatString,
                0,
                0,
                buffer,
                sizeof(buffer),
                &argList
                );

    va_end(argList);

    if (bytes != 0) {
        ClRtlLogPrint(LogLevel, "%1!hs!", buffer);
    }

    return;

} // ClNetPrint

VOID
ClNetLogEvent(
    IN DWORD    LogLevel,
    IN DWORD    MessageId
    )
{
    CsLogEvent(LogLevel, MessageId);

    return;

}  // ClNetLogEvent

VOID
ClNetLogEvent1(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1
    )
{
    CsLogEvent1(LogLevel, MessageId, Arg1);

    return;

}  // ClNetLogEvent1


VOID
ClNetLogEvent2(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2
    )
{
    CsLogEvent2(LogLevel, MessageId, Arg1, Arg2);

    return;

}  // ClNetLogEvent2


VOID
ClNetLogEvent3(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2,
    IN LPCWSTR  Arg3
    )
{
    CsLogEvent3(LogLevel, MessageId, Arg1, Arg2, Arg3);

    return;

}  // ClNetLogEvent3


BOOLEAN
NmpLockedEnterApi(
    NM_STATE  RequiredState
    )
{
    if (NmpState >= RequiredState) {
        NmpActiveThreadCount++;
        CL_ASSERT(NmpActiveThreadCount != 0);
        return(TRUE);
    }

    return(FALSE);

} // NmpLockedEnterApi


BOOLEAN
NmpEnterApi(
    NM_STATE  RequiredState
    )
{
    BOOLEAN  mayEnter;


    NmpAcquireLock();

    mayEnter = NmpLockedEnterApi(RequiredState);

    NmpReleaseLock();

    return(mayEnter);

} // NmpEnterApi


VOID
NmpLockedLeaveApi(
    VOID
    )
{
    CL_ASSERT(NmpActiveThreadCount > 0);

    NmpActiveThreadCount--;

    if ((NmpActiveThreadCount == 0) && (NmpState == NmStateOfflinePending)) {
        SetEvent(NmpShutdownEvent);
    }

    return;

} // NmpLockedLeaveApi


VOID
NmpLeaveApi(
    VOID
    )
{
    NmpAcquireLock();

    NmpLockedLeaveApi();

    NmpReleaseLock();

    return;

} // NmpLeaveApi


//
// Routines to provide a cluster shared key for signing and encrypting
// data.
//

DWORD
NmpGetLogonId(
    OUT LUID * LogonId
    )
{
    HANDLE              tokenHandle = NULL;
    TOKEN_STATISTICS    tokenInfo;
    DWORD               bytesReturned;
    BOOL                success = FALSE;
    DWORD               status;

    if (LogonId == NULL) {
        status = STATUS_UNSUCCESSFUL;
        goto error_exit;
    }

    if (!OpenProcessToken(
             GetCurrentProcess(),
             TOKEN_QUERY,
             &tokenHandle
             )) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to open process token, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    if (!GetTokenInformation(
             tokenHandle,
             TokenStatistics,
             &tokenInfo,
             sizeof(tokenInfo),
             &bytesReturned
             )) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get token information, status %1!u!.\n",
            status
            );        
        goto error_exit;
    }

    RtlCopyMemory(LogonId, &(tokenInfo.AuthenticationId), sizeof(LUID));

    status = STATUS_SUCCESS;

error_exit:

    if (tokenHandle != NULL) {
        CloseHandle(tokenHandle);
    }

    return(status);

} // NmpGetLogonId


DWORD
NmpGenerateClusterKey(
    IN  PVOID   MixingBytes,
    IN  DWORD   MixingBytesSize,
    OUT PVOID * Key,
    OUT DWORD * KeyLength
    )
/*++

Routine Description:

    Generate the cluster key using the cluster instance id
    as mixing bytes. Allocate a buffer for the key and 
    return it.
    
Arguments:

    Key - set to buffer containing key
    
    KeyLength - length of resulting key
    
--*/
{
    LUID                        logonId;

    BOOLEAN                     wasEnabled = FALSE;
    BOOLEAN                     trusted = FALSE;

    STRING                      name;

    HANDLE                      lsaHandle = NULL;
    DWORD                       ignore;

    DWORD                       packageId = 0;

    DWORD                       requestSize;
    PMSV1_0_DERIVECRED_REQUEST  request = NULL;
    DWORD                       responseSize;
    PMSV1_0_DERIVECRED_RESPONSE response = NULL;

    PUCHAR                      key;
    DWORD                       keyLength;
    
    DWORD                       status = STATUS_SUCCESS;
    DWORD                       subStatus = STATUS_SUCCESS;

    status = NmpGetLogonId(&logonId);
    if (!NT_SUCCESS(status)) {
        ClRtlLogPrint(
            LOG_UNUSUAL,
            "[NM] Failed to determine logon ID, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Try to turn on TCB privilege if running in console mode.
    //
    // ISSUE-2001/04/30-daviddio
    // In normal operation, there is no need to enable the TCB privilege.
    // In fact, enabling the TCB privilege should usually fail since the
    // cluster service account is not given the TCB privilege during setup.
    // The fix for bug 337751 allows the cluster service account to issue
    // a MSV1_0_DERIVECRED_REQUEST even if it does not have a trusted
    // connection to LSA. The reason this code is left in is for 
    // trouble-shooting. If the cluster service is run from the command
    // line (e.g. not via the SCM), then the fix for bug 337751 will not
    // apply, and a trusted connection to LSA will be required to generate
    // the cluster key.
    //
    if (CsRunningAsService) {
        status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &wasEnabled);
        if (!NT_SUCCESS(status)) {
#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to turn on TCB privilege, status %1!u!.\n",
                LsaNtStatusToWinError(status)
                );
#endif // CLUSTER_BETA
            trusted = FALSE;
        } else {
#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Turned on TCB privilege, wasEnabled = %1!ws!.\n",
                (wasEnabled) ? L"TRUE" : L"FALSE"
                );
#endif // CLUSTER_BETA
            trusted = TRUE;
        }
    }

    //
    // Establish contact with LSA.
    //
    if (trusted) {
        RtlInitString(&name, "ClusSvcNM");
        status = LsaRegisterLogonProcess(&name, &lsaHandle, &ignore);
    
        //
        // Turn off TCB privilege
        //
        if (!wasEnabled) {
            subStatus = RtlAdjustPrivilege(
                            SE_TCB_PRIVILEGE, 
                            FALSE, 
                            FALSE, 
                            &wasEnabled
                            );
            if (!NT_SUCCESS(subStatus)) {
                ClRtlLogPrint(
                    LOG_UNUSUAL,
                    "[NM] Failed to disable TCB privilege, "
                    "status %1!u!.\n",
                    subStatus
                    );
            }
        }
    }
    else {
        status = LsaConnectUntrusted(&lsaHandle);
    }

    if (!NT_SUCCESS(status)) {
        status = LsaNtStatusToWinError(status);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to obtain LSA logon handle in %1!ws! mode, "
            "status %2!u!.\n",
            (trusted) ? L"trusted" : L"untrusted", status
            );
        goto error_exit;
    }

    //
    // Lookup the authentication package.
    //
    RtlInitString( &name, MSV1_0_PACKAGE_NAME );

    status = LsaLookupAuthenticationPackage(lsaHandle, &name, &packageId);
    if (!NT_SUCCESS(status)) {
        status = LsaNtStatusToWinError(status);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to local authentication package with "
            "name %1!ws!, status %2!u!.\n",
            name.Buffer, status
            );
        goto error_exit;
    }

    //
    // Build the derive credentials request with the provided
    // mixing bytes.
    //
    requestSize = sizeof(MSV1_0_DERIVECRED_REQUEST) + MixingBytesSize;
    
    request = LocalAlloc(LMEM_FIXED, requestSize);
    if (request == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate LSA request of size %1!u! bytes.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    request->MessageType = MsV1_0DeriveCredential;
    RtlCopyMemory(&(request->LogonId), &logonId, sizeof(logonId));
    request->DeriveCredType = MSV1_0_DERIVECRED_TYPE_SHA1;
    request->DeriveCredInfoLength = MixingBytesSize;
    RtlCopyMemory(
        &(request->DeriveCredSubmitBuffer[0]),
        MixingBytes,
        MixingBytesSize
        );

    //
    // Make the call through LSA to the authentication package.
    //
    status = LsaCallAuthenticationPackage(
                 lsaHandle,
                 packageId,
                 request,
                 requestSize,
                 &response,
                 &responseSize,
                 &subStatus
                 );
    if (!NT_SUCCESS(status)) {
        status = LsaNtStatusToWinError(status);
        subStatus = LsaNtStatusToWinError(subStatus);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] DeriveCredential call to authentication "
            "package failed, status %1!u!, auth package "
            "status %2!u!.\n", status, subStatus
            );
        goto error_exit;
    }

    //
    // Allocate a non-LSA buffer to store the key.
    //
    keyLength = response->DeriveCredInfoLength;
    key = MIDL_user_allocate(keyLength);
    if (key == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate buffer for cluster "
            "key of size %1!u!.\n",
            keyLength
            );
        goto error_exit;
    }

    //
    // Store the derived credentials in the key buffer.
    //
    RtlCopyMemory(key, &(response->DeriveCredReturnBuffer[0]), keyLength);

    //
    // Zero the derived credential buffer to be extra paranoid.
    //
    RtlZeroMemory(
        &(response->DeriveCredReturnBuffer[0]),
        response->DeriveCredInfoLength
        );

    status = STATUS_SUCCESS;
    *Key = key;
    *KeyLength = keyLength;

error_exit:

    if (lsaHandle != NULL) {
        LsaDeregisterLogonProcess(lsaHandle);
        lsaHandle = NULL;
    }

    if (request != NULL) {
        LocalFree(request);
        request = NULL;
    }

    if (response != NULL) {
        LsaFreeReturnBuffer(response);
        response = NULL;
    }

    return(status);

} // NmpGenerateClusterKey


DWORD
NmpGetClusterKey(
    OUT    PVOID    KeyBuffer,
    IN OUT DWORD  * KeyBufferLength
    )
/*++

Routine Description:

    Copy the shared cluster key into the buffer provided.
   
Arguments:

    KeyBuffer - buffer to which key should be copied
    
    KeyBufferLength - IN: length of KeyBuffer
                      OUT: required buffer size, if input
                           buffer length is insufficient
                           
Return value:

    ERROR_INSUFFICIENT_BUFFER if KeyBuffer is too small.
    ERROR_FILE_NOT_FOUND if NmpClusterKey has not yet been
        generated.
    ERROR_SUCCESS on success.
    
Notes:

    Acquires and releases NM lock. Since NM lock is 
    implemented as a critical section, calling thread
    is permitted to already hold NM lock.
    
--*/
{
    DWORD                  status;

    NmpAcquireLock();

    if (NmpClusterKey == NULL) {
        status = ERROR_FILE_NOT_FOUND;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] The cluster key has not yet been derived.\n"
            );
    } else{
        if (KeyBuffer == NULL || NmpClusterKeyLength > *KeyBufferLength) {
            status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            RtlCopyMemory(KeyBuffer, NmpClusterKey, NmpClusterKeyLength);
            status = ERROR_SUCCESS;
        }

        *KeyBufferLength = NmpClusterKeyLength;
    }

    NmpReleaseLock();

    return(status);

} // NmpGetClusterKey


DWORD
NmpRegenerateClusterKey(
    VOID
    )
/*++

Routine Description:

    Forces regeneration of cluster key.
    
    Must be called during cluster initialization to generate
    cluster key the first time.
    
Notes:

    Acquires and releases NM lock.    
    
--*/
{
    DWORD                  status;
    BOOLEAN                lockAcquired;
    PVOID                  oldKey = NULL;
    DWORD                  oldKeyLength = 0;
    PVOID                  key = NULL;
    DWORD                  keyLength = 0;
    PVOID                  mixingBytes;
    DWORD                  mixingBytesSize;

    NmpAcquireLock();
    lockAcquired = TRUE;

    NmpLockedEnterApi(NmStateOnlinePending);

    //
    // Form the mixing bytes.
    //
    if (NmpClusterInstanceId == NULL) {
        status = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Need cluster instance id in order to derive "
            "cluster key, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    mixingBytesSize = NM_WCSLEN(NmpClusterInstanceId);
    mixingBytes = MIDL_user_allocate(mixingBytesSize);
    if (mixingBytes == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate buffer of size %1!u! "
            "for mixing bytes to derive cluster key.\n",
            mixingBytesSize
            );
        goto error_exit;
    }
    RtlCopyMemory(mixingBytes, NmpClusterInstanceId, mixingBytesSize);

    //
    // Make a copy of the old key to detect changes.
    //
    if (NmpClusterKey != NULL) {

        CL_ASSERT(NmpClusterKeyLength > 0);

        oldKey = MIDL_user_allocate(NmpClusterKeyLength);
        if (oldKey == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate buffer for cluster "
                "key copy.\n"
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
        oldKeyLength = NmpClusterKeyLength;
        RtlCopyMemory(oldKey, NmpClusterKey, NmpClusterKeyLength);
    }

    NmpReleaseLock();
    lockAcquired = FALSE;

    status = NmpGenerateClusterKey(
                 mixingBytes, 
                 mixingBytesSize,
                 &key,
                 &keyLength
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to generate cluster key, "
            "status %1!u!.\n", 
            status
            );
        goto error_exit;
    }

    NmpAcquireLock();
    lockAcquired = TRUE;

    //
    // Make sure another thread didn't beat us in obtaining a key.
    // We replace the cluster key with the generated key if it is
    // not different from the old key (or somebody set it to NULL).
    //
    if (NmpClusterKey != NULL &&
        (oldKey == NULL ||
         NmpClusterKeyLength != oldKeyLength ||
         RtlCompareMemory(
             NmpClusterKey,
             oldKey,
             oldKeyLength
             ) != oldKeyLength
         )
        ) {

        //
        // Keep the current NmpClusterKey.
        //
    } else {

        MIDL_user_free(NmpClusterKey);
        NmpClusterKey = key;
        NmpClusterKeyLength = keyLength;
        key = NULL;
    }

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    } else {
        NmpLeaveApi();
    }

    if (key != NULL) {
        MIDL_user_free(key);
        key = NULL;
    }

    if (mixingBytes != NULL) {
        MIDL_user_free(mixingBytes);
        mixingBytes = NULL;
    }

    return(status);

} // NmpRegenerateClusterKey


VOID
NmpFreeClusterKey(
    VOID
    )
/*++

Routine Description:

    Called during NmShutdown.
    
--*/
{
    if (NmpClusterKey != NULL) {
        MIDL_user_free(NmpClusterKey);
        NmpClusterKey = NULL;
        NmpClusterKeyLength = 0;
    }

    return;

} // NmpFreeClusterKey

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\nmver.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    nmver.c

Abstract:

    Version management functions used by rolling upgrade.

Author:

    Sunita Shrivastava (sunitas)

Revision History:

    1/29/98   Created.

--*/

#include "nmp.h"

error_status_t
s_CsRpcGetJoinVersionData(
    handle_t  handle,
    DWORD     JoiningNodeId,
    DWORD     JoinerHighestVersion,
    DWORD     JoinerLowestVersion,
    LPDWORD   SponsorNodeId,
    LPDWORD   ClusterHighestVersion,
    LPDWORD   ClusterLowestVersion,
    LPDWORD   JoinStatus
    )

/*++

Routine Description:

    Get from and supply to the joiner, version information about the
    sponsor. Mostly a no-op for first version.

Arguments:

    A pile...

Return Value:

    None

--*/

{
    *SponsorNodeId = NmLocalNodeId;

    NmpAcquireLock();

    if (JoiningNodeId == 0)
    {
        //called by setup join
        *ClusterHighestVersion = CsClusterHighestVersion;
        *ClusterLowestVersion = CsClusterLowestVersion;
        //dont exclude any node for version calculation and checking
        *JoinStatus = NmpIsNodeVersionAllowed(ClusterInvalidNodeId, JoinerHighestVersion,
            JoinerLowestVersion, TRUE);
    }
    else
    {
        //called by regular join
        //SS:  we should verify this against the cluster version
        NmpCalcClusterVersion(
            JoiningNodeId,
            ClusterHighestVersion,
            ClusterLowestVersion
            );
        *JoinStatus = NmpIsNodeVersionAllowed(JoiningNodeId, JoinerHighestVersion,
            JoinerLowestVersion, TRUE);

    }
    NmpReleaseLock();

    return ERROR_SUCCESS;
}

/****
@func       HLOG | NmGetClusterOperationalVersion| This returns the
            operational version for the cluster.

@parm       LPDWORD | pdwClusterHighestVersion | A pointer to a DWORD where
            the Cluster Highest Version is returned.

@parm       LPDWORD | pdwClusterHighestVersion | A pointer to a DWORD where
            the Cluster Lowest Version is returned.

@parm       LPDWORD | pdwFlags | A pointer to a DWORD where the flags
            describing the cluster mode(pure vs fixed version etc) are
            returned.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm

@xref       <>
****/
DWORD NmGetClusterOperationalVersion(
    OUT LPDWORD pdwClusterHighestVersion, OPTIONAL
    OUT LPDWORD pdwClusterLowestVersion,  OPTIONAL
    OUT LPDWORD pdwFlags                  OPTIONAL
)
{

    DWORD       dwStatus = ERROR_SUCCESS;
    DWORD       flags = 0;

    //acquire the lock, we are going to be messing with the operational
    //versions for the cluster
    NmpAcquireLock();

    if (pdwClusterHighestVersion != NULL) {
        *pdwClusterHighestVersion = CsClusterHighestVersion;
    }

    if (pdwClusterLowestVersion != NULL) {
        *pdwClusterLowestVersion = CsClusterLowestVersion;
    }

    if (CsClusterHighestVersion == CsClusterLowestVersion) {
        //this is a mixed mode cluster, with the possible exception of
        //nt 4 release(which didnt quite understand anything about rolling
        //upgrades
        flags = CLUSTER_VERSION_FLAG_MIXED_MODE;
    }

    NmpReleaseLock();

    if (pdwFlags != NULL) {
        *pdwFlags = flags;
    }

    return (ERROR_SUCCESS);
}


/****
@func       HLOG | NmpResetClusterVersion| An operational version of the
            cluster is maintained in the service.  This function recalculates
            the operation version. The operational version describes the mode
            in which the cluster is running and prevents nodes which are two
            versions away from running in the same cluster.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function is called when a node forms a cluster(to initialize
            the operational version) OR when a node joins a cluster (to
            initialize its version) OR when a node is ejected from a
            cluster(to recalculate the clusterversion).

@xref       <>
****/
VOID
NmpResetClusterVersion(
    BOOL ProcessChanges
    )
{
    PNM_NODE    pNmNode;

    //acquire the lock, we are going to be messing with the operational
    //versions for the cluster
    NmpAcquireLock();

    //initialize the clusterhighestverion and clusterlowest version
    NmpCalcClusterVersion(
        ClusterInvalidNodeId,
        &CsClusterHighestVersion,
        &CsClusterLowestVersion
        );

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] [NmpResetClusterVersion] ClusterHighestVer=0x%1!08lx! ClusterLowestVer=0x%2!08lx!\r\n",
        CsClusterHighestVersion,
        CsClusterLowestVersion
        );

    if (ProcessChanges) {
        //
        // If the cluster operational version changed, adjust
        // algorithms and data as needed.
        //
        NmpProcessClusterVersionChange();
    }

    NmpReleaseLock();

    return;
}

/****
@func       HLOG | NmpValidateNodeVersion| The sponsor validates that the
            version of the joiner is still the same as before.

@parm       IN LPWSTR| NodeJoinerId | The Id of the node that is trying to
            join.

@parm       IN DWORD | NodeHighestVersion | The highest version with which
            this node can communicate.

@parm       IN DWORD | NodeLowestVersion | The lowest version with which this
            node can communicate.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function is called at join time to make sure that the
            joiner's version is still the same as when he last joined.  Due
            to uninstalls/upgrade, the cluster service version may change on
            a node.  Usually on a complete uninstall, one is expected to
            evict the node out before it may join again.

@xref       <>
****/
DWORD NmpValidateNodeVersion(
    IN LPCWSTR  NodeId,
    IN DWORD    dwHighestVersion,
    IN DWORD    dwLowestVersion
    )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pNmNode = NULL;

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpValidateNodeVersion: Node=%1!ws!, HighestVersion=0x%2!08lx!, LowestVersion=0x%3!08lx!\r\n",
        NodeId, dwHighestVersion, dwLowestVersion);

    //acquire the NmpLocks, we will be examining the node structure for
    // the joiner node
    NmpAcquireLock();

    pNmNode = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (!pNmNode)
    {
        dwStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto FnExit;
    }

    if ((pNmNode->HighestVersion != dwHighestVersion) ||
        (pNmNode->LowestVersion != dwLowestVersion))
    {
        dwStatus = ERROR_REVISION_MISMATCH;
        goto FnExit;
    }

FnExit:
    if (pNmNode) OmDereferenceObject(pNmNode);
    ClRtlLogPrint(LOG_NOISE, "[NM] NmpValidateNodeVersion: returns %1!u!\r\n",
        dwStatus);
    NmpReleaseLock();
    return(dwStatus);
}

/****
@func       DWORD | NmpFormFixupNodeVersion| This may be called by a node
            when it is forming a cluster to fix the registry reflect its
            correct version.

@parm       IN LPCWSTR| NodeId | The Id of the node that is trying to join.

@parm       IN DWORD | dwHighestVersion | The highest version of the cluster
            s/w running on this code.

@parm       IN DWORD | dwLowestVersion | The lowest version of the cluster
            s/w running on this node.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       If on a form, there is a mismatch between the versions of the
            cluster s/w and what is recorded as the version in the cluster
            database, the forming node checks to see if the version of
            its current s/w is compatible with the operational version of the
            cluster.  If so, it resets the registry to reflect the correct
            version.  Else,  the form is aborted.

@xref       <f NmpIsNodeVersionAllowed>
****/
DWORD NmpFormFixupNodeVersion(
    IN LPCWSTR      NodeId,
    IN DWORD        dwHighestVersion,
    IN DWORD        dwLowestVersion
    )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pNmNode = NULL;
    HDMKEY      hNodeKey = NULL;

    //acquire the NmpLocks, we will be fixing up the node structure for
    // the joiner node
    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpFormFixupNodeVersion: Node=%1!ws! to HighestVer=0x%2!08lx!, LowestVer=0x%3!08lx!\r\n",
        NodeId, dwHighestVersion, dwLowestVersion);

    pNmNode = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (!pNmNode)
    {
        dwStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto FnExit;
    }

    hNodeKey = DmOpenKey(DmNodesKey, NodeId, KEY_WRITE);

    if (hNodeKey == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpFormFixupNodeVersion: Failed to open node key, status %1!u!\n",
            dwStatus);
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //set the node's highest version
    dwStatus = DmSetValue(hNodeKey, CLUSREG_NAME_NODE_HIGHEST_VERSION,
        REG_DWORD, (LPBYTE)&dwHighestVersion, sizeof(DWORD));

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpFormFixupNodeVersion: Failed to set the highest version\r\n");
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //set the node's lowest version
    dwStatus = DmSetValue(hNodeKey, CLUSREG_NAME_NODE_LOWEST_VERSION,
        REG_DWORD, (LPBYTE)&dwLowestVersion, sizeof(DWORD));

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpFormFixupNodeVersion: Failed to set the lowest version\r\n");
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    pNmNode->HighestVersion = dwHighestVersion;
    pNmNode->LowestVersion = dwLowestVersion;

FnExit:
    NmpReleaseLock();
    if (pNmNode)
        OmDereferenceObject(pNmNode);
    if (hNodeKey != NULL)
        DmCloseKey(hNodeKey);

    return(dwStatus);
}

/****
@func       DWORD | NmpJoinFixupNodeVersion| This may be called by a node
            when it is forming a cluster to fix the registry reflect its
            correct version.

@parm       IN LPCWSTR| NodeId | The Id of the node that is trying to join.

@parm       IN DWORD | dwHighestVersion | The highest version of this cluster
            s/w running on this code.

@parm       IN DWORD | dwLowestVersion | The lowest version of the cluster
            s/w running on this node.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       If on a form, their is a mismatch between the versions of the
            cluster s/w and what is recorded as the version in the cluster
            database, the forming node checks to see if the version of
            its current s/w compatible with the operational version of the
            cluster.  If so, it resets the registry to reflect the correct
            version.  Else,  the form is aborted.

@xref       <f NmpIsNodeVersionAllowed>
****/
DWORD NmpJoinFixupNodeVersion(
    IN HLOCALXSACTION   hXsaction,
    IN LPCWSTR          szNodeId,
    IN DWORD            dwHighestVersion,
    IN DWORD            dwLowestVersion
    )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pNmNode = NULL;
    HDMKEY      hNodeKey = NULL;

    //acquire the NmpLocks, we will be fixing up the node structure for
    // the joiner node
    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpJoinFixupNodeVersion: Node=%1!ws! to HighestVer=0x%2!08lx!, LowestVer=0x%3!08lx!\r\n",
        szNodeId, dwHighestVersion, dwLowestVersion);

    pNmNode = OmReferenceObjectById(ObjectTypeNode, szNodeId);

    if (!pNmNode)
    {
        dwStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto FnExit;
    }

    hNodeKey = DmOpenKey(DmNodesKey, szNodeId, KEY_WRITE);

    if (hNodeKey == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpJoinFixupNodeVersion: Failed to open node key, status %1!u!\n",
            dwStatus);
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //set the node's highest version
    dwStatus = DmLocalSetValue(
                   hXsaction,
                   hNodeKey,
                   CLUSREG_NAME_NODE_HIGHEST_VERSION,
                   REG_DWORD,
                   (LPBYTE)&dwHighestVersion,
                   sizeof(DWORD)
                   );

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpJoinFixupNodeVersion: Failed to set the highest version\r\n"
            );
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //set the node's lowest version
    dwStatus = DmLocalSetValue(
                   hXsaction,
                   hNodeKey,
                   CLUSREG_NAME_NODE_LOWEST_VERSION,
                   REG_DWORD,
                   (LPBYTE)&dwLowestVersion,
                   sizeof(DWORD)
                   );

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpJoinFixupNodeVersion: Failed to set the lowest version\r\n"
            );
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //if written to the registry successfully, update the in-memory structures
    pNmNode->HighestVersion = dwHighestVersion;
    pNmNode->LowestVersion = dwLowestVersion;


    if (dwStatus == ERROR_SUCCESS)
    {
        ClusterEvent(CLUSTER_EVENT_NODE_PROPERTY_CHANGE, pNmNode);
    }
    

FnExit:
    NmpReleaseLock();
    if (pNmNode)
        OmDereferenceObject(pNmNode);
    if (hNodeKey != NULL)
        DmCloseKey(hNodeKey);

    return(dwStatus);
}

/****
@func       HLOG | NmpIsNodeVersionAllowed| This is called at join time
            (not setup join) e sponsor validates if a joiner
            should be allowed to join a  cluster at this time.  In a mixed
            mode cluster, a node may not be able to join a cluster if another
            node that is two versions away is already a part of the cluster.

@parm       IN DWORD | dwExcludeNodeId |  The node Id to exclude while
            evaluating the cluster operational version.

@parm       IN DWORD | NodeHighestVersion | The highest version with which
            this node can communicate.

@parm       IN DWORD | NodeLowestVersion | The lowest version with which this
            node can communicate.

@parm       IN BOOL |bJoin| If this is being invoked at join or form time.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function is called when a node requests a sponsor to allow
            it to join a cluster.

@xref       <>
****/
DWORD NmpIsNodeVersionAllowed(
    IN DWORD    dwExcludeNodeId,
    IN DWORD    dwNodeHighestVersion,
    IN DWORD    dwNodeLowestVersion,
    IN BOOL     bJoin
    )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           ClusterHighestVersion;
    DWORD           ClusterLowestVersion;
    PLIST_ENTRY     pListEntry;
    DWORD           dwCnt;
    PNM_NODE        pNmNode;

    ClRtlLogPrint(LOG_UNUSUAL, 
        "[NM] NmpIsNodeVersionAllowed: Entry\r\n");


    //acquire the NmpLocks, we will be examining the node structures
    NmpAcquireLock();

    //if NoVersionCheckOption is true
    if (CsNoVersionCheck)
        goto FnExit;


    //if this is a single node cluster, and this is being called at form
    //the count of nodes is zero.
    //this will happen when the registry versions dont match with
    //cluster service exe version numbers and we need to allow the single
    //node to form
    for (dwCnt=0, pListEntry = NmpNodeList.Flink;
        pListEntry != &NmpNodeList; pListEntry = pListEntry->Flink )
    {
        pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);
        if (NmGetNodeId(pNmNode) == dwExcludeNodeId)
            continue;
        dwCnt++;
    }

    if (!dwCnt)
    {
        //allow the node to form
        goto FnExit;
    }


    dwStatus = NmpCalcClusterVersion(
                   dwExcludeNodeId,
                   &ClusterHighestVersion,
                   &ClusterLowestVersion
                   );

    if (dwStatus != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    //if the node is forming and this node has just upgraded
    //allow the node to form as long as its minor(or build number)
    //is greater than or equal to all other nodes with the same
    //major number in the cluster
    if (!bJoin && CsUpgrade)
    {

        DWORD dwMinorVersion = 0x00000000;

        for (pListEntry = NmpNodeList.Flink; pListEntry != &NmpNodeList;
            pListEntry = pListEntry->Flink )
        {
                pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

                if (NmGetNodeId(pNmNode) == dwExcludeNodeId)
                    continue;

                if (CLUSTER_GET_MAJOR_VERSION(pNmNode->HighestVersion) ==
                     CLUSTER_GET_MAJOR_VERSION(dwNodeHighestVersion))
                {
                    //the minor version to check is the maximum of the
                    //build numbers amongst the nodes with the same major
                    //version
                    dwMinorVersion = max(dwMinorVersion,
                        CLUSTER_GET_MINOR_VERSION(pNmNode->HighestVersion));
                }
        }

        //dont allow a lower build on a node to regress the cluster version
        // if other nodes have already upgraded to higher builds
        if ((dwMinorVersion != 0) &&
            (CLUSTER_GET_MINOR_VERSION(dwNodeHighestVersion) < dwMinorVersion))
        {
            dwStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
            goto FnExit;
        }
        else
        {
            //ISSUE ::for now we allow double jumps(from n-1 to n+1)
            // on upgrades
            //skip  checking versioning
            goto FnExit;
        }
    }

    //if the joiners lowest version is equal the clusters highest
    //For instance 3/2, 2/1 and 4/3 can all join 3/2
    if ((dwNodeHighestVersion == ClusterHighestVersion) ||
        (dwNodeHighestVersion == ClusterLowestVersion) ||
        (dwNodeLowestVersion == ClusterHighestVersion))
    {

        PNM_NODE    pNmNode= NULL;
        DWORD       dwMinorVersion;

        //since the version numbers include build number as the minor part
        // and we disallow a node from operating with a cluster if its
        // major number is equal but its minor number is different from
        // any of the nodes in the cluster.
        // The CsClusterHighestVersion doesnt encapsulate this since it just
        // remembers the highest  version that the cluster as a whole can talk
        // to.
        // E.g 1.
        // 3.2003 should be able to join a cluster with nodes
        // 3.2002(not running and not upgraded as yet but a part of the cluster)and
        // 3.2003(running).
        // E.g 2
        //  3.2002 will not be able to join a cluster with nodes 3.2003(running)and
        // 3.2002 (not running  but a part of the cluster)
        // E.g 3.
        // 3.2003 will not able to join a cluster with nodes 3.2002(running) and
        // 3.2002(running)

        dwMinorVersion = 0x00000000;

        for (pListEntry = NmpNodeList.Flink; pListEntry != &NmpNodeList;
            pListEntry = pListEntry->Flink )
        {
                pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

                if (NmGetNodeId(pNmNode) == dwExcludeNodeId)
                    continue;

                if (CLUSTER_GET_MAJOR_VERSION(pNmNode->HighestVersion) ==
                     CLUSTER_GET_MAJOR_VERSION(dwNodeHighestVersion))
                {
                    //the minor version to check is the maximum of the
                    //build numbers amongst the nodes with the same major
                    //version
                    dwMinorVersion = max(dwMinorVersion,
                        CLUSTER_GET_MINOR_VERSION(pNmNode->HighestVersion));
                }
        }
        // if the joining node's build number is the same as max of build
        //number of all nodes within the cluster with the same major version
        //allow it to participate in this cluster, else dont allow it to participate in this cluster
        //take care of a single node case by checking the minor number against
        //0
        if ((dwMinorVersion != 0) &&
            (CLUSTER_GET_MINOR_VERSION(dwNodeHighestVersion) != dwMinorVersion))
        {
            dwStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
        }
    }
    else
    {
        dwStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
    }

FnExit:
    NmpReleaseLock();
    ClRtlLogPrint(LOG_UNUSUAL, 
        "[NM] NmpIsNodeVersionAllowed: Exit, Status=%1!u!\r\n",
        dwStatus);

    return(dwStatus);
}


/****
@func       HLOG | NmpCalcClusterVersion| This is called to calculate the
            operational cluster version.

@parm       IN DWORD | dwExcludeNodeId |  The node Id to exclude while evaluating
            the cluster operational version.

@parm       OUT LPDWORD | pdwClusterHighestVersion | The highest version with which this node
            can communicate.

@parm       IN LPDWORD | pdwClusterLowestVersion | The lowest version with which this node can
            communicate.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function must be called with the NmpLock held.

@xref       <f NmpResetClusterVersion> <f NmpIsNodeVersionAllowed>
****/
DWORD NmpCalcClusterVersion(
    IN  DWORD       dwExcludeNodeId,
    OUT LPDWORD     pdwClusterHighestVersion,
    OUT LPDWORD     pdwClusterLowestVersion
    )
{

    WCHAR       Buffer[4];
    PNM_NODE    pExcludeNode=NULL;
    PNM_NODE    pNmNode;
    DWORD       dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY pListEntry;
    DWORD       dwCnt = 0;

    //initialize the values such that min/max do the right thing
    *pdwClusterHighestVersion = 0xFFFFFFFF;
    *pdwClusterLowestVersion = 0x00000000;

    if (dwExcludeNodeId != ClusterInvalidNodeId)
    {
        wsprintfW(Buffer, L"%d", dwExcludeNodeId);
        pExcludeNode = OmReferenceObjectById(ObjectTypeNode, Buffer);
        if (!pExcludeNode)
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] NmpCalcClusterVersion :Node=%1!ws! to be excluded not found\r\n",
                Buffer);
            goto FnExit;
        }
    }

    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);
        if ((pExcludeNode) && (pExcludeNode->NodeId == pNmNode->NodeId))
            continue;

        //Actually to fix upgrade scenarios, we must fix the cluster
        //version such that the node with the highest minor version
        //is able to form/join but others arent
        // This is needed for multinode clusters
        if (CLUSTER_GET_MAJOR_VERSION(pNmNode->HighestVersion) ==
            CLUSTER_GET_MAJOR_VERSION(*pdwClusterHighestVersion))
        {
            if (CLUSTER_GET_MINOR_VERSION(pNmNode->HighestVersion) >
                CLUSTER_GET_MINOR_VERSION(*pdwClusterHighestVersion))
            {
                *pdwClusterHighestVersion = pNmNode->HighestVersion;
            }

        }
        else
        {
            *pdwClusterHighestVersion = min(
                                        *pdwClusterHighestVersion,
                                        pNmNode->HighestVersion
                                        );

        }
        *pdwClusterLowestVersion = max(
                                       *pdwClusterLowestVersion,
                                       pNmNode->LowestVersion
                                       );
        dwCnt++;

    }

    if (dwCnt == 0)
    {
        ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpCalcClusterVersion: Single node version. Setting cluster version to node version\r\n"
        );

        //single node cluster, even though the we were requested to
        //exclude this node, the cluster version must be calculated
        //using that node's version
        *pdwClusterHighestVersion = pExcludeNode->HighestVersion;
        *pdwClusterLowestVersion = pExcludeNode->LowestVersion;
    }
    CL_ASSERT(*pdwClusterHighestVersion != 0xFFFFFFFF);
    CL_ASSERT(*pdwClusterLowestVersion != 0x00000000);

FnExit:
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpCalcClusterVersion: status = %1!u! ClusHighestVer=0x%2!08lx!, ClusLowestVer=0x%3!08lx!\r\n",
        dwStatus, *pdwClusterHighestVersion, *pdwClusterLowestVersion);

    if (pExcludeNode) OmDereferenceObject(pExcludeNode);
    return(dwStatus);
}


VOID
NmpProcessClusterVersionChange(
    VOID
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD   status;
    LPWSTR  szClusterName=NULL;
    DWORD   dwSize=0;

    NmpMulticastProcessClusterVersionChange();

    //rjain: issue CLUSTER_EVENT_PROPERTY_CHANGE to propagate new
    //cluster version  info
    DmQuerySz( DmClusterParametersKey,
                    CLUSREG_NAME_CLUS_NAME,
                    &szClusterName,
                    &dwSize,
                    &dwSize);
    if(szClusterName)
        ClusterEventEx(
            CLUSTER_EVENT_PROPERTY_CHANGE,
            EP_FREE_CONTEXT,
            szClusterName
            );

    return;

} // NmpProcessClusterVersionChange


/****
@func       DWORD | NmpBuildVersionInfo| Its a callback function used by
            NmPerformFixups to build a property list of the Major Version,
            Minor version, Build Number and CSDVersionInfo, This propertylist
            is used by NmUpdatePerformFixups Update type to store this info
            in registry.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID*  | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@param      OUT LPWSTR* | pszKeyName. The name of registry key for which this
            property list is being constructed.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmpUpdatePerformFixups2>
****/


DWORD NmpBuildVersionInfo(
    IN  DWORD     dwFixUpType,
    OUT PVOID  *  ppPropertyList,
    OUT LPDWORD   pdwPropertyListSize,
    OUT LPWSTR *  pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    HDMKEY          hdmKey;
    DWORD           dwTemp;
    CLUSTERVERSIONINFO ClusterVersionInfo;
    LPWSTR          szTemp=NULL;

    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;

    //check we if need to send this information
    dwTemp=(lstrlenW(CLUSREG_KEYNAME_NODES) + lstrlenW(L"\\")+lstrlenW(NmLocalNodeIdString)+1)*sizeof(WCHAR);
    *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,dwTemp);
    if(*pszKeyName==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_NODES);
    lstrcatW(*pszKeyName,L"\\");
    lstrcatW(*pszKeyName,NmLocalNodeIdString);

    // Build the parameter list

    pInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,4*sizeof(DWORD)+sizeof(LPWSTR));
    if(pInParams==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }

    CsGetClusterVersionInfo(&ClusterVersionInfo);

    dwTemp=(DWORD)ClusterVersionInfo.MajorVersion;
    CopyMemory(pInParams,&dwTemp,sizeof(DWORD));

    dwTemp=(DWORD)ClusterVersionInfo.MinorVersion;
    CopyMemory(pInParams+sizeof(DWORD),&dwTemp,sizeof(DWORD));

    dwTemp=(DWORD)ClusterVersionInfo.BuildNumber;
    CopyMemory(pInParams+2*sizeof(DWORD),&dwTemp,sizeof(DWORD));

    if(ClusterVersionInfo.szCSDVersion==NULL)
        szTemp=NULL;
    else
    {
        szTemp=(LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,(lstrlenW(ClusterVersionInfo.szCSDVersion) +1)*sizeof(WCHAR));
        if (szTemp==NULL)
        {
            dwStatus=GetLastError();
            goto FnExit;
        }
        lstrcpyW(szTemp,ClusterVersionInfo.szCSDVersion);
        szTemp[lstrlenW(ClusterVersionInfo.szCSDVersion)]=L'\0';
    }
    CopyMemory(pInParams+3*sizeof(DWORD),&szTemp,sizeof(LPWSTR));

    //copy the suite information
    CopyMemory(pInParams+3*sizeof(DWORD)+sizeof(LPWSTR*),
            &CsMyProductSuite, sizeof(DWORD));

    Required=sizeof(DWORD);
AllocMem:
    *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList==NULL)
    {
        dwStatus=GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize=Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmFixupVersionInfo,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                         );
    *pdwPropertyListSize=Returned;
    if (dwStatus==ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,"[NM] NmBuildVersionInfo - error = %1!u!\r\n",dwStatus);
            goto FnExit;
        }

FnExit:
// Cleanup
    if (szTemp)
        LocalFree(szTemp);
    if(pInParams)
        LocalFree(pInParams);
    return dwStatus;
}//NmpBuildVersionInfo

/****
@func       HLOG | NmpCalcClusterNodeLimit|This is called to calculate the
            operational cluster node limit.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This acquires/releases NmpLock.

@xref       <f NmpResetClusterVersion> <f NmpIsNodeVersionAllowed>
****/
DWORD NmpCalcClusterNodeLimit(
    )
{
    PNM_NODE    pNmNode;
    DWORD       dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY pListEntry;

    //acquire the lock, we are going to be messing with the operational
    //versions for the cluster
    NmpAcquireLock();

    CsClusterNodeLimit = NmMaxNodeId;

    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

        CsClusterNodeLimit = min(
                                 CsClusterNodeLimit,
                                 ClRtlGetDefaultNodeLimit(
                                     pNmNode->ProductSuite
                                     )
                                );
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Calculated cluster node limit = %1!u!\r\n",
        CsClusterNodeLimit);

    NmpReleaseLock();

    return (dwStatus);
}


/****
@func       VOID| NmpResetClusterNodeLimit| An operational node limit
            on the number of nodes that can join this cluster is maintained.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function is called when a node forms a cluster(to initialize
            the operational version) OR when a node joins a cluster (to
            initialize its version) OR when a node is ejected from a
            cluster(to recalculate the clusterversion).

@xref       <>
****/
VOID
NmpResetClusterNodeLimit(
    )
{
    NmpCalcClusterNodeLimit();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\node.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    node.c

Abstract:

    Private Node Manager routines.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/

#define UNICODE 1

#include "nmp.h"


/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////
ULONG              NmMaxNodes = ClusterInvalidNodeId;
CL_NODE_ID         NmMaxNodeId = ClusterInvalidNodeId;
CL_NODE_ID         NmLocalNodeId = ClusterInvalidNodeId;
PNM_NODE           NmLocalNode = NULL;
WCHAR              NmLocalNodeIdString[CS_MAX_NODE_ID_LENGTH+1];
WCHAR              NmLocalNodeName[CS_MAX_NODE_NAME_LENGTH+1];
LIST_ENTRY         NmpNodeList = {NULL, NULL};
PNM_NODE *         NmpIdArray = NULL;
DWORD              NmpNodeCount = 0;
BOOL               NmpLastNodeEvicted = FALSE;
BOOL               NmLocalNodeVersionChanged = FALSE;
LIST_ENTRY *       NmpIntraClusterRpcArr=NULL;
CRITICAL_SECTION   NmpRPCLock;

#if DBG

DWORD              NmpRpcTimer=0;

#endif // DBG



///////////////////////////////////////////////////////////////////////////
//
// Initialization/Cleanup Routines
//
///////////////////////////////////////////////////////////////////////////
VOID
NmpCleanupNodes(
    VOID
    )
{
    PNM_NODE     node;
    PLIST_ENTRY  entry, nextEntry;
    DWORD        status;


    ClRtlLogPrint(LOG_NOISE,"[NM] Node cleanup starting...\n");

    NmpAcquireLock();

    while (!IsListEmpty(&NmpNodeList)) {
        entry = NmpNodeList.Flink;
        node = CONTAINING_RECORD(entry, NM_NODE, Linkage);

        if (node == NmLocalNode) {
            entry = node->Linkage.Flink;

            if (entry == &NmpNodeList) {
                break;
            }

            node = CONTAINING_RECORD(entry, NM_NODE, Linkage);
        }

        CL_ASSERT(NM_OM_INSERTED(node));
        CL_ASSERT(!NM_DELETE_PENDING(node));

        NmpDeleteNodeObject(node, FALSE);
    }

    NmpReleaseLock();


    ClRtlLogPrint(LOG_NOISE,"[NM] Node cleanup complete\n");

    return;

}  // NmpCleanupNodes


/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by joining nodes or on behalf of joining nodes.
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcEnumNodeDefinitions(
    IN  handle_t         IDL_handle,
    IN  DWORD            JoinSequence,   OPTIONAL
    IN  LPWSTR           JoinerNodeId,   OPTIONAL
    OUT PNM_NODE_ENUM *  NodeEnum1
    )
{
    DWORD     status = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;

    ClRtlLogPrint(LOG_UNUSUAL,
        "[NMJOIN] Refusing node info to joining node nodeid=%1!ws!. Aborting join, obsolete interface.\n",
        JoinerNodeId
        );

    return(status);

} // s_NmRpcEnumNodeDefinitions


error_status_t
s_NmRpcEnumNodeDefinitions2(
    IN  handle_t          IDL_handle,
    IN  DWORD             JoinSequence,   OPTIONAL
    IN  LPWSTR            JoinerNodeId,   OPTIONAL
    OUT PNM_NODE_ENUM2 *  NodeEnum
    )
{
    DWORD     status = ERROR_SUCCESS;
    PNM_NODE  joinerNode = NULL;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Supplying node information to joining node.\n"
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] EnumNodeDefinitions call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] EnumNodeDefinitions call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            status = NmpEnumNodeObjects(NodeEnum);

            if (joinerNode != NULL) {
                if (status == ERROR_SUCCESS) {
                    //
                    // Restart the join timer.
                    //
                    NmpJoinTimer = NM_JOIN_TIMEOUT;
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NMJOIN] EnumNodeDefinitions failed, status %1!u!.\n",
                        status
                        );

                    //
                    // Abort the join
                    //
                    NmpJoinAbort(status, joinerNode);
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process EnumNodeDefinitions request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcEnumNodeDefinitions2


error_status_t
s_NmRpcAddNode(
    IN handle_t IDL_handle,
    IN LPCWSTR  NewNodeName,
    IN DWORD    NewNodeHighestVersion,
    IN DWORD    NewNodeLowestVersion,
    IN DWORD    NewNodeProductSuite
    )
/*++

Routine Description:

    Adds a new node to the cluster by selecting an ID and
    issuing a global update.

Arguments:

    IDL_handle - RPC client interface handle.

    NewNodeName - A pointer to a string containing the name of the
                  new node.

    NewNodeHighestVersion - The highest cluster version number that the
                            new node can support.

    NewNodeLowestVersion - The lowest cluster version number that the
                            new node can support.

    NewNodeProductSuite - The product suite identifier for the new node.

Return Value:

    A Win32 status code.

Notes:

    Called with NmpLock held.

--*/
{
    DWORD  status;
    DWORD  registryNodeLimit;


    ClRtlLogPrint(LOG_UNUSUAL, 
        "[NMJOIN] Received forwarded request to add node '%1!ws!' to the "
        "cluster.\n",
        NewNodeName
        );
    //
    // Read the registry override before acquiring the NM lock.
    //
    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_MAX_NODES,
                 &registryNodeLimit,
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        registryNodeLimit = 0;
    }

    NmpAcquireLock();

    if (!NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] This node is not in a valid state to process a "
            "request to add node '%1!ws!' to the cluster.\n",
            NewNodeName
            );
        NmpReleaseLock();
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    if (NmpLeaderNodeId == NmLocalNodeId) {\
        //
        // Call the internal handler.
        //
        status = NmpAddNode(
                     NewNodeName,
                     NewNodeHighestVersion,
                     NewNodeLowestVersion,
                     NewNodeProductSuite,
                     registryNodeLimit
                     );
    }
    else {
        //
        // This node is not the leader.
        // Fail the request.
        //
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Cannot process request to add node '%1!ws!' to the "
            "cluster because this node is not the leader.\n",
            NewNodeName
            );
    }

    NmpLockedLeaveApi();

    NmpReleaseLock();

    return(status);

} // s_NmRpcAddNode


/////////////////////////////////////////////////////////////////////////////
//
// Routines called by other cluster service components
//
/////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////
//
// Rpc Extended error tracking.
//
/////////////////////////////////////////////////////////////////////////////

VOID NmDumpRpcExtErrorInfo(RPC_STATUS status)
{
        RPC_STATUS status2;
        RPC_ERROR_ENUM_HANDLE enumHandle;

        status2 = RpcErrorStartEnumeration(&enumHandle);

        if(status2 == RPC_S_ENTRY_NOT_FOUND) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] RpcExtErrorInfo: Error info not found.\n"
                );
        }
        else if(status2 != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] RpcExtErrorInfo: Couldn't get error info, status %1!u!\n",
                status2
                );
        }
        else {
            RPC_EXTENDED_ERROR_INFO errorInfo;
            int records;
            BOOL result;
            BOOL copyStrings=TRUE;
            BOOL fUseFileTime=TRUE;
            SYSTEMTIME *systemTimeToUse;
            SYSTEMTIME systemTimeBuffer;

            while(status2 == RPC_S_OK) {
                errorInfo.Version = RPC_EEINFO_VERSION;
                errorInfo.Flags = 0;
                errorInfo.NumberOfParameters = 4;

                if(fUseFileTime) {
                    errorInfo.Flags |= EEInfoUseFileTime;
                }

                status2 = RpcErrorGetNextRecord(&enumHandle, copyStrings, &errorInfo);
                
                if(status2 == RPC_S_ENTRY_NOT_FOUND) {
                    break;
                }
                else if(status2 != RPC_S_OK) {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NM] RpcExtErrorInfo: Couldn't complete enumeration, status %1!u!\n",
                        status2
                        );
                    break;
                }
                else {
                    int i;

                    if(errorInfo.ComputerName) {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] RpcExtErrorInfo: ComputerName= %1!ws!\n",
                            errorInfo.ComputerName
                            );
                    }
                    if(copyStrings) {
                        result = HeapFree(GetProcessHeap(), 0, errorInfo.ComputerName);
                        CL_ASSERT(result);
                    }
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] RpcExtErrorInfo: ProcessId= %1!u!\n",
                        errorInfo.ProcessID
                        );

                    if(fUseFileTime) {
                        result = FileTimeToSystemTime(&errorInfo.u.FileTime, &systemTimeBuffer);
                        CL_ASSERT(result);
                        systemTimeToUse = &systemTimeBuffer;
                    }
                    else {
                        systemTimeToUse = &errorInfo.u.SystemTime;
                    }

                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] RpcExtErrorInfo: SystemTime= %1!u!/%2!u!/%3!u! %4!u!:%5!u!:%6!u!:%7!u!\n",
                        systemTimeToUse->wMonth,
                        systemTimeToUse->wDay,
                        systemTimeToUse->wYear,
                        systemTimeToUse->wHour,
                        systemTimeToUse->wMinute,
                        systemTimeToUse->wSecond,
                        systemTimeToUse->wMilliseconds
                        );
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] RpcExtErrorInfo: GeneratingComponent= %1!u!\n",
                        errorInfo.GeneratingComponent
                        );
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] RpcExtErrorInfo: Status= 0x%1!x!\n",
                        errorInfo.Status
                        );
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] RpcExtErrorInfo: Detection Location= %1!u!\n",
                        (DWORD)errorInfo.DetectionLocation
                        );
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] RpcExtErrorInfo: Flags= 0x%1!x!\n",
                        errorInfo.Flags
                        );
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] RpcExtErrorInfo: Number of Parameters= %1!u!\n",
                        errorInfo.NumberOfParameters
                        );
                    for(i=0;i<errorInfo.NumberOfParameters;i++) {
                        switch(errorInfo.Parameters[i].ParameterType) {
                        case eeptAnsiString:
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] RpcExtErrorInfo: Ansi String= %1!s!\n",
                                errorInfo.Parameters[i].u.AnsiString
                                );
                            if(copyStrings) {
                                result = HeapFree(GetProcessHeap(), 0, errorInfo.Parameters[i].u.AnsiString);
                                CL_ASSERT(result);
                            }
                            break;
                        case eeptUnicodeString:
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] RpcExtErrorInfo: Unicode String= %1!S!\n",
                                errorInfo.Parameters[i].u.UnicodeString
                                );
                            if(copyStrings) {
                                result = HeapFree(GetProcessHeap(), 0, errorInfo.Parameters[i].u.UnicodeString);
                                CL_ASSERT(result);
                            }
                            break;
                        case eeptLongVal:
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] RpcExtErrorInfo: Long Val= %1!u!\n",
                                errorInfo.Parameters[i].u.LVal
                                );
                            break;
                        case eeptShortVal:
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] RpcExtErrorInfo: Short Val= %1!u!\n",
                                (DWORD)errorInfo.Parameters[i].u.SVal
                                );
                            break;
                        case eeptPointerVal:
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] RpcExtErrorInfo: Pointer Val= 0x%1!u!\n",
                                errorInfo.Parameters[i].u.PVal
                                );
                            break;
                        case eeptNone:
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] RpcExtErrorInfo: Truncated\n"
                                );
                            break;
                        default:
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] RpcExtErrorInfo: Invalid Type %1!u!\n",
                                errorInfo.Parameters[i].ParameterType
                                );
                        }
                    }
                }
            }
            RpcErrorEndEnumeration(&enumHandle);
        }
} //NmDumpRpcExtErrorInfo




///////////////////////////////////////////////////////////////////////////
//
// RPC Monitoring Routines
//
///////////////////////////////////////////////////////////////////////////


VOID 
NmStartRpc(
    DWORD NodeId
    )
/*++

Routine Description:

    Registers the fact that an RPC is about to be made to the specified 
    node by the current thread. This allows the call to be cancelled if 
    the target node dies.

Arguments:

    NodeId - The ID of the node about to be called.

Return Value:

    None

Notes:
    
    This routine must not be called by a thread that makes concurrent
    asynch RPC calls.
        
--*/
{
    HANDLE thHandle;
    PNM_INTRACLUSTER_RPC_THREAD entry;

    CL_ASSERT((NodeId >= ClusterMinNodeId) && (NodeId <= NmMaxNodeId));
    CL_ASSERT(NmpIntraClusterRpcArr != NULL);

    thHandle = OpenThread(
                    THREAD_ALL_ACCESS,
                    FALSE,
                    GetCurrentThreadId()
                    );

    if(thHandle == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] NmStartRpc: Failed to open handle to current thread.\n"
            );
        return;
    }
    
    entry = LocalAlloc(LMEM_FIXED, sizeof(NM_INTRACLUSTER_RPC_THREAD));
    if(entry == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] NmStartRpc: Failed to allocate memory.\n"
            );
        CloseHandle(thHandle);
        return;
    }

    entry->ThreadId = GetCurrentThreadId();
    entry->Thread = thHandle;
    entry->Cancelled = FALSE;


    NmpAcquireRPCLock();

#if DBG
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Starting RPC to node %1!u!\n",
        NodeId
        );
#endif

    InsertHeadList(&NmpIntraClusterRpcArr[NodeId], &entry->Linkage);

    NmpReleaseRPCLock();

    return;

} // NmStartRpc


VOID 
NmEndRpc(
    DWORD NodeId
    )
/*++

Routine Description:

    Cancels registration of an RPC to the specified node by the current 
    thread. 

Arguments:

    NodeId - The ID of the node that was called.

Return Value:

    None
    
Notes:

    This routine must be invoked even if the RPC was cancelled.

--*/
{
    DWORD threadId;
    LIST_ENTRY *pEntry;
    PNM_INTRACLUSTER_RPC_THREAD pRpcTh;

    CL_ASSERT((NodeId >= ClusterMinNodeId) && (NodeId <= NmMaxNodeId));
    CL_ASSERT(NmpIntraClusterRpcArr != NULL);

    threadId = GetCurrentThreadId();

    NmpAcquireRPCLock();
    pEntry = NmpIntraClusterRpcArr[NodeId].Flink;

    while(pEntry != &NmpIntraClusterRpcArr[NodeId]) {
        pRpcTh = CONTAINING_RECORD(pEntry, NM_INTRACLUSTER_RPC_THREAD, Linkage);
        if(pRpcTh->ThreadId == threadId) {
#if DBG
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Finished RPC to node %1!u!\n",
                NodeId
                );
#endif
            if (pRpcTh->Cancelled) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] RPC by this thread to node %1!u! is cancelled\n",
                    NodeId
                    );
            }
            
            RemoveEntryList(pEntry);
            CloseHandle(pRpcTh->Thread);
            LocalFree(pRpcTh);
            NmpReleaseRPCLock();
            return;
        }
        pEntry = pEntry->Flink;
    }

    ClRtlLogPrint(LOG_UNUSUAL, 
        "[NM] No record of RPC by this thread to node %1!u!.\n",
        NodeId
        );
#if DBG
    CL_ASSERT(pEntry != &NmpIntraClusterRpcArr[NodeId]); 
#endif 

    NmpReleaseRPCLock();
    return;

} // NmEndRpc






DWORD
NmPauseNode(
    IN PNM_NODE Node
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPCWSTR nodeId = OmObjectId(Node);
    DWORD status;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received request to pause node %1!ws!.\n",
        nodeId
        );

    if (NmpEnterApi(NmStateOnline)) {
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdatePauseNode,
                     1,
                     (lstrlenW(nodeId)+1)*sizeof(WCHAR),
                     nodeId
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Global update to pause node %1!ws! failed, status %2!u!\n",
                nodeId,
                status
                );
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process PauseNode request.\n"
            );
    }

    return(status);

}  // NmPauseNode


DWORD
NmResumeNode(
    IN PNM_NODE  Node
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPCWSTR nodeId = OmObjectId(Node);
    DWORD status;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received request to resume node %1!ws!.\n",
        nodeId
        );

    if (NmpEnterApi(NmStateOnline)) {
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateResumeNode,
                     1,
                     (lstrlenW(nodeId)+1)*sizeof(WCHAR),
                     nodeId
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Global update to resume node %1!ws! failed, status %2!u!\n",
                nodeId,
                status
                );
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process ResumeNode request.\n"
            );
    }

    return(status);

}  // NmResumeNode


DWORD
NmEvictNode(
    IN PNM_NODE Node
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   The caller must be holding a reference on the node object.

--*/
{
    LPCWSTR nodeId = OmObjectId(Node);
    DWORD   status = ERROR_SUCCESS;
    LPCWSTR pcszNodeName = NULL;

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received request to evict node %1!ws!.\n",
        nodeId
        );

    if (NmpEnterApi(NmStateOnline)) {

        // Acquire NM lock (to ensure that the number of nodes does not change)
        NmpAcquireLock();

        if (NmpNodeCount != 1 ) {
            
            NmpReleaseLock();
            
            // We are not evicting the last node.
            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateEvictNode,
                         1,
                         (lstrlenW(nodeId)+1)*sizeof(WCHAR),
                         nodeId
                         );

            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Global update to evict node %1!ws! failed, status %2!u!\n",
                    nodeId,
                    status
                    );
            }

            pcszNodeName = OmObjectName(Node);
        }
        else {
            // We are evicting the last node. Set a flag to indicate this fact.
            if ( NmpLastNodeEvicted == FALSE ) {
                NmpLastNodeEvicted = TRUE;
            }
            else {
                // We have already evicted this node. This is an error.
                status = ERROR_NODE_NOT_AVAILABLE;
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Not in valid state to process EvictNode request.\n"
                    );
            }

            NmpReleaseLock();
        }
       
        if (status == ERROR_SUCCESS) {
            HRESULT cleanupStatus;

            // The node was successfully evicted. Now initiate cleanup on that node.
            // However, specify that cleanup is to be started only after 60000 ms (1 minute).
            cleanupStatus = 
                ClRtlCleanupNode(
                    pcszNodeName,           // Name of the node to be cleaned up
                    60000,                  // Amount of time (in milliseconds) to wait before starting cleanup
                    0                       // timeout interval in milliseconds
                    );

            if ( FAILED( cleanupStatus ) && ( cleanupStatus != RPC_S_CALLPENDING ) ){
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to initiate cleanup of evicted node %1!ws!, status 0x%2!x!\n",
                    nodeId,
                    cleanupStatus
                    );
                status = cleanupStatus;
            }
            else {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Cleanup of evicted node %1!ws! successfully initiated.\n",
                    nodeId
                    );

                CsLogEvent1(LOG_UNUSUAL, NM_NODE_EVICTED, OmObjectName(Node));
            }
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process EvictNode request.\n"
            );
    }

    return(status);

}  // NmEvictNode



PNM_NODE
NmReferenceNodeById(
    IN DWORD NodeId
    )
/*++

Routine Description:

    Given a node id, returns a referenced pointer to the node object.
    The caller is responsible for calling OmDereferenceObject.

Arguments:

    NodeId - Supplies the node id

Return Value:

    A pointer to the node object if it exists

    NULL if there is no such node.

--*/

{
    PNM_NODE Node = NULL;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnlinePending)) {
        CL_ASSERT(NmIsValidNodeId(NodeId));
        CL_ASSERT(NmpIdArray != NULL);

        Node = NmpIdArray[NodeId];

        if (NmpIdArray[NodeId] != NULL) {
            OmReferenceObject(Node);
        }
        else {
            SetLastError(ERROR_CLUSTER_NODE_NOT_FOUND);
        }

        NmpLockedLeaveApi();
    }
    else {
        SetLastError(ERROR_NODE_NOT_AVAILABLE);
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process ReferenceNodeById request.\n"
            );
    }

    NmpReleaseLock();

    return(Node);

}  // NmReferenceNodeById



PNM_NODE
NmReferenceJoinerNode(
    IN DWORD       JoinSequence,
    IN CL_NODE_ID  JoinerNodeId
    )
/*++

Routine Description:

    Given a node id, returns a referenced pointer to the node object.
    The caller is responsible for calling OmDereferenceObject.
    Also validates the joiner's information

Arguments:

    NodeId - Supplies the node id

Return Value:

    A pointer to the node object if it exists

    NULL if there is no such node.

Notes:

    If the routine is successful, the caller must dereference the
    node object by calling NmDereferenceJoiningNode.

--*/

{
    PNM_NODE  joinerNode = NULL;
    DWORD     status;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {

        joinerNode = NmpIdArray[JoinerNodeId];

        if (joinerNode != NULL) {

            if ( (JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == JoinerNodeId)
               )
            {
                OmReferenceObject(joinerNode);

                NmpReleaseLock();

                //
                // Return holding an active thread reference.
                //
                return(joinerNode);
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
            }
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
    }

    NmpReleaseLock();

    if (status != ERROR_SUCCESS) {
        SetLastError(status);
    }

    return(joinerNode);

}  // NmReferenceJoinerNode


VOID
NmDereferenceJoinerNode(
    PNM_NODE  JoinerNode
    )
{

    OmDereferenceObject(JoinerNode);

    NmpLeaveApi();

    return;

} // NmDereferenceJoinerNode


CLUSTER_NODE_STATE
NmGetNodeState(
    IN PNM_NODE  Node
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/
{
    CLUSTER_NODE_STATE  state;


    NmpAcquireLock();

    state = Node->State;

    NmpReleaseLock();

    return(state);

}  // NmGetNodeState


CLUSTER_NODE_STATE
NmGetExtendedNodeState(
    IN PNM_NODE  Node
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/
{
    CLUSTER_NODE_STATE  state;


    NmpAcquireLock();

    state = Node->State;

    if(NM_NODE_UP(Node) ) {
        //
        // We need to check whether the node is really up
        //
        switch( Node->ExtendedState ) {

            case ClusterNodeUp:
                //
                // The node explicitly set its extended state to UP immediately after
                // ClusterJoin / ClusterForm was complete.
                // We need to return either Up or Paused, depending on the node state
                //
                state = Node->State;
                break;

            case ClusterNodeDown:
                //
                // The node explicitly set its extended state to DOWN in the beginning of
                // the shutdown process. We will report the node state as down.
                //
                // It is better to have ClusterNodeShuttindDown state for this situation.
                //
                //              state = ClusterNodeDown;
                // We do not want to return NodeDown, we really want NodeShuttingDown.
                //
                // Return UP or Paused
                //
                state = Node->State;
                break;

            default:
                //
                // Node is up from NM standpoint, but other components are not up yet.
                //
                state = ClusterNodeJoining;
        }
    }


    NmpReleaseLock();

    return(state);

}  // NmGetExtendedNodeState


DWORD NmpUpdateExtendedNodeState(
    IN BOOL SourceNode,
    IN LPWSTR NodeId,
    IN CLUSTER_NODE_STATE* ExtendedState
    )
{
    DWORD status = ERROR_SUCCESS;

    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to set extended state for node %1!ws! "
        "to %2!d!\n",
        NodeId,
        *ExtendedState
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE  node = OmReferenceObjectById(ObjectTypeNode, NodeId);

        if (node != NULL) {
            //
            // Extended State is valid only when the node is online.
            // Ignore the update otherwise.
            //
            if ( NM_NODE_UP(node) ) {
                CLUSTER_EVENT event;
                node->ExtendedState = *ExtendedState;

                if (*ExtendedState == ClusterNodeUp) {
                    event = CLUSTER_EVENT_API_NODE_UP;
                } else {
                    event = CLUSTER_EVENT_API_NODE_SHUTTINGDOWN;
                }

                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Issuing event %1!x!.\n",
                    event
                    );

                ClusterEvent(event, node);
            }

            OmDereferenceObject(node);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Node %1!ws! is not a cluster member. Rejecting request "
                "to set the node's extended state.\n",
                NodeId
                );
            status = ERROR_NODE_NOT_AVAILABLE;
        }

        NmpLockedLeaveApi();
    } else {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in a valid state to process request to set extended "
            "state for node %1!ws!\n",
            NodeId
            );
        status = ERROR_CLUSTER_NODE_NOT_READY;
    }

    NmpReleaseLock();

    return status;
} // NmpUpdateExtendedNodeState

DWORD
NmSetExtendedNodeState(
    IN CLUSTER_NODE_STATE State
    )
{
    DWORD Status;

    Status = GumSendUpdateEx(
                GumUpdateMembership,
                NmUpdateExtendedNodeState,
                2,
                sizeof(NmLocalNodeIdString),
                &NmLocalNodeIdString,
                sizeof(CLUSTER_NODE_STATE),
                &State
                );
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[INIT] NmUpdateExtendedNodeState node failed, status %1!d!.\n", Status);
    }

    return Status;
} // NmSetExtendedNodeState


DWORD
NmGetNodeId(
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Returns the given node's node ID.

Arguments:

    Node - Supplies a pointer to a node object.

Return Value:

    The node's node id.

Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/

{
    DWORD   nodeId;

    //
    // Since the caller has a reference on the object, and the node ID can't
    // be changed, it is safe to do this without taking a lock. It is also
    // necessary to prevent some deadlocks.
    //
    nodeId = Node->NodeId;

    return(nodeId);

}  // NmGetNodeId

DWORD
NmGetCurrentNumberOfNodes()
{
    DWORD       dwCnt = 0;
    PLIST_ENTRY pListEntry;

    NmpAcquireLock();

    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        dwCnt++;
    }

    NmpReleaseLock();
    return(dwCnt);

}


DWORD
NmGetMaxNodeId(
)
/*++

Routine Description:

    Returns the max node's node ID.

Arguments:

    Node - Supplies a pointer to a node object.

Return Value:

    The node's node id.

Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/

{

    return(NmMaxNodeId);

}  // NmGetMaxNodeId


VOID
NmpAdviseNodeFailure(
    IN PNM_NODE  Node,
    IN DWORD     ErrorCode
    )
/*++

Routine Description:

    Reports that a communication failure to the specified node has occurred.
    A poison packet will be sent to the failed node and regroup initiated.

Arguments:

    Node - Supplies a pointer to the node object for the failed node.

    ErrorCode - Supplies the error code that was returned from RPC

Return Value:

    None

Notes:

    Called with NM lock held.

--*/
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received advice that node %1!u! has failed with "
        "error %2!u!.\n",
        Node->NodeId,
        ErrorCode
        );

    if (Node->State != ClusterNodeDown) {
        LPCWSTR    nodeName = OmObjectName(Node);
        DWORD      status;

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Banishing node %1!u! from active cluster membership.\n",
            Node->NodeId
            );

        OmReferenceObject(Node);

        NmpReleaseLock();

        status = MMEject(Node->NodeId);

        if (status == MM_OK) {
            CsLogEvent1(
                LOG_UNUSUAL,
                NM_EVENT_NODE_BANISHED,
                nodeName
                );
        }

        OmDereferenceObject(Node);

        NmpAcquireLock();
    }

    return;

}  // NmpAdviseNodeFailure


VOID
NmAdviseNodeFailure(
    IN DWORD NodeId,
    IN DWORD ErrorCode
    )
/*++

Routine Description:

    Reports that a communication failure to the specified node has occurred.
    A poison packet will be sent to the failed node and regroup initiated.

Arguments:

    NodeId - Supplies the node id of the failed node.

    ErrorCode - Supplies the error code that was returned from RPC

Return Value:

    None

--*/
{
    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received advice that node %1!u! has failed with error %2!u!.\n",
        NodeId,
        ErrorCode
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE   node;


        CL_ASSERT(NodeId != NmLocalNodeId);
        CL_ASSERT(NmpIdArray != NULL);

        node = NmpIdArray[NodeId];

        NmpAdviseNodeFailure(node, ErrorCode);

        NmpLockedLeaveApi();
    }
    else {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process AdviseNodeFailure request.\n"
            );
    }

    NmpReleaseLock();

    return;

}  // NmAdviseNodeFailure


DWORD
NmEnumNodeInterfaces(
    IN  PNM_NODE          Node,
    OUT LPDWORD           InterfaceCount,
    OUT PNM_INTERFACE *   InterfaceList[]
    )
/*++

Routine Description:

    Returns the list of interfaces associated with a specified node.

Arguments:

    Node - A pointer to the node object for which to enumerate interfaces.

    InterfaceCount - On output, contains the number of items in InterfaceList.

    InterfaceList - On output, points to an array of pointers to interface
                    objects. Each pointer in the array must be dereferenced
                    by the caller. The storage for the array must be
                    deallocated by the caller.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

--*/
{
    DWORD             status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        if (Node->InterfaceCount > 0) {
            PNM_INTERFACE *  interfaceList = LocalAlloc(
                                                 LMEM_FIXED,
                                                 sizeof(PNM_INTERFACE) *
                                                 Node->InterfaceCount
                                                 );

            if (interfaceList != NULL) {
                PNM_INTERFACE     netInterface;
                PLIST_ENTRY       entry;
                DWORD             i;

                for (entry = Node->InterfaceList.Flink, i=0;
                     entry != &(Node->InterfaceList);
                     entry = entry->Flink, i++
                    )
                {
                    netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NodeLinkage);

                    OmReferenceObject(netInterface);
                    interfaceList[i] = netInterface;
                }

                *InterfaceCount = Node->InterfaceCount;
                *InterfaceList = interfaceList;
            }
            else {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            *InterfaceCount = 0;
            *InterfaceList = NULL;
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process EnumNodeInterfaces request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // NmEnumNodeInterfaces


DWORD
NmGetNodeHighestVersion(
    IN PNM_NODE Node
    )
{
    return Node->HighestVersion;
}


/////////////////////////////////////////////////////////////////////////////
//
// Handlers for global updates
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpUpdateAddNode(
    IN BOOL       SourceNode,
    IN LPDWORD    NewNodeId,
    IN LPCWSTR    NewNodeName,
    IN LPDWORD    NewNodeHighestVersion,
    IN LPDWORD    NewNodeLowestVersion,
    IN LPDWORD    NewNodeProductSuite
    )
/*++

Routine Description:

     GUM update handler for adding a new node to a cluster.

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the ID of the node.

    NewNodeName - A pointer to a string containing the name of the
                  new node.

    NewNodeHighestVersion - A pointer to the highest cluster version number
                            that the new node can support.

    NewNodeLowestVersion - A pointer to the lowest cluster version number
                           that the new node can support.

    NewNodeProductSuite - A pointer to the product suite identifier for
                          the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

     This routine is used to add an NT5 (or later) node to an NT5 (or
     later) cluster. It will never be invoked in a mixed NT4/NT5
     cluster.

--*/
{
    PNM_NODE          node = NULL;
    NM_NODE_INFO2     nodeInfo;
    HDMKEY            nodeKey = NULL;
    DWORD             disposition;
    DWORD             status;
    DWORD             registryNodeLimit;
    HLOCALXSACTION    xaction = NULL;
    BOOLEAN           lockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] This node is not in a valid state to process a request "
            "to add node %1!ws! to the cluster.\n",
            NewNodeName
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Received an update to add node '%1!ws!' to "
        "the cluster with node ID %2!u!.\n",
        NewNodeName,
        *NewNodeId
        );

    if (*NewNodeId > NmMaxNodeId) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Failed to add node %1!ws! to the cluster because the "
            "specified node ID, '%2!u!' , is not valid.\n",
            NewNodeName,
            *NewNodeId
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Read the registry override before acquiring the NM lock.
    //
    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_MAX_NODES,
                 &registryNodeLimit,
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        registryNodeLimit = 0;
    }

    //
    // Begin a transaction - This must be done before acquiring the
    //                       NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to begin a transaction to add node %1!ws! "
            "to the cluster, status %2!u!.\n",
            NewNodeName,
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    //
    // Verify that we do not already have the maximum number of nodes
    // allowed in this cluster.
    //
    if (!NmpIsAddNodeAllowed(*NewNodeProductSuite, registryNodeLimit, NULL)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster. "
            "The cluster already contains the maximum number of nodes "
            "allowed by the product licenses of the current member nodes "
            "and the proposed new node. \n",
            NewNodeName
            );
        status = ERROR_LICENSE_QUOTA_EXCEEDED;
        goto error_exit;
    }

    //
    // Verify that the specified node ID is available.
    //
    if (NmpIdArray[*NewNodeId] != NULL) {
        status = ERROR_CLUSTER_NODE_EXISTS;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster because "
            "node ID '%2!u!' is already in use.\n",
            NewNodeName,
            *NewNodeId
            );

        goto error_exit;
    }

    //
    // Try to create a key for the node in the cluster registry.
    //
    wsprintfW(&(nodeInfo.NodeId[0]), L"%u", *NewNodeId);

    nodeKey = DmLocalCreateKey(
                  xaction,
                  DmNodesKey,
                  nodeInfo.NodeId,
                  0,
                  KEY_READ | KEY_WRITE,
                  NULL,
                  &disposition
                  );

    if (nodeKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Failed to create registry key for new "
            "node '%1!ws!' using node ID '%2!u!', status %3!u!\n",
            NewNodeName,
            *NewNodeId,
            status
            );
        goto error_exit;
    }

    if (disposition != REG_CREATED_NEW_KEY) {
        //
        // The key already exists. This must be
        // garbage leftover from a failed evict or oldstyle add.
        // We'll just overwrite the key.
        //
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] A partial definition exists for node ID '%1!u!'. "
            "A node addition or eviction operation may have failed.\n",
            *NewNodeId
            );
    }

    //
    // Add the rest of the node's parameters to the registry.
    //
    status = DmLocalSetValue(
                 xaction,
                 nodeKey,
                 CLUSREG_NAME_NODE_NAME,
                 REG_SZ,
                 (CONST BYTE *)NewNodeName,
                 NM_WCSLEN(NewNodeName)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Failed to set registry value '%1!ws!', status %2!u!. "
            "Cannot add node '%3!ws!' to the cluster.\n",
            CLUSREG_NAME_NODE_NAME,
            status,
            NewNodeName
            );
        goto error_exit;
    }

    status = DmLocalSetValue(
                 xaction,
                 nodeKey,
                 CLUSREG_NAME_NODE_HIGHEST_VERSION,
                 REG_DWORD,
                 (CONST BYTE *)NewNodeHighestVersion,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Failed to set registry value '%1!ws!', status %2!u!. "
            "Cannot add node '%3!ws!' to the cluster.\n",
            CLUSREG_NAME_NODE_HIGHEST_VERSION,
            status,
            NewNodeName
            );
        goto error_exit;
    }

    status = DmLocalSetValue(
                 xaction,
                 nodeKey,
                 CLUSREG_NAME_NODE_LOWEST_VERSION,
                 REG_DWORD,
                 (CONST BYTE *)NewNodeLowestVersion,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Failed to set registry value %1!ws!, status %2!u!. "
            "Cannot add node '%3!ws!' to the cluster.\n",
            CLUSREG_NAME_NODE_LOWEST_VERSION,
            status,
            NewNodeName
            );
        goto error_exit;
    }

    status = DmLocalSetValue(
                 xaction,
                 nodeKey,
                 CLUSREG_NAME_NODE_PRODUCT_SUITE,
                 REG_DWORD,
                 (CONST BYTE *)NewNodeProductSuite,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Failed to set registry value %1!ws!, status %2!u!. "
            "Cannot add node '%3!ws!' to the cluster.\n",
            CLUSREG_NAME_NODE_PRODUCT_SUITE,
            status,
            NewNodeName
            );
        goto error_exit;
    }

    DmCloseKey(nodeKey); nodeKey = NULL;

    status = NmpGetNodeDefinition(&nodeInfo);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Failed to read definition for node %1!ws! from the "
            "cluster database, status %2!u!.\n",
            NewNodeName,
            status
            );
        goto error_exit;
    }

    //
    // If a node happens to be joining right now, flag the fact that
    // it is now out of synch with the cluster config.
    //
    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Joiner (ID %1!u!) is now out of sync due to add of "
            "node %2!ws!.\n",
            NmpJoinerNodeId,
            NewNodeName
            );
        NmpJoinerOutOfSynch = TRUE;
    }

    //
    // Create the node object
    //
    NmpReleaseLock();

    node = NmpCreateNodeObject(&nodeInfo);

    ClNetFreeNodeInfo(&nodeInfo);

    NmpAcquireLock();

    if (node == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Failed to create object for node %1!ws!, "
            "status %2!u!.\n",
            NewNodeName,
            status
            );
        goto error_exit;
    }

    ClusterEvent(CLUSTER_EVENT_NODE_ADDED, node);
    CsLogEvent1(LOG_NOISE, NM_EVENT_NEW_NODE, NewNodeName);

    //
    // Remove the reference that NmpCreateNodeObject left on the node.
    //
    OmDereferenceObject(node);

    //
    // Reset the cluster version and node limit
    //
    NmpResetClusterVersion(FALSE);
    NmpResetClusterNodeLimit();

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Successfully added node %1!ws! to the cluster.\n",
        NewNodeName
        );

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction); xaction = NULL;
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (nodeKey != NULL) {
        DmCloseKey(nodeKey);
    }

    return(status);

} // NmpUpdateAddNode



DWORD
NmpUpdateCreateNode(
    IN BOOL SourceNode,
    IN LPDWORD NodeId
    )
/*++

Routine Description:

    GUM update handler for dynamically creating a new node

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the ID of the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This handler was used by NT4 nodes. Since it is not possible to add
    an NT4 node to a cluster containing an NT5 node, this handler should
    never be called in an NT5 system.

--*/

{
    CL_ASSERT(FALSE);

    return(ERROR_CLUSTER_INCOMPATIBLE_VERSIONS);

}  // NmpUpdateCreateNode



DWORD
NmpUpdatePauseNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeId
    )
/*++

Routine Description:

    GUM update handler for pausing a node

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the name of the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    HLOCALXSACTION  xaction = NULL;
    PNM_NODE        node = NULL;
    BOOLEAN         lockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process PauseNode update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to pause node %1!ws!\n",
        NodeId
        );

    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    node = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (node == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Node %1!ws! does not exist\n",
            NodeId
            );
        goto error_exit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    if (node->NodeId == NmpJoinerNodeId) {
        status = ERROR_CLUSTER_NODE_DOWN;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Cannot pause node %1!ws! because it is in the process "
            "of joining the cluster.\n",
            NodeId
            );
        goto error_exit;
    }

    if (node->State == ClusterNodeUp) {
        //
        // Update the registry to reflect the new state.
        //
        HDMKEY nodeKey = DmOpenKey(DmNodesKey, NodeId, KEY_WRITE);

        if (nodeKey != NULL) {
            DWORD  isPaused = 1;

            status = DmLocalSetValue(
                         xaction,
                         nodeKey,
                         CLUSREG_NAME_NODE_PAUSED,
                         REG_DWORD,
                         (CONST BYTE *)&isPaused,
                         sizeof(isPaused)
                         );

#ifdef CLUSTER_TESTPOINT
            TESTPT(TpFailNmPauseNode) {
                status = 999999;
            }
#endif

            if (status == ERROR_SUCCESS) {
                node->State = ClusterNodePaused;
                ClusterEvent(CLUSTER_EVENT_NODE_CHANGE, node);

                //
                // If a node happens to be joining right now, flag the
                // fact that it is now out of synch with the cluster config.
                //
                if (NmpJoinerNodeId != ClusterInvalidNodeId) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NMJOIN] Joiner (ID %1!u!) is now out of sync due "
                        "to pause operation on node %2!ws!.\n",
                        NmpJoinerNodeId,
                        NodeId
                        );
                    NmpJoinerOutOfSynch = TRUE;
                }
            }
            else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to set Paused value for node %1!ws!, "
                    "status %2!u!.\n",
                    NodeId,
                    status
                    );
            }

            DmCloseKey(nodeKey);
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to open key for node %1!ws!, status %2!u!.\n",
                NodeId,
                status
                );
        }
    }
    else if (node->State != ClusterNodePaused) {
        status = ERROR_CLUSTER_NODE_DOWN;
    }

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (node != NULL) {
        OmDereferenceObject(node);
    }

    return(status);

}  // NmpUpdatePauseNode



DWORD
NmpUpdateResumeNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeId
    )
/*++

Routine Description:

    GUM update handler for resuming a node

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the name of the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    HLOCALXSACTION  xaction = NULL;
    PNM_NODE        node = NULL;
    BOOLEAN         lockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process ResumeNode update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to resume node %1!ws!\n",
        NodeId
        );

    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    node = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (node == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Node %1!ws! does not exist\n",
            NodeId
            );
        goto error_exit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    if (node->NodeId == NmpJoinerNodeId) {
        status = ERROR_CLUSTER_NODE_DOWN;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Cannot resume node %1!ws! because it is in the process "
            "of joining the cluster.\n",
            NodeId
            );
        goto error_exit;
    }

    if (node->State == ClusterNodePaused) {
        //
        // Update the registry to reflect the new state.
        //
        HDMKEY nodeKey = DmOpenKey(DmNodesKey, NodeId, KEY_WRITE);

        if (nodeKey != NULL) {
            status = DmLocalDeleteValue(
                         xaction,
                         nodeKey,
                         CLUSREG_NAME_NODE_PAUSED
                         );

#ifdef CLUSTER_TESTPOINT
            TESTPT(TpFailNmResumeNode) {
                status = 999999;
            }
#endif

            if (status == ERROR_SUCCESS) {
                node->State = ClusterNodeUp;
                ClusterEvent(CLUSTER_EVENT_NODE_CHANGE, node);

                //
                // If a node happens to be joining right now, flag the
                // fact that it is now out of synch with the cluster config.
                //
                if (NmpJoinerNodeId != ClusterInvalidNodeId) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NMJOIN] Joiner (ID %1!u!) is now out of sync due "
                        "to resume operation on node %2!ws!.\n",
                        NmpJoinerNodeId,
                        NodeId
                        );
                    NmpJoinerOutOfSynch = TRUE;
                }
            }
            else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to delete Paused value for node %1!ws!, "
                    "status %2!u!.\n",
                    NodeId,
                    status
                    );
            }

            DmCloseKey(nodeKey);
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to open key for node %1!ws!, status %2!u!.\n",
                NodeId,
                status
                );
        }
    }
    else {
        status = ERROR_CLUSTER_NODE_NOT_PAUSED;
    }

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (node != NULL) {
        OmDereferenceObject(node);
    }

    return(status);

}  // NmpUpdateResumeNode



DWORD
NmpUpdateEvictNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeId
    )
/*++

Routine Description:

    GUM update handler for evicting a node.

    The specified node is deleted from the OM.

    If the specified node is online, it is paused to prevent any other groups
    from moving there.

    If the specified node is the current node, it attempts to failover any
    owned groups.

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the name of the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    It is very hard to make this operation abortable, so it isn't. If anything
    goes wrong past a certain point, the node will halt.

    Assumption: Since global updates are serialized, and local transactions
    guarantee exclusive access to the registry, no other updates can be made in
    parallel by the FM.

--*/

{
    DWORD            status = ERROR_SUCCESS;
    PNM_NODE         node = NULL;
    HLOCALXSACTION   xaction = NULL;
    PNM_NETWORK      network;
    LPCWSTR          networkId;
    PNM_INTERFACE    netInterface;
    LPCWSTR          interfaceId;
    PLIST_ENTRY      entry;
    BOOLEAN          lockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process EvictNode update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to evict node %1!ws!\n",
        NodeId
        );

    node = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (node == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Node %1!ws! does not exist\n",
            NodeId
            );
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        goto error_exit;
    }

    //
    // Begin a transaction
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Cannot evict node because a join is in progress.\n"
            );
        goto error_exit;
    }

    //
    // Only continue if the node is down. Evicting a node while it
    // is actively participating in the cluster is way too tricky.
    //
    if (node->State != ClusterNodeDown) {
        status = ERROR_CANT_EVICT_ACTIVE_NODE;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Node %1!ws! cannot be evicted because it is not offline.\n",
            NodeId
            );
        goto error_exit;
    }

    //
    // Scrub the FM's portion of the registry of all references to this node.
    //
    status = NmpCleanseRegistry(NodeId, xaction);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to remove all resource database references to "
            "evicted node %1!ws!, status %2!u!\n",
            NodeId,
            status
            );
        goto error_exit;
    }

    //
    // Delete the node's interfaces from the database.
    //
    for (entry = node->InterfaceList.Flink;
         entry != &(node->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NodeLinkage
                           );

        interfaceId = OmObjectId(netInterface);
        network = netInterface->Network;
        networkId = OmObjectId(network);

        //
        // Delete the interface definition from the database.
        //
        status = DmLocalDeleteTree(xaction, DmNetInterfacesKey, interfaceId);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to delete definition for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        if (network->InterfaceCount == 1) {
            //
            // This is the last interface on the network.
            // Delete the network too.
            //
            status = DmLocalDeleteTree(xaction, DmNetworksKey, networkId);

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Failed to delete definition for network %1!ws!, "
                    "status %2!u!.\n",
                    networkId,
                    status
                    );
                goto error_exit;
            }
        }
    }

    //
    // Delete the node's database entry
    //
    status = DmLocalDeleteTree(xaction, DmNodesKey, NodeId);

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmEvictNodeAbort) {
        status = 999999;
    }
#endif

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to delete node's database key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // WARNING: From here on, operations cannot be reversed.
    // If any one of them fails, this node must halt to avoid being
    // inconsistent.
    //

    //
    // Delete the interface objects associated with this node.
    //
    while (!IsListEmpty(&(node->InterfaceList))) {
        entry = node->InterfaceList.Flink;

        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NodeLinkage
                           );

        network = netInterface->Network;
        networkId = OmObjectId(network);

        NmpDeleteInterfaceObject(netInterface, TRUE);

        if (network->InterfaceCount == 0) {
            //
            // This is the last interface on the network.
            // Delete the network too.
            //
            NmpDeleteNetworkObject(network, TRUE);
        }
    }

    //
    // Delete the node's object.
    //
    NmpDeleteNodeObject(node, TRUE);

    //after the node is deleted, recalculate the operational version of
    //the cluster
    NmpResetClusterVersion(TRUE);

    //calculate the operational limit on the number of nodes that
    //can be a part of this cluster
    NmpResetClusterNodeLimit();

    NmpReleaseLock(); lockAcquired = FALSE;

    //
    // Call the FM so it can clean up any outstanding references to this
    // node from its structures.
    //
    status = FmEvictNode(node);

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmEvictNodeHalt) {
        status = 999999;
    }
#endif

    if (status != ERROR_SUCCESS ) {
        WCHAR  string[16];

        wsprintfW(&(string[0]), L"%u", status);

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] FATAL ERROR: Failed to remove all resource references to evicted node %1!ws!, status %2!u!\n",
            NodeId,
            status
            );

        CsLogEvent3(
            LOG_CRITICAL,
            NM_EVENT_EVICTION_ERROR,
            NmLocalNodeName,
            OmObjectName(node),
            string
            );

        CsInconsistencyHalt(status);
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (node != NULL) {
        OmDereferenceObject(node);
    }

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to evict node %1!ws!.\n",
            NodeId
            );
    }

    return(status);

}  // NmpUpdateEvictNode


/////////////////////////////////////////////////////////////////////////////
//
// Database management routines
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpGetNodeDefinition(
    IN OUT PNM_NODE_INFO2   NodeInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster node from the cluster database
    and stores the information in a supplied structure.

Arguments:

    NodeInfo  - A pointer to the structure into which to store the node
                information. The NodeId field of the structure contains
                the ID of the node for which to read information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD           status;
    HDMKEY          nodeKey = NULL;
    DWORD           valueLength;
    DWORD           valueType;
    LPWSTR          string;
    WCHAR           errorString[12];


    nodeKey = DmOpenKey(DmNodesKey, NodeInfo->NodeId, KEY_READ);

    if (nodeKey == NULL) {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_OPEN_FAILED,
            NodeInfo->NodeId,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open node key, status %1!u!\n",
            status
            );
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto error_exit;
    }

    valueLength = sizeof(NodeInfo->NodeName);
    string = CLUSREG_NAME_NODE_NAME;

    status = DmQueryValue(
                 nodeKey,
                 string,
                 &valueType,
                 (LPBYTE) &(NodeInfo->NodeName[0]),
                 &valueLength
                 );

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to read node name, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    if (valueType != REG_SZ) {
        status = ERROR_INVALID_PARAMETER;
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        goto error_exit;
    }

    //read the node's highest version
    string = CLUSREG_NAME_NODE_HIGHEST_VERSION;
    status = DmQueryDword(nodeKey, string, &NodeInfo->NodeHighestVersion,
                NULL);
    if (status != ERROR_SUCCESS)
    {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        //this can happen on an upgrade from sp3 to nt5
        //assume the node highest version is that of sp3
        //the fixup function will get this fixed
        NodeInfo->NodeHighestVersion = CLUSTER_MAKE_VERSION(1, 224);
    }

    //read the node's lowest version
    string = CLUSREG_NAME_NODE_LOWEST_VERSION;
    status = DmQueryDword(nodeKey, string, &NodeInfo->NodeLowestVersion,
                NULL);
    if (status != ERROR_SUCCESS)
    {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        //this can happen on upgrade from sp3 to nt5
        //if the nodelowestversion is not present assume it
        //was an sp3 node(lowest version is 1.224)
        NodeInfo->NodeLowestVersion = CLUSTER_MAKE_VERSION( 1, 224);
    }


    NodeInfo->State = ClusterNodeDown;

    DmCloseKey(nodeKey);

    return(ERROR_SUCCESS);


error_exit:

    ClNetFreeNodeInfo(NodeInfo);

    if (nodeKey != NULL) {
        DmCloseKey(nodeKey);
    }

    return(status);

}  // NmpGetNodeDefinition


DWORD
NmpGetNodeAuxInfo(
    IN LPCWSTR NodeId,
    IN OUT PNM_NODE_AUX_INFO   pNodeAuxInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster node from the cluster database
    and stores the information in a supplied structure.

Arguments:

    pNodeAuxInfo  - A pointer to the structure into which to store the node
                information. The NodeId field of the structure contains
                the ID of the node for which to read information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD           status;
    HDMKEY          nodeKey = NULL;
    DWORD           valueLength;
    DWORD           valueType;
    LPWSTR          string;
    WCHAR           errorString[12];


    nodeKey = DmOpenKey(DmNodesKey, NodeId, KEY_READ);

    if (nodeKey == NULL)
    {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_OPEN_FAILED,
            NodeId,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] NmpGetNodeAuxInfo : Failed to open node key, "
             "status %1!u!\n",
             status);
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto error_exit;
    }


    //read the node's product suite
    string = CLUSREG_NAME_NODE_PRODUCT_SUITE;
    status = DmQueryDword(
                 nodeKey,
                 string,
                 (LPDWORD)&(pNodeAuxInfo->ProductSuite),
                NULL
                );
    if (status != ERROR_SUCCESS)
    {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_NOISE,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        //assume it is enterprise
        pNodeAuxInfo->ProductSuite = Enterprise;

    }


    DmCloseKey(nodeKey);

    return(ERROR_SUCCESS);


error_exit:
    if (nodeKey != NULL)
    {
        DmCloseKey(nodeKey);
    }

    return(status);

}  // NmpGetNodeAuxInfo



DWORD
NmpEnumNodeDefinitions(
    PNM_NODE_ENUM2 *  NodeEnum
    )
/*++

Routine Description:

    Reads information about all defined cluster nodes from the cluster
    database and builds an enumeration structure containing the information.

Arguments:

    NodeEnum -  A pointer to the variable into which to place a pointer to
                the allocated node enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    This routine MUST NOT be called with the NM lock held.

--*/

{
    DWORD            status;
    PNM_NODE_ENUM2   nodeEnum = NULL;
    WCHAR            nodeId[CS_MAX_NODE_ID_LENGTH];
    DWORD            i;
    DWORD            valueLength;
    DWORD            numNodes;
    DWORD            ignored;
    FILETIME         fileTime;
    WCHAR            errorString[12];
    HLOCALXSACTION   xaction;
    BOOLEAN          commitXaction = FALSE;


    *NodeEnum = NULL;

    //
    // Begin a transaction - this must not be done while holding
    //                       the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to begin a transaction, status %1!u!.\n",
            status
            );
    }

    NmpAcquireLock();

    //
    // First count the number of nodes.
    //
    status = DmQueryInfoKey(
                 DmNodesKey,
                 &numNodes,
                 &ignored,   // MaxSubKeyLen
                 &ignored,   // Values
                 &ignored,   // MaxValueNameLen
                 &ignored,   // MaxValueLen
                 &ignored,   // lpcbSecurityDescriptor
                 &fileTime
                 );

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_REG_OPERATION_FAILED, errorString);
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to query Nodes key information, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    valueLength = sizeof(NM_NODE_ENUM2) +
                  (sizeof(NM_NODE_INFO2) * (numNodes - 1));

    nodeEnum = MIDL_user_allocate(valueLength);

    if (nodeEnum == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory.\n");
        goto error_exit;
   }

    ZeroMemory(nodeEnum, valueLength);

    for (i=0; i < numNodes; i++) {
        valueLength = sizeof(nodeEnum->NodeList[nodeEnum->NodeCount].NodeId);

        status = DmEnumKey(
                     DmNodesKey,
                     i,
                     &(nodeEnum->NodeList[nodeEnum->NodeCount].NodeId[0]),
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent1(
                LOG_CRITICAL,
                CS_EVENT_REG_OPERATION_FAILED,
                errorString
                );
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to enumerate node key, status %1!u!\n",
                status
                );
            goto error_exit;
        }

        status = NmpGetNodeDefinition(
                     &(nodeEnum->NodeList[nodeEnum->NodeCount])
                     );

        if (status != ERROR_SUCCESS) {
            if (status == ERROR_FILE_NOT_FOUND) {
                //
                // Partial node definition in the database.
                // Probably from a failed AddNode operation.
                //
                LPWSTR nodeIdString =
                           nodeEnum->NodeList[nodeEnum->NodeCount].NodeId;
                DWORD  nodeId = wcstoul(
                                    nodeIdString,
                                    NULL,
                                    10
                                    );

                //
                // Delete the key and ignore it in the enum struct if it
                // is safe to do so.
                //
                if ( (NmpIdArray[nodeId] == NULL) &&
                     (nodeId != NmLocalNodeId)
                   )
                {
                    if (xaction != NULL) {
                        DWORD status2;

                        ClRtlLogPrint(LOG_CRITICAL, 
                            "[NM] Deleting partial definition for node "
                            "ID %1!ws!\n",
                            nodeIdString
                            );

                        status2 = DmLocalDeleteKey(
                                      xaction,
                                      DmNodesKey,
                                      nodeIdString
                                      );


                        if (status2 == ERROR_SUCCESS) {
                            commitXaction = TRUE;
                        }
                    }
                }

                continue;
            }

            goto error_exit;
        }

        nodeEnum->NodeCount++;
    }

    *NodeEnum = nodeEnum;

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    NmpReleaseLock();

    if (xaction != NULL) {
        if ((status == ERROR_SUCCESS) && commitXaction) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if ((status != ERROR_SUCCESS) && (nodeEnum != NULL)) {
        ClNetFreeNodeEnum(nodeEnum);
    }

    return(status);

}  // NmpEnumNodeDefinitions


/////////////////////////////////////////////////////////////////////////////
//
// Object management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateNodeObjects(
    IN PNM_NODE_ENUM2  NodeEnum
    )
/*++

Routine Description:

    Processes a node information enumeration and creates node objects.

Arguments:

    NodeEnum - A pointer to a node information enumeration structure.

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

--*/
{
    DWORD          status = ERROR_SUCCESS;
    PNM_NODE_INFO2 nodeInfo;
    DWORD          i;
    PNM_NODE       node;
    BOOLEAN        foundLocalNode = FALSE;


    for (i=0; i < NodeEnum->NodeCount; i++) {
        nodeInfo = &(NodeEnum->NodeList[i]);

        //
        // The local node object was created during initialization.
        // Skip it.
        //
        if (wcscmp(NmLocalNodeIdString, nodeInfo->NodeId) != 0) {
            node = NmpCreateNodeObject(nodeInfo);

            if (node == NULL) {
                status = GetLastError();
                break;
            }
            else {
                OmDereferenceObject(node);
            }
        }
        else {
            foundLocalNode = TRUE;
        }
    }

    if ( !foundLocalNode ) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
    }

    return(status);

}  // NmpCreateNodeObjects


DWORD
NmpCreateLocalNodeObject(
    IN PNM_NODE_INFO2  NodeInfo
    )
/*++

Routine Description:

    Creates a node object for the local node given information about the node.

Arguments:

    NodeInfo - A pointer to a structure containing a description of the node
               to create.

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

--*/
{
    DWORD       status;
    LPWSTR      string;

    CL_ASSERT(NmLocalNode == NULL);

    //
    // Verify that the node name matches the local computername.
    //
    if (wcscmp(NodeInfo->NodeName, NmLocalNodeName) != 0) {
        string = L"";
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_NODE_NOT_MEMBER,
            NmLocalNodeName,
            string
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Computername does not match node name in database.\n"
            );
        return(ERROR_INVALID_PARAMETER);
    }

    NmLocalNode = NmpCreateNodeObject(NodeInfo);

    if (NmLocalNode == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create local node (%1!ws!), status %2!u!.\n",
            NodeInfo->NodeId,
            status
            );
        return(status);
    }
    else {
        NmLocalNode->ExtendedState = ClusterNodeJoining;
        OmDereferenceObject(NmLocalNode);
    }

    return(ERROR_SUCCESS);
}


PNM_NODE
NmpCreateNodeObject(
    IN PNM_NODE_INFO2  NodeInfo
    )
/*++

Routine Description:

    Creates a node object given information about the node.

Arguments:

    NodeInfo - A pointer to a structure containing a description of the node
               to create.

Return Value:

    A pointer to the created node object if successful.
    NULL if not successful. Extended error information is available
    from GetLastError().

--*/
{
    PNM_NODE    node = NULL;
    DWORD       status = ERROR_SUCCESS;
    BOOL        created = FALSE;
    DWORD       eventCode = 0;
    WCHAR       errorString[12];


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating object for node %1!ws! (%2!ws!)\n",
        NodeInfo->NodeId,
        NodeInfo->NodeName
        );

    //
    // Make sure that the node doesn't already exist.
    //
    node = OmReferenceObjectById(ObjectTypeNode, NodeInfo->NodeId);

    if (node == NULL) {
      //
      // Make sure that the node doesn't already exist, this time by name.
      //
      node = OmReferenceObjectByName(ObjectTypeNode, NodeInfo->NodeName);
    }

    if (node != NULL) {
        OmDereferenceObject(node);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Object already exists for node %1!ws!\n",
            NodeInfo->NodeId
            );
        SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
        return(NULL);
    }

    node = OmCreateObject(
               ObjectTypeNode,
               NodeInfo->NodeId,
               NodeInfo->NodeName,
               &created
               );

    if (node == NULL) {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create object for node %1!ws! (%2!ws!), status %3!u!\n",
            NodeInfo->NodeId,
            NodeInfo->NodeName,
            status
            );
        SetLastError(status);
        return(NULL);
    }

    CL_ASSERT(created == TRUE);

    ZeroMemory(node, sizeof(NM_NODE));

    node->NodeId = wcstoul(NodeInfo->NodeId, NULL, 10);
    node->State = NodeInfo->State;

    // A join cannot proceed if any of the current node's ExtendedState is not up. But the State might be paused.
    // So don't copy the State field into ExtendedState field. (#379170)
    node->ExtendedState = ClusterNodeUp; 

    
    node->HighestVersion = NodeInfo->NodeHighestVersion;
    node->LowestVersion = NodeInfo->NodeLowestVersion;

    //for now assume enterprise
    //NmpRefresh will fixup this information later..
    node->ProductSuite = Enterprise;

    InitializeListHead(&(node->InterfaceList));

    CL_ASSERT(NmIsValidNodeId(node->NodeId));

    if (node->NodeId != NmLocalNodeId) {
        status = ClusnetRegisterNode(NmClusnetHandle, node->NodeId);

        if (status != ERROR_SUCCESS) {
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent2(
                LOG_CRITICAL,
                NM_EVENT_CLUSNET_REGISTER_NODE_FAILED,
                NodeInfo->NodeId,
                errorString
                );

            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to register node %1!ws! (%2!ws!) with the Cluster Network, status %3!u!\n",
                NodeInfo->NodeId,
                NodeInfo->NodeName,
                status
                );
            goto error_exit;
        }
    }

    //
    // Put a reference on the object for the caller.
    //
    OmReferenceObject(node);

    NmpAcquireLock();

    if (NM_NODE_UP(node)) {
        //
        // Add this node to the up nodes set
        //
        BitsetAdd(NmpUpNodeSet, node->NodeId);

        //
        // Enable communication with this node during the
        // join process.
        //
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Enabling communication for node %1!ws!\n",
            NodeInfo->NodeId
            );
        status = ClusnetOnlineNodeComm(NmClusnetHandle, node->NodeId);

        if (status != ERROR_SUCCESS) {
            NmpReleaseLock();
            OmDereferenceObject(node);
            
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent2(
                LOG_CRITICAL,
                NM_EVENT_CLUSNET_ONLINE_COMM_FAILED,
                NodeInfo->NodeId,
                errorString
                );

            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to enable node %1!ws! (%2!ws!) for communication, status %3!u!\n",
                NodeInfo->NodeId,
                NodeInfo->NodeName,
                status
                );
            goto error_exit;
        }
    }

    CL_ASSERT(NmpIdArray != NULL);
    CL_ASSERT(NmpIdArray[node->NodeId] == NULL);
    NmpIdArray[node->NodeId] = node;
    InsertTailList(&NmpNodeList, &(node->Linkage));
    node->Flags |= NM_FLAG_OM_INSERTED;
    OmInsertObject(node);
    NmpNodeCount++;

    NmpReleaseLock();

    return(node);

error_exit:

    ClRtlLogPrint(LOG_CRITICAL, 
        "[NM] Failed to create object for node %1!ws!, status %2!u!.\n",
        NodeInfo->NodeId,
        status
        );

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    if (node != NULL) {
        NmpAcquireLock();
        NmpDeleteNodeObject(node, FALSE);
        NmpReleaseLock();
    }

    SetLastError(status);

    return(NULL);

}  // NmpCreateNodeObject



DWORD
NmpGetNodeObjectInfo(
    IN     PNM_NODE        Node,
    IN OUT PNM_NODE_INFO2  NodeInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster node from the its cluster
    object and stores the information in a supplied structure.

Arguments:

    Node - A pointer to the node object to query.

    NodeInfo  - A pointer to the structure into which to store the node
                information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD           status;

    lstrcpyW(&(NodeInfo->NodeId[0]), OmObjectId(Node));
    lstrcpyW(&(NodeInfo->NodeName[0]), OmObjectName(Node));
    NodeInfo->State = Node->State;
    NodeInfo->NodeHighestVersion = Node->HighestVersion;
    NodeInfo->NodeLowestVersion = Node->LowestVersion;

    return(ERROR_SUCCESS);

}  // NmpGetNodeObjectInfo


VOID
NmpDeleteNodeObject(
    IN PNM_NODE   Node,
    IN BOOLEAN    IssueEvent
    )
/*++

Notes:

    Called with NM lock held.

--*/
{
    DWORD           status;
    PNM_INTERFACE   netInterface;
    PLIST_ENTRY     entry;
    LPWSTR          nodeId = (LPWSTR) OmObjectId(Node);


    if (NM_DELETE_PENDING(Node)) {
        CL_ASSERT(!NM_OM_INSERTED(Node));
        return;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Deleting object for node %1!ws!.\n",
        nodeId
        );

    Node->Flags |= NM_FLAG_DELETE_PENDING;

    //
    // Remove from the various object lists.
    //
    if (NM_OM_INSERTED(Node)) {
        status = OmRemoveObject(Node);
        CL_ASSERT(status == ERROR_SUCCESS);
        Node->Flags &= ~NM_FLAG_OM_INSERTED;
        RemoveEntryList(&(Node->Linkage));
        NmpIdArray[Node->NodeId] = NULL;
        CL_ASSERT(NmpNodeCount > 0);
        NmpNodeCount--;
    }

    //
    // Delete all of the interfaces on this node
    //
    while (!IsListEmpty(&(Node->InterfaceList))) {
        entry = Node->InterfaceList.Flink;
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NodeLinkage);

        NmpDeleteInterfaceObject(netInterface, IssueEvent);
    }

    status = ClusnetDeregisterNode(NmClusnetHandle, Node->NodeId);

    CL_ASSERT( (status == ERROR_SUCCESS) ||
               (status == ERROR_NOT_READY) ||
               (status == ERROR_CLUSTER_NODE_NOT_FOUND)
             );

    if (IssueEvent) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Issuing delete event for node %1!ws!.\n",
            nodeId
            );

        ClusterEvent(CLUSTER_EVENT_NODE_DELETED, Node);
    }

    OmDereferenceObject(Node);

    return;

}  // NmpDeleteNodeObject


BOOL
NmpDestroyNodeObject(
    PNM_NODE  Node
    )
{
    DWORD  status;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] destroying node %1!ws!\n",
        OmObjectId(Node)
        );

    CL_ASSERT(NM_DELETE_PENDING(Node));
    CL_ASSERT(!NM_OM_INSERTED(Node));

    ClMsgDeleteDefaultRpcBinding(Node, Node->DefaultRpcBindingGeneration);
    ClMsgDeleteRpcBinding(Node->ReportRpcBinding);
    ClMsgDeleteRpcBinding(Node->IsolateRpcBinding);

    return(TRUE);

}  // NmpDestroyNodeObject


DWORD
NmpEnumNodeObjects(
    PNM_NODE_ENUM2 *  NodeEnum
    )
/*++

Routine Description:

    Reads information about all defined cluster nodes from the cluster
    object manager and builds an enumeration structure containing
    the information.

Arguments:

    NodeEnum -  A pointer to the variable into which to place a pointer to
                the allocated node enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    PNM_NODE_ENUM2  nodeEnum = NULL;
    DWORD           i;
    DWORD           valueLength;
    PLIST_ENTRY     entry;
    PNM_NODE        node;


    *NodeEnum = NULL;

    if (NmpNodeCount == 0) {
        valueLength = sizeof(NM_NODE_ENUM2);

    }
    else {
        valueLength = sizeof(NM_NODE_ENUM2) +
                      (sizeof(NM_NODE_INFO2) * (NmpNodeCount - 1));
    }

    nodeEnum = MIDL_user_allocate(valueLength);

    if (nodeEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(nodeEnum, valueLength);

    for (entry = NmpNodeList.Flink, i=0;
         entry != &NmpNodeList;
         entry = entry->Flink, i++
        )
    {
        node = CONTAINING_RECORD(entry, NM_NODE, Linkage);

        status = NmpGetNodeObjectInfo(
                     node,
                     &(nodeEnum->NodeList[i])
                     );

        if (status != ERROR_SUCCESS) {
            ClNetFreeNodeEnum(nodeEnum);
            return(status);
        }
    }

    nodeEnum->NodeCount = NmpNodeCount;
    *NodeEnum = nodeEnum;
    nodeEnum = NULL;

    return(ERROR_SUCCESS);


}  // NmpEnumNodeObjects


DWORD
NmpSetNodeInterfacePriority(
    IN  PNM_NODE Node,
    IN  DWORD Priority,
    IN  PNM_INTERFACE TargetInterface OPTIONAL,
    IN  DWORD TargetInterfacePriority OPTIONAL
    )
/*++

    Called with the NmpLock held.

--*/
{
    PNM_INTERFACE netInterface;
    PNM_NETWORK   network;
    DWORD         status = ERROR_SUCCESS;
    PLIST_ENTRY   entry;


    for (entry = Node->InterfaceList.Flink;
         entry != &Node->InterfaceList;
         entry = entry->Flink
         )
    {
        netInterface = CONTAINING_RECORD( entry, NM_INTERFACE, NodeLinkage );
        network = netInterface->Network;

        if ( NmpIsNetworkForInternalUse(network) &&
             NmpIsInterfaceRegistered(netInterface)
           )
        {
            if ( netInterface == TargetInterface ) {

                status = ClusnetSetInterfacePriority(
                             NmClusnetHandle,
                             netInterface->Node->NodeId,
                             netInterface->Network->ShortId,
                             TargetInterfacePriority
                             );
            } else {

                status = ClusnetSetInterfacePriority(
                             NmClusnetHandle,
                             netInterface->Node->NodeId,
                             netInterface->Network->ShortId,
                             Priority
                             );

            }
        }

        if ( status != ERROR_SUCCESS ) {
            break;
        }
    }

    return(status);

} // NmpSetNodeInterfacePriority


/////////////////////////////////////////////////////////////////////////////
//
// Node eviction utilities
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpCleanseRegistry(
    IN LPCWSTR          NodeId,
    IN HLOCALXSACTION   Xaction
    )
/*++

Routine Description:

    Removes all references to the specified node from the cluster
    registry.

Arguments:

    Node - Supplies the node that is being evicted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    NM_EVICTION_CONTEXT   context;


    context.NodeId = NodeId;
    context.Xaction = Xaction;
    context.Status = ERROR_SUCCESS;

    //
    // Remove this node from the possible owner list of
    // each resource type.
    //
    OmEnumObjects(
        ObjectTypeResType,
        NmpCleanseResTypeCallback,
        &context,
        NULL
        );

    if (context.Status == ERROR_SUCCESS) {
        //
        // Remove this node from the preferred owner list of
        // each group.
        //
        OmEnumObjects(
            ObjectTypeGroup,
            NmpCleanseGroupCallback,
            &context,
            NULL
            );
    }
    
    if (context.Status == ERROR_SUCCESS) {
        //
        // Remove this node from the possible owner list of
        // each resource.
        //
        OmEnumObjects(
            ObjectTypeResource,
            NmpCleanseResourceCallback,
            &context,
            NULL
            );
    }

    return(context.Status);

}  // NmpCleanseRegistry



BOOL
NmpCleanseGroupCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR GroupName
    )
/*++

Routine Description:

    Group enumeration callback for removing an evicted node from the
    group's preferred owners list.

Arguments:

    Context - Supplies the node ID of the evicted node and other context info.

    Context2 - Not used

    Group - Supplies the group.

    GroupName - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.

--*/

{
    HDMKEY  groupKey;
    DWORD   status;


    //
    // Open the group's key.
    //
    groupKey = DmOpenKey(DmGroupsKey, GroupName, KEY_READ | KEY_WRITE);

    if (groupKey != NULL) {
        status = DmLocalRemoveFromMultiSz(
                     Context->Xaction,
                     groupKey,
                     CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                     Context->NodeId
                     );

        if (status == ERROR_FILE_NOT_FOUND) {
            status = ERROR_SUCCESS;
        }

        DmCloseKey(groupKey);
    }
    else {
        status = GetLastError();
    }

    Context->Status = status;

    if (status != ERROR_SUCCESS) {
        return(FALSE);
    }
    else {
        return(TRUE);
    }

}  // NmpCleanseGroupCallback



BOOL
NmpCleanseResourceCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR ResourceName
    )
/*++

Routine Description:

    Group enumeration callback for removing an evicted node from the
    resource's possible owner's list.

    Also deletes any node-specific parameters from the resource's registry
    key.

Arguments:

    Context - Supplies the node ID of the evicted node and other context info.

    Context2 - Not used

    Resource - Supplies the resource.

    ResourceName - Supplies the resource's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.

--*/

{
    HDMKEY  resourceKey;
    HDMKEY  paramKey;
    HDMKEY  subKey;
    DWORD   status;


    //
    // Open the resource's key.
    //
    resourceKey = DmOpenKey(
                      DmResourcesKey,
                      ResourceName,
                      KEY_READ | KEY_WRITE
                      );

    if (resourceKey != NULL) {
        status = DmLocalRemoveFromMultiSz(
                     Context->Xaction,
                     resourceKey,
                     CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                     Context->NodeId
                     );

        if ((status == ERROR_SUCCESS) || (status == ERROR_FILE_NOT_FOUND)) {
            paramKey = DmOpenKey(
                           resourceKey,
                           CLUSREG_KEYNAME_PARAMETERS,
                           KEY_READ | KEY_WRITE
                           );

            if (paramKey != NULL) {

                status = DmLocalDeleteTree(
                             Context->Xaction,
                             paramKey,
                             Context->NodeId
                             );

                DmCloseKey(paramKey);
            }
            else {
                status = GetLastError();
            }
        }

        DmCloseKey(resourceKey);
    }
    else {
        status = GetLastError();
    }

    if (status == ERROR_FILE_NOT_FOUND) {
        status = ERROR_SUCCESS;
    }

    Context->Status = status;

    if (status != ERROR_SUCCESS) {
        return(FALSE);
    }
    else {
        return(TRUE);
    }

}  // NmpCleanseResourceCallback

BOOL
NmpCleanseResTypeCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_RESTYPE pResType,
    IN LPCWSTR pszResTypeName
    )
/*++

Routine Description:

    Group enumeration callback for removing an evicted node from the
    resource type's possible owner's list.

    Also deletes any node-specific parameters from the resource types's registry
    key.

Arguments:

    Context - Supplies the node ID of the evicted node and other context info.

    Context2 - Not used

    pResType - Supplies the resource type.

    pszResTypeeName - Supplies the resource type's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.

--*/

{
    HDMKEY  hResTypeKey;
    HDMKEY  paramKey;
    HDMKEY  subKey;
    DWORD   status;


    //
    // Open the resource's key.
    //
    hResTypeKey = DmOpenKey(
                      DmResourceTypesKey,
                      pszResTypeName,
                      KEY_READ | KEY_WRITE
                      );

    if (hResTypeKey != NULL) {
        status = DmLocalRemoveFromMultiSz(
                     Context->Xaction,
                     hResTypeKey,
                     CLUSREG_NAME_RESTYPE_POSSIBLE_NODES,
                     Context->NodeId
                     );

        if ((status == ERROR_SUCCESS) || (status == ERROR_FILE_NOT_FOUND)) {
            paramKey = DmOpenKey(
                           hResTypeKey,
                           CLUSREG_KEYNAME_PARAMETERS,
                           KEY_READ | KEY_WRITE
                           );

            if (paramKey != NULL) {

                status = DmLocalDeleteTree(
                             Context->Xaction,
                             paramKey,
                             Context->NodeId
                             );

                DmCloseKey(paramKey);
            }
            else {
                status = GetLastError();
            }
        }

        DmCloseKey(hResTypeKey);
    }
    else {
        status = GetLastError();
    }

    if (status == ERROR_FILE_NOT_FOUND) {
        status = ERROR_SUCCESS;
    }

    Context->Status = status;

    if (status != ERROR_SUCCESS) {
        return(FALSE);
    }
    else {
        return(TRUE);
    }

}  // NmpCleanseResTypeCallback


/////////////////////////////////////////////////////////////////////////////
//
// Node failure handler
//
/////////////////////////////////////////////////////////////////////////////

VOID
NmpNodeFailureHandler(
    CL_NODE_ID    NodeId,
    LPVOID        NodeFailureContext
    )
{
    return;
}


/////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous routines
//
/////////////////////////////////////////////////////////////////////////////



//SS: when the node objects are created, their product suite is
//assumed to be Enterprise(aka Advanced Server) - This is because
//the joining interface doesnt allow the joiner to provide the node
//suite type and we didnt want to muck with it at a late state in
//shipping because it affects mixed mode clusters.
//SO, we fixup the structures after NmPerformFixups is called
//and calculate the cluster node limit
DWORD NmpRefreshNodeObjects(
)
{

    NM_NODE_AUX_INFO    NodeAuxInfo;
    PLIST_ENTRY         pListEntry;
    PNM_NODE            pNmNode;
    WCHAR               szNodeId[6];
    DWORD               dwStatus = ERROR_SUCCESS;

    NmpAcquireLock();

    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

        wsprintf(szNodeId, L"%u", pNmNode->NodeId);
        //read the information from the registry
        NmpGetNodeAuxInfo(szNodeId, &NodeAuxInfo);
        //update the node structure
        pNmNode->ProductSuite = NodeAuxInfo.ProductSuite;

        //SS: This is ugly---we should pass in the product suits early on.
        //we dont know that the versions have changed, so should we  generate
        //a cluster_change_node_property event?
        //Also the fixup interface needs to to be richer so that the postcallback
        //function knows whether it is a form fixup or a join fixup and if it 
        //is a join fixup, which node is joining.  This could certainly optimize
        //some of the fixup processing
        ClusterEvent(CLUSTER_EVENT_NODE_PROPERTY_CHANGE, pNmNode);          
        
    }
    
    NmpReleaseLock();

    return(dwStatus);
}


BOOLEAN
NmpIsAddNodeAllowed(
    IN  DWORD    NewNodeProductSuite,
    IN  DWORD    RegistryNodeLimit,
    OUT LPDWORD  EffectiveNodeLimit  OPTIONAL
    )
/*++

Routine Description:

    Determines whether a new node can be added to the cluste membership.
    The membership size limit decision is based on the product suites
    of the cluster and the new node. If the registry override exists,
    we will use that limit instead.

Arguments:

    NewNodeProductSuite - The product suite identifier for the proposed
                          new member node.

    RegistryNodeLimit - The membership size override value stored in the
                        cluster database.

    EffectiveNodeLimit - On output, contains the membership size limit
                         that was calculated for this cluster.

Return Value:

    TRUE if the new node may be added to the cluster. FALSE otherwise.

Notes:

    Called with NmpLock held.

--*/
{
    DWORD   nodeLimit;
    DWORD   newNodeProductLimit;
    DWORD   currentNodeCount;


    //
    // Check if we already have the maximum number of nodes allowed in
    // this cluster, based on the the product suites of the cluster and
    // the joiner. If the registry override exists, we will use that
    // limit instead.
    //
    newNodeProductLimit = ClRtlGetDefaultNodeLimit(NewNodeProductSuite);
    currentNodeCount = NmGetCurrentNumberOfNodes();
    nodeLimit = RegistryNodeLimit;

    if (nodeLimit == 0) {
        //
        // No override in the registry.
        // Limit is minimum of cluster's limit and new node's limit
        //
        nodeLimit = min(CsClusterNodeLimit, newNodeProductLimit);
    }

    //
    // The runtime limit cannot exceed the compile time limit.
    //
    if (nodeLimit > NmMaxNodeId) {
        nodeLimit = NmMaxNodeId;
    }

    if (currentNodeCount >= nodeLimit) {
        return(FALSE);
    }

    if (EffectiveNodeLimit != NULL) {
        *EffectiveNodeLimit = nodeLimit;
    }

    return(TRUE);

} // NmpIsAddNodeAllowed


DWORD
NmpAddNode(
    IN LPCWSTR  NewNodeName,
    IN DWORD    NewNodeHighestVersion,
    IN DWORD    NewNodeLowestVersion,
    IN DWORD    NewNodeProductSuite,
    IN DWORD    RegistryNodeLimit
)
/*++

Routine Description:

    Adds a new node to the cluster by selecting an ID and
    issuing a global update.

Arguments:

    NewNodeName - A pointer to a string containing the name of the
                  new node.

    NewNodeHighestVersion - The highest cluster version number that the
                            new node can support.

    NewNodeLowestVersion - The lowest cluster version number that the
                            new node can support.

    NewNodeProductSuite - The product suite identifier for the new node.

Return Value:

    A Win32 status code.

Notes:

    Called with NmpLock held.

--*/
{
    DWORD     status;
    DWORD     nodeId;
    DWORD     nodeLimit;


    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Processing request to add node '%1!ws!' to "
        "the cluster.\n",
        NewNodeName
        );

    if (NmpAddNodeId != ClusterInvalidNodeId) {
        //
        // An add is already in progress. Return an error.
        //
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster because "
            "another add node operation is in progress. Retry later.\n",
            NewNodeName
            );

        return(ERROR_CLUSTER_JOIN_IN_PROGRESS);
    }

    if (!NmpIsAddNodeAllowed(
            NewNodeProductSuite,
            RegistryNodeLimit,
            &nodeLimit
            )
       )
    {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster. "
            "The cluster already contains the maximum number of nodes "
            "allowed by the product licenses of the current member nodes "
            "and the proposed new node.\n",
            NewNodeName
            );
        return(ERROR_LICENSE_QUOTA_EXCEEDED);
    }

    //
    // Find a free node ID.
    //
    for (nodeId=ClusterMinNodeId; nodeId<=nodeLimit; nodeId++) {
        if (NmpIdArray[nodeId] == NULL) {
            //
            // Found an available node ID.
            //
            NmpAddNodeId = nodeId;
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Allocated node ID '%1!u!' for new node '%2!ws!'\n",
                NmpAddNodeId,
                NewNodeName
                );
            break;
        }
    }

    //
    // Since the license test passed, it should be impossible for us to
    // find no free slots in the node table.
    //
    CL_ASSERT(NmpAddNodeId != ClusterInvalidNodeId);

    if (NmpAddNodeId == ClusterInvalidNodeId) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster because "
            "no slots are available in the node table.\n"
            );
        return(ERROR_LICENSE_QUOTA_EXCEEDED);
    }

    NmpReleaseLock();

    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateAddNode,
                 5,
                 sizeof(NmpAddNodeId),
                 &NmpAddNodeId,
                 NM_WCSLEN(NewNodeName),
                 NewNodeName,
                 sizeof(NewNodeHighestVersion),
                 &NewNodeHighestVersion,
                 sizeof(NewNodeLowestVersion),
                 &NewNodeLowestVersion,
                 sizeof(NewNodeProductSuite),
                 &NewNodeProductSuite
                 );

    NmpAcquireLock();

    //
    // Reset the global serialization variable.
    //
    CL_ASSERT(NmpAddNodeId == nodeId);

    NmpAddNodeId = ClusterInvalidNodeId;

    return(status);

} // NmpAddNode


VOID 
NmpTerminateRpcsToNode(
    DWORD NodeId
    )
/*++

Routine Description:

    Cancels all outstanding RPCs to the specified node.

Arguments:

    NodeId - The ID of the node for which calls should be cancelled.

Return Value:

    None

--*/
{
    LIST_ENTRY *pEntry, *pStart;
    PNM_INTRACLUSTER_RPC_THREAD pRpcTh;
    RPC_STATUS status;

#if DBG
    BOOLEAN  startTimer = FALSE;
#endif // DBG


    CL_ASSERT((NodeId >= ClusterMinNodeId) && (NodeId <= NmMaxNodeId));
    CL_ASSERT(NmpIntraClusterRpcArr != NULL);

    NmpAcquireRPCLock();
    pEntry = pStart = &NmpIntraClusterRpcArr[NodeId];
    pEntry = pEntry->Flink;
    while(pEntry != pStart) {
        pRpcTh = CONTAINING_RECORD(pEntry, NM_INTRACLUSTER_RPC_THREAD, Linkage);
        status = RpcCancelThreadEx(pRpcTh->Thread, 0);
        pRpcTh->Cancelled = TRUE;
        if(status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to cancel RPC to node %1!u! by thread "
                "x%2!x!, status %3!u!.\n",
                NodeId,
                pRpcTh->ThreadId,
                status
                );
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Cancelled RPC to node %1!u! by thread x%2!x!.\n",
                NodeId,
                pRpcTh->ThreadId
                );
#if DBG
            startTimer = TRUE;
#endif // DBG
        }

        pEntry = pEntry->Flink;
    }

#if DBG
    //
    // Now start a timer to make sure that all cancelled RPCs return to 
    // their callers within a reasonable amount of time.
    //
    if (startTimer) {
        NmpRpcTimer = NM_RPC_TIMEOUT;
    }

#endif // DBG
    
    NmpReleaseRPCLock();

    return;

}  // NmTerminateRpcsToNode


#if DBG

VOID 
NmpRpcTimerTick(
    DWORD MsTickInterval
    )
/*++

Routine Description:

    Decrements a timer used to ensure that all cancelled RPCs to a dead
    node return to their callers within a reasonable amount of time.

Arguments:

    MsTickInterval - The time, in milliseconds, that has elapsed since this
                     routine was last invoked.
Return Value:

    None

--*/
{
    DWORD ndx;
    LIST_ENTRY *pEntry, *pStart;
    PNM_INTRACLUSTER_RPC_THREAD pRpcTh;

    if(NmpRpcTimer == 0)
        return;

    NmpAcquireRPCLock();
    
    if (NmpRpcTimer > MsTickInterval) {
        NmpRpcTimer -= MsTickInterval;
    }
    else {
        BOOLEAN stopClusSvc=FALSE;
        
        NmpRpcTimer = 0;

        for(ndx=0;ndx<=NmMaxNodeId;ndx++) {
            pStart = pEntry = &NmpIntraClusterRpcArr[ndx];
            pEntry = pEntry->Flink;
            while(pEntry != pStart) {
                pRpcTh = CONTAINING_RECORD(
                             pEntry, 
                             NM_INTRACLUSTER_RPC_THREAD, 
                             Linkage
                             );
                if(pRpcTh->Cancelled == TRUE) {
                    ClRtlLogPrint( LOG_CRITICAL, 
                        "[NM] Cancelled RPC to node %1!u! by thread x%2!x! "
                        "is still lingering after %3!u! seconds.\n",
                        ndx,
                        pRpcTh->ThreadId,
                        (NM_RPC_TIMEOUT/1000)
                        );
                    stopClusSvc = TRUE;
                }
                pEntry = pEntry->Flink;
            }
        }

        if(stopClusSvc) {
            DebugBreak();
        }
    }
    
    NmpReleaseRPCLock();

    return;

}  // NmpRpcTimerTick

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\om\obmgmt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    objmgr.c

Abstract:

    Object Manager object management routines for the NT Cluster Service

Author:

    Rod Gamache (rodga) 13-Mar-1996

Revision History:

--*/
#include "omp.h"

//
// Global data defined by this module
//

//
// The Object Type table and lock.
//
POM_OBJECT_TYPE OmpObjectTypeTable[ObjectTypeMax] = {0};
CRITICAL_SECTION OmpObjectTypeLock;

#if OM_TRACE_REF
LIST_ENTRY	gDeadListHead;
#endif
//
// Functions local to this module
//

#if OM_TRACE_OBJREF
DWORDLONG *OmpMatchRef = NULL;

VOID
OmpReferenceHeader(
    POM_HEADER pOmHeader
    )
{
    InterlockedIncrement(&(pOmHeader)->RefCount);
    if (&(pOmHeader)->Body == OmpMatchRef) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[OM] Referencing %1!lx! - new ref %2!d!\n",
                   OmpMatchRef,
                   (pOmHeader)->RefCount);
    }
}

DWORD
OmpDereferenceHeader(
    IN POM_HEADER Header
    )
{
    if (&Header->Body == OmpMatchRef) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[OM] Dereferencing %1!lx! - old ref %2!d!\n",
                   OmpMatchRef,
                   Header->RefCount);
    }
    return(InterlockedDecrement(&Header->RefCount) == 0);
}
#endif



DWORD
WINAPI
OmCreateType(
    IN OBJECT_TYPE ObjectType,
    IN POM_OBJECT_TYPE_INITIALIZE ObjectTypeInitialize
    )

/*++

Routine Description:

    This routine creates an object of the type specified. This merely
    allocates an object type structure, and inserts a pointer to this
    structure into the OmpObjectTypeTable.

Arguments:
    ObjectType - The Object Type being created.
    ObjectTypeIntialize - The initialization info.

Returns:
    ERROR_SUCCESS if the request is successful.
    A Win32 error code on failure.

--*/

{
    POM_OBJECT_TYPE objType;
    DWORD objTypeSize;

    CL_ASSERT( ObjectType < ObjectTypeMax );
    CL_ASSERT( ARGUMENT_PRESENT(ObjectTypeInitialize) );
    CL_ASSERT( ObjectTypeInitialize->ObjectSize );

    //
    // Take out a lock, just in case there can be multiple threads.
    //

    EnterCriticalSection( &OmpObjectTypeLock );

    //
    // Check if this ObjectType is already allocated.
    //

    if ( OmpObjectTypeTable[ObjectType] != NULL ) {
        LeaveCriticalSection( &OmpObjectTypeLock );
        return(ERROR_OBJECT_ALREADY_EXISTS);
    }

    //
    // Allocate an object type block, plus its name.
    //

    objTypeSize = (sizeof(OM_OBJECT_TYPE) + sizeof(DWORDLONG)) &
                   ~sizeof(DWORDLONG);

    objType = LocalAlloc(LMEM_ZEROINIT, objTypeSize +
                          ((lstrlenW(ObjectTypeInitialize->Name) + 1) *
                            sizeof(WCHAR)));

    if ( objType == NULL ) {
        LeaveCriticalSection( &OmpObjectTypeLock );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Init the object type block.
    //

    InitializeListHead(&objType->ListHead);
    InitializeListHead(&objType->CallbackListHead);
    InitializeCriticalSection(&objType->CriticalSection);

    objType->Type = ObjectType;

    objType->ObjectSize = ObjectTypeInitialize->ObjectSize;
    objType->Signature = ObjectTypeInitialize->Signature;
    objType->DeleteObjectMethod = ObjectTypeInitialize->DeleteObjectMethod;

    objType->Name = (LPWSTR)((PCHAR)objType + objTypeSize);
    lstrcpyW(objType->Name, ObjectTypeInitialize->Name);

    OmpObjectTypeTable[ObjectType] = objType;

    LeaveCriticalSection( &OmpObjectTypeLock );

    OmpLogPrint( L"OTCREATE \"%1!ws!\"\n", objType->Name );

    return(ERROR_SUCCESS);

} // OmCreateType



PVOID
WINAPI
OmCreateObject(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR ObjectId,
    IN LPCWSTR ObjectName OPTIONAL,
    OUT PBOOL  Created OPTIONAL
    )

/*++

Routine Description:

    This routine creates an object of the type specified or opens an
    object if one of the same Id already exists. If the object is created
    its reference count is 1. If it is not create, then the reference count
    of the object is incremented.

Arguments:
    ObjectType - The type of object being created.
    ObjectId - The Id string for the object to find/create.
    ObjectName - The name to set for the object if found or created.
    Created - If present, returns TRUE if the object was created, returns
              FALSE otherwise.

Returns:
    A pointer to the created/opened object on success.
    A NULL on failure - use GetLastError to get the error code.

--*/

{
    DWORD status;
    PVOID object;
    PVOID tmpObject = NULL;
    LPWSTR objectName = NULL;
    POM_HEADER objHeader;
    POM_OBJECT_TYPE objType;
    DWORD objSize;

    CL_ASSERT( ObjectType < ObjectTypeMax );
    CL_ASSERT( OmpObjectTypeTable[ObjectType] );

    //
    // Get our Object Type block.
    //
    objType = OmpObjectTypeTable[ObjectType];

    //
    // Calculate size of this object (round it to a DWORDLONG).
    // Note: we don't subtract the DWORDLONG Body for rounding purposes.
    //
    objSize = (sizeof(OM_HEADER) + objType->ObjectSize) & ~sizeof(DWORDLONG);

    EnterCriticalSection( &objType->CriticalSection );

    //
    // Try to open the object first
    //
    object = OmReferenceObjectById( ObjectType, ObjectId );

    if ( object != NULL ) {
        status = ERROR_SUCCESS;
        if ( ARGUMENT_PRESENT(ObjectName) ) {
            //
            // Set the new ObjectName.
            //
            status = OmSetObjectName( object, ObjectName );

            //
            // If we failed, then return NULL.
            //
            if ( status != ERROR_SUCCESS ) {
				OmDereferenceObject( object );
				object = NULL;
            }
        }
        LeaveCriticalSection( &objType->CriticalSection );

        if ( ARGUMENT_PRESENT(Created) ) {
            *Created = FALSE;
        }

        SetLastError( status );
        return(object);
    }

    //
    // Attempt to allocate the object, plus its Id string.
    //
    objHeader = LocalAlloc(LMEM_ZEROINIT, objSize +
                           ((lstrlenW(ObjectId) + 1) * sizeof(WCHAR)));

    if ( objHeader == NULL ) {
        LeaveCriticalSection( &objType->CriticalSection );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    if ( ARGUMENT_PRESENT(ObjectName) ) {
        //
        // Make sure ObjectName is unique.
        //
        tmpObject = OmReferenceObjectByName( ObjectType, ObjectName );
        if ( tmpObject != NULL ) {
            LeaveCriticalSection( &objType->CriticalSection );
            LocalFree( objHeader );
            SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
            return(NULL);
        }

        objectName = LocalAlloc(LMEM_ZEROINIT,
                                (lstrlenW(ObjectName) + 1) * sizeof(WCHAR));

        if ( objectName == NULL ) {
            LeaveCriticalSection( &objType->CriticalSection );
            LocalFree( objHeader );
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }
        lstrcpyW( objectName, ObjectName );
    }

    //
    // Initialize the object.
    //
    InitializeListHead(&objHeader->ListEntry);
    objHeader->Signature = objType->Signature;
    objHeader->RefCount = 1;
    objHeader->ObjectType = objType;
    objHeader->Name = objectName;
    InitializeListHead(&objHeader->CbListHead);

    //
    // The Id string goes after the object header and body.
    //
    objHeader->Id = (LPWSTR)((PCHAR)objHeader + objSize);
    lstrcpyW(objHeader->Id, ObjectId);

    //
    // Tell the caller that we had to create this object.
    //
    if ( ARGUMENT_PRESENT(Created) ) {
        *Created = TRUE;
    }

#if  OM_TRACE_REF
	//SS: all objects are added to the dead list on creation
	// they are removed when the refcount goes to zero
    InitializeListHead(&objHeader->DeadListEntry);
    InsertTailList( &gDeadListHead, &objHeader->DeadListEntry );
#endif

    LeaveCriticalSection( &objType->CriticalSection );

    OmpLogPrint(L"OBCREATE \"%1!ws!\" \"%2!ws!\" \"%3!ws!\"\n",
                objType->Name,
                ObjectId,
                ObjectName == NULL ? L"" : ObjectName);

    return(&objHeader->Body);

} // OmCreateObject



DWORD
WINAPI
OmInsertObject(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine inserts an object into the object's list.

Arguments:

    Object - A pointer to the object to be inserted into its object type list.

Returns:

    ERROR_SUCCESS - if the request was successful.
    ERROR_OBJECT_ALREADY_EXISTS if this object is already in the list.

--*/

{
    POM_HEADER objHeader;
    POM_HEADER otherHeader;
    POM_OBJECT_TYPE objType;

    //
    // Get our Object Header.
    //

    objHeader = OmpObjectToHeader( Object );

    //
    // Get our Object Type block.
    //

    objType = objHeader->ObjectType;

    //
    // Now perform the insertion, but first check to see if someone else
    // snuck in ahead of us and inserted another object of the same name.
    //

    EnterCriticalSection( &objType->CriticalSection );

    CL_ASSERT( !(objHeader->Flags & OM_FLAG_OBJECT_INSERTED) );

    otherHeader = OmpFindIdInList( &objType->ListHead, objHeader->Id );

    if ( otherHeader != NULL ) {
        // We loose!
        LeaveCriticalSection( &objType->CriticalSection );
        return(ERROR_OBJECT_ALREADY_EXISTS);
    }

    //
    // We generate the enumeration key for this object, and we must insert
    // the object at the tail of the list, so the list is ordered by EnumKey.
    // By definition, this entry must go at the end of the list.
    //

    objHeader->EnumKey = ++objType->EnumKey;
    CL_ASSERT( objHeader->EnumKey > 0 );

    InsertTailList( &objType->ListHead, &objHeader->ListEntry );

    objHeader->Flags |= OM_FLAG_OBJECT_INSERTED;

    LeaveCriticalSection( &objType->CriticalSection );

    return(ERROR_SUCCESS);

} // OmInsertObject



DWORD
WINAPI
OmRemoveObject(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine removes an object from its object's list.

Arguments:

    Object - A pointer to the object to be removed from its object type list.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_RESOURCE_NOT_FOUND if the object is not in any list.

--*/

{
    POM_HEADER objHeader;
    POM_OBJECT_TYPE objType;

    //
    // Get our Object Header.
    //

    objHeader = OmpObjectToHeader( Object );

    //
    // Get our Object Type block.
    //

    objType = objHeader->ObjectType;

    //
    // Now perform the removal.
    //

    EnterCriticalSection( &objType->CriticalSection );

    if ( !(objHeader->Flags & OM_FLAG_OBJECT_INSERTED) ) {
        LeaveCriticalSection( &objType->CriticalSection );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    RemoveEntryList( &objHeader->ListEntry );

    objHeader->Flags &= ~OM_FLAG_OBJECT_INSERTED;

    //
    // log while the lock is held so we don't lose our pointers
    //
    OmpLogPrint(L"OBDELETE \"%1!ws!\" \"%2!ws!\" \"%3!ws!\"\n",
                objType->Name,
                objHeader->Id,
                objHeader->Name == NULL ? L"" : objHeader->Name);

    LeaveCriticalSection( &objType->CriticalSection );

    return(ERROR_SUCCESS);

} // OmRemoveObject



PVOID
WINAPI
OmpReferenceObjectById(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    This routine opens an object of the name and type specified. It also
    increments the reference count on the object.

Arguments:
    ObjectType - The Object Type to open.
    Id - The Id string of the object to open.

Returns:
    A pointer to the object on success.
    NULL on error.

--*/

{
    DWORD status;
    POM_OBJECT_TYPE objType;
    POM_HEADER objHeader;

    CL_ASSERT( ObjectType < ObjectTypeMax );
    CL_ASSERT( OmpObjectTypeTable[ObjectType] );

    //
    // Get our Object Type block.
    //

    objType = OmpObjectTypeTable[ObjectType];

    EnterCriticalSection( &objType->CriticalSection );

    //
    // Get the Object's header
    //
    objHeader = OmpFindIdInList( &objType->ListHead, Id );

    if ( objHeader == NULL ) {
        LeaveCriticalSection( &objType->CriticalSection );
        return(NULL);
    }

#if OM_TRACE_REF    
	OmReferenceObject(&objHeader->Body);
#else
    OmpReferenceHeader( objHeader );
#endif
    LeaveCriticalSection( &objType->CriticalSection );

    return(&objHeader->Body);

} // OmpReferenceObjectById



PVOID
WINAPI
OmpReferenceObjectByName(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    This routine opens an object of the name and type specified. It also
    increments the reference count on the object.

Arguments:
    ObjectType - The Object Type to open.
    Name - The name of the object to open.

Returns:
    A pointer to the object on success.
    NULL on error.

--*/

{
    DWORD status;
    POM_OBJECT_TYPE objType;
    POM_HEADER objHeader;

    CL_ASSERT( ObjectType < ObjectTypeMax );
    CL_ASSERT( OmpObjectTypeTable[ObjectType] );

    //
    // Get our Object Type block.
    //

    objType = OmpObjectTypeTable[ObjectType];

    EnterCriticalSection( &objType->CriticalSection );

    //
    // Get the Object's header
    //

    objHeader = OmpFindNameInList( &objType->ListHead, Name );

    if ( objHeader == NULL ) {
        LeaveCriticalSection( &objType->CriticalSection );
        return(NULL);
    }

#if OM_TRACE_REF    
	OmReferenceObject(&objHeader->Body);
#else
    OmpReferenceHeader( objHeader );
#endif

    LeaveCriticalSection( &objType->CriticalSection );

    return(&objHeader->Body);

} // OmReferenceObjectByName


DWORD
WINAPI
OmCountObjects(
    IN OBJECT_TYPE ObjectType,
    OUT LPDWORD NumberOfObjects
    )

/*++

Routine Description:

    Returns the count of the number of objects of a particular type
    which exist in the database at this time.

Arguments:

    ObjectType - The object type to count.

    NumberOfObjects - On output, contains the number of objects of the
                      specified type in the database.

Return Value:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

--*/

{
    POM_OBJECT_TYPE objType;
    PLIST_ENTRY listEntry;
    DWORD objectCount = 0;


    CL_ASSERT( ObjectType < ObjectTypeMax );

    objType = OmpObjectTypeTable[ObjectType];

    if ( !objType ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    EnterCriticalSection(&objType->CriticalSection);


    for ( listEntry = objType->ListHead.Flink;
          listEntry != &(objType->ListHead);
          listEntry = listEntry->Flink
        )
    {
        objectCount++;
    }

    LeaveCriticalSection(&objType->CriticalSection);

    *NumberOfObjects = objectCount;

    return(ERROR_SUCCESS);

} // OmCountObjects



DWORD
WINAPI
OmEnumObjects(
    IN OBJECT_TYPE ObjectType,
    IN OM_ENUM_OBJECT_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    )

/*++

Routine Description:

    Enumerates all objects of the specified type.

Arguments:

    ObjectType - The object type to enumerate.

    EnumerationRoutine - Supplies the enumeration routine to be
        called for each object.

    Context1 - Supplies a context pointer to be passed to the
        enumeration routine.

    Context2 - Supplies a second context pointer to be passed to the
        enumeration routine.

Return Value:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

--*/

{
    POM_OBJECT_TYPE objType;
    POM_HEADER objHeader;
    PLIST_ENTRY listEntry;
    DWORD   enumKey = 0;

    CL_ASSERT( ObjectType < ObjectTypeMax );

    objType = OmpObjectTypeTable[ObjectType];

    if ( !objType ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Enumeration is a little tricky. First, we have to allow for multiple
    // entries in the enumeration list to be removed as a side effect of the
    // callout. Second, we have to allow the list lock to be released so the
    // first issue can be handled. We'll use a sort order key to remember where
    // we are in the enumeration and pick up from the next highest value.
    //

    while ( TRUE ) {

        EnterCriticalSection(&objType->CriticalSection);

        //
        // Skip to next entry to process in list.
        // We can treat this like an entry only after verifying it is not the
        // ListHeader.
        //

        listEntry = objType->ListHead.Flink;
        objHeader = CONTAINING_RECORD( listEntry, OM_HEADER, ListEntry );

        while ( listEntry != &objType->ListHead &&
                objHeader->EnumKey <= enumKey ) {
            listEntry = listEntry->Flink;
            objHeader = CONTAINING_RECORD( listEntry, OM_HEADER, ListEntry );
        }

        //
        // Save the enumeration key for next iteration.
        //

        enumKey = objHeader->EnumKey;

        //if it is a valid object, increment the reference count
        // so that it is not deleted while the call out is being
        // made
        if ( listEntry != &objType->ListHead ) {
            OmReferenceObject(&objHeader->Body);
        }
        //
        // Drop the lock to return or call out.
        //

        LeaveCriticalSection(&objType->CriticalSection);

        if ( listEntry == &objType->ListHead ) {
            return(ERROR_SUCCESS);
        }

        if (!(EnumerationRoutine)(Context1,
                                  Context2,
                                  &objHeader->Body,
                                  objHeader->Id)) {
            OmDereferenceObject(&objHeader->Body);
            break;
        }
        OmDereferenceObject(&objHeader->Body);
    }

    return(ERROR_SUCCESS);

} // OmEnumObject



VOID
OmpDereferenceObject(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine dereferences an object. If the reference count goes to
    zero, then the object is deallocated.

Arguments:
    Object - A pointer to the object to be dereferenced.

Returns:
    None

--*/

{
    DWORD status;
    POM_HEADER objHeader;
    POM_OBJECT_TYPE objType;

    objHeader = OmpObjectToHeader( Object );

    objType = objHeader->ObjectType;

    CL_ASSERT( objHeader->RefCount != 0xfeeefeee );
    CL_ASSERT( objHeader->RefCount > 0 );

    if ( OmpDereferenceHeader(objHeader) ) {

        //
        // The reference count has gone to zero. Acquire the
        // lock, remove the object from the list, and perform
        // cleanup.
        //

        EnterCriticalSection( &objType->CriticalSection );

        //
        // Check the ref count again, to close the race condition between
        // open/create and this routine.
        //

        if ( objHeader->RefCount == 0 ) {
            //
            // If the object hasn't been previously removed from it's
            // object type list, then remove it now.
            //

            if ( objHeader->Flags & OM_FLAG_OBJECT_INSERTED ) {
                RemoveEntryList( &objHeader->ListEntry );
                objHeader->Flags &= ~OM_FLAG_OBJECT_INSERTED;
            }

            //
            // Call the object type's delete method (if present).
            //

            if ( ARGUMENT_PRESENT( objType->DeleteObjectMethod ) ) {
                (objType->DeleteObjectMethod)( &objHeader->Body );
            }

            objHeader->Signature = 'rFmO';
#if OM_TRACE_REF
			RemoveEntryList(&objHeader->DeadListEntry);
#endif			
            if ( objHeader->Name != NULL ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[OM] Deleting object %1!ws! (%2!ws!)\n",
                           objHeader->Name,
                           objHeader->Id);
                LocalFree( objHeader->Name );
            } else {
                ClRtlLogPrint(LOG_NOISE,
                           "[OM] Deleting object %1!ws!\n",
                           objHeader->Id);
            }
            LocalFree( objHeader );
        }
        LeaveCriticalSection( &objType->CriticalSection );
    }

} // OmpDereferenceObject



DWORD
WINAPI
OmSetObjectName(
    IN PVOID    Object,
    IN LPCWSTR  ObjectName
    )

/*++

Routine Description:

    Set the object name for an object. If the ObjectName already exists on a
    different object, then this call will fail.

Arguments:

    Object - A pointer to the object to set its name.
    ObjectName - The name to set for the object.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD status = ERROR_SUCCESS;
    PVOID object = NULL;
    LPWSTR objectName;
    POM_HEADER objHeader;
    POM_OBJECT_TYPE objType;

    //
    // Make sure object name is valid (not empty)
    //
    if (ObjectName[0] == '\0') 
    {
        status = ERROR_INVALID_NAME;
        goto FnExit;
    }

    objHeader = OmpObjectToHeader( Object );

    objType = objHeader->ObjectType;

    EnterCriticalSection( &objType->CriticalSection );

    //
    // Make sure ObjectName is unique.
    //
    object = OmReferenceObjectByName( objType->Type, ObjectName );
    if ( object != NULL ) 
    {
        //
        // If our's is the other object, then nothing to do. Otherwise,
        // there is a duplicate.
        //
        if ( object != Object ) 
        {
            status = ERROR_OBJECT_ALREADY_EXISTS;
            goto FnUnlock;
        }
    } 
    else 
    {
        //
        // No other object with the new name, then set the new name.
        //
        objectName = LocalAlloc(LMEM_ZEROINIT,
                                (lstrlenW(ObjectName) + 1) * sizeof(WCHAR));
        if ( objectName == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            if ( objHeader->Name != NULL ) {
                LocalFree( objHeader->Name );
            }
            objHeader->Name = objectName;
            lstrcpyW( objectName, ObjectName );

            OmpLogPrint(L"OBRENAME \"%1!ws!\" \"%2!ws!\" \"%3!ws!\"\n",
                        objType->Name,
                        objHeader->Id,
                        ObjectName);
        }
    }

FnUnlock:
    LeaveCriticalSection( &objType->CriticalSection );
FnExit:
	if (object)
	{
		OmDereferenceObject(object);
	}    	
    return(status);

} // OmSetObjectName



DWORD
WINAPI
OmRegisterTypeNotify(
    IN OBJECT_TYPE          ObjectType,
    IN PVOID                pContext,
    IN DWORD                dwNotifyMask,
    IN OM_OBJECT_NOTIFYCB   pfnObjNotifyCb
    )

/*++

Routine Description:

    Registers a callback to be called by the FM on object state changes.

Arguments:

    ObjectType - The object type that notifications should be delivered for.

    pContext - A pointer to context information that is passed back into the callback.

    dwNotifyMask - The type of notifications that should be delivered

    pfnObjNotifyCb - a pointer to the callback.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD               dwError = ERROR_SUCCESS;
    POM_HEADER          pObjHeader;
    POM_OBJECT_TYPE     pObjType;
    POM_NOTIFY_RECORD   pNotifyRec;

    if ( !pfnObjNotifyCb ) {
        return(ERROR_INVALID_PARAMETER);
    }

    pObjType = OmpObjectTypeTable[ObjectType];

    //
    // The object type lock is used to serialize callbacks. This
    // is so that callees do not deadlock if they are waiting on
    // another thread that needs to enumerate objects.
    //
    EnterCriticalSection( &OmpObjectTypeLock );

    //
    // First, check if the same notification is being registered twice!
    // If so, then just change the notification mask and context.
    //
    pNotifyRec = OmpFindNotifyCbInList( &pObjType->CallbackListHead,
                                        pfnObjNotifyCb);
    if ( !pNotifyRec ) {
        pNotifyRec = (POM_NOTIFY_RECORD) LocalAlloc(LMEM_FIXED,sizeof(OM_NOTIFY_RECORD));

        if ( !pNotifyRec ) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            CsInconsistencyHalt(dwError);
            goto FnExit;
        }

        pNotifyRec->pfnObjNotifyCb = pfnObjNotifyCb;

        //insert the notification record at the tail
        InsertTailList(&pObjType->CallbackListHead, &pNotifyRec->ListEntry);
    }

    pNotifyRec->dwNotifyMask = dwNotifyMask;
    pNotifyRec->pContext = pContext;

FnExit:
    LeaveCriticalSection( &OmpObjectTypeLock );

    return(dwError);

} // OmRegisterTypeNotify



DWORD
WINAPI
OmRegisterNotify(
    IN PVOID                pObject,
    IN PVOID                pContext,
    IN DWORD                dwNotifyMask,
    IN OM_OBJECT_NOTIFYCB   pfnObjNotifyCb
    )

/*++

Routine Description:

    Registers a callback to be called by the FM on object state changes.

Arguments:

    pObject - A pointer to the object to set its name.
    pContext - A pointer to context information that is passed back into the callback.
    dwNotifyMask - The name to set for the object.
    pfnObjNotifyCb - a pointer to the callback.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD               dwError = ERROR_SUCCESS;
    POM_HEADER          pObjHeader;
    POM_OBJECT_TYPE     pObjType;
    POM_NOTIFY_RECORD   pNotifyRec;

    if ( !pfnObjNotifyCb ) {
        return(ERROR_INVALID_PARAMETER);
    }

    pObjHeader = OmpObjectToHeader( pObject );

    pObjType = pObjHeader->ObjectType;

    EnterCriticalSection( &OmpObjectTypeLock );

    //
    // First, check if the same notification is being registered twice!
    // If so, then just change the notification mask and context.
    //
    pNotifyRec = OmpFindNotifyCbInList(&pObjHeader->CbListHead, pfnObjNotifyCb);
    if ( !pNotifyRec ) {
        pNotifyRec = (POM_NOTIFY_RECORD) LocalAlloc(LMEM_FIXED,sizeof(OM_NOTIFY_RECORD));

        if ( !pNotifyRec ) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            CsInconsistencyHalt(dwError);
            goto FnExit;
        }

        pNotifyRec->pfnObjNotifyCb = pfnObjNotifyCb;

        //insert the notification record at the tail
        InsertTailList(&pObjHeader->CbListHead, &pNotifyRec->ListEntry);
    }

    pNotifyRec->dwNotifyMask = dwNotifyMask;
    pNotifyRec->pContext = pContext;

FnExit:
    LeaveCriticalSection( &OmpObjectTypeLock );

    return(dwError);

} // OmRegisterNotify


DWORD
WINAPI
OmDeregisterNotify(
    IN PVOID                    pObject,
    IN OM_OBJECT_NOTIFYCB       pfnObjNotifyCb
    )

/*++

Routine Description:

    Removes the callback registed with the object.

Arguments:

    pObject - A pointer to the object to set its name.
    pfnObjNotifyCb - a pointer to the callback.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD               dwError = ERROR_SUCCESS;
    POM_HEADER          pObjHeader;
    POM_OBJECT_TYPE     pObjType;
    POM_NOTIFY_RECORD   pNotifyRec;

    if ( !pfnObjNotifyCb ) {
        return(ERROR_INVALID_PARAMETER);
    }


    pObjHeader = OmpObjectToHeader( pObject );


        //SS: we use the same crit section for list manipulations
    pObjType = pObjHeader->ObjectType;

    //
    // The object type lock is used to serialize callbacks. This
    // is so that callees do not deadlock if they are waiting on
    // another thread that needs to enumerate objects.
    //
    EnterCriticalSection( &OmpObjectTypeLock );

    pNotifyRec = OmpFindNotifyCbInList(&pObjHeader->CbListHead, pfnObjNotifyCb);
    if (!pNotifyRec) {
            ClRtlLogPrint(LOG_UNUSUAL,
                    "[OM] OmRegisterNotify: OmpFindNotifyCbInList failed for 0x%1!08lx!\r\n",
                    pfnObjNotifyCb);

            dwError = ERROR_INVALID_PARAMETER;
            CL_LOGFAILURE(dwError);
            goto FnExit;
    }
    RemoveEntryList(&pNotifyRec->ListEntry);

FnExit:
    LeaveCriticalSection( &OmpObjectTypeLock );

    return(dwError);

} // OmRegisterNotify



DWORD
WINAPI
OmNotifyCb(
    IN PVOID pObject,
    IN DWORD dwNotification
    )
/*++

Routine Description:

    The callback registered with the quorum resource object.

Arguments:

    pContext - The resource whose call back list will be traversed.
        dwNotification - The notification to be passed to the callback.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    POM_HEADER              pObjHeader;
    POM_OBJECT_TYPE         pObjType;
    PLIST_ENTRY             ListEntry;
    DWORD                   dwError=ERROR_SUCCESS;
    POM_NOTIFY_RECORD       pNotifyRecList = NULL;
    DWORD                   dwCount;
    DWORD                   i;
    
    CL_ASSERT(pObject);

    //get the callback list
    pObjHeader = OmpObjectToHeader(pObject);
    pObjType = pObjHeader->ObjectType;

    //will walk the list of callbacks, do allow more registrations
    EnterCriticalSection(&OmpObjectTypeLock);
    dwError = OmpGetCbList(pObject, &pNotifyRecList, &dwCount);
    LeaveCriticalSection(&OmpObjectTypeLock);

    for (i=0; i < dwCount; i++)
    {
        if (pNotifyRecList[i].dwNotifyMask & dwNotification) {
            (pNotifyRecList[i].pfnObjNotifyCb)(pNotifyRecList[i].pContext,
                                         pObject,
                                         dwNotification);
        }
    }

    LocalFree(pNotifyRecList);
    return(dwError);
}    

DWORD OmpGetCbList(
    IN PVOID                pObject,
    OUT POM_NOTIFY_RECORD   *ppNotifyRecList,
    OUT LPDWORD             pdwCount
)    
{
    DWORD                   status = ERROR_SUCCESS;
    POM_NOTIFY_RECORD       pNotifyRecList;
    POM_NOTIFY_RECORD       pNotifyRec;
    DWORD                   dwAllocated;
    PLIST_ENTRY             ListEntry;
    DWORD                   dwRetrySize=1;
    POM_HEADER              pObjHeader;
    POM_OBJECT_TYPE         pObjType;
    DWORD                   i = 0;

    *ppNotifyRecList = NULL;
    *pdwCount = 0;
Retry:    
    dwAllocated = ENUM_GROW_SIZE * dwRetrySize;

    pObjHeader = OmpObjectToHeader(pObject);
    pObjType = pObjHeader->ObjectType;

    pNotifyRecList = LocalAlloc(LMEM_FIXED, sizeof(OM_NOTIFY_RECORD) * ENUM_GROW_SIZE);
    if ( pNotifyRecList == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    ZeroMemory( pNotifyRecList, sizeof(OM_NOTIFY_RECORD) * ENUM_GROW_SIZE );


    //
    // First notify any type-specific callbacks
    //
    ListEntry = pObjType->CallbackListHead.Flink;
    while (ListEntry != &pObjType->CallbackListHead) {
        pNotifyRec = CONTAINING_RECORD(ListEntry,
                                       OM_NOTIFY_RECORD,
                                       ListEntry);
        if (i < dwAllocated)
        {
            CopyMemory(&pNotifyRecList[i++], pNotifyRec, sizeof(OM_NOTIFY_RECORD));
        }
        else
        {
            LocalFree(pNotifyRecList);
            dwRetrySize++;
            goto Retry;
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // Next notify any resource-specific callbacks
    //
    ListEntry = pObjHeader->CbListHead.Flink;
    while (ListEntry != &(pObjHeader->CbListHead)) {
        pNotifyRec = CONTAINING_RECORD(ListEntry, OM_NOTIFY_RECORD, ListEntry);

        if (i < dwAllocated)
        {
            CopyMemory(&pNotifyRecList[i++], pNotifyRec, sizeof(OM_NOTIFY_RECORD));
        }
        else
        {
            LocalFree(pNotifyRecList);
            dwRetrySize++;
            goto Retry;
        }
        ListEntry = ListEntry->Flink;

    }


FnExit:
    *ppNotifyRecList = pNotifyRecList;
    *pdwCount = i;
    return(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\om\ominit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ominit.c

Abstract:

    Initialization module for Object Manager

Author:

    John Vert (jvert) 16-Feb-1996

Revision History:

--*/
#include "omp.h"

//
// Local data
//
BOOL OmInited = FALSE;

#if	OM_TRACE_REF
	extern LIST_ENTRY	gDeadListHead;
#endif	


DWORD
OmInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes the object manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status = ERROR_SUCCESS;

    if ( OmInited ) {
        return(ERROR_DUPLICATE_SERVICE_NAME);
    }

    //
    // Initialize locks
    //
    InitializeCriticalSection(&OmpObjectTypeLock);
#if	OM_TRACE_REF
    InitializeListHead(&gDeadListHead);
#endif

    //
    // open the log and write a start record
    //
    OmpOpenObjectLog();
    OmpLogStartRecord();

    OmInited = TRUE;

    return(Status);
}


VOID
OmShutdown(
    VOID
    )

/*++

Routine Description:

    Shuts down the object manager

Arguments:

    None

Return Value:

    None.

--*/

{
    OmInited = FALSE;

#if	OM_TRACE_REF	
{
    POM_HEADER 		pHeader;
	PLIST_ENTRY 	pListEntry;
	
	ClRtlLogPrint(LOG_NOISE, "[OM] Scanning for objects on deadlist\r\n");
    //SS: dump the objects and their ref counts
    pListEntry = gDeadListHead.Flink;
	while (pListEntry != &gDeadListHead)
	{
        pHeader = CONTAINING_RECORD(pListEntry, OM_HEADER, DeadListEntry);
        
        ClRtlLogPrint(LOG_NOISE, "[OM] ObjBody= %1!lx! RefCnt=%2!d! ObjName=%3!ws! ObjId=%4!ws!\n",
        	&pHeader->Body, pHeader->RefCount,pHeader->Name, pHeader->Id);
		/*        	
		if (pHeader->Name)
		{
        	ClRtlLogPrint(LOG_NOISE, "[OM] ObjectName=%1!ws!\r\n", pHeader->Name);
		}        	
		*/        	
        pListEntry = pListEntry->Flink;
	}
}	
#endif    
    //
    // Maybe we should check that the object type table is empty and
    // deallocate ObjectType blocks if it isn't empty!
    // However, since we are shutting down and presumably exiting, this
    // really doesn't matter that much.
    //

    ZeroMemory( &OmpObjectTypeTable, sizeof(OmpObjectTypeTable) );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\om\omlist.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    omlist.c

Abstract:

    Object Manager list processing routines for the NT Cluster Service

Author:

    John Vert (jvert) 27-Feb-1996

Revision History:

--*/
#include "omp.h"


POM_HEADER
OmpFindIdInList(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Searches the specified list of objects for the given name.

Arguments:

    ListHead - Supplies the head of the object list.

    Id - Supplies the Id string of the object.

Return Value:

    A pointer to the specified object's OM_HEADER if it is found

    NULL if the given Id string was not found

Notes:

    This routine assumes the the critical section for the object type
    is held on entry.

--*/

{
    PLIST_ENTRY ListEntry;
    POM_HEADER Header;
    POM_HEADER FoundHeader = NULL;

    ListEntry = ListHead->Flink;
    while (ListEntry != ListHead) {
        Header = CONTAINING_RECORD(ListEntry, OM_HEADER, ListEntry);
        if (lstrcmpiW(Header->Id, Id) == 0) {
            FoundHeader = Header;
            break;
        }
        ListEntry = ListEntry->Flink;
    }

    return(FoundHeader);

} // OmpFindIdInList



POM_HEADER
OmpFindNameInList(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Searches the specified list of objects for the given name.

Arguments:

    ListHead - Supplies the head of the object list.

    Name - Supplies the name of the object.

Return Value:

    A pointer to the specified object's OM_HEADER if it is found

    NULL if the given name was not found

Notes:

    This routine assumes the the critical section for the object type
    is held on entry.

--*/
{
    PLIST_ENTRY ListEntry;
    POM_HEADER Header;
    POM_HEADER FoundHeader = NULL;

    ListEntry = ListHead->Flink;
    while (ListEntry != ListHead) {
        Header = CONTAINING_RECORD(ListEntry, OM_HEADER, ListEntry);
        if (lstrcmpiW(Header->Name, Name) == 0) {
            FoundHeader = Header;
            break;
        }
        ListEntry = ListEntry->Flink;
    }

    return(FoundHeader);

} // OmpFindNameInList



POM_NOTIFY_RECORD
OmpFindNotifyCbInList(
    IN PLIST_ENTRY 			ListHead,
    IN OM_OBJECT_NOTIFYCB	pfnObjNotifyCb
    )

/*++

Routine Description:

    Searches the specified list of objects for the given name.

Arguments:

    ListHead - Supplies the head of the object list.

    pfnObjNotifyCb - Supplies the callback fn that we are looking
    	for.

Return Value:

    A pointer to the specified object's OM_NOTIFY_RECORD if it is found

    NULL if the given Id string was not found

Notes:

    This routine assumes the the critical section for the object type
    is held on entry.

--*/

{
    PLIST_ENTRY 		ListEntry;
    POM_NOTIFY_RECORD 	pNotifyRec;
    POM_NOTIFY_RECORD	pFoundNotifyRec = NULL;

    ListEntry = ListHead->Flink;
    while (ListEntry != ListHead) {
        pNotifyRec = CONTAINING_RECORD(ListEntry, OM_NOTIFY_RECORD, ListEntry);
        if (pNotifyRec->pfnObjNotifyCb == pfnObjNotifyCb)
        {
            pFoundNotifyRec = pNotifyRec;
            break;
        }
        ListEntry = ListEntry->Flink;
    }

    return(pFoundNotifyRec);

} // OmpFindNotifyCbInList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\om\omp.h ===
#ifndef _OMP_H
#define _OMP_H
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    omp.h

Abstract:

    Private data structures and procedure prototypes for
    the Object Manager subcomponent of the NT Cluster
    Service

Author:

    John Vert (jvert) 16-Feb-1996

Revision History:

--*/
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_OM


#define ENUM_GROW_SIZE    5
//
// Data structures for the ObjectTypes
//
extern POM_OBJECT_TYPE OmpObjectTypeTable[ObjectTypeMax];
extern CRITICAL_SECTION OmpObjectTypeLock;

//
// Macros
//


//
// Find the object type for an object
//

#define OmpObjectType(pObject) (((POM_HEADER)OmpObjectToHeader(pObject))->ObjectType)

//
// Dereference object header
//
#if OM_TRACE_OBJREF
DWORD
OmpDereferenceHeader(
    IN POM_HEADER Header
    );

#else
#define OmpDereferenceHeader(pOmHeader) (InterlockedDecrement(&(pOmHeader)->RefCount) == 0)
#endif

//
// Search object list.
//
POM_HEADER
OmpFindIdInList(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Id
    );

POM_HEADER
OmpFindNameInList(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Name
    );


POM_NOTIFY_RECORD
OmpFindNotifyCbInList(
    IN PLIST_ENTRY                      ListHead,
    IN OM_OBJECT_NOTIFYCB       lpfnObjNotifyCb
    );

//
// Enumerate object list.
//
typedef BOOL (*OMP_ENUM_LIST_ROUTINE)(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

VOID
OmpEnumerateList(
    IN PLIST_ENTRY ListHead,
    IN OMP_ENUM_LIST_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    );

DWORD OmpGetCbList(
    IN PVOID                pObject,
    OUT POM_NOTIFY_RECORD   *ppNotifyRecList,
    OUT LPDWORD             pdwCount
    );

//
// object logging routines
//

VOID
OmpOpenObjectLog(
    VOID
    );

VOID
OmpLogPrint(
    LPWSTR  FormatString,
    ...
    );

VOID
OmpLogStartRecord(
    VOID
    );

VOID
OmpLogStopRecord(
    VOID
    );

#endif //_OMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\vss\cvssclusterp.h ===
#pragma once

//++
//
// Copyright (c) 2001 Microsoft Corporation
//
// FACILITY:
//
//      Cluster Service
//
// MODULE DESCRIPTION:
//
//      Private header for Vss support within cluster service.
//
// ENVIRONMENT:
//
//      User mode NT Service.
//
// AUTHOR:
//
//      Conor Morrison
//
// CREATION DATE:
//
//      18-Apr-2001
//
// Revision History:
//
// X-1	CM		Conor Morrison        				18-Apr-2001
//      Initial version.
//--
#include "CVssCluster.h"

#define LOG_CURRENT_MODULE LOG_MODULE_VSSCLUS

// Global data for our instance of the class and boolean to say if we
// subscribed or not.  This will be used in cluster service.
//
PCVssWriterCluster g_pCVssWriterCluster = NULL;
bool g_bCVssWriterClusterSubscribed = FALSE;

// Our VSS_ID a.k.a GUID

// {41E12264-35D8-479b-8E5C-9B23D1DAD37E}
const VSS_ID g_VssIdCluster = 
    { 0x41e12264, 0x35d8, 0x479b, { 0x8e, 0x5c, 0x9b, 0x23, 0xd1, 0xda, 0xd3, 0x7e } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\vss\cvsscluster.cpp ===
#define _MODULE_VERSION_STR "X-1.3"
#define _MODULE_STR "CVssCluster"
#define _AUTHOR_STR "Conor Morrison"

#pragma comment (compiler)
#pragma comment (exestr, _MODULE_STR _MODULE_VERSION_STR)
#pragma comment (user, _MODULE_STR _MODULE_VERSION_STR " Compiled on " __DATE__ " at " __TIME__ " by " _AUTHOR_STR)

//++
//
// Copyright (c) 2000 Microsoft Corporation
//
// FACILITY:
//
//      CVssCluster
//
// MODULE DESCRIPTION:
//
//      Implements cluster support for Vss (i.e. NT backup).
//
// ENVIRONMENT:
//
//      User mode as part of an NT service.  Adheres to the following state
//      transition diagram for CVssWriter:
//
//                   OnBackupComplete
// Backup Complete <----------------IDLE -------------->Create Writer Metadata
//        |                          ^|^                         |
//        +--------------------------+|+-------------------------+
//                                    |
//                                    |OnBackupPrepare
//                                    |
//                                    |         OnAbort
//                              PREPARE BACKUP ---------> to IDLE
//                                    |
//                                    |OnPrepareSnapshot
//                                    |
//                                    |           OnAbort
//                              PREPARE SNAPSHOT ---------> to IDLE
//                                    |
//                                    |OnFreeze
//                                    |
//                                    |      OnAbort
//                                  FREEZE  ---------> to IDLE
//                                    |
//                                    |OnThaw
//                                    |
//                                    |    OnAbort
//                                  THAW  ---------> to IDLE
//    
//
// AUTHOR:
//
//      Conor Morrison
//
// CREATION DATE:
//
//      18-Apr-2001
//
// Revision History:
//
// X-1	CM		Conor Morrison        				18-Apr-2001
//      Initial version to address bug #367566.
//   .1 Set restore method to custom and reboot required to false.
//      Check for component selected or bootable system state in
//      OnPrepareSnapshot and ignore if not.  Add cleanup to Abort and
//      Thaw.  Fix bug in RemoveDirectoryTree.
//   .2 Incorporate first review comments: change caption to be the component
//      name.  Set bRestoreMetadata to false.  Remove extraneous tracing.
//      Release the interface in the while loop.  Cleanup after a non-cleanly
//      terminated backup.  This is done in OnPrepareSnapshot.  Tolerate
//      error_file_not_found at various places.
//   .3 More review comments.  Reset g_bDoBackup in the prepare routine.
//      SetWriterFailure in more places - any time we veto we should set this.
//--

extern "C" {
#include "service.h"
//CMCM! Mask build breaks.
#define _LMERRLOG_
#define _LMHLOGDEFINED_
#define _LMAUDIT_
#include "lm.h"                 // for SHARE_INFO_502
}
#include "CVssClusterp.h"

// Up the warning level to 4 - we can survive...
//
#pragma warning( push, 4 )

//
// Globals
//
UNICODE_STRING		g_ucsBackupPathLocal;
bool                g_bDoBackup; // Assume we are not enabled until we find out otherwise.

//
// Forward declarations for static functions.
//
static HRESULT StringAllocate( PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes );
static void StringFree( PUNICODE_STRING pucsString );
static void StringAppendString( PUNICODE_STRING pucsTarget, PWCHAR pwszSource );
static void StringAppendString( PUNICODE_STRING pucsTarget, PUNICODE_STRING pucsSource );
static HRESULT StringTruncate (PUNICODE_STRING pucsString, USHORT usSizeInChars);
static HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars);
static HRESULT StringCreateFromExpandedString( PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars);
static HRESULT DoClusterDatabaseBackup( void );
static HRESULT ConstructSecurityAttributes( PSECURITY_ATTRIBUTES  psaSecurityAttributes,
                                            BOOL                  bIncludeBackupOperator );
static VOID CleanupSecurityAttributes( PSECURITY_ATTRIBUTES psaSecurityAttributes );
static HRESULT CreateTargetDirectory( OUT UNICODE_STRING* pucsTarget );
static HRESULT CleanupTargetDirectory( LPCWSTR pwszTargetPath );
static HRESULT RemoveDirectoryTree (PUNICODE_STRING pucsDirectoryPath);

//
// Some useful macros.
//
#define LOGERROR( _hr, _func ) ClRtlLogPrint( LOG_CRITICAL, "VSS: Error: 0x%1!08lx! from: %2\n", (_hr), L#_func )

#ifdef DBG
#define LOGFUNCTIONENTRY( _name ) ClRtlLogPrint( LOG_NOISE, "VSS: Function: " #_name " Called.\n" )
#define LOGFUNCTIONEXIT( _name ) ClRtlLogPrint( LOG_NOISE, "VSS: Function: " #_name " Exiting.\n" )
#define LOGUNICODESTRING( _ustr ) ClRtlLogPrint( LOG_NOISE, "VSS: String %1 == %2\n", L#_ustr, (_ustr).Buffer );
#define LOGSTRING( _str ) ClRtlLogPrint( LOG_NOISE, "VSS: String %1 == %2\n", L#_str, _str );
#else
#define LOGFUNCTIONENTRY( _name ) 
#define LOGFUNCTIONEXIT( _name ) 
#define LOGUNICODESTRING( _ustr ) 
#define LOGSTRING( _str ) 
#endif

#define	GET_HR_FROM_BOOL(_bSucceed)	((_bSucceed)      ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define HandleInvalid(_Handle)      ((NULL == (_Handle)) || (INVALID_HANDLE_VALUE == (_Handle)))
#define GET_HR_FROM_HANDLE(_handle)	((!HandleInvalid(_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError( )))
#define GET_HR_FROM_POINTER(_ptr)	((NULL != (_ptr))          ? NOERROR : E_OUTOFMEMORY)

#define IS_VALID_PATH( _path ) ( ( ( pwszPathName[0] == DIR_SEP_CHAR )  && ( pwszPathName[1] == DIR_SEP_CHAR ) ) || \
                             ( isalpha( pwszPathName[0] ) && ( pwszPathName[1] == L':' ) && ( pwszPathName[2] == DIR_SEP_CHAR ) ) )

#define StringZero( _pucs ) ( (_pucs)->Buffer = NULL, (_pucs)->Length = 0, (_pucs)->MaximumLength = 0 )

//
// Defines that identify us as a product to VSS - these are the same as in the old shim
//
#define COMPONENT_NAME		L"Cluster Database"
#define APPLICATION_STRING	L"ClusterDatabase"
#define SHARE_NAME L"__NtBackup_cluster"

// Some borrowed defines from the shim stuff.
//
#ifndef DIR_SEP_STRING
#define DIR_SEP_STRING		L"\\"
#endif
#ifndef DIR_SEP_CHAR
#define DIR_SEP_CHAR		L'\\'
#endif

//
// Define some constants that are borrowed from the original shim.  These will
// be used to build the path to the directory in which the cluster files will
// be placed by the cluster backup.  TARGET_PATH gives this full directory.  In
// Identify we tell the backup app which directory we are using so it knows
// where to get the files from.
//
#define ROOT_REPAIR_DIR         L"%SystemRoot%\\Repair"
#define BACKUP_SUBDIR           L"\\Backup"
#define BOOTABLE_STATE_SUBDIR	L"\\BootableSystemState"

#define SERVICE_STATE_SUBDIR	L"\\ServiceState"

#define TARGET_PATH		ROOT_REPAIR_DIR BACKUP_SUBDIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING


//++
// DESCRIPTION:                         CreateIfNotExistAndSetAttributes
//
//      Create the directory specified by pucsTarget if it does not
//      already exist and give it the security attributes supplied.
//
// PARAMETERS:
//      pucsTarget - string for the directory to create.  Full path, possibly
//                   with %var%
//      lpSecurityAttributes - Pointer to security attributes to apply to
//                             directories created.
//      dwExtraAttributes - Additional attributes to apply to the directory.
//
// PRE-CONDITIONS:
//      None
//
// POST-CONDITIONS:
//      Directory created (or it already existed).
//
// RETURN VALUE:
//      S_OK - All went OK, directory created and set with attributes and
//             security supplied.
//      Error status from creating directory or setting attributes.  Note that
//      ALREADY_EXISTS is not returned if the directory already exists.
//      However, if it a FILE of the same name as pucsTarget exists then this
//      error can be returned.
//--
static HRESULT CreateIfNotExistAndSetAttributes( UNICODE_STRING*           pucsTarget,
                                                 IN LPSECURITY_ATTRIBUTES  lpSecurityAttributes,
                                                 IN DWORD                  dwExtraAttributes)
{
    LOGFUNCTIONENTRY( CreateIfNotExistAndSetAttributes );

    HRESULT hr = S_OK;
    
    // Create the directory
    //
    LOGUNICODESTRING( *pucsTarget );
    GET_HR_FROM_BOOL( CreateDirectoryW (pucsTarget->Buffer, lpSecurityAttributes ) );
    ClRtlLogPrint( LOG_NOISE, "VSS: CreateIfNotExistAndSetAttributes: CreateDirectory returned: 0x%1!08lx!\n", hr );
    if ( hr == HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ) {
        DWORD dwObjAttribs = GetFileAttributesW( pucsTarget->Buffer );
        if (( dwObjAttribs != 0xFFFFFFFF ) && ( dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY ))
            hr = S_OK;
    }
    // Note that we can fail with ALREADY_EXISTS if it is a file by the check above.
    //
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateDirectoryW );
        goto ErrorExit;
    }
    
    // Set the extra attributes
    //
    if ( dwExtraAttributes != 0 ) {
        GET_HR_FROM_BOOL( SetFileAttributesW (pucsTarget->Buffer, dwExtraAttributes ));
        if ( FAILED ( hr )) {
            LOGERROR( hr, SetFileAttributesW );
            goto ErrorExit;
        }
    }
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    LOGFUNCTIONEXIT( CreateIfNotExistAndSetAttributes );
    return hr;
}

//++
// DESCRIPTION:                         CreateTargetDirectory
//
//      Create a new target directory (hardcoded) and return it in
//      pucsTarget member variable if not NULL. It will create any
//      necessary.  Uses helper function that tolerates
//      ERROR_ALREADY_EXISTS.
//
// PARAMETERS:
//      pucsTarget - Address to receive unicode string giving path to
//                   directory.
//
// PRE-CONDITIONS:
//      pucsTarget must be all zeros.
//
// POST-CONDITIONS:
//      pucsTarget points to buffer containing dir string.  Memory was
//      allocated for this buffer.
//
// RETURN VALUE:
//      S_OK - all went well
//      Errors from creating directories or memory allocation failure.
//--
static HRESULT CreateTargetDirectory( OUT UNICODE_STRING* pucsTarget )
{
    LOGFUNCTIONENTRY( CreateTargetDirectory );
    
    HRESULT		hr = NOERROR;
    SECURITY_ATTRIBUTES	saSecurityAttributes, *psaSecurityAttributes=&saSecurityAttributes;
    SECURITY_DESCRIPTOR	sdSecurityDescriptor;
    bool		bSecurityAttributesConstructed = false;

    const DWORD dwExtraAttributes = 
        FILE_ATTRIBUTE_ARCHIVE 
        | FILE_ATTRIBUTE_HIDDEN  
        | FILE_ATTRIBUTE_SYSTEM  
        | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    
    //
    // We really want a no access acl on this directory but because of various
    // problems with the EventLog and ConfigDir writers we will settle for
    // admin or backup operator access only. The only possible accessor is
    // Backup which is supposed to have the SE_BACKUP_NAME priv which will
    // effectively bypass the ACL. No one else needs to see this stuff.
    //
    saSecurityAttributes.nLength              = sizeof( saSecurityAttributes );
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = false;

    hr = ConstructSecurityAttributes( &saSecurityAttributes, false );
    if ( FAILED( hr )) {
        LOGERROR( hr, ConstructSecurityAttributes );
        goto ErrorExit;
    }
    bSecurityAttributesConstructed = true;

    // OK, now we have attributes we can do the directories.
    //
    // First expand the Root, checking that our input is NULL.
    //
    CL_ASSERT( pucsTarget->Buffer == NULL );
    hr = StringCreateFromExpandedString( pucsTarget, ROOT_REPAIR_DIR, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromExpandedString );
        goto ErrorExit;
    }

    hr = CreateIfNotExistAndSetAttributes( pucsTarget, psaSecurityAttributes, dwExtraAttributes );
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateIfNotExistAndSetAttributes );
        goto ErrorExit;
    }
    
    StringAppendString( pucsTarget, BACKUP_SUBDIR );
    hr = CreateIfNotExistAndSetAttributes( pucsTarget, psaSecurityAttributes, dwExtraAttributes );
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateIfNotExistAndSetAttributes );
        goto ErrorExit;
    }

    StringAppendString( pucsTarget, BOOTABLE_STATE_SUBDIR );
    hr = CreateIfNotExistAndSetAttributes( pucsTarget, psaSecurityAttributes, dwExtraAttributes );
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateIfNotExistAndSetAttributes );
        goto ErrorExit;
    }

    StringAppendString( pucsTarget, DIR_SEP_STRING APPLICATION_STRING );
    hr = CreateIfNotExistAndSetAttributes( pucsTarget, psaSecurityAttributes, dwExtraAttributes );
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateIfNotExistAndSetAttributes );
        goto ErrorExit;
    }

    // At this point we have TARGET_PATH created.
    //    
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
    (void) CleanupTargetDirectory( pucsTarget->Buffer );
    
ret:
    // In all cases we don't need the security attributes any more.
    //
    if ( bSecurityAttributesConstructed )
        CleanupSecurityAttributes( &saSecurityAttributes );
    
    return hr ;
}

//
// There are only some valid statuses to pass to SetWriterFailure.  These are
// listed below.  For now we just return VSS_E_WRITEERROR_NONRETRYABLE. We
// could perhaps switch on the status and return something different depending
// on hr.
//      VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT The snapshot contains only a
//      subset of the volumes needed to correctly back up an application
//      component.
//      VSS_E_WRITERERROR_NONRETRYABLE The writer failed due to an error that
//      would likely occur if another snapshot is created.
//      VSS_E_WRITERERROR_OUTRESOURCES The writer failed due to a resource
//      allocation error.
//      VSS_E_WRITERERROR_RETRYABLE The writer failed due to an error that would
//      likely not occur if another snapshot is created.
//      VSS_E_WRITERERROR_TIMEOUT The writer could not complete the snapshot
//      creation process due to a time-out between the freeze and thaw states.

#if defined DBG
#define SETWRITERFAILURE( ) {               \
    HRESULT __hrTmp = SetWriterFailure( VSS_E_WRITERERROR_NONRETRYABLE );  \
    if ( FAILED( __hrTmp )) ClRtlLogPrint( LOG_CRITICAL, "VSS: Error from SetWriterFailure: %1!u!\n", (__hrTmp)); \
    CL_ASSERT( !FAILED( __hrTmp ));             \
}
#else
#define SETWRITERFAILURE( ) { \
    (void) SetWriterFailure( VSS_E_WRITERERROR_NONRETRYABLE );  \
}
#endif

#define NameIsDotOrDotDot(_ptszName)           \
    (( L'.'  == (_ptszName) [0])               \
     && ((L'\0' == (_ptszName) [1])            \
         || ((L'.'  == (_ptszName) [1])        \
             && (L'\0' == (_ptszName) [2]))))

//++
// DESCRIPTION:                         CVssWriterCluster::OnIdentify
//
//      Callback when a request for metadata comes in.  This routine
//      identifies this applications special needs to the backup
//      utility.
//
// PARAMETERS:
//      IVssCreateWriterMetadata - Interface for some methods we can call.
//
// PRE-CONDITIONS:
//      Called from Idle state
//
// POST-CONDITIONS:
//      Backup returns to idle state.
//
// RETURN VALUE:
//      true - continue with snapshot operation.
//      false - Veto the snapshot creation.
//--
bool STDMETHODCALLTYPE CVssWriterCluster::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
{
    LOGFUNCTIONENTRY( OnIdentify );

    HRESULT     hr = S_OK;
    bool        bRet = true;
 
    ClRtlLogPrint( LOG_NOISE, "VSS: OnIdentify.  CVssCluster.cpp version %1 Add Component %2\n",
                   _MODULE_VERSION_STR, COMPONENT_NAME );

    // Add ourselves to the components.
    //
    hr = pMetadata->AddComponent (VSS_CT_FILEGROUP, // VSS_COMPONENT_TYPE enumeration value. 
                                  NULL,             // Pointer to a string containing the logical path of the DB or file group. 
                                  COMPONENT_NAME,   // Pointer to a string containing the name of the component. 
                                  COMPONENT_NAME,   // Pointer to a string containing the description of the component.
                                  NULL,             // Pointer to a bitmap of the icon representing the database (for UI)
                                  0,                // Number of bytes in bitmap.
                                  false,             // bRestoreMetadata - Boolean is true if there is writer metadata associated
                                                    // with the backup of the component and false if not.
                                  false,            // bNotifyOnBackupComplete 
                                  false);           // bSelectable - true if the component can be selectively backed up.
    if ( FAILED( hr )) {
        LOGERROR( hr, IVssCreateWriterMetadata::AddComponent );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }
    ClRtlLogPrint( LOG_NOISE, "VSS: OnIdentify.  Add Files To File Group target path: %1\n", TARGET_PATH );
    hr= pMetadata->AddFilesToFileGroup (NULL,
                                        COMPONENT_NAME,
                                        TARGET_PATH,
                                        L"*",
                                        true,
                                        NULL);
    if ( FAILED ( hr )) {
        LOGERROR( hr, IVssCreateWriterMetadata::AddFilesToFileGroup );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }
    
    // If we decide to go for copying the checkpoint file to the
    // CLUSDB for restore then we need to setup an alternate mapping.
    //
    //      IVssCreateWriterMetadata::AddAlternateLocationMapping
    //  [This is preliminary documentation and subject to change.] 
    //
    //  The AddAlternateLocationMapping method creates an alternate location mapping.
    //
    //  HRESULT AddAlternateLocationMapping(
    //    LPCWSTR wszPath,
    //    LPCWSTR wszFilespec,
    //    bool bRecursive,
    //    LPCWSTR wszDestination
    //  );


    // Now, set the restore method to custom.  This is because we need
    // special actions for restore.
    //
    hr = pMetadata->SetRestoreMethod( VSS_RME_CUSTOM,   // VSS_RESTOREMETHOD_ENUM Method,
                                      L"",              // LPCWSTR wszService,
                                      NULL,             // LPCWSTR wszUserProcedure,
                                      VSS_WRE_NEVER,    // VSS_WRITERRESTORE_ENUM wreWriterRestore,
                                      false             // bool bRebootRequired
                                      );
    // wszUserProcedure [out] String containing the URL of an HTML or
    // XML document describing to the user how the restore is to be
    // performed.
    if ( FAILED ( hr )) {
        LOGERROR( hr, IVssCreateWriterMetadata::SetRestoreMethod );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }

    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
    CL_ASSERT( bRet == false );
    SETWRITERFAILURE( );
ret:
    return bRet;
}

// callback for prepare backup event
//
bool STDMETHODCALLTYPE CVssWriterCluster::OnPrepareBackup(IN IVssWriterComponents *pComponent)
{
    LOGFUNCTIONENTRY( OnPrepareBackup );
    bool bRet = true;
    UINT cComponents = 0;
    IVssComponent* pMyComponent = NULL;
    BSTR pwszName;
    
    g_bDoBackup = false;         // Assume false until the loop below or IsBootableSystemStateBackedUp tells us otherwise.

    HRESULT hr = pComponent->GetComponentCount( &cComponents );
    ClRtlLogPrint( LOG_NOISE, "VSS: GetComponentCount returned hr: 0x%1!08lx! cComponents: %2!u!\n", hr, cComponents );
    if ( FAILED( hr )) {
        LOGERROR( hr, GetComponentCount );
        bRet = false;
        goto ErrorExit;
    }
    
    // Now, loop over all the components and see if we are there.
    //
    for ( UINT iComponent = 0; !g_bDoBackup && iComponent < cComponents; ++iComponent ) {
        hr = pComponent->GetComponent( iComponent, &pMyComponent );
        if ( FAILED( hr )) {
            ClRtlLogPrint( LOG_CRITICAL, "VSS: Failed to get Component: %1!u! hr: 0x%2!08lx!\n", iComponent, hr );
            bRet = false;
            goto ErrorExit;
        }
        ClRtlLogPrint( LOG_CRITICAL, "VSS: Got Component: 0x%1!08lx!\n", pMyComponent );

        // Now check the name.
        //
        hr = pMyComponent->GetComponentName( &pwszName );
        if ( FAILED( hr )) {
            ClRtlLogPrint( LOG_CRITICAL, "VSS: Failed to get Component Name hr: 0x%1!08lx!\n", hr );
            bRet = false;
            pMyComponent->Release( );
            goto ErrorExit;
        }

        ClRtlLogPrint( LOG_CRITICAL, "VSS: Got component: %1\n", pwszName );

        if ( wcscmp ( pwszName, COMPONENT_NAME ) == 0 )
            g_bDoBackup = true;

        SysFreeString( pwszName );
        pMyComponent->Release( );
    }
        
    // OK, explicitly selected component count is 0 but we can be part
    // of a backup of bootable system state so check for that too.
    //
    if ( IsBootableSystemStateBackedUp( )) {
        ClRtlLogPrint( LOG_NOISE, "VSS: IsBootableSystemStateBackedUp returned true\n" );
        g_bDoBackup = true;
    }
    goto ret;

ErrorExit:
    CL_ASSERT( FAILED( hr ));
    CL_ASSERT( bRet == false );
    SETWRITERFAILURE( );
ret:
    LOGFUNCTIONEXIT( OnPrepareBackup );
    return bRet;
}

//++
// DESCRIPTION:                         CVssWriterCluster::OnPrepareSnapshot
//
//      Callback for prepare snapshot event.  Actually makes the call to backup
//      the cluster.  Uses the target path declared in Identify so that the
//      ntbackup will pickup our files for us.  Before doing anything the
//      directory is cleared out (if it exists) and the share deleted (if it
//      exists).
//
// PARAMETERS:
//      none
//
// PRE-CONDITIONS:
//      OnPrepareBackup was already called.
//
// POST-CONDITIONS: 
//      The cluster database is backed up and the data copied to another
//      location for backup to save.
//
// RETURN VALUE:
//      true - continue with snapshot operation.
//      false - Veto the snapshot creation.
//--
bool STDMETHODCALLTYPE CVssWriterCluster::OnPrepareSnapshot()
{
    NET_API_STATUS NetStatus = NERR_Success;
    HRESULT	hr = S_OK;
    bool    bRet = true;
    UNICODE_STRING ucsBackupDir;

    LOGFUNCTIONENTRY( OnPrepareSnapshot );
    if ( g_bDoBackup == false )
        goto ret;

    // Delete the share if it exists.  Tolerate errors but warns for anything
    // except NERR_NetNameNotFound.  Break if debug.
    //
    NetStatus = NetShareDel( NULL, SHARE_NAME, 0 );
    CL_ASSERT( NetStatus == NERR_Success || NetStatus == NERR_NetNameNotFound );
    if ( NetStatus != NERR_Success && NetStatus != NERR_NetNameNotFound ) {
        ClRtlLogPrint( LOG_UNUSUAL, "VSS: OnPrepareSnapshot: Tolerating error: %1!u! from NetShareDel\n", NetStatus );
        NetStatus = NERR_Success;
    }

    // Delete the directory if it exists.  This can only be the case if we
    // prematurely exited a previous backup.
    //
    // First expand the Root, checking that our input is NULL.
    //
    StringZero( &ucsBackupDir );
    hr = StringCreateFromExpandedString( &ucsBackupDir, ROOT_REPAIR_DIR, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromExpandedString );
        goto ErrorExit;
    }

    StringAppendString( &ucsBackupDir, BACKUP_SUBDIR );
    StringAppendString( &ucsBackupDir, BOOTABLE_STATE_SUBDIR );
    StringAppendString( &ucsBackupDir, DIR_SEP_STRING APPLICATION_STRING );

    ClRtlLogPrint( LOG_NOISE, "VSS: OnPrepareSnapshot: Cleaning up target directory: %1\n", ucsBackupDir.Buffer );
    hr = CleanupTargetDirectory( ucsBackupDir.Buffer );
    if ( FAILED( hr ) ) {
        ClRtlLogPrint( LOG_UNUSUAL, "VSS: Tolerating error 0x%1!08lx! from CleanupTargetDirectory.\n", hr );
        hr = S_OK;          // tolerate this failure.
    }
    StringFree( &ucsBackupDir );

    hr = DoClusterDatabaseBackup( );
    if ( FAILED( hr ) ) {
        LOGERROR( hr, DoClusterDatabaseBackup );
        SETWRITERFAILURE( );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
    CL_ASSERT( bRet == false );
    SETWRITERFAILURE( );
ret:
    LOGFUNCTIONEXIT( OnPrepareSnapshot );
    return bRet;
}

// callback for freeze event
//
bool STDMETHODCALLTYPE CVssWriterCluster::OnFreeze()
{
    LOGFUNCTIONENTRY( OnFreeze );
    LOGFUNCTIONEXIT( OnFreeze );
    return true;
}

// callback for thaw event
//
bool STDMETHODCALLTYPE CVssWriterCluster::OnThaw()
{
    LOGFUNCTIONENTRY( OnThaw );
    if ( g_bDoBackup == false )
        goto ret;

    if ( g_ucsBackupPathLocal.Buffer ) {

        ClRtlLogPrint( LOG_NOISE, "VSS: Cleaning up target directory: %1\n", g_ucsBackupPathLocal.Buffer );
        HRESULT hr = CleanupTargetDirectory( g_ucsBackupPathLocal.Buffer );
        if ( FAILED( hr ) ) {
            LOGERROR( hr, CVssWriterCluster::OnThaw );
            ClRtlLogPrint( LOG_CRITICAL, "VSS: 0x%1!08lx! from CleanupTargetDirectory. Mapping to S_OK and continuing\n", hr );
            hr = S_OK;          // tolerate this failure.
        }
    }

    // Free the buffer if non-NULL.
    //
    StringFree ( &g_ucsBackupPathLocal );
    
    LOGFUNCTIONEXIT( OnThaw );
ret:
    return true;
}

// callback if current sequence is aborted
//
bool STDMETHODCALLTYPE CVssWriterCluster::OnAbort()
{
    LOGFUNCTIONENTRY( OnAbort );
    bool bRet = OnThaw( );
    LOGFUNCTIONEXIT( OnAbort );
    return bRet;
}

//++
// DESCRIPTION:                         DoClusterDatabaseBackup
//
//      Perform the backup of the cluster database.  This function wraps
//      FmBackupClusterDatabase which does the right thing to do the cluster
//      backup.  This function first creates a directory that will serve as the
//      destination for the backup.  Next it creates a network share to point
//      to this directory and starts the cluster backup.  After this is done it
//      cleans up.
//
// PARAMETERS:
//      none
//
// PRE-CONDITIONS:
//      . Called only from CVssWriterCluster::OnPrepareSnapshot.
//      . We must be the only call to backup in progress on this machine (the
//      share names will clash otherwise and clustering may not behave well
//      with multiple FmBackupClusterDatabase calls it the same time).
//
// POST-CONDITIONS:
//      Cluster database backed up to another location, ready for the backup tool to copy.
//
// RETURN VALUE:
//      S_OK  - all went well.
//      Error status from creating directories or net shares or from cluster backup.
//--
static HRESULT DoClusterDatabaseBackup( )
{
    LOGFUNCTIONENTRY( DoClusterDatabaseBackup );

    HRESULT             hr             = S_OK;
    bool                bNetShareAdded = false;
    SHARE_INFO_502		ShareInfo;
    UNICODE_STRING		ucsComputerName;
    UNICODE_STRING		ucsBackupPathNetwork;
    NET_API_STATUS      NetStatus;

    StringZero( &ucsComputerName );
    StringZero( &g_ucsBackupPathLocal );
    StringZero( &ucsBackupPathNetwork );

    // Create the directories and set the attributes and security and stuff.
    // Set g_ucsBackupPathLocal to the directory created.
    //
    hr = CreateTargetDirectory( &g_ucsBackupPathLocal );
    if ( FAILED (hr )) {
        LOGERROR( hr, CreateTargetDirectory );
        goto ErrorExit;
    }

#ifdef DBG
    {
        // Check that the directory does exist.
        //
        DWORD dwFileAttributes = GetFileAttributesW( g_ucsBackupPathLocal.Buffer );
        hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
        ClRtlLogPrint( LOG_NOISE, "VSS: GetFileAttributes(1) returned 0x%1!08lx!  for path: %2\n", 
                       hr, g_ucsBackupPathLocal.Buffer );    
    }
#endif
    hr = StringAllocate (&ucsComputerName,
                         (MAX_COMPUTERNAME_LENGTH * sizeof (WCHAR)) + sizeof (UNICODE_NULL));
    
    if ( FAILED( hr )) {
        LOGERROR( hr, StringAllocate );
        goto ErrorExit;
    }        

    DWORD	dwNameLength = ucsComputerName.MaximumLength / sizeof (WCHAR);
    hr = GET_HR_FROM_BOOL( GetComputerNameW( ucsComputerName.Buffer, &dwNameLength ));
    if ( FAILED ( hr )) {
        LOGERROR( hr, GetComputerNameW );
        goto ErrorExit;
    }
    
    ucsComputerName.Length = (USHORT) (dwNameLength * sizeof (WCHAR));

    hr = StringAllocate (&ucsBackupPathNetwork,
                         (USHORT) (sizeof (L'\\')
                                   + sizeof (L'\\')
                                   + ucsComputerName.Length
                                   + sizeof (L'\\')
                                   + ( wcslen( SHARE_NAME ) * sizeof( WCHAR ) )
                                   + sizeof (UNICODE_NULL)));
    if ( FAILED ( hr )) {
        LOGERROR( hr, GetComputerNameW );
        goto ErrorExit;
    }

    ClRtlLogPrint( LOG_NOISE, "VSS: backup path network size: %1!u!\n", ucsBackupPathNetwork.Length );

    //
    // Should we uniquify the directory name at all here
    // to cater for the possiblity that we may be involved
    // in more than one snapshot at a time?
    //
    StringAppendString( &ucsBackupPathNetwork, L"\\\\" );
    StringAppendString( &ucsBackupPathNetwork, &ucsComputerName );
    StringAppendString( &ucsBackupPathNetwork, L"\\" );
    StringAppendString( &ucsBackupPathNetwork, SHARE_NAME );

    ClRtlLogPrint( LOG_NOISE, "VSS: backup path network: %1\n", ucsBackupPathNetwork.Buffer );

    ZeroMemory( &ShareInfo, sizeof( ShareInfo ));

    ShareInfo.shi502_netname     = SHARE_NAME;
    ShareInfo.shi502_type        = STYPE_DISKTREE;
    ShareInfo.shi502_permissions = ACCESS_READ | ACCESS_WRITE | ACCESS_CREATE;
    ShareInfo.shi502_max_uses    = 1;
    ShareInfo.shi502_path        = g_ucsBackupPathLocal.Buffer;

#ifdef DBG
    {
        // Check that the directory does exist.
        //
        DWORD dwFileAttributes = GetFileAttributesW( g_ucsBackupPathLocal.Buffer );
        hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
        ClRtlLogPrint( LOG_NOISE, "VSS: GetFileAttributes(2) returned 0x%1!08lx!  for path: %2\n", 
                       hr, g_ucsBackupPathLocal.Buffer );    
    }
#endif

    //
    // Make sure to try to delete the share first in case for some reason it exists.
    //
    NetStatus = NetShareDel( NULL, SHARE_NAME, 0 );
    ClRtlLogPrint( LOG_NOISE, "VSS: NetShareDel returned: %1!u!\n", NetStatus );
    if ( NetStatus == NERR_NetNameNotFound )
        NetStatus = NERR_Success;
    CL_ASSERT( NetStatus == NERR_Success );

#ifdef DBG
    {
        // Check that the directory does exist.
        //
        DWORD dwFileAttributes = GetFileAttributesW( g_ucsBackupPathLocal.Buffer );
        hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
        ClRtlLogPrint( LOG_NOISE, "VSS: GetFileAttributes(3) returned 0x%1!08lx!  for path: %2\n", 
                       hr, g_ucsBackupPathLocal.Buffer );    
    }
#endif

    ClRtlLogPrint( LOG_NOISE, "VSS: NetShareAdd: Adding share: %1 with path: %2\n", SHARE_NAME, g_ucsBackupPathLocal.Buffer );

    NetStatus = NetShareAdd( NULL, 502, (LPBYTE)(&ShareInfo), NULL );
    ClRtlLogPrint( LOG_NOISE, "VSS: NetShareAdd completed: %1!u!\n", NetStatus );
    if ( NetStatus != NERR_Success ) {
        LOGERROR( NetStatus, NetShareAdd );
        if ( NetStatus == NERR_DuplicateShare ) {
            ClRtlLogPrint( LOG_NOISE, "VSS: Mapping NERR_DuplicateShare to success\n" );
            NetStatus = NERR_Success;
        } else {
            hr = HRESULT_FROM_WIN32( NetStatus );
            goto ErrorExit;
        }
    }
    bNetShareAdded = true;

#ifdef DBG
    {
        // Check that the directory does exist.
        //
        DWORD dwFileAttributes = GetFileAttributesW( g_ucsBackupPathLocal.Buffer );
        hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
        ClRtlLogPrint( LOG_NOISE, "VSS: GetFileAttributes returned 0x%1!08lx!  for path: %2\n", 
                       hr, g_ucsBackupPathLocal.Buffer );    
    }
#endif

    // If we are not logging to the quorum log then we don't do the backup.
    //
    if ( CsNoQuorumLogging || CsUserTurnedOffQuorumLogging ) {
        ClRtlLogPrint( LOG_NOISE, "VSS: Quorum logging is turned off.  Not attempting backup.\n" );
        //
        // CMCM!
        // We could opt to take a checkpoint and then setup alternate
        // path to ensure it is copied over CLUSDB on restore.
        //
        hr = S_OK;
    } else {
        ClRtlLogPrint( LOG_NOISE, "VSS: Calling FmBackupClusterDatabase with path: %1\n", ucsBackupPathNetwork.Buffer );

        DWORD dwStatus = FmBackupClusterDatabase( ucsBackupPathNetwork.Buffer );
        hr = HRESULT_FROM_WIN32( dwStatus );
        ClRtlLogPrint( LOG_NOISE, "VSS: FmBackupClusterDatabase completed. hr: 0x%1!08lx! \n", hr );
        if ( FAILED( hr ) ) {
            LOGERROR( hr, FmBackupClusterDatabase );
            goto ErrorExit;
        }
    }
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
#ifdef DBG
    ClRtlLogPrint( LOG_NOISE, "VSS:\n" );
    ClRtlLogPrint( LOG_NOISE, "VSS: DEBUG - sleeping for 30s.  This would be a good time to test killing backup in progress...\n" );
    ClRtlLogPrint( LOG_NOISE, "VSS:\n" );
    Sleep( 30*1000 );
#endif

    // Common cleanup for success or failure.
    //
    if ( bNetShareAdded ) {
        NetStatus = NetShareDel (NULL, SHARE_NAME, 0);
        ClRtlLogPrint( LOG_NOISE, "VSS: NetShareDel returned: %1!u!\n", NetStatus );
        if ( NetStatus == NERR_NetNameNotFound )
            NetStatus = NERR_Success;
        CL_ASSERT( NetStatus == NERR_Success );
    }

    // Cleanup strings but leave the local path so we can cleanup the files later.
    // 
    StringFree( &ucsComputerName );
    StringFree( &ucsBackupPathNetwork );

    LOGFUNCTIONEXIT( DoClusterDatabaseBackup );
    return hr;
}

//++
// DESCRIPTION:                         ConstructSecurityAttributes
//
//      Routines to construct and cleanup a security descriptor which can be
//      applied to limit access to an object to member of either the
//      Administrators or Backup Operators group.
//
// PARAMETERS:
//      psaSecurityAttributes - Pointer to a SecurityAttributes structure which
//                              has already been setup to point to a blank
//                              security descriptor.
//      bIncludeBackupOperator - Whether or not to include an ACE to grant
//                               BackupOperator access
//
// PRE-CONDITIONS:
//      None.
//
// POST-CONDITIONS:
//      Security attributes created that are suitable for backup directory
//
// RETURN VALUE:
//      S_OK - Attributes created OK.
//      Error from setting up attributes or SID or ACL.
//--
static HRESULT ConstructSecurityAttributes( PSECURITY_ATTRIBUTES  psaSecurityAttributes,
                                            BOOL                  bIncludeBackupOperator )
{
    HRESULT			hr             = NOERROR;
    DWORD			dwStatus;
    DWORD			dwAccessMask         = FILE_ALL_ACCESS;
    PSID			psidBackupOperators  = NULL;
    PSID			psidAdministrators   = NULL;
    PACL			paclDiscretionaryAcl = NULL;
    SID_IDENTIFIER_AUTHORITY	sidNtAuthority       = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS		eaExplicitAccess [2];
    //
    // Initialise the security descriptor.
    //
    hr = GET_HR_FROM_BOOL( InitializeSecurityDescriptor( psaSecurityAttributes->lpSecurityDescriptor,
                                                         SECURITY_DESCRIPTOR_REVISION ));
    if ( FAILED( hr )) {
        LOGERROR( hr, InitializeSecurityDescriptor );
        goto ErrorExit;
    }

    if ( bIncludeBackupOperator ) {
        //
        // Create a SID for the Backup Operators group.
        //
        hr = GET_HR_FROM_BOOL( AllocateAndInitializeSid( &sidNtAuthority,
                                                         2,
                                                         SECURITY_BUILTIN_DOMAIN_RID,
                                                         DOMAIN_ALIAS_RID_BACKUP_OPS,
                                                         0, 0, 0, 0, 0, 0,
                                                         &psidBackupOperators ));
        if ( FAILED( hr )) {
            LOGERROR( hr, AllocateAndInitializeSid );
            goto ErrorExit;
        }
    }
    //
    // Create a SID for the Administrators group.
    //
    hr = GET_HR_FROM_BOOL( AllocateAndInitializeSid( &sidNtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &psidAdministrators ));
    if ( FAILED( hr )) {
        LOGERROR( hr, InitializeSecurityDescriptor );
        goto ErrorExit;
    }

    //
    // Initialize the array of EXPLICIT_ACCESS structures for an
    // ACEs we are setting.
    //
    // The first ACE allows the Backup Operators group full access
    // and the second, allowa the Administrators group full
    // access.
    //
    eaExplicitAccess[0].grfAccessPermissions             = dwAccessMask;
    eaExplicitAccess[0].grfAccessMode                    = SET_ACCESS;
    eaExplicitAccess[0].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    eaExplicitAccess[0].Trustee.pMultipleTrustee         = NULL;
    eaExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    eaExplicitAccess[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
    eaExplicitAccess[0].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
    eaExplicitAccess[0].Trustee.ptstrName                =( LPTSTR ) psidAdministrators;
        
    if ( bIncludeBackupOperator ) {
        eaExplicitAccess[1].grfAccessPermissions             = dwAccessMask;
        eaExplicitAccess[1].grfAccessMode                    = SET_ACCESS;
        eaExplicitAccess[1].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        eaExplicitAccess[1].Trustee.pMultipleTrustee         = NULL;
        eaExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
        eaExplicitAccess[1].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
        eaExplicitAccess[1].Trustee.ptstrName                =( LPTSTR ) psidBackupOperators;
    }

    //
    // Create a new ACL that contains the new ACEs.
    //
    dwStatus = SetEntriesInAcl( bIncludeBackupOperator ? 2 : 1,
                                eaExplicitAccess,
                                NULL,
                                &paclDiscretionaryAcl );
    hr = HRESULT_FROM_WIN32( dwStatus );
    if ( FAILED( hr )) {
        LOGERROR( hr, SetEntriesInAcl );
        goto ErrorExit;
    }

    //
    // Add the ACL to the security descriptor.
    //
    hr = GET_HR_FROM_BOOL( SetSecurityDescriptorDacl( psaSecurityAttributes->lpSecurityDescriptor,
                                                      true,
                                                      paclDiscretionaryAcl,
                                                      false ));
    if ( FAILED( hr )) {
        LOGERROR( hr, SetSecurityDescriptorDacl );
        goto ErrorExit;
    }

    paclDiscretionaryAcl = NULL;
    goto ret;

ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    // Cleanup (some may be NULL)
    
    FreeSid( psidAdministrators );
    FreeSid( psidBackupOperators );
    LocalFree( paclDiscretionaryAcl );    
    return hr;
}


//++
// DESCRIPTION:                         CleanupSecurityAttributes
//
//      Deallocate the ACL if present with the security attributes.
//
// PARAMETERS:
//      psaSecurityAttributes - Pointer to a SecurityAttributes structure which
//                              has already been setup to point to a blank
//                              security descriptor.
//
// PRE-CONDITIONS:
//      psaSecurityAttributes points to security attributes as allocated by
//      ConstructSecurityAttributes.
//
// POST-CONDITIONS:
//      Memory freed if it was in use.
//
// RETURN VALUE:
//      None.
//--
static VOID CleanupSecurityAttributes( PSECURITY_ATTRIBUTES psaSecurityAttributes )
{
    BOOL	bDaclPresent         = false;
    BOOL	bDaclDefaulted       = true;
    PACL	paclDiscretionaryAcl = NULL;

    BOOL bSucceeded = GetSecurityDescriptorDacl( psaSecurityAttributes->lpSecurityDescriptor,
                                                 &bDaclPresent,
                                                 &paclDiscretionaryAcl,
                                                 &bDaclDefaulted );

    if ( bSucceeded && bDaclPresent && !bDaclDefaulted && ( paclDiscretionaryAcl != NULL )) {

        LocalFree( paclDiscretionaryAcl );
    }
}

//++
// DESCRIPTION:                         CleanupTargetDirectory
//
//      Deletes all the files present in the directory pointed at by the target
//      path member variable if not NULL. It will also remove the target
//      directory itself, eg for a target path of c:\dir1\dir2 all files under
//      dir2 will be removed and then dir2 itself will be deleted.
//
// PARAMETERS:
//      pwszTargetPath - full path to the directory to cleanup.
//
// PRE-CONDITIONS:
//      pwszTargetPath non NULL.
//
// POST-CONDITIONS:
//      Directory and contained files deleted.
//
// RETURN VALUE:
//      S_OK - Directory and contained files all cleaned up OK.
//      Error status from RemoveDirectoryTree or from GetFileAttributesW
//--
static HRESULT CleanupTargetDirectory( LPCWSTR pwszTargetPath )
{
    LOGFUNCTIONENTRY( CleanupTargetDirectory );

    HRESULT		hr         = NOERROR;
    DWORD		dwFileAttributes = 0;
    BOOL		bSucceeded;
    WCHAR		wszTempBuffer [50];
    UNICODE_STRING	ucsTargetPath;
    UNICODE_STRING	ucsTargetPathAlternateName;

    CL_ASSERT( pwszTargetPath != NULL );

    StringZero( &ucsTargetPath );
    StringZero( &ucsTargetPathAlternateName );

    //
    // Create strings with extra space for appending onto later.
    //
    hr = StringCreateFromExpandedString( &ucsTargetPath, pwszTargetPath, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromExpandedString );
        goto ErrorExit;
    }

    hr = StringCreateFromString( &ucsTargetPathAlternateName, &ucsTargetPath, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromString );
        goto ErrorExit;
    }        

    dwFileAttributes = GetFileAttributesW( ucsTargetPath.Buffer );
    hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
    if (( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND )) 
        || ( hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ))) {
        
		hr         = NOERROR;
		dwFileAttributes = 0;
    }

    if ( FAILED( hr )) {
        LOGERROR( hr, GetFileAttributesW );
        goto ErrorExit;
    }

    //
    // If there is a file there then blow it away, or if it's
    // a directory, blow it and all it's contents away. This
    // is our directory and no one but us gets to play there.
    // The random rename directory could exist but it's only for cleanup anyway...
    //
    hr = RemoveDirectoryTree( &ucsTargetPath );
    if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ))
        hr = S_OK;
    if ( FAILED( hr )) {
        srand( (unsigned) GetTickCount( ));
        _itow( rand (), wszTempBuffer, 16 );
        StringAppendString( &ucsTargetPathAlternateName, wszTempBuffer );
        bSucceeded = MoveFileW( ucsTargetPath.Buffer, ucsTargetPathAlternateName.Buffer );
        if (bSucceeded) {
			ClRtlLogPrint( LOG_UNUSUAL, "VSS: CleanupTargetDirectory failed to delete %1 with hr: 0x%2!08lx! so renamed to %3\n",
                           ucsTargetPath.Buffer,
                           hr,
                           ucsTargetPathAlternateName.Buffer );
        } else {
			ClRtlLogPrint( LOG_UNUSUAL, "VSS: CleanupTargetDirectory failed to delete %1 with hr: 0x%2!08lx!"
                           " failed to rename to %3 with status 0x%4!08lx!\n",
                           ucsTargetPath.Buffer,
                           hr,
                           ucsTargetPathAlternateName.Buffer,
                           GET_HR_FROM_BOOL (bSucceeded) );
        }
	}
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    StringFree( &ucsTargetPathAlternateName );
    StringFree( &ucsTargetPath );
    LOGFUNCTIONEXIT( CleanupTargetDirectory );
    return hr;
}

//++
// DESCRIPTION:                         RemoveDirectoryTree
//
//      Deletes all the sub-directories and files in the specified directory
//      and then deletes the directory itself.
//
// PARAMETERS:
//      pucsDirectoryPath - pointer to the directory
//
// PRE-CONDITIONS:
//      Called only from CleanupTargetDirectory
//
// POST-CONDITIONS:
//      Directory tree deleted.
//
// RETURN VALUE:
//      S_OK - Directory tree deleted.
//      Error status from deleting directory or from allocating strings.
//--
static HRESULT RemoveDirectoryTree( PUNICODE_STRING pucsDirectoryPath )
{
    LOGFUNCTIONENTRY( RemoveDirectoryTree );

    HRESULT		hr                = NOERROR;
    HANDLE		hFileScan               = INVALID_HANDLE_VALUE;
    DWORD		dwSubDirectoriesEntered = 0;
    USHORT		usCurrentPathCursor     = 0;
    PWCHAR		pwchLastSlash           = NULL;
    bool		bContinue               = true;
    UNICODE_STRING	ucsCurrentPath;
    WIN32_FIND_DATAW	FileFindData;

    StringZero (&ucsCurrentPath);
    
    LOGUNICODESTRING( *pucsDirectoryPath );
    
    // Create the string with enough extra characters to allow all the
    // appending later on!
    //
	hr = StringCreateFromString (&ucsCurrentPath, pucsDirectoryPath, MAX_PATH);
    if ( FAILED ( hr )) {
        LOGERROR( hr, StringCreateFromString );
        goto ErrorExit;
    }
    
    pwchLastSlash = wcsrchr (ucsCurrentPath.Buffer, DIR_SEP_CHAR);
    usCurrentPathCursor = (USHORT)(pwchLastSlash - ucsCurrentPath.Buffer) + 1;

    while ( SUCCEEDED( hr ) && bContinue ) {
        if ( HandleInvalid( hFileScan )) {
            //
            // No valid scan handle so start a new scan
            //
            ClRtlLogPrint( LOG_NOISE, "VSS: Starting scan: %1\n", ucsCurrentPath.Buffer );
            hFileScan = FindFirstFileW( ucsCurrentPath.Buffer, &FileFindData );
            hr = GET_HR_FROM_HANDLE( hFileScan );
            if ( SUCCEEDED( hr )) {
                StringTruncate( &ucsCurrentPath, usCurrentPathCursor );
                StringAppendString( &ucsCurrentPath, FileFindData.cFileName );
            }
	    } else {
            //
            // Continue with the existing scan
            //
            hr = GET_HR_FROM_BOOL( FindNextFileW( hFileScan, &FileFindData ));
            if (SUCCEEDED( hr )) {

                StringTruncate( &ucsCurrentPath, usCurrentPathCursor );
                StringAppendString( &ucsCurrentPath, FileFindData.cFileName );

            } else if ( hr == HRESULT_FROM_WIN32( ERROR_NO_MORE_FILES )) {

                FindClose( hFileScan );
                hFileScan = INVALID_HANDLE_VALUE;
                
                if (dwSubDirectoriesEntered > 0) {
                    //
                    // This is a scan of a sub-directory that is now 
                    // complete so delete the sub-directory itself.
                    //
                    StringTruncate( &ucsCurrentPath, usCurrentPathCursor - 1 );
                    hr = GET_HR_FROM_BOOL( RemoveDirectory( ucsCurrentPath.Buffer ));
                    dwSubDirectoriesEntered--;
                }
                if ( dwSubDirectoriesEntered == 0) {
                    //
                    // We are back to where we started except that the 
                    // requested directory is now gone. Time to leave.
                    //
                    bContinue = false;
                    hr = NOERROR;
                } else {
                    //
                    // Move back up one directory level, reset the cursor 
                    // and prepare the path buffer to begin a new scan.
                    //
                    pwchLastSlash = wcsrchr( ucsCurrentPath.Buffer, DIR_SEP_CHAR );
                    usCurrentPathCursor =( USHORT )( pwchLastSlash - ucsCurrentPath.Buffer ) + 1;
                    StringTruncate( &ucsCurrentPath, usCurrentPathCursor );
                    StringAppendString( &ucsCurrentPath, L"*" );
                }

                //
                // No files to be processed on this pass so go back and try to 
                // find another or leave the loop as we've finished the task. 
                //
                continue;
            }
	    }
        
        if (SUCCEEDED( hr )) {
            if ( FileFindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributesW( ucsCurrentPath.Buffer, 
                                    FileFindData.dwFileAttributes ^ (FILE_ATTRIBUTE_READONLY) );
            }

            if ( !NameIsDotOrDotDot( FileFindData.cFileName )) {
                if (( FileFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) ||
                    !( FileFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )) {
                    ClRtlLogPrint( LOG_NOISE, "VSS: RemoveDirectoryTree: Deleting file: %1\n", ucsCurrentPath.Buffer );
                    hr = GET_HR_FROM_BOOL( DeleteFileW( ucsCurrentPath.Buffer ) );
                } else {
                    ClRtlLogPrint( LOG_NOISE, "VSS: RemoveDirectoryTree: RemoveDirectory: %1\n", ucsCurrentPath.Buffer );
                    hr = GET_HR_FROM_BOOL( RemoveDirectory( ucsCurrentPath.Buffer ));
                    if (hr == HRESULT_FROM_WIN32( ERROR_DIR_NOT_EMPTY )) {
                        ClRtlLogPrint( LOG_NOISE, "VSS: RemoveDirectoryTree: dir not empty.  Restarting scan.\n" );
                        //
                        // The directory wasn't empty so move down one level, 
                        // close the old scan and start a new one. 
                        //
                        hr = S_OK;
                        FindClose( hFileScan );
                        hFileScan = INVALID_HANDLE_VALUE;                        
                        StringAppendString( &ucsCurrentPath, DIR_SEP_STRING L"*" );
                        usCurrentPathCursor =( ucsCurrentPath.Length / sizeof (WCHAR) ) - 1;
                        dwSubDirectoriesEntered++;
                    }
                }
            }
        }
        LOGUNICODESTRING( ucsCurrentPath );
	} // while 

    if ( FAILED( hr )) {
        ClRtlLogPrint( LOG_NOISE, "VSS: RemoveDirectoryTree: exited while loop due to failed hr: 0x%1!08lx!\n", hr );
        goto ErrorExit;
    }

    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    if ( !HandleInvalid( hFileScan ))
        FindClose( hFileScan );

    StringFree( &ucsCurrentPath );

    return hr;
}


//////////////////////////////////////////////////////////////////////////
// Some useful UNICODE string stuff.
//////////////////////////////////////////////////////////////////////////
//
static HRESULT StringAllocate( PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes )
{
    HRESULT	hr            = NOERROR;
    LPVOID	pvBuffer      = NULL;
    SIZE_T	cActualLength = 0;

    pvBuffer = HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, usMaximumStringLengthInBytes );
    hr = GET_HR_FROM_POINTER( pvBuffer );
    if ( FAILED (hr )) {
        LOGERROR( hr, StringAllocate );
        goto ErrorExit;
    }
    
    pucsString->Buffer        = (PWCHAR)pvBuffer;
    pucsString->Length        = 0;
    pucsString->MaximumLength = usMaximumStringLengthInBytes;

    cActualLength = HeapSize ( GetProcessHeap( ), 0, pvBuffer );
    
    if ( ( cActualLength <= MAXUSHORT ) && ( cActualLength > usMaximumStringLengthInBytes ))
        pucsString->MaximumLength = (USHORT) cActualLength;

    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    ClRtlLogPrint( LOG_NOISE, "VSS: Allocated string at: 0x%1!08lx! Length: %2!u! MaxLength: %3!u!\n",
                   pucsString->Buffer, pucsString->Length, pucsString->MaximumLength );
    return hr;
}


static void StringFree( PUNICODE_STRING pucsString )
{
    HRESULT	hr = NOERROR;

    CL_ASSERT( pucsString->Length <= pucsString->MaximumLength );
    CL_ASSERT( ( pucsString->Buffer == NULL) ? pucsString->Length == 0 : pucsString->MaximumLength > 0 );

    if ( pucsString->Buffer == NULL ) {
        ClRtlLogPrint( LOG_UNUSUAL, "VSS: StringFree. Attempt to free NULL buffer.\n" );
        return;
    }

    ClRtlLogPrint( LOG_NOISE, "VSS: Freeing string at: %1\n", pucsString->Buffer );

    ClRtlLogPrint( LOG_NOISE, "VSS: Freeing string at: 0x%1!08lx! Length: %2!u! MaxLength: %3!u!\n",
                   pucsString->Buffer, pucsString->Length, pucsString->MaximumLength );

    hr = GET_HR_FROM_BOOL( HeapFree( GetProcessHeap( ), 0, pucsString->Buffer ));
    CL_ASSERT ( SUCCEEDED( hr ));

    pucsString->Buffer        = NULL;
    pucsString->Length        = 0;
    pucsString->MaximumLength = 0;
}

static HRESULT StringCreateFromExpandedString( PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars)
{
    HRESULT	hr = NOERROR;
    DWORD	dwStringLength;

    //
    // Remember, ExpandEnvironmentStringsW () includes the terminating null in the response.
    //
    dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString, NULL, 0) + dwExtraChars;

    hr = GET_HR_FROM_BOOL( dwStringLength != 0 );
    if ( FAILED ( hr )) {
        LOGERROR( hr, ExpandEnvironmentStringsW );
        goto ErrorExit;
    }

    if ( (dwStringLength * sizeof (WCHAR)) > MAXUSHORT ) {
        hr = HRESULT_FROM_WIN32( ERROR_BAD_LENGTH );
        LOGERROR( hr, ExpandEnvironmentStringsW );
        goto ErrorExit;        
    }

    hr = StringAllocate( pucsNewString, (USHORT)( dwStringLength * sizeof (WCHAR) ));
    if ( FAILED( hr )) {
        LOGERROR( hr, StringAllocate );
        goto ErrorExit;
    }

    //
    // Note that if the expanded string has gotten bigger since we
    // allocated the buffer then too bad, we may not get all the
    // new translation. Not that we really expect these expanded
    // strings to have changed any time recently.
    //
    dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString,
                                                pucsNewString->Buffer,
                                                pucsNewString->MaximumLength / sizeof (WCHAR));
    
    hr = GET_HR_FROM_BOOL( dwStringLength != 0 );
    if ( FAILED ( hr )) {
        LOGERROR( hr, ExpandEnvironmentStringsW );
        goto ErrorExit;
    }
    pucsNewString->Length = (USHORT) ((dwStringLength - 1) * sizeof (WCHAR));
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    CL_ASSERT( pucsNewString->Length <= pucsNewString->MaximumLength );
    return hr;
}

static HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, 
                                       PUNICODE_STRING pucsOriginalString, 
                                       DWORD dwExtraChars)
{
    HRESULT	hr       = NOERROR;
    ULONG	ulStringLength = pucsOriginalString->MaximumLength + (dwExtraChars * sizeof (WCHAR));

    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL))) {
        hr = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
        goto ErrorExit;
	}

	hr = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
    if ( FAILED( hr ))
        goto ErrorExit;

	memcpy (pucsNewString->Buffer, pucsOriginalString->Buffer, pucsOriginalString->Length);
	pucsNewString->Length = pucsOriginalString->Length;
	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    return hr;
}

static void StringAppendString( PUNICODE_STRING pucsTarget, PUNICODE_STRING pucsSource )
{
    CL_ASSERT( pucsTarget->Length <= pucsTarget->MaximumLength );
    CL_ASSERT( pucsSource->Length <= pucsSource->MaximumLength );
    CL_ASSERT( pucsTarget->Length + pucsSource->Length < pucsTarget->MaximumLength );

    memmove( &pucsTarget->Buffer [pucsTarget->Length / sizeof (WCHAR)], 
             pucsSource->Buffer,
             pucsSource->Length + sizeof( UNICODE_NULL ));
    pucsTarget->Length = pucsTarget->Length + pucsSource->Length;

    CL_ASSERT( pucsTarget->Length <= pucsTarget->MaximumLength );
    CL_ASSERT( pucsSource->Length <= pucsSource->MaximumLength );
}

static void StringAppendString( PUNICODE_STRING pucsTarget, PWCHAR pwszSource )
{
    CL_ASSERT( pucsTarget->Length <= pucsTarget->MaximumLength );
    CL_ASSERT( pucsTarget->Length + ( wcslen( pwszSource ) * sizeof( WCHAR )) < pucsTarget->MaximumLength );

    USHORT Length = (USHORT) wcslen( pwszSource ) * sizeof ( WCHAR );
    memmove( &pucsTarget->Buffer [pucsTarget->Length / sizeof (WCHAR)], pwszSource, Length + sizeof( UNICODE_NULL ));
    pucsTarget->Length = pucsTarget->Length + Length;

    CL_ASSERT( pucsTarget->Length <= pucsTarget->MaximumLength );
}

static HRESULT StringTruncate (PUNICODE_STRING pucsString, USHORT usSizeInChars)
{
    HRESULT	hr    = NOERROR;
    USHORT	usNewLength = (USHORT)(usSizeInChars * sizeof (WCHAR));

    if (usNewLength > pucsString->Length) {
        hr = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	} else {
        pucsString->Buffer [usSizeInChars] = UNICODE_NULL;
        pucsString->Length                 = usNewLength;
	}
    return hr;
}

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\om\omlog.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    omlog.c

Abstract:

    logging routines for the object log stream

    this code was jumpstarted from the clusrtl logging code. Most notably, it
    is UTF-8 encoded which allows full Unicode without the cost of writing
    16b. for each character.

    remaining issues to solve: proper truncation of log file based on current
    starting session. We'd like to remember as many sessions as possible but
    since I've chosen UTF-8, I can't jump to the middle of the file and start
    looking around. One possibility strategy is using an alternate NTFS stream
    to record the starting offsets of sessions. If that stream didn't exist or
    we're on a FAT FS, then we'll continue with the current strategy.

Author:

    Charlie Wickham (charlwi) 07-May-2001

Environment:

    User Mode

Revision History:

--*/

#include "omp.h"

//
// when this sequence is at the beginning of the file, it indicates that the
// file is UTF8 encoded
//
#define UTF8_BOM    "\x0EF\x0BB\x0BF"

//
// Private Data
//

DWORD   OmpLogFileLimit;
DWORD   OmpCurrentSessionStart;
BOOL    OmpLogToFile = FALSE;
HANDLE  OmpLogFileHandle = NULL;
DWORD   OmpProcessId;
DWORD   OmpCurrentSessionOffset;

PCLRTL_WORK_QUEUE OmpLoggerWorkQueue;

//
// structure used to pass formatted buffers to work queue routine
//
typedef struct _OM_LOG_BUFFER_DESC {
    DWORD   TimeBytes;
    DWORD   MsgBytes;
    PCHAR   TimeBuffer;
    PCHAR   MsgBuffer;
} OM_LOG_BUFFER_DESC, *POM_LOG_BUFFER_DESC;

#define MAX_NUMBER_LENGTH 20

// Specify maximum file size ( DWORD / 1MB )

#define MAX_FILE_SIZE ( 0xFFFFF000 / ( 1024 * 1024 ) )

DWORD               OmpLogFileLimit = ( 1 * 1024 * 1024 ); // 1 MB default
DWORD               OmpLogFileLoWater = 0;

//
// internal functions
//
DWORD
OmpTruncateFile(
    IN HANDLE FileHandle,
    IN DWORD FileSize,
    IN LPDWORD LastPosition
    )

/*++

Routine Description:

    Truncate a file by copying the portion starting at LastPosition and ending
    at EOF to the front of the file and setting the file's EOF pointer to the
    end of the new chunk. We always keep the current session even that means
    growing larger than the file limit.

    For now, we have no good way of finding all the sessions within the file,
    so if the file must be truncated, we whack it back to the beginning of the
    current session. If time permits, I'll add something more intelligent
    later on.

Arguments:

    FileHandle - File handle.

    FileSize - Current End of File.

    LastPosition - On input, specifies the starting position in the file from
    which the copy begins. On output, it is set to the new EOF

Return Value:

    New end of file.

--*/

{
//
// The following buffer size should never be more than 1/4 the size of the
// file.
//
#define BUFFER_SIZE ( 64 * 1024 )
    DWORD   bytesLeft;
    DWORD   endPosition = sizeof( UTF8_BOM ) - 1;
    DWORD   bufferSize;
    DWORD   bytesRead;
    DWORD   bytesWritten;
    DWORD   fileSizeHigh = 0;
    DWORD   readPosition;
    DWORD   writePosition;
    PVOID   dataBuffer;

    //
    // current session is already at beginning of file so bale now...
    //
    if ( OmpCurrentSessionOffset == sizeof( UTF8_BOM ) - 1) {
        return FileSize;
    }

    //
    // don't truncate the current session, i.e., always copy from the start of
    // the current session
    //
    if ( *LastPosition > OmpCurrentSessionOffset ) {
        *LastPosition = OmpCurrentSessionOffset;
    }

    if ( *LastPosition > FileSize ) {
        //
        // something's confused; the spot we're supposed to copy from is at or
        // past the current EOF. reset the entire file
        //
        goto error_exit;
    }

    dataBuffer = LocalAlloc( LMEM_FIXED, BUFFER_SIZE );
    if ( !dataBuffer ) {
        goto error_exit;
    }

    //
    // calc number of bytes to move
    //
    bytesLeft = FileSize - *LastPosition;
    endPosition = bytesLeft + sizeof( UTF8_BOM ) - 1;

    //
    // Point back to last position for reading.
    //
    readPosition = *LastPosition;
    writePosition = sizeof( UTF8_BOM ) - 1;

    while ( bytesLeft ) {
        if ( bytesLeft >= BUFFER_SIZE ) {
            bufferSize = BUFFER_SIZE;
        } else {
            bufferSize = bytesLeft;
        }
        bytesLeft -= bufferSize;

        SetFilePointer( FileHandle,
                        readPosition,
                        &fileSizeHigh,
                        FILE_BEGIN );

        if ( ReadFile( FileHandle,
                       dataBuffer,
                       bufferSize,
                       &bytesRead,
                       NULL ) )
        {
            SetFilePointer( FileHandle,
                            writePosition,
                            &fileSizeHigh,
                            FILE_BEGIN );
            WriteFile( FileHandle,
                       dataBuffer,
                       bytesRead,
                       &bytesWritten,
                       NULL );
        } else {
            endPosition = sizeof( UTF8_BOM ) - 1;
            break;
        }
        readPosition += bytesRead;
        writePosition += bytesWritten;
    }

    LocalFree( dataBuffer );

    //
    // for now, we only only one truncate by setting the current position to
    // the beginning of file.
    //
    OmpCurrentSessionOffset = sizeof( UTF8_BOM ) - 1;

error_exit:

    //
    // Force end of file to get set.
    //
    SetFilePointer( FileHandle,
                    endPosition,
                    &fileSizeHigh,
                    FILE_BEGIN );

    SetEndOfFile( FileHandle );

    *LastPosition = endPosition;

    return(endPosition);

} // OmpTruncateFile

VOID
OmpLoggerWorkThread(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )

/*++

Routine Description:

    work queue worker routine. actually does the write to the file.

Arguments:

    standard ClRtl thread args; we only care about WorkItem

Return Value:

    None

--*/

{
    DWORD   fileSize;
    DWORD   fileSizeHigh;
    DWORD   tsBytesWritten;
    DWORD   msgBytesWritten;

    POM_LOG_BUFFER_DESC bufDesc = (POM_LOG_BUFFER_DESC)(WorkItem->Context);

    fileSize = GetFileSize( OmpLogFileHandle, &fileSizeHigh );
    ASSERT( fileSizeHigh == 0 );        // We're only using DWORDs!

    if ( fileSize > OmpLogFileLimit ) {
        fileSize = OmpTruncateFile( OmpLogFileHandle, fileSize, &OmpLogFileLoWater );
    }

    SetFilePointer( OmpLogFileHandle,
                    fileSize,
                    &fileSizeHigh,
                    FILE_BEGIN );

    WriteFile(OmpLogFileHandle,
              bufDesc->TimeBuffer,
              bufDesc->TimeBytes,
              &tsBytesWritten,
              NULL);

    WriteFile(OmpLogFileHandle,
              bufDesc->MsgBuffer,
              bufDesc->MsgBytes,
              &msgBytesWritten,
              NULL);

    //
    // if we haven't set the lo water mark, wait until the file size has
    // crossed the halfway mark and set it to the beginning of the line we
    // just wrote.
    //
    if ( OmpLogFileLoWater == 0 && (fileSize > (OmpLogFileLimit / 2)) ) {
        OmpLogFileLoWater = fileSize;

        ASSERT( OmpLogFileLoWater >= OmpCurrentSessionOffset );
    }

} // OmpLoggerWorkThread

VOID
OmpLogPrint(
    LPWSTR  FormatString,
    ...
    )

/*++

Routine Description:

    Prints a message to the object config log file.

Arguments:

    FormatString - The initial message string to print.

    Any FormatMessage-compatible arguments to be inserted in the message
    before it is logged.

 Return Value:

     None.

--*/

{
    PWCHAR  unicodeOutput = NULL;
    PCHAR   timestampBuffer;
    DWORD   timestampBytes;
    PCHAR   utf8Buffer;
    DWORD   utf8Bytes;
    PWCHAR  unicodeBuffer;
    DWORD   unicodeBytes;
    DWORD   status = ERROR_SUCCESS;

    SYSTEMTIME  Time;
    ULONG_PTR   ArgArray[9];
    va_list     ArgList;

    //
    // init the variable arg list
    //
    va_start(ArgList, FormatString);

    if ( !OmpLogToFile ) {
        va_end(ArgList);
        return;
    }

    GetSystemTime(&Time);

    ArgArray[0] = OmpProcessId;
    ArgArray[1] = GetCurrentThreadId();
    ArgArray[2] = Time.wYear;
    ArgArray[3] = Time.wMonth;
    ArgArray[4] = Time.wDay;
    ArgArray[5] = Time.wHour;
    ArgArray[6] = Time.wMinute;
    ArgArray[7] = Time.wSecond;
    ArgArray[8] = Time.wMilliseconds;

    //
    // we can get away with formatting it as ANSI since our data is all numbers
    //
    timestampBytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING |
                                    FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                    FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    "%1!08lx!.%2!08lx!::%3!02d!/%4!02d!/%5!02d!-%6!02d!:%7!02d!:%8!02d!.%9!03d! ",
                                    0,
                                    0,
                                    (LPSTR)&timestampBuffer,
                                    50,
                                    (va_list*)&ArgArray);

    if ( timestampBytes == 0 ) {
        va_end(ArgList);
//        WmiTrace("Prefix format failed, %d: %!ARSTR!", GetLastError(), FormatString);
        return;
    }

    //
    // format the message in unicode
    //
    try {
        unicodeBytes = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                      | FORMAT_MESSAGE_FROM_STRING,
                                      FormatString,
                                      0,
                                      0,
                                      (LPWSTR)&unicodeOutput,
                                      512,
                                      &ArgList);
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        unicodeBytes = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                      | FORMAT_MESSAGE_FROM_STRING
                                      | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      L"LOGERROR(exception): Could not print message: %1!ws!",
                                      0,
                                      0,
                                      (LPWSTR)&unicodeOutput,
                                      512,
                                      (va_list *) &FormatString );
    }
    va_end(ArgList);

    if (unicodeBytes != 0) {
        PCLRTL_WORK_ITEM workQItem;

        //
        // convert the output to UTF-8; first get the size to see if it will
        // fit in our stack buffer.
        //
        utf8Bytes = WideCharToMultiByte(CP_UTF8,
                                        0,                     // dwFlags
                                        unicodeOutput,
                                        unicodeBytes,
                                        NULL,
                                        0,
                                        NULL,                  // lpDefaultChar
                                        NULL);                 // lpUsedDefaultChar

        utf8Buffer = LocalAlloc( LMEM_FIXED, utf8Bytes );
        if ( utf8Buffer == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        utf8Bytes = WideCharToMultiByte(CP_UTF8,
                                        0,                     // dwFlags
                                        unicodeOutput,
                                        unicodeBytes,
                                        utf8Buffer,
                                        utf8Bytes,
                                        NULL,                  // lpDefaultChar
                                        NULL);                 // lpUsedDefaultChar

        workQItem = (PCLRTL_WORK_ITEM)LocalAlloc(LMEM_FIXED,
                                                 sizeof( CLRTL_WORK_ITEM ) + sizeof( OM_LOG_BUFFER_DESC ));

        if ( workQItem != NULL ) {
            POM_LOG_BUFFER_DESC bufDesc = (POM_LOG_BUFFER_DESC)(workQItem + 1);

            bufDesc->TimeBytes = timestampBytes;
            bufDesc->TimeBuffer = timestampBuffer;
            bufDesc->MsgBytes = utf8Bytes;
            bufDesc->MsgBuffer = utf8Buffer;

            ClRtlInitializeWorkItem( workQItem, OmpLoggerWorkThread, bufDesc );
            status = ClRtlPostItemWorkQueue( OmpLoggerWorkQueue, workQItem, 0, 0 );

        } else {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
//        WmiTrace("%!level! %!ARSTR!", *(UCHAR*)&LogLevel, AnsiString.Buffer + timestampBytes);
    } else {
//        WmiTrace("Format returned 0 bytes: %!ARSTR!", FormatString);
        status = GetLastError();
    }

error_exit:
    if ( unicodeOutput != NULL ) {
        LocalFree( unicodeOutput );
    }

    return;

} // OmpLogPrint


//
// exported (within OM) functions
//

VOID
OmpOpenObjectLog(
    VOID
    )

/*++

Routine Description:

    Use the clusterlog environment variable to open another file that contains
    object mgr name to ID mapping info. If the routine fails, the failure is
    logged in the cluster log but no logging will be done to the object log
    file.

    NOTE: access to the file is synchronized since this routine is assumed to
    be called only once by OmInit.  Arguments:

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR   logFileBuffer[MAX_PATH];
    LPWSTR  logFileName = NULL;
    LPWSTR  objectLogExtension = L".obj";
    DWORD   status = ERROR_SUCCESS;
    DWORD   defaultLogSize = 1;           // in MB
    DWORD   envLength;
    WCHAR   logFileSize[MAX_NUMBER_LENGTH];
    DWORD   logSize;
    LPWSTR  lpszBakFileName = NULL;
    DWORD   fileSizeHigh = 0;
    DWORD   fileSizeLow;
    DWORD   bytesWritten;
    PWCHAR  dot;

    UNICODE_STRING  logFileString;

    //
    // see if logging has been specified; get a buffer big enough that will
    // hold the object log name
    //
    envLength = GetEnvironmentVariable(L"ClusterLog",
                                       logFileBuffer,
                                       sizeof(logFileBuffer)/sizeof(WCHAR));
    if ( envLength > (( sizeof(logFileBuffer) + sizeof(objectLogExtension)) / sizeof(WCHAR)) ) {
        //
        // allocate a larger buffer since our static one wasn't big enough
        //
        logFileName = LocalAlloc( LMEM_FIXED,
                                  envLength * sizeof( WCHAR ) );
        if ( logFileName == NULL ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[OM] Unable to get memory for Object log filename buffer\n");
            return;
        }

        envLength = GetEnvironmentVariable(L"ClusterLog",
                                           logFileName,
                                           envLength);
        if ( envLength == 0 ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[OM] Unable to read ClusterLog environment variable\n");

            goto error_exit;
        }
    } else if ( envLength != 0 ) {
        logFileName = logFileBuffer;
    }

    if ( logFileName == NULL ) {
        //
        // logging is turned off or we can't determine where to put the file.
        //
        goto error_exit;
    }

    //
    // Try to get a limit on the log file size.  This number is the number of
    // MB.
    //
    envLength = GetEnvironmentVariable(L"ClusterLogSize",
                                       logFileSize,
                                       sizeof(logFileSize)/sizeof(WCHAR));

    if ( envLength != 0 && envLength < MAX_NUMBER_LENGTH ) {
        RtlInitUnicodeString( &logFileString, logFileSize );
        status = RtlUnicodeStringToInteger( &logFileString,
                                            10,
                                            &logSize );
        if ( NT_SUCCESS( status ) ) {
            OmpLogFileLimit = logSize;
        }
    } else {
        OmpLogFileLimit = defaultLogSize;
    }

    status = ERROR_SUCCESS;

    if ( OmpLogFileLimit == 0 ) {
        goto error_exit;
    }

    //
    // make the file size no bigger than one-eighth the size of the normal log
    // file but no less than 256KB
    //
    if ( OmpLogFileLimit > MAX_FILE_SIZE ) {
        OmpLogFileLimit = MAX_FILE_SIZE;
    }
    OmpLogFileLimit = ( OmpLogFileLimit * ( 1024 * 1024 )) / 8;
    if ( OmpLogFileLimit < ( 256 * 1024 )) {
        OmpLogFileLimit = 256 * 1024;
    }

    //
    // replace the filename with the object log name; deal with the use of
    // forward slashes
    //
    dot = wcsrchr( logFileName, L'.' );

    if ( dot != NULL ) {
        wcscpy( dot, objectLogExtension );
    } else {
        wcscat( logFileName, objectLogExtension );
    }

    OmpLogFileHandle = CreateFile(logFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  0,
                                  NULL );

    if ( OmpLogFileHandle == INVALID_HANDLE_VALUE ) {
        status = GetLastError();

        ClRtlLogPrint(LOG_UNUSUAL,
                      "[OM] Open of object log file failed. Error %1!u!\n",
                      status);
        goto error_exit;
    } else {

        //
        // write UTF-8 header to beginning of file and get the offset of the
        // EOF; we never want to reset the start of the file after this point.
        //
        WriteFile( OmpLogFileHandle, UTF8_BOM, sizeof( UTF8_BOM ) - 1, &bytesWritten, NULL );

        OmpCurrentSessionOffset = SetFilePointer( OmpLogFileHandle, 0, NULL, FILE_END );
        if ( OmpCurrentSessionOffset == INVALID_SET_FILE_POINTER ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[OM] Unable to get object log end of file position. error %1!u!.\n",
                          GetLastError());

            CloseHandle( OmpLogFileHandle );
            goto error_exit;
        }

        OmpLogToFile = TRUE;
        OmpProcessId = GetCurrentProcessId();

        //
        // determine the initial low water mark. We have 3 cases
        // we need to handle:
        // 1) log size is less than 1/2 limit
        // 2) log size is within limit but more than 1/2 limit
        // 3) log size is greater than limit
        //
        // case 1 requires nothing special; the low water mark will be updated
        // on the next log write.
        //
        // for case 2, we need to find the beginning of a line near 1/2 the
        // current limit. for case 3, the place to start looking is current
        // log size - 1/2 limit. In this case, the log will be truncated
        // before the first write occurs, so we need to take the last 1/2
        // limit bytes and copy them down to the front.
        //

        //
        // For now, set the low water mark to be the current offset. When it
        // is time to wrap, we'll lose everything but the current session.
        //
        // the problem is that we're dealing with UTF8 and we can't just jump
        // in the middle of the file and start looking around (we might hit
        // the 2nd byte of a DBCS sequence). For now, we'll leave
        // OmpLogFileLoWater set to zero. It will get updated when the 1/2 way
        // threshold is crossed.
        //
        OmpLogFileLoWater = OmpCurrentSessionOffset;
#if 0

        fileSizeLow = GetFileSize( OmpLogFileHandle, &fileSizeHigh );
        if ( fileSizeLow < ( OmpLogFileLimit / 2 )) {
            //
            // case 1: leave low water at zero; it will be updated with next
            // log write
            //
            ;
        } else {
#define LOGBUF_SIZE 1024                        
            CHAR    buffer[LOGBUF_SIZE];
            LONG    currentPosition;
            DWORD   bytesRead;

            if ( fileSizeLow < OmpLogFileLimit ) {
                //
                // case 2; start looking at the 1/2 the current limit to find
                // the starting position
                //
                currentPosition = OmpLogFileLimit / 2;
            } else {
                //
                // case 3: start at current size minus 1/2 limit to find our
                // starting position.
                //
                currentPosition  = fileSizeLow - ( OmpLogFileLimit / 2 );
            }

            //
            // backup from the initial file position, read in a block and look
            // for the start of a session. When we find one, backup to the
            // beginning of that line. Use that as the initial starting
            // position when we finally truncate the file.
            //
            OmpLogFileLoWater = 0;
            currentPosition -= LOGBUF_SIZE;

            SetFilePointer(OmpLogFileHandle,
                           currentPosition,
                           &fileSizeHigh,
                           FILE_BEGIN);

            do {

                if ( ReadFile(OmpLogFileHandle,
                              buffer,
                              LOGBUF_SIZE - 1,
                              &bytesRead,
                              NULL ) )                                                   
                    {
                        PCHAR p = buffer;
                        PCHAR newp;

                        buffer[ bytesRead ] = NULL;
                        while ( *p != 'S' && bytesRead-- != 0 ) {
                            newp = CharNextExA( CP_UTF8, p, 0 );
                            if ( newp == p ) {
                                break;
                            }
                            p = newp;
                        }

                        if ( p != newp ) {
                            if ( strchr( p, "START" )) {
                                //
                                // set pointer to beginning of line
                                //
                                p = currentLine;
                                break;
                            }
                        } else {
                            //
                            // not found in this block; read in the next one
                            //

                        }
                    }
            } while ( TRUE );

            if ( *p == '\n' ) {
                OmpLogFileLoWater = (DWORD)(currentPosition + ( p - buffer + 1 ));
            }

            if ( OmpLogFileLoWater == 0 ) {
                //
                // couldn't find any reasonable data. just set it to
                // initial current position.
                //
                OmpLogFileLoWater = currentPosition + LOGBUF_SIZE;
            }
        }
#endif
    }

    //
    // finally, create the threadq that will handle the IO to the file
    //
    OmpLoggerWorkQueue = ClRtlCreateWorkQueue( 1, THREAD_PRIORITY_BELOW_NORMAL );
    if ( OmpLoggerWorkQueue == NULL ) {
        CloseHandle( OmpLogFileHandle );

        ClRtlLogPrint(LOG_UNUSUAL,
                      "[OM] Unable to logger work queue. error %1!u!.\n",
                      GetLastError());
    }

error_exit:
    if ( logFileName != logFileBuffer && logFileName != NULL ) {
        LocalFree( logFileName );
    }

} // OmpOpenObjectLog

VOID
OmpLogStartRecord(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    OSVERSIONINFOEXW    version;
    BOOL        success;
    PWCHAR      suiteAbbrev;
    SYSTEMTIME  localTime;

    GetLocalTime( &localTime );

    version.dwOSVersionInfoSize = sizeof(version);
    success = GetVersionExW((POSVERSIONINFOW)&version);

    if ( success ) {
        //
        // Log the System version number
        //
        if ( version.wSuiteMask & VER_SUITE_DATACENTER ) {
            suiteAbbrev = L"DTC";
        } else if ( version.wSuiteMask & VER_SUITE_ENTERPRISE ) {
            suiteAbbrev = L"ADS";
        } else if ( version.wSuiteMask & VER_SUITE_EMBEDDEDNT ) {
            suiteAbbrev  = L"EMB";
        } else if ( version.wProductType & VER_NT_WORKSTATION ) {
            suiteAbbrev = L"WS";
        } else if ( version.wProductType & VER_NT_DOMAIN_CONTROLLER ) {
            suiteAbbrev = L"DC";
        } else if ( version.wProductType & VER_NT_SERVER ) {
            suiteAbbrev = L"SRV";  // otherwise - some non-descript Server
        } else {
            suiteAbbrev = L"";
        }

        OmpLogPrint(L"START    %1!02d!/%2!02d!/%3!02d!-%4!02d!:%5!02d!:%6!02d!.%7!03d! %8!u! %9!u! "
                    L"%10!u! %11!u! %12!u! %13!u! \"%14!ws!\" "
                    L"%15!u! %16!u! %17!04X! (%18!ws!) %19!u!\n",
                    localTime.wYear,
                    localTime.wMonth,
                    localTime.wDay,
                    localTime.wHour,
                    localTime.wMinute,
                    localTime.wSecond,
                    localTime.wMilliseconds,
                    CLUSTER_GET_MAJOR_VERSION( CsMyHighestVersion ),
                    CLUSTER_GET_MINOR_VERSION( CsMyHighestVersion ),
                    version.dwMajorVersion,         // param 10
                    version.dwMinorVersion,
                    version.dwBuildNumber,
                    version.dwPlatformId,
                    version.szCSDVersion,
                    version.wServicePackMajor,      // param 15
                    version.wServicePackMinor,
                    version.wSuiteMask,
                    suiteAbbrev,
                    version.wProductType);
    }

} // OmpLogStartRecord

VOID
OmpLogStopRecord(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    OmpLogPrint( L"STOP\n" );

} // OmpLogStopRecord


/* end omlog.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\cluscomp\cluscomp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    ClusComp.cpp
//
// Abstract:
//    This file implements the Clustering Service Upgrade Compatibility Check DLL.
//    The DLL gets executed by winnt32. It's purpose is to alert the user to possible
//    incompatibilities that may be encountered after performing an upgrade.
//
//    At this time, 8/4/98, the only known incompatibility that may arise stems
//    from upgrading NTSE 4.0 with MSCS installed.
//
// Author:
//    C. Brent Thomas (a-brentt)
//
// Revision History:
//    8/4/98 - original
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////


#include <windows.h>
#include <tchar.h>
#include <winuser.h>
#include <comp.h>

#include <clusapi.h>

#include <IsClusterServiceRegistered.h>

#include "resource.h"

HMODULE ghInstance;

/////////////////////////////////////////////////////////////////////////////
//++
//
// DllMain
//
// Routine Description:
//    DLL entry point
//
// Arguments:
//    
//    
//
// Return Value:
//    
// Note:
//    This function was copied from msmqcomp.dll.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL DllMain( IN const HANDLE DllHandle, IN const DWORD  Reason, IN const LPVOID Reserved )
{
   switch ( Reason )
   {
      case DLL_PROCESS_ATTACH:

         ghInstance = (HINSTANCE)DllHandle;

         break;

      case DLL_PROCESS_DETACH:

         break;

      default:

         break;
   }

   return TRUE;

} //DllMain



/////////////////////////////////////////////////////////////////////////////
//++
//
// ClusterUpgradeCompatibilityCheck
//
// Routine Description:
//    This function is the exported function for cluscomp.dll, the Cluster Upgrade
//    Compatibility Check DLL called by winnt32 to handle incompatibilities when
//    upgrading the Clustering Service.
//
// Arguments:
//    pfnCompatibilityCallback - points to the callback function used to supply
//                               compatibility information to winnt32.exe.
//    pvContext - points to a context buffer supplied by winnt32.exe.
//    
//
// Return Value:
//    TRUE - either indicates that no incompatibility was detected or that
//           *pfnComaptibilityCallback() returned TRUE.
//    FALSE - *pfnCompatibilityCallback() returned FALSE
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL ClusterUpgradeCompatibilityCheck( PCOMPAIBILITYCALLBACK pfnCompatibilityCallback,
                                       LPVOID pvContext )
{
   BOOL  IsCompatibilityWarningRequired( void );
   
   BOOL  fReturnValue = (BOOL) TRUE;

   // Is the cluster service registered with the Service Control Manager?
   // If the cluster service is not registered that means that Clustering Service
   // has not been installed. That implies that there can be no incompatibility.
   
   if ( IsClusterServiceRegistered() == (BOOL) TRUE )
   {
      // Get the current operating system version. Note that this cannot call
      // VerifyVersionInfo() which requires Windows 2000.

      OSVERSIONINFO  OsVersionInfo;
      
      OsVersionInfo.dwOSVersionInfoSize = sizeof( OsVersionInfo );

      GetVersionEx( &OsVersionInfo );

      // As per Bohdan R. and David P., 8/6/98, no compatibility warning is 
      // required if the system being upgraded is already at NT 5 or later.
      
      if ( (OsVersionInfo.dwPlatformId == (DWORD) VER_PLATFORM_WIN32_NT) &&
           (OsVersionInfo.dwMajorVersion < (DWORD) 5) )
      {
         // Determine whether a compatibility warning is necessary.
         
         BOOL  fCompatibilityWarningRequired;

         fCompatibilityWarningRequired = IsCompatibilityWarningRequired();
         
         // Is it necessary to display a compatibility warning?

         if ( fCompatibilityWarningRequired == (BOOL) TRUE )
         {
            // It is necessary to display a compatibility warning.
            
            TCHAR tszDescription[100];       // size is arbitrary
            TCHAR tszHtmlName[MAX_PATH];
            TCHAR tszTextName[MAX_PATH];
            
            // Set the Description string.
            
            *tszDescription = TEXT( '\0' );

            LoadString( ghInstance,
                        IDS_UPGRADE_OTHER_NODES,
                        tszDescription,
                        100 );

            // Set the HTML file name. Note that following the example of msmqcomp.cpp
            // this path is relative to the winnt32 directory.
            
            _tcscpy( tszHtmlName, TEXT( "CompData\\ClusComp.htm" ) );

            // Set the TEXT file name. Note that following the example of msmqcomp.cpp
            // this path is relative to the winnt32 directory.
            
            _tcscpy( tszTextName, TEXT( "CompData\\ClusComp.txt" ) );

            // Build the COMPATIBILITY_ENTRY structure to pass to *pfnCompatibilityCallback().
            
            COMPATIBILITY_ENTRY  CompatibilityEntry;

            ZeroMemory( &CompatibilityEntry, sizeof( CompatibilityEntry ) );

            CompatibilityEntry.Description = tszDescription;
            CompatibilityEntry.HtmlName = tszHtmlName;
            CompatibilityEntry.TextName = tszTextName;
            CompatibilityEntry.RegKeyName = (LPTSTR) NULL;
            CompatibilityEntry.RegValName = (LPTSTR) NULL;
            CompatibilityEntry.RegValDataSize = (DWORD) 0L;
            CompatibilityEntry.RegValData = (LPVOID) NULL;
            CompatibilityEntry.SaveValue = (LPVOID) NULL;
            CompatibilityEntry.Flags = (DWORD) 0L;

            // Execute the callback function.
            
            fReturnValue = pfnCompatibilityCallback( (PCOMPATIBILITY_ENTRY) &CompatibilityEntry,
                                                     pvContext );
         }
         else
         {
            // It is not necessary to display a compatibility warning.

            fReturnValue = (BOOL) TRUE;
         } // Is it necessary to display a compatibility warning?
      } // Is this system already running NT 5 or later?
   } // Is the cluster service registered?
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// IsCompatibilityWarningRequired
//
// Routine Description:
//    This function determines whether it is necessary to display the compatibility
//    warning message.
//
// Arguments:
//    none
//    
//
// Return Value:
//    TRUE - indicates that it compatibility warning message should be displayed.
//    FALSE - indicates that it is not necessary to display the compatibility
//            warning message.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL  IsCompatibilityWarningRequired( void )
{
   BOOL     fCompatibilityWarningRequired = (BOOL) FALSE;
   
   HCLUSTER hCluster;

   // Open a connection to the cluster to which the machine being upgraded belongs.
   
   hCluster = OpenCluster( NULL );

   // Was the connection to the cluster opened successfully?
   
   if ( hCluster != (HCLUSTER) NULL )
   {
      // A connection to the cluster was opened.
      
      DWORD                dwClusterNameLength;
      DWORD                dwErrorCode;
      
      LPWSTR               lpwszClusterName;
      
      // Allocate a buffer for the cluster name.
      
      lpwszClusterName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                              (MAX_CLUSTERNAME_LENGTH + 1) * sizeof( WCHAR ) );

      // Was the allocation successfull?
      
      if ( lpwszClusterName != (LPWSTR) NULL )
      {
         CLUSTERVERSIONINFO   ClusterVersionInfo;
         
         ClusterVersionInfo.dwVersionInfoSize = sizeof( CLUSTERVERSIONINFO );

         // Query the version information from the cluster.

         dwErrorCode = GetClusterInformation( hCluster,
                                              lpwszClusterName,
                                              &dwClusterNameLength,
                                              &ClusterVersionInfo );

         // Was the cluster version information obtained?
         
         if ( dwErrorCode == (DWORD) ERROR_MORE_DATA )
         {
            // The call to GetClusterInformation failed because the buffer for the
            // cluster name was too small. Get a larger buffer.

            LocalFree( lpwszClusterName );

            lpwszClusterName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                                    (dwClusterNameLength) * sizeof( WCHAR ) );

            // Was the reallocation successfull?
            
            if ( lpwszClusterName != (LPWSTR) NULL )
            {
               // Try a second time to get the version information.


               dwErrorCode = GetClusterInformation( hCluster,
                                                    lpwszClusterName,
                                                    &dwClusterNameLength,
                                                    &ClusterVersionInfo );
            }
            else
            {
               // The reallocation failed
               
               fCompatibilityWarningRequired = (BOOL) TRUE;
            } // Was the reallocation succesfull?
         } // Did the initial call to GetClusterInformation succeed?

         // Was the cluster version information obtained?
         
         if ( dwErrorCode == (DWORD) ERROR_SUCCESS )
         {
            // Examine the cluster version information to determine whether the
            // compatibility warning should be displayed.

            // Note: 
            // If this node is an SP3 node, then the ClusterVersionInfo returned by
            // GetClusterInformation will be of type CLUSTERVERSIONINFO_NT4.

            // If this node is an SP4 node or higher, then the ClusterVersionInfo returned by
            // GetClusterInformation will be of type CLUSTERVERSIONINFO.

            // ClusterVersionInfo.MajorVersion is being set to NT4_MAJOR_VERSION both on 
            // SP4 and on SP3, so this field cannot be used to distinguish between the two.
            // So, we use the ClusterVersionInfo.szCSDVersion for the test.

             if ( ( ClusterVersionInfo.MajorVersion > NT4_MAJOR_VERSION ) ||
                  ( _wcsicmp( ClusterVersionInfo.szCSDVersion, L"Service Pack 3" ) != 0 )
                )
            {
               // This node is an NT4SP4 or higher.

               // It is necessary to examing the dwNodeHighestVersion member of the
               // CLUSTERVERSIONINFO structure.
               if ( CLUSTER_GET_MAJOR_VERSION( ClusterVersionInfo.dwClusterHighestVersion ) >=
                    NT4SP4_MAJOR_VERSION )
               {
                  // There are no NT4/SP3 nodes in the cluster.
                  
                  fCompatibilityWarningRequired = (BOOL) FALSE;
               }
               else
               {
                  // There is at least one NT4/SP3 node in the cluster.
                  
                  fCompatibilityWarningRequired = (BOOL) TRUE;
               }
            }
            else
            {
               // This node is an SP3 node. We cannot find out what the version information of
               // the other node in the cluster (if any). So, issue the warning.
               fCompatibilityWarningRequired = (BOOL) TRUE;
            }
         }
         else
         {
            // The cluster version information was not obtained.

            fCompatibilityWarningRequired = (BOOL) TRUE;
         } // Is the cluster version information available?

         LocalFree( lpwszClusterName );
      }
      else
      {
         // The buffer for the cluster name could not be allocated.
         
         fCompatibilityWarningRequired = (BOOL) TRUE;
      }
      
      // Close the connection to the cluster.
      
      CloseCluster( hCluster );     // Since there is no recovery possible on error,
                                    // the return value is irrelevant.
   }
   else
   {
      // Since a connection to the cluster that this machine belongs to could
      // not be opened no information about the OS version and service pack
      // level can be inferred. It is safest to display the compatibility warning.
      
      fCompatibilityWarningRequired = (BOOL) TRUE;
   } // Was the connection to the cluster opened successfully?
   
   return ( fCompatibilityWarningRequired );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\clusocm\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	clusocm.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\cluscomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ClusComp.rc
//
#define IDS_UPGRADE_OTHER_NODES         33001
#define IDS_CLUSTER_TERMINAL_SERVICES   33002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\clusocm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by CLUSOCM.RC
//

#define IDS_ERR_UNINSTALL_OTHER_SW           40001
#define IDS_ERR_UNINSTALL_OTHER_SW_EXT       40002
#define IDS_START_GROUP_NAME                 40003
#define IDS_START_ITEM_NAME                  40004
#define IDS_OLE_INIT_FAILED                  40005

#define IDS_ERROR_SPAWNING_CLUSCFG           40018

#define IDS_INSTALLING_CLUS_SERVICE          40028
#define IDS_UPGRADING_CLUS_SERVICE           40029
#define IDS_CONFIGURING_CLUS_SERVICE         40030
#define IDS_REMOVING_CLUS_SERVICE            40031
#define IDS_ERR_TERMINAL_SERVICES_SELECTED   40032
#define IDS_ERR_TERMINAL_SERVICES_INSTALLED  40033
#define IDS_ERR_INCORRECT_OS_VERSION         40034


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\clusocm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__63844346_9801_11D1_8CF1_00609713055B__INCLUDED_)
#define AFX_STDAFX_H__63844346_9801_11D1_8CF1_00609713055B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#ifndef __AFX_H__
#undef ASSERT               // make afx.h happy
#endif


#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <setupapi.h>
#include <clusrtl.h>

#include <userenv.h>          // Required for DeleteLinkFile
#include <userenvp.h>         // Required for DeleteLinkFile
#include <shlobj.h>           // Required for DeleteLinkFile

#include <winsvc.h>           // Required for SC_HANDLE, OpenSCManager, etc.
#include <winbase.h>

#include <clusudef.h>
#include <clusrpc.h>

#include <stdlib.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__63844346_9801_11D1_8CF1_00609713055B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\clusocm\clusocm.h ===
// clusocm.h : main header file for the CLUSOCM DLL
//

// Include installstate.h before this file.

#if !defined(AFX_CLUSOCM_H__63844344_9801_11D1_8CF1_00609713055B__INCLUDED_)
#define AFX_CLUSOCM_H__63844344_9801_11D1_8CF1_00609713055B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols
#include <ocmanage.h>

/////////////////////////////////////////////////////////////////////////////
// CClusocmApp
// See clusocm.cpp for the implementation of this class
//

class CClusocmApp : public CWinApp
{
public:
	CClusocmApp();                               // Default constructor

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClusocmApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CClusocmApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG

   virtual BOOL InitInstance();

	DECLARE_MESSAGE_MAP()

public:
   DWORD CClusocmApp::ClusOcmSetupProc( IN LPCVOID pvComponentId,
                                     IN LPCVOID pvSubComponentId,
                                     IN UINT uxFunction,
                                     IN UINT uxParam1,
                                     IN OUT PVOID pvParam2 );

private:
   DWORD OnOcPreinitialize( void );

   DWORD OnOcInitComponent( IN OUT PSETUP_INIT_COMPONENT pvParam2 );

   DWORD OnOcQueryState( IN LPCTSTR ptszSubComponentId,
                         IN UINT uxSelStateQueryType );

   DWORD OnOcSetLanguage( void );

   DWORD OnOcCalcDiskSpace( IN LPCTSTR ptszSubComponentId,
                            IN UINT uxAddOrRemoveFlag,
                            IN OUT HDSKSPC hDiskSpaceList );

   DWORD OnOcQueueFileOps( IN LPCTSTR ptszSubComponentId,
                           IN OUT HSPFILEQ hSetupFileQueue );

   DWORD OnOcQueueFileOpsUnattended( IN LPCTSTR ptszSubComponentId,
                                     IN OUT HSPFILEQ hSetupFileQueue );

   DWORD QueueFileOpsUnattendedUpgrade( IN LPCTSTR ptszSubComponentId,
                                        IN OUT HSPFILEQ hSetupFileQueue );

   DWORD OnOcQueueFileOpsAttended( IN LPCTSTR ptszSubComponentId,
                                   IN OUT HSPFILEQ hSetupFileQueue );

   DWORD OnOcCompleteInstallation( IN LPCTSTR ptszSubComponentId );

   DWORD OnOcQueryChangeSelState( IN LPCTSTR ptszSubComponentId,
                                  IN UINT uxProposedSelectionState,
                                  IN DWORD dwFlags );

   DWORD QueueInstallFileOperations( IN HINF hInfHandle,
                                     IN LPCTSTR ptszSubComponentId,
                                     IN OUT HSPFILEQ hSetupFileQueue );

   DWORD QueueRemoveFileOperations( IN HINF hInfHandle,
                                    IN LPCTSTR ptszSubComponentId,
                                    IN OUT HSPFILEQ hSetupFileQueue );

   DWORD PerformRegistryOperations( HINF hInfHandle,
                                    LPCTSTR ptszSectionName );

   DWORD UninstallRegistryOperations( HINF hInfHandle,
                                      LPCTSTR ptszSubComponentId );

   DWORD OnOcAboutToCommitQueue( IN LPCTSTR ptszSubComponentId );

   BOOL LocateClusterHiveFile( CString & rcsClusterHiveFilePath );

   BOOL CheckForCustomResourceTypes( void );

   VOID UnloadClusDB( VOID );

   VOID TryToRecognizeResourceType( CString& str, LPTSTR keyname );

   BOOL GetServiceBinaryPath( IN LPWSTR lpwszServiceName,
                              OUT LPTSTR lptszBinaryPathName );

   BOOL SetDirectoryIds( BOOL fClusterServiceRegistered );

   DWORD UpgradeClusterServiceImagePath( void );

   DWORD CompleteUninstallingClusteringService( IN LPCTSTR ptszSubComponentId );

   HKEY OpenClusterRegistryRoot( void );

   PWSTR FindNodeNumber( HKEY ClusterKey );

   PWSTR GetConnectionName( HKEY NetInterfacesGuidKey,
                            PCLRTL_NET_ADAPTER_ENUM AdapterEnum );

   PCLRTL_NET_ADAPTER_ENUM GetTCPAdapterInfo( void );

   DWORD RenameConnectionObjects( void );

   DWORD CompleteUpgradingClusteringService( IN LPCTSTR ptszSubComponentId );

   DWORD CompleteStandAloneInstallationOfClusteringService( IN LPCTSTR ptszSubComponentId );

   DWORD CompleteInstallingClusteringService( IN LPCTSTR ptszSubComponentId );

   DWORD OnOcCleanup( void );

   DWORD CleanupDirectories( void );

   BOOL IsDirectoryEmpty( LPCTSTR ptszDirectoryName );

   BOOL GetPathToClusCfg( LPTSTR lptszPathToClusCfg );

   DWORD CalculateStepCount( IN LPCTSTR ptszSubComponentId );

   void SetStepCount( DWORD dwStepCount );

   DWORD GetStepCount( void );
/////////////////////////////////////////////////////////////////////////////

// Data Members

public:

   HINSTANCE             m_hInstance;
private:

   SETUP_INIT_COMPONENT  m_SetupInitComponent;

   char                  m_szOriginalLogFileName[MAX_PATH];

   DWORD                 m_dwStepCount;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

// Non-localizable strings used only by clusocm.dll are defined below.

#define  UNINSTALL_INF_KEY             _T( "Uninstall" )
#define  UPGRADE_INF_KEY               _T( "Upgrade" )
#define  UPGRADE_REPLACEONLY_INF_KEY   _T( "UpgradeReplaceOnly" )
#define  CLUSTER_FILES_INF_KEY         _T( "ClusterFiles" )
#define  REGISTERED_INF_KEY_FRAGMENT   _T( "Registered" )
#define  UNATTEND_COMMAND_LINE_OPTION  _T( "-UNATTEND" )
#define  CLUSTER_CONFIGURATION_PGM     _T( "ClusCfg.exe" )

#endif // !defined(AFX_CLUSOCM_H__63844344_9801_11D1_8CF1_00609713055B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\answerfile.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    AnswerFile.cpp
//
// Abstract:
//    This is the implementation file for the CAnswerFileSection class and
//    its' contained classes.
//
// Author:
//    C. Brent Thomas   a-brentt
//
// Revision History:
//
//    24-Sep-1998    original
//
// Notes:
//
//    The classes implemented in this file include:
//
//          CAnswerFileSection
//          CAnswerFileEntry
//          CParameterListEntry
//
//    I consciously chose not to use MFC because I expect cluster setup to
//    move away from MFC (probably to ATL) when it gets rewritten.
//
/////////////////////////////////////////////////////////////////////////////


#include <windows.h>
#include <setupapi.h>
#include <tchar.h>
#include "AnswerFile.h"



// The following set of functions implements the CParameterList class.

/////////////////////////////////////////////////////////////////////////////
//++
//
// CParameterListEntry
//
// Routine Description:
//    This is the constructor for the CParameterListEntry class.
//
// Arguments:
//    None
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CParameterListEntry::CParameterListEntry()
{
   // Initialize the pointer to the next CParameterListEntry object to NULL.
   
   m_pNextParameter = NULL;   // The CParameterList object that this data
                              // member points to will be allocated with the
                              // new operator.

   // Initialize the pointer to the parameter string to NULL.
   
   m_ptszParameter = NULL;    // The string that this data member points to
                              // will be allocated with the new operator.
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// ~CParameterListEntry
//
// Routine Description:
//    This is the destructor for the CParameterListEntry class.
//
// Arguments:
//    None
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CParameterListEntry::~CParameterListEntry()
{
   // Delete the parameter string.
   
   if ( m_ptszParameter != NULL )
   {
      delete [] m_ptszParameter;
   }

   // Delete any other CParameterListEntry objects that may be in this list.

   if ( m_pNextParameter != NULL )
   {
      delete m_pNextParameter;
   }
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetParameterString
//
// Routine Description:
//    This function allocates memory for a parameter string, initializes the
//    string, ans sets the m_ptszParameter data member of a CParameterListEntry
//    object.
//
// Arguments:
//    ptszParameter - the input string
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates and error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CParameterListEntry::SetParameterString( LPTSTR ptszParameter )
{
   BOOL fReturnValue;

   // Has the parameter string already been set?

   if ( m_ptszParameter != NULL )
   {
      // Free the existing parameter string. It will be replaced below.

      delete m_ptszParameter;
   }

   // Is the parameter meaningfull?

   if ( (ptszParameter != NULL) && (*ptszParameter != TEXT( '\0' )) )
   {
      // Allocate memory for the parameter string ans save its' address.

      m_ptszParameter = new TCHAR[_tcslen( ptszParameter ) + 1];

      _tcscpy( m_ptszParameter, ptszParameter );
   }
   else
   {
      m_ptszParameter = NULL;
   }

   fReturnValue = TRUE;

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetparameterStringPointer
//
// Routine Description:
//    This function returns the contents of the m_ptszParameter member of
//    a CParameterListEntry object.
//
// Arguments:
//    None
//
// Return Value:
//    A pointer to a parameter string.
//
//--
/////////////////////////////////////////////////////////////////////////////

LPTSTR CParameterListEntry::GetParameterStringPointer( void )
{
   return ( m_ptszParameter );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetNextParameterPointer
//
// Routine Description:
//    This function sets the m_pNextParameter data member of a CParameterListEntry object.
//
// Arguments:
//    pParameterListPointer - Points to a CParameterListEntry object.
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates error
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CParameterListEntry::SetNextParameterPointer( CParameterListEntry * pParameterListPointer )
{
   BOOL fReturnValue;

   // If the parameter list pointer has already been set, free it. It will get replaced below.

   if ( m_pNextParameter != NULL )
   {
      delete m_pNextParameter;
   }

   // Set the parameter list pointer member.

   m_pNextParameter = pParameterListPointer;

   fReturnValue = TRUE;

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetParameterListPointer
//
// Routine Description:
//    This function returns the m_pNextParameter data member of a CParameterListEntry object.
//
// Arguments:
//    None
//
// Return Value:
//    The value of the m_pNextParameter data member of a CParameterListEntry object.
//
//--
/////////////////////////////////////////////////////////////////////////////

CParameterListEntry * CParameterListEntry::GetParameterListPointer( void )
{
   return ( m_pNextParameter );
}



// The following set of functions implements the CAnswerFileEntry class.

/////////////////////////////////////////////////////////////////////////////
//++
//
// CAnswerFileEntry
//
// Routine Description:
//    This is the constructor for the CAnswerFileEntry class.
//
// Arguments:
//    None
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CAnswerFileEntry::CAnswerFileEntry()
{
   // Initialize the pointer to the next CAnswerFileEntry object to NULL.
   
   m_pNextEntry = NULL;       // The CAnswerFileEntry object that this
                              // data member points to will be allocated
                              // with the new operator.
                                    
   // Initialize the pointer to the key string to NULL.
   
   m_ptszKey = NULL;          // The string that this data member points to
                              // will be allocated with the new operator.
   
   // Initialize the pointer to the list of parameters to NULL;
   
   m_pParameterList = NULL;   // The CParameterList object that this data
                              // member points to will be allocated with the
                              // new operator.
   
   // Initialize the number of parameters to zero;
   
   m_xParameterCount = 0;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// ~CAnswerFileEntry
//
// Routine Description:
//    This is the destructor for the CAnswerFileEntry class.
//
// Arguments:
//    None
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CAnswerFileEntry::~CAnswerFileEntry()
{
   // Delete the key string.
   
   if ( m_ptszKey != NULL )
   {
      delete [] m_ptszKey;
   }

   // Delete the parameter list.
   
   if ( m_pParameterList != NULL )
   {
      delete m_pParameterList;
   }

   // Delete any other CAnswerFileEntry objects that may be in this list.

   if ( m_pNextEntry != NULL )
   {
      delete m_pNextEntry;
   }
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetKey
//
// Routine Description:
//    This function sets the m_ptszKey data member of a CAnswerFileEntry object.
//    It allocates memory for the string, initializes the string, and sets the
//    m_ptszKey member to point to the string.
//
// Arguments:
//    ptszKey - the string to which the m_ptszKey member should be set.
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CAnswerFileEntry::SetKey( LPTSTR ptszKey )
{
   BOOL  fReturnValue;

   // If the key string has previously been set delete it.

   if ( m_ptszKey != NULL )
   {
      delete m_ptszKey;
   }

   // Set the key string.

   // Is the parameter meaningfull?

   if ( (ptszKey != NULL) && (*ptszKey != TEXT( '\0' )) )
   {
      // Allocate memory for the string and save its' address.

      m_ptszKey = new TCHAR[_tcslen(ptszKey) + 1];

      // Store the key string.

      _tcscpy( m_ptszKey, ptszKey );
   }
   else
   {
      m_ptszKey = NULL;
   }

   fReturnValue = TRUE;

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetKeyPointer
//
// Routine Description:
//    This function returns the contents of the m_ptszKey member of a
//    CAnswerFileEntry object.
//
// Arguments:
//    None
//
// Return Value:
//    A pointer to the key for a CAnswerFileEntry object.
//
//--
/////////////////////////////////////////////////////////////////////////////

LPTSTR CAnswerFileEntry::GetKeyPointer( void )
{
   return ( m_ptszKey );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetParameterCount
//
// Routine Description:
//    This function sets the m_xParameterCount member of a CAnswerFileEntry object.
//
// Arguments:
//    xParameterCount - the number of parameters in the answer file entry
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CAnswerFileEntry::SetParameterCount( int xParameterCount )
{
   BOOL  fReturnValue;

   m_xParameterCount = xParameterCount;

   fReturnValue = TRUE;

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetParameterCount
//
// Routine Description:
//    This function returns the m_xParameterCount member of a CAnswerFileEntry object.
//
// Arguments:
//    None
//
// Return Value:
//    the number of parameters read from the answer file for this entry
//
//--
/////////////////////////////////////////////////////////////////////////////

int CAnswerFileEntry::GetParameterCount( void )
{
   return ( m_xParameterCount );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetNextEntryPointer
//
// Routine Description:
//    This function sets the m_pNextEntry member of a CAnswerFileEntry object.
//
// Arguments:
//    pAnswerFileEntry - points to a CAnswerFileEntry object.
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CAnswerFileEntry::SetNextEntryPointer( CAnswerFileEntry * pEntry )
{
   BOOL  fReturnValue;

   // If the next entry pointer has already been set free it. It will be set below.

   if ( m_pNextEntry != NULL )
   {
      delete m_pNextEntry;
   }

   // Set the next entry pointer.

   m_pNextEntry = pEntry;

   fReturnValue = TRUE;

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetNextEntryPointer
//
// Routine Description:
//    This function returns the m_pNextEntry member of a CAnswerFileEntry object.
//
// Arguments:
//    None
//
// Return Value:
//    The m_pNextEntry member of a CAnswerFileEntry object.
//
//--
/////////////////////////////////////////////////////////////////////////////

CAnswerFileEntry * CAnswerFileEntry::GetNextEntryPointer( void )
{
   return ( m_pNextEntry );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// ReadParameters
//
// Routine Description:
//    This function reads the parameters for an entry in the answer file.
//    It may create and initialize a CParameterListEntry object.
//
// Arguments:
//    pAnswerFileEntry - points to the CAnswerFileEntry object
//    pAnswerFileContext - points to the INFCONTEXT structure for the answer file
//
// Return Value:
//    TRUE - indicates that the parameters were read successfully
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CAnswerFileEntry::ReadParameters( PINFCONTEXT pAnswerFileContext )
{
   BOOL  fReturnValue;

   // Are the parameters meaningfull?

   if ( pAnswerFileContext != NULL )
   {
      DWORD dwFieldCount;

      // How many fields are in the entry? There must be at least one to be meaningfull.

      dwFieldCount = SetupGetFieldCount( pAnswerFileContext );

      if ( dwFieldCount >= 1 )
      {
         // Read the parameters. Apparently SetupGetStringField does not handle
         // empty fields gracefully. So, any empty parameter shall be treated
         // as an error. Parsing will terminate at that point.

         TCHAR tszBuffer[MAX_INF_STRING_LENGTH];   // buffer to receive strings

         // Attempt to read the first parameter.

         fReturnValue = SetupGetStringField( pAnswerFileContext,
                                             1,
                                             tszBuffer,
                                             MAX_INF_STRING_LENGTH,
                                             NULL );

         // Was the first parameter read?

         if ( fReturnValue == TRUE )
         {
            // Is the parameter string non-empty?

            if ( _tcslen( tszBuffer ) > 0 )
            {
               // Create a CParameterListEntry object and save its' address.
      
               CParameterListEntry *   pParameterListEntry;    // working pointer
      
               pParameterListEntry = new CParameterListEntry;
               if ( pParameterListEntry != NULL )
               {
                   SetParameterListPointer( pParameterListEntry );
   
                   // Initialize the first parameter string.
   
                   pParameterListEntry->SetParameterString( tszBuffer );
   
                   int   xParameterCount = 1;    // one parameter has already been read.

                   // Are there additional parameters?
   
                   if ( dwFieldCount >= 2 )
                   {
                      // Read the second and subsequent parameters.
   
                      int   xIndex;
            
                      // On entry to this loop pParameterListEntry points to the first
                      // CParameterListEntry object.
         
                      for ( xIndex = 2; xIndex <= (int) dwFieldCount; xIndex++ )
                      {
                         // Attempt to read a parameter.
         
                         fReturnValue = SetupGetStringField( pAnswerFileContext,
                                                             xIndex,
                                                             tszBuffer,
                                                             MAX_INF_STRING_LENGTH,
                                                             NULL );
         
                         // Was a parameter read?
         
                         if ( fReturnValue == TRUE )
                         {
                            // Is the parameter string non-empty?
            
                            if ( _tcslen( tszBuffer ) > 0 )
                            {
                               // Create a CParameterListEntry object and save its' address.
                  
                               pParameterListEntry->SetNextParameterPointer( new CParameterListEntry );
      
                               // Point to the newly created CParameterListEntry object.
      
                               pParameterListEntry = pParameterListEntry->GetParameterListPointer();
                           
                               // Initialize the parameter string.
               
                               pParameterListEntry->SetParameterString( tszBuffer );

                               // Increment the count of parameters.

                               xParameterCount += 1;
                            } // if - parameter non-empty?
                            else
                            {
                               // Since the parameter is an empty string, terminate
                               // the loop.

                               break;
                            } // if - parameter non-empty?
                         } // if - SetupGetStringField succeeded?
                         else
                         {
                            // Since SetupGetStringField failed, terminate the loop.
                            // fReturnValue will indicate error.
   
                            break;
                         } // if - SetupGetStringField succeeded?
                      } // for loop reading 2nd and subsequent parameters
                   } // Additional parameters?
                   else
                   {
                      fReturnValue = TRUE;
                   } // Additional parameters?

                   // Set the parameter count.

                   SetParameterCount( xParameterCount );
               } // if - memory allocation succeeded
               else
               {
                  fReturnValue = FALSE;
               } // else - memory allocation failed.
            } // if - first parameter non-empty?
            else
            {
               // There is no use attempting to read additional parameters.
   
               SetParameterCount( 0 );
            } // if - first parameter non-empty?
         } // Was a parameter read?
         else
         {
            // There is no use attempting to read additional parameters.

            SetParameterCount( 0 );
         } // Was a parameter read?
      } // two or more fields?
      else
      {
         // It is legal for an entry to have no parameters, but not useful.

         SetParameterCount( 0 );

         fReturnValue = TRUE;
      } // two or more fields?
   }
   else
   {
      fReturnValue = FALSE;
   }

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetParameterListPointer
//
// Routine Description:
//    This function sets the m_pParameterList member of a CAnswerFileEntry object.
//
// Arguments:
//    pParameterList - points to a CParameterListEntry object.
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates that an error occured.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CAnswerFileEntry::SetParameterListPointer( CParameterListEntry * pParameterList )
{
   BOOL  fReturnValue;

   // If the parameter list pointer has already been set free it. It will be set below.

   if ( m_pParameterList != NULL )
   {
      delete m_pParameterList;
   }

   // Set the next entry pointer.

   m_pParameterList = pParameterList;

   fReturnValue = TRUE;

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetParameterListPointer
//
// Routine Description:
//    This function returns the m_pParameterList data member of a CAnswerFileEntry object.
//
// Arguments:
//    None
//
// Return Value:
//    The value of the m_pParameterList data member of a CAnswerFileEntry object.
//
//--
/////////////////////////////////////////////////////////////////////////////

CParameterListEntry * CAnswerFileEntry::GetParameterListPointer( void )
{
   return ( m_pParameterList );
}



// The following set of functions implements the CAnswerFileSection class.

/////////////////////////////////////////////////////////////////////////////
//++
//
// CAnswerFileSection
//
// Routine Description:
//    This is the constructor for the CAnswerFileSection class.
//
// Arguments:
//    None
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CAnswerFileSection::CAnswerFileSection()
{
   // Initialize the pointer to the CAnswerFileEntry objects to NULL.

   m_pEntries = NULL;         // The CAnswerFileEntry object that this data member
                              // points to will be allocated with the new operator.
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetEntryPointer
//
// Routine Description:
//    This function returns the contents of the m_pEntries member of a
//    CAnswerFileSection object.
//
// Arguments:
//    None
//
// Return Value:
//    A pointer to a CAnswerFileEntry object.
//
//--
/////////////////////////////////////////////////////////////////////////////

CAnswerFileEntry * CAnswerFileSection::GetEntryPointer( void )
{
   return ( m_pEntries );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// ~CAnswerFileSection
//
// Routine Description:
//    This is the destructor for the CAnswerFileSection class.
//
// Arguments:
//    None
//    
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CAnswerFileSection::~CAnswerFileSection()
{
   // Delete the CAnswerFileEntry objects.

   if ( m_pEntries != NULL )
   {
      delete m_pEntries;
   }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
// ReadAnswerFileSection
//
// Routine Description:
//    This function reads the entries in an answer file.
//
// Arguments:
//    hAnswerFile - the handle to the answer file
//    ptszSection - points to the answer file section name
//    
//
// Return Value:
//    TRUE - indicates that the section whose name is in ptszSection was read
//           from the answer file whose handle is hAnswerFile successfully.
//    FALSE - indicates that an error occured.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CAnswerFileSection::ReadAnswerFileSection( HINF hAnswerFile,
                                                LPTSTR ptszSection )
{
   BOOL  fReturnValue;

   // Is the desired section present and non-empty in the answer file?

   LONG  lSectionLineCount;

   lSectionLineCount = SetupGetLineCount( hAnswerFile, ptszSection );

   if ( lSectionLineCount > 0L )
   {
      // The section is present and non empty. Find the first entry.

      INFCONTEXT  AnswerFileContext;

      fReturnValue = SetupFindFirstLine( hAnswerFile,
                                         ptszSection,
                                         NULL,           // find first line of the section
                                         &AnswerFileContext );

      // Was the first entry found?

      if ( fReturnValue == TRUE )
      {
         // Get the key for the first entry.

         TCHAR tszBuffer[MAX_INF_STRING_LENGTH];   // buffer to receive strings

         fReturnValue = SetupGetStringField( &AnswerFileContext,
                                             0,                    // get the key
                                             tszBuffer,
                                             MAX_INF_STRING_LENGTH,
                                             NULL );
         // Was the first key read?

         if ( fReturnValue == TRUE )
         {
            // The key for the first entry in the section was read.

            // Create the first CAnswerFileEntry object and save its' address.

            m_pEntries = new CAnswerFileEntry;     // m_pEntries points to the head of
                                                   // the list of CAnswerFileEntry objects.

            if ( m_pEntries == NULL )
            {
                fReturnValue = FALSE;
            }
            else
            {
                // Set the key for the first CAnswerFileEntry object.
                fReturnValue = m_pEntries->SetKey( tszBuffer );
            }

            // Was the key for the first entry set?

            if ( fReturnValue == TRUE )
            {
               // Read the parameters for the first entry.

               fReturnValue = m_pEntries->ReadParameters( &AnswerFileContext );

               // Were the parameters for the first entry read successfully?

               if ( fReturnValue == TRUE )
               {
                  CAnswerFileEntry *   pEntry;        // working pointer to entries

                  // Initialize the working pointer to the head of the list.

                  pEntry = m_pEntries;
         
                  // Read the rest of the entries/

                  while ( (SetupFindNextLine( &AnswerFileContext, &AnswerFileContext ) == TRUE) &&
                          (fReturnValue == TRUE) )
                  {
                     // Create a CAnswerFileEntry object for the next entry.

                     pEntry->SetNextEntryPointer( new CAnswerFileEntry );

                     // Operate on the next entry object.

                     pEntry = pEntry->GetNextEntryPointer();
                     if ( pEntry == FALSE )
                     {
                         fReturnValue = FALSE;
                         break;
                     }

                     // Read the key for this entry.

                     fReturnValue = SetupGetStringField( &AnswerFileContext,
                                                         0,                    // get the key
                                                         tszBuffer,
                                                         MAX_INF_STRING_LENGTH,
                                                         NULL );
                     // Was the key for this entry read?

                     if ( fReturnValue == TRUE )
                     {
                        pEntry->SetKey( tszBuffer );

                        // Read the parameters for the next entry.

                        fReturnValue = pEntry->ReadParameters( &AnswerFileContext );
                     }
                  } // while reading lines in the section
               } // params for first entry read successfully?
            } // Was the first key set?
         } // Was the first key read?
      } // Was the first entry found?
   }
   else
   {
      // Either the section does not exist or it is empty.

      fReturnValue = FALSE;
   } // Does a non-empty section exist?

   return ( fReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\common.cpp ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <setupapi.h>

VOID
DoUninstall(
    IN HWND hWnd
    )
/*++

Routine Description:

    Uninstalls the cluster software by running the uninstall
    section of the cluster INF.

Arguments:

    hWnd - Supplies the hWnd of the dialog to run the INF in.

Return Value:

    None.

--*/

{
    HINF ClusterSetupInf;
    CString TargetInf;
    CString error;
    CString GroupName;
    CString ItemName;

    DoingUninstall = TRUE;
    if(IsOtherSoftwareInstalled())
        return;
    //
    // Stop the services if they are running.
    //
    StopService(L"ClusSvc");
//    StopService(L"ClusDisk");
    StopService(L"TimeServ");

    UnloadClusDB();

    //
    // Register CluAdMMC.
    //
    error = registerCOMObject(FALSE /*bRegister*/, _T("CluAdMMC.dll"), theApp.m_SetupDirectory);
    if (!error.IsEmpty()) {
        MessageBox(hWnd, error, _T("SETUP ERROR"), MB_OK | MB_ICONEXCLAMATION);
    }

    //
    // Register ClAdmWiz.
    //
    error = registerCOMObject(FALSE /*bRegister*/, _T("ClAdmWiz.dll"), theApp.m_SetupDirectory);
    if (!error.IsEmpty()) {
        MessageBox(hWnd, error, _T("SETUP ERROR"), MB_OK | MB_ICONEXCLAMATION);
    }

    //
    // Register CluAdmEx.
    //
    error = registerCOMObject(FALSE /*bRegister*/, _T("CluAdmEx.dll"), theApp.m_SetupDirectory);
    if (!error.IsEmpty()) {
        MessageBox(hWnd, error, _T("SETUP ERROR"), MB_OK | MB_ICONEXCLAMATION);
    }

    //
    // Register IISClEx3.
    //
    error = registerCOMObject(FALSE /*bRegister*/, _T("IISClEx3.dll"), theApp.m_SetupDirectory);
    if (!error.IsEmpty()) {
        MessageBox(hWnd, error, _T("SETUP ERROR"), MB_OK | MB_ICONEXCLAMATION);
    }

    //
    // Register ClNetREx.
    //
    error = registerCOMObject(FALSE /*bRegister*/, _T("ClNetREx.dll"), theApp.m_SetupDirectory);
    if (!error.IsEmpty()) {
        MessageBox(hWnd, error, _T("SETUP ERROR"), MB_OK | MB_ICONEXCLAMATION);
    }

    TargetInf = theApp.m_SetupDirectory;
    TargetInf +=_T("\\CLUSTER.INF");

    //
    // Open the cluster setup INF file.
    //
    ClusterSetupInf = SetupOpenInfFile(TargetInf,
                                       NULL,
                                       INF_STYLE_WIN4,
                                       NULL);
    if (ClusterSetupInf == INVALID_HANDLE_VALUE ) {
        MessageBox(hWnd,_T("couldn't open INF"),_T("SETUP ERROR"),MB_OK | MB_ICONEXCLAMATION);
        return;
    }


    // Uninstall stuff ...

#ifdef   COPYCLUSTERFILES_IS_OBSOLETE
    error = copyClusterFiles(ClusterSetupInf, hWnd, _T("DefaultUninstall"));
    if(!error.IsEmpty()) {
        MessageBox(hWnd,error, _T("SETUP ERROR"), MB_OK | MB_ICONEXCLAMATION);
        return;
    }
#endif   // COPYCLUSTERFILES_IS_OBSOLETE

    //
    // Remove the cluster network provider
    //
    error = removeNetworkProvider();
    if(!error.IsEmpty()) {
        MessageBox(hWnd,error, _T("SETUP ERROR"), MB_OK | MB_ICONEXCLAMATION);
    }

    //
    // Remove the cluster item from the start menu
    //
    GroupName.LoadString(IDS_START_GROUP_NAME);
    ItemName.LoadString(IDS_START_ITEM_NAME);
    DeleteItem(GroupName, TRUE, ItemName, FALSE);

    if ((!theApp.m_UninstallOnError) || theApp.m_RebootOnUninstall) {
        if (theApp.m_CommandLine->m_Force) {
            SystemShutdown();
        } else {
            BOOL nResponse = AfxMessageBox(IDS_WRN_UNINSTALL,MB_OKCANCEL | MB_ICONEXCLAMATION);
            if(nResponse == IDOK)
                            SystemShutdown();
/*            SetupPromptReboot(NULL,
                              hWnd,
                              FALSE);*/
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\clusocm\clusocm.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Module Name:
//    clusocm.cpp
//
//  Abstract:
//    CLUSOCM.DLL is an Optional Components Manager DLL for installation of
//    Microsoft Cluster Server. This file is the class implementation file
//    for the CClusocmApp class which implements the component setup procedure.
//
//  Author:
//    C. Brent Thomas (a-brentt)
//
//  Revision History:
//    1/29/98  original
//
// Notes:
//
//      If this DLL is dynamically linked against the MFC
//      DLLs, any functions exported from this DLL which
//      call into MFC must have the AFX_MANAGE_STATE macro
//      added at the very beginning of the function.
//
//      For example:
//
//      extern "C" BOOL PASCAL EXPORT ExportedFunction()
//      {
//          AFX_MANAGE_STATE(AfxGetStaticModuleState());
//          // normal function body here
//      }
//
//      It is very important that this macro appear in each
//      function, prior to any calls into MFC.  This means that
//      it must appear as the first statement within the
//      function, even before any object variable declarations
//      as their constructors may generate calls into the MFC
//      DLL.
//
//      Please see MFC Technical Notes 33 and 58 for additional
//      details.
//
//
/////////////////////////////////////////////////////////////////////////////
//

#include "stdafx.h"
#include "clusocm.h"
#include <regcomobj.h>
#include <StopService.h>
#include <RemoveNetworkProvider.h>
#include <IsClusterServiceRegistered.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// Global Data


/////////////////////////////////////////////////////////////////////////////
// The one and only CClusocmApp object

CClusocmApp theApp;

/////////////////////////////////////////////////////////////////////////////
// Global Functions

// This is the function that OC Manager will call.
/////////////////////////////////////////////////////////////////////////////
//++
//
// ClusOcmSetupProc
//
// Routine Description:
//    This is the exported function that OC Manager calls. It merely passes
//    its' parameters to the CClusocmApp object and returns the results to
//    OC Manager.
//
// Arguments:
//    pvComponentId - points to a string that uniquely identifies the component
//                    to be set up to OC Manager.
//    pvSubComponentId - points to a string that uniquely identifies a sub-
//                       component in the component's hiearchy.
//    uxFunction - A numeric value indicating which function is to be perfomed.
//                 See ocmanage.h for the macro definitions.
//    uxParam1 - supplies a function specific parameter.
//    pvParam2 - points to a function specific parameter (which may be an
//               output).
//
// Return Value:
//    A function specific value is returned to OC Manager.
//
//--
/////////////////////////////////////////////////////////////////////////////

extern "C" DWORD WINAPI ClusOcmSetupProc( IN LPCVOID pvComponentId,
                                          IN LPCVOID pvSubComponentId,
                                          IN UINT uxFunction,
                                          IN UINT uxParam1,
                                          IN OUT PVOID pvParam2 )
{
	return theApp.ClusOcmSetupProc( pvComponentId,
                                   pvSubComponentId,
                                   uxFunction,
                                   uxParam1,
                                   pvParam2 );

} //*** exported ClusOcmSetupProc()


/////////////////////////////////////////////////////////////////////////////
// CClusocmApp

BEGIN_MESSAGE_MAP(CClusocmApp, CWinApp)
	//{{AFX_MSG_MAP(CClusocmApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClusocmApp construction

// Default constructor

CClusocmApp::CClusocmApp()
{
   // TODO: add construction code here,
   // Place all significant initialization in InitInstance

   // Initialize the values of the HINF members in the SETUP_INIT_COMPONENT
   // structure data member.

   m_SetupInitComponent.OCInfHandle = (HINF) INVALID_HANDLE_VALUE;
   m_SetupInitComponent.ComponentInfHandle = (HINF) INVALID_HANDLE_VALUE;

   m_dwStepCount = 0L;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// InitInstance
//
// Routine Description:
//
//
// Arguments:
//
//
//
// Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusocmApp::InitInstance( void )
{
   BOOL  fReturnValue = (BOOL) TRUE;

   m_hInstance = AfxGetInstanceHandle();

	// Initialize OLE libraries

	if (!AfxOleInit())
	{
      if ( (m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_BATCH) ==
           (DWORDLONG) 0L )
      {
         AfxMessageBox( IDS_OLE_INIT_FAILED );
      }

      ClRtlLogPrint( "OLE initialization failed.  Make sure that the OLE libraries are the correct version.\n" );

		fReturnValue = (BOOL) FALSE;
	}

   return ( fReturnValue );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
// CClusocmApp::ClusOcmSetupProc
//
//	Routine Description:
//    This function implements the Optional Components Manager component
//    setup procedure. This function is called by the exported function
//    of the same name, which in turn is called by OC Manager.
//
// Arguments:
//    pvComponentId - points to a string that uniquely identifies the component
//                    to be set up to OC Manager.
//    pvSubComponentId - points to a string that uniquely identifies a sub-
//                       component in the component's hiearchy.
//    uxFunction - A numeric value indicating which function is to be perfomed.
//                 See ocmanage.h for the macro definitions.
//    uxParam1 - supplies a function specific parameter.
//    pvParam2 - points to a function specific parameter (which may be an
//               output).
//
//
//	Return Value:
//    A function specific value is returned to OC Manager.
//
//--
/////////////////////////////////////////////////////////////////////////////

#pragma  warning ( disable : 4100 )     // disable "unreferenced formal parameter" warning
                                        // At this time (2/26/98) pvComponentId is unused.

DWORD CClusocmApp::ClusOcmSetupProc( IN LPCVOID pvComponentId,
                                     IN LPCVOID pvSubComponentId,
                                     IN UINT uxFunction,
                                     IN UINT uxParam1,
                                     IN OUT PVOID pvParam2 )
{
   AFX_MANAGE_STATE( AfxGetStaticModuleState() );     // As per the note in file header

   DWORD dwReturnValue;

   switch ( uxFunction )
   {
      case OC_PREINITIALIZE:

         // This is the first interface function that OC Manager calls.

         // OnOcPreinitialize enables the log file for clusocm.dll, verifies
         // that the OS version and Product Suite are correct, etc.

         dwReturnValue = OnOcPreinitialize();

         ClRtlLogPrint( "OnOcPreinitialize returned 0x%1!x!\n\n", dwReturnValue );

         break;

      case OC_INIT_COMPONENT:

         // This function is called soon after the component's setup dll is
         // loaded. This function provides initialization information to the
         // dll, instructs the dll to initialize itself, and provides a
         // mechanism for the dll to return information to OC Manager.

         // It may be desirable to verify that Microsoft Cluster Server is being
         // installed on NT Enterprise and to authenticate the user at this point.

         dwReturnValue = OnOcInitComponent((PSETUP_INIT_COMPONENT) pvParam2 );

         ClRtlLogPrint( "OnOcInitComponent returned 0x%1!x!\n\n", dwReturnValue );

         break;

      case OC_REQUEST_PAGES:

         // OC Manager is requesting a set of wizard pages from the dll.
         // As of 2/16/98 there are no wizard pages to supply.

         dwReturnValue = (DWORD) 0L;

         ClRtlLogPrint( "ClusOcmSetupProc is returning 0x%1!x! in response to OC_REQUEST_PAGES.\n\n",
                        dwReturnValue );

         break;

      case OC_QUERY_STATE:

         // Oc Manager is requesting the selection state of the component.
         // It does that at least three times.

         dwReturnValue = OnOcQueryState( (LPCTSTR) pvSubComponentId, uxParam1 );

         ClRtlLogPrint( "OnQueryState returned 0x%1!x!\n\n", dwReturnValue );

         break;

      case OC_SET_LANGUAGE:

         // OC Manager documentation states:
         //
         // "If a component does not support multiple languages, or if it does
         // not support the requested language, then it may ignore OC_SET_LANGUAGE."

         // I have replicated the functionality in Pat Styles' generic sample, ocgen.cpp.

         dwReturnValue = OnOcSetLanguage();

         ClRtlLogPrint( "OnOcSetLanguage returned 0x%1!x!.\n\n", dwReturnValue );

         break;

      case OC_CALC_DISK_SPACE:

         dwReturnValue = OnOcCalcDiskSpace( (LPCTSTR) pvSubComponentId,
                                            uxParam1,
                                            (HDSKSPC) pvParam2 );

         ClRtlLogPrint( "OnOcCalcDiskSpace returned 0x%1!x!.\n\n", dwReturnValue );

         break;

      case OC_QUEUE_FILE_OPS:

         if ( (pvSubComponentId != (PVOID) NULL) &&
              (*((LPCTSTR) pvSubComponentId) != _T('\0')) )
         {
            dwReturnValue = OnOcQueueFileOps( (LPCTSTR) pvSubComponentId,
                                              (HSPFILEQ) pvParam2 );

            ClRtlLogPrint( "OnOcQueueFileOps returned 0x%1!x!.\n\n", dwReturnValue );
         }
         else
         {
            dwReturnValue = (DWORD) NO_ERROR;
         }

         break;

      case OC_QUERY_CHANGE_SEL_STATE:

         dwReturnValue = OnOcQueryChangeSelState( (LPCTSTR) pvSubComponentId,
                                                  (UINT) uxParam1,
                                                  (DWORD) ((DWORD_PTR)pvParam2) );

         ClRtlLogPrint( "OnOnQueryChangeSelState returned 0x%1!x!.\n\n", dwReturnValue );

         break;

      case OC_COMPLETE_INSTALLATION:

         if ( (pvSubComponentId != (PVOID) NULL) &&
              (*((LPCTSTR) pvSubComponentId) != _T('\0')) )
         {
            dwReturnValue = OnOcCompleteInstallation( (LPCTSTR) pvSubComponentId );

            ClRtlLogPrint( "OnOcCompleteInstallation returned 0x%1!x!.\n\n", dwReturnValue );
         }
         else
         {
            dwReturnValue = (DWORD) NO_ERROR;
         }

         break;

      case OC_WIZARD_CREATED:

         // This interface function code is not documented. I have replicated the
         // functionality of Pat Styles' generic sample, ocgen.cpp.

         dwReturnValue = (DWORD) NO_ERROR;

         ClRtlLogPrint( "returning 0x%1!x! for OC_WIZARD_CREATED.\n\n", dwReturnValue );

         break;

      case OC_NEED_MEDIA:

         // This interface function code is not documented. I have replicated the
         // functionality of Pat Styles' generic sample, ocgen.cpp.

         dwReturnValue = (DWORD) FALSE;

         ClRtlLogPrint( "returning 0x%1!x! for OC_NEED_MEDIA.\n\n" );

         break;

      case OC_QUERY_SKIP_PAGE:

         // This interface function code is not documented. I have replicated the
         // functionality of Pat Styles' generic sample, ocgen.cpp.

         dwReturnValue = (DWORD) FALSE;

         ClRtlLogPrint( "returning 0x%1!x! for OC_QUERY_SKIP_PAGE.\n\n", dwReturnValue );

         break;

      case OC_QUERY_STEP_COUNT:

         // OC Manager uses this interface function code to request the number
         // of "steps", other than file operations, that must be performed to
         // install the component.

         if ( (pvSubComponentId != (PVOID) NULL) &&
              (*((LPCTSTR) pvSubComponentId) != _T('\0')) )
         {
            dwReturnValue = CalculateStepCount( (LPCTSTR) pvSubComponentId );

            if ( dwReturnValue != 0L )
            {
               // Update the data member.

               SetStepCount( dwReturnValue );
            }
         }
         else
         {
            dwReturnValue = (DWORD) NO_ERROR;
         }

         ClRtlLogPrint( "returning 0x%1!x! for OC_QUERY_STEP_COUNT.\n\n", dwReturnValue );

         break;

      case OC_CLEANUP:

         // This interface function code is the last to be processed.

         // OC Manager documentation states that the return value from processing
         // this interface function code is ignored.

         dwReturnValue = OnOcCleanup();

         break;

      case OC_ABOUT_TO_COMMIT_QUEUE:

         if ( (pvSubComponentId != (PVOID) NULL) &&
              (*((LPCTSTR) pvSubComponentId) != _T('\0')) )
         {
            dwReturnValue = OnOcAboutToCommitQueue( (LPCTSTR) pvSubComponentId );

            ClRtlLogPrint( "OnOcAboutToCommitQueue returned 0x%1!x!.\n\n", dwReturnValue );
         }
         else
         {
            dwReturnValue = (DWORD) NO_ERROR;
         }

         break;

      case OC_EXTRA_ROUTINES:

         dwReturnValue = (DWORD) NO_ERROR;

         ClRtlLogPrint( "returning 0x%1!x! for OC_EXTRA_ROUTINES.\n\n", dwReturnValue );

         break;

      default:

         dwReturnValue = (DWORD) NO_ERROR;

         ClRtlLogPrint( "ClusOcmSetupProc received an unknown function code, 0x%1!x!.\n",
                        uxFunction );
         ClRtlLogPrint( "returning 0x%1!x!.\n", dwReturnValue );

         break;
   }  // end of switch( uxFunction )

   return ( (DWORD) dwReturnValue );
}

#pragma warning ( default : 4100 )  // default behavior "unreferenced formal parameter" warning



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcPreinitialize
//
// Routine Description:
//    This funcion processes OC_PREINITIALIZE "messages" from Optional
//    Components Manager. This is the first function in the component
//    setup dll that OC Manager calls.
//
//    This function prevents clusocm.dll from running on down level operating
//    systems and unuthorized platforms.
//
//    Since Microsoft Cluster Server can only be installed on NT this function
//    selects the UNICODE character set.
//
// Arguments:
//    None
//
// Return Value:
//    (DWORD) OCFLAG_UNICODE - indicates success
//    (DWORD) 0 - indicates that the component cannot be initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcPreinitialize( void )
{
   DWORD dwReturnValue;

   // The ClRtlInitialize function that opens a log file reads the ClusterLog
   // environment variable. This code segment reads that environment variable
   // and saves it so that it can be restored on exit.

   char *   pszOriginalLogFileName;

   pszOriginalLogFileName = getenv( "ClusterLog" );

   if ( pszOriginalLogFileName != (char *) NULL )
   {
      strcpy( m_szOriginalLogFileName, pszOriginalLogFileName );
   }
   else
   {
      *m_szOriginalLogFileName = (char) '\0';
   }

   // Build the string used to set the ClusterLog environment variable to point
   // to the log for clusocm.dll.

   char szClusterLogEnvString[MAX_PATH];

   // Initialize the string to be empty.

   *szClusterLogEnvString = '\0';

   // The log file for clusocm.dll will be located in the windows directory.
   // Note that if the path to the Windows directory cannot be obtained the
   // ClusterLog environment variable will be set empty. Then function ClRtlInitialize
   // will use the default log file name and location.

   TCHAR tszWindowsDirectory[MAX_PATH];

   UINT  uxReturnValue;

   uxReturnValue = GetWindowsDirectory( tszWindowsDirectory, (UINT) MAX_PATH );

   if ( uxReturnValue > 0 )
   {
      // The first part of the string to set the ClusterLog environment variable is
      // "ClusterLog=".

      strcpy( szClusterLogEnvString, "ClusterLog=" );

      // Convert the path to the Windows directory to MBCS.

      char  szWindowsDirectory[MAX_PATH];

      wcstombs( szWindowsDirectory, tszWindowsDirectory, MAX_PATH );

      // Append the path to the Windows directory.

      strcat( szClusterLogEnvString, szWindowsDirectory );

      // Append the log file name.

      strcat( szClusterLogEnvString, "\\clusocm.log" );
   }  // Was the path to the Windows directory obtained?

   // Set the ClusterLog environment variable. Note that _putenv returns 0
   // on success.

   if ( _putenv( szClusterLogEnvString ) != 0 )
   {
      dwReturnValue = GetLastError();  // just here for debugging
   }

   // Initialize the cluster runtime library. FALSE indicates that debug
   // output should not be redirected to a console window. If ClRtlInitialize
   // fails the calls to ClRtlLogPrint will be benign.

   ClRtlInitialize( FALSE );

   // Note: The date in the following statement is hardcoded on purpose. It is to
   //       indicate when the last time the logging statements were revised.

   ClRtlLogPrint( "\n\nCLUSOCM.LOG version 04/09/99 13:20.\n" );

   // Microsoft Cluster Server can only be installed on Windows NT Server Enterprise 5.0+.

   // This code segment checks the operating system version.

   // Since Microsoft Cluster Server can only be installed on NT indicate
   // to OC Manager that the UNICODE character set should be used.

   dwReturnValue = (DWORD) OCFLAG_UNICODE;

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcInitComponent
//
// Routine Description:
//    This funcion processes OC_INIT_COMPONENT "messages" from Optional
//    Components Manager.
//
//    This function is called soon after the component's setup dll is
//    loaded. This function provides initialization information to the
//    dll, instructs the dll to initialize itself, and provides a
//    mechanism for the dll to return information to OC Manager.
//
// Arguments:
//    pSetupInitComponent - points to a SETUP_INIT_COMPONENT structure
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
// Note:
//    The SETUP_INIT_COMPONENT structure pointed to by pSetupInitComponent
//    DOES NOT PERSIST. It is ncessary to save a copy in the CClusocmApp object.
//    This function initializes the SETUP_INIT_COMPONENT data member,
//    m_SetupInitComponent.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcInitComponent( IN OUT PSETUP_INIT_COMPONENT pSetupInitComponent )
{
   DWORD dwReturnValue;

   if ( pSetupInitComponent != (PSETUP_INIT_COMPONENT) NULL )
   {
      // Save the pointer to the SETUP_INIT_COMPONENT structure.

      m_SetupInitComponent = *pSetupInitComponent;

      // This code segment determines whether the version of OC Manager is
      // correct.

      if ( OCMANAGER_VERSION <= m_SetupInitComponent.OCManagerVersion )
      {
         // Indicate to OC Manager which version of OC Manager this dll expects.

         pSetupInitComponent->ComponentVersion = OCMANAGER_VERSION;

         // Update CClusocmApp's copy of the SETUP_INIT_COMPONENT structure.

         m_SetupInitComponent.ComponentVersion = OCMANAGER_VERSION;

         // Is the handle to the component INF valid ?

         if ( (m_SetupInitComponent.ComponentInfHandle !=
               (HINF) INVALID_HANDLE_VALUE) &&
              (m_SetupInitComponent.ComponentInfHandle !=
               (HINF) NULL) )
         {
            // The following call to SetupOpenAppendInfFile ensures that layout.inf
            // gets appended to clusocm.inf. This is required for several reasons
            // dictated by the Setup API. In theory OC Manager should do this, but
            // as per Andrew Ritz, 8/24/98, OC manager neglects to do it and it is
            // harmless to do it here after OC Manager is revised.

            // Note that passing NULL as the first parameter causes SetupOpenAppendInfFile
            // to append the file(s) listed on the LayoutFile entry in clusocm.inf.

            UINT uxStatus;

            SetupOpenAppendInfFile( NULL, m_SetupInitComponent.ComponentInfHandle,
                                    &uxStatus );

            if ( ClRtlIsOSValid() == TRUE )
            {
               // Since Microsoft Cluster Server can only be installed on NT indicate
               // to OC Manager that the UNICODE character set should be used.

               dwReturnValue = (DWORD) NO_ERROR;
            }
            else
            {
               // The operating system version is not correct.

               if ( (m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_BATCH) ==
                    (DWORDLONG) 0L )
               {
                  CString  csMessage;

                  csMessage.LoadString( IDS_ERR_INCORRECT_OS_VERSION );

                  AfxMessageBox( csMessage );
               }

               DWORD dwErrorCode;

               dwErrorCode = GetLastError();

               ClRtlLogPrint( "ClRtlIsOSValid failed with error code %1!x!.\n",
                              dwErrorCode );

               dwReturnValue = (DWORD) ERROR_CALL_NOT_IMPLEMENTED;
            }
         }
         else
         {
            // Indicate failure.

            ClRtlLogPrint( "In OnOcInitComponent the ComponentInfHandle is bad.\n" );

            dwReturnValue = (DWORD) ERROR_CALL_NOT_IMPLEMENTED;
         }
      }
      else
      {
         // Indicate failure.

         ClRtlLogPrint( "An OC Manager version mismatch. Version %1!d! is required, version %2!d! was reported.\n",
                        OCMANAGER_VERSION, m_SetupInitComponent.OCManagerVersion );

         dwReturnValue = (DWORD) ERROR_CALL_NOT_IMPLEMENTED;
      }
   }
   else
   {
      ClRtlLogPrint( "In OnOcInitComponent the pointer to the SETUP_INIT_COMPONENT structure is NULL.\n" );

      dwReturnValue = (DWORD) ERROR_CALL_NOT_IMPLEMENTED;
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcQueryState
//
// Routine Description:
//    This funcion sets the original, current, and final selection states of the
//    Cluster service optional component.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//    uxSelStateQueryType - indicates whether OC Manager is requesting the
//                          original, current, or final selection state of the
//                          component
//
// Return Value:
//    SubcompOn - indicates that the checkbox should be set
//    SubcompOff - indicates that the checkbox should be clear
//    SubcompUseOCManagerDefault - OC Manager should set the state of the checkbox
//                                 according to state information that is maintained
//                                 internally by OC Manager itself.
//
// Note:
//    By the time this function gets called OnOcInitComponent has already determined
//    that Terminal Services is not installed. It is only necessary to determine
//    whether Terminal Services is selected for installation.
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcQueryState( IN LPCTSTR ptszSubComponentId,
                                   IN UINT uxSelStateQueryType )
{
   DWORD dwReturnValue;
   eClusterInstallState eState;

   // For unattended setup the selection state of the Cluster service optional
   // component is specified in the answer file. Pat Styles recommends returning
   // SubcompUseOcManagerDefault in every case.

   // The following "if" statement forces SubcompUseOcManagerDefault to be returned
   // if the subcomponent name is invalid.

   if ( ptszSubComponentId != (LPCTSTR) NULL )
   {
      // The subcomponent ID is valid. For what purpose was this function called?

      switch ( uxSelStateQueryType )
      {
         case OCSELSTATETYPE_ORIGINAL:

            // OC Manager is requesting the intitial (original) selection state
            // of the component.

            // Is this a fresh install running under GUI mode setup ?

            if ( ( (m_SetupInitComponent.SetupData.OperationFlags &
                    (DWORDLONG) SETUPOP_STANDALONE) == (DWORDLONG) 0L ) &&
                 ( (m_SetupInitComponent.SetupData.OperationFlags &
                    (DWORDLONG) SETUPOP_NTUPGRADE) == (DWORDLONG) 0L ) )
            {
               // SETUPOP_STANDALONE flag clear means running under GUI mode setup.
               // SETUPOP_NTUPGRADE flag clear means not performing an upgrade.
               // Both flags clear means a fresh install in GUI MODE setup.

               // Return SubcompUseOcManagerDefault. As per AndrewR, for unattended
               // clean install return SubcompUseOcManagerDefault. For attended
               // clean install let OC Manager manage the selection state. Returning
               // SubcompUseOcManagerDefault will allow OC Manager to honor the
               // "modes" line in clusocm.inf if one is present.

               dwReturnValue = (DWORD) SubcompUseOcManagerDefault;

               ClRtlLogPrint( "OnOcQueryState is returning SubcompUseOcManagerDefault for ORIGINAL on a clean install.\n" );
            } // clean install?
            else
            {
               // This is standalone or upgrade. Is this an unattended clean install?

               if ( ( (m_SetupInitComponent.SetupData.OperationFlags &
                      (DWORDLONG) SETUPOP_BATCH) != (DWORDLONG) 0L ) &&
                    ( (m_SetupInitComponent.SetupData.OperationFlags &
                      (DWORDLONG) SETUPOP_NTUPGRADE) == (DWORDLONG) 0L ) )
               {
                  // This is UNATTENDED INSTALL with OCM running STANDALONE. Since
                  // this is STANDALONE, the MUST be an answer file.

                  // As per AndrewR for unattended clean install return SubcompUseOcManagerDefault.

                  dwReturnValue = (DWORD) SubcompUseOcManagerDefault;

                  ClRtlLogPrint( "ORIGINAL selection state: SubcompUseOcManagerDefault - UNATTENDED CLEAN install.\n" );
               }
               else
               {
                  // Either an upgrade is in progress or OC Manager is running standalone.
                  // The state of the checkbox depends on whether Cluster service has
                  // previously been installed.

                  // GetClusterInstallationState reports on the state of the registry value
                  // that records the state of the Cluster service installation on NT 5 machines.
                  // IsClusterServiceRegistered indicates whether the Cluster service is registered on
                  // BOTH NT 4 and NT 5 machines. Both tests are required: IsClusterServiceRegistered for
                  // upgrading NT 4 machines, GetClusterInstallationState for NT 5 machines.

                  ClRtlGetClusterInstallState( NULL, &eState );

                  if ( ( eState != eClusterInstallStateUnknown ) ||
                       ( IsClusterServiceRegistered() == (BOOL) TRUE ) )
                  {
                     // No error was detected.

                     dwReturnValue = (DWORD) SubcompOn;

                     ClRtlLogPrint( "ORIGINAL selection state: SubcompOn - UPGRADE or STANDALONE - Cluster service previously installed.\n" );
                  }
                  else
                  {
                     // Some error occured.

                     dwReturnValue = (DWORD) SubcompOff;

                  ClRtlLogPrint( "ORIGINAL selection state: SubcompOff - UPGRADE or STANDALONE - Cluster service NOT previously installed.\n" );
                  }  // Were the Cluster service files installed?
               } // unattended?
            }  // Is this a fresh install?

            break;

         case OCSELSTATETYPE_CURRENT:

            // OC Manager is requesting the current selection state of the component.

            // For the cases of a "clean" install or when OC manager is running
            // standalone it is safe to let OC Manager use the default selection state
            // to determine the cuttent selection state. The UPGRADE case requires
            // specific handling. Is this an UPGRADE?

            if ( (m_SetupInitComponent.SetupData.OperationFlags &
                  (DWORDLONG) SETUPOP_NTUPGRADE) != (DWORDLONG) 0L )
            {
               // This is an upgrade. The state of the checkbox depends on whether
               // Cluster service has previously been installed.

               // GetClusterInstallationState reports on the state of the registry value
               // that records the state of the Cluster service installation on NT 5 machines.
               // IsClusterServiceRegistered indicates whether the Cluster service is registered on
               // BOTH NT 4 and NT 5 machines. Both tests are required: IsClusterServiceRegistered for
               // upgrading NT 4 machines, GetClusterInstallationState for NT 5 machines.

               ClRtlGetClusterInstallState( NULL, &eState );

               if ( ( eState != eClusterInstallStateUnknown ) ||
                    ( IsClusterServiceRegistered() == (BOOL) TRUE ) )
               {
                  // No error was detected.

                  dwReturnValue = (DWORD) SubcompOn;

                  ClRtlLogPrint( "CURRENT selection state: SubcompOn - UPGRADE - Cluster service previously installed.\n" );
               }
               else
               {
               // Some error occured.

                  dwReturnValue = (DWORD) SubcompOff;

                  ClRtlLogPrint( "CURRENT selection state: SubcompOff - UPGRADE - Cluster service NOT previously installed.\n" );
               }  // Were the Cluster service files installed?
            }
            else
            {
               // This is either a "fresh" install or OC Manager is running standalone.
               dwReturnValue = (DWORD) SubcompUseOcManagerDefault;

               ClRtlLogPrint( "CURRENT selection state: SubcompUseOcManagerDefault - CLEAN install or STANDALONE.\n" );
            }  // Is this an UPGRADE?

            break;

         case OCSELSTATETYPE_FINAL:

            // OC Manager is requesting the final selection state of the component.

            // As per Pat Styles, this call to OnOcQueryState will occur AFTER
            // OnOcCompleteInstallation has been called. The registry operation that
            // creates the registry key that GetClusterInstallationState checks as
            // its' indicator of success is queued by OnOcCompleteInstallation.

            // Does this OC Manager Setup DLL believe it has completed without error?

            ClRtlGetClusterInstallState( NULL, &eState );
            if ( eState != eClusterInstallStateUnknown )
            {
               // No error was detected.

               dwReturnValue = (DWORD) SubcompOn;

               ClRtlLogPrint( "FINAL selection state: SubcompOn.\n" );
            }
            else
            {
               // Some error occured.

               dwReturnValue = (DWORD) SubcompOff;

               ClRtlLogPrint( "FINAL selection state: SubcompOff.\n" );
            }  // Were the Cluster service files installed?

            break;

         default:

            // This is an error condition.

            dwReturnValue = (DWORD) SubcompUseOcManagerDefault;

            ClRtlLogPrint( "Bad Param1 passed to OnOcQueryState.\n" );

            break;
      }  // end of switch ( uxSelStateQueryType )
   }
   else
   {
      // The subcomponent ID is invalid.

      dwReturnValue = (DWORD) SubcompUseOcManagerDefault;

      ClRtlLogPrint( "In OnOcQueryState the subcomponent ID is NULL.\n" );
   }  // Is the subcomponent ID legal?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcSetLanguage
//
// Routine Description:
//    This funcion indicates to OC Manager that clusocm.dll cannot handle
//    alternate langiages.
//
// Arguments:
//    None
//
// Return Value:
//    (DWORD) FALSE
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcSetLanguage( void )
{
   // Returning (DWORD) FALSE will indicate to OC Manager that the component
   // setup dll does not support the requested language.

   return (DWORD) FALSE;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcCalcDiskSpace
//
// Routine Description:
//    This function processes the OC_CALC_DISK_SPACE "messages" from the
//    Optional Components Manager. It either adds or removes disk space
//    requirements from the Disk Space List maintained by OC Manager.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//    uxAddOrRemoveFlag - Non-zero means that the component setup dll is being
//                        asked to add space requirements for a subcomponent to
//                        the disk space list. ZERO means that the component
//                        setup dll is being asked to remove space requirements
//                        for the subcomponent from the disk space list.
//    hDiskSpaceList - a HDSPSPC (typedefed in setupapi.h to PVOID)
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcCalcDiskSpace( IN LPCTSTR ptszSubComponentId,
                                      IN UINT uxAddOrRemoveFlag,
                                      IN OUT HDSKSPC hDiskSpaceList )
{
   DWORD dwReturnValue = NO_ERROR;

   // Is the subcomponent ID meaningfull?

   if ( ptszSubComponentId != (LPCTSTR) NULL )
   {
      // Is the handle to the component INF file meaningfull?

      if ( (m_SetupInitComponent.ComponentInfHandle !=
            (HINF) INVALID_HANDLE_VALUE) &&
           (m_SetupInitComponent.ComponentInfHandle !=
            (HINF) NULL) )
      {
         BOOL  fReturnValue;

         // The INF file is open. Now we can use it.

         // Associate the user defined Directory IDs in the [DestinationDirs] section
         // of clusocm.inf with actual directories.

         BOOL  fClusterServiceRegistered;

         fClusterServiceRegistered = IsClusterServiceRegistered();

         if ( SetDirectoryIds( fClusterServiceRegistered ) == (BOOL) TRUE )
         {
            if ( uxAddOrRemoveFlag != (UINT) 0 )
            {
               // Add disk space requirements to the file disk space list.

               fReturnValue =
                  SetupAddInstallSectionToDiskSpaceList( hDiskSpaceList,
                                                         m_SetupInitComponent.ComponentInfHandle,
                                                         NULL,
                                                         ptszSubComponentId,
                                                         0,
                                                         0 );

               if ( fReturnValue == (BOOL) FALSE )
               {
                  dwReturnValue = GetLastError();
               }

               ClRtlLogPrint( "SetupAddInstallSectionToDiskSpaceList returned 0x%1!x! to OnOcCalcDiskSpace.\n",
                              fReturnValue );
            }
            else
            {
               // Remove disk space requirements from the disk space list.

               fReturnValue =
                   SetupRemoveInstallSectionFromDiskSpaceList( hDiskSpaceList,
                                                               m_SetupInitComponent.ComponentInfHandle,
                                                               NULL,
                                                               ptszSubComponentId,
                                                               0,
                                                               0 );

               if ( fReturnValue == (BOOL) FALSE )
               {
                  dwReturnValue = GetLastError();
               }

               ClRtlLogPrint( "SetupRemoveInstallSectionFromDiskSpaceList returned 0x%1!x! to OnOcCalcDiskSpace.\n",
                              fReturnValue );
            }
         }
         else
         {
            dwReturnValue = GetLastError();

            ClRtlLogPrint( "In OnCalcDiskSpace the call to SetDirectoryIds failed.\n" );
            ClRtlLogPrint( "The error code is 0x%1!x!.\n", dwReturnValue );
         }  // Were the directory Id associations made successfully?
      }
      else
      {
         ClRtlLogPrint( "In OnOcCalcDiskSpace ComponentInfHandle is bad.\n" );

         dwReturnValue = ERROR_FILE_NOT_FOUND;
      }
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcCompleteInstallation
//
// Routine Description:
//    This function processes the OC_COMPLETE_INSTALLATION "messages" from the
//    Optional Components Manager. It queues registry operations.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcCompleteInstallation( IN LPCTSTR ptszSubComponentId )
{
   DWORD dwReturnValue = NO_ERROR;

   if ( (m_SetupInitComponent.ComponentInfHandle != (HINF) INVALID_HANDLE_VALUE) &&
        (m_SetupInitComponent.ComponentInfHandle != (HINF) NULL) )
   {
      // The INF file handle is valid.

      BOOL  fOriginalSelectionState;
      BOOL  fCurrentSelectionState;

      // Is the subcomponent currently selected ?

      fCurrentSelectionState =
      m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                               (LPCTSTR) ptszSubComponentId,
                                                               (UINT) OCSELSTATETYPE_CURRENT );

      if ( fCurrentSelectionState == (BOOL) TRUE )
      {
         ClRtlLogPrint( "In OnOcCompleteInstallation the current selection state is TRUE.\n" );

         // The subcomponent is currently selected. Is this a fresh install ?

         if ( ( (m_SetupInitComponent.SetupData.OperationFlags &
                 (DWORDLONG) SETUPOP_STANDALONE) == (DWORDLONG) 0L ) &&
              ( (m_SetupInitComponent.SetupData.OperationFlags &
                 (DWORDLONG) SETUPOP_NTUPGRADE) == (DWORDLONG) 0L ) )
         {
            ClRtlLogPrint( "In OnOcCompleteInstallation this is a GUI mode clean install.\n" );

            // SETUPOP_STANDALONE flag clear means running under GUI mode setup.
            // SETUPOP_NTUPGRADE flag clear means not performing an upgrade.
            // Both flags clear means a fresh install. Do not check for a selection
            // state transition.

            dwReturnValue = CompleteInstallingClusteringService( (LPCTSTR) ptszSubComponentId );

            ClRtlLogPrint( "CompleteInstallingClusteringService returned 0x%1!x! to OnOcCompleteInstallation.\n",
                           dwReturnValue );
         }
         else
         {
            // This is not a GUI mode fresh install. Is it an UPGRADE ?

            if ( (m_SetupInitComponent.SetupData.OperationFlags &
                  (DWORDLONG) SETUPOP_NTUPGRADE) != (DWORDLONG) 0L )
            {
               ClRtlLogPrint( "In OnOcCompleteInstallation - This is an UPGRADE.\n" );

               // Complete the process of upgrading Cluster service.

               dwReturnValue = CompleteUpgradingClusteringService( (LPCTSTR) ptszSubComponentId );

               ClRtlLogPrint( "CompleteUpgradingClusteringService returned 0x%1!x! to OnOnCompleteInstallation.\n",
                              dwReturnValue );
            }
            else
            {
               ClRtlLogPrint( "In OnOcCompleteinstallation - this is STANDALONE.\n" );

               if ( (m_SetupInitComponent.SetupData.OperationFlags &
                     (DWORDLONG) SETUPOP_BATCH) != (DWORDLONG) 0L )
               {
                  ClRtlLogPrint( "In OnOcCompleteInstallation this is UNATTENDED STANDALONE and Cluster service is selected.\n" );
               }

               // This is not an upgrade. That means Add/Remove Programs must be
               // running.

               // Check for a selection state transition.

               fOriginalSelectionState =
               m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                        ptszSubComponentId,
                                                                        (UINT) OCSELSTATETYPE_ORIGINAL );

               if ( fCurrentSelectionState != fOriginalSelectionState )
               {
                   ClRtlLogPrint( "In OnOcCompleteInstallation a selection state transition has been detected.\n" );

                   dwReturnValue = CompleteStandAloneInstallationOfClusteringService( (LPCTSTR) ptszSubComponentId );

                   ClRtlLogPrint( "CompleteStandAloneInstallationOfClusteringService returned 0x%1!x! to OnOcCompleteInstallation.\n",
                                  dwReturnValue );
               }
               else
               {
                  ClRtlLogPrint( "In OnOcCompleteInstallation since no selection state transition was detected there is nothing to do.\n" );

                  // The selection state has not been changed. Perform no action.
                  dwReturnValue = (DWORD) NO_ERROR;
               } // was there a selection state transition?
            }  // is this an UPGRADE?
         }  // is this a fresh install ?
      }
      else
      {
         ClRtlLogPrint( "In OnOcCompleteInstallation the current selection state is FALSE.\n" );

         // The subcomponent is not selected. Is OC Manager running stand-alone ?
         // If not, i.e. if GUI mode setup is running, there is nothing to do.

         if ( (m_SetupInitComponent.SetupData.OperationFlags &
               (DWORDLONG) SETUPOP_STANDALONE) != (DWORDLONG) 0L )
         {
            ClRtlLogPrint( "In OnOcCompleteInstallation this is STANDALONE.\n" );

            // SETUPOP_STANDALONE set implies GUI mode setup is not running. If
            // there was a selection state change (to unselected) then delete
            // registry entries.

            fOriginalSelectionState =
            m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                     ptszSubComponentId,
                                                                     (UINT) OCSELSTATETYPE_ORIGINAL );

            // Has there been a selection state transition ?

            if ( fCurrentSelectionState != fOriginalSelectionState )
            {
               ClRtlLogPrint( "In OnOcCompleteInstallation a selection state transition has been detected.\n" );

               // Complete the process of uninstalling Cluster service.

               dwReturnValue = CompleteUninstallingClusteringService( (LPCTSTR) ptszSubComponentId );

               ClRtlLogPrint( "CompleteUninstallingClusteringService returned 0x%1!x! to OnOcCompleteInstallation.\n",
                              dwReturnValue );
            }
            else
            {
               // The selection state has not been changed. Perform no action.

               dwReturnValue = (DWORD) NO_ERROR;

               ClRtlLogPrint( "In OnOcCompleteInstallation a selection state transition was not detected\n" );
               ClRtlLogPrint( "so there is nothing to do.\n" );
            }     // Was there a selection state transition ?
         }
         else
         {
            // GUI mode setup is running. Perform no action.

            dwReturnValue = (DWORD) NO_ERROR;

            ClRtlLogPrint( "In OnOcCompleteInstallation GUI mode setup is running and the\n" );
            ClRtlLogPrint( "component is not selected so there is nothing to do.\n" );
         }     // Is GUI mode setup running ?
      }     // Is the subcomponent currently selected ?
   }
   else
   {
      dwReturnValue = ERROR_FILE_NOT_FOUND;

      ClRtlLogPrint( "In OnOcCompleteInstallation the handle to the component INF file is bad.\n" );
   }     // Is the handle to the component INF file valid ?

   ClRtlLogPrint( "OnOcCompleteInstallation is preparing to return 0x%1!x!.\n", dwReturnValue );

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcQueryChangeSelState
//
// Routine Description:
//    This function processes the OC_QUERY_CHANGE_SEL_STATE "messages" from the
//    Optional Components Manager.
//
// Arguments:
//    pvComponentId - points to a string that uniquely identifies the component
//                    to be set up to OC Manager.
//    pvSubComponentId - points to a string that uniquely identifies a sub-
//                       component in the component's hiearchy.
//    uxFunction - OC_QUERY_CHANGE_SEL_STATE - See ocmanage.h for the macro definitions.
//    uxParam1 - proposed state of the subcomponent
//               zero means unselected
//               non-zero means selected
//    pvParam2 - Flags
//
// Return Value:
//    (DWORD) TRUE - the proposed selection state should be accepted
//    (DWORD) FALSE - the proposed selection state should be rejected
//
// Note:
//    As currently implemented on 2/25/1998, this function will disallow all
//    changes to the selection state of Cluster service during an upgrade to a
//    machine on which Cluster service has previously been installed.
//
//    I have assumed that if the SETUPOP_NTUPGRADE flag is set that GUI mode
//    setup is running because there is no way to perform and upgrade other
//    than running NT setup.
//
//    Cluster service and Terminal Services are mutually exclusive. By the
//    time that this function gets called, OnOcInitComponent has already determined
//    that Terminal Services is not installed. Therefore it is only necessary to
//    determine whether Terminal Services is selected for installation.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcQueryChangeSelState( IN LPCTSTR ptszSubComponentId,
                                            IN UINT uxProposedSelectionState,
                                            IN DWORD dwFlags )
{
   DWORD dwReturnValue = (DWORD) TRUE;

   eClusterInstallState eState;

   // Is an upgrade in progress ?

   if ( (m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_NTUPGRADE) !=
        (DWORDLONG) 0L )
   {
      ClRtlLogPrint( "In OnOnQueryChangeSelState this is an UPGRADE. Selection state transitions are not allowed.\n" );

      // Since this is an UPGRADE the selection state cannot be changed.
      // Return FALSE to disallow selection state changes.

      dwReturnValue = (DWORD) FALSE;
   }
   else
   {
      if ( dwReturnValue == (DWORD) TRUE )
      {
         // Either Cluster service is being deselected, which implies that the
         // selection state of Terminal Services is inconsequential, or Terminal
         // Services is not selected for installation.

         // Is GUI mode setup running?

         if ( (m_SetupInitComponent.SetupData.OperationFlags &
              (DWORDLONG) SETUPOP_STANDALONE) == (DWORDLONG) 0L )
         {
            ClRtlLogPrint( "In OnOcQueryChangeSelState this is NOT STANDALONE.\n" );

            // SETUPOP_STANDALONE clear means GUI mode setup is running.
            // In conjunction with SETUPOP_NTUPGRADE clear it means that
            // a fresh NT installation is in progress.

            // It is possible for the user to request that a fresh install target
            // the directory for an existing NT installation. In that event, as per
            // David P., if Cluster Server has been installed, the user should
            // not be allowed to deselect the Cluster Server component.

            // GetClusterInstallationState reports on the state of the registry value
            // that records the state of the Cluster service installation on NT 5 machines.
            // IsClusterServiceRegistered indicates whether the Cluster service is registered on
            // BOTH NT 4 and NT 5 machines. Both tests are required: IsClusterServiceRegistered for
            // upgrading NT 4 machines, GetClusterInstallationState for NT 5 machines.

            ClRtlGetClusterInstallState( NULL, &eState );
            if ( ( eState != eClusterInstallStateUnknown ) ||
                 ( IsClusterServiceRegistered() == (BOOL) TRUE ) )
            {
               // Disallow deselection of the cluster component(s).

               dwReturnValue = (DWORD) FALSE;

               ClRtlLogPrint( "In OnOcQueryChangeSelState since Clustering Server has previously\n" );
               ClRtlLogPrint( "been installed selection state transitions are not allowed.\n" );
            }
            else
            {
               // Allow the selection state to be changed.

               dwReturnValue = (DWORD) TRUE;

               ClRtlLogPrint( "In OnOcQueryChangeSelState since Clustering Server has never\n" );
               ClRtlLogPrint( "been installed selection state transitions are allowed.\n" );
            }
         } // GUI mode setup running?
         else
         {
            // This is a standalone operation. Allow the selection state to be changed.

            dwReturnValue = (DWORD) TRUE;

            ClRtlLogPrint( "In OnOcQueryChangeSelState this is STANDALONE so selection state transitions are allowed.\n" );
         } // GUI mode setup running?
      }
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// PerformRegistryOperations
//
// Routine Description:
//    This function performs the registry operations, both the AddReg and DelReg
//    in the section indicated by ptszSectionName are processed.
//    registry entries.
//
// Arguments:
//    hInfHandle - a handle to the component INF file.
//    ptszSectionName - points to a string containing the name of a section in
//                      the INF file.
//
// Return Value:
//    (DWORD) NO_ERROR - indicated success
//    Any other retuen value is a Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::PerformRegistryOperations( HINF hInfHandle,
                                              LPCTSTR ptszSectionName )
{
   DWORD dwReturnValue;

   // Install ... perform the registry operations.

   dwReturnValue = SetupInstallFromInfSection( NULL,                 // hwndOwner
                                               m_SetupInitComponent.ComponentInfHandle,     // inf handle
                                               ptszSectionName,      // name of section
                                               SPINST_REGISTRY,      // operation flags
                                               NULL,                 // relative key root
                                               NULL,                 // source root path -
                                                                     // irrelevant for registry operations
                                               0,                    // copy flags
                                               NULL,                 // callback routine
                                               NULL,                 // callback routine context
                                               NULL,                 // device info set
                                               NULL );               // device info struct

   // Were the registry operations performed successfully?

   if ( dwReturnValue == (DWORD) TRUE )
   {
      dwReturnValue = (DWORD) NO_ERROR;
   }
   else
   {
      dwReturnValue = GetLastError();
   }  // Were the registry operations performed successfully?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// UninstallRegistryOperations
//
// Routine Description:
//    This function queues the registry operations that delete cluster related
//    registry entries on UNINSTALL.
//
// Arguments:
//    hInfHandle - a handle to the component INF file.
//    ptszSubComponentId - points to a string containing the name of the subcomponent.
//
//
// Return Value:
//    (DWORD) NO_ERROR - indicated success
//    Any other retuen value is a Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::UninstallRegistryOperations( IN HINF hInfHandle,
                                                IN LPCTSTR ptszSubComponentId )
{
   DWORD dwReturnValue;

   BOOL        fReturnValue;

   INFCONTEXT  InfContext;

   // There is an entry called "Uninstall" in the [Cluster] section of
   // cluster.inf. That entry provides the name of an "install" section
   // that should be substituted for the [Cluster] section when uninstalling.
   // The following function locates that line so it can be read.

   CString  csSectionName;

   csSectionName = UNINSTALL_INF_KEY;

   fReturnValue = SetupFindFirstLine( m_SetupInitComponent.ComponentInfHandle,
                                      ptszSubComponentId,
                                      csSectionName,
                                      &InfContext );

   if ( fReturnValue == (BOOL) TRUE )
   {
      // Read the name of the replacement section.

      TCHAR  tszReplacementSection[256];     // Receives the section name

      fReturnValue = SetupGetStringField( &InfContext,
                                          1,       // there should be a single field
                                          tszReplacementSection,
                                          sizeof( tszReplacementSection ) / sizeof( TCHAR ),
                                          NULL );

      if ( fReturnValue == (BOOL) TRUE )
      {
         // Remove the registry keys.

         dwReturnValue = PerformRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                                    tszReplacementSection );

         ClRtlLogPrint( "PerformRegistryOperations returned 0x%1!x! to UninstallRegistryOperations.\n",
                        dwReturnValue );
      }
      else
      {
         ClRtlLogPrint( "UninstallDelRegistryOperations could not read the INF file.\n" );

         dwReturnValue = (DWORD) ERROR_FILE_NOT_FOUND;
      }
   }
   else
   {
      ClRtlLogPrint( "UninstallDelRegistryOperations could not read the INF file.\n" );

      dwReturnValue = (DWORD) ERROR_FILE_NOT_FOUND;
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// QueueInstallFileOperations
//
// Routine Description:
//    This function queues the file operations that install cluster related files.
//
// Arguments:
//    hInfHandle - a handle to the component INF file.
//    ptszSubComponentId - points to a string containing the name of the subcomponent.
//
//
// Return Value:
//    (DWORD) NO_ERROR - indicated success
//    Any other retuen value is a Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::QueueInstallFileOperations( IN HINF hInfHandle,
                                               IN LPCTSTR ptszSubComponentId,
                                               IN OUT HSPFILEQ hSetupFileQueue )
{
   DWORD dwReturnValue;
   CString  csSectionName;


   // Dummy do-while loop to avoid gotos.
   do
   {
       // As per Pat Styles on 7/16/98 pass NULL in the SourcePath parameter.
       dwReturnValue = SetupInstallFilesFromInfSection(
                          hInfHandle,               // handle to the INF file
                          NULL,                     // optional, layout INF handle
                          hSetupFileQueue,          // handle to the file queue
                          ptszSubComponentId,       // name of the Install section
                          NULL,                     // optional, root path to source files
                          SP_COPY_NEWER             // optional, specifies copy behavior
                          );

       ClRtlLogPrint( "The first call to SetupInstallFilesFromInfSection returned 0x%1!x! to QueueInstallFileOperations.\n",
                      dwReturnValue );

       // Was the operation successful ?
       if ( dwReturnValue == (DWORD) FALSE )
       {
           dwReturnValue = GetLastError();
           break;
       }

       if ( (m_SetupInitComponent.SetupData.OperationFlags &
          (DWORDLONG) SETUPOP_NTUPGRADE) == (DWORDLONG) 0L )
       {
           dwReturnValue = (DWORD) NO_ERROR;
           // This is not an UPGRADE.
           break;
       }

       // If this is an UPGRADE (from NT 4.0) then queue the file operations
       // specified in the [Upgrade] section.

       ClRtlLogPrint( "In QueueInstallFileOperations this is an UPGRADE.\n" );


       // Copy the replace-only files. Some files like IISCLUS3.DLL need to be copied
       // on an upgrade only if they already existed before the upgrade.
       // This is what I learnt from Brent (a-brentt) on 7/15/1999.
       csSectionName = UPGRADE_REPLACEONLY_INF_KEY;

       // As per Pat Styles on 7/16/98 pass NULL in the SourcePath parameter.
       dwReturnValue = SetupInstallFilesFromInfSection(
                          hInfHandle,               // handle to the INF file
                          NULL,                     // optional, layout INF handle
                          hSetupFileQueue,          // handle to the file queue
                          csSectionName,            // name of the Install section
                          NULL,                     // optional, root path to source files
                          SP_COPY_REPLACEONLY       // optional, specifies copy behavior
                          );

       ClRtlLogPrint( 
            "The first call to SetupInstallFilesFromInfSection returned 0x%1!x! to QueueInstallFileOperations.\n",
             dwReturnValue 
             );

       if ( dwReturnValue == (DWORD) FALSE )
       {
           dwReturnValue = GetLastError();
           break;
       }

       // The replace only copy was successful. Now do the normal CopyFiles and DelFiles
       // subsections.
       csSectionName = UPGRADE_INF_KEY;


       // This function processes the CopyFiles subsection under the UPGRADE_INF_KEY section.
       dwReturnValue = SetupInstallFilesFromInfSection(
                          hInfHandle,               // handle to the INF file
                          NULL,                     // optional, layout INF handle
                          hSetupFileQueue,          // handle to the file queue
                          csSectionName,            // name of the Install section
                          NULL,                     // optional, root path to source files
                          SP_COPY_NEWER             // optional, specifies copy behavior
                          );

       ClRtlLogPrint( 
            "The second call to SetupInstallFilesFromInfSection returned 0x%1!x! to QueueInstallFileOperations.\n",
             dwReturnValue 
             );

       if ( dwReturnValue == (DWORD) FALSE )
       {
           dwReturnValue = GetLastError();
           break;
       }

       // This function processes the DelFiles subsection under the UPGRADE_INF_KEY section.
       dwReturnValue = SetupQueueDeleteSection(
                            hSetupFileQueue,        // handle to the file queue
                            hInfHandle,             // handle to the INF file containing the [DestinationDirs] section
                            hInfHandle,             // handle to the INF file
                            csSectionName           // INF section that lists the files to delete
                            );

       ClRtlLogPrint( 
            "The call to SetupQueueDeleteSection returned 0x%1!x! to QueueInstallFileOperations.\n", dwReturnValue 
             );

       if ( dwReturnValue == (DWORD) FALSE )
       {
           dwReturnValue = GetLastError();
           break;
       }

       dwReturnValue = (DWORD) NO_ERROR;
   }
   while ( FALSE ); // dummy do-while loop to avoid gotos.

   if ( dwReturnValue == (DWORD) NO_ERROR )
   {
       ClRtlLogPrint( "QueueInstallFileOperations compeleted successfully.\n" );
   }
   else
   {
       ClRtlLogPrint( "Error in QueueInstallFileOperations.\n" );
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// QueueRemoveFileOperations
//
// Routine Description:
//    This function queues the file operations that delete cluster related files.
//
// Arguments:
//    hInfHandle - a handle to the component INF file.
//    ptszSubComponentId - points to a string containing the name of the subcomponent.
//
//
// Return Value:
//    (DWORD) NO_ERROR - indicated success
//    Any other return value is a Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::QueueRemoveFileOperations( IN HINF hInfHandle,
                                              IN LPCTSTR ptszSubComponentId,
                                              IN OUT HSPFILEQ hSetupFileQueue )
{
   DWORD dwReturnValue;

   BOOL        fReturnValue;

   INFCONTEXT  InfContext;

   // There is an entry called "Uninstall" in the [Cluster] section of
   // cluster.inf. That entry provides the name of an "install" section
   // that should be substituted for the [Cluster] section when uninstalling.
   // The following function locates that line so it can be read.

   CString  csSectionName;

   csSectionName = UNINSTALL_INF_KEY;

   fReturnValue = SetupFindFirstLine( hInfHandle,
                                      ptszSubComponentId,
                                      csSectionName,
                                      &InfContext );

   if ( fReturnValue == (BOOL) TRUE )
   {
      // Read the name of the replacement section.

      TCHAR  tszReplacementSection[256];     // Receives the section name

      fReturnValue = SetupGetStringField( &InfContext,
                                          1,       // there should be a single field
                                          tszReplacementSection,
                                          sizeof( tszReplacementSection ) / sizeof( TCHAR ),
                                          NULL );

      if ( fReturnValue == (BOOL) TRUE )
      {
         // Remove the files.

         dwReturnValue = SetupInstallFilesFromInfSection( hInfHandle,
                                                          (HINF) NULL,              // No layout file
                                                          hSetupFileQueue,
                                                          (LPCTSTR) tszReplacementSection,
                                                          (LPCTSTR) NULL,  // SourceRootPath is irrelevant
                                                          (UINT) 0 );

         ClRtlLogPrint( "SetupInstallFilesFromInfSection returned 0x%1!x! to QueueRemoveFilesOperations.\n",
                        dwReturnValue );

         // Was the operation successfull ?

         if ( dwReturnValue == (DWORD) TRUE )
         {
            dwReturnValue = (DWORD) NO_ERROR;
         }
         else
         {
            dwReturnValue = GetLastError();
         }
      }
      else
      {
         dwReturnValue = (DWORD) ERROR_FILE_NOT_FOUND;

         ClRtlLogPrint( "QueueRemoveFileOperations was unable to read the [Uninstall] section in the INF file.\n" );
      }
   }
   else
   {
      dwReturnValue = (DWORD) ERROR_FILE_NOT_FOUND;

      ClRtlLogPrint( "QueueRemoveFileOperations was unable to locate the [Uninstall] section in the INF file.\n" );
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcAboutToCommitQueue
//
// Routine Description:
//    If clusocm.dll is performing an uninstall, this function unregisters the
//    cluster services.
//
//    if clusocm.dll is performing an install or an upgrade this function does
//    nothing.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcAboutToCommitQueue( IN LPCTSTR ptszSubComponentId )
{
   DWORD dwReturnValue;

   if ( (m_SetupInitComponent.ComponentInfHandle != (HINF) INVALID_HANDLE_VALUE) &&
        (m_SetupInitComponent.ComponentInfHandle != (HINF) NULL) )
   {
      // The INF file handle is valid.

      BOOL  fOriginalSelectionState;
      BOOL  fCurrentSelectionState;

      // Is the subcomponent currently selected ?

      fCurrentSelectionState =
          m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                   (LPCTSTR) ptszSubComponentId,
                                                                   (UINT) OCSELSTATETYPE_CURRENT );

      if ( fCurrentSelectionState != (BOOL) TRUE )
      {
         // The subcomponent is not selected. Is OC Manager running stand-alone ?
         // If not, i.e. if GUI mode setup is running, there is nothing to do.

         if ( (m_SetupInitComponent.SetupData.OperationFlags &
              (DWORDLONG) SETUPOP_STANDALONE) != (DWORDLONG) 0L )
         {
            ClRtlLogPrint( "In OnOcAboutToCommitQueue this is STANDALONE and the component is not selected.\n" );
            ClRtlLogPrint( "So, this is an uninstall operation.\n" );

            // SETUPOP_STANDALONE set implies GUI mode setup is not running. If
            // there was a selection state change (to unselected) then delete
            // registry entries.

            fOriginalSelectionState =
               m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                        ptszSubComponentId,
                                                                        (UINT) OCSELSTATETYPE_ORIGINAL );

            // Has there been a selection state transition ?

            if ( fCurrentSelectionState != fOriginalSelectionState )
            {
               CString  csTemp;

               ClRtlLogPrint( "In OnOcAboutToCommitQueue a selection state transition has been detected.\n" );

               // At this point in cluscfg.exe file utils.cpp function DoUninstall
               // called function IsOtherSoftwareInstalled. That function apparently
               // checked for the presence of custom cluster resources and warned the
               // user to handle them before proceeding. (at least that is what David
               // told me). So, that logic needs to be replicated here.

               // NOTE: According to Andrew Ritz (AndrewR), there is no way to abort the
               // installation at this point. So the user is just shown the list of
               // custom resource types and is prompted to remove them after the cluster 
               // service has been uninstalled. The user is not given an option to abort
               // the installation.
               // (Vvasu 14-DEC-1999)

               if ( ( m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_BATCH ) ==
                    (DWORDLONG) 0L )
               {
                   // If this is not an unattended operation.

                   BOOL fReturnValue = CheckForCustomResourceTypes();

                   ClRtlLogPrint( "CheckForCustomResourceTypes returned 0x%1!x! to OnOcAboutToCommitQueue.\n",
                                  fReturnValue );
               }
               else
               {
                   ClRtlLogPrint( "CheckForCustomResourceTypes not called in OnOcAboutToCommitQueue as this is an unattended operation.\n" );
               }

               // Stop ClusSvc. Note that if ClusDisk is someday revised so that
               // it will unload, it will be appropriate to stop ClusDisk here
               // as well.

               csTemp = CLUSTER_SERVICE_NAME;

               // I'm going to assume that, since UNICODE is defined, the casts
               // in the calls to function StopService are OK, even though there
               // is probably a better approach.

               StopService( (LPCWSTR) (LPCTSTR) csTemp );

               csTemp =  TIME_SERVICE_NAME;

               StopService( (LPCWSTR) (LPCTSTR) csTemp );

               ClRtlLogPrint( "OnOcAboutToCommitQueue has attempted to stop ClusSvc and TimeServ.\n" );

               //
               // Unregister the COM objects that may previously have been registered.
               //
               // Note that since msclus.dll is registered as part of NT setup
               // it is not unregistered here.
               //

               csTemp =  CLUSTER_DIRECTORY;

               TCHAR tszPathToClusterDir[_MAX_PATH];

               if ( ExpandEnvironmentStrings( (LPCTSTR) csTemp,
                                              tszPathToClusterDir, _MAX_PATH ) > 0L )
               {
                  BOOL bUnregisterResult = UnRegisterClusterCOMObjects( m_hInstance, tszPathToClusterDir );

                  ClRtlLogPrint( "OnOcAboutToCommitQueue has unregistered the COM objects. The return value is %1!d!\n", bUnregisterResult );
               }
               else
               {
                  // Couldn't expand the environment string.

                  ClRtlLogPrint( "OnOcAboutToCommitQueue could not unregister the COM objects\n" );
                  ClRtlLogPrint( "because it could not locate the cluster directory.\n" );
               }

               // Unload the Cluster hive so that the Cluster hive file can be removed.

               UnloadClusDB();

               ClRtlLogPrint( "OnOcAbouToCommitQueue has unloaded the Cluster hive.\n" );

               dwReturnValue = (DWORD) NO_ERROR;
            }
            else
            {
               // The selection state has not been changed. Perform no action.

               dwReturnValue = (DWORD) NO_ERROR;

               ClRtlLogPrint("In OnOcAboutToCommitQueue no selection state transition was detected.\n" );
            }     // Was there a selection state transition ?
         }
         else
         {
            // OC Manager is NOT running stand-alone. This CANNOT be an uninstall
            // operation. There is nothing for this function to do.

            dwReturnValue = (DWORD) NO_ERROR;
         }     // Is GUI mode setup running ?
      }     // Is the subcomponent cuttently selected ?
      else
      {
         // Since the component is selected this CANNOT be an uninstall operation.
         // There is nothing for this function to do.

         dwReturnValue = (DWORD) NO_ERROR;

         ClRtlLogPrint( "In OnOcAboutToCommitQueue the component is selected so there is nothing to do.\n" );
      }
   }
   else
   {
      dwReturnValue = ERROR_FILE_NOT_FOUND;

      ClRtlLogPrint( "In OnOcAboutToCommitQueue the handle to the INF file is bad.\n" );
   }     // Is the handle to the component INF file valid ?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// LocateClusterHiveFile
//
// Routine Description:
//    This function attempts to locate the Cluster hive file and supply the
//    path to the calling function.
//
// Arguments:
//    rcsClusterHiveFilePath - a reference to a the CString to receive the
//                             path to the Cluster hive file.
//
// Return Value:
//    TRUE - incicates that the Cluster hive file was located and that
//           rcsClusterHiveFilePath is meaningfull.
//    FALSE - indicates that the Cluster hive file was not located and
//            rcsClusterHiveFilePath is empty.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusocmApp::LocateClusterHiveFile( CString & rcsClusterHiveFilePath )
{
   BOOL  fReturnValue;

   // The path to the Cluster hive file may be deduced by reading the
   // [DestinationDirs] section of the INF file. The ClusterFiles entry
   // will specify the file's location.

   if ( (m_SetupInitComponent.ComponentInfHandle != (HINF) INVALID_HANDLE_VALUE) &&
        (m_SetupInitComponent.ComponentInfHandle != (HINF) NULL) )
   {
      // The handle to the INF file is valid.

      TCHAR tszPathToClusterDirectory[MAX_PATH];

      // First, get the path to the cluster directory.

      DWORD    dwRequiredSize;

      CString  csSectionName;

      csSectionName =  CLUSTER_FILES_INF_KEY;

      fReturnValue = SetupGetTargetPath( m_SetupInitComponent.ComponentInfHandle,
                                         (PINFCONTEXT) NULL,
                                         (PCTSTR) csSectionName,
                                         tszPathToClusterDirectory,
                                         (DWORD) MAX_PATH,
                                         (PDWORD) &dwRequiredSize );

      if ( fReturnValue == (BOOL) TRUE )
      {
         rcsClusterHiveFilePath = (CString) tszPathToClusterDirectory;

         // Append the name of the Cluster hive file to the path.

         CString  csClusterDatabaseName;

         csClusterDatabaseName =  CLUSTER_DATABASE_NAME;

         rcsClusterHiveFilePath += (CString) _T("\\") + csClusterDatabaseName;

         ClRtlLogPrint( "LocateClusterHiveFile has deduced that the cluster hive is in %1!s!.\n",
                        rcsClusterHiveFilePath );

         // The path to the Cluster hive file has been built. Now, make
         // sure that the file is present.

         HANDLE            hSearchHandle;

         WIN32_FIND_DATA   FindData;

         hSearchHandle = FindFirstFile( rcsClusterHiveFilePath,
                                        &FindData);

         if( hSearchHandle != (HANDLE) INVALID_HANDLE_VALUE )
         {
             FindClose( hSearchHandle );

             // A file with the correct name was located. Is it the cluster hive
             // file? If it is a directory it is not.

             if( (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) !=
                  (DWORD) 0L )
             {
                // The file is a directory. That means that the Cluster
                // hive file could not be located.

                ClRtlLogPrint( "LocateClusterHiveFile could not find file %1!s!.\n", 
                               rcsClusterHiveFilePath );

                rcsClusterHiveFilePath.Empty();

                fReturnValue = (BOOL)  FALSE;
             }
             else
             {
                // The Cluster hive file was found.

                ClRtlLogPrint( "LocateClusterHiveFile found the Cluster hive at %1!s!.\n",
                               rcsClusterHiveFilePath );

                fReturnValue = (BOOL) TRUE;
             }
         }
         else
         {
            // The cluster hive file was not located.

            ClRtlLogPrint( "LocateClusterHiveFile could not find file %1!s!.\n", 
                           rcsClusterHiveFilePath );

            rcsClusterHiveFilePath.Empty();

            fReturnValue = (BOOL)  FALSE;
         }
      }
      else
      {
         rcsClusterHiveFilePath.Empty();

         ClRtlLogPrint( "SetupGetTargetPath failed in LocateClusterHiveFile.\n" );
      }
   }
   else
   {
      // The handle to the INF file is not valid. That means that the Cluster
      // hive file could not be located.

      ClRtlLogPrint( "LocateClusterHiveFile could not locate the cluster hive because the\n" );
      ClRtlLogPrint( "handle to the INF file is bad.\n" );

      rcsClusterHiveFilePath.Empty();

      fReturnValue = (BOOL) FALSE;
   }

   return ( fReturnValue );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
// CheckForCustomResourceTypes
//
// Routine Description:
//    This function examines the ResourceTypes subkey of the Cluster key to
//    determine whether custom resource types have been installed.
//
// Arguments:
//    None
//
//
// Return Value:
//    TRUE - indicates that either no custom resource types have been detected
//           or the user chooses to continue uninstalling Cluster Server without
//           first uninstalling the software packages associated with the custom
//           resource types.
//    FALSE - indicates that custom resource types were detected and the user
//            wishes to terminate uninstallation of Cluster Server.
//
// Note:
//    This function was originally called IsOtherSoftwareInstalled in the old
//    cluster\newsetup project in the file called utils.cpp.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusocmApp::CheckForCustomResourceTypes( void )
{
   BOOL  fReturnValue = (BOOL) TRUE;
   BOOL  fEnumerateResourceTypesKeys = (BOOL) TRUE;
   BOOL  fClusterHiveLoadedByThisFunction = (BOOL) FALSE;

   HKEY  hClusterKey;

   LONG lReturnValue;

   // Attempt to open the Cluster Registry key.

   CString  csClusterRegKey;

   csClusterRegKey = CLUSREG_KEYNAME_CLUSTER;

   lReturnValue = RegOpenKeyEx( HKEY_LOCAL_MACHINE, csClusterRegKey,
                                0, KEY_READ, &hClusterKey);

   if ( lReturnValue != ERROR_SUCCESS )
   {
      ClRtlLogPrint( "In CheckForCustomResourceTypes the first attempt to open the Cluster key failed.\n" );

      // The Cluster hive is not currently loaded. This condition means that
      // the cluster service has not been started. Attempt to load the Cluster
      // hive so that it can be read.

      // First, locate the Cluster hive file. It should be in the location
      // specified for the ClusterFiles entry in the [DestinationDirs] section
      // of clusocm.inf.

      CString  csClusterHiveFilePath;

      fReturnValue = LocateClusterHiveFile( (CString &) csClusterHiveFilePath );

      ClRtlLogPrint( "LocateClusterHiveFile returned 0x%1!x! to CheckForCustomResourceTypes.\n",
                     fReturnValue );

      // Was the Cluster hive file located?

      if ( fReturnValue == (BOOL) TRUE )
      {
         // The Cluster hive file was located. Custom resource types may exist.
         // Attempt to load the cluster hive.

         BOOLEAN  OriginalState;

         // I'm not sure what the following function does, but the prototype is
         // in sdk\inc\ntrtl.h. Look in stdafx.h for the inclusion of ntrtl.h. I
         // replicated the logic that was used in newsetup.h to make it work.

         // RtlAdjustPrivilege returns NTSTATUS.

         NTSTATUS Status;

         Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                      TRUE,
                                      FALSE,
                                      &OriginalState );

         if ( NT_SUCCESS( Status ) )
         {
            // Attempt to Load the Cluster Hive.

            lReturnValue = RegLoadKey( HKEY_LOCAL_MACHINE,
                                       csClusterRegKey,
                                       csClusterHiveFilePath );

            if ( lReturnValue == ERROR_SUCCESS )
            {
               fClusterHiveLoadedByThisFunction = (BOOL) TRUE;

               // Now that the Cluster hive has been loaded, attempt to open the
               // Cluster registry key.

               lReturnValue = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            csClusterRegKey,
                                            0, KEY_READ,
                                            &hClusterKey );

               // lReturnValue will be tested by the next BLOCK of code.
            } // cluster hive loaded?
            else
            {
               // The Cluster hive could not be loaded. Treat that as if there
               // are no custom resource types.

               // A return value of TRUE will allow the uninstall operation to
               // continue. Since lReturnValue is NOT ERROR_SUCCESS no additional
               // processing will be performed by this function.

               fReturnValue = (BOOL) TRUE;
            }  // Was the cluster hive loaded successfully?

            // Undo whatever the preceding call to RtlAdjustPrivilege() did.

            RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                OriginalState,
                                FALSE,
                                &OriginalState );
         } // Initial call to RtlAdjustPrivilege succeeded?
         else
         {
            // The initial call to RtlAdjustPrivilege FAILED.

            ClRtlLogPrint( "In CheckForCustomResources the initial call to RtlAdjustPrivileges failed with status %1!d!.\n",
                           Status );

            // A return value of TRUE will allow the uninstall operation to
            // continue. Since lReturnValue is NOT ERROR_SUCCESS no additional
            // processing will be performed by this function.

            fReturnValue = (BOOL) TRUE;
         }  // Did RtlAdjustPrivilege succeed?
      } // cluster hive file located?
      else
      {
         // The Cluster hive file was not located. That implies that there can be
         // no custom resources. Since lReturnValue is NOT ERROR_SUCCESS no
         // additional processing will be done by this function. A return value
         // of TRUE will allow the uninstall operation to continue.

         ClRtlLogPrint( "Since the Cluster hive file could not be located CheckForCustomResources will\n" );
         ClRtlLogPrint( "report that the uninstall operation may continue.\n" );

         fReturnValue = (BOOL) TRUE;
      }  // Was the cluster hive file located?
   }  // Was the Cluster registry key opened successfully?

   // The preceeding code segment may have loaded the cluster hive and
   // attempted to open the cluster key. Was it sucessful?

   if ( lReturnValue == ERROR_SUCCESS )
   {
      // At this point, the Cluster registry key was opened successfully. Now, attempt
      // to open the Resource Type subkey.

      HKEY  hResourceTypesKey;

      CString  csResourceTypesRegKey;

      csResourceTypesRegKey = CLUSREG_KEYNAME_RESOURCE_TYPES;

      lReturnValue = RegOpenKeyEx( hClusterKey,
                                   csResourceTypesRegKey,
                                   0, KEY_READ, &hResourceTypesKey );

      if ( lReturnValue == ERROR_SUCCESS )
      {
         // The ResourceTypes sub key is open.
         // Enumerate the subkeys of the REG_RESTYPES.

         FILETIME t_LastWriteTime;
         WCHAR wszSubKeyName[256];
         DWORD dwCharCount;
         DWORD dwIndex = 0;   // index of the first sub-key to enumerate

         dwCharCount = sizeof( wszSubKeyName ) / sizeof( wszSubKeyName[0] );
         lReturnValue = RegEnumKeyEx( hResourceTypesKey,
                                      dwIndex,
                                      wszSubKeyName,
                                      &dwCharCount,
                                      NULL,
                                      NULL,// Class of the Key. Not Reqd.
                                      NULL,// Size of the above param.
                                      &t_LastWriteTime );

         // RegEnumKeyEx returns ERROR_NO_MORE_ITEMS when there are
         // no additional sub-keys to enumerate.

         if ( lReturnValue == ERROR_SUCCESS )
         {
            // The initial call to RegEnumKeyEx succeeded. Determine whether
            // the sub-key is associated with a non-standard resource type.

            // Function TryToRecognizeResourceType builds a list of non-standard resource types
            // in the CString variable csNonStandardResourceTypeList.

            CString  csNonStandardResourceTypeList;

            TryToRecognizeResourceType( csNonStandardResourceTypeList, wszSubKeyName );

            // The following loop checks the remaining sub-keys in the
            // Resource Types registry key.

            while ( lReturnValue == ERROR_SUCCESS )
            {
               dwIndex++;

               dwCharCount = sizeof( wszSubKeyName ) / sizeof( wszSubKeyName[0] );
               lReturnValue = RegEnumKeyEx( hResourceTypesKey,
                                            dwIndex,
                                            wszSubKeyName,
                                            &dwCharCount,
                                            NULL,
                                            NULL,// Class of the Key. Not Reqd.
                                            NULL,// Size of the above param.
                                            &t_LastWriteTime );

               TryToRecognizeResourceType( csNonStandardResourceTypeList, wszSubKeyName );
            }

            // Were all subkeys of the ResourceTypes registry key "verified"?

            if( lReturnValue == ERROR_NO_MORE_ITEMS )
            {
               CString csMessage;

               fReturnValue = (BOOL) TRUE;

               RegCloseKey( hResourceTypesKey );
               RegCloseKey( hClusterKey );

               // Were there any non-standard subkeys in the Resource Types registry key?

               if ( csNonStandardResourceTypeList.IsEmpty() == (BOOL) FALSE )
               {
                  // Non-standard subkeys were found. Ask the user about removal.

                  // Build and present a message of the form:
                  //
                  // The following software packages should be removed before removing
                  // the Microsoft Cluster Server software.
                  //
                  // <list of packages>
                  //
                  // Do you want to continue with uninstall?

                  CString csLastPartOfMessage;
                  CString csMessageBoxTitle;

                  csLastPartOfMessage.LoadString(IDS_ERR_UNINSTALL_OTHER_SW_EXT);
                  csNonStandardResourceTypeList += csLastPartOfMessage;

                   // BUGBUG - The next two statements are commented out temporarily because the localization
                   // changes needed for this have not been approved. Uncomment after NT 5.0.
                   // Also restore clusocm.rc@v2 and resource.h@v2
                   // (Vvasu 05-Jan-2000
                  
                  //  csMessageBoxTitle.LoadString(IDS_TITLE_CUSTOM_RESTYPES);
                  //::MessageBox( NULL,
                  //              csNonStandardResourceTypeList,
                  //              csMessageBoxTitle,
                  //              MB_OK | MB_ICONINFORMATION 
                  //            );

                  ClRtlLogPrint( "CheckForClusterResourceTypes detected custom resources.\n" );
               }  // Were non-standard resource typed detected?
               else
               {
                  ClRtlLogPrint( "CheckForCustomResourceTypes did not detect any custom resource types,\n" );
               }
            } // Was there an error enumerating the ResourceTypes key?
            else
            {
               ClRtlLogPrint( "CheckForCustomResourceTypes was unable to enumerate the resource types,\n" );
               ClRtlLogPrint( "implying that no custom resource types exist, so the uninstall will continue.\n" );
               ClRtlLogPrint( "The error code is %1!d!.\n", lReturnValue );

               // An error occured while enumerating the ResourceTypes sub-keys.

               RegCloseKey( hResourceTypesKey );
               RegCloseKey( hClusterKey );

               // The uninstall operation should continue because the installation
               // is apparently defective.

               fReturnValue = (BOOL) TRUE;
            } // Was there an error enumerating the ResourceTypes key?
         }
         else
         {
            // The initial call to RegEnumKeyEx failed.
            // Issue an error message and exit.

            RegCloseKey( hClusterKey );

            ClRtlLogPrint( "CheckForCustomResourceTypes was unable to enumerate the resource types,\n" );
            ClRtlLogPrint( "implying that no custom resource types exist, so the uninstall will continue.\n" );
            ClRtlLogPrint( "The error code is %1!d!.\n", lReturnValue );

            // A return value of TRUE will allow the uninstall operation to
            // continue.

            fReturnValue = (BOOL) TRUE;

         }  // Did RegEnumKeyEx open the ResourceTypes key?
      }  // Was the ResourceTypes sub key opened?
      else
      {
         // The ResourceTypes sub key could not be opened.
         // Issue an error message and exit.

         RegCloseKey( hClusterKey );

         ClRtlLogPrint( "CheckForCustomResourceTypes was unable to open the Cluster\\ResourceTypes key,\n" );
         ClRtlLogPrint( "implying that no custom resource types exist, so the uninstall will continue.\n" );

         // A return value of TRUE will allow the uninstall operation to
         // continue.

         fReturnValue = (BOOL) TRUE;
      }  // Was the ResourceTypes sub key opened?
   } // cluster hive opened?
   else
   {
      // The Cluster registry key could not be opened, even after possibly
      // attempting to load the cluster hive.

      ClRtlLogPrint( "CheckForCustomResourceTypes was unable to open the Cluster key,\n" );
      ClRtlLogPrint( "implying that no custom resource types exist, so the uninstall will continue.\n" );
      ClRtlLogPrint( "The error code is %1!d!.\n", lReturnValue );

      // A return value of TRUE will allow the uninstall operation to
      // continue.

      fReturnValue = (BOOL) TRUE;
   }  // Second test whether the Cluster registry key was opened successfully.

   if ( fClusterHiveLoadedByThisFunction == (BOOL) TRUE )
   {
      UnloadClusDB();
   }

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// UnloadClusDB
//
// Routine Description:
//    This function unloads the Cluster hive.
//
// Arguments:
//    None
//
// Return Value:
//    None
//
// Note:
//    This function was originally in newsetup\utils.cpp.
//
//--
/////////////////////////////////////////////////////////////////////////////

VOID CClusocmApp::UnloadClusDB( VOID )
{
   DWORD Status;
   BOOLEAN  WasEnabled;

   Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                               TRUE,
                               FALSE,
                               &WasEnabled);

   if ( Status == ERROR_SUCCESS )
   {
      LONG  lReturnValue;

      CString  csClusterRegKey;

      csClusterRegKey = CLUSREG_KEYNAME_CLUSTER;

      lReturnValue = RegUnLoadKeyW(HKEY_LOCAL_MACHINE, csClusterRegKey );

      RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                         WasEnabled,
                         FALSE,
                         &WasEnabled);
   }
}


PWCHAR WellKnownResourceTypes[] = {
    CLUS_RESTYPE_NAME_GENAPP,
    CLUS_RESTYPE_NAME_GENSVC,
    CLUS_RESTYPE_NAME_FTSET,
    CLUS_RESTYPE_NAME_PHYS_DISK,
    CLUS_RESTYPE_NAME_IPADDR,
    CLUS_RESTYPE_NAME_NETNAME,
    CLUS_RESTYPE_NAME_FILESHR,
    CLUS_RESTYPE_NAME_PRTSPLR,
    CLUS_RESTYPE_NAME_TIMESVC,
    CLUS_RESTYPE_NAME_LKQUORUM,
    CLUS_RESTYPE_NAME_DHCP,
    CLUS_RESTYPE_NAME_MSMQ,
    CLUS_RESTYPE_NAME_NEW_MSMQ,
    CLUS_RESTYPE_NAME_MSDTC,
    CLUS_RESTYPE_NAME_WINS,
    CLUS_RESTYPE_NAME_IIS4,
    CLUS_RESTYPE_NAME_SMTP,
    CLUS_RESTYPE_NAME_NNTP,
    (PWCHAR) UNICODE_NULL
};



/////////////////////////////////////////////////////////////////////////////
//++
//
// TryToRecognizeResourceType
//
// Routine Description:
//    This function determines whether the resource type whose name is in
//    parameter "keyname" is recognized as a standard resource type as defined
//    in clusudef.h.
//
//    This function builds a list of unrecognized reaource types in the CString
//    referenced by parameter "str".
//
// Arguments:
//    str - a reference to a CString in which to build a list of unrecognized
//          resource types.
//    keyname - points to a string that contains the resource type name.
//
// Return Value:
//    None
//
// Note:
//    This function was excerpted verbatim from newsetup\utils.cpp.
//
//--
/////////////////////////////////////////////////////////////////////////////

VOID CClusocmApp::TryToRecognizeResourceType( CString& str, LPTSTR keyname )
{
   PWCHAR * ppName = WellKnownResourceTypes;

   while ( *ppName != (PWCHAR)UNICODE_NULL )
   {
      if ( lstrcmp( keyname, *ppName) == 0 )
         return;
      ++ppName;
   }

   if ( !str.IsEmpty() )
      str += L", ";
   else
   {
      str.LoadString(IDS_ERR_UNINSTALL_OTHER_SW);

      str += _T('\n');
   }
   str += keyname;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetServiceBinaryPath
//
// Routine Description:
//    This function retrieves the fully qualified path to a Service
//    from the Service Control Manager.
//
// Arguments:
//    lpwszServiceName - points to a wide character string containing the service name
//    lptszBinaryPathName - points to a string to receive the fully qualified
//                          path to the Cluster Service.
//
// Return Value:
//    TRUE - The path to the Cluster Service was obtained successfully.
//    FALSE - The path to the Cluster Service was not obtained.
//
// Note:
//    Calling this function makes sense IFF the Cluster Service is registered
//    with the Service Control Manager. Call IsClusterServiceRegistered() to
//    ascertain that BEFORE calling GetServiceBinaryPath.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusocmApp::GetServiceBinaryPath( IN LPWSTR lpwszServiceName,
                                        OUT LPTSTR lptszBinaryPathName )
{
   BOOL  fReturnValue;

   DWORD dwErrorCode = (DWORD) ERROR_SUCCESS;

   if ( lpwszServiceName != (LPWSTR) NULL )
   {
      SC_HANDLE hscServiceMgr;
      SC_HANDLE hscService;

      // Connect to the Service Control Manager and open the specified service
      // control manager database.

      hscServiceMgr = OpenSCManager( NULL, NULL, GENERIC_READ | GENERIC_WRITE );

      // Was the service control manager database opened successfully?

      if ( hscServiceMgr != NULL )
      {
         // The service control manager database is open.
         // Open a handle to the Service.

         hscService = OpenService( hscServiceMgr,
                                   lpwszServiceName,
                                   GENERIC_READ );

         // Was the handle to the service opened?

         if ( hscService != NULL )
         {
            // A valid handle to the Service was obtained.

            DWORD dwBufferSize;

            // Note that the size of the buffer required to get the service configuration
            // information was determined empherically to be 240 bytes.

            LPQUERY_SERVICE_CONFIG lpServiceConfig;

            dwBufferSize = (DWORD) sizeof( QUERY_SERVICE_CONFIG ) + 256;   // The delta from the
                                                                           // size of the structure
                                                                           // was chosen arbitrarily.

            // Attempt to allocate the buffer.

            lpServiceConfig = (LPQUERY_SERVICE_CONFIG) LocalAlloc( LMEM_ZEROINIT, dwBufferSize );

            // Was the bufer allocated successfully?

            if ( lpServiceConfig != (LPQUERY_SERVICE_CONFIG) NULL )
            {
               // The following call to QueryServiceConfig should return something
               // usefull. If it fails it is probably because the guess at the size
               // of the buffer is too small.

               fReturnValue = QueryServiceConfig( hscService,
                                                  lpServiceConfig,
                                                  dwBufferSize,
                                                  (LPDWORD) &dwBufferSize );

               // Was the Service configuration info obtained?

               if ( fReturnValue == (BOOL) TRUE )
               {
                  // Update the output parameter.

                  _tcscpy( lptszBinaryPathName, lpServiceConfig->lpBinaryPathName );

                  // lptszBinaryPathName includes the service name. Strip that off.

                  LPTSTR   ptszTemp;

                  ptszTemp = _tcsrchr( (const wchar_t *) lptszBinaryPathName,
                                       (int) _T('\\') );

                  *ptszTemp = _T('\0');

                  ClRtlLogPrint( "In GetServiceBinaryPath the first call to QueryServiceConfig succeeded.\n" );
               }
               else
               {
                  // Was the buffer too small?

                  dwErrorCode = GetLastError();

                  if ( dwErrorCode == (DWORD) ERROR_INSUFFICIENT_BUFFER )
                  {
                     ClRtlLogPrint( "GetServiceBinaryPath is enlarging the buffer for the QUERY_SERVICE_CONFIG structure.\n" );

                     // Increase the size of the buffer.

                     HLOCAL   hLocalBlock;

                     // As per RodGa LocalReAlloc is not always reliable. Here that functionality
                     // is implemented by freeing the buffer for the QUERY_SERVICE_CONFIG struct
                     // and allocating a nre block using LocalFree and LocalAlloc.

                     hLocalBlock = LocalFree( lpServiceConfig );

                     if ( hLocalBlock == (HLOCAL) NULL )
                     {
                        // The previously allocated block has been released. Now,
                        // allocate a block of the proper size.

                        lpServiceConfig = (LPQUERY_SERVICE_CONFIG) LocalAlloc( LMEM_ZEROINIT,
                                                                               (UINT) dwBufferSize );

                        // Was the larger buffer allocated successfully?

                        if ( lpServiceConfig != (LPQUERY_SERVICE_CONFIG) NULL )
                        {
                           // The following call to QueryServiceConfig should return something
                           // usefull. If it fails it is not because the buffer is too small.

                           fReturnValue = QueryServiceConfig( hscService,
                                                              lpServiceConfig,
                                                              dwBufferSize,
                                                              (LPDWORD) &dwBufferSize );

                           // Was the Service configuration info obtained this time.

                           if ( fReturnValue == (BOOL) TRUE )
                           {
                              // Update the output parameter.

                              _tcscpy( lptszBinaryPathName, lpServiceConfig->lpBinaryPathName );

                              // lptszBinaryPathName includes the service name. Strip that off.

                              LPTSTR   ptszTemp;

                              ptszTemp = _tcsrchr( (const wchar_t *) lptszBinaryPathName,
                                                   (int) _T('\\') );

                              *ptszTemp = _T('\0');

                              ClRtlLogPrint( "In GetServiceBinaryPath the second call to QueryServiceConfig succeeded.\n" );
                           }
                           else
                           {
                              // The Service configuration info was not obtained.

                              dwErrorCode = GetLastError();

                              ClRtlLogPrint( "In GetServiceBinaryPath the second call to QueryServiceConfig failed\n" );
                              ClRtlLogPrint( "with error code 0x%1!x!,\n", dwErrorCode );

                              fReturnValue = (BOOL) FALSE;
                           }  // second call to QueryServiceConfig succeeded?
                        }
                        else
                        {
                           // The attempt to enlarge the buffer failed.

                           dwErrorCode = GetLastError();

                           ClRtlLogPrint( "GetServiceBinaryPath was unable to enlarge the buffer for the QUERY_SERVICE_CONFIG structure.\n" );
                           ClRtlLogPrint( "The error code is 0x%1!x!.\n", dwErrorCode );

                           fReturnValue = (BOOL) FALSE;
                        }
                     }
                     else
                     {
                        dwErrorCode = GetLastError();

                        ClRtlLogPrint( "In GetServiceBinaryPath the call to LocalFree failed with error code 0x%1!x!.\n",
                                       dwErrorCode );

                        fReturnValue = (BOOL) FALSE;
                     }
                  }
                  else
                  {
                     // Some other error occured.

                     ClRtlLogPrint( "In GetServiceBinaryPath the first call to QueryServiceConfig failed\n" );
                     ClRtlLogPrint( "with error code 0x%1!x!.\n", dwErrorCode );

                     fReturnValue = (BOOL) FALSE;
                  }  // Was the buffer to small?
               }  // Service config info obtained from first call to QueryServiceConfig?

               // Free the buffer if it was ever allocated successfully.

               if ( lpServiceConfig != (LPQUERY_SERVICE_CONFIG) NULL )
               {
                  LocalFree( lpServiceConfig );
               }
            }
            else
            {
               // Could not allocate the buffer.

               dwErrorCode = GetLastError();

               ClRtlLogPrint( "GetServiceBinaryPath could not allocate a buffer for the QUERY_SERVICE_CONFIG structure.\n" );
               ClRtlLogPrint( "The error code is 0x%1!x!.\n", dwErrorCode );

               fReturnValue = (BOOL) FALSE;
            }  // Was the buffer allocated successfully?

            // Close the handle to the Cluster Service.

            CloseServiceHandle( hscService );
         }
         else
         {
            // The Service could not be opened.

            dwErrorCode = GetLastError();

            ClRtlLogPrint( "GetServiceBinaryPath could not open an handle to %1!ws!.\n",
                           lpwszServiceName );
            ClRtlLogPrint( "The error code is 0x%1!x!.\n", dwErrorCode );

            fReturnValue = (BOOL) FALSE;
         }  // Was the Cluster Service opened?

         // Close the handle to the Service Control Manager.

         CloseServiceHandle( hscServiceMgr );
      }
      else
      {
         // The Service Control Manager could not be opened.

         dwErrorCode = GetLastError();

         ClRtlLogPrint( "GetServiceBinaryPath could not open the Service Control Manager.\n" );
         ClRtlLogPrint( "The error code is 0x%1!x!.\n", dwErrorCode );

         fReturnValue = (BOOL) FALSE;
      }  // Was the Service Control Manager opened?
   }
   else
   {
      // The service name pointer was bogus.

      ClRtlLogPrint( "The service name passed to GetServiceBinaryPath is invalid.\n" );

      fReturnValue = FALSE;
   }  // Is the service name legal?

   if ( fReturnValue == (BOOL) FALSE )
   {
      // Set the binary path invalid.

      *lptszBinaryPathName = _T('\0');
   }
   else
   {
      ClRtlLogPrint( "GetServiceBinaryPath located %1!ws! at %2!s!.\n",
                     lpwszServiceName, lptszBinaryPathName );
   }

   SetLastError( dwErrorCode );     // Set the "last" error code (which may be ERROR_SUCCESS)
                                    // because this function's caller is likely to call GetLastError().
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetDirectoryIds
//
// Routine Description:
//    This function associates the user defined Directory Identifiers in the
//    [DestinationDirs] section of the component INF file with particular
//    directories, either the default location for NT 5 installations,
//    %windir%\cluster, or the location of a previous installation.
//
// Arguments:
//    fClusterServiceRegistered - TRUE indicates that Cluster service has
//                                previously been installed and the files should
//                                be updated in place.
//
//                                FALSE - indicates that the Cluster service
//                                files should be installed into the default
//                                location.
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates error
//
// Note:
//    The [DestinationDirs] section in clusocm.inf contains the following keys:
//
//          ClusterFiles               = 33001
//          ClusterUpgradeFiles        = 33002
//          ClusterAdminFiles          = 33003
//          ClusterUninstallFiles      = 33004
//
//    Those directory IDs were chosen to be larger than DIRID_USER.
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusocmApp::SetDirectoryIds( BOOL fClusterServiceRegistered )
{
   BOOL  fReturnValue;

   TCHAR tszClusterServiceBinaryPath[MAX_PATH];

   // Are Cluster service files already present?

   if ( fClusterServiceRegistered == (BOOL) TRUE )
   {
      // Cluster service files should be upgraded in place.

      // Query the path to the Cluster Service executable from the Service Control Manager.

      CString  csClusterService;

      csClusterService = CLUSTER_SERVICE_NAME;

      fReturnValue = GetServiceBinaryPath( (LPWSTR) (LPCTSTR) csClusterService,
                                            tszClusterServiceBinaryPath );

      if ( fReturnValue == (BOOL) FALSE )
      {
         DWORD dwErrorCode;

         dwErrorCode = GetLastError();

         ClRtlLogPrint( "In SetDirectoryIds the call to GetServiceBinaryPath failed with error code 0x%1!x!.\n",
                        dwErrorCode );
      }
   }
   else
   {
      // Cluster service files should be installed in the default location.

      CString  csClusterDirectory;

      csClusterDirectory =  CLUSTER_DIRECTORY;

      if ( ExpandEnvironmentStrings( (LPCTSTR) csClusterDirectory,
                                     tszClusterServiceBinaryPath, MAX_PATH ) > 0L )
      {
         fReturnValue = (BOOL) TRUE;
      }
      else
      {
         // Could not expand the enviornment string. The default location for the
         // Cluster service could not be determined.

         fReturnValue = (BOOL) FALSE;

         DWORD dwErrorCode;

         dwErrorCode = GetLastError();

         ClRtlLogPrint( "ExpandEnvironmentString returned 0x%1!x! to SetDirectoryIds.\n",
                        dwErrorCode );
      }  // Was the default location for the Cluster service determined?
   }  // Where should Cluster service files be installed?

   // Was the location into which Cluster service files should be copied obtained?

   if ( fReturnValue == (BOOL) TRUE )
   {
      // Associate selected Directory Ids with the path in tszClusterServiceBinaryPath.

      // Set the Directory Id for the ClusterFiles key in [DestinationDirs].

      fReturnValue = SetupSetDirectoryId( m_SetupInitComponent.ComponentInfHandle,
                                          33001,
                                          (PCTSTR) tszClusterServiceBinaryPath );

      // Was the Directory Id for the ClusterFiles key set successfully?

      if ( fReturnValue = (BOOL) TRUE )
      {
         ClRtlLogPrint( "Directory Id 33001 was set to %1!s!.\n", tszClusterServiceBinaryPath );

         // Set the Directory Id for the ClusterUpgradeFiles key in [DestinationDirs].

         fReturnValue = SetupSetDirectoryId( m_SetupInitComponent.ComponentInfHandle,
                                             33002,
                                             (PCTSTR) tszClusterServiceBinaryPath );

      }  // Was the Directory Id for the ClusterFiles key set successfully?

      // Was the Directory Id for the ClusterUpgradeFiles key set successfully?

      if ( fReturnValue = (BOOL) TRUE )
      {
         ClRtlLogPrint( "Directory Id 33002 was set to %1!s!.\n", tszClusterServiceBinaryPath );

         // Set the Directory Id for the ClusterAdminFiles key in [DestinationDirs].

         fReturnValue = SetupSetDirectoryId( m_SetupInitComponent.ComponentInfHandle,
                                             33003,
                                             (PCTSTR) tszClusterServiceBinaryPath );

      }  // Was the Directory Id for the ClusterUpgradeFiles key set successfully?

      // Was the Directory Id for the ClusterAdminFiles key set successfully?

      if ( fReturnValue = (BOOL) TRUE )
      {
         ClRtlLogPrint( "Directory Id 33003 was set to %1!s!.\n", tszClusterServiceBinaryPath );

         // Set the Directory Id for the ClusterUninstallFiles key in [DestinationDirs].

         fReturnValue = SetupSetDirectoryId( m_SetupInitComponent.ComponentInfHandle,
                                             33004,
                                             (PCTSTR) tszClusterServiceBinaryPath );

      }  // Was the Directory Id for the ClusterAdminFiles key set successfully?

      // Was the Directory Id for the ClusterUninstallFiles key set successfully?

      if ( fReturnValue = (BOOL) TRUE )
      {
         ClRtlLogPrint( "Directory Id 33004 was set to %1!s!.\n", tszClusterServiceBinaryPath );

         // Set the Directory Id for the NT4.files.root key in [DestinationDirs].

         fReturnValue = SetupSetDirectoryId( m_SetupInitComponent.ComponentInfHandle,
                                             33005,
                                             (PCTSTR) tszClusterServiceBinaryPath );

      }  // Was the Directory Id for the ClusterUninstallFiles key set successfully?

      // Was the Directory Id for NT4.files.root key set successfully?

      if ( fReturnValue = (BOOL) TRUE )
      {
         ClRtlLogPrint( "Directory Id 33005 was set to %1!s!.\n", tszClusterServiceBinaryPath );

         // Append the "private" directory to the path.

         // Note, I didn't put this string in the stringtable because it is
         // not localizable, and will never change.

         _tcscat( tszClusterServiceBinaryPath, _T("\\private") );

         // Set the Directory Id for the NT4.files.private key in [DestinationDirs].

         fReturnValue = SetupSetDirectoryId( m_SetupInitComponent.ComponentInfHandle,
                                             33006,
                                             (PCTSTR) tszClusterServiceBinaryPath );

      }  // Was the Directory Id for the NT4.files.root key set successfully?

      // Was the Directory Id for NT4.files.private key set successfully?

      if ( fReturnValue = (BOOL) TRUE )
      {
         ClRtlLogPrint( "Directory Id 33006 was set to %1!s!.\n", tszClusterServiceBinaryPath );
      } // Was the Directory Id for NT4.files.private key set successfully?
   }  // Was the path to the Cluster files determined?
   else
   {
      ClRtlLogPrint( "SetDirectoryIds could not locate the cluster directory, so it failed.\n" );
   }

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// UpgradeClusterServiceImagePath
//
// Routine Description:
//    This function "upgrades" the ImagePath value in the Cluster Service registry
//    key to the location queried from the Service Control Manager.
//
// Arguments:
//    None
//
// Return Value:
//    NO_ERROR - indicates success
//    Any other value is a Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::UpgradeClusterServiceImagePath( void )
{
   BOOL  fReturnValue;

   DWORD dwReturnValue;

   // Query the path to the Cluster Service from the Service Control Manager.

   TCHAR tszClusterServiceBinaryPath[MAX_PATH];

   CString  csClusterService;

   csClusterService = CLUSTER_SERVICE_NAME;

   fReturnValue = GetServiceBinaryPath( (LPWSTR) (LPCTSTR) csClusterService,
                                         tszClusterServiceBinaryPath );

   // Was the path to the Cluster Service obtained?

   if ( fReturnValue == (BOOL) TRUE )
   {
      // Set the ImagePath value in the Cluster Service reg key to the location
      // obtained from the Service Control Manager.

      LONG lReturnValue;

      HKEY hClusterServiceKey;

      DWORD dwType;
      DWORD dwSize;

      // Attempt to open the Cluster Service reg key.

      CString  csClusterServiceRegKey;

      csClusterServiceRegKey = CLUSREG_KEYNAME_CLUSSVC;

      lReturnValue = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                   csClusterServiceRegKey,
                                   (DWORD) 0L,           // reserved
                                   (REGSAM) KEY_SET_VALUE,
                                   &hClusterServiceKey );

      // Was the Cluster Service reg key opened?

      if ( lReturnValue == (LONG) ERROR_SUCCESS )
      {
         TCHAR tszClusterServicePath[MAX_PATH];

         _tcscpy( tszClusterServicePath, tszClusterServiceBinaryPath );

         _tcscat( tszClusterServicePath, _T("\\") );

         // Append the name of the Cluster Service.

         CString  csClusterService;

         csClusterService = CLUSTER_SERVICE_NAME;

         csClusterService += (CString) _T(".exe");

         _tcscat( tszClusterServicePath, csClusterService );

         DWORD dwImagePathValueLength;

         dwImagePathValueLength = (DWORD) ((_tcslen( tszClusterServicePath ) + 1) * sizeof( TCHAR ));

         CString  csImagePath;

         csImagePath = CLUSREG_KEYNAME_IMAGE_PATH;

         lReturnValue = RegSetValueEx( hClusterServiceKey,
                                       csImagePath,
                                       (DWORD) 0L,                      // reserved
                                       (DWORD) REG_EXPAND_SZ,
                                       (CONST BYTE *) tszClusterServicePath,
                                       dwImagePathValueLength );

         // Was the ImagePath written successfully?

         if ( lReturnValue == (LONG) ERROR_SUCCESS )
         {
            dwReturnValue = (DWORD) NO_ERROR;

            ClRtlLogPrint( "UpgradeClusterServiceImagePath succeeded.\n" );
         }
         else
         {
            dwReturnValue = GetLastError();

            ClRtlLogPrint( "UpgradeClusterServiceImagePath failed with error code 0x%1!x!.\n",
                           dwReturnValue );
         }  // Was the ImagePath written successfully?

         // Close the Cluster Service registry key.

         RegCloseKey( hClusterServiceKey );        // do we care about the return value?
      }
      else
      {
         dwReturnValue = GetLastError();

         ClRtlLogPrint( "UpgradeClusterServiceImagePath failed with error code 0x%1!x!.\n",
                        dwReturnValue );
      }  // Was the Cluster Service reg key opened?
   }  // Was the path to the Cluster Service obtained?
   else
   {
      // Indicate error.

      dwReturnValue = GetLastError();

      ClRtlLogPrint( "UpgradeClusterServiceImagePath failed with error code 0x%1!x!.\n",
                     dwReturnValue );
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcQueueFileOps
//
// Routine Description:
//    This function processes the OC_QUEUE_FILE_OPS "messages" from the
//    Optional Components Manager.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//    hSetupFileQueue - a HSPFILEQ (typedefed in setupapi.h to PVOID)
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcQueueFileOps( IN LPCTSTR ptszSubComponentId,
                                     IN OUT HSPFILEQ hSetupFileQueue )
{
   DWORD dwReturnValue = NO_ERROR;

   // Is the handle to the component INF file valid?

   if ( (m_SetupInitComponent.ComponentInfHandle != (HINF) INVALID_HANDLE_VALUE) &&
        (m_SetupInitComponent.ComponentInfHandle != (HINF) NULL) )
   {
      // Is this UNATTENDED or ATTENDED?

      if ( (m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_BATCH) !=
           (DWORDLONG) 0L )
      {
         // This is UNATTENDED.

         ClRtlLogPrint( "In OnOcQueueFileOps this is an UNATTENDED operation.\n" );

         dwReturnValue = OnOcQueueFileOpsUnattended( (LPCTSTR) ptszSubComponentId,
                                                     hSetupFileQueue );
      }
      else
      {
         // This is ATTENDED.

         ClRtlLogPrint( "In OnOcQueueFileOps this is an ATTENDED operation.\n" );

         dwReturnValue = OnOcQueueFileOpsAttended( (LPCTSTR) ptszSubComponentId,
                                                   hSetupFileQueue );
      } // Is this UNATTENDED or ATTENDED?
   }
   else
   {
      dwReturnValue = ERROR_FILE_NOT_FOUND;

      ClRtlLogPrint( "In OnOcQueueFileOps the handle to the component INF file is bad.\n" );
   } // Is the handle to the component INF file valid?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcQueueFileOpsUnattended
//
// Routine Description:
//    This function processes the OC_QUEUE_FILE_OPS "messages" from the
//    Optional Components Manager during UNATTENDED operations.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//    hSetupFileQueue - a HSPFILEQ (typedefed in setupapi.h to PVOID)
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
// Note:
//    OC Manager sends OC_QUEUE_FILE_OPS to the component DLL when the Components
//    List wizard page is dismissed.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcQueueFileOpsUnattended( IN LPCTSTR ptszSubComponentId,
                                               IN OUT HSPFILEQ hSetupFileQueue )
{
   DWORD dwReturnValue;

   // Is this an UPGRADE?

   if ( (m_SetupInitComponent.SetupData.OperationFlags &
         (DWORDLONG) SETUPOP_NTUPGRADE) != (DWORDLONG) 0L )
   {
      // This is an unattended UPGRADE.

      dwReturnValue = QueueFileOpsUnattendedUpgrade( (LPCTSTR) ptszSubComponentId,
                                                     hSetupFileQueue );

      ClRtlLogPrint( "QueueFileOpsUnattendedUpgrade returned 0x%1!x!.\n", dwReturnValue );
   }
   else
   {
      HINF  hAnswerFile;      // WARNING: NEVER close this handle because clusocm.dll
                              //          did not open it.

      // Get a handle to the answer file. WARNING: NEVER close this handle because clusocm.dll
      // did not open it.

      hAnswerFile = m_SetupInitComponent.HelperRoutines.GetInfHandle( INFINDEX_UNATTENDED,
                                                                      m_SetupInitComponent.HelperRoutines.OcManagerContext );

      if ( (hAnswerFile != (HINF) NULL) && (hAnswerFile != (HINF) INVALID_HANDLE_VALUE) )
      {
         ClRtlLogPrint( "In OnOcQueueFileOpsUnattended this is a CLEAN install.\n" );

            // Is Cluster service selected? It is probably overkill to check, but
            // it is safer to check than to be sorry later.

         BOOL  fCurrentSelectionState;
         BOOL  fOriginalSelectionState;

         fCurrentSelectionState =
            m_SetupInitComponent.HelperRoutines.QuerySelectionState( 
                m_SetupInitComponent.HelperRoutines.OcManagerContext,
                (LPCTSTR) ptszSubComponentId,
                (UINT) OCSELSTATETYPE_CURRENT 
                );

         fOriginalSelectionState = 
             m_SetupInitComponent.HelperRoutines.QuerySelectionState( 
                 m_SetupInitComponent.HelperRoutines.OcManagerContext,
                 ptszSubComponentId,
                 (UINT) OCSELSTATETYPE_ORIGINAL 
                 );

         if ( fCurrentSelectionState == (BOOL) TRUE )
         {
            // Was there a selection state transition?
            if ( fCurrentSelectionState != fOriginalSelectionState )
            {
               ClRtlLogPrint( "A selection state transition was detected.\n" );

               // A selection state transition has occured. Install files.
               dwReturnValue = QueueInstallFileOperations( m_SetupInitComponent.ComponentInfHandle,
                                                           ptszSubComponentId,
                                                           hSetupFileQueue );

               ClRtlLogPrint( "QueueInstallFileOperations returned 0x%1!x! to OnOcQueueFileOpsAttended,\n",
                              dwReturnValue );
            }
            else
            {
               ClRtlLogPrint( "NO selection state transition was detected.\n" );

               // The selection state has not been changed. Perform no action.

               dwReturnValue = (DWORD) NO_ERROR;
            }  // Was there a selection state transition?
         }
         else
         {
             // Has there been a selection state transition ?
             ClRtlLogPrint( "In OnOcQueueFileOpsUnattended Cluster service is not selected for installation.\n" );

             if ( fCurrentSelectionState != fOriginalSelectionState )
             {
                // Remove files.

                dwReturnValue = QueueRemoveFileOperations( m_SetupInitComponent.ComponentInfHandle,
                                                           ptszSubComponentId,
                                                           hSetupFileQueue );

                ClRtlLogPrint( "QueueRemoveFileOperations returned 0x%1!x! to OnOcQueueFileOpsUnattended.\n",
                               dwReturnValue );
             }
             else
             {
                ClRtlLogPrint( "In OnOcQueueFileOpsUnattended NO selection state transition was detected.\n" );

                // The selection state has not been changed. Perform no action.

                dwReturnValue = (DWORD) NO_ERROR;
             }  // Was there a selection state transition ?
         }
      }
      else
      {
         // A handle to the answer file could not be obtained. Treat it as a UPGRADE.

         ClRtlLogPrint( "InOnOcQueueFileOpsUnattended the handle to the answer file could not be obtained.\n" );

         dwReturnValue = QueueFileOpsUnattendedUpgrade( (LPCTSTR) ptszSubComponentId,
                                                        hSetupFileQueue );

         ClRtlLogPrint( "QueueFileOpsUnattendedUpgrade returned 0x%1!x!.\n", dwReturnValue );
      }
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// QueueFileOpsUnattendedUpgrade
//
// Routine Description:
//    This function queues the file operations appropriate for an unattended
//    upgrade operation.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//    hSetupFileQueue - a HSPFILEQ (typedefed in setupapi.h to PVOID)
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::QueueFileOpsUnattendedUpgrade( IN LPCTSTR ptszSubComponentId,
                                                  IN OUT HSPFILEQ hSetupFileQueue )
{
   DWORD dwReturnValue;
   eClusterInstallState eState;

   // Has Cluster service previously been installed?

   // GetClusterInstallationState reports on the state of the registry value
   // that records the state of the Cluster service installation on NT 5 machines.
   // IsClusterServiceRegistered indicates whether the Cluster service is registered on
   // BOTH NT 4 and NT 5 machines. Both tests are required: IsClusterServiceRegistered for
   // upgrading NT 4 machines, GetClusterInstallationState for NT 5 machines.

   BOOL  fClusteringServicePreviouslyInstalled;

   ClRtlGetClusterInstallState( NULL, &eState );
   if ( ( eState != eClusterInstallStateUnknown ) ||
        ( IsClusterServiceRegistered() == (BOOL) TRUE ) )
   {
      fClusteringServicePreviouslyInstalled = (BOOL) TRUE;
   }
   else
   {
      fClusteringServicePreviouslyInstalled = (BOOL) FALSE;
   }

   if ( fClusteringServicePreviouslyInstalled == (BOOL) TRUE )
   {
      // Upgrade the ClusteringService files.

      dwReturnValue = QueueInstallFileOperations( m_SetupInitComponent.ComponentInfHandle,
                                                  ptszSubComponentId,
                                                  hSetupFileQueue );

      ClRtlLogPrint( "QueueInstallFileOperations returned 0x%1!x! to QueueFileOpsUnattendedUpgrade.\n",
                     dwReturnValue );
   } // Has Cluster service previously been installed?
   else
   {
      // Since Cluster service has not been previously installed there is
      // nothing to do.

      ClRtlLogPrint( "In QueueFileOpsUnattendedUpgrade Cluster service has never been installed.\n" );

      dwReturnValue = (DWORD) NO_ERROR;
   } // Has Cluster service previously been installed?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcQueueFileOpsAttended
//
// Routine Description:
//    This function processes the OC_QUEUE_FILE_OPS "messages" from the
//    Optional Components Manager during ATTENDED operations.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//    hSetupFileQueue - a HSPFILEQ (typedefed in setupapi.h to PVOID)
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcQueueFileOpsAttended( IN LPCTSTR ptszSubComponentId,
                                             IN OUT HSPFILEQ hSetupFileQueue )
{
   DWORD dwReturnValue;
   eClusterInstallState eState;

   // Is Cluster service selected?

   BOOL  fCurrentSelectionState;
   BOOL  fOriginalSelectionState;

   fCurrentSelectionState =
   m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                            (LPCTSTR) ptszSubComponentId,
                                                            (UINT) OCSELSTATETYPE_CURRENT );

   if ( fCurrentSelectionState == (BOOL) TRUE )
   {
      // The subcomponent is selected. Is this a fresh install ?

      ClRtlLogPrint( "In OnOcQueueFileOpsAttended the current selection state is TRUE.\n" );

      if ( ( (m_SetupInitComponent.SetupData.OperationFlags &
              (DWORDLONG) SETUPOP_STANDALONE) == (DWORDLONG) 0L ) &&
           ( (m_SetupInitComponent.SetupData.OperationFlags &
              (DWORDLONG) SETUPOP_NTUPGRADE) == (DWORDLONG) 0L ) )
      {
         // SETUPOP_STANDALONE flag clear means running under GUI mode setup.
         // SETUPOP_NTUPGRADE flag clear means not performing an upgrade.
         // Both flags clear means a fresh install. Do not check for a selection
         // state transition.

         ClRtlLogPrint( "In OnOcQueueFileOpsAttended this is a CLEAN install.\n" );

         dwReturnValue = QueueInstallFileOperations( m_SetupInitComponent.ComponentInfHandle,
                                                     ptszSubComponentId,
                                                     hSetupFileQueue );

         ClRtlLogPrint( "QueueInstallFileOperations returned 0x%1!x! to OnOcQueueFileOpsAttended.\n",
                        dwReturnValue );
      }
      else
      {
         // This is either an upgrade or OC Manager is running stand-alone.

         if ( (m_SetupInitComponent.SetupData.OperationFlags &
               (DWORDLONG) SETUPOP_NTUPGRADE) != (DWORDLONG) 0L )
         {
            ClRtlLogPrint( "In OnOcQueueFileOpsAttended this is an UPGRADE.\n" );

            // This is an upgrade, if Cluster Server has previously been
            // been installed then queue the file copies.

            // Has Cluster service perviously been installed? Ask the Service Control
            // Manager whether the Cluster Service is registered.

            // GetClusterInstallationState reports on the state of the registry value
            // that records the state of the Cluster service installation on NT 5 machines.
            // IsClusterServiceRegistered indicates whether the Cluster service is registered on
            // BOTH NT 4 and NT 5 machines. Both tests are required: IsClusterServiceRegistered for
            // upgrading NT 4 machines, GetClusterInstallationState for NT 5 machines.

            BOOL  fClusterServiceRegistered;

            fClusterServiceRegistered = IsClusterServiceRegistered();

            BOOL  fClusterServicePreviouslyInstalled;

            ClRtlGetClusterInstallState( NULL, &eState );
            if ( ( eState != eClusterInstallStateUnknown ) ||
                 ( fClusterServiceRegistered == (BOOL) TRUE ) )
            {
               fClusterServicePreviouslyInstalled = (BOOL) TRUE;
            }
            else
            {
               fClusterServicePreviouslyInstalled = (BOOL) FALSE;
            }

            if ( fClusterServicePreviouslyInstalled == (BOOL) TRUE )
            {
               // Since this is an UPGRADE and Cluster service has been
               // installed there is no need to test for a selection state transition.

               dwReturnValue = QueueInstallFileOperations( m_SetupInitComponent.ComponentInfHandle,
                                                           ptszSubComponentId,
                                                           hSetupFileQueue );

               ClRtlLogPrint( "QueueInstallFileOperations returned 0x%1!x! to OnOcQueueFileOpsAttended.\n",
                              dwReturnValue );
            }
            else
            {
               ClRtlLogPrint( "In OnOcQueueFileOps attempted an UPGRADE but Cluster service has never been installed.\n" );

               dwReturnValue = (DWORD) NO_ERROR;
            }  // Was Cluster service perviously installed?
         }
         else
         {
            ClRtlLogPrint( "In OnOcQueueFileOpsAttended this is STANDALONE.\n" );

            // This is not an upgrade. That means Add/Remove Programs must be
            // running. It is necessary to test for a selection state transition.

            fOriginalSelectionState =
            m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                     ptszSubComponentId,
                                                                     (UINT) OCSELSTATETYPE_ORIGINAL );

            // Was there a selection state transition?

            if ( fCurrentSelectionState != fOriginalSelectionState )
            {
               ClRtlLogPrint( "A selection state transition was detected.\n" );

               // A selection state transition has occured. Install files.

               dwReturnValue = QueueInstallFileOperations( m_SetupInitComponent.ComponentInfHandle,
                                                           ptszSubComponentId,
                                                           hSetupFileQueue );

               ClRtlLogPrint( "QueueInstallFileOperations returned 0x%1!x! to OnOcQueueFileOpsAttended,\n",
                              dwReturnValue );
            }
            else
            {
               ClRtlLogPrint( "NO selection state transition was detected.\n" );

               // The selection state has not been changed. Perform no action.

               dwReturnValue = (DWORD) NO_ERROR;
            }  // Was there a selection state transition?
         }  // Is this an UPGRADE?
      }  // Is this a clean install?
   }  // Is Cluster service currently selected ?
   else
   {
      ClRtlLogPrint( "In OnOcQueueFileOpsAttended the current selection state is FALSE.\n" );

      // Cluster service is not selected. Is OC Manager running stand-alone ?
      // If not, i.e. if GUI mode setup is running, there is nothing to do.

      if ( (m_SetupInitComponent.SetupData.OperationFlags &
            (DWORDLONG) SETUPOP_STANDALONE) != (DWORDLONG) 0L )
      {
         ClRtlLogPrint( "In OnOcQueueFileOpsAttended this is STANDALONE.\n" );

         // SETUPOP_STANDALONE set implies GUI mode setup is not running. If
         // there was a selection state change (to unselected) then remove files.

         fOriginalSelectionState =
         m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                  ptszSubComponentId,
                                                                  (UINT) OCSELSTATETYPE_ORIGINAL );

         // Has there been a selection state transition ?

         if ( fCurrentSelectionState != fOriginalSelectionState )
         {
            // Remove files.

            dwReturnValue = QueueRemoveFileOperations( m_SetupInitComponent.ComponentInfHandle,
                                                       ptszSubComponentId,
                                                       hSetupFileQueue );

            ClRtlLogPrint( "QueueRemoveFileOperations returned 0x%1!x! to OnOcQueueFileOpsAttended.\n",
                           dwReturnValue );
         }
         else
         {
            ClRtlLogPrint( "NO selection state transition was detected.\n" );

            // The selection state has not been changed. Perform no action.

            dwReturnValue = (DWORD) NO_ERROR;
         }  // Was there a selection state transition ?
      }
      else
      {
         // GUI mode setup is running and Cluster service is not selected.
         // There is nothing to do.

         dwReturnValue = (DWORD) NO_ERROR;
      }  // Is GUI mode setup running ?
   }  // Is Cluster service currently selected ?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// CompleteUninstallingClusteringService
//
// Routine Description:
//    This function completes uninstalling ClusteringService by queuing the
//    registry operations to delete the Cluster service registry keys,
//    cleaning up the Start Menu, removing the Network Provider, and requesting
//    a reboot.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::CompleteUninstallingClusteringService( IN LPCTSTR ptszSubComponentId )
{
   DWORD dwReturnValue;
   eClusterInstallState ecisInstallState;
   BOOL bRebootRequired = FALSE;

   // Update the "progress text"

   CString  csProgressText;

   csProgressText.LoadString( IDS_REMOVING_CLUS_SERVICE );

   m_SetupInitComponent.HelperRoutines.SetProgressText( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                        (LPCTSTR) csProgressText );

   // Request that the system reboot only if clusdisk has been started.
   // We can deduce this by looking at the cluster installation state.
   // If the state is not eClusterInstallStateFilesCopied then it means that
   // ClusCfg may have run successfully and therefore, clusdisk may have been started.

   // We must call ClRtlGetClusterInstallState before calling UninstallRegistryOperations.
   // Otherwise it will always return eClusterInstallStateUnknown!

   // If ClRtlGetClusterInstallState fails, reboot anyway.
   // If it succeeds, reboot only if ClusCfg has completed successfully.
   if (    ( ClRtlGetClusterInstallState( NULL, &ecisInstallState ) != ERROR_SUCCESS ) 
        || ( ecisInstallState != eClusterInstallStateFilesCopied ) 
      )
   {
       bRebootRequired = TRUE;
   }

   // Delete registry entries. Queue the base registry operations.

   dwReturnValue = UninstallRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                                ptszSubComponentId );

   ClRtlLogPrint( "UninstallRegistryOperations returned 0x%1!x! to CompleteUninstallingClusteringService.\n",
                  dwReturnValue );

   //
   // Remove the cluster item from the start menu
   //

   CString csGroupName;
   CString csItemName;

   csGroupName.LoadString( IDS_START_GROUP_NAME );
   csItemName.LoadString( IDS_START_ITEM_NAME );

   DeleteLinkFile( CSIDL_COMMON_PROGRAMS,
                   (LPCWSTR) csGroupName,
                   (LPCWSTR) csItemName,
                   (BOOL) FALSE );

   // Delete the cluster directory. BUGBUG

   //
   // Remove the cluster network provider
   //

   dwReturnValue = RemoveNetworkProvider();

   if ( bRebootRequired )
   {
       BOOL  fRebootRequestStatus;

       // In the following call the value passed in the second parameter
       // was chosen arbitrarily. Ocmanage.h implies that the parameter is not used.

       fRebootRequestStatus =
          m_SetupInitComponent.HelperRoutines.SetReboot( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                         (BOOL) TRUE );
   }

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OpenClusterRegistryRoot
//
// Routine Description:
//    This function retuns a handle to the root key of the Cluster hive.
//    It will load the hive if necessary.
//
// Arguments:
//    none
//
//
// Return Value:
//    If success, handle to the cluster root key. Otherwise, NULL
//
//--
/////////////////////////////////////////////////////////////////////////////

HKEY CClusocmApp::OpenClusterRegistryRoot( void )
{
   BOOL  fReturnValue;

   HKEY hClusterKey = NULL;
   LONG lReturnValue;

   // Attempt to open the Cluster Registry key.

   CString  csClusterRegKey;

   csClusterRegKey = CLUSREG_KEYNAME_CLUSTER;

   lReturnValue = RegOpenKeyEx( HKEY_LOCAL_MACHINE, csClusterRegKey,
                                0, KEY_READ, &hClusterKey);

   if ( lReturnValue != ERROR_SUCCESS )
   {
      ClRtlLogPrint( "In OpenClusterRegistryRoot, the first attempt to open the Cluster key failed.\n" );

      // The Cluster hive is not currently loaded. This condition means that
      // the cluster service has not been started. Attempt to load the Cluster
      // hive so that it can be read.

      // First, locate the Cluster hive file. It should be in the location
      // specified for the ClusterFiles entry in the [DestinationDirs] section
      // of clusocm.inf.

      CString  csClusterHiveFilePath;

      fReturnValue = LocateClusterHiveFile( (CString &) csClusterHiveFilePath );

      ClRtlLogPrint( "LocateClusterHiveFile returned 0x%1!x! to OpenClusterRegistryRoot.\n",
                     fReturnValue );

      // Was the Cluster hive file located?

      if ( fReturnValue == (BOOL) TRUE )
      {
         // The Cluster hive file was located.
         // Attempt to load the cluster hive.

         BOOLEAN  OriginalState;

         // I'm not sure what the following function does, but the prototype is
         // in sdk\inc\ntrtl.h. Look in stdafx.h for the inclusion of ntrtl.h. I
         // replicated the logic that was used in newsetup.h to make it work.

         lReturnValue = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                             TRUE,
                                             FALSE,
                                             &OriginalState );

         if ( lReturnValue == ERROR_SUCCESS )
         {
            // Attempt to Load the Cluster Hive.

            lReturnValue = RegLoadKey( HKEY_LOCAL_MACHINE,
                                       csClusterRegKey,
                                       csClusterHiveFilePath );

            if ( lReturnValue == ERROR_SUCCESS )
            {

               // Now that the Cluster hive has been loaded, attempt to open the
               // Cluster registry key.

               lReturnValue = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            csClusterRegKey,
                                            0, KEY_READ,
                                            &hClusterKey );

               // lReturnValue will be tested by the next BLOCK of code.
            }

            // Undo whatever the preceding call to RtlAdjustPrivilege() did.

            RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                OriginalState,
                                FALSE,
                                &OriginalState );

            if ( lReturnValue != ERROR_SUCCESS )
            {
                // Set the error code.
                SetLastError( lReturnValue );
            }

         }
         else
         {
            // The initial call to RtlAdjustPrivilege FAILED.
            SetLastError( lReturnValue );

            // A return value of TRUE will allow the uninstall operation to
            // continue. Since lReturnValue is NOT ERROR_SUCCESS no additional
            // processing will be performed by this function.

         }  // Did RtlAdjustPrivilege succeed?
      }
      else
      {
         // The Cluster hive file was not located. Set last error and return
         // a null handle

         ClRtlLogPrint( "OpenClusterRegistryRoot couldn't locate the hive files\n" );

         SetLastError( ERROR_FILE_NOT_FOUND );

      }  // Was the cluster hive file located?
   }  // Was the Cluster registry key opened successfully?

   return ( hClusterKey );
} // OpenClusterRegistryRoot

/////////////////////////////////////////////////////////////////////////////
//++
//
// FindNodeNumber
//
// Routine Description:
//    This function looks through the cluster's Node key and returns a pointer to
//    the node number string of the current node.
//
// Arguments:
//    ClusterKey - handle to cluster root key
//
//    NodeNumberString - pointer to location that receives the node number
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

PWSTR CClusocmApp::FindNodeNumber( HKEY ClusterKey )
{
   WCHAR nodeName[ MAX_COMPUTERNAME_LENGTH + 1 ];
   DWORD nodeNameLength = sizeof( nodeName );
   WCHAR registryNodeName[ MAX_COMPUTERNAME_LENGTH + 1 ];
   DWORD registryNodeNameLength;
   HKEY nodesKey = NULL;
   HKEY nodesEnumKey = NULL;
   DWORD status;
   PWSTR nodeNumberString;
   DWORD nodeNumberStringLength;
   DWORD index = 0;
   DWORD dataType;

   //
   // allocate space for the node number string
   //
   nodeNumberString = (PWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                         ( CS_MAX_NODE_ID_LENGTH + 1 ) * sizeof( WCHAR ));
   if ( nodeNumberString == NULL ) {
       status = GetLastError();
       ClRtlLogPrint( "FindNodeNumber couldn't allocate node number buffer: %1!u!\n",
                      status );
       return NULL;
   }

   //
   // get our node name and a handle to the root key in the cluster hive
   //

   if ( !GetComputerName( nodeName, &nodeNameLength )) {
      status = GetLastError();
      ClRtlLogPrint( "FindNodeNumber failed to get computer name: %1!u!\n",
                     status );

      goto error_exit;
   }

   status = RegOpenKeyEx( ClusterKey,
                          CLUSREG_KEYNAME_NODES,
                          0,
                          KEY_READ,
                          &nodesKey );

   if ( status != ERROR_SUCCESS ) {
      ClRtlLogPrint( "FindNodeName failed to open Nodes key: %1!u!\n",
                     status );
      goto error_exit;
   }

   //
   // enum the entries under the Nodes key
   //
   do {
       nodeNumberStringLength = sizeof( nodeNumberString );
       status = RegEnumKeyEx( nodesKey,
                              index,
                              nodeNumberString,
                              &nodeNumberStringLength,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

       if ( status == ERROR_NO_MORE_ITEMS ) {
           ClRtlLogPrint( "FindNodeNumber finished enum'ing the Nodes key\n" );
           break;
       } else if ( status != ERROR_SUCCESS ) {
           ClRtlLogPrint( "FindNodeNumber failed to enum Nodes key: %1!u!\n",
                          status );
           goto error_exit;
       }

       //
       // open this key and get the Name value
       //
       status = RegOpenKeyEx( nodesKey,
                              nodeNumberString,
                              0,
                              KEY_READ,
                              &nodesEnumKey );

       if ( status != ERROR_SUCCESS ) {
           ClRtlLogPrint( "FindNodeNumber failed to open Nodes key %1!ws!: %2!u!\n",
                          nodeNumberString,
                          status );
           goto error_exit;

       }

       registryNodeNameLength = sizeof( registryNodeName );
       status = RegQueryValueEx( nodesEnumKey,
                                 CLUSREG_NAME_NODE_NAME,
                                 NULL,
                                 &dataType,
                                 (LPBYTE)registryNodeName,
                                 &registryNodeNameLength );

       RegCloseKey( nodesEnumKey );
       nodesEnumKey = NULL;

       if ( status != ERROR_SUCCESS || dataType != REG_SZ ) {
           ClRtlLogPrint( "FindNodeNumber failed to get NodeName value: "
                          "status %1!u!, data type %2!u!\n",
                          status, dataType );
           goto error_exit;

       }

       //
       // finally, we get to see if this is our node
       //
       if ( lstrcmpiW( nodeName, registryNodeName ) == 0 ) {
           break;
       }

       ++index;
   } while ( TRUE );

error_exit:
   if ( nodesKey != NULL ) {
       RegCloseKey( nodesKey );
   }

   if ( nodesEnumKey != NULL ) {
       RegCloseKey( nodesEnumKey );
   }

   if ( status != ERROR_SUCCESS || lstrlenW( nodeNumberString ) == 0 ) {
       LocalFree( nodeNumberString );
       nodeNumberString = NULL;
   }

   return nodeNumberString;
} // FindNodeNumber

/////////////////////////////////////////////////////////////////////////////
//++
//
// GetConnectionName
//
// Routine Description:
//    This function finds the matching connection object based on the IP address
//    of the network interface. NOTE that the return value is also pointed to in
//    the Adapter Info of the Adapter enum struct. This return value must not be
//    freed with LocalFree.
//
// Arguments:
//    NetInterfacesKey - handle to key of network interface
//
//    AdapterEnum - pointer to struct with adapter/IP interface info
//
// Return Value:
//    If successful, pointer to connectoid name. Otherwise, NULL with Win32
//    error available from GetLastError().
//
//--
/////////////////////////////////////////////////////////////////////////////

PWSTR CClusocmApp::GetConnectionName( HKEY NetInterfacesGuidKey,
                                      PCLRTL_NET_ADAPTER_ENUM AdapterEnum )
{
    WCHAR                     ipAddress[ 16 ];
    DWORD                     ipAddressLength = sizeof( ipAddress );
    DWORD                     status;
    PCLRTL_NET_ADAPTER_INFO   adapterInfo;
    PCLRTL_NET_INTERFACE_INFO interfaceInfo;
    PWSTR                     connectoidName = NULL;
    DWORD                     dataType;

    //
    // query for the netIf's IP address
    //
    status = RegQueryValueEx( NetInterfacesGuidKey,
                              CLUSREG_NAME_NETIFACE_ADDRESS,
                              NULL,
                              &dataType,
                              (LPBYTE)ipAddress,
                              &ipAddressLength );


    if ( status != ERROR_SUCCESS || dataType != REG_SZ ) {
        ClRtlLogPrint( "GetConnectionName failed to get Address value: "
                       "status %1!u!, data type %2!u!\n",
                       status, dataType );

        SetLastError( ERROR_INVALID_DATA );
        goto error_exit;
    }

    adapterInfo = ClRtlFindNetAdapterByInterfaceAddress( AdapterEnum,
                                                         ipAddress,
                                                         &interfaceInfo );
    if ( adapterInfo != NULL ) {
        connectoidName = adapterInfo->ConnectoidName;
    }

error_exit:
    return connectoidName;
} // GetConnectionName

/////////////////////////////////////////////////////////////////////////////
//++
//
// GetTCPAdapterInfo
//
// Routine Description:
//    This function opens a handle to the service controller and tries to
//    start the DHCP service. If successful, then TCP is queried for its
//    NIC and IP interface info.
//
// Arguments:
//    none
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

PCLRTL_NET_ADAPTER_ENUM CClusocmApp::GetTCPAdapterInfo( void )
{
    SC_HANDLE schSCManager;
    SC_HANDLE serviceHandle;
    PCLRTL_NET_ADAPTER_ENUM adapterEnum = NULL;
    BOOL success;
    DWORD retryCount;
    DWORD status;

    schSCManager = OpenSCManager(NULL,                   // machine (NULL == local)
                                 NULL,                   // database (NULL == default)
                                 SC_MANAGER_CONNECT); // access required

    if ( schSCManager ) {

        //
        // start DHCP for nodes that are using it. it will cause TCP to start
        // as well. For statically configured nodes, starting DHCP causes no
        // harm.
        //
        serviceHandle = OpenService(schSCManager,
                                    L"DHCP",
                                    SERVICE_START );

        if ( serviceHandle ) {
            success = StartService( serviceHandle, 0, NULL );

            if ( !success ) {
                status = GetLastError();
                if ( status == ERROR_SERVICE_ALREADY_RUNNING ) {
                    success = TRUE;
                }
            }

            if ( success ) {

                //
                // wait while TCP gets bound to all its adapters and discovers
                // its IP interfaces.
                //
                retryCount = 3;
                do {
                    Sleep( 2000 );
                    adapterEnum = ClRtlEnumNetAdapters();

                    if (adapterEnum != NULL) {
                        break;
                    }
                } while ( --retryCount != 0 );

                if (adapterEnum == NULL) {
                    status = GetLastError();
                    ClRtlLogPrint( "Failed to obtain local system network config. "
                                   "status %1!u! retryCount %2!u!\n",
                                   status, retryCount);
                }
            } else {
                ClRtlLogPrint( "StartService returned %1!u! to StartTCP\n", status);
            }
            CloseServiceHandle( serviceHandle );
        } else {
            status = GetLastError();
            ClRtlLogPrint( "OpenService returned %1!u! to StartTCP\n", status);
        }

        CloseServiceHandle( schSCManager );
    } else {
        status = GetLastError();
        ClRtlLogPrint("OpenSCManager returned %1!u! to StartTCP\n", status);
    }

    return adapterEnum;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
// RenameConnectionObjects
//
// Routine Description:
//    This function walks through the node's network interfaces and changes,
//    if necessary, their associated connection objects.
//
// Arguments:
//    none
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::RenameConnectionObjects( void )
{
   HKEY                       clusterKey;
   HKEY                       netInterfacesKey = NULL;
   HKEY                       netInterfacesGuidKey = NULL;
   HKEY                       networkGuidKey = NULL;
   HKEY                       networksKey = NULL;
   DWORD                      status;
   PCLRTL_NET_ADAPTER_ENUM    adapterEnum = NULL;
   PCLRTL_NET_ADAPTER_INFO    adapterInfo = NULL;
   PCLRTL_NET_INTERFACE_INFO  adapterIfInfo = NULL;
   DWORD                      hiddenAdapterCount = 0;
   PWSTR                      ourNodeNumber = NULL;
   DWORD                      index = 0;
   WCHAR                      netIfGuidString[ CS_NETINTERFACE_ID_LENGTH + 1 ];
   DWORD                      netIfGuidStringLength;
   WCHAR                      networkGuidString[ CS_NETWORK_ID_LENGTH + 1 ];
   DWORD                      networkGuidStringLength;
   WCHAR                      netIfNodeNumber[ CS_MAX_NODE_ID_LENGTH + 1 ];
   DWORD                      netIfNodeNumberLength;
   DWORD                      dataType;
   PWSTR                      connectoidName;
   PWSTR                      networkName = NULL;
   DWORD                      networkNameLength;

   //
   // initialize COM
   //
   status = CoInitializeEx( NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
   if ( !SUCCEEDED( status )) {
      ClRtlLogPrint( "RenameConnectionObjects Couldn't init COM %1!08X!\n", status );
      return status;
   }

   //
   // get a handle to the root key in the cluster hive
   //
   clusterKey = OpenClusterRegistryRoot();

   if ( clusterKey == NULL ) {
      status = GetLastError();
      ClRtlLogPrint( "OpenClusterRegistryRoot returned %1!u! to RenameConnectionObjects\n",
                     status );
      goto error_exit;
   }

   //
   // start TCP if necessary
   //
   adapterEnum = GetTCPAdapterInfo();
   if ( adapterEnum == NULL ) {
      status = GetLastError();

      if ( status == ERROR_SUCCESS ) {
          ClRtlLogPrint( "No usable network adapters are installed in this system.\n" );
      } else {
          ClRtlLogPrint( "GetTCPAdapterInfo returned %1!u! to RenameConnectionObjects\n",
                         status );
      }
      goto error_exit;
   }

   //
   // Ignore all adapters which are hidden or have an address of 0.0.0.0.
   //
   for (adapterInfo = adapterEnum->AdapterList;
        adapterInfo != NULL;
        adapterInfo = adapterInfo->Next
        )
   {
       if (adapterInfo->Flags & CLRTL_NET_ADAPTER_HIDDEN) {
           ClRtlLogPrint( "Ignoring hidden adapter '%1!ws!'.\n",
                          adapterInfo->DeviceName );
           adapterInfo->Ignore = TRUE;
           hiddenAdapterCount++;
       }
       else {
           adapterIfInfo = ClRtlGetPrimaryNetInterface(adapterInfo);

           if (adapterIfInfo->InterfaceAddress == 0) {
               ClRtlLogPrint( "Ignoring adapter '%1!ws!' because primary address is 0.0.0.0.\n",
                              adapterInfo->DeviceName );
               adapterInfo->Ignore = TRUE;
               hiddenAdapterCount++;
           }
       }
   }

   if ((adapterEnum->AdapterCount - hiddenAdapterCount) == 0) {
       ClRtlLogPrint( "No usable network adapters are installed in this system.\n" );
       status = ERROR_SUCCESS;
       goto error_exit;
   }

   ClRtlLogPrint( "RenameConnectionObject found %1!u! adapters to process.\n",
                  adapterEnum->AdapterCount - hiddenAdapterCount );

   //
   // now find our node number by looking through the node key in the cluster
   // registry and comparing our netbios name with the names in the registry
   //
   ourNodeNumber = FindNodeNumber( clusterKey );
   if ( ourNodeNumber == NULL ) {
       status = GetLastError();
       ClRtlLogPrint( "FindNodeNumber failed: status %1!u!\n",
                      status );
       goto error_exit;
   }

   //
   // open the network and network interface keys
   //
   status = RegOpenKeyEx( clusterKey,
                          CLUSREG_KEYNAME_NETWORKS,
                          0,
                          KEY_READ,
                          &networksKey );

   if ( status != ERROR_SUCCESS ) {
       ClRtlLogPrint( "RenameConnectionObjects failed to open Networks key: %1!u!\n",
                      status );
       goto error_exit;

   }

   status = RegOpenKeyEx( clusterKey,
                          CLUSREG_KEYNAME_NETINTERFACES,
                          0,
                          KEY_READ,
                          &netInterfacesKey );

   if ( status != ERROR_SUCCESS ) {
       ClRtlLogPrint( "RenameConnectionObjects failed to open NetworkInterfaces key: %1!u!\n",
                      status );
       goto error_exit;

   }

   //
   // enum the NetworkInterfaces key, looking for interfaces on this node. If
   // we find one, get their IP address and find the corresponding network and
   // connection object.
   //
   do {
       netIfGuidStringLength = sizeof( netIfGuidString );
       status = RegEnumKeyEx( netInterfacesKey,
                              index,
                              netIfGuidString,
                              &netIfGuidStringLength,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

       if ( status == ERROR_NO_MORE_ITEMS ) {
           ClRtlLogPrint( "RenameConnectionObjects finished enum'ing the "
                          "NetworkInterfaces key\n" );

           status = ERROR_SUCCESS;
           break;
       } else if ( status != ERROR_SUCCESS ) {
           ClRtlLogPrint( "RenameConnectionObjects failed to enum NetworkInterfaces "
                          "key: %1!u!\n",
                          status );
           goto error_exit;
       }

       //
       // open this key and get the Node value
       //
       status = RegOpenKeyEx( netInterfacesKey,
                              netIfGuidString,
                              0,
                              KEY_READ,
                              &netInterfacesGuidKey );

       if ( status != ERROR_SUCCESS ) {
           ClRtlLogPrint( "RenameConnectionObjects failed to open NetworkIntefaces "
                          "subkey %1!ws!: %2!u!\n",
                          netIfGuidString,
                          status );
           goto error_exit;

       }

       netIfNodeNumberLength = sizeof( netIfNodeNumber );
       status = RegQueryValueEx( netInterfacesGuidKey,
                                 CLUSREG_NAME_NETIFACE_NODE,
                                 NULL,
                                 &dataType,
                                 (LPBYTE)netIfNodeNumber,
                                 &netIfNodeNumberLength );


       if ( status != ERROR_SUCCESS || dataType != REG_SZ ) {
           ClRtlLogPrint( "RenameConnectionObjects failed to get Node value: "
                          "status %1!u!, data type %2!u!\n",
                          status, dataType );
           status = ERROR_INVALID_DATA;
           goto error_exit;

       }

       //
       // if this is one our interfaces, then adjust the name of the
       // associated connection object
       //
       if ( lstrcmpiW( ourNodeNumber, netIfNodeNumber ) == 0 ) {
           ClRtlLogPrint( "Net Interface %1!ws! is on this node.\n",
                          netIfGuidString );

           connectoidName = GetConnectionName( netInterfacesGuidKey,
                                               adapterEnum );

           if ( connectoidName != NULL ) {

               ClRtlLogPrint( "Associated connectoid name is '%1!ws!'.\n",
                              connectoidName);

               //
               // look up network GUID and open its Key to get the network name
               //
               networkGuidStringLength = sizeof( networkGuidString );
               status = RegQueryValueEx( netInterfacesGuidKey,
                                         CLUSREG_NAME_NETIFACE_NETWORK,
                                         NULL,
                                         &dataType,
                                         (LPBYTE)networkGuidString,
                                         &networkGuidStringLength );

               if ( status != ERROR_SUCCESS || dataType != REG_SZ ) {
                   ClRtlLogPrint( "RenameConnectionObjects failed to get Network value: "
                                  "status %1!u!, data type %2!u!\n",
                                  status, dataType );
                   status = ERROR_INVALID_DATA;
                   goto error_exit;
               }

               status = RegOpenKeyEx( networksKey,
                                      networkGuidString,
                                      0,
                                      KEY_READ,
                                      &networkGuidKey );

               if ( status != ERROR_SUCCESS ) {
                   ClRtlLogPrint( "RenameConnectionObjects failed to open networks "
                                  "subkey %1!ws!: %2!u!\n",
                                  networkGuidString,
                                  status );
                   goto error_exit;

               }

               //
               // query the Name value to get its size, allocate a buffer large
               // enough to hold it and request the data contained in the value.
               //
               networkNameLength = 0;
               status = RegQueryValueEx( networkGuidKey,
                                         CLUSREG_NAME_NET_NAME,
                                         NULL,
                                         &dataType,
                                         (LPBYTE)NULL,
                                         &networkNameLength );

               if ( status != ERROR_SUCCESS || dataType != REG_SZ ) {
                   ClRtlLogPrint( "RenameConnectionObjects failed to get Network Name "
                                  "size: status %1!u!, data type %2!u!\n",
                                  status, dataType );
                   status = ERROR_INVALID_DATA;
                   goto error_exit;
               }

               networkName = (PWCHAR)LocalAlloc( LMEM_FIXED, networkNameLength );
               if ( networkName == NULL ) {
                   status = GetLastError();
                   ClRtlLogPrint( "RenameConnectionObjects failed to alloc space "
                                  "for network name: %1!u!\n",
                                  status );
                   goto error_exit;
               }

               status = RegQueryValueEx( networkGuidKey,
                                         CLUSREG_NAME_NET_NAME,
                                         NULL,
                                         NULL,
                                         (LPBYTE)networkName,
                                         &networkNameLength );

               RegCloseKey( networkGuidKey );
               networkGuidKey = NULL;

               if ( status != ERROR_SUCCESS ) {
                   ClRtlLogPrint( "RenameConnectionObjects failed to get Network "
                                  "Name: status %1!u!\n",
                                  status );
                   goto error_exit;
               }

               ClRtlLogPrint( "Network name is '%1!ws!'.\n", networkName );

               if ( lstrcmpiW( connectoidName, networkName ) != 0 ) {
                   ClRtlLogPrint( "Changing connectoid name to '%1!ws!'.\n", networkName );
                   ClRtlFindConnectoidByNameAndSetName(
                       connectoidName,
                       networkName
                       );
               }
           } else {
               ClRtlLogPrint( "RenameConnectionObjects failed to get connection name.\n" );
           }
       }

       RegCloseKey( netInterfacesGuidKey );
       netInterfacesGuidKey = NULL;

       ++index;
   } while ( TRUE );

error_exit:
   if ( clusterKey != NULL ) {
      RegCloseKey( clusterKey );
   }

   if ( netInterfacesKey != NULL ) {
      RegCloseKey( netInterfacesKey );
   }

   if ( netInterfacesGuidKey != NULL ) {
      RegCloseKey( netInterfacesGuidKey );
   }

   if ( networksKey != NULL ) {
      RegCloseKey( networksKey );
   }

   if ( networkGuidKey != NULL ) {
      RegCloseKey( networkGuidKey );
   }

   if ( ourNodeNumber != NULL ) {
       LocalFree( ourNodeNumber );
   }

   if ( networkName != NULL ) {
       LocalFree( networkName );
   }

   if ( adapterEnum != NULL ) {
       ClRtlFreeNetAdapterEnum( adapterEnum );
   }

   CoUninitialize();

   return status;
} // RenameConnectionObjects



/////////////////////////////////////////////////////////////////////////////
//++
//
// CompleteUpgradingClusteringService
//
// Routine Description:
//    This function completes the process of upgrading a Cluster service installation.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::CompleteUpgradingClusteringService( IN LPCTSTR ptszSubComponentId )
{
   DWORD dwReturnValue;
   eClusterInstallState eState;

   // This is an upgrade, if Cluster Server has previously been
   // been installed then queue the registry additions.

   // GetClusterInstallationState reports on the state of the registry value
   // that records the state of the Cluster service installation on NT 5 machines.
   // IsClusterServiceRegistered indicates whether the Cluster service is registered on
   // BOTH NT 4 and NT 5 machines. Both tests are required: IsClusterServiceRegistered for
   // upgrading NT 4 machines, ClRtlGetClusterInstallState for NT 5 machines.

   BOOL  fClusterServiceRegistered;

   fClusterServiceRegistered = IsClusterServiceRegistered();

   ClRtlGetClusterInstallState( NULL, &eState );

   if ( ( eState != eClusterInstallStateUnknown ) ||
        ( fClusterServiceRegistered == (BOOL) TRUE ) )
   {
      // Update the progress bar.

      m_SetupInitComponent.HelperRoutines.TickGauge( m_SetupInitComponent.HelperRoutines.OcManagerContext );

      // Update the "progress text"

      CString  csProgressText;

      csProgressText.LoadString( IDS_UPGRADING_CLUS_SERVICE );

      m_SetupInitComponent.HelperRoutines.SetProgressText( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                           (LPCTSTR) csProgressText );
      ClRtlLogPrint( "In CompleteUpgradingClusteringService Cluster service has previously been installed.\n" );

      // Perform the base registry operations.

      dwReturnValue = PerformRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                                 ptszSubComponentId );

      ClRtlLogPrint( "The base call to PerformRegistryOperations returned 0x%1!x! to "
                     "CompleteUpgradingClusteringService.\n",
                     dwReturnValue );

      // Were the base registry operations performed successfully?

      CString  csUpgrade;

      if ( dwReturnValue == (DWORD) NO_ERROR )
      {
         // Perform the registry operations that pertain to UPGRADE.

         csUpgrade = UPGRADE_INF_KEY;

         dwReturnValue = PerformRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                                    csUpgrade );

         ClRtlLogPrint( "The UPGRADE call to PerformRegistryOperations returned 0x%1!x! "
                        "to CompleteUpgradingClusteringService.\n",
                        dwReturnValue );
      }  // Were the base registry operations performed successfully?

      // Were the UPGRADE registry operations performed successfully?

      if ( dwReturnValue == (DWORD) NO_ERROR )
      {
         // If the Cluster Service is registered with the Service Control Manager then
         // the registry keys that add "Configure Cluster service" to the Welcome UI
         // should be eliminated because the service has already been configured.

         if ( fClusterServiceRegistered == (BOOL) TRUE )
         {
            CString  csClusterService;

            csClusterService = CLUSTER_SERVICE_NAME;

            CString  csRegistered;

            csRegistered = REGISTERED_INF_KEY_FRAGMENT;

            CString  csSectionName;

            csSectionName = csUpgrade + (CString) _T(".") +
                            csClusterService + (CString) _T(".") +
                            csRegistered;

            dwReturnValue = PerformRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                                       csSectionName );

            ClRtlLogPrint( "The REGISTERED call to PerformRegistryOperations returned 0x%1!x! "
                           "to CompleteUpgradingClusteringService.\n",
                           dwReturnValue );
         }

         // Were the Welcome UI registry operations performed successfully?

         if ( dwReturnValue == (DWORD) NO_ERROR )
         {
            ClRtlLogPrint( "In CompleteUpgradingClusteringService the registry operations "
                           "were performed successfully.\n" );

            // In NT 4 the ImagePath value in HKLM\System\CurrentControlSet\Services\ClusSvc
            // is set to reference clusprxy.exe. In NT 5 it must reference clussvc.exe.

            // The ImagePath value in the Cluster Service registry key must
            // be set programmatically because the path to the service
            // executable image is not known to the component INF file. That
            // is because in NT 4 "Cluster Server" as it was known, could be
            // installed in an arbitrary location.

            // There is no straightforward way to determine whether this upgrade
            // is from NT 4 or NT 5. The assumption made here is that if the
            // Cluster Service is registered with the Service Control Manager
            // then it was upgraded in place, regardless of the OS level. In that
            // case it will be safe to set the ImagePath value to reference clussvc.exe
            // in that location. If the Cluster Service is not registered with the
            // SC Manager then it is safe to leave that reg value alone because when
            // cluscfg.exe configures the Cluster service the ImagePath value will
            // get written correctly.

            if ( fClusterServiceRegistered == (BOOL) TRUE )
            {
               dwReturnValue = UpgradeClusterServiceImagePath();

               ClRtlLogPrint( "UpgradeClusterServiceImagePath returned 0x%1!x! to "
                              "CompleteUpgradingClusteringService.\n",
                              dwReturnValue );
            }

            // Was the ImagePath set successfully?

            if ( dwReturnValue == (DWORD) NO_ERROR )
            {
               // did the connection objects get renamed?

               dwReturnValue = RenameConnectionObjects();

               ClRtlLogPrint( "RenameConnectionObjects returned 0x%1!x! to "
                              "CompleteUpgradingClusteringService.\n",
                              dwReturnValue );

               if ( dwReturnValue == (DWORD) NO_ERROR )
               {
                  //
                  // set the service controller default failure actions
                  //
                  dwReturnValue = ClRtlSetSCMFailureActions( NULL );

                  ClRtlLogPrint( "ClRtlSetDefaultFailureActions returned 0x%1!x! to "
                                 "CompleteUpgradingClusteringService.\n",
                                 dwReturnValue );

                  if ( dwReturnValue == (DWORD) NO_ERROR )
                  {
                     // In NT4 the "Display Name" for the Cluster service was
                     // "Cluster Server". It must be programatically changed to
                     // "Cluster service".

                     if ( fClusterServiceRegistered == (BOOL) TRUE )
                     {
                        CString  csClusterService;

                        csClusterService = CLUSTER_SERVICE_NAME;

                        SC_HANDLE hscServiceMgr;
                        SC_HANDLE hscService;

                        // Connect to the Service Control Manager and open the specified service
                        // control manager database.

                        hscServiceMgr = OpenSCManager( NULL, NULL, GENERIC_READ | GENERIC_WRITE );

                        // Was the service control manager database opened successfully?

                        if ( hscServiceMgr != NULL )
                        {
                           // The service control manager database is open.
                           // Get the current display name of the service.

                           TCHAR tszDisplayName[50];     // arbitrary size
                           DWORD dwBufferSize = 50;

                           BOOL fStatus;

                           fStatus = GetServiceDisplayName( hscServiceMgr,
                                                            (LPCTSTR) csClusterService,
                                                            tszDisplayName,
                                                            &dwBufferSize );

                           if ( fStatus == (BOOL) TRUE )
                           {
                              // Is the service name "Cluster service"?

                              if ( _tcscmp( tszDisplayName, _T("Cluster service") ) != 0 )
                              {
                                 // The display name is not correct. Change it.
                                 // Open a handle to the Service. Allow configuration changes.

                                 hscService = OpenService( hscServiceMgr,
                                                           (LPWSTR) (LPCTSTR) csClusterService,
                                                           SERVICE_CHANGE_CONFIG );

                                 // Was the handle to the service opened?

                                 if ( hscService != NULL )
                                 {
                                    // A valid handle to the Service was obtained.

                                    fStatus = ChangeServiceConfig( hscService,
                                                                   SERVICE_NO_CHANGE,
                                                                   SERVICE_NO_CHANGE,
                                                                   SERVICE_NO_CHANGE,
                                                                   NULL,
                                                                   NULL,
                                                                   NULL,
                                                                   NULL,
                                                                   NULL,
                                                                   NULL,
                                                                   _T("Cluster service") );

                                    // Was the change succesful?

                                    if ( fStatus != (BOOL) TRUE )
                                    {
                                       dwReturnValue = GetLastError();

                                       ClRtlLogPrint( "Could not change the cluster service display name"
                                                      " in CompleteUpgradingClusteringService."
                                                      " Error: 0x%1!x!.\n",
                                                      dwReturnValue );
                                    }

                                    // Close the handle to the Cluster Service.

                                    CloseServiceHandle( hscService );
                                 } // service opened?
                              } // display name correct?
                           }
                           else
                           {
                              // Couldn't get the display name.

                              dwReturnValue = GetLastError();

                              ClRtlLogPrint( "Could not query the cluster service display name"
                                             " in CompleteUpgradingClusteringService."
                                             " Error: 0x%1!x!.\n",
                                             dwReturnValue );
                           }// got display name?

                           // Close the handle to the Service Control Manager.

                           CloseServiceHandle( hscServiceMgr );
                        }
                     } // cluster service registered?

                     if ( dwReturnValue == (DWORD) NO_ERROR )
                     {
                        // Register ClAdmWiz.

                        // First, get the path to the cluster directory.

                        CString  csTemp;

                        csTemp =  CLUSTER_DIRECTORY;
   
                        TCHAR tszPathToClusterDir[_MAX_PATH];
   
                        if ( ExpandEnvironmentStrings( (LPCTSTR) csTemp,
                                                       tszPathToClusterDir, _MAX_PATH ) > 0L )
                        {
                           HRESULT  hResult;

                           // Attempt to initialize the COM library.

                           hResult = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

                           if ( (hResult == S_OK) ||                 // success
                                (hResult == S_FALSE) ||              // already initialized
                                (hResult == RPC_E_CHANGED_MODE) )    // previous initialization specified 
                                                                     // a different concurrency model
                           {
                              DWORD dwRCOrv;
   
                              // RegisterCOMObject returns ERROR_SUCCESS on success.
   
                              dwRCOrv = RegisterCOMObject( TEXT("ClAdmWiz.dll"), tszPathToClusterDir );
   
                              if ( dwRCOrv != (DWORD) ERROR_SUCCESS )
                              {
                                 ClRtlLogPrint( "CompleteUpgradingClusteringService failed to register ClAdmWiz.dll with error %1!d!.\n", dwRCOrv );
                              } // ClAdmWiz registered?
                              else
                              {
                                 // ERROR_SUCCESS and NO_ERROR are coincidentally the same.
   
                                 ClRtlLogPrint( "CompleteUpgradingClusteringService has registered ClAdmWiz.dll.\n" );
                              } // ClAdmWiz registered?
   
                              // RegisterCOMObject returns ERROR_SUCCESS on success.
   
                              dwRCOrv = RegisterCOMObject( TEXT("ClNetREx.dll"), tszPathToClusterDir );
   
                              if ( dwRCOrv != (DWORD) ERROR_SUCCESS )
                              {
                                 ClRtlLogPrint( "CompleteUpgradingClusteringService failed to register ClNetREx.dll with error %1!d!.\n", dwRCOrv );
                              } // ClNetREx registered?
                              else
                              {
                                 // ERROR_SUCCESS and NO_ERROR are coincidentally the same.
   
                                 ClRtlLogPrint( "CompleteUpgradingClusteringService has registered ClNetREx.dll.\n" );
                              } // ClNetREx registered?

                              // RegisterCOMObject returns ERROR_SUCCESS on success.
   
                              dwRCOrv = RegisterCOMObject( TEXT("CluAdMMC.dll"), tszPathToClusterDir );
   
                              if ( dwRCOrv != (DWORD) ERROR_SUCCESS )
                              {
                                 ClRtlLogPrint( "CompleteUpgradingClusteringService failed to register CluAdMMC.dll with error %1!d!.\n", dwRCOrv );
                              } // CluAdMMC registered?
                              else
                              {
                                 // ERROR_SUCCESS and NO_ERROR are coincidentally the same.
   
                                 ClRtlLogPrint( "CompleteUpgradingClusteringService has registered CluAdMMC.dll.\n" );
                              } // CluAdMMC registered?

                              // Close the COM library. As per MSDN, each successfull call
                              // to CoInitializeEx() must be balanced ba a call to CoUnitialize().

                              CoUninitialize();

                           } // COM library initialized?
                           else
                           {
                              // Could not inititlize the COM library.

                              ClRtlLogPrint( "CompleteUpgradingClusteringService could not initialize the COM library. Error %1!d!.\n", hResult );
                           } // COM library initialized?
                        } // path to cluster directory obtained?
                        else
                        {
                           // Couldn't expand the environment string.

                           dwReturnValue = GetLastError();
   
                           ClRtlLogPrint( "CompleteUpgradingClusteringService could not register ClAdmWiz.dll\n" );
                           ClRtlLogPrint( "because it could not locate the cluster directory. Error %1!d!.\n", dwReturnValue );
                        } // path to cluster directory obtained?
                     }

                     if ( dwReturnValue == (DWORD) NO_ERROR )
                     {
                        // Set the ClusterInstallationState reg value to "UPGRADED"

                        ClRtlSetClusterInstallState( eClusterInstallStateUpgraded );
                     }
                  } // did the default failure actions get set?
               } // did the connection objects get renamed?
            }  // Was the ImagePath set successfully?
         } // Were the Welcome UI registry operations performed successfully?
      }  // Were the UPGRADE registry operations performed successfully?
   }
   else
   {
      ClRtlLogPrint( "In CompleteUpgradingClusteringService since Cluster service "
                     "has never been installed there is nothing to do.\n" );

      dwReturnValue = (DWORD) NO_ERROR;
   }  // Has Cluster service previously been installed?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// CompleteStandAloneInstallationOfClusteringService
//
// Routine Description:
//    This function completes the process of installing Cluster service when
//    either Add/Remove Programs is running or sysocmgr.exe was launched from
//    a command prompt.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::CompleteStandAloneInstallationOfClusteringService( IN LPCTSTR ptszSubComponentId )
{
   DWORD dwReturnValue;
   DWORD_PTR dwResult;

   // Update the progress bar.

   m_SetupInitComponent.HelperRoutines.TickGauge( m_SetupInitComponent.HelperRoutines.OcManagerContext );

   // Update the "progress text"

   CString  csProgressText;

   csProgressText.LoadString( IDS_INSTALLING_CLUS_SERVICE );

   m_SetupInitComponent.HelperRoutines.SetProgressText( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                        (LPCTSTR) csProgressText );
   // A selection state transition has occured. Perform the base
   // registry operations.

   dwReturnValue = PerformRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                              ptszSubComponentId );


   // On a standalone installation, we need to send a WM_SETTINGCHANGE message to all top level windows
   // so that any changes we have made to the system environment variables take effect.
   // During fresh installation, this happens automatically since there is a reboot.
   // See Knowledge Base article Q104011.
   SendMessageTimeout( 
       HWND_BROADCAST,                      // handle to window
       WM_SETTINGCHANGE,                    // message
       0,                                   // wparam
       (LPARAM) _T("Environment"),          // lparam
       SMTO_ABORTIFHUNG | SMTO_NORMAL,      // send options
       100,                                 // time-out duration (ms). Note, each top level window can wait upto this time
       &dwResult                            // return value for synchronous call - we ignore this
       );

   ClRtlLogPrint( "The base call to PerformRegistryOperations returned 0x%1!x! to CompleteStandAloneInstallationOfClusteringService.\n",
                  dwReturnValue );

   // Were the base registry operations performed successfully?

   if ( dwReturnValue == (DWORD) NO_ERROR )
   {
      // Queue the registry operations to add "Configure Cluster service"
      // to the Welcome UI task list. As per Sharon Montgomery on 12/18/98 the
      // Server Solutions will use those same keys.

      CString  csSectionName;

      csSectionName = CLUSREG_KEYNAME_WELCOME_UI;

      dwReturnValue = PerformRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                                 csSectionName );

      ClRtlLogPrint( "The WelcomeUI call to PerformRegistryOperations returned 0x%1!x! to CompleteStandAloneInstallationOfClusteringService.\n",
                     dwReturnValue );

      if ( dwReturnValue == (DWORD) NO_ERROR )
      {
         ClRtlLogPrint( "In CompleteStandAloneInstallationOfClusteringService the registry operations were queued successfully.\n" );

         // Since this was a standalone installation launch the Cluster Configuration
         // program, cluscfg.exe.

         // First, build the command line used to launch cluscfg. The specific
         // command depends on whether this is an unattended operation. Regardless
         // of whether this is unattended, the first part of the command line is
         // the fully qualified path to cluscfg.

         BOOL  fReturnValue;

         TCHAR tszClusCfgCommandLine[MAX_PATH];

         fReturnValue = GetPathToClusCfg( tszClusCfgCommandLine );

         // Was the path to cluscfg.exe deduced?

         if ( fReturnValue == (BOOL) TRUE )
         {
            // Update the progress bar.

            m_SetupInitComponent.HelperRoutines.TickGauge( m_SetupInitComponent.HelperRoutines.OcManagerContext );

            // Update the "progress text"

            CString  csProgressText;

            csProgressText.LoadString( IDS_CONFIGURING_CLUS_SERVICE );

            m_SetupInitComponent.HelperRoutines.SetProgressText( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                 (LPCTSTR) csProgressText );

            // Is this an unattended operation?

            if ( (m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_BATCH) !=
                 (DWORDLONG) 0L )
            {
               // This is unattended.

               HINF  hAnswerFile;      // WARNING: NEVER close this handle because clusocm.dll
                                       //          did not open it.
      
               // Get a handle to the answer file. WARNING: NEVER close this handle because clusocm.dll
               // did not open it.
      
               hAnswerFile = m_SetupInitComponent.HelperRoutines.GetInfHandle( INFINDEX_UNATTENDED,
                                                                               m_SetupInitComponent.HelperRoutines.OcManagerContext );
      
               // Is the handle to the answer file OK?

               if ( (hAnswerFile != (HINF) NULL) && (hAnswerFile != (HINF) INVALID_HANDLE_VALUE) )
               {
                  // The handle to the answer file is legal.

                  // tszClusCfgCommandLine is the path to cluscfg.exe. Append the "-UNATTEND"
                  // command line option.

                  CString  csUnattendCommandLineOption;

                  csUnattendCommandLineOption = UNATTEND_COMMAND_LINE_OPTION;

                  _tcscat( tszClusCfgCommandLine, _T(" ") );
                  _tcscat( tszClusCfgCommandLine, csUnattendCommandLineOption );

                  // Append the path to the answer file.

                  _tcscat( tszClusCfgCommandLine, _T(" ") );
                  _tcscat( tszClusCfgCommandLine, m_SetupInitComponent.SetupData.UnattendFile );
               } // handle to answer file OK?
            } // unattended?

            // Launch cluscfg - tszClusCfgCommandLine contains the command, either
            //                  attended or unattended.

            STARTUPINFO StartupInfo;

            ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
            StartupInfo.cb = sizeof( StartupInfo );

            PROCESS_INFORMATION  ProcessInformation;

            fReturnValue = CreateProcess( (LPCTSTR) NULL,
                                          (LPTSTR) tszClusCfgCommandLine,
                                          (LPSECURITY_ATTRIBUTES) NULL,
                                          (LPSECURITY_ATTRIBUTES) NULL,
                                          (BOOL) FALSE,
                                          (DWORD) (CREATE_DEFAULT_ERROR_MODE | CREATE_UNICODE_ENVIRONMENT),
                                          (LPVOID) GetEnvironmentStrings(),
                                          (LPCTSTR) NULL,
                                          (LPSTARTUPINFO) &StartupInfo,
                                          (LPPROCESS_INFORMATION) &ProcessInformation );

            // Was the process created?

            if ( fReturnValue == (BOOL) TRUE )
            {
               // Wait for cluscfg.exe to complete. As per Pat Styles on 7/6/98,
               // an OCM Setup DLL MUST wait for any process it spawns to complete.

               DWORD dwWFSOrv;

               dwWFSOrv = WaitForSingleObject( ProcessInformation.hProcess,
                                               INFINITE );
            }
            else
            {
               DWORD dwErrorCode;

               dwErrorCode = GetLastError();

               if ( (m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_BATCH) ==
                    (DWORDLONG) 0L )
               {
                  CString  csMessage;

                  csMessage.Format( IDS_ERROR_SPAWNING_CLUSCFG, dwErrorCode );

                  AfxMessageBox( csMessage );
               }

               ClRtlLogPrint( "Error %1!d! occured attempting to spawn cluscfg.exe.\n", dwErrorCode );
            } // Was the process created?
         } // Path to cluscfg obtained?
      } // WelcomeUI registry operations succeeded?
   }  // Were the base registry operations performed successfully?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// CompleteInstallingClusteringService
//
// Routine Description:
//    This function performs much of the processing when OC_COMPLETE_INSTALLATION
//    has been received and a clean installation is being performed.
//
// Arguments:
//    ptszSubComponentId - points to a string that uniquely identifies a sub-
//                         component in the component's hiearchy.
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::CompleteInstallingClusteringService( IN LPCTSTR ptszSubComponentId )
{
   DWORD dwReturnValue;

   // Update the progress bar.

   if ( GetStepCount() != 0L )
   {
      // Update the progress meter.

      m_SetupInitComponent.HelperRoutines.TickGauge( m_SetupInitComponent.HelperRoutines.OcManagerContext );
   }

   // Update the "progress text"

   CString  csProgressText;

   csProgressText.LoadString( IDS_INSTALLING_CLUS_SERVICE );

   m_SetupInitComponent.HelperRoutines.SetProgressText( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                        (LPCTSTR) csProgressText );

   // Perform the base registry operations.

   dwReturnValue = PerformRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                              ptszSubComponentId );

   ClRtlLogPrint( "The base call to PerformRegistryOperations returned 0x%1!x! to CompleteInstallingClusteringService.\n",
                  dwReturnValue );

   // Were the base registry operations performed successfully?

   if ( dwReturnValue == (DWORD) NO_ERROR )
   {
      // Queue the registry operations to add "Configure Cluster service"
      // to the Welcome UI task list. As per Sharon Montgomery on 12/18/98, Server
      // Solutions will use those same keys.

      CString  csSectionName;

      csSectionName = CLUSREG_KEYNAME_WELCOME_UI;

      dwReturnValue = PerformRegistryOperations( m_SetupInitComponent.ComponentInfHandle,
                                                 csSectionName );

      ClRtlLogPrint( "The WelcomeUI call to PerformRegistryOperations returned 0x%1!x! to CompleteInstallingClusteringService.\n",
                     dwReturnValue );
   }  // Were the base registry operations performed successfully?

   // Were the Welcome UI registry operations performed successfully?

   if ( dwReturnValue == (DWORD) NO_ERROR )
   {
      ClRtlLogPrint( "In CompleteInstallingClusteringService for a clean install all registery operations were performed successfully.\n" );
   }
   else
   {
      ClRtlLogPrint( "In CompleteInstallingClusteringService for a clean install the registry operations were not performed successfully.\n" );
   }

   // For unattended setup this needs to write the WelcomeUI reg keys in a way that
   // will cause Configure Your Server to launch cluscfg.exe in unattended mode.

   // revisions to CompleteInstallingClusteringService may be appropriate prior to this code segment.

   // Were all registry operations performed correctly?

   if ( dwReturnValue == (DWORD) NO_ERROR )
   {
      LONG lReturnValue;   // used below for registry operations

      HKEY hKey;           // used below for registry operations

      // Is this an unattended installation?

      if ( (m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_BATCH) !=
           (DWORDLONG) 0L )
      {
         HINF  hAnswerFile;      // WARNING: NEVER close this handle because clusocm.dll
                                 //          did not open it.

         // Get a handle to the answer file. WARNING: NEVER close this handle because clusocm.dll
         // did not open it.

         hAnswerFile = m_SetupInitComponent.HelperRoutines.GetInfHandle( INFINDEX_UNATTENDED,
                                                                         m_SetupInitComponent.HelperRoutines.OcManagerContext );

         if ( (hAnswerFile != (HINF) NULL) && (hAnswerFile != (HINF) INVALID_HANDLE_VALUE) )
         {
            // Write the WelcomeUI registry entry to launch cluscfg in unattended mode.
            // Note that the registry operations performed when CLUSREG_KEYNAME_WELCOME_UI
            // was passed to PerformRegistryOperations() above included creation of
            // HKLM\Software\Microsoft\Windows NT\CurrentVersion\Setup\OCManager\ToDoList\Cluster\ConfigCommand.
            // All that is necessary is to create the ConfigArgs value with the
            // appropriate command line arguments to execute cluscfg.exe in unattended mode.

            HKEY hKey;

            DWORD dwType;

            // Attempt to open an existing key in the registry.

            lReturnValue = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                         _T( "Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList\\Cluster" ),
                                         (DWORD) 0,         // reserved
                                         KEY_SET_VALUE,
                                         &hKey );

            // Was the Cluster "to do list" registry key opened?

            if ( lReturnValue == (LONG) ERROR_SUCCESS )
            {
               // The key is open.

               TCHAR tszValue[MAX_PATH];

               _tcscpy( tszValue, UNATTEND_COMMAND_LINE_OPTION );

               // Append the path to the answer file.

               _tcscat( tszValue, _T(" ") );
               _tcscat( tszValue, m_SetupInitComponent.SetupData.UnattendFile );

               // Set the key.

               DWORD dwValueLength;

               dwValueLength = (DWORD) ((_tcslen( tszValue ) + 1) * sizeof( TCHAR ));

               lReturnValue = RegSetValueEx( hKey,
                                             _T( "ConfigArgs" ),
                                             (DWORD) 0L,                            // reserved
                                             (DWORD) REG_EXPAND_SZ,
                                             (CONST BYTE *) tszValue,
                                             dwValueLength );

                  // Was the key written successfully?

               if ( lReturnValue == (LONG) ERROR_SUCCESS )
               {
                  dwReturnValue = (DWORD) NO_ERROR;

                  ClRtlLogPrint( "CompleteInstallingClusteringService created the ConfigArgs reg key for unattended operation of cluscfg.\n" );
               }
               else
               {
                  dwReturnValue = GetLastError();

                  ClRtlLogPrint( "CompleteInstallingClusteringService failed to create the ConfigArgs reg key with error code %1!d!.\n",
                                 dwReturnValue );
               } // Was the reg key written successfully?

               // Close the registry key.

               RegCloseKey( hKey );           // do we care about the return value?
            }
            else
            {
               // The key could not be opened.

               DWORD dwErrorCode;

               dwErrorCode = GetLastError();

               ClRtlLogPrint( "In CompleteInstallingClusteringService RegOpenKeyEx failed with error code 0x%1!x!.\n",
                              dwErrorCode );
            } // Was the key opened?
         } // handle to answer file OK?
      } // Is this unattended?
      else
      {
         // This is NOT unattended, so make sure the ConfigArgs value is removed.
         // That will prevent any value left from a previous unattended install
         // which was never successfully configured from corrupting the behavior
         // of Configure Your Server or Add/Remove Programs.

         // Attempt to open an existing key in the registry.

         lReturnValue = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList\\Cluster"),
                                      (DWORD) 0,         // reserved
                                      KEY_READ,
                                      &hKey );

         // Was the Cluster "to do list" registry key opened?

         if ( lReturnValue == (long) ERROR_SUCCESS )
         {
            // Delete the values (which may not exist).

            RegDeleteValue( hKey, (LPCTSTR) TEXT("ConfigArgs") );
         } // if ToDoList opened
      } // if unattended?
   } // registry operations successfull?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// OnOcCleanup
//
// Routine Description:
//    This function processes the OC_CLEANUP messages by removing the "private"
//    subdirectory in the cluster directory if it is empty and the cluster directory
//    itself it it is empty.
//
// Arguments:
//    none
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    Any other value is a standard Win32 error code.
//
// Note:
//    The "private" subrirectory may exist in the cluster directory if the system
//    was upgraded from NT4.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::OnOcCleanup( void )
{
   ClRtlLogPrint( "Processing OC_CLEANUP.\n" );

   DWORD dwReturnValue;

   dwReturnValue = CleanupDirectories();

   ClRtlLogPrint( "\n\n\n\n" );

   // Close the log file.

   ClRtlCleanup();

   // Set the ClusterLog environment variable back to its' original state.

   char  szLogFileName[MAX_PATH];

   strcpy( szLogFileName, "ClusterLog=" );

   if ( *m_szOriginalLogFileName != (char) '\0' )
   {
      strcat( szLogFileName, m_szOriginalLogFileName );
   }

   _putenv( szLogFileName );

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// CleanupDirectories
//
// Routine Description:
//    This function removes the "private" subdirectory that may remain in the
//    cluster directory if the system has ever been upgraded from NT 4 if that
//    directory is empty. It will also remove the cluster directory itself if
//    it is empty.
//
// Arguments:
//    none
//
// Return Value:
//    (DWORD) NO_ERROR - indicates success
//    (DWORD) -1L - means that the cluster directory was not empty
//    Any other value is a standard Win32 error code.
//
// Note:
//    This function assumes that the path to the cluster directory is less than
//    MAX_PATH TCHARs long and that function SetupGetTargetPath expects the fifth
//    parameter to specify the number of TCHARS (not bytes) in the buffer.
//
//    No recovery is attempted if the call to SetupGetTargetPath fails.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::CleanupDirectories( void )
{
   DWORD dwReturnValue = (DWORD) NO_ERROR;

   BOOL  fReturnValue;

   DWORD dwRequiredSize;

   TCHAR tszPathToClusterDirectory[MAX_PATH];

   // First, get the path to the cluster directory.

   CString  csSectionName;

   csSectionName =  CLUSTER_FILES_INF_KEY;

   fReturnValue = SetupGetTargetPath( m_SetupInitComponent.ComponentInfHandle,
                                      (PINFCONTEXT) NULL,
                                      (PCTSTR) csSectionName,
                                      tszPathToClusterDirectory,
                                      (DWORD) MAX_PATH,
                                      (PDWORD) &dwRequiredSize );

   // Was the path to the cluster directory obtained?

   if ( fReturnValue == (BOOL) TRUE )
   {
      // Test for the presence of a subdirectory named "private".

      TCHAR tszPathToPrivateDirectory[MAX_PATH];

      // Append "\private" to the path to the cluster directory that was obtained above.

      // Note, I didn't put this string in the stringtable because it is
      // not localizable, and will never change.

      _tcscpy( tszPathToPrivateDirectory, tszPathToClusterDirectory );
      _tcscat( tszPathToPrivateDirectory, _T("\\private") );

      HANDLE            hFindHandle;
      WIN32_FIND_DATA   FindData;

      // Does a file or directory named "private" exist?

      hFindHandle = FindFirstFile( (LPCTSTR) tszPathToPrivateDirectory, &FindData );

      if ( hFindHandle != (HANDLE) INVALID_HANDLE_VALUE )
      {
         // A file named "private" exists in the cluster directory. Is it a directory?

         if ( (FindData.dwFileAttributes & (DWORD) FILE_ATTRIBUTE_DIRECTORY) != (DWORD) 0L )
         {
            // The "private" directory has been located. Determine whether it is empty.

            if ( IsDirectoryEmpty( tszPathToPrivateDirectory ) == (BOOL) TRUE )
            {
               // No file was found in the "private" directory. Remove the "private" directory.

               if ( RemoveDirectory( (LPCTSTR) tszPathToPrivateDirectory ) == (BOOL) TRUE )
               {
                  dwReturnValue = (DWORD) NO_ERROR;
               }
               else
               {
                  // Could not delete the "private" directory even though it was empty.

                  dwReturnValue = GetLastError();

                  ClRtlLogPrint( "CleanupDirectories was unable to remove %1!s!. The error code is %2!x!.\n",
                                 tszPathToPrivateDirectory, dwReturnValue );
               } // Was the "private" directory removed successfully?
            }
            else
            {
               ClRtlLogPrint( "CleanupDirectories did not attempt to remove %1!s! because it is not empty.\n",
                              tszPathToPrivateDirectory );

               // An error code of -1 means the "private" directory, and thus the
               // cluster directory was not empty.

               dwReturnValue = (DWORD) -1L;
            } // Was any file found in the "private" directory?
         }
         else
         {
            ClRtlLogPrint( "In CleanupDirectories the file named private is not a directory.\n");

            dwReturnValue = (DWORD) ERROR_FILE_NOT_FOUND;
         } // Is it a directory?

         // Close the search that located the "private" directory.

         FindClose( hFindHandle );
      }
      else
      {
         dwReturnValue = GetLastError();

         ClRtlLogPrint( "CleanupDirectories was unable to find any file named private in the cluster directory.\n");
         ClRtlLogPrint( "The error code is 0x%1!x!.\n", dwReturnValue );
      } // Does a file or directory named "private" exist?

      // Was the "private" directory absent or removed successfully?

      if ( (dwReturnValue == (DWORD) ERROR_FILE_NOT_FOUND) ||
           (dwReturnValue == (DWORD) NO_ERROR) )
      {
         // The "private" directory either did not exist or has been removed.
         // Now determine whether the cluster directory is empty and therefore should be removed.

         // This code segment assumes that the cluster directory, as specified
         // in tszPathToClusterDirectory exists.

         if ( IsDirectoryEmpty( tszPathToClusterDirectory ) == (BOOL) TRUE )
         {
            // The cluster directory is empty.

            if ( RemoveDirectory( tszPathToClusterDirectory ) == (BOOL) TRUE )
            {
               dwReturnValue = (DWORD) NO_ERROR;
            }
            else
            {
               // Could not delete the "cluster" directory even though it was empty.

               dwReturnValue = GetLastError();

               ClRtlLogPrint( "CleanupDirectories was unable to remove %1!s!. The error code is %2!x!.\n",
                              tszPathToClusterDirectory, dwReturnValue );
            } // Was the cluster directory removed?
         }
         else
         {
            // The cluster directory is not empty.

            ClRtlLogPrint( "CleanupDirectories did not attempt to remove %1!s! because it is not empty.\n",
                           tszPathToClusterDirectory );

            // An error code of -1 means the cluster directory was not empty.

            dwReturnValue = (DWORD) -1L;
         } // Is the cluster directory empty?
      } // Was the "private" directory absent or removed?
   }
   else
   {
      dwReturnValue = GetLastError();

      ClRtlLogPrint( "CleanupDirectories was unable to obtain the path to the cluster directory.\n");
      ClRtlLogPrint( "The error code is 0x%1!x!.\n", dwReturnValue );
   } // Was the path to the cluster directory obtained?

   return ( dwReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// IsDirectoryEmpty
//
// Routine Description:
//    This function determines whether a directory is empty.
//
// Arguments:
//    ptzDirectoryName - points to a string specifying the directory name.
//
// Return Value:
//    TRUE - indicates that the directory is empty
//    FALSE - indicates that the directory is not empty
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusocmApp::IsDirectoryEmpty( LPCTSTR ptszDirectoryName )
{
   BOOL              fDirectoryEmpty;

   HANDLE            hFindHandle;

   WIN32_FIND_DATA   FindData;

   TCHAR             tszFindPath[MAX_PATH];

   // Append the file specification to the path supplied.

   _tcscpy( tszFindPath, ptszDirectoryName );
   _tcscat( tszFindPath, _T("\\*") );

   hFindHandle = FindFirstFile( tszFindPath, &FindData );

   // Was any file found in the directory?

   if ( hFindHandle != (HANDLE) INVALID_HANDLE_VALUE )
   {
      // A file was found. It could be "." or "..".

      if ( (_tcscmp( FindData.cFileName, _T(".") ) == 0) ||
           (_tcscmp( FindData.cFileName, _T("..") ) == 0) )
      {
         // The file was either "." or "..". Keep trying.

         DWORD dwErrorCode;

         if ( FindNextFile( hFindHandle, &FindData ) == (BOOL) TRUE )
         {
            // A file was found. It could be "." or "..".

            if ( (_tcscmp( FindData.cFileName, _T(".") ) == 0) ||
                 (_tcscmp( FindData.cFileName, _T("..") ) == 0) )
            {
               // The file was either "." or "..". Keep trying.

               if ( FindNextFile( hFindHandle, &FindData ) == (BOOL) TRUE )
               {
                  // The file cannot possibly be either "." or "..".

                  fDirectoryEmpty = (BOOL) FALSE;
               }
               else
               {
                  dwErrorCode = GetLastError();

                  if ( dwErrorCode == (DWORD) ERROR_NO_MORE_FILES )
                  {
                     fDirectoryEmpty = (BOOL) TRUE;
                  }
                  else
                  {
                     fDirectoryEmpty = (BOOL) FALSE;
                  }
               }
            }
            else
            {
               // The private directory is not empty.

               fDirectoryEmpty = (BOOL) FALSE;
            }
         }
         else
         {
            dwErrorCode = GetLastError();

            if ( dwErrorCode == ERROR_NO_MORE_FILES )
            {
               fDirectoryEmpty = (BOOL) TRUE;
            }
            else
            {
               fDirectoryEmpty = (BOOL) FALSE;
            }
         }
      }
      else
      {
         // The directory is not empty.

         fDirectoryEmpty = (BOOL) FALSE;
      }

      // Close the search.

      FindClose( hFindHandle );
   }
   else
   {
      fDirectoryEmpty = (BOOL) TRUE;
   }

   return ( fDirectoryEmpty );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetPathToClusCfg
//
// Routine Description:
//    This function deduces the path to the Cluster service configuration
//    program, cluscfg.exe.
//
//    It assumes that if the Cluster service is registered with the Service
//    COntrol Manager then cluscfg.exe is located in the directory with clussvc.exe.
//    Otherwise it expands %windir%\cluster and declares that to be the path.
//
//    The name of the Cluster service configuration pogram is then appended to
//    the path.
//
// Arguments:
//    lptszPathToClusCfg - points to a string in which the fully qualified path to
//                         the Cluster service configuration program is to be placed.
//
// Return Value:
//    TRUE - indicates that lptszPathToClusCfg is valid
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusocmApp::GetPathToClusCfg( LPTSTR lptszPathToClusCfg )
{
   BOOL  fReturnValue;

   // If the Cluster service is registered assume that cluscfg is in
   // the same directory as clussvc.exe and get the path to cluscfg.exe
   // from the Service Control Mamager. If the Cluster service is not
   // registered, assume cluscfg.exe is in %windir%\cluster.

   if ( IsClusterServiceRegistered() == (BOOL) TRUE )
   {
      // Query the path to the Cluster Service executable from the Service Control Manager.

      CString  csClusterService;

      csClusterService = CLUSTER_SERVICE_NAME;

      fReturnValue = GetServiceBinaryPath( (LPWSTR) (LPCTSTR) csClusterService,
                                            lptszPathToClusCfg );
   }
   else
   {
      // Use the default location.

      CString  csClusterDirectory;

      csClusterDirectory =  CLUSTER_DIRECTORY;

      if ( ExpandEnvironmentStrings( (LPCTSTR) csClusterDirectory,
                                     lptszPathToClusCfg, MAX_PATH ) > 0L )
      {
         fReturnValue = (BOOL) TRUE;
      }
      else
      {
         // Could not expand the enviornment string. The default location for the
         // Cluster service could not be determined.

         fReturnValue = (BOOL) FALSE;
      }  // Was the default location for cluscfg.exe determined?
   }  // Where is cluscfg.exe?

   // Was the path to cluscfg.exe deduced?

   if ( fReturnValue == (BOOL) TRUE )
   {
      // tszPathToClusCfg is the path to cluscfg.exe. Append the program name.

      CString  csClusterConfigurationProgram;

      csClusterConfigurationProgram =  CLUSTER_CONFIGURATION_PGM;

      _tcscat( lptszPathToClusCfg, _T("\\") );
      _tcscat( lptszPathToClusCfg, csClusterConfigurationProgram );
   }
   else
   {
      // Set the target string empty.

      *lptszPathToClusCfg = _T( '\0' );
   }

   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// CalculateStepCount
//
// Routine Description:
//    This function calculates the "step count", i.e the number of non-file operations
//    to be performed when processing OC_COMPLETE_INSTALLATION.
//
// Arguments:
//    ptszSubComponentId
//
// Return Value:
//    The number of non-file operation (steps) to perform when processing
//    OC_COMPLETE_INSTALLATION
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::CalculateStepCount( LPCTSTR ptszSubComponentId )
{
   DWORD dwStepCount;

   // Is this UNATTENDED or ATTENDED?

   if ( (m_SetupInitComponent.SetupData.OperationFlags & (DWORDLONG) SETUPOP_BATCH) !=
        (DWORDLONG) 0L )
   {
      // This is UNATTENDED.

      if ( (m_SetupInitComponent.SetupData.OperationFlags &
           (DWORDLONG) SETUPOP_NTUPGRADE) != (DWORDLONG) 0L )
      {
         // This is UPGRADE. Cluscfg.exe will not be launched, so there is
         // one non-file operation to be performed, registry revisions.

         dwStepCount = 1L;
      }
      else
      {
         // This is a clean INSTALL. Cluscfg.exe may be launched.

         // Is there a [cluster] section in the answer file? BUGBUG

         //   so there
         // are two non-file operations to be performed, registry revisions
         // and execution of cluscfg.

         dwStepCount = 2L;
      } // unattended: upgrade or install?
   }
   else
   {
      // This is ATTENDED.

      if ( (m_SetupInitComponent.SetupData.OperationFlags &
           (DWORDLONG) SETUPOP_STANDALONE) != (DWORDLONG) 0L )
      {
         // This is STANDALONE. Is Cluster service selected?

         BOOL  fCurrentSelectionState;
         BOOL  fOriginalSelectionState;

         fCurrentSelectionState =
         m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                  (LPCTSTR) ptszSubComponentId,
                                                                  (UINT) OCSELSTATETYPE_CURRENT );
         fOriginalSelectionState =
         m_SetupInitComponent.HelperRoutines.QuerySelectionState( m_SetupInitComponent.HelperRoutines.OcManagerContext,
                                                                  ptszSubComponentId,
                                                                  (UINT) OCSELSTATETYPE_ORIGINAL );

         // Was there a selection state transition?

         if ( fCurrentSelectionState != fOriginalSelectionState )
         {
            if ( fCurrentSelectionState == (BOOL) TRUE )
            {
               // Currently selected - This is a clean install. There are two
               // non-file operations to be performed, registry revisions and
               // execution of cluscfg.exe.

               dwStepCount = 2L;
            }
            else
            {
               // Currently not selected - This is an uninstall. There is one
               // non-file operation to be performed, registry revisions.

               dwStepCount = 1L;
            } // currently selected?

            dwStepCount = 1L;
         }
         else
         {
            // There was no selection state transition, therefore there
            // are zero non-file operations to be performed.

            dwStepCount = 0L;
         } // selection state transition?

      }
      else
      {
         // This is GUI mode setup. The two operations that may be performed
         // during GUI mode setup are clean install and upgrade. In neither
         // case does cluscfg.exe get launched. Thus, there is one non-file
         // operation to be performed, registry revisions.

         dwStepCount = 1L;
      } // interactive: standalone or atttended?
   } // Is this UNATTENDED or ATTENDED?

   return ( dwStepCount );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetStepCount
//
// Routine Description:
//    This function sets the value of the m_dwStepCount member of the CClusocmApp object.
//
// Arguments:
//    dwStepCount - the value to which the m_dwStepCount member should be set.
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

void CClusocmApp::SetStepCount( DWORD dwStepCount )
{
   m_dwStepCount = dwStepCount;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetStepCount
//
// Routine Description:
//    This function returns the content of the m_dwStepCount member of the
//    CClusocmApp object.
//
// Arguments:
//    None
//
// Return Value:
//    The content of the m_dwStepCount member.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusocmApp::GetStepCount( void )
{
   return ( m_dwStepCount );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\answerfile.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    AnswerFile.h
//
// Abstract:
//    This is the class definition file for the CAnswerFileSection class and its'
//    contained classes.
//
// Author:
//    C. Brent Thomas - a-brentt
//
// Revision History:
//
//    24-Sep-1998    original
//
// Notes:
//
//    The classes defined in this file include:
//
//          CAnswerFileSection
//          CAnswerFileEntry
//          CParameterListEntry
//
//    I consciously chose not to use MFC because I expect cluster setup to
//    move away from MFC (probably to ATL) when it gets rewritten.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ANSWERFILE_H_
#define __ANSWERFILE_H_

// CParameterListEntry class
//
// An object of this class corresponds to a parameter on an entry in an answer file.
// It is implemented as a singly linked list of pointers to arrays of type TCHAR.

class CParameterListEntry
{
public:
   CParameterListEntry();  // constructor
   
   ~CParameterListEntry(); // destructor

// Data members

private:
   LPTSTR                  m_ptszParameter;    // points to the parameter string
   CParameterListEntry *   m_pNextParameter;   // points to the next parameter list entry

// Member functions

public:
   BOOL SetParameterString( LPTSTR ptszParameterString );

   BOOL SetNextParameterPointer( CParameterListEntry * pParameterListEntry );

   CParameterListEntry * GetParameterListPointer( void );

   LPTSTR GetParameterStringPointer( void );

private:

};


// CAnswerFileEntry class definition
//
// An object of this class corresponds to an entry in an answer file.

class CAnswerFileEntry
{
public:
   CAnswerFileEntry();     // constructor

   ~CAnswerFileEntry();    // destructor

// Data members

private:
   CAnswerFileEntry *      m_pNextEntry;           // points to the next CAnswerFileEntry object
                                                   // in the list.
   LPTSTR                  m_ptszKey;              // points to the key string for this
                                                   // answer file entry
   CParameterListEntry *   m_pParameterList;       // points to the parameter list for
                                                   // this answer file (may be empty)
   int                     m_xParameterCount;      // the number of parameters that may
                                                   // be present (on initialization) or
                                                   // the number of parameters found (after
                                                   // the parameter list has been read)

//  Member functions

public:
   BOOL                    SetKey( LPTSTR ptszKey );
   
   BOOL                    ReadParameters( PINFCONTEXT pAnswerFileContext );

   BOOL                    SetNextEntryPointer( CAnswerFileEntry * pEntry );

   CAnswerFileEntry *      GetNextEntryPointer( void );

   LPTSTR                  GetKeyPointer( void );

   CParameterListEntry *   GetParameterListPointer( void );

   int                     GetParameterCount( void );

private:
   BOOL                    SetParameterListPointer( CParameterListEntry * pParameterList );

   BOOL                    SetParameterCount( int xParameterCount );

}; // class CAnswerFileEntry


// CAnswerFileSection class definition
//
// An object of this class corresponds to a section in an answer file.

class CAnswerFileSection
{
public:
   CAnswerFileSection();   // constructor

   ~CAnswerFileSection();  // destructor


// Data members

private:
   CAnswerFileEntry *   m_pEntries;                // points to the entries in the answer file section

   int                  m_xCurrentRequiredParameterCount;

   int                  m_xCurrentOptionalParameterCount;

// Member functions

public:
   CAnswerFileEntry *   GetEntryPointer( void );

   BOOL ReadAnswerFileSection( HINF hAnswerFile,
                               LPTSTR ptszSection );
}; // class CAnswerFileSection 

#endif   // __ANSWERFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\cluscfgcommands.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    ClusCfgCommands
//
// Abstract:
//    This file contains functions for handling commands passed to cluscfg.exe
//    either via a command line option of via entries in an answer file.
//
// Author:
//    C. Brent Thomas   a-brentt
//
// Revision History:
//    30 Sep 1998       original
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <setupapi.h>
#include <tchar.h>

#include "ClusCfgCommands.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
// CClusCfgCommand
//
// Routine Description:
//    This is the default constructor for the CClusCfgConnand class.
//
// Arguments:
//    None
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CClusCfgCommand::CClusCfgCommand( void )
{
   m_pNextCommand = NULL;

   m_dwCommandStringId = 0L;
   
   m_ptszCommandString = NULL;
   
   m_dwCommandSubStringId = 0L;
   
   m_ptszCommandSubString = NULL;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// CClusCfgCommand
//
// Routine Description:
//    This constructor initializes the string Id data members of a CClusCfgCommand object.
//
// Arguments:
//    dwStringId - the string Id of the command string
//    dwSubStringId - the string Id of the minimum substring of a command
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CClusCfgCommand::CClusCfgCommand( DWORD dwStringId, DWORD dwSubStringId )
{
   m_pNextCommand = NULL;

   m_dwCommandStringId = dwStringId;
   
   m_ptszCommandString = NULL;
   
   m_dwCommandSubStringId = dwSubStringId;
   
   m_ptszCommandSubString = NULL;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// ~CClusCfgCommand
//
// Routine Description:
//    This is the destructor for the CClusCfgCommand class.
//
// Arguments:
//    None
//    
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

CClusCfgCommand::~CClusCfgCommand( void )
{
   if ( m_pNextCommand != NULL )
   {
      delete m_pNextCommand;
   }

   if ( m_ptszCommandString != NULL )
   {
      delete m_ptszCommandString;
   }

   if ( m_ptszCommandSubString != NULL )
   {
      delete m_ptszCommandSubString;
   }
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// InitializeCommandSubString
//
// Routine Description:
//    This function sets the m_dwCommandSubStringId and m_ptszCommandSubString members
//    of a CClusCfgCommand object.
//
// Arguments:
//    hInstance = the instance handle of the executable image
//    dwCommandSubStringId = the string Id of the command Sub string
//    
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::InitializeCommandSubString( HINSTANCE hInstance, DWORD dwCommandSubStringId )
{
   BOOL  fReturnValue;
   
   // Assume that no valid command will be longer than the maximum length of an answer file entry.
   
   TCHAR tszString[MAX_INF_STRING_LENGTH];
   
   // Is the command string Id meaningfull?
   
   if ( dwCommandSubStringId != 0L )
   {
      // Set the command string Id.

      SetCommandSubStringId( dwCommandSubStringId );
      
      // Read the command string from the STRINGTABLE.

      if ( LoadString( hInstance,
                       m_dwCommandSubStringId,
                       tszString,
                       MAX_INF_STRING_LENGTH ) > 0 )
      {
         // tszString is the command string.
         
         // Allocate memory for the string and save its' address.

         SetCommandSubStringPointer( new TCHAR[_tcslen( tszString ) +1] );

         // Store the command string.

         _tcscpy( GetCommandSubStringPointer(), tszString );

         fReturnValue = TRUE;
      }
      else
      {
         // Set the command string to empty.
         
         if ( GetCommandSubStringPointer() != NULL )
         {
            delete GetCommandSubStringPointer();
         }

         SetCommandSubStringPointer( NULL );

         fReturnValue = FALSE;
      } // string loaded from STRINGTABLE?
   }
   else
   {
      // Set the command string to empty.
      
      if ( GetCommandSubStringPointer() != NULL )
      {
         delete GetCommandSubStringPointer();
      }

      SetCommandSubStringPointer( NULL );

      fReturnValue = FALSE;
   } // String Id meaningfull?
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// InitializeCommandSubString
//
// Routine Description:
//    This function sets the m_ptszCommandSubString member of a CClusCfgCommand object
//    based on the contents of the m_dwCommandSubStringId member.
//
// Arguments:
//    hInstance = the instance handle of the executable image
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::InitializeCommandSubString( HINSTANCE hInstance )
{
   BOOL  fReturnValue;

   // Assume that no valid command will be longer than the maximum length of an answer file entry.
   
   TCHAR tszString[MAX_INF_STRING_LENGTH];
   
   // Is the command string Id meaningfull?
   
   if ( GetCommandSubStringId() != 0L )
   {
      // Read the command string from the STRINGTABLE.

      if ( LoadString( hInstance,
                       m_dwCommandSubStringId,
                       tszString,
                       MAX_INF_STRING_LENGTH ) > 0 )
      {
         // tszString is the command string.
         
         // Allocate memory for the string and save its' address.

         SetCommandSubStringPointer( new TCHAR[_tcslen(tszString) + 1] );

         // Store the command string.

         _tcscpy( GetCommandSubStringPointer(), tszString );

         fReturnValue = TRUE;
      }
      else
      {
         // Set the command string to empty.
         
         if ( GetCommandSubStringPointer() != NULL )
         {
            delete GetCommandSubStringPointer();
         }

         SetCommandSubStringPointer( NULL );

         fReturnValue = FALSE;
      } // string loaded from STRINGTABLE?
   }
   else
   {
      // Set the command string to empty.
      
      if ( GetCommandSubStringPointer() != NULL )
      {
         delete GetCommandSubStringPointer();
      }

      SetCommandSubStringPointer( NULL );

      fReturnValue = FALSE;
   } // String Id meaningfull?
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// InitializeCommandString
//
// Routine Description:
//    This function sets the m_dwCommandStringId and m_ptszCommandString members
//    of a CClusCfgCommand object.
//
// Arguments:
//    hInstance = the instance handle of the executable image
//    dwCommandStringId = the string Id of the command string
//    
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::InitializeCommandString( HINSTANCE hInstance, DWORD dwCommandStringId )
{
   BOOL  fReturnValue;
   
   // Assume that no valid command will be longer than the maximum length of an answer file entry.
   
   TCHAR tszString[MAX_INF_STRING_LENGTH];
   
   // Is the command string Id meaningfull?
   
   if ( dwCommandStringId != 0L )
   {
      // Set the command string Id.

      SetCommandStringId( dwCommandStringId );
      
      // Read the command string from the STRINGTABLE.

      if ( LoadString( hInstance,
                       m_dwCommandStringId,
                       tszString,
                       MAX_INF_STRING_LENGTH ) > 0 )
      {
         // tszString is the command string.
         
         // Allocate memory for the string and save its' address.

         SetCommandStringPointer( new TCHAR[_tcslen(tszString) + 1] );

         // Store the command string.

         _tcscpy( GetCommandStringPointer(), tszString );

         fReturnValue = TRUE;
      }
      else
      {
         // Set the command string to empty.
         
         if ( GetCommandStringPointer() != NULL )
         {
            delete GetCommandStringPointer();
         }

         SetCommandStringPointer( NULL );

         fReturnValue = FALSE;
      } // string loaded from STRINGTABLE?
   }
   else
   {
      // Set the command string to empty.
      
      if ( GetCommandStringPointer() != NULL )
      {
         delete GetCommandStringPointer();
      }

      SetCommandStringPointer( NULL );

      fReturnValue = FALSE;
   } // String Id meaningfull?
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// InitializeCommandString
//
// Routine Description:
//    This function sets the m_ptszCommandString member of a CClusCfgCommand object
//    based on the contents of the m_dwCommandStringId member.
//
// Arguments:
//    hInstance = the instance handle of the executable image
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::InitializeCommandString( HINSTANCE hInstance )
{
   BOOL  fReturnValue;

   // Assume that no valid command will be longer than the maximum length of an answer file entry.
   
   TCHAR tszString[MAX_INF_STRING_LENGTH];
   
   // Is the command string Id meaningfull?
   
   if ( GetCommandStringId() != 0L )
   {
      // Read the command string from the STRINGTABLE.

      if ( LoadString( hInstance,
                       m_dwCommandStringId,
                       tszString,
                       MAX_INF_STRING_LENGTH ) > 0 )
      {
         // tszString is the command string.
         
         // Allocate memory for the string and save its' address.

         SetCommandStringPointer( new TCHAR[_tcslen(tszString) + 1] );

         // Store the command string.

         _tcscpy( GetCommandStringPointer(), tszString );

         fReturnValue = TRUE;
      }
      else
      {
         // Set the command string to empty.
         
         if ( GetCommandStringPointer() != NULL )
         {
            delete GetCommandStringPointer();
         }

         SetCommandStringPointer( NULL );

         fReturnValue = FALSE;
      } // string loaded from STRINGTABLE?
   }
   else
   {
      // Set the command string to empty.
      
      if ( GetCommandStringPointer() != NULL )
      {
         delete GetCommandStringPointer();
      }

      SetCommandStringPointer( NULL );

      fReturnValue = FALSE;
   } // String Id meaningfull?
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetNextCommandPointer
//
// Routine Description:
//    This function sets the m_pNextCommand member of a CClusCfgCommand object.
//
// Arguments:
//    pNextCommand - points to a CClusCfgCommand object
//
// Return Value:
//    TRUE - indicates success
//    FALSE - indicates that an error occured
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::SetNextCommandPointer( CClusCfgCommand * pNextCommand )
{
   BOOL fReturnValue;
   
   m_pNextCommand = pNextCommand;
   
   fReturnValue = TRUE;
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetNextCommandPointer
//
// Routine Description:
//    This function returns the m_pNextCommand member of a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    The contents of the m_pNextCommand member.
//
//--
/////////////////////////////////////////////////////////////////////////////

CClusCfgCommand * CClusCfgCommand::GetNextCommandPointer( void )
{
   return ( m_pNextCommand );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// BuildClusCfgCommandList
//
// Routine Description:
//    This function builds a singly linked list of CClusCfgCommand objects
//    and initializes the elements of the list based on the entries in a
//    table of CLUSCFG_COMMAND_IDS structures.
//
// Arguments:
//    hInstance - the instance handle of the executable
//    pClusCfgCommandIds - points to a table of CLUSCFG_COMMAND_IDS structures.
//
// Return Value:
//    A pointer to the head of a singly linked list of CClusCfgCommand objects.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::BuildClusCfgCommandList( HINSTANCE hInstance,
                                               CLUSCFG_COMMAND_IDS * pClusCfgCommandIds )
{
   BOOL  fReturnValue;

   // Is the pointer to the table of string resource IDs meaningfull?
   
   if ( pClusCfgCommandIds != NULL )
   {
      // Is the table non-empty?
      
      if ( (pClusCfgCommandIds->dwCommandStringId != 0L) &&
           (pClusCfgCommandIds->dwCommandSubStringId != 0L) )
      {
         // Initialize the first CClusCfgCommand object.
         
         if ( (InitializeCommandString( hInstance, pClusCfgCommandIds->dwCommandStringId ) == TRUE) &&
              (InitializeCommandSubString( hInstance, pClusCfgCommandIds->dwCommandSubStringId ) == TRUE) )
         {
            // Initialize the parameter counts.
            
            SetNumRequiredParameters( pClusCfgCommandIds->xNumRequiredParameters );
            
            SetNumOptionalParameters( pClusCfgCommandIds->xNumOptionalParameters );

            // Point to the next element in the table.
            
            pClusCfgCommandIds++;
         
            // Create and initialize the rest of the list.

            CClusCfgCommand * pClusCfgCommand;

            pClusCfgCommand = this;

            BOOL  fError = FALSE;

            while ( (pClusCfgCommandIds->dwCommandStringId != 0L) &&
                    (pClusCfgCommandIds->dwCommandSubStringId != 0L) &&
                    (fError == FALSE) )
            {
               // Create an object.
               
               pClusCfgCommand->SetNextCommandPointer( new CClusCfgCommand( pClusCfgCommandIds->dwCommandStringId,
                                                                            pClusCfgCommandIds->dwCommandSubStringId ) );

               // Adjust the pointer to the new command object.
               
               pClusCfgCommand = pClusCfgCommand->GetNextCommandPointer();

               // Initialize it.
               
               if ( (pClusCfgCommand != NULL ) && 
                    (pClusCfgCommand->InitializeCommandString( hInstance ) == TRUE) &&
                    (pClusCfgCommand->InitializeCommandSubString( hInstance ) == TRUE) )
               {
                  // Initialize the parameter counts.
                  
                  pClusCfgCommand->SetNumRequiredParameters( pClusCfgCommandIds->xNumRequiredParameters );
                  
                  pClusCfgCommand->SetNumOptionalParameters( pClusCfgCommandIds->xNumOptionalParameters );

                  // Point to the next entry in the table.
                  
                  pClusCfgCommandIds++;
               }
               else
               {
                  // Could not initialize the object. Terminate the loop.
                  
                  fError = TRUE;
               } // Current object initialized?
            } // end of "while" loop

            // Was the list built and initialized successfully?
            
            if ( fError == FALSE )
            {
               fReturnValue = TRUE;
            }
            else
            {
               // An error occured. Delete the list.
               
               delete GetNextCommandPointer();
               
               SetNextCommandPointer( NULL );

               fReturnValue = FALSE;
            }
         }
         else
         {
            // The first CClusCfgCommand object could not be initialized.
            
            delete GetNextCommandPointer();
            
            SetNextCommandPointer( NULL );

            fReturnValue = FALSE;
         } // First string initialized succesfully?
      }
      else
      {
         // The table of string resource Ids is empty.
         
         fReturnValue = FALSE;
      } // Is the table empty
   }
   else
   {
      // The table of string resource Ids does not exist.
      
         fReturnValue = FALSE;
   } // table of string ids meaningfull?
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetCommandString
//
// Routine Description:
//    This function returns the contents of the m_ptszCommandString member of
//    a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    A pointer to a string that represents a command that can be passed to
//    ClusCfg.exe.
//
//--
/////////////////////////////////////////////////////////////////////////////

LPTSTR CClusCfgCommand::GetCommandString( void )
{
   return ( m_ptszCommandString );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetCommandSubString
//
// Routine Description:
//    This function returns the contents of the m_ptszCommandSubString member of
//    a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    A pointer to a string that represents the smallest substring that can be
//    recognized as a command that can be passed to ClusCfg.exe.
//
//--
/////////////////////////////////////////////////////////////////////////////

LPTSTR CClusCfgCommand::GetCommandSubString( void )
{
   return ( m_ptszCommandSubString );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// RecognizeCommandToken
//
// Routine Description:
//    This routine attempts to recognize a token as a command that may be
//    passed to cluscfg.exe.
//
// Arguments:
//    ptszToken - points to the token to be recognized
//    pClusCfgCommandList - points to the singly linked list of CClusCfgCommand
//                          objects that describe the set of valid commands that
//                          may be passed to cluscfg.exe
//
// Return Value:
//    TRUE - indicates that the token was recognized as a command
//    FALSE - indicates that the token was not recognized as a command
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::RecognizeCommandToken( LPCTSTR ptszToken,
                                             CClusCfgCommand * pClusCfgCommandList )
{
   BOOL fReturnValue = FALSE;

   // Are the parameters meaningfull?
   
   if ( (ptszToken != NULL) &&
        (*ptszToken != TEXT('\0')) &&
        (pClusCfgCommandList != NULL) )
   {
      BOOL  fTokenRecognized = FALSE;
      
      CClusCfgCommand * pTempCommand;
      
      // Starting at the head of the list compare the token to the command strings
      // and command sub-strings.
      
      pTempCommand = pClusCfgCommandList;

      // The token will be "recognized" if it is a sub-string of the "command string"
      // and the command sub-string is a sub-string of the token. This must be a case
      // insensitive comparison.
      
      LPTSTR   ptszUpperCaseTokenCopy;

      // Allocate memory for an upper case copy of the token.
      
      ptszUpperCaseTokenCopy = new TCHAR[_tcslen( ptszToken ) + 1];
            
      _tcscpy( ptszUpperCaseTokenCopy, ptszToken );

      // Convert it to upper case.
      
      _tcsupr( ptszUpperCaseTokenCopy );
      
      // Starting at the head of the list compare the token to the command strings.

      do
      {
         // Allocate memory for an upper case copy of the command string.
         
         LPTSTR   ptszUpperCaseCommandStringCopy;

         ptszUpperCaseCommandStringCopy = new TCHAR[_tcslen( pTempCommand->GetCommandString() ) +1];
            
         _tcscpy( ptszUpperCaseCommandStringCopy, pTempCommand->GetCommandString() );

         // Convert it to upper case.
         
         _tcsupr( ptszUpperCaseCommandStringCopy );
      
         // Is the token a sub-string of the command string?
         
         if ( _tcsstr( ptszUpperCaseCommandStringCopy, ptszUpperCaseTokenCopy ) == ptszUpperCaseCommandStringCopy )
         {
            // The token is a sub-string of the command string. Now determine whether
            // the command sub-string is a sub-string of the token.

            // Allocate memory for a upper case copy of the command sub-string.
         
            LPTSTR   ptszUpperCaseCommandSubStringCopy;

            ptszUpperCaseCommandSubStringCopy = new TCHAR[_tcslen( pTempCommand->GetCommandSubString() ) +1];
               
            _tcscpy( ptszUpperCaseCommandSubStringCopy, pTempCommand->GetCommandSubString() );

            // Convert it to upper case.
            
            _tcsupr( ptszUpperCaseCommandSubStringCopy );
      
            // Is the command sub-string a sub-string of the token?
            
            if ( _tcsstr( ptszUpperCaseTokenCopy, ptszUpperCaseCommandSubStringCopy ) == ptszUpperCaseTokenCopy )
            {
               LPTSTR string;

               // The token is recognized. Make a copy of the all the contents
               // so we don't try to free the same chunk of memory
               // twice. Technically, we should check to see memory is already
               // allocated and free it.

               SetCommandStringId( pTempCommand->GetCommandStringId() );

               string = pTempCommand->GetCommandString();
               if ( string != NULL ) {

                   // Allocate space for the copy

                   SetCommandStringPointer( new TCHAR[_tcslen( string ) +1] );

                   // Store the command string.

                   _tcscpy( GetCommandStringPointer(), string );
               }

               SetCommandSubStringId( pTempCommand->GetCommandSubStringId() );

               string = pTempCommand->GetCommandSubString();
               if ( string != NULL ) {

                   // Allocate space for the copy

                   SetCommandSubStringPointer( new TCHAR[_tcslen( string ) +1] );

                   // Store the command string.

                   _tcscpy( GetCommandSubStringPointer(), string );
               }

               SetNumRequiredParameters( pTempCommand->GetNumRequiredParameters() );

               SetNumOptionalParameters( pTempCommand->GetNumOptionalParameters() );

               SetNextCommandPointer( NULL );
               
               fTokenRecognized = TRUE;

               fReturnValue = TRUE;
            }
            else
            {
               // Test the next command.
               
               pTempCommand = pTempCommand->GetNextCommandPointer();
            }
            
            // Free the upper case copy of the command sub-string.
            
            delete ptszUpperCaseCommandSubStringCopy;
         }
         else
         {
            // Test the next command.
            
            pTempCommand = pTempCommand->GetNextCommandPointer();
         } // Is the token a sub-string of the command string?

         // Free the upper case copy of the command string.
         
         delete ptszUpperCaseCommandStringCopy;

      } while ( (pTempCommand != NULL) &&
                (fTokenRecognized == FALSE)  );

      // Free the memory for the upper case copy of the token.
      
      delete ptszUpperCaseTokenCopy;
   }
   else
   {
      // At least one parameter was invalid.
      
      fReturnValue = FALSE;
   } // parameters meaningfull?
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetNumRequiredParameters
//
// Routine Description:
//    This function sets the m_xNumRequiredParameters member of a CClusCfgCommand
//    object.
//
// Arguments:
//    xNumRequiredParameters - the number of parameters required by the command
//                             which is described by the CClusCfgCommand object.
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

void CClusCfgCommand::SetNumRequiredParameters( int xNumRequiredParameters )
{
   m_xNumRequiredParameters = xNumRequiredParameters;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetNumRequiredParameters
//
// Routine Description:
//    This function returns the contents of the m_xNumRequiredParameters
//    member of a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    the number of parameters required by the command which is described by the
//    CClusCfgCommand object.
//
//--
/////////////////////////////////////////////////////////////////////////////

int CClusCfgCommand::GetNumRequiredParameters( void )
{
   return ( m_xNumRequiredParameters );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetNumOptionalParameters
//
// Routine Description:
//    This function sets the m_xNumOptionalParameters member of a CClusCfgCommand
//    object.
//
// Arguments:
//    xNumOptionalParameters - the number of parameters accepted by the command
//                             which is described by the CClusCfgCommand object.
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

void CClusCfgCommand::SetNumOptionalParameters( int xNumOptionalParameters )
{
   m_xNumOptionalParameters = xNumOptionalParameters;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetNumOptionalParameters
//
// Routine Description:
//    This function returns the contents of the m_xNumOptionalParameters
//    member of a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    the number of parameters accepted by the command which is described by the
//    CClusCfgCommand object.
//
//--
/////////////////////////////////////////////////////////////////////////////

int CClusCfgCommand::GetNumOptionalParameters( void )
{
   return ( m_xNumOptionalParameters );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// Reset
//
// Routine Description:
//    This function sets all datamembers of a CClusCfgCommand object to zero.
//
// Arguments:
//    None
//
// Return Value:
//    None
//
//--
/////////////////////////////////////////////////////////////////////////////

void CClusCfgCommand::Reset( void )
{
   SetNextCommandPointer( NULL );

   SetCommandStringId( 0L );
   
   SetCommandStringPointer( NULL );
   
   SetCommandSubStringId( 0L );
   
   SetCommandSubStringPointer( NULL );

   SetNumRequiredParameters( 0 );
   
   SetNumOptionalParameters( 0 );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetCommandStringId
//
// Routine Description:
//    This function returns the m_dwCommandStringId member of a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    A DWORD indicating the string resource ID of the command string.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusCfgCommand::GetCommandStringId( void )
{
   return ( m_dwCommandStringId );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetCommandStringId
//
// Routine Description:
//    This function sets the m_dwCommandStringId member of a CClusCfgCommand object.
//
// Arguments:
//    dwCommandStringId - the string resource ID of the command string.
//
// Return Value:
//    TRUE - indicates success
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::SetCommandStringId( DWORD dwCommandStringId )
{
   BOOL  fReturnValue = TRUE;

   m_dwCommandStringId = dwCommandStringId;
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetCommandSubStringId
//
// Routine Description:
//    This function returns the m_dwCommandSubStringId member of a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    A DWORD indicating the string resource ID of the command sub-string.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD CClusCfgCommand::GetCommandSubStringId( void )
{
   return ( m_dwCommandSubStringId );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetCommandSubStringId
//
// Routine Description:
//    This function sets the m_dwCommandSubStringId member of a CClusCfgCommand object.
//
// Arguments:
//    dwCommandSubStringId - the string resource ID of the command string.
//
// Return Value:
//    TRUE - indicates success
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::SetCommandSubStringId( DWORD dwCommandSubStringId )
{
   BOOL  fReturnValue = TRUE;

   m_dwCommandSubStringId = dwCommandSubStringId;
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetCommandStringPointer
//
// Routine Description:
//    This function sets the m_ptszCommandString member of a CClusCfgCommand object.
//
// Arguments:
//    pAddress - the value to which the command string pointer should be set.
//
// Return Value:
//    TRUE - indicates success
//
// Note:
//    IT IS THE CALLER'S RESPONSIBILITY TO AVOID MEMORY LEAKS WHEN USING THIS FUNCTION!
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::SetCommandStringPointer( LPTSTR pAddress )
{
   BOOL  fReturnValue = TRUE;
   
   m_ptszCommandString = pAddress;
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// SetCommandSubStringPointer
//
// Routine Description:
//    This function sets the m_ptszCommandSubString member of a CClusCfgCommand object.
//
// Arguments:
//    pAddress - the value to which the command sub-string pointer should be set.
//
// Return Value:
//    TRUE - indicates success
//
// Note:
//    IT IS THE CALLER'S RESPONSIBILITY TO AVOID MEMORY LEAKS WHEN USING THIS FUNCTION!
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL CClusCfgCommand::SetCommandSubStringPointer( LPTSTR pAddress )
{
   BOOL  fReturnValue = TRUE;
   
   m_ptszCommandSubString = pAddress;
   
   return ( fReturnValue );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetCommandSubStringPointer
//
// Routine Description:
//    This function returns the m_ptszCommandSubString member of a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    The contents of the m_ptszCommandSubString member
//
//--
/////////////////////////////////////////////////////////////////////////////

LPTSTR CClusCfgCommand::GetCommandSubStringPointer( void )
{
   return ( m_ptszCommandSubString );
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetCommandStringPointer
//
// Routine Description:
//    This function returns the m_ptszCommandString member of a CClusCfgCommand object.
//
// Arguments:
//    None
//
// Return Value:
//    The contents of the m_ptszCommandString member
//
//--
/////////////////////////////////////////////////////////////////////////////

LPTSTR CClusCfgCommand::GetCommandStringPointer( void )
{
   return ( m_ptszCommandString );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\isterminalservicesinstalled.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Module Name: 
//    IsTerminalServicesInstalled.cpp
//
// Abstract:
//    This module includes the functions necessary to determine whether 
//    Terminal Serivces is installed.
//
// Author:
//    C. Brent Thomas (a-brentt)
//
// Revision History:
//    03 Feb 1998 - original
//
// Notes:
//    Clustering service and Terminal Services are mutually exclusive due to
//    a Product management decision regarding the lack of testing resources.
//    Sooner or later that restriction will be lifted.
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winbase.h>


/////////////////////////////////////////////////////////////////////////////
//++
//
// IsTerminalServicesInstalled
//
// Routine Description:
//    This function determines whether Terminal Services is installed.
//
// Arguments:
//    None
//
// Return Value:
//    TRUE - indicates that Terminal Services is installed.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL IsTerminalServicesInstalled( void )
{
   BOOL              fReturnValue;

   OSVERSIONINFOEX   osiv;

   ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );

   osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

   osiv.wSuiteMask = VER_SUITE_TERMINAL;

   DWORDLONG   dwlConditionMask;

   dwlConditionMask = (DWORDLONG) 0L;

   VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

   fReturnValue = VerifyVersionInfo( &osiv,
                                     VER_SUITENAME,
                                     dwlConditionMask );
   
   return ( fReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\cluscfgcommands.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    ClusCfgCommands.h
//
// Abstract:
//    This is the class definition file for the CClusCfgCommand and
//    associated classes.
//
// Author:
//    C. Brent Thomas
//
// Revision History:
//    30 Sep 1998    original
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSCFGCOMMANDS_H_
#define __CLUSCFGCOMMANDS_H_

// The members of the _CLUSCFG_COMMAND_IDS structure are the string IDs of
// two string resources. Member dwCommandStringId identifies a string resource
// that specifies the full text of a command that may be supplied to cluscfg.exe,
// either via a command line option or an entry in an answer file. Member
// dwSubStringId identifies a string resource that specifies the minimum substring
// that may be recognized as that command.

typedef struct _CLUSCFG_COMMAND_IDS
{
   DWORD    dwCommandStringId;      // string Id of the full command
   DWORD    dwCommandSubStringId;   // string Id of the minimum substring
   int      xNumRequiredParameters; // the number of parameters required by this command
   int      xNumOptionalParameters; // the number of optional parameters accepted by this command
} CLUSCFG_COMMAND_IDS;

// Objects of the CClusCfgCommand class are used to build a list of all of the
// legal commands that can be passed to ClusCfg.exe, either via a command line
// option or via entries in an answer file. The list is used to recognize the
// command keywords when parsing a command line or answer file entries.

class CClusCfgCommand
{
public:
   CClusCfgCommand( void );         // default constructor

   CClusCfgCommand( DWORD dwStringId, DWORD dwSubStringId );
   
   ~CClusCfgCommand( void );        // destructor

// Data members

private:
   CClusCfgCommand *    m_pNextCommand;
  
   DWORD                m_dwCommandStringId;
  
   LPTSTR               m_ptszCommandString;
  
   DWORD                m_dwCommandSubStringId;
  
   LPTSTR               m_ptszCommandSubString;

   int                  m_xNumRequiredParameters;
   
   int                  m_xNumOptionalParameters;

  
// Member functions

public:
   BOOL                 BuildClusCfgCommandList( HINSTANCE hInstance,
                                                 CLUSCFG_COMMAND_IDS * pClusCfgCommandIds );

   BOOL                 RecognizeCommandToken( LPCTSTR ptszToken,
                                               CClusCfgCommand * pClusCfgCommandList );

   int                  GetNumRequiredParameters( void );

   int                  GetNumOptionalParameters( void );

   void                 Reset( void );

   DWORD                GetCommandStringId( void );

   DWORD                GetCommandSubStringId( void );

   BOOL                 SetCommandStringPointer( LPTSTR pAddress );

   BOOL                 SetCommandSubStringPointer( LPTSTR pAddress );

private:
   BOOL                 InitializeCommandString( HINSTANCE hInstance, DWORD dwStringId );

   BOOL                 InitializeCommandString( HINSTANCE hInstance );

   BOOL                 InitializeCommandSubString( HINSTANCE hInstance, DWORD dwSubStringId );

   BOOL                 InitializeCommandSubString( HINSTANCE hInstance );

   LPTSTR               GetCommandString( void );
   
   LPTSTR               GetCommandSubString( void );

   BOOL                 SetNextCommandPointer( CClusCfgCommand * pNextCommand );

   CClusCfgCommand *    GetNextCommandPointer( void );

   void                 SetNumRequiredParameters( int xNumRequiredParameters );

   void                 SetNumOptionalParameters( int xNumOptionalParameters );

   BOOL                 SetCommandStringId( DWORD dwCommandStringId );

   BOOL                 SetCommandSubStringId( DWORD dwCommandStringId );

   LPTSTR               GetCommandStringPointer( void );

   LPTSTR               GetCommandSubStringPointer( void );
};
#endif // __CLUSCFGCOMMANDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\isclusterserviceregistered.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    IsClusterServiceRegistered.cpp
//
// Abstract:
//    This functions queries the Service Control Manager to determine whether the
//    Cluster Service, clussvc.exe, is registered.
//
// Author:
//    C. Brent Thomas (a-brentt)
//
// Revision History:
//    4 Aug 1998    original
//
// Notes:
//    If the Cluster Service is registered with the Service Control Manager that
//    implies that Clustering Service has beeninstalled.
//
/////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winerror.h>
#include <tchar.h>


/////////////////////////////////////////////////////////////////////////////
//++
//
// IsClusterServiceRegistered
//
// Routine Description:
//    This function determines whether the Cluster Service has beem registered
//    with the Service Control Manager.
//
// Arguments:
//    None
//
// Return Value:
//    TRUE - indicates that the Cluster Service has been registered with the
//           Service Control Manager.
//    FALSE - indicates that the Cluster Service has not been registered with
//            the Service Control Manager.
//
// Note:
//    If the Cluster Service has been registered with the Service Control Manager
//    that implies that Clustering Services has previously been installed.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL IsClusterServiceRegistered( void )
{
   BOOL      fReturnValue;

   SC_HANDLE hscServiceMgr;
   SC_HANDLE hscService;

   // Connect to the Service Control Manager and open the specified service
   // control manager database. 

   hscServiceMgr = OpenSCManager( NULL, NULL, GENERIC_READ | GENERIC_WRITE );

   // Was the service control manager database opened successfully?
   
   if ( hscServiceMgr != NULL )
   {
      // The service control manager database is open.
      // Open a handle to the Cluster Service.
      
      WCHAR wszServiceName[_MAX_PATH];

      wcscpy( wszServiceName, TEXT("clussvc") );

      hscService = OpenService( hscServiceMgr,
                                wszServiceName,
                                GENERIC_READ );

      // Was the handle to the service opened?

      if ( hscService != NULL )
      {
         // A valid handle to the Cluster Service was obtained. That implies that
         // Clustering Services has been installed.

         fReturnValue = (BOOL) TRUE;

         // Close the handle to the Cluster Service.
         
         CloseServiceHandle( hscService );
      }
      else
      {
         // The Cluster Service could not be opened. That implies that Clustering
         // Services has not been installed.

         fReturnValue = (BOOL) FALSE;
      }  // Was the Cluster Service opened?

      // Close the handle to the Service Control Manager.

      CloseServiceHandle( hscServiceMgr );
   }
   else
   {
      // The Service Control Manager could not be opened.

      fReturnValue = (BOOL) FALSE;
   }  // Was the Service Control Manager opened?

   return ( fReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\isclusterserviceregistered.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    IsClusterServiceRegistered.h
//
// Abstract:
//    function prototypes
//
// Author:
//    C. Brent Thomas
//
// Revision History:
//    4 Aug 1998 - original
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////

BOOL IsClusterServiceRegistered( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\removenetworkprovider.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		RemoveNetworkProvider.h
//
//	Abstract:
//		Declaration of functions to remove the Clustering Service
//              network providrt, ClusNet, from the list of Winsock Transports.
//
//	Implementation File:
//		RemoveNetworkProvider.cpp
//
//	Author:
//		C. Brent Thomas (a-brentt) 01-Jul-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __REMOVENETWORKPROVIDER_H_
#define __REMOVENETWORKPROVIDER_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

DWORD RemoveNetworkProvider( void );

/////////////////////////////////////////////////////////////////////////////

#endif // __REMOVENETWORKPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\regcomobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		RegComObj.h
//
//	Abstract:
//		Declaration of functions to register and unregister COM objects.
//
//	Implementation File:
//		RegComObj.cpp
//
//	Author:
//		C. Brent Thomas (a-brentt) 27-Mar-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __REGCOMOBJ_H_
#define __REGCOMOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

DWORD RegisterCOMObject( LPCTSTR ptszCOMObjectFileName,
                         LPCTSTR ptszPathToCOMObject );

DWORD UnRegisterCOMObject( LPCTSTR ptszCOMObjectFileName,
                           LPCTSTR ptszPathToCOMObject );

BOOL UnRegisterClusterCOMObjects( HINSTANCE hInstance,
                                  LPCTSTR ptszPathToCOMObject );

/////////////////////////////////////////////////////////////////////////////

#endif // __REGCOMOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\isterminalservicesinstalled.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		IsTerminalServicesInstalled.h
//
//	Abstract:
//		Declaration of functions to determine whether Terminal Services is installed.
//
//	Implementation File:
//		IsTerminalServicesInstalled.cpp
//
//	Author:
//		C. Brent Thomas (a-brentt)
//
//	Revision History:
//              03 Feb 1999 - original
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __IsTerminalServicesInstalled_H_
#define __IsTerminalServicesInstalled_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

BOOL IsTerminalServicesInstalled( void );

/////////////////////////////////////////////////////////////////////////////

#endif // __IsTerminalServicesInstalled_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\removenetworkprovider.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tchar.h>

extern "C" {
#include <wsasetup.h>
}
  
/////////////////////////////////////////////////////////////////////////////
//++
//
// RemoveNetworkProvider
//
// Routine Description:
//    This routine uninstalls the Clustering Service Network Provider.
//
// Arguments:
//    None
//
// Return Value:
//    (DWORD) ERROR_SUCCESS - indicates success
//    Any other value is a Win32 error code.
//
// Note:
//    This function was adapted from removeNetworkProvider in the NT 4.0
//    Cluster "setup" program.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD RemoveNetworkProvider( void )
{
   DWORD dwReturnValue;

   LONG  lReturnValue;

   //
   // The inf file will take care of deleting the clusnet winsock key.
   // We just need to delete clusnet from the list of winsock transports.
   //

   //
   // Open the winsock service parameters key.
   //

   HKEY  hWinsockParametersRegKey;

   lReturnValue = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT("System\\CurrentControlSet\\Services\\WinSock\\Parameters"),
                                (DWORD) 0L,     // reserved
                                MAXIMUM_ALLOWED,
                                (PHKEY) &hWinsockParametersRegKey );

   dwReturnValue = (DWORD) lReturnValue;

   if ( lReturnValue == (LONG) ERROR_SUCCESS )
   {
      //
      // Update the winsock transports list.
      //
      
      // Allocate memory into which to read the Winsock Transports List.

      LPBYTE   pWinsockTransportsList;

      DWORD    dwWinsockTransportsListSize = 200;     // arbitrary size

      pWinsockTransportsList = (LPBYTE) LocalAlloc( LPTR, dwWinsockTransportsListSize );

      // Was the buffer for the Winsock Transports List allocated?

      if ( pWinsockTransportsList != (LPBYTE) NULL )
      {
        // Read the Winsock Transports List from the registry.

        DWORD  dwRegKeyType;

        lReturnValue = RegQueryValueEx( hWinsockParametersRegKey,
                                        TEXT("Transports"),
                                        (LPDWORD) NULL,
                                        &dwRegKeyType,
                                        pWinsockTransportsList,
                                        &dwWinsockTransportsListSize );

        // Was the Winsock Transports List read on the first attempt?

        if ( lReturnValue != (LONG) ERROR_SUCCESS )
        {
           // Was the buffer too small?

           if ( lReturnValue == (LONG) ERROR_MORE_DATA )
           {
              // The Winsock Transports List was not read form the registry because
              // the buffer was too small. Increase the size of the buffer.
   
              pWinsockTransportsList = (LPBYTE) LocalReAlloc( pWinsockTransportsList,
                                                              (UINT) dwWinsockTransportsListSize,
                                                              (UINT) LMEM_ZEROINIT );
   
              // Was the buffer reallocation successfull?
   
              if ( pWinsockTransportsList != (LPBYTE) NULL )
              {
                 // Attempt to read the Wincosk Transports List a second time.
   
                 lReturnValue = RegQueryValueEx( hWinsockParametersRegKey,
                                                 TEXT("Transports"),
                                                 (LPDWORD) NULL,
                                                 &dwRegKeyType,
                                                 pWinsockTransportsList,
                                                 &dwWinsockTransportsListSize );
   
                 // Was the Winsock Transports List read on the second attempt?
   
                 if ( lReturnValue != (LONG) ERROR_SUCCESS )
                 {
                    dwReturnValue = (DWORD) lReturnValue;
                 } // Was the Winsock Transports List read on the second attempt?
              } // Was the buffer reallocation successfull?
              else
              {
                 dwReturnValue = GetLastError();
              } // Was the buffer reallocation successfull?
           } // Was the buffer too small?
        } // Was the Winsock Transports List read on the first attempt?

        // At this point variable lReturnValue indicates whether the Winsock
        // Transports List was read from the registry.

        if ( lReturnValue == (LONG) ERROR_SUCCESS )
        {
           // Is the type of the registry value correct?

           if ( dwRegKeyType == (DWORD) REG_MULTI_SZ )
           {
              LPTSTR ptszOldTransportsList;

              ptszOldTransportsList = (LPTSTR) pWinsockTransportsList;

              LPTSTR ptszNewTransportList;

              ptszNewTransportList = (LPTSTR) LocalAlloc( LMEM_FIXED, dwWinsockTransportsListSize );

              // Was the buffer for the new Winsock Transports List allocated successfully?

              if ( ptszNewTransportList != (LPTSTR) NULL )
              {
                 // Start building a list of Winsock Transports that does not include
                 // the Clustering Service Network Provider.

                 LPTSTR ptszNextTransport;

                 ptszNextTransport = ptszNewTransportList;

                 // Initialize the size of the new Winsock Transports List to zero.

                 dwWinsockTransportsListSize = (DWORD) 0L;

                 DWORD  dwIndividualTransportLength;

                 while ( *ptszOldTransportsList != UNICODE_NULL )
                 {
                    dwIndividualTransportLength = _tcslen(ptszOldTransportsList) + 1;

                    // This comparison is case insensitive, like registry values.

                    if ( _tcsicmp( ptszOldTransportsList, TEXT("ClusNet") ) != 0 )
                    {
                       _tcscpy( ptszNextTransport, ptszOldTransportsList );

                       ptszNextTransport += dwIndividualTransportLength;

                       dwWinsockTransportsListSize += dwIndividualTransportLength * sizeof(WCHAR);
                    };
                    ptszOldTransportsList += dwIndividualTransportLength;
                 } // end of while loop

                 *ptszNextTransport = UNICODE_NULL;

                 dwWinsockTransportsListSize += sizeof( UNICODE_NULL );

                 // Save the new Winsock Transports List in the registry.

                 ASSERT( dwWinsockTransportsListSize != 0L );

                 lReturnValue = RegSetValueEx( hWinsockParametersRegKey,
                                               TEXT("Transports"),
                                               NULL,
                                               dwRegKeyType,
                                               (CONST BYTE *) ptszNewTransportList,
                                               dwWinsockTransportsListSize );

                 if ( lReturnValue == (LONG) ERROR_SUCCESS )
                 {
                    //
                    // Poke winsock to update the Winsock2 config
                    //

                    WSA_SETUP_DISPOSITION   disposition;

                    dwReturnValue = MigrateWinsockConfiguration( &disposition, NULL, NULL );
                 }
                 else
                 {
                    dwReturnValue = (DWORD) lReturnValue;
                 }
                 
                 // Free the buffer for the new Winsock Transports List.

                 LocalFree( ptszNewTransportList );
              }
              else
              {
                 dwReturnValue = GetLastError();
              } // Was the buffer for the new Winsock Transports List allocated successfully?
           }
           else
           {
              dwReturnValue = ERROR_INVALID_PARAMETER;
           } // Is the type of the registry value correct?
        } // Did one of the attempts to read the Winsock Transports List succeed?

        // Free the buffer for the Winsock Transports List.
  
        if ( pWinsockTransportsList != (LPBYTE) NULL )
        {
           LocalFree( pWinsockTransportsList );
        }
      } // Was the buffer for the Winsock Transports List allocated?
      else
      {
         dwReturnValue = GetLastError();
      } // Was the buffer for the Winsock Transports List allocated?
   }  // Was the Winsock Parameters key opened?

   return ( dwReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\setupcommonlibres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//      Copyright (c) 1996-1998 Microsoft Corporation
//
//      Module Name:
//              SetupCommonLibRes.h
//
//      Abstract:
//              Definition of resource constants used with the cluster setup
//              common library.
//
//      Implementation File:
//              SetupCommonLibRes.rc
//
//      Author:
//              C. Brent Thomas (a-brentt) April 1, 1998
//
//      Revision History:
//
//      Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SETUPCOMMONLIBRES_H_
#define __SETUPCOMMONLIBRES_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//
// Note that the high orger byte of the value was chosen arbitrarily to 
// preclude collisions with symbols defined elsewhere. There is, of course,
// no guarrantee.
/////////////////////////////////////////////////////////////////////////////

#define IDS_ERROR_UNREGISTERING_COM_OBJECT                  0xEC01
#define IDS_CLUSTERING_SERVICES_INSTALL_STATE_REGKEY_NAME   0xEC02
#define IDS_CLUSTERING_SERVICES_INSTALL_STATE_REGVALUE_NAME 0xEC03

/////////////////////////////////////////////////////////////////////////////

#endif // __SETUPCOMMONLIBRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\regcomobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Module Name:
//    RegCOMObj.cpp
//
// Abstract:
//    The functions in this file are used to register and unregister the COM
//    objects used by Cluster Server.
//
// Author:
//    C. Brent Thomas (a-brentt) April 1 1998
//
// Revision History:
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winerror.h>
#include <tchar.h>

#include "SetupCommonLibRes.h"

typedef HRESULT (*PFDLLREGISTERSERVER)(void);




/////////////////////////////////////////////////////////////////////////////
//++
//
// RegisterCOMObject
//
// Routine Description:
//    This function attempts to register a COM object.
//
// Arguments:
//    ptszCOMObjectFileName - points to the name of the COM object file.
//    ptszPathToCOMObject - points to the location of the COM object.
//    
//
// Return Value:
//    ERROR_SUCCESS - indicated success
//    Any other value is an NT error code retrunde by GetLastError()
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD RegisterCOMObject( LPCTSTR ptszCOMObjectFileName,
                         LPCTSTR ptszPathToCOMObject )
{
   DWORD               dwStatus;

   HINSTANCE           hLib = NULL;

   TCHAR               tszComObjFileName[_MAX_PATH];

   LPSTR               pszEntryPoint;

   PFDLLREGISTERSERVER pfnRegisterServer;

//   ASSERT(ptszCOMObjectFileName != NULL);      BUGBUG
//   ASSERT(ptszPathToCOMObject != NULL);

   //
   // Construct the file name.
   //

   wsprintf( tszComObjFileName, TEXT("%s\\%s"), ptszPathToCOMObject, ptszCOMObjectFileName );

   //
   // Load the DLL.
   //

   hLib = LoadLibrary( tszComObjFileName );

   if ( hLib != NULL )
   {
      //
      // Get the DllRegisterServer entry point.
      //
   
      pfnRegisterServer = (PFDLLREGISTERSERVER) GetProcAddress( hLib,
                                                                "DllRegisterServer" );
   
      if ( pfnRegisterServer != NULL )
      {
         //
         // Call the entry point.
         //
      
         dwStatus = (*pfnRegisterServer)();
      }
      else
      {
         dwStatus = GetLastError();
      }
      
      FreeLibrary( hLib );
   }
   else
   {
      dwStatus = GetLastError();
   }

   return ( dwStatus );
} // RegisterCOMObject



/////////////////////////////////////////////////////////////////////////////
//++
//
// UnRegisterCOMObject
//
// Routine Description:
//    This function attempts to unregister a COM object.
//
// Arguments:
//    ptszCOMObjectFileName - points to the name of the COM object file.
//    ptszPathToCOMObject - points to the location of the COM object.
//    
//
// Return Value:
//    ERROR_SUCCESS - indicated success
//    Any other value is an NT error code retrunde by GetLastError()
//
//--
/////////////////////////////////////////////////////////////////////////////


DWORD UnRegisterCOMObject( LPCTSTR ptszCOMObjectFileName,
                           LPCTSTR ptszPathToCOMObject )
{
   DWORD               dwStatus;

   HINSTANCE           hLib = NULL;

   TCHAR               tszComObjFileName[_MAX_PATH];

   LPSTR               pszEntryPoint;

   PFDLLREGISTERSERVER pfnRegisterServer;

//   ASSERT(ptszCOMObjectFileName != NULL);      BUGBUG
//   ASSERT(ptszPathToCOMObject != NULL);

   //
   // Construct the file name.
   //

   wsprintf( tszComObjFileName, TEXT("%s\\%s"), ptszPathToCOMObject, ptszCOMObjectFileName );

   //
   // Load the DLL.
   //

   hLib = LoadLibrary( tszComObjFileName );

   if ( hLib != NULL )
   {
      //
      // Get the DllRegisterServer entry point.
      //
   
      pfnRegisterServer = (PFDLLREGISTERSERVER) GetProcAddress( hLib,
                                                                "DllUnregisterServer" );
   
      if ( pfnRegisterServer != NULL )
      {
         //
         // Call the entry point.
         //
      
         dwStatus = (*pfnRegisterServer)();
      }
      else
      {
         dwStatus = GetLastError();
      }
      
      FreeLibrary( hLib );
   }
   else
   {
      dwStatus = GetLastError();
   }

   return ( dwStatus );
} // UnRegisterCOMObject


/////////////////////////////////////////////////////////////////////////////
//++
//
// UnRegisterClusterCOMObjects
//
// Routine Description:
//    This function unregisters the COM objects that are components of Cluster
//    Server.
//
// Arguments:
//    hWnd - the handle to the parent window.
//    ptszPathToCOMObject - points to the location of the COM objects to be
//                          unregistered..
//
// Return Value:
//    (BOOL) TRUE - indicates success
//    (BOOL) FALSE - indicates that an error was encountered
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL UnRegisterClusterCOMObjects( HINSTANCE hInstance,
                                  LPCTSTR ptszPathToCOMObject )
{
   BOOL  fReturnValue = (BOOL) TRUE;

   DWORD   dwURCORv;

   TCHAR tszMessage[256];        // arbitrary size
   TCHAR tszFormatString[256];


   //
   // Unregister CluAdMMC.
   //

   dwURCORv = UnRegisterCOMObject( TEXT("CluAdMMC.dll"), ptszPathToCOMObject );

   if ( (dwURCORv != (DWORD) ERROR_SUCCESS) && (dwURCORv != (DWORD) ERROR_MOD_NOT_FOUND) )
   {
      if ( LoadString( hInstance, IDS_ERROR_UNREGISTERING_COM_OBJECT,
                       tszFormatString, 256 ) > 0 )
      {
         wsprintf( tszMessage, tszFormatString, dwURCORv, TEXT("CluAdMMC.dll") );
   
         MessageBox( NULL, tszMessage, NULL, MB_OK | MB_ICONEXCLAMATION );
      }  // Did LoadString succeed?

      fReturnValue = (BOOL) FALSE;
   }

   //
   // Unregister ClAdmWiz.
   //

   dwURCORv = UnRegisterCOMObject( TEXT("ClAdmWiz.dll"), ptszPathToCOMObject );

   if ( (dwURCORv != (DWORD) ERROR_SUCCESS) && (dwURCORv != (DWORD) ERROR_MOD_NOT_FOUND) )
   {
      if ( LoadString( hInstance, IDS_ERROR_UNREGISTERING_COM_OBJECT,
                       tszFormatString, 256 ) > 0 )
      {
         wsprintf( tszMessage, tszFormatString, dwURCORv, TEXT("ClAdmWiz.dll") );
   
         MessageBox( NULL, tszMessage, NULL, MB_OK | MB_ICONEXCLAMATION );
      }  // Did LoadString succeed?

      fReturnValue = (BOOL) FALSE;
   }

   //
   // Unregister IISClEx3.
   //

   dwURCORv = UnRegisterCOMObject( TEXT("IISClEx3.dll"), ptszPathToCOMObject );

   if ( (dwURCORv != (DWORD) ERROR_SUCCESS) && (dwURCORv != (DWORD) ERROR_MOD_NOT_FOUND) )
   {
      if ( LoadString( hInstance, IDS_ERROR_UNREGISTERING_COM_OBJECT,
                       tszFormatString, 256 ) > 0 )
      {
         wsprintf( tszMessage, tszFormatString, dwURCORv, TEXT("IISClEx3.dll") );
   
         MessageBox( NULL, tszMessage, NULL, MB_OK | MB_ICONEXCLAMATION );
      }  // Did LoadString succeed?

      fReturnValue = (BOOL) FALSE;
   }

   //
   // Unregister ClNetREx.
   //

   dwURCORv = UnRegisterCOMObject( TEXT("ClNetREx.dll"), ptszPathToCOMObject );

   if ( (dwURCORv != (DWORD) ERROR_SUCCESS) && (dwURCORv != (DWORD) ERROR_MOD_NOT_FOUND) )
   {
      if ( LoadString( hInstance, IDS_ERROR_UNREGISTERING_COM_OBJECT,
                       tszFormatString, 256 ) > 0 )
      {
         wsprintf( tszMessage, tszFormatString, dwURCORv, TEXT("ClNetREx.dll") );
   
         MessageBox( NULL, tszMessage, NULL, MB_OK | MB_ICONEXCLAMATION );
      }  // Did LoadString succeed?

      fReturnValue = (BOOL) FALSE;
   }

   //
   // Unregister CluAdmEx.
   //

   dwURCORv = UnRegisterCOMObject( TEXT("CluAdmEx.dll"), ptszPathToCOMObject );

   if ( (dwURCORv != (DWORD) ERROR_SUCCESS) && (dwURCORv != (DWORD) ERROR_MOD_NOT_FOUND) )
   {
      if ( LoadString( hInstance, IDS_ERROR_UNREGISTERING_COM_OBJECT,
                       tszFormatString, 256 ) > 0 )
      {
         wsprintf( tszMessage, tszFormatString, dwURCORv, TEXT("CluAdmEx.dll") );
   
         MessageBox( NULL, tszMessage, NULL, MB_OK | MB_ICONEXCLAMATION );
      }  // Did LoadString succeed?

      fReturnValue = (BOOL) FALSE;
   }

   return ( fReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\stopservice.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    StopService.h
//
// Abstract:
//    Declaration of functions to start and stop services.
//
// Implementation File:
//    StopService.cpp
//
// Author:
//    C. Brent Thomas   (a-brentt)      1 April 1998
//
// Revision History:
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef  __STOPSERVICE_H_
#define __STOPSERVICE_H_

BOOL StopService( IN LPCWSTR pwszServiceName );

#endif  // __STOPSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\inc\installstate.h ===
#ifndef _INSTALLSTATE_H_
#define _INSTALLSTATE_H_

// This enum is used to indicate the state of the Cluster Server installation.
// The registry key that indicates the state of the Cluster Server installation
// will be a DWORD representation of one of the following values.

typedef enum
{
   eClusterInstallStateUnknown,
   eClusterInstallStateFilesCopied,
   eClusterInstallStateConfigured
} eClusterInstallState;

#endif   // _INSTALLSTATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\setup\common\stopservice.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Module Name:
//    StopService.cpp
//
// Abstract:
//    The functions in this file are used to stop the services used
//    by the Cluster Service.
//
// Author:
//    C. Brent Thomas (a-brentt) April 1 1998
//
// Revision History:
//
// Notes:
//
/////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winerror.h>
#include <tchar.h>

#include "SetupCommonLibRes.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
// StopService
//
// Routine Description:
//    This function attempts to stop a service. This function will time out
//    if the service does not stop soon enough. If this function times out,
//    The service may eventually stop, but this function will have exited.
//
// Arguments:
//    pwszServiceName - points to a wide character string that contains the
//    name of the service to be stopped.
//
// Return Value:
//    TRUE - indicates that the service was stopped
//    FALSE - indicates that the service had not stopped when this function
//            timed out.
//
// Note:
//    This function was adapted from a function with the same name in the
//    "newsetup" project utils.cpp file.
//--
/////////////////////////////////////////////////////////////////////////////

BOOL StopService( IN LPCWSTR pwszServiceName )
{
   SC_HANDLE hscServiceMgr;
   SC_HANDLE hscService;

   SERVICE_STATUS t_Status;

   BOOL fSuccess = (BOOL) FALSE;

   DWORD dwTimeoutTime;

   //
   // Timeout after 20 seconds and keep going. So if the service
   // is hung, we won't hang forever.
   //

   dwTimeoutTime = GetTickCount() + 20 * 1000;

   // Connect to the Service Control Manager and open the specified service
   // control manager database. 

   hscServiceMgr = OpenSCManager( NULL, NULL, GENERIC_READ | GENERIC_WRITE );

   // Was the service control manager database opened successfully?
   
   if ( hscServiceMgr != NULL )
   {
      // The service control manager database is open.
      // Open a handle to the service to be stopped.
      
      hscService = OpenService( hscServiceMgr,
                                pwszServiceName,
                                GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

      // Was the handle to the service opened?

      if ( hscService != NULL )
      {
         // Request that the service stop.
         
         fSuccess = ControlService( hscService,
                                    SERVICE_CONTROL_STOP,
                                    &t_Status );

         // Was the "stop" request sent to the service successfully?
         
         if ( fSuccess == (BOOL) TRUE )
         {
            // Give the service a chance to stop.
            
            Sleep(1000);

            fSuccess = (BOOL) FALSE;   // Indicate that the service has not stopped.
                                       // If this function times out fSuccess will
                                       // remain FALSE when StopService exits.
            
            // Check the status of the service to determine whether it has stopped.
            
            while ( QueryServiceStatus( hscService, &t_Status ) &&
                    (dwTimeoutTime > GetTickCount()) )
            {
               // Is the "stop" request still pending?
               
               if ( t_Status.dwCurrentState == SERVICE_STOP_PENDING )
               {
                  // The "stop" request is still pending. Give the service a
                  // little while longer to stop.
                  
                  Sleep(1000);
               }
               else
               {
                  // The service has stopped.

                  fSuccess = (BOOL) TRUE;    // Indicate that the service has stoped.
                  
                  break;
               } // Is the "stop" request still pending?
            }  // end of while loop
         }  // Was the "stop" request sent to the service successfully?

         // Close the handle to the service.
         
         CloseServiceHandle( hscService );
      } // Was the handle to the service opened?

      // Close connsection to the service control manager and close the service
      // control manager database.
      
      CloseServiceHandle( hscServiceMgr );
   } // Was the service control manager database opened successfully?

   return ( fSuccess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\leaks.h ===
#define MEM_LEAKS 1
//#define EVENT_LEAKS 1
#define KEY_LEAKS 1


#ifdef MEM_LEAKS

#undef LocalAlloc
#undef LocalFree

//WINBASEAPI
HLOCAL
WINAPI
CheckLocalAlloc(
    UINT    uFlags,
    UINT    uBytes
    );

//WINBASEAPI
HLOCAL
WINAPI
CheckLocalFree(
    HLOCAL  hMem
    );

#define LocalAlloc CheckLocalAlloc
#define LocalFree CheckLocalFree

#endif // MEM_LEAKS


#ifdef EVENT_LEAKS

#undef CreateEventA
#undef CreateEventW

//WINBASEAPI
HANDLE
WINAPI
CheckCreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );


//WINBASEAPI
HANDLE
WINAPI
CheckCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

#define CreateEventA CheckCreateEventA
#define CreateEventW CheckCreateEventW

#endif // EVENT_LEAKS


#ifdef KEY_LEAKS

//WINADVAPI
LONG
APIENTRY
CheckRegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
CheckRegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
CheckRegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
CheckRegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
CheckRegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
CheckRegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

//WINADVAPI
LONG
APIENTRY
CheckRegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  Reserved,
    LPSTR  lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

//WINADVAPI
LONG
APIENTRY
CheckRegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  Reserved,
    LPSTR  lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

//WINADVAPI
LONG
APIENTRY
CheckRegCloseKey(
    HKEY hKey
    );


#define RegOpenKeyA CheckRegOpenKeyA
#define RegOpenKeyW CheckRegOpenKeyW
#define RegOpenKeyExA CheckRegOpenKeyExA
#define RegOpenKeyExW CheckRegOpenKeyExW
#define RegCreateKeyA CheckRegCreateKeyA
#define RegCreateKeyW CheckRegCreateKeyW
#define RegCreateKeyExA CheckRegCreateKeyExA
#define RegCreateKeyExW CheckRegCreateKeyExW
#define RegCloseKey   CheckRegCloseKey

#endif // KEY_LEAKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\leaks.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module provides the main cluster initialization.

Author:

    John Vert (jvert) 6/5/1996

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "clusrtl.h"

#define MEM_LEAKS 1
#define EVENT_LEAKS 1
#define KEY_LEAKS 1


#define HEAP_SIGNATURE 'PAEH'

typedef struct _MEM_HDR {
    DWORD   Signature;
    PVOID   CallersAddress;
    PVOID   CallersCaller;
} MEM_HDR, *PMEM_HDR;

#ifdef MEM_LEAKS

HLOCAL
WINAPI
CheckLocalAlloc(
    UINT    uFlags,
    UINT    uBytes
    )
{
    HLOCAL  memory;
    PMEM_HDR memHdr;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );


    memHdr = LocalAlloc( uFlags, uBytes + sizeof(MEM_HDR) );
    if ( !memHdr ) {
        return NULL;
    }

    memHdr->Signature = HEAP_SIGNATURE;
    memHdr->CallersAddress = callersAddress;
    memHdr->CallersCaller = callersCaller;

    return(memHdr+1);
}


HLOCAL
WINAPI
CheckLocalFree(
    HLOCAL  hMem
    )
{
    PMEM_HDR memHdr = hMem;

    if ( memHdr ) {
        --memHdr;
        if ( memHdr->Signature != HEAP_SIGNATURE ) {
            memHdr++;
        }
    }

    return( LocalFree(memHdr) );
}

#endif // MEM_LEAKS

#ifdef EVENT_LEAKS

//WINBASEAPI
HANDLE
WINAPI
CheckCreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )
{
    HANDLE  handle;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    handle = CreateEventA( 
                    lpEventAttributes,
                    bManualReset,
                    bInitialState,
                    lpName
                    );

    ClRtlLogPrint( "[TEST] CreateEvent returns handle %1!lx!, called from %2!lx! and %3!lx!\n",
                   handle,
                   callersAddress,
                   callersCaller );

    return(handle);

} // CheckCreateEventA


//WINBASEAPI
HANDLE
WINAPI
CheckCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    HANDLE  handle;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    handle = CreateEventW( 
                    lpEventAttributes,
                    bManualReset,
                    bInitialState,
                    lpName
                    );

    ClRtlLogPrint( "[TEST] CreateEventW returns handle %1!lx!, called from %2!lx! and %3!lx!\n",
                   handle,
                   callersAddress,
                   callersCaller );

    return(handle);

} // CheckCreateEventW

#endif // EVENT_LEAKS

#ifdef KEY_LEAKS

//WINADVAPI
LONG
APIENTRY
CheckRegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    status = RegOpenKeyA(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status ) {
        ClRtlLogPrint( "[TEST] RegOpenKey returns key %1!lx!, called from %2!lx! and %3!lx!\n",
                   *phkResult,
                   callersAddress,
                   callersCaller );
    }

    return(status);

} // CheckRegOpenKeyA

//WINADVAPI
LONG
APIENTRY
CheckRegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    status = RegOpenKeyW(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status ) {
        ClRtlLogPrint( "[TEST] RegOpenKeyW returns key %1!lx!, called from %2!lx! and %3!lx!\n",
                   *phkResult,
                   callersAddress,
                   callersCaller );
    }

    return(status);

} // CheckRegOpenKeyW

//WINADVAPI
LONG
APIENTRY
CheckRegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    status = RegOpenKeyExA(
                    hKey,
                    lpSubKey,
                    ulOptions,
                    samDesired,
                    phkResult
                    );

    if ( status ) {
        ClRtlLogPrint( "[TEST] RegOpenKeyEx returns key %1!lx!, called from %2!lx! and %3!lx!\n",
                   *phkResult,
                   callersAddress,
                   callersCaller );
    }

    return(status);

} // CheckRegOpenKeyExA

//WINADVAPI
LONG
APIENTRY
CheckRegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    status = RegOpenKeyExW(
                    hKey,
                    lpSubKey,
                    ulOptions,
                    samDesired,
                    phkResult
                    );

    if ( status ) {
        ClRtlLogPrint( "[TEST] RegOpenKeyExW returns key %1!lx!, called from %2!lx! and %3!lx!\n",
                   *phkResult,
                   callersAddress,
                   callersCaller );
    }

    return(status);

} // CheckRegOpenKeyExW


//WINADVAPI
LONG
APIENTRY
CheckRegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    status = RegCreateKeyA(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status ) {
        ClRtlLogPrint( "[TEST] RegCreateKey returns key %1!lx!, called from %2!lx! and %3!lx!\n",
                   *phkResult,
                   callersAddress,
                   callersCaller );
    }

    return(status);

} // CheckRegCreateKeyA


//WINADVAPI
LONG
APIENTRY
CheckRegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    status = RegCreateKeyW(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status ) {
        ClRtlLogPrint( "[TEST] RegCreateKeyW returns key %1!lx!, called from %2!lx! and %3!lx!\n",
                   *phkResult,
                   callersAddress,
                   callersCaller );
    }

    return(status);

} // CheckRegCreateKeyW


//WINADVAPI
LONG
APIENTRY
CheckRegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  Reserved,
    LPSTR  lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    status = RegCreateKeyExA(
                    hKey,
                    lpSubKey,
                    Reserved,
                    lpClass,
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    phkResult,
                    lpdwDisposition
                    );

    if ( status ) {
        ClRtlLogPrint( "[TEST] RegCreateKeyEx returns key %1!lx!, called from %2!lx! and %3!lx!\n",
                   *phkResult,
                   callersAddress,
                   callersCaller );
    }

    return(status);

} // CheckRegCreateKeyExA

//WINADVAPI
LONG
APIENTRY
CheckRegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  Reserved,
    LPWSTR lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    status = RegCreateKeyExW(
                    hKey,
                    lpSubKey,
                    Reserved,
                    lpClass,
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    phkResult,
                    lpdwDisposition
                    );

    ClRtlLogPrint( "[TEST] RegCreateKeyExW returns key %1!lx!, called from %2!lx! and %3!lx!\n",
                   *phkResult,
                   callersAddress,
                   callersCaller );

    return(status);

} // CheckRegCreateKeyExW


//WINADVAPI
LONG
APIENTRY
CheckRegCloseKey(
    HKEY hKey
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );

    ClRtlLogPrint( "[TEST] RegCloseKey for handle %1!lx! called from %2!lx! and %3!lx!\n",
                   hKey,
                   callersAddress,
                   callersCaller );


    status = RegCloseKey(
                    hKey
                    );

    return(status);

} // CheckRegCloseKey



#endif // KEY_LEAKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\ainfodlg.cpp ===
// AInfodlg.cpp : implementation file
//

#include "stdafx.h"
#include "evtview.h"
#include "AInfodlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScheduleActionInfo dialog


CScheduleActionInfo::CScheduleActionInfo(CWnd* pParent /*=NULL*/)
	: CDialog(CScheduleActionInfo::IDD, pParent)
{
	//{{AFX_DATA_INIT(CScheduleActionInfo)
	m_stParam = _T("");
	//}}AFX_DATA_INIT
}


void CScheduleActionInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScheduleActionInfo)
	DDX_Control(pDX, IDC_TYPE, m_ctrlType);
	DDX_Text(pDX, IDC_PARAM, m_stParam);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScheduleActionInfo, CDialog)
	//{{AFX_MSG_MAP(CScheduleActionInfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleActionInfo message handlers

BOOL CScheduleActionInfo::OnInitDialog() 
{
	CDialog::OnInitDialog();

	int i =0 ;

	while (aAction [i].pszDesc)
	{
		m_ctrlType.AddString (aAction [i].pszDesc) ;
		m_ctrlType.SetItemData (i, aAction [i].dwCode) ;

		i++ ;
	} ;

	if (i)
		m_ctrlType.SetCurSel (0) ;
	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CScheduleActionInfo::OnOK() 
{
	UpdateData(TRUE) ;

	sActionInfo.dwActionType = m_ctrlType.GetItemData (m_ctrlType.GetCurSel()) ;
	sActionInfo.stParam = m_stParam ;

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\ainfodlg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ainfodlg.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
// CScheduleActionInfo dialog
#include "globals.h"

class CScheduleActionInfo : public CDialog
{
// Construction
public:
    struct SCHEDULE_ACTIONINFO sActionInfo ;

    CScheduleActionInfo(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CScheduleActionInfo)
    enum { IDD = IDD_SCHEDULEACTIONINFO };
    CComboBox    m_ctrlType;
    CString    m_stParam;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScheduleActionInfo)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CScheduleActionInfo)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\childfrm.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    childfrm.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/
/////////////////////////////////////////////////////////////////////////////

class CChildFrame : public CMDIChildWnd
{
    DECLARE_DYNCREATE(CChildFrame)
public:
    CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CChildFrame)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\childfrm.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    childfrm.cpp

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#include "stdafx.h"
#include "evtview.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
    // TODO: add member initialization code here
    
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
    CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
    CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\clusname.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusname.cpp

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#include "stdafx.h"
#include "evtview.h"
#include "clusname.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGetClusterName dialog


CGetClusterName::CGetClusterName(CWnd* pParent /*=NULL*/)
    : CDialog(CGetClusterName::IDD, pParent)
{
    //{{AFX_DATA_INIT(CGetClusterName)
    //}}AFX_DATA_INIT
}


void CGetClusterName::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGetClusterName)
    DDX_Control(pDX, IDC_CLUSTERNAME, m_ctrlClusterName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetClusterName, CDialog)
    //{{AFX_MSG_MAP(CGetClusterName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetClusterName message handlers

void CGetClusterName::OnOK() 
{
    m_ctrlClusterName.GetWindowText (m_stClusterName) ;
    
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\clusutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusutil.h

Abstract:
    This files has to be kept in ssync with \kinglet\rats\testsrc\kernel\cluster\clusapi\clusutil.



Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/
#ifndef _CLUSUTIL_H_
#define _CLUSUTIL_H_

#include <clusapi.h>

#define PARAM_LEN    512

typedef struct {
    LPCWSTR pszDesc  ;
    DWORD    dwCode ;
} DWORDTOSTRINGMAP, *PDWORDTOSTRINGMAP ;

extern DWORDTOSTRINGMAP aTypeMap [] ;

extern LPCWSTR GetType (PDWORDTOSTRINGMAP pTypeMap, DWORD_PTR dwCode) ;

typedef struct {
    LPCWSTR pszDesc  ;
    DWORD    dwCode ;
    DWORD    dwSubCode ;
} DWORDTOSUBSTRINGMAP, *PDWORDTOSUBSTRINGMAP ;

extern DWORDTOSUBSTRINGMAP aSubTypeMap [] ;

extern LPCWSTR GetSubType (PDWORDTOSUBSTRINGMAP pTypeMap, DWORD dwCode, DWORD dwSubCode) ;

LPCWSTR GetType (ULONG_PTR dwFilter) ;
void RecurseEvalParam (LPCWSTR pszParam, LPWSTR pszValueconst, LPCWSTR pszSection = L"PARAMETER") ;
int RecurseEvalIntParam (LPCWSTR pszParam) ;
void SaveParam (LPCWSTR pszKey, LPCWSTR pszValue) ;
void SaveIntParam (LPCWSTR pszKey, int iValue) ;
void MemSet (LPWSTR pszBuf, WCHAR c, DWORD cb) ;
int MemCheck (LPCWSTR pszBuf, WCHAR c, DWORD cb) ;

DumpClusterDetails (HCLUSTER hCluster, LPCWSTR pszFileName, LPCWSTR pszComment) ;
CLUSTER_GROUP_STATE MyGetClusterGroupState (HCLUSTER hCluster, LPCWSTR pszGroupName, LPWSTR pszNodeName) ;
CLUSTER_NODE_STATE MyGetClusterNodeState (HCLUSTER hCluster, LPWSTR pszNodeName) ;
CLUSTER_RESOURCE_STATE MyGetClusterResourceState (HCLUSTER hCluster, LPCWSTR pszResourceName, LPWSTR pszNodeName, LPWSTR pszGroupName) ;
CLUSTER_NETWORK_STATE MyGetClusterNetworkState (HCLUSTER hCluster, LPWSTR pszNetworkName) ;
CLUSTER_NETINTERFACE_STATE MyGetClusterNetInterfaceState (HCLUSTER hCluster, LPWSTR pszNetInterfaceName) ;

#endif _CLUSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\clusutil.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusutil.cpp

Abstract:
    This file has to be kept in sync with \kinglet\rats\testsrc\kernel\cluster\clusapi\clusutil



Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/
#include "stdafx.h"
//#include <windows.h>
//#include <stdlib.h>
#include <clusapi.h>
#include "clusutil.h"



DWORDTOSTRINGMAP aTypeMap [] =
{
    {L"NODE_STATE", CLUSTER_CHANGE_NODE_STATE},
    {L"NODE_DELETED", CLUSTER_CHANGE_NODE_DELETED},
    {L"NODE_ADDED", CLUSTER_CHANGE_NODE_ADDED},
    {L"NODE_PROPERTY", CLUSTER_CHANGE_NODE_PROPERTY},

    {L"REGISTRY_NAME", CLUSTER_CHANGE_REGISTRY_NAME},
    {L"REGISTRY_ATTRIBUTES", CLUSTER_CHANGE_REGISTRY_ATTRIBUTES},
    {L"REGISTRY_VALUE", CLUSTER_CHANGE_REGISTRY_VALUE},
    {L"REGISTRY_SUBTREE", CLUSTER_CHANGE_REGISTRY_SUBTREE},

    {L"RESOURCE_STATE", CLUSTER_CHANGE_RESOURCE_STATE},
    {L"RESOURCE_DELETED", CLUSTER_CHANGE_RESOURCE_DELETED},
    {L"RESOURCE_ADDED", CLUSTER_CHANGE_RESOURCE_ADDED},
    {L"RESOURCE_PROPERTY", CLUSTER_CHANGE_RESOURCE_PROPERTY},

    {L"GROUP_STATE", CLUSTER_CHANGE_GROUP_STATE},
    {L"GROUP_DELETED", CLUSTER_CHANGE_GROUP_DELETED},
    {L"GROUP_ADDED", CLUSTER_CHANGE_GROUP_ADDED},
    {L"GROUP_PROPERTY", CLUSTER_CHANGE_GROUP_PROPERTY},

    {L"RESOURCE_TYPE_DELETED", CLUSTER_CHANGE_RESOURCE_TYPE_DELETED},
    {L"RESOURCE_TYPE_ADDED", CLUSTER_CHANGE_RESOURCE_TYPE_ADDED},

    {L"NETWORK_STATE", CLUSTER_CHANGE_NETWORK_STATE},
    {L"NETWORK_DELETED", CLUSTER_CHANGE_NETWORK_DELETED},
    {L"NETWORK_ADDED", CLUSTER_CHANGE_NETWORK_ADDED},
    {L"NETWORK_PROPERTY", CLUSTER_CHANGE_NETWORK_PROPERTY},

    {L"NETINTERFACE_STATE", CLUSTER_CHANGE_NETINTERFACE_STATE},
    {L"NETINTERFACE_DELETED", CLUSTER_CHANGE_NETINTERFACE_DELETED},
    {L"NETINTERFACE_ADDED", CLUSTER_CHANGE_NETINTERFACE_ADDED},
    {L"NETINTERFACE_PROPERTY", CLUSTER_CHANGE_NETINTERFACE_PROPERTY},

    {L"QUORUM_STATE", CLUSTER_CHANGE_QUORUM_STATE},
    {L"CLUSTER_STATE", CLUSTER_CHANGE_CLUSTER_STATE},
    {L"CLUSTER_PROPERTY", CLUSTER_CHANGE_CLUSTER_PROPERTY},

    {L"HANDLE_CLOSE", CLUSTER_CHANGE_HANDLE_CLOSE},

    {NULL, 0 }
} ;


LPCWSTR GetType (PDWORDTOSTRINGMAP pTypeMap, ULONG_PTR dwCode)
{
    int i = 0;
    while (pTypeMap [i].pszDesc)
    {
        if (pTypeMap [i].dwCode == dwCode)
            return pTypeMap [i].pszDesc ;
        i++ ;
    }

    return L"Unknown Type" ;
}

LPCWSTR GetType (ULONG_PTR dwFilter)
{
    return GetType (aTypeMap, dwFilter) ;
}


DWORDTOSUBSTRINGMAP aSubTypeMap [] =
{
    {L"Unknown", CLUSTER_CHANGE_RESOURCE_STATE, ClusterResourceStateUnknown},
    {L"Online", CLUSTER_CHANGE_RESOURCE_STATE, ClusterResourceOnline},
    {L"Offline", CLUSTER_CHANGE_RESOURCE_STATE, ClusterResourceOffline},
    {L"Failed", CLUSTER_CHANGE_RESOURCE_STATE, ClusterResourceFailed},
    {L"OnlinePending", CLUSTER_CHANGE_RESOURCE_STATE, ClusterResourceOnlinePending},
    {L"OfflinePending", CLUSTER_CHANGE_RESOURCE_STATE, ClusterResourceOfflinePending},

    {L"Unknown", CLUSTER_CHANGE_GROUP_STATE, ClusterGroupStateUnknown},
    {L"Online", CLUSTER_CHANGE_GROUP_STATE, ClusterGroupOnline},
    {L"Offline", CLUSTER_CHANGE_GROUP_STATE, ClusterGroupOffline},
    {L"Failed", CLUSTER_CHANGE_GROUP_STATE, ClusterGroupFailed},
    {L"PartialOnline", CLUSTER_CHANGE_GROUP_STATE, ClusterGroupPartialOnline},
    {L"Pending", CLUSTER_CHANGE_GROUP_STATE, ClusterGroupPending},

    {L"Unknown", CLUSTER_CHANGE_NODE_STATE, ClusterNodeStateUnknown},
    {L"Up", CLUSTER_CHANGE_NODE_STATE, ClusterNodeUp},
    {L"Down", CLUSTER_CHANGE_NODE_STATE, ClusterNodeDown},
    {L"Paused", CLUSTER_CHANGE_NODE_STATE, ClusterNodePaused},
    {L"Joining", CLUSTER_CHANGE_NODE_STATE, ClusterNodeJoining},

    {L"Unknown", CLUSTER_CHANGE_NETWORK_STATE, ClusterNetworkStateUnknown},
    {L"Unavailable", CLUSTER_CHANGE_NETWORK_STATE, ClusterNetworkUnavailable},
    {L"Down", CLUSTER_CHANGE_NETWORK_STATE, ClusterNetworkDown},
    {L"Partitioned", CLUSTER_CHANGE_NETWORK_STATE, ClusterNetworkPartitioned},
    {L"Up", CLUSTER_CHANGE_NETWORK_STATE, ClusterNetworkUp},
    
    {L"Unknown", CLUSTER_CHANGE_NETINTERFACE_STATE, ClusterNetInterfaceStateUnknown},
    {L"Unavailable", CLUSTER_CHANGE_NETINTERFACE_STATE, ClusterNetInterfaceUnavailable},
    {L"Failed", CLUSTER_CHANGE_NETINTERFACE_STATE, ClusterNetInterfaceFailed},
    {L"Unreachable", CLUSTER_CHANGE_NETINTERFACE_STATE, ClusterNetInterfaceUnreachable},
    {L"Up", CLUSTER_CHANGE_NETINTERFACE_STATE, ClusterNetInterfaceUp},

    {NULL, 0, 0 }
} ;

LPCWSTR GetSubType (PDWORDTOSUBSTRINGMAP pTypeMap, DWORD dwCode, DWORD dwSubCode)
{
    int i = 0;
    while (pTypeMap [i].pszDesc)
    {
        if (pTypeMap [i].dwCode == dwCode &&
            pTypeMap [i].dwSubCode == dwSubCode )
            return pTypeMap [i].pszDesc ;
        i++ ;
    }

    return L"Unknown Type" ;
}


/*
Ini File Manipulating routines.

*/

const LPCWSTR pszDefaultIni = L".\\CLUSMAN.INI" ;

void
RecurseEvalParam (LPCWSTR pszParam, LPWSTR pszValue, LPCWSTR pszSection)
{
    LPCWSTR pszIniFile = _wgetenv (L"CLUSMANINI") ;
    if (!pszIniFile)
        pszIniFile = pszDefaultIni ;

    LPCWSTR pszTmp, pszStart, pszEnd ;
    WCHAR    szVariable [PARAM_LEN], szTmpParam [PARAM_LEN], szTmpValue [PARAM_LEN] ;
    while (*pszParam)
    {
        if (*pszParam != L'%')
            *pszValue++ = *pszParam++ ;
        else  // Has to substitute for the parameter.
        {
            pszEnd = pszStart = pszParam + 1 ;

            while (*pszEnd && *pszEnd != L'%')pszEnd++ ;

            if (!*pszEnd) // Only one % is found. Just copy the string to the value
            {
                while (*pszParam)
                    *pszValue++ = *pszParam++ ;
            }
            else
            {
                pszParam = pszEnd + 1 ;

                wcsncpy (szVariable, pszStart, (UINT)(pszEnd - pszStart)) ;
                szVariable [pszEnd-pszStart] = L'\0' ;

                if (wcslen (szVariable) == 0)
                    continue ;

                pszTmp = _wgetenv (szVariable) ;

                if (pszTmp)  // Env variable found, copy it.
                {
                    RecurseEvalParam (pszTmp, szTmpValue) ;
                    pszTmp = szTmpValue ;

                    while (*pszTmp)
                        *pszValue++ = *pszTmp++ ;
                }
                else  // Now try in the Ini File
                {
                    if (GetPrivateProfileString (pszSection, szVariable, L"", szTmpParam, sizeof (szTmpParam)/sizeof(szTmpParam[0]), pszIniFile) > 0)
                    { // Copied some stuff.

                        RecurseEvalParam (szTmpParam, szTmpValue) ;
                        pszTmp = szTmpValue ;

                        while (*pszTmp)
                            *pszValue++ = *pszTmp++ ;
                    }
                }
            }
        }
    }
    *pszValue = L'\0' ;
}

int RecurseEvalIntParam (LPCWSTR pszParam)
{
    WCHAR szBuf [PARAM_LEN] ;

    RecurseEvalParam (pszParam, szBuf) ;

    return szBuf [0] == L'\0'?0:_wtoi (szBuf) ;
}

void
SaveParam (LPCWSTR pszKey, LPCWSTR pszValue)
{
    LPCWSTR pszIniFile = _wgetenv (L"CLUSMANINI") ;
    if (!pszIniFile)
        pszIniFile = pszDefaultIni ;

    WritePrivateProfileString (L"PARAMETER", pszKey, pszValue, pszIniFile) ;
}


void
SaveIntParam (LPCWSTR pszKey, int iValue)
{
    LPCWSTR pszIniFile = _wgetenv (L"CLUSMANINI") ;
    if (!pszIniFile)
        pszIniFile = pszDefaultIni ;

    WCHAR szBuf [80] ;

    wsprintf (szBuf, L"%d", iValue) ;

    WritePrivateProfileString (L"PARAMETER", pszKey, szBuf, pszIniFile) ;
}

void MemSet (LPWSTR pszBuf, WCHAR c, DWORD cb)
{
    while (cb--)
        *pszBuf++ = c ;
}

int MemCheck (LPCWSTR pszBuf, WCHAR c, DWORD cb)
{
    while (cb--)
        if (*pszBuf++ != c)
            return 1 ;
    return 0 ;
}

// Get the state of the resource of the name of the resource
CLUSTER_RESOURCE_STATE MyGetClusterResourceState (HCLUSTER hCluster, LPCWSTR pszResourceName, LPWSTR pszNodeName, LPWSTR pszGroupName)
{
    HRESOURCE hResource ;
    CLUSTER_RESOURCE_STATE dwState ;
    DWORD cbNodeName, cbGroupName ;

    if (hResource = OpenClusterResource (hCluster, pszResourceName))
    {
        // This is a bug of hard coding the length. Hopefully the code does not crash.
        cbGroupName = (pszGroupName)?80:0 ;
        cbNodeName = (pszNodeName)?80:0 ;
        dwState = GetClusterResourceState (hResource, pszNodeName, &cbNodeName, pszGroupName, &cbGroupName) ;
        CloseClusterResource (hResource) ;
    }
    else
        dwState = ClusterResourceStateUnknown ;

    return dwState ;
}

// Get the state of the Group given the name.
CLUSTER_GROUP_STATE MyGetClusterGroupState (HCLUSTER hCluster, LPCWSTR pszGroupName, LPWSTR pszNodeName)
{
    HGROUP hGroup ;
    CLUSTER_GROUP_STATE dwState ;
    DWORD cbNodeName ;

    if (hGroup = OpenClusterGroup (hCluster, pszGroupName))
    {
        // This is a bug of hard coding the length. Hopefully the code does not crash.
        cbNodeName = (pszNodeName)?80:0 ;
        dwState = GetClusterGroupState (hGroup, pszNodeName, &cbNodeName) ;
        CloseClusterGroup (hGroup) ;
    }
    else
        dwState = ClusterGroupStateUnknown ;

    return dwState ;
}

// Get the state of the Node given the name.
CLUSTER_NODE_STATE MyGetClusterNodeState (HCLUSTER hCluster, LPWSTR pszNodeName)
{
    HNODE hNode ;
    CLUSTER_NODE_STATE dwState ;

    if (hNode = OpenClusterNode (hCluster, pszNodeName))
    {
        dwState = GetClusterNodeState (hNode) ;
        CloseClusterNode (hNode) ;
    }
    else
        dwState = ClusterNodeStateUnknown ;

    return dwState ;
}

// Get the state of the Network given the name.
CLUSTER_NETWORK_STATE MyGetClusterNetworkState (HCLUSTER hCluster, LPWSTR pszNetworkName)
{
    HNETWORK hNetwork ;
    CLUSTER_NETWORK_STATE dwState ;

    if (hNetwork = OpenClusterNetwork (hCluster, pszNetworkName))
    {
        dwState = GetClusterNetworkState (hNetwork) ;
        CloseClusterNetwork (hNetwork) ;
    }
    else
        dwState = ClusterNetworkStateUnknown ;

    return dwState ;
}


// Get the state of the NetInterface given the name.
CLUSTER_NETINTERFACE_STATE MyGetClusterNetInterfaceState (HCLUSTER hCluster, LPWSTR pszNetInterfaceName)
{
    HNETINTERFACE hNetInterface ;
    CLUSTER_NETINTERFACE_STATE dwState ;

    if (hNetInterface = OpenClusterNetInterface (hCluster, pszNetInterfaceName))
    {
        dwState = GetClusterNetInterfaceState (hNetInterface) ;
        CloseClusterNetInterface (hNetInterface) ;
    }
    else
        dwState = ClusterNetInterfaceStateUnknown ;

    return dwState ;
}

// returns 0 on success.
// hCluster is the handle to the cluster.
// pszFileName is filename where to store the cluster information.
#include <stdio.h>
DumpClusterDetails (HCLUSTER hCluster, LPCWSTR pszFileName, LPCWSTR pszComment)
{
    FILE *fp = _wfopen (pszFileName, L"a") ;
    HCLUSENUM hEnum = NULL ;
    DWORD cbNodeName, cbGroupName, cbResourceName, dwEnumType, dwIndex = 0 ;
    BOOL bMoreData = TRUE ;
    WCHAR szNodeName [512], szGroupName [512], szResourceName [512] ;
    DWORD dwState ;

    fwprintf (fp, L"\n*********************************************************************\n") ;
    fwprintf (fp, pszComment) ;
    fwprintf (fp, L"*********************************************************************\n") ;
    __try
    {
        // Dump all the Node Information
        fwprintf (fp, L"DUMP ALL THE NODE  INFORMATION\n------------------------------\n") ;
        if ((hEnum = ClusterOpenEnum (hCluster, CLUSTER_ENUM_NODE)) == NULL)
        {
            fwprintf (fp, L"Clus Open Enum failed for the node\n") ;
            return 1 ;
        }

        while (bMoreData)
        {
            cbNodeName = sizeof (szNodeName)/sizeof (szNodeName[0]) ;
            switch (ClusterEnum (hEnum, dwIndex, &dwEnumType, szNodeName, &cbNodeName))
            {
            case ERROR_SUCCESS:
                dwState = (DWORD) MyGetClusterNodeState (hCluster, szNodeName) ;
                fwprintf (fp, L"%-30s Status:%-30s\n", szNodeName, GetSubType (aSubTypeMap, CLUSTER_CHANGE_NODE_STATE, dwState)) ;
                break ;
            case ERROR_NO_MORE_ITEMS:
                bMoreData = FALSE ;
                break ;
            default:
                fwprintf (fp, L"ClusterEnum returned Invalid Value\n") ;
                bMoreData = FALSE ;
                return 1 ;
            }
            dwIndex++ ;
        }
        ClusterCloseEnum (hEnum) ;

        // Dump all the Group Information
        dwIndex = 0 ;
        bMoreData = TRUE ;
        fwprintf (fp, L"DUMP ALL THE GROUP INFORMATION\n------------------------------\n") ;
        
        if ((hEnum = ClusterOpenEnum (hCluster, CLUSTER_ENUM_GROUP)) == NULL)
        {
            fwprintf (fp, L"Clus Open Enum failed for the node\n") ;
            return 1 ;
        }

        while (bMoreData)
        {
            cbGroupName = sizeof (szGroupName) / sizeof (szGroupName [0]) ;
            switch (ClusterEnum (hEnum, dwIndex, &dwEnumType, szGroupName, &cbGroupName))
            {
            case ERROR_SUCCESS:
                dwState = (DWORD) MyGetClusterGroupState (hCluster, szGroupName, szNodeName) ;
                fwprintf (fp, L"%-30s Node:%-30s Status:%-30s\n", szGroupName, szNodeName, GetSubType (aSubTypeMap, CLUSTER_CHANGE_GROUP_STATE, dwState)) ;
                break ;
            case ERROR_NO_MORE_ITEMS:
                bMoreData = FALSE ;
                break ;
            default:
                fwprintf (fp, L"ClusterEnum returned Invalid Value\n") ;
                bMoreData = FALSE ;
                return 1 ;
            }
            dwIndex++ ;
        }

        ClusterCloseEnum (hEnum) ;

        // Dump all the Resource Information
        dwIndex = 0 ;
        bMoreData = TRUE ;
        fwprintf (fp, L"DUMP ALL THE RESOURCE INFORMATION\n---------------------------------\n") ;
        
        if ((hEnum = ClusterOpenEnum (hCluster, CLUSTER_ENUM_RESOURCE)) == NULL)
        {
            fwprintf (fp, L"Clus Open Enum failed for the node\n") ;
            return 1 ;
        }

        while (bMoreData)
        {
            cbResourceName = sizeof (szResourceName) / sizeof (szResourceName [0]) ;
            switch (ClusterEnum (hEnum, dwIndex, &dwEnumType, szResourceName, &cbResourceName))
            {
            case ERROR_SUCCESS:
                dwState = (DWORD)MyGetClusterResourceState (hCluster, szResourceName, szNodeName, szGroupName) ;
                fwprintf (fp, L"%-30s Node:%-30s Group:%-30s Status:%-30s\n", szResourceName, szNodeName, szGroupName, GetSubType (aSubTypeMap, CLUSTER_CHANGE_RESOURCE_STATE, dwState)) ;
                break ;
            case ERROR_NO_MORE_ITEMS:
                bMoreData = FALSE ;
                break ;
            default:
                fwprintf (fp, L"ClusterEnum returned Invalid Value\n") ;
                bMoreData = FALSE ;
                return 1 ;
            }
            dwIndex++ ;
        }

        ClusterCloseEnum (hEnum) ;

        hEnum = NULL ;

        return 0 ;
    }
    __finally
    {
        if (hEnum)
            ClusterCloseEnum (hEnum) ;
        fclose (fp) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\doc.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    doc.cpp

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#include "stdafx.h"
#include "evtview.h"

#include "Doc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEvtviewDoc

IMPLEMENT_DYNCREATE(CEvtviewDoc, CDocument)

BEGIN_MESSAGE_MAP(CEvtviewDoc, CDocument)
    //{{AFX_MSG_MAP(CEvtviewDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEvtviewDoc construction/destruction

extern CEvtviewDoc *pEventDoc ;

CEvtviewDoc::CEvtviewDoc()
{
    // TODO: add one-time construction code here
    pEventDoc = this ;
    dwCount = 0 ;
    dwMaxCount = 1000 ;

    sThreadParam.hWnd = AfxGetApp ()->m_pMainWnd->GetSafeHwnd () ;
    sThreadParam.pDoc = this ;
    sThreadParam.hEvent = CreateEvent (NULL, FALSE, FALSE, NULL) ;
}

CEvtviewDoc::~CEvtviewDoc()
{
//    TerminateThread (pWorkerThread->m_hThread, 1) ;
    SetEvent (sThreadParam.hEvent) ;
    WaitForSingleObject (pWorkerThread->m_hThread, INFINITE) ;
    ClearAllEvents () ;
}

BOOL CEvtviewDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    // TODO: add reinitialization code here
    // (SDI documents will reuse this document)

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CEvtviewDoc serialization

void CEvtviewDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

void CEvtviewDoc::GotEvent (PEVTFILTER_TYPE p_pEventDetails)
{
    PEVTFILTER_TYPE pEventDetails = new EVTFILTER_TYPE (*p_pEventDetails) ;

    dwCount++ ;
    if ((DWORD)ptrlstEvent.GetCount() >= dwMaxCount)
    {
        delete (PEVTFILTER_TYPE) ptrlstEvent.RemoveHead () ;
    }
    ptrlstEvent.AddTail (pEventDetails) ;
    UpdateAllViews (NULL, (LPARAM)pEventDetails) ;
}

void CEvtviewDoc::ClearAllEvents ()
{
    dwCount = 0 ;
    POSITION pos = ptrlstEvent.GetHeadPosition () ;
    while (pos)
        delete (PEVTFILTER_TYPE) ptrlstEvent.GetNext (pos) ;
    ptrlstEvent.RemoveAll () ;
    UpdateAllViews (NULL, 0) ;
}


/////////////////////////////////////////////////////////////////////////////
// CEvtviewDoc diagnostics

#ifdef _DEBUG
void CEvtviewDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CEvtviewDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CEvtviewDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\clusname.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusname.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
// CGetClusterName dialog

class CGetClusterName : public CDialog
{
// Construction
public:
    CString    m_stClusterName;
    CGetClusterName(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CGetClusterName)
    enum { IDD = IDD_GETCLUSTERNAME };
    CComboBox    m_ctrlClusterName;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CGetClusterName)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CGetClusterName)
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\doc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    doc.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/
//
/////////////////////////////////////////////////////////////////////////////
#include "globals.h"

class CEvtviewDoc : public CDocument
{
protected: // create from serialization only
    CEvtviewDoc();
    DECLARE_DYNCREATE(CEvtviewDoc)

// Attributes
public:
    CPtrList ptrlstEvent ;
    DWORD dwCount, dwMaxCount ;
    CWinThread *pWorkerThread ;
    EVENTTHREADPARAM sThreadParam ;

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEvtviewDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEvtviewDoc();

    void GotEvent (PEVTFILTER_TYPE pEventDetails) ;
    void ClearAllEvents () ;
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CEvtviewDoc)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\dofilter.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dofilter.cpp

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#include "stdafx.h"
#include "evtview.h"
#include "DOFilter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDefineObjectFilter dialog


CDefineObjectFilter::CDefineObjectFilter(CWnd* pParent /*=NULL*/)
    : CDialog(CDefineObjectFilter::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDefineObjectFilter)
    m_stObjectFilter = _T("");
    //}}AFX_DATA_INIT
}


void CDefineObjectFilter::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDefineObjectFilter)
    DDX_Text(pDX, IDC_OBJECTFILTER, m_stObjectFilter);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDefineObjectFilter, CDialog)
    //{{AFX_MSG_MAP(CDefineObjectFilter)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDefineObjectFilter message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\dtfilter.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dtfilter.cpp

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#include "stdafx.h"
#include "globals.h"
#include "evtview.h"
#include "DTFilter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDefineTypeFilter dialog


CDefineTypeFilter::CDefineTypeFilter(CWnd* pParent /*=NULL*/)
    : CDialog(CDefineTypeFilter::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDefineTypeFilter)
    m_stTypeFilter = _T("");
    //}}AFX_DATA_INIT
}


void CDefineTypeFilter::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDefineTypeFilter)
    DDX_CBString(pDX, IDC_TYPEFILTER, m_stTypeFilter);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDefineTypeFilter, CDialog)
    //{{AFX_MSG_MAP(CDefineTypeFilter)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDefineTypeFilter message handlers

BOOL CDefineTypeFilter::OnInitDialog() 
{
    CDialog::OnInitDialog();

    CComboBox *pTypeFilter = (CComboBox *) GetDlgItem (IDC_TYPEFILTER) ;
    PEVENTDEFINITION pEvtDef ;
    PDWORDTOSTRINGMAP pTypeMap ;

    POSITION pos = ptrlstEventDef.GetHeadPosition () ;

    int i ;
    while (pos)
    {
        i = 0 ;
        pEvtDef = (PEVENTDEFINITION) ptrlstEventDef.GetNext (pos) ;

        pTypeMap = pEvtDef->pFilter ;
        while (pTypeMap [i].pszDesc)
        {
            pTypeFilter->AddString (pTypeMap [i].pszDesc) ;
            // pTypeFilter->SetItemData (i, pTypeMap [i].dwCode) ;
            i++ ;
        }
    }
    
    if (i)
        pTypeFilter->SetCurSel (0) ;

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\dtfilter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dtfilter.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
// CDefineTypeFilter dialog

class CDefineTypeFilter : public CDialog
{
// Construction
public:
    CDefineTypeFilter(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CDefineTypeFilter)
    enum { IDD = IDD_DEFINETYPEFILTER };
    CString    m_stTypeFilter;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDefineTypeFilter)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CDefineTypeFilter)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\einfodlg.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    einfodlg.cpp

Abstract:
    



Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#include "stdafx.h"
#include "evtview.h"
#include "EInfodlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScheduleEventInfo dialog


CScheduleEventInfo::CScheduleEventInfo(CWnd* pParent /*=NULL*/)
    : CDialog(CScheduleEventInfo::IDD, pParent)
{
    //{{AFX_DATA_INIT(CScheduleEventInfo)
    m_stSourceName = _T("");
    m_stSCatagory = _T("");
    m_stSFilter = _T("");
    m_stSSourceName = _T("");
    m_stSSubFilter = _T("");
    m_stSObjectName = _T("");
    m_stObjectName = _T("");
    //}}AFX_DATA_INIT
}


void CScheduleEventInfo::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CScheduleEventInfo)
    DDX_Control(pDX, IDC_CATAGORY, m_ctrlCatagory);
    DDX_Control(pDX, IDC_SUBFILTER, m_ctrlSubFilter);
    DDX_Control(pDX, IDC_FILTER, m_ctrlFilter);
    DDX_Text(pDX, IDC_SOURCENAME, m_stSourceName);
    DDX_Text(pDX, IDC_SCATAGORY, m_stSCatagory);
    DDX_Text(pDX, IDC_SFILTER, m_stSFilter);
    DDX_Text(pDX, IDC_SSOURCENAME, m_stSSourceName);
    DDX_Text(pDX, IDC_SSUBFILTER, m_stSSubFilter);
    DDX_Text(pDX, IDC_SOBJECTNAME, m_stSObjectName);
    DDX_Text(pDX, IDC_OBJECTNAME, m_stObjectName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScheduleEventInfo, CDialog)
    //{{AFX_MSG_MAP(CScheduleEventInfo)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleEventInfo message handlers

void CScheduleEventInfo::OnOK() 
{
    UpdateData (TRUE) ;

    sEventInfo.dwCatagory = m_ctrlCatagory.GetItemData (m_ctrlCatagory.GetCurSel()) ;
    sEventInfo.dwFilter = m_ctrlFilter.GetItemData (m_ctrlFilter.GetCurSel()) ;
    sEventInfo.dwSubFilter = m_ctrlSubFilter.GetItemData (m_ctrlSubFilter.GetCurSel()) ;
    wcscpy (sEventInfo.szSourceName, m_stSourceName) ;
    wcscpy (sEventInfo.szObjectName, m_stObjectName) ;

    
    CDialog::OnOK();
}

void CScheduleEventInfo::InitializeFilter ()
{
    ULONG_PTR dwCatagory = m_ctrlCatagory.GetItemData (m_ctrlCatagory.GetCurSel ()) ;
    
    ASSERT (dwCatagory != CB_ERR) ;

    PEVENTDEFINITION pEvtDef = GetEventDefinition (dwCatagory) ;

    PDWORDTOSTRINGMAP pTypeMap ;
    pTypeMap = pEvtDef->pFilter ;
    int i = 0;
    while (pTypeMap [i].pszDesc)
    {
        // BUBBUG No Idea why this works and the other crashes.
        CString st = pTypeMap [i].pszDesc ;
        m_ctrlFilter.AddString (st) ;

//        m_ctrlFilter.AddString (pTypeMap [i].pszDesc) ;
        m_ctrlFilter.SetItemData (i, pTypeMap [i].dwCode) ;
        i++ ;
    }

    if (i)
        m_ctrlFilter.SetCurSel (0) ;
}

BOOL CScheduleEventInfo::OnInitDialog() 
{
    CDialog::OnInitDialog();

    POSITION pos = ptrlstEventDef.GetHeadPosition () ;
    PEVENTDEFINITION pEvtDef ;
    int i = 0;
    while (pos)
    {
        pEvtDef = (PEVENTDEFINITION) ptrlstEventDef.GetNext (pos) ;

        m_ctrlCatagory.AddString (pEvtDef->szCatagory) ;
        m_ctrlCatagory.SetItemData (i, pEvtDef->dwCatagory) ;
        i ++ ;
    }

    m_ctrlCatagory.SetCurSel (0) ;


    m_stSCatagory = pEvtDef->szCatagory ;
    m_stSFilter = pEvtDef->szFilterPrompt ;
    m_stSSourceName = pEvtDef->szSourceNamePrompt ;
    m_stSSubFilter = pEvtDef->szSubFilterPrompt ;
    m_stSObjectName = pEvtDef->szObjectNamePrompt ;

    InitializeFilter () ;

    UpdateData (FALSE) ;

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\efilter.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    efilter.cpp

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#include "stdafx.h"
#include "evtview.h"
#include "EFilter.h"

#include "DTFilter.h"
#include "DOFilter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEventFilter dialog


CEventFilter::CEventFilter(
           CStringList &p_stlstObjectFilter, CStringList &p_stlstObjectIncFilter, CStringList &p_stlstTypeFilter, CStringList &p_stlstTypeIncFilter,

                CWnd* pParent /*=NULL*/)
    : stlstObjectFilter(p_stlstObjectFilter),
    stlstObjectIncFilter(p_stlstObjectIncFilter),
    stlstTypeFilter (p_stlstTypeFilter),
    stlstTypeIncFilter (p_stlstTypeIncFilter),
    CDialog(CEventFilter::IDD, pParent)
{
    //{{AFX_DATA_INIT(CEventFilter)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CEventFilter::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEventFilter)
    DDX_Control(pDX, IDC_TYPEINCFILTERLIST, m_TypeIncFilterList);
    DDX_Control(pDX, IDC_TYPEFILTERLIST, m_TypeFilterList);
    DDX_Control(pDX, IDC_OBJECTINCFILTERLIST, m_ObjectIncFilterList);
    DDX_Control(pDX, IDC_OBJECTFILTERLIST, m_ObjectFilterList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEventFilter, CDialog)
    //{{AFX_MSG_MAP(CEventFilter)
    ON_BN_CLICKED(IDC_ADDOBJECTFILTER, OnAddobjectfilter)
    ON_BN_CLICKED(IDC_ADDOBJECTINCFILTER, OnAddobjectincfilter)
    ON_BN_CLICKED(IDC_ADDTYPEFILTER, OnAddtypefilter)
    ON_BN_CLICKED(IDC_ADDTYPEINCFILTER, OnAddtypeincfilter)
    ON_BN_CLICKED(IDC_REMOVEOBJECTFILTER, OnRemoveobjectfilter)
    ON_BN_CLICKED(IDC_REMOVEOBJECTINCFILTER, OnRemoveobjectincfilter)
    ON_BN_CLICKED(IDC_REMOVETYPEFILTER, OnRemovetypefilter)
    ON_BN_CLICKED(IDC_REMOVETYPEINCFILTER, OnRemovetypeincfilter)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEventFilter message handlers

void CEventFilter::OnAddobjectfilter() 
{
    CDefineObjectFilter oObjectFilter ;

    if (oObjectFilter.DoModal () == IDOK)
        m_ObjectFilterList.AddString (oObjectFilter.m_stObjectFilter) ;
}

void CEventFilter::OnAddobjectincfilter() 
{
    CDefineObjectFilter oObjectFilter ;

    if (oObjectFilter.DoModal () == IDOK)
        m_ObjectIncFilterList.AddString (oObjectFilter.m_stObjectFilter) ;
}

void CEventFilter::OnAddtypefilter() 
{
    CDefineTypeFilter oTypeFilter ;

    if (oTypeFilter.DoModal () == IDOK)
        m_TypeFilterList.AddString (oTypeFilter.m_stTypeFilter) ;
}

void CEventFilter::OnAddtypeincfilter() 
{
    CDefineTypeFilter oTypeFilter ;

    if (oTypeFilter.DoModal () == IDOK)
        m_TypeIncFilterList.AddString (oTypeFilter.m_stTypeFilter) ;
}

void CEventFilter::OnRemoveobjectfilter() 
{
    m_ObjectFilterList.DeleteString(m_ObjectFilterList.GetCurSel ()) ;
}

void CEventFilter::OnRemoveobjectincfilter() 
{
    m_ObjectIncFilterList.DeleteString(m_ObjectIncFilterList.GetCurSel ()) ;
}

void CEventFilter::OnRemovetypefilter() 
{
    m_TypeFilterList.DeleteString(m_TypeFilterList.GetCurSel ()) ;
}

void CEventFilter::OnRemovetypeincfilter() 
{
    m_TypeIncFilterList.DeleteString(m_TypeIncFilterList.GetCurSel ()) ;
}

BOOL CEventFilter::OnInitDialog() 
{
    CDialog::OnInitDialog();
    CString st ;

    POSITION pos ;

    pos = stlstObjectFilter.GetHeadPosition () ;

    while (pos)
    {
        st = stlstObjectFilter.GetNext (pos) ;
        m_ObjectFilterList.AddString (st) ;
    }
    
    pos = stlstObjectIncFilter.GetHeadPosition () ;

    while (pos)
    {
        st = stlstObjectIncFilter.GetNext (pos) ;
        m_ObjectIncFilterList.AddString (st) ;
    }
    
    pos = stlstTypeFilter.GetHeadPosition () ;

    while (pos)
    {
        st = stlstTypeFilter.GetNext (pos) ;
        m_TypeFilterList.AddString (st) ;
    }
    
    pos = stlstTypeIncFilter.GetHeadPosition () ;

    while (pos)
    {
        st = stlstTypeIncFilter.GetNext (pos) ;
        m_TypeIncFilterList.AddString (st) ;
    }
    
    return TRUE; 
}

void CEventFilter::OnOK() 
{
    POSITION pos = stlstObjectFilter.GetHeadPosition () ;
    CString st ;

    stlstObjectFilter.RemoveAll () ;
    stlstObjectIncFilter.RemoveAll () ;
    stlstTypeFilter.RemoveAll () ;
    stlstTypeIncFilter.RemoveAll () ;


    for (int i =0; i < m_ObjectFilterList.GetCount () ; i++)
    {
        m_ObjectFilterList.GetText (i, st) ;
        stlstObjectFilter.AddTail (st) ;
    }

    for (i =0; i < m_ObjectIncFilterList.GetCount () ; i++)
    {
        m_ObjectIncFilterList.GetText (i, st) ;
        stlstObjectIncFilter.AddTail (st) ;
    }

    for (i =0; i < m_TypeFilterList.GetCount () ; i++)
    {
        m_TypeFilterList.GetText (i, st) ;
        stlstTypeFilter.AddTail (st) ;
    }

    for (i =0; i < m_TypeIncFilterList.GetCount () ; i++)
    {
        m_TypeIncFilterList.GetText (i, st) ;
        stlstTypeIncFilter.AddTail (st) ;
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\dofilter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dofilter.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
// CDefineObjectFilter dialog

class CDefineObjectFilter : public CDialog
{
// Construction
public:
    CDefineObjectFilter(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CDefineObjectFilter)
    enum { IDD = IDD_DEFINEOBJECTFILTER };
    CString    m_stObjectFilter;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDefineObjectFilter)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CDefineObjectFilter)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\evtview.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    evtview.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEvtviewApp:
// See evtview.cpp for the implementation of this class
//

class CEvtviewApp : public CWinApp
{
public:
	CEvtviewApp();

	void OnFileNew () { CWinApp::OnFileNew() ; } ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEvtviewApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	virtual BOOL OnIdle(LONG lCount);
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CEvtviewApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\evtview.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    evtview.cpp

Abstract:
    Defines the class behaviors for the application.



Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

#include "stdafx.h"
#include "evtview.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "Doc.h"
#include "ListView.h"
#include "globals.h"
#include "getevent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEvtviewApp

BEGIN_MESSAGE_MAP(CEvtviewApp, CWinApp)
    //{{AFX_MSG_MAP(CEvtviewApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEvtviewApp construction

CEvtviewApp::CEvtviewApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEvtviewApp object

CEvtviewApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEvtviewApp initialization

BOOL CEvtviewApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();            // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();    // Call this when linking to MFC statically
#endif

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CMultiDocTemplate* pDocTemplate;
    pDocTemplate = new CMultiDocTemplate(
        IDR_EVTVIETYPE,
        RUNTIME_CLASS(CEvtviewDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CEventListView));
    AddDocTemplate(pDocTemplate);

    // c`reate main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

/*
    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;
*/
    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();

    ScheduleInit () ;
    EventInit () ;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CEvtviewApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CEvtviewApp commands

int CEvtviewApp::ExitInstance() 
{
    ScheduleDeInit() ;
    EventDeInit () ;

    return CWinApp::ExitInstance();
}

BOOL CEvtviewApp::OnIdle(LONG lCount) 
{
    return CWinApp::OnIdle(lCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\efilter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    efilter.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
// CEventFilter dialog

class CEventFilter : public CDialog
{
// Construction
    CStringList & stlstObjectFilter, &stlstObjectIncFilter, &stlstTypeFilter, &stlstTypeIncFilter ;
public:
    CEventFilter(CStringList &p_stlstObjectFilter, CStringList &p_stlstObjectIncFilter, CStringList &p_stlstTypeFilter, CStringList &p_stlstTypeIncFilter, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CEventFilter)
    enum { IDD = IDD_EVENT_FILTER };
    CListBox    m_TypeIncFilterList;
    CListBox    m_TypeFilterList;
    CListBox    m_ObjectIncFilterList;
    CListBox    m_ObjectFilterList;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEventFilter)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEventFilter)
    afx_msg void OnAddobjectfilter();
    afx_msg void OnAddobjectincfilter();
    afx_msg void OnAddtypefilter();
    afx_msg void OnAddtypeincfilter();
    afx_msg void OnRemoveobjectfilter();
    afx_msg void OnRemoveobjectincfilter();
    afx_msg void OnRemovetypefilter();
    afx_msg void OnRemovetypeincfilter();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\getevent.h ===
#ifndef _GETEVENT_H_
#define _GETEVENT_H_

EventInit () ;
void EventDeInit () ;

DWORD EventThread (EVENTTHREADPARAM *pThreadParam) ;


#endif // _GETEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\einfodlg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    einfodlg.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
// CScheduleEventInfo dialog
#include "globals.h"

class CScheduleEventInfo : public CDialog
{
// Construction
    void InitializeFilter () ;
public:
    DWORD dwCatagory ;
    struct SCHEDULE_EVENTINFO sEventInfo ;

    CScheduleEventInfo(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CScheduleEventInfo)
    enum { IDD = IDD_SCEDULEEVENTINFO };
    CComboBox    m_ctrlCatagory;
    CComboBox    m_ctrlSubFilter;
    CComboBox    m_ctrlFilter;
    CString    m_stObjectName;
    CString    m_stSCatagory;
    CString    m_stSFilter;
    CString    m_stSObjectName;
    CString    m_stSSubFilter;
    CString    m_stSSourceName;
    CString    m_stSourceName;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScheduleEventInfo)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CScheduleEventInfo)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\globals.cpp ===
#include "stdafx.h"
#include "evtview.h"
#include "doc.h"
#include "clusapi.h"

#include "schview.h"

CEvtviewDoc *pEventDoc ;

CPtrList ptrlstSInfo ;

EVENTDEFINITION aClusEventDefinition = {
	EVENT_CATAGORY_CLUSTER,
		aTypeMap,
		aSubTypeMap,
		L"CLUSTER",
		L"Filter Type:",
		L"Sub Filter",
		L"Cluster Name",
		L"Object Name"
} ;


DWORDTOSTRINGMAP aClusConsistTypeMap [] =
{
	{L"CONSISTENCY", EVENT_FILTER_CONSISTENCY},
	{NULL, 0 }
} ;


EVENTDEFINITION aClusConsistEventDefinition = {
	EVENT_CATAGORY_CLUSTER_CONSISTENCY,
		aClusConsistTypeMap,
		NULL,
		L"CLUSTER CONSISTENCY",
		L"Filter Type:",
		L"Sub Filter",
		L"Cluster Name",
		L"Object Name"
} ;


DWORDTOSTRINGMAP aAction [] = {
	{L"COMMAND", SCHEDULE_ACTION_COMMAND },
	{NULL, 0 },
} ;

HWND hScheduleWnd  ;
//CTime minTime ;
UINT_PTR nIDTimer ;

CPtrList ptrlstEventDef ;

// For the modeless dialog to display the event list

CScheduleView oScheduleView ;



PEVENTDEFINITION GetEventDefinition (DWORD_PTR dwCatagory)
{
	POSITION pos = ptrlstEventDef.GetHeadPosition () ;
	PEVENTDEFINITION pEvtDef ;
	while (pos)
	{
		pEvtDef = (PEVENTDEFINITION) ptrlstEventDef.GetNext (pos) ;

		if (pEvtDef->dwCatagory == dwCatagory)
			return pEvtDef ;
	}
	return NULL ;
}

LPCWSTR GetType (DWORD_PTR dwCatagory, DWORD_PTR dwCode)
{
	int i = 0;
	PEVENTDEFINITION pEvtDef = GetEventDefinition (dwCatagory) ;

	return GetType (pEvtDef->pFilter, dwCode) ;
}

LPCWSTR GetSubType (DWORD_PTR dwCatagory, DWORD dwCode, DWORD dwSubCode)
{
	int i = 0;
	PEVENTDEFINITION pEvtDef = GetEventDefinition (dwCatagory) ;

	LPCWSTR psz = GetSubType (pEvtDef->pSubFilter, dwCode, dwSubCode) ;

	return (wcscmp (psz, L"Unknown Type") == 0)?L"":psz ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\getevent.cpp ===
#include "stdafx.h"
#include <stdlib.h>
#include <clusapi.h>
#include <stdio.h>
#include "globals.h"
#include "doc.h"
#include "time.h"

EventInit ()
{
    ptrlstEventDef.AddTail (&aClusEventDefinition) ;
    return 0 ;
}

void
EventDeInit ()
{
}

DWORD EventThread (EVENTTHREADPARAM *pThreadParam)
{
    DWORD dwFilter ;
    HCLUSTER hCluster ;
    HCHANGE hChange = (HCHANGE)INVALID_HANDLE_VALUE ;
    DWORD_PTR dwNotifyKey ;
    DWORD dwFilterType ;
    WCHAR* szObjectName ;
    DWORD cbszObjectBuffer ;
    DWORD cbszObjectName ;
    DWORD dwStatus, dwCount = 0 ;
    HRESOURCE hResource ;
    HGROUP hGroup ;
    DWORD cbGroupName, cbNodeName ;

    EVTFILTER_TYPE sEventDetails ;

    sEventDetails.dwCatagory = EVENT_CATAGORY_CLUSTER ;

    wcscpy (sEventDetails.szSourceName, pThreadParam->szSourceName) ;

    dwFilter = CLUSTER_CHANGE_ALL ;
    if ( lstrcmp(pThreadParam->szSourceName, L"." ) == 0 ) {
        hCluster=OpenCluster(NULL);
    } else {
        hCluster=OpenCluster(pThreadParam->szSourceName);
    }

    if (hCluster)
    {
        hChange = CreateClusterNotifyPort (hChange, hCluster, dwFilter, 0) ;

        if (!hChange)
            PostMessage (pThreadParam->hWnd, WM_EXITEVENTTHREAD, (WPARAM)pThreadParam->pDoc, 0) ;

        cbszObjectBuffer = 256 ;
        szObjectName = new WCHAR[cbszObjectBuffer] ;

        if ( szObjectName == NULL )
        {
            printf ("Could not allocate a buffer.\n" );
            PostMessage (pThreadParam->hWnd, WM_EXITEVENTTHREAD, (WPARAM)pThreadParam->pDoc, 0) ;            
        }

        while (hChange && szObjectName != NULL)
        {
            cbszObjectName = cbszObjectBuffer;

            dwStatus = GetClusterNotify (hChange, &dwNotifyKey, &dwFilterType,
                szObjectName, &cbszObjectName, 1000) ;

            if (dwStatus == ERROR_MORE_DATA)
            {
                ++cbszObjectName;
                cbszObjectBuffer = cbszObjectName;

                delete [] szObjectName;

                szObjectName = new WCHAR[cbszObjectBuffer] ;

                if ( szObjectName == NULL )
                {
                    printf ("Could not allocate a buffer.\n" );
                    PostMessage (pThreadParam->hWnd, WM_EXITEVENTTHREAD, (WPARAM)pThreadParam->pDoc, 0) ;            
                }

                cbszObjectName = cbszObjectBuffer;

                dwStatus = GetClusterNotify (hChange, &dwNotifyKey, &dwFilterType,
                    szObjectName, &cbszObjectName, 0) ;
            }

            if (dwStatus == ERROR_SUCCESS)
            {
                cbNodeName = 0 ;
                cbGroupName = 0 ;
                switch (dwFilterType)
                {
                case CLUSTER_CHANGE_RESOURCE_STATE:
                    sEventDetails.dwSubFilter  = MyGetClusterResourceState (hCluster, szObjectName, NULL, NULL) ;
                    break ;
                case CLUSTER_CHANGE_GROUP_STATE:
                    sEventDetails.dwSubFilter  = MyGetClusterGroupState (hCluster, szObjectName, NULL) ;
                    break ;
                case CLUSTER_CHANGE_NODE_STATE:
                    sEventDetails.dwSubFilter  = MyGetClusterNodeState (hCluster, szObjectName) ;
                    break ;
                case CLUSTER_CHANGE_NETWORK_STATE:
                    sEventDetails.dwSubFilter  = MyGetClusterNetworkState (hCluster, szObjectName) ;
                    break ;
                case CLUSTER_CHANGE_NETINTERFACE_STATE:
                    sEventDetails.dwSubFilter  = MyGetClusterNetInterfaceState (hCluster, szObjectName) ;
                    break ;
                }
                time (&sEventDetails.time) ;

                sEventDetails.dwFilter = dwFilterType ;
                wcscpy (sEventDetails.szObjectName, szObjectName) ;

                SendMessage (pThreadParam->hWnd, WM_GOTEVENT, (WPARAM)pThreadParam->pDoc, (LPARAM)&sEventDetails) ;
                SendMessage (hScheduleWnd, WM_GOTEVENT, (WPARAM)pThreadParam->pDoc, (LPARAM)&sEventDetails) ;
            }
            else if (dwStatus == WAIT_TIMEOUT)
            {
            }
            else
            {
                printf ("GetClusterNotifyFailed") ;
                PostMessage (pThreadParam->hWnd, WM_EXITEVENTTHREAD, (WPARAM)pThreadParam->pDoc, 0) ;
                break ;
            }
            if (WaitForSingleObject (pThreadParam->hEvent, 0) == WAIT_OBJECT_0)
            {
                break ;
            }
        }
        CloseClusterNotifyPort (hChange) ;

        CloseCluster (hCluster) ;

        if (szObjectName != NULL)
        {
            delete [] szObjectName;
        }
    }
    else
    {
        printf ("Could Not open the Cluster Handle\n") ;
        PostMessage (pThreadParam->hWnd, WM_EXITEVENTTHREAD, (WPARAM)pThreadParam->pDoc, 0) ;
    }

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\globals.h ===
#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#include "clusapi.h"
#include "clusutil.h"

#define NAME_LEN	80

#define WM_GOTEVENT			WM_USER + 1
#define WM_EXITEVENTTHREAD	WM_USER + 2
#define WM_REFRESH			WM_USER + 3


// Event Defintions


typedef struct {
	DWORD     dwCatagory ;
	time_t    time ;
	DWORD     dwFilter ;
	DWORD     dwSubFilter ;
	WCHAR	  szSourceName[NAME_LEN] ;
	WCHAR	  szObjectName[NAME_LEN] ;
} EVTFILTER_TYPE, *PEVTFILTER_TYPE ;


// Event Catagories

#define EVENT_CATAGORY_CLUSTER				1
#define	EVENT_CATAGORY_CLUSTER_CONSISTENCY	2


// Event filter definitions

#define EVENT_FILTER	1
#define EVENT_SUBFILTER	2

// Define Distinct Types of Events.
// Events Generated By the clustering system.

struct EVENTDEFINITION {
	DWORD_PTR dwCatagory ;

	PDWORDTOSTRINGMAP pFilter ;
	PDWORDTOSUBSTRINGMAP pSubFilter ;

	WCHAR szCatagory [NAME_LEN] ;
	WCHAR szFilterPrompt [NAME_LEN] ;
	WCHAR szSubFilterPrompt [NAME_LEN] ;
	WCHAR szSourceNamePrompt [NAME_LEN] ;
	WCHAR szObjectNamePrompt [NAME_LEN] ;
} ;

typedef EVENTDEFINITION *PEVENTDEFINITION ;

struct EVENTTHREADPARAM
{
	HWND hWnd ;
	CDocument *pDoc ;
	WCHAR szSourceName [NAME_LEN] ;
	HANDLE hEvent ;
} ;

extern CPtrList ptrlstEventDef ;

// Clustering Related

extern EVENTDEFINITION aClusEventDefinition ;



// For Cluster Consistency Checks.

#define	EVENT_FILTER_CONSISTENCY 1

// -1 in any of the following stands for any value
#define SCHEDULE_SUNDAY		1
#define SCHEDULE_MONDAY		2
#define SCHEDULE_TUESDAY	4
#define SCHEDULE_WEDNESDAY	8
#define SCHEDULE_THURSDAY	16
#define SCHEDULE_FRIDAY		32
#define SCHEDULE_SATURDAY	64


// Action Type definitions.

#define SCHEDULE_ACTION_COMMAND 1

struct SCHEDULE_TIMEINFO
{
	int iYear ;
	int iMonth ;
	int iDay ;
	int iHour ;
	int iMin ;
	int iSec ;
	int iWeekDay ;
	CTime ctime ;
} ;

struct SCHEDULE_EVENTINFO
{
	DWORD_PTR dwCatagory ;
	DWORD_PTR dwFilter ;
	DWORD_PTR dwSubFilter ; // online or Offline or Fail or Pause
	WCHAR szSourceName [NAME_LEN] ;
	WCHAR szObjectName [NAME_LEN] ;
} ;

struct SCHEDULE_ACTIONINFO
{
    DWORD_PTR dwActionType ;
	CString   stParam ;
} ;

struct SCHEDULE_INFO
{
	CTime	minTime ;
	CPtrList lstTimeInfo ;  // List of SCHEDULE_TIMEINFO
	CPtrList lstEventInfo ; // List of SCHEDULE_EVENTINFO
	CPtrList lstActionInfo ; // List of SCHEDULE_ACTIONINFO
} ;


extern DWORDTOSTRINGMAP aAction [] ;



//extern CTime minTime ;
extern HWND     hScheduleWnd  ;
extern UINT_PTR nIDTimer ;
extern CPtrList ptrlstSInfo ;

// For the modeless dialog to display the event list

LPCWSTR GetType (DWORD_PTR dwCatagory, DWORD_PTR dwCode) ;
LPCWSTR GetSubType (DWORD_PTR dwCatagory, DWORD dwCode, DWORD dwSubCode) ;
extern PEVENTDEFINITION GetEventDefinition (DWORD_PTR dwType) ;


// Functions defined in schedule.cpp
extern AddSchedule () ;
extern ModifySchedule (SCHEDULE_INFO *pSOldInfo) ;
extern ScheduleInit () ;
extern void ScheduleDeInit() ;
extern void ResetTimer () ;
extern void FreeEventList (CPtrList &ptrlst) ;
extern void FreeActionList (CPtrList &ptrlst) ;
extern void FreeTimeList (CPtrList &ptrlst) ;
void ComputeAbsoluteTime (SCHEDULE_INFO *pSInfo) ;



#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\listview.cpp ===
// ListView.cpp : implementation file
//

#include "stdafx.h"

#include "evtview.h"
#include "Doc.h"

#include "clusapi.h"
#include "globals.h"

#include "ListView.h"
#include "Efilter.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEventListView

IMPLEMENT_DYNCREATE(CEventListView, CListView)

CEventListView::CEventListView()
{
}

CEventListView::~CEventListView()
{
}


BEGIN_MESSAGE_MAP(CEventListView, CListView)
	//{{AFX_MSG_MAP(CEventListView)
	ON_COMMAND(IDM_EVENT_CLEARALLEVENTS, OnEventClearallevents)
	ON_COMMAND(IDM_EVENT_FILTER, OnEventFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEventListView drawing

void CEventListView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CEventListView diagnostics

#ifdef _DEBUG
void CEventListView::AssertValid() const
{
	CListView::AssertValid();
}

void CEventListView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CEventListView message handlers

BOOL CEventListView::PreCreateWindow(CREATESTRUCT& cs) 
{

	cs.style &= ~LVS_TYPEMASK ;
	cs.style |= LVS_REPORT ;
	
	return CListView::PreCreateWindow(cs);
}



void CEventListView::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	CListCtrl & ctrl = GetListCtrl() ;
	ctrl.InsertColumn (0, L"Seq No.", LVCFMT_LEFT, 70, 0) ;
	ctrl.InsertColumn (1, L"Event Type", LVCFMT_LEFT, 150) ;
	ctrl.InsertColumn (2, L"Sub Type", LVCFMT_LEFT, 150) ;
	ctrl.InsertColumn (3, L"Object", LVCFMT_LEFT, 250) ;
	ctrl.InsertColumn (4, L"Time Received", LVCFMT_LEFT, 100) ;
}

void CEventListView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	CEvtviewDoc *pDoc = (CEvtviewDoc *) GetDocument () ;

	PEVTFILTER_TYPE pEvtFilter = (PEVTFILTER_TYPE) lHint ;
//	WCHAR szBuf [256] ;
	if (pEvtFilter)
	{
		if ((DWORD)GetListCtrl().GetItemCount () >= pDoc->dwMaxCount)
			GetListCtrl().DeleteItem (GetListCtrl().GetItemCount ()-1) ;

		if (pEvtFilter && IsQualified(pEvtFilter))
		{
			ShowEvent (pEvtFilter, pDoc->dwCount) ;
		}
	}
	else
		OnInitialize () ;
}

void CEventListView::ShowEvent (PEVTFILTER_TYPE pEvtFilter, DWORD dwCount)
{
	WCHAR szBuf [25] ;
	CTime t = CTime (pEvtFilter->time) ;
	CListCtrl & ctrl = GetListCtrl() ;

//	wsprintf (pszBuf, L"%-6d %-15.15s %-20.20s %-20.20s %-15s", dwCount, pEvtFilter->szSourceName, GetType (pEvtFilter->dwCatagory, EVENT_FILTER, pEvtFilter->dwFilter), pEvtFilter->szObjectName, t.Format(L"%d %b,%H:%M:%S")) ;
	wsprintf (szBuf, L"%d", dwCount) ;
	ctrl.InsertItem (0, szBuf) ;
	ctrl.SetItemText (0, 1, GetType (pEvtFilter->dwCatagory, pEvtFilter->dwFilter)) ;
	ctrl.SetItemText (0, 2, GetSubType (pEvtFilter->dwCatagory, pEvtFilter->dwFilter, pEvtFilter->dwSubFilter)) ;
	ctrl.SetItemText (0, 3, pEvtFilter->szObjectName) ;
	ctrl.SetItemText (0, 4, t.Format(L"%d %b,%H:%M:%S")) ;
}

BOOL CEventListView::IsQualified (PEVTFILTER_TYPE pEvtFilterType)
{
	BOOL bIsQualified = TRUE ;

	if (stlstTypeIncFilter.GetCount() && !stlstTypeIncFilter.Find(GetType (pEvtFilterType->dwCatagory, pEvtFilterType->dwFilter)))
		bIsQualified = FALSE ;
	else
	{
		if (stlstObjectIncFilter.GetCount() && !stlstObjectIncFilter.Find (pEvtFilterType->szObjectName))
			bIsQualified = FALSE ;
		else
		{
			if (stlstTypeFilter.Find(GetType (pEvtFilterType->dwCatagory, pEvtFilterType->dwFilter)))
				bIsQualified = FALSE ;
			else
			{
				if (stlstObjectFilter.Find (pEvtFilterType->szObjectName))
					bIsQualified = FALSE ;
			}
		}
	}
	return bIsQualified ;	
}

void CEventListView::OnEventClearallevents() 
{
	CEvtviewDoc *pDoc = (CEvtviewDoc *) GetDocument () ;

	pDoc->ClearAllEvents () ;
}

void CEventListView::OnEventFilter() 
{
	CEventFilter oEventFilter (stlstObjectFilter, stlstObjectIncFilter, stlstTypeFilter, stlstTypeIncFilter) ;

	if (oEventFilter.DoModal () == IDOK)
		OnInitialize () ;
}

void CEventListView::OnInitialize() 
{
	CEvtviewDoc *pEventDoc = (CEvtviewDoc *) GetDocument () ;

	DWORD dwCount = pEventDoc->dwCount ;
	
	GetListCtrl ().DeleteAllItems () ;

	CPtrList *pPtrList = &pEventDoc->ptrlstEvent ;
	POSITION pos = pPtrList->GetTailPosition () ;

	PEVTFILTER_TYPE pEvtFilter ;

	while (pos)
	{
		pEvtFilter = (PEVTFILTER_TYPE) pPtrList->GetPrev (pos) ;

		if (pEvtFilter && IsQualified(pEvtFilter))
			ShowEvent (pEvtFilter, pEventDoc->dwCount) ;
		dwCount-- ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by evtview.rc
//
#define IDC_ADDTIMEINFOBUTTON           4
#define IDC_REMOVETIMEINFOBUTTON        5
#define IDC_ADDEVENTINFOBUTTON          6
#define IDC_REMOVEEVENTINFOBUTTON       7
#define IDC_ADDACTIONINFOBUTTON         8
#define IDC_REMOVEACTIONINFOBUTTON      9
#define IDD_ABOUTBOX                    100
#define IDD_EVTVIEW_FORM                101
#define IDR_MAINFRAME                   128
#define IDR_EVTVIETYPE                  129
#define IDD_DEFINETYPEFILTER            130
#define IDD_DEFINEOBJECTFILTER          131
#define IDD_SCHEDULEINFO                132
#define IDD_SCHEDULETIMEINFO            133
#define IDD_SCEDULEEVENTINFO            135
#define IDD_SCHEDULEACTIONINFO          137
#define IDD_GETCLUSTERNAME              138
#define IDD_DIALOG1                     139
#define IDR_SCHEDULEVIEW                140
#define IDD_EVENT_FILTER                141
#define IDC_EVENTLIST                   1002
#define IDC_TYPEFILTERLIST              1003
#define IDC_OBJECTFILTERLIST            1004
#define IDC_ADDTYPEFILTER               1005
#define IDC_ADDOBJECTFILTER             1006
#define IDC_TYPEFILTER                  1006
#define IDC_REMOVETYPEFILTER            1007
#define IDC_OBJECTFILTER                1007
#define IDC_REMOVEOBJECTFILTER          1008
#define IDC_TIMEINFOLIST                1009
#define IDC_TYPEINCFILTERLIST           1009
#define IDC_EVENTINFOLIST               1010
#define IDC_OBJECTINCFILTERLIST         1010
#define IDC_ACTIONINFOLIST              1011
#define IDC_ADDTYPEINCFILTER            1011
#define IDC_ADDOBJECTINCFILTER          1012
#define IDC_YEAR                        1013
#define IDC_REMOVETYPEINCFILTER         1013
#define IDC_MONTH                       1014
#define IDC_REMOVEOBJECTINCFILTER       1014
#define IDC_DAY                         1015
#define IDC_HOUR                        1016
#define IDC_MINUTE                      1017
#define IDC_SECOND                      1018
#define IDC_SUNDAY                      1019
#define IDC_TUESDAY                     1020
#define IDC_TYPE                        1020
#define IDC_MONDAY                      1021
#define IDC_SUBTYPE                     1021
#define IDC_SUBFILTER                   1021
#define IDC_FRIDAY                      1022
#define IDC_SOURCENAME                  1022
#define IDC_SATURDAY                    1023
#define IDC_BOBJECTNAME                 1023
#define IDC_OBJECTNAME                  1023
#define IDC_THURSDAY                    1024
#define IDC_PARAM                       1024
#define IDC_WEDNESDAY                   1025
#define IDC_CLUSTERNAME                 1025
#define IDC_DELETE                      1029
#define IDC_SCHEDULELIST                1030
#define IDC_DETAILS                     1031
#define IDC_SCATAGORY                   1031
#define IDC_SFILTER                     1033
#define IDC_FILTER                      1034
#define IDC_SSUBFILTER                  1035
#define IDC_SSOURCENAME                 1036
#define IDC_SOBJECTNAME                 1037
#define IDC_CATAGORY                    1038
#define IDM_NEWEVENTCONNECTION          32771
#define IDM_SCHEDULE_MODIFYSCHEDULES    32773
#define IDM_VIEWSHEDULE                 32774
#define ID_EVENT_CLEARALLEVENTS         32775
#define IDM_EVENT_CLEARALLEVENTS        32776
#define IDM_EVENT_FILTER                32777
#define ID_INDICATOR_TIME               59142

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        142
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1039
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////
#include "statusbr.h"

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CEvtStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg LRESULT OnGotEvent (WPARAM wParam, LPARAM lParam) ;
	afx_msg LRESULT OnRefresh (WPARAM wParam, LPARAM lParam) ;
	afx_msg LRESULT	OnExitEventThread(WPARAM wParam, LPARAM lParam) ;
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnNeweventconnection();
	afx_msg void OnScheduleModifyschedules();
	afx_msg void OnViewshedule();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\listview.h ===
// ListView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEventListView view

class CEventListView : public CListView
{
	BOOL IsQualified (PEVTFILTER_TYPE pEvtFilterType) ;
	void ShowEvent (PEVTFILTER_TYPE pEvtFilter, DWORD dwCount) ;
	CStringList stlstObjectFilter, stlstObjectIncFilter, stlstTypeFilter, stlstTypeIncFilter ;
	void OnInitialize() ;
protected:
	CEventListView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CEventListView)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventListView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CEventListView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CEventListView)
	afx_msg void OnEventClearallevents();
	afx_msg void OnEventFilter();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "evtview.h"

#include "MainFrm.h"
#include "globals.h"
#include "doc.h"
#include "schview.h"

#include "clusname.h"
#include "getevent.h"

extern CEvtviewDoc *pEventDoc ;
extern CScheduleView oScheduleView ;

extern DWORD GetEvent (EVENTTHREADPARAM *pThreadParam) ;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_MESSAGE (WM_GOTEVENT, OnGotEvent)
	ON_MESSAGE (WM_EXITEVENTTHREAD, OnExitEventThread)
	ON_WM_CREATE()
	ON_COMMAND(IDM_NEWEVENTCONNECTION, OnNeweventconnection)
	ON_COMMAND(IDM_SCHEDULE_MODIFYSCHEDULES, OnScheduleModifyschedules)
	ON_COMMAND(IDM_VIEWSHEDULE, OnViewshedule)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
	ID_INDICATOR_TIME,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	UINT nId, nStyle ;
	int cxWidth ;
	m_wndStatusBar.GetPaneInfo (4, nId, nStyle, cxWidth) ;
	cxWidth *= 2 ;
	m_wndStatusBar.SetPaneInfo (4, nId, nStyle, cxWidth) ;

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}


// This function is called when the event thread exits.
LRESULT	CMainFrame::OnExitEventThread(WPARAM wParam, LPARAM lParam)
{
	CEvtviewDoc *pEventDoc = (CEvtviewDoc *) wParam ;
	pEventDoc->OnCloseDocument () ;
	return 0 ;
}

LRESULT	CMainFrame::OnGotEvent(WPARAM wParam, LPARAM lParam)
{
	CEvtviewDoc *pEventDoc = (CEvtviewDoc *) wParam ;
	pEventDoc->GotEvent ((PEVTFILTER_TYPE)lParam) ;
	return 0 ;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnNeweventconnection() 
{
	CGetClusterName oClusterName ;

	if (oClusterName.DoModal () == IDOK)
	{
		((CEvtviewApp *)AfxGetApp ())->OnFileNew () ;

	//	EVENTTHREADPARAM *pThreadParam  = new EVENTTHREADPARAM ;

	//	pThreadParam->pDoc = pEventDOc ;
	//	pThreadParam->hWnd = m_pMainWnd->m_hWnd ;

		wcscpy (pEventDoc->sThreadParam.szSourceName, oClusterName.m_stClusterName) ;

		pEventDoc->SetTitle (oClusterName.m_stClusterName.IsEmpty()?L"Local":oClusterName.m_stClusterName) ;

		pEventDoc->pWorkerThread = AfxBeginThread ((AFX_THREADPROC)EventThread, &pEventDoc->sThreadParam) ;
//		pEventDoc->pWorkerThread = AfxBeginThread ((AFX_THREADPROC)GetEvent, pEventDoc,
//			THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED) ;


//		pEventDoc->pWorkerThread->ResumeThread () ;
	}
}

void CMainFrame::OnScheduleModifyschedules() 
{
	AddSchedule () ;
}

void CMainFrame::OnViewshedule() 
{
	if (oScheduleView.GetSafeHwnd())
		oScheduleView.ShowWindow (SW_SHOW) ;
	else oScheduleView.Create (CScheduleView::IDD) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\schview.h ===
// SchView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CScheduleView dialog

class CScheduleView : public CDialog
{
// Construction
public:
	CScheduleView(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CScheduleView)
	enum { IDD = IDR_SCHEDULEVIEW };
	CListBox	m_ctrlScheduleList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScheduleView)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CScheduleView)
	afx_msg LRESULT	OnRefresh (WPARAM wParam, LPARAM lParam) ;
	afx_msg LRESULT OnExitEventThread (WPARAM wParam, LPARAM lParam) ;
	virtual BOOL OnInitDialog();
	afx_msg void OnDetails();
	afx_msg void OnDelete();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\sinfodlg.cpp ===
// SInfodlg.cpp : implementation file
//

#include "stdafx.h"
#include "evtview.h"
#include "SInfodlg.h"
#include "globals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScheduleInfo dialog


CScheduleInfo::CScheduleInfo(CWnd* pParent /*=NULL*/)
	: CDialog(CScheduleInfo::IDD, pParent)
{
	//{{AFX_DATA_INIT(CScheduleInfo)
	//}}AFX_DATA_INIT
}


void CScheduleInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScheduleInfo)
	DDX_Control(pDX, IDC_TIMEINFOLIST, m_ctrlTime);
	DDX_Control(pDX, IDC_EVENTINFOLIST, m_ctrlEvent);
	DDX_Control(pDX, IDC_ACTIONINFOLIST, m_ctrlAction);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScheduleInfo, CDialog)
	//{{AFX_MSG_MAP(CScheduleInfo)
	ON_BN_CLICKED(IDC_ADDACTIONINFOBUTTON, OnAddactioninfobutton)
	ON_BN_CLICKED(IDC_ADDEVENTINFOBUTTON, OnAddeventinfobutton)
	ON_BN_CLICKED(IDC_ADDTIMEINFOBUTTON, OnAddtimeinfobutton)
	ON_BN_CLICKED(IDC_REMOVEACTIONINFOBUTTON, OnRemoveactioninfobutton)
	ON_BN_CLICKED(IDC_REMOVEEVENTINFOBUTTON, OnRemoveeventinfobutton)
	ON_BN_CLICKED(IDC_REMOVETIMEINFOBUTTON, OnRemovetimeinfobutton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleInfo message handlers

void CScheduleInfo::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

void
CScheduleInfo::InsertEventInfo (SCHEDULE_EVENTINFO *pEventInfo)
{
	int iCount ;
	PEVENTDEFINITION pEvtDef ;
	PDWORDTOSTRINGMAP pTypeMap ;

	pEvtDef = GetEventDefinition (pEventInfo->dwCatagory) ;
	pTypeMap = pEvtDef->pFilter ;

	m_ctrlEvent.InsertItem (iCount = m_ctrlEvent.GetItemCount(), pEvtDef->szCatagory) ;

	m_ctrlEvent.SetItemText (iCount, 1, pEventInfo->szSourceName) ;
	m_ctrlEvent.SetItemText (iCount, 2, pEventInfo->szObjectName) ;
	m_ctrlEvent.SetItemText (iCount, 3, GetType (pEventInfo->dwCatagory, pEventInfo->dwFilter)) ;
//		m_ctrlEvent.SetItemText (iCount, 4, GetType (aTypeMap, pEventInfo->dwSubFilter)) ;
}

void
CScheduleInfo::InsertActionInfo (SCHEDULE_ACTIONINFO *pActionInfo)
{
	int iCount ;
	m_ctrlAction.InsertItem (iCount = m_ctrlAction.GetItemCount(), GetType (aAction, pActionInfo->dwActionType)) ;
	m_ctrlAction.SetItemText (iCount, 1, pActionInfo->stParam) ;
}


void
CScheduleInfo::InsertTimeInfo (SCHEDULE_TIMEINFO *pTimeInfo)
{
	int iCount ;
	WCHAR	szBuf [NAME_LEN] ;

	wsprintf (szBuf, L"%d", pTimeInfo->iYear) ;
	m_ctrlTime.InsertItem (iCount = m_ctrlTime.GetItemCount (), szBuf) ;

	wsprintf (szBuf, L"%d", pTimeInfo->iMonth) ;
	m_ctrlTime.SetItemText (iCount, 1, szBuf) ;

	wsprintf (szBuf, L"%d", pTimeInfo->iDay) ;
	m_ctrlTime.SetItemText (iCount, 2, szBuf) ;

	szBuf [0] = L'\0' ;
	if (pTimeInfo->iWeekDay & SCHEDULE_SUNDAY)
		wcscat (szBuf, L"Su ") ;
	if (pTimeInfo->iWeekDay & SCHEDULE_MONDAY)
		wcscat (szBuf, L"Mo ") ;
	if (pTimeInfo->iWeekDay & SCHEDULE_TUESDAY)
		wcscat (szBuf, L"Tu ") ;
	if (pTimeInfo->iWeekDay & SCHEDULE_WEDNESDAY)
		wcscat (szBuf, L"We ") ;
	if (pTimeInfo->iWeekDay & SCHEDULE_THURSDAY)
		wcscat (szBuf, L"Th ") ;
	if (pTimeInfo->iWeekDay & SCHEDULE_FRIDAY)
		wcscat (szBuf, L"Fr ") ;
	if (pTimeInfo->iWeekDay & SCHEDULE_SATURDAY)
		wcscat (szBuf, L"Sa ") ;
	m_ctrlTime.SetItemText (iCount, 3, szBuf) ;

	wsprintf (szBuf, L"%d", pTimeInfo->iHour) ;
	m_ctrlTime.SetItemText (iCount, 4, szBuf) ;

	wsprintf (szBuf, L"%d", pTimeInfo->iMin) ;
	m_ctrlTime.SetItemText (iCount, 5, szBuf) ;

	wsprintf (szBuf, L"%d", pTimeInfo->iSec) ;
	m_ctrlTime.SetItemText (iCount, 6, szBuf) ;
}


BOOL CScheduleInfo::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_ctrlAction.InsertColumn (0, L"Type", LVCFMT_LEFT, 70, 0) ;
	m_ctrlAction.InsertColumn (1,  L"Parameters", LVCFMT_LEFT, 90, 1) ;

	POSITION pos ;

	SCHEDULE_ACTIONINFO *pActionInfo ;
	pos = pSInfo->lstActionInfo.GetHeadPosition () ;
	while (pos)
	{
		pActionInfo = (SCHEDULE_ACTIONINFO *)pSInfo->lstActionInfo.GetNext (pos) ;

		InsertActionInfo (pActionInfo) ;
	}

	m_ctrlEvent.InsertColumn (0, L"Catagory", LVCFMT_LEFT, 100) ;
	m_ctrlEvent.InsertColumn (3, L"Source Name", LVCFMT_LEFT, 140) ;
	m_ctrlEvent.InsertColumn (0, L"ObjectName", LVCFMT_LEFT, 100) ;
	m_ctrlEvent.InsertColumn (1, L"Filter", LVCFMT_LEFT, 100) ;
	m_ctrlEvent.InsertColumn (2, L"SubFilter", LVCFMT_LEFT, 80) ;

	SCHEDULE_EVENTINFO *pEventInfo ;
	pos = pSInfo->lstEventInfo.GetHeadPosition () ;
	while (pos)
	{
		pEventInfo = (SCHEDULE_EVENTINFO *)pSInfo->lstEventInfo.GetNext (pos) ;
		
		InsertEventInfo (pEventInfo) ;
	}

	
	
	m_ctrlTime.InsertColumn (0, L"Year", LVCFMT_LEFT, 60) ;
	m_ctrlTime.InsertColumn (1, L"Month", LVCFMT_LEFT, 60) ;
	m_ctrlTime.InsertColumn (2, L"Day", LVCFMT_LEFT, 60) ;
	m_ctrlTime.InsertColumn (3, L"Week Day", LVCFMT_LEFT, 100) ;
	m_ctrlTime.InsertColumn (4, L"Hour", LVCFMT_LEFT, 60) ;
	m_ctrlTime.InsertColumn (5, L"Minute", LVCFMT_LEFT, 60) ;
	m_ctrlTime.InsertColumn (6, L"Second", LVCFMT_LEFT, 60) ;

	SCHEDULE_TIMEINFO *pTimeInfo ;
	pos = pSInfo->lstTimeInfo.GetHeadPosition () ;

	while (pos)
	{
		pTimeInfo = (SCHEDULE_TIMEINFO *)pSInfo->lstTimeInfo.GetNext (pos) ;
		InsertTimeInfo (pTimeInfo) ;
	}

	
	return TRUE;  // return TRUE unless you set the focus to a control
              // EXCEPTION: OCX Property Pages should return FALSE
}

void CScheduleInfo::OnAddactioninfobutton() 
{
	if (oAction.DoModal () == IDOK)
	{
		SCHEDULE_ACTIONINFO *pActionInfo = new SCHEDULE_ACTIONINFO ;
		*pActionInfo = oAction.sActionInfo ;
		pSInfo->lstActionInfo.AddTail (pActionInfo) ;

		InsertActionInfo (pActionInfo) ;
	}
}

void CScheduleInfo::OnAddeventinfobutton() 
{
	oEvent.dwCatagory = EVENT_CATAGORY_CLUSTER ;
	if (oEvent.DoModal () == IDOK)
	{
		SCHEDULE_EVENTINFO *pEventInfo = new SCHEDULE_EVENTINFO ;
		*pEventInfo = oEvent.sEventInfo ;
		pSInfo->lstEventInfo.AddTail (pEventInfo) ;

		InsertEventInfo (pEventInfo) ;
	}
}

void CScheduleInfo::OnAddtimeinfobutton() 
{
	if (oTime.DoModal () == IDOK)
	{
		SCHEDULE_TIMEINFO *pTimeInfo = new SCHEDULE_TIMEINFO ;
		*pTimeInfo = oTime.sTimeInfo ;
		pSInfo->lstTimeInfo.AddTail (pTimeInfo) ;

		InsertTimeInfo (pTimeInfo) ;
	}
}

void CScheduleInfo::OnRemoveactioninfobutton() 
{
	int iIndex = m_ctrlAction.GetNextItem (-1, LVNI_SELECTED) ;

	if (iIndex != -1)
	{
		POSITION pos = pSInfo->lstActionInfo.FindIndex (iIndex) ;
		pSInfo->lstActionInfo.RemoveAt (pos) ;

		m_ctrlAction.DeleteItem (iIndex) ;
	}
}

void CScheduleInfo::OnRemoveeventinfobutton() 
{
	int iIndex = m_ctrlEvent.GetNextItem (-1, LVNI_SELECTED) ;

	if (iIndex != -1)
	{
		POSITION pos = pSInfo->lstEventInfo.FindIndex (iIndex) ;
		pSInfo->lstEventInfo.RemoveAt (pos) ;

		m_ctrlEvent.DeleteItem (iIndex) ;
	}
}

void CScheduleInfo::OnRemovetimeinfobutton() 
{
	int iIndex = m_ctrlTime.GetNextItem (-1, LVNI_SELECTED) ;

	if (iIndex != -1)
	{
		POSITION pos = pSInfo->lstTimeInfo.FindIndex (iIndex) ;
		pSInfo->lstTimeInfo.RemoveAt (pos) ;

		m_ctrlTime.DeleteItem (iIndex) ;
	}
}


void CScheduleInfo::Terminate()
{
	if (GetSafeHwnd())
	{
		AfxMessageBox (L"The data being edited is scheduled so it closes the dialog") ;

		if (oTime.GetSafeHwnd ())
			oTime.EndDialog (IDCANCEL) ;

		if (oEvent.GetSafeHwnd ())
			oEvent.EndDialog (IDCANCEL) ;

		if (oAction.GetSafeHwnd ())
			oAction.EndDialog (IDCANCEL) ;

		EndDialog (IDCANCEL) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\schview.cpp ===
// SchView.cpp : implementation file
//

#include "stdafx.h"
#include "evtview.h"
#include "SchView.h"
#include "globals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScheduleView dialog


CScheduleView::CScheduleView(CWnd* pParent /*=NULL*/)
	: CDialog(CScheduleView::IDD, pParent)
{
	//{{AFX_DATA_INIT(CScheduleView)
	//}}AFX_DATA_INIT
}


void CScheduleView::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScheduleView)
	DDX_Control(pDX, IDC_SCHEDULELIST, m_ctrlScheduleList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScheduleView, CDialog)
	//{{AFX_MSG_MAP(CScheduleView)
	ON_MESSAGE (WM_REFRESH, OnRefresh)
	ON_BN_CLICKED(IDC_DETAILS, OnDetails)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleView message handlers
void GetScheduleFormatString (SCHEDULE_INFO *pSInfo, WCHAR *pszBuf)
{
	POSITION pos ;
	SCHEDULE_ACTIONINFO *pAInfo ;

	pos = pSInfo->lstActionInfo.GetHeadPosition () ;
	*pszBuf = L'\0' ;
	if (pos)
	{
		pAInfo = (SCHEDULE_ACTIONINFO *) pSInfo->lstActionInfo.GetNext (pos) ;
		wsprintf (pszBuf, L"%s %s On:", GetType (aAction, pAInfo->dwActionType),
			pAInfo->stParam) ;
	}

	if (pSInfo->lstTimeInfo.GetCount())
	{
		wcscat (pszBuf, pSInfo->minTime.Format (L"%d %b %H:%M:%S")) ;
	}

	if (pSInfo->lstEventInfo.GetCount())
	{
		WCHAR szTmpBuf [200] ;
		SCHEDULE_EVENTINFO *pEventInfo = (SCHEDULE_EVENTINFO *) pSInfo->lstEventInfo.GetHead () ;

		swprintf (szTmpBuf, L"%s->%s(%s)", pEventInfo->szSourceName, GetType (pEventInfo->dwCatagory, pEventInfo->dwFilter), pEventInfo->szObjectName) ;
		wcscat (pszBuf, szTmpBuf) ;
	}
}

LRESULT	CScheduleView::OnRefresh (WPARAM wParam, LPARAM lParam)
{
	WCHAR szBuf [256] ;
	POSITION pos = ptrlstSInfo.GetHeadPosition () ;
	SCHEDULE_INFO *pSInfo ;

	m_ctrlScheduleList.ResetContent () ;
	while (pos)
	{
		pSInfo = (SCHEDULE_INFO *) ptrlstSInfo.GetNext (pos) ;

		GetScheduleFormatString (pSInfo, szBuf) ;

		m_ctrlScheduleList.AddString (szBuf) ;
	}
	return 0 ;
}

BOOL CScheduleView::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	OnRefresh (0, 0) ;
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CScheduleView::OnDetails() 
{
	int iIndex ;
	if ((iIndex = m_ctrlScheduleList.GetCurSel ()) != LB_ERR)
	{
		POSITION pos = ptrlstSInfo.FindIndex (iIndex) ;
		SCHEDULE_INFO *pSInfo = (SCHEDULE_INFO *)ptrlstSInfo.GetAt (pos) ;
		WCHAR szBuf [256] ;
		
		if (ModifySchedule (pSInfo) == IDOK)
		{
			m_ctrlScheduleList.DeleteString (iIndex) ;
			GetScheduleFormatString (pSInfo, szBuf) ;
			m_ctrlScheduleList.InsertString (iIndex, szBuf) ;
		}
	}
}

void CScheduleView::OnDelete()
{
	int iIndex ;
	if ((iIndex = m_ctrlScheduleList.GetCurSel ()) != LB_ERR)
	{
		POSITION pos = ptrlstSInfo.FindIndex (iIndex) ;
		SCHEDULE_INFO *pSInfo = (SCHEDULE_INFO *)ptrlstSInfo.GetAt (pos) ;


		FreeEventList (pSInfo->lstEventInfo) ;
		FreeActionList (pSInfo->lstActionInfo) ;
		FreeTimeList (pSInfo->lstTimeInfo) ;
		delete pSInfo ;
		ptrlstSInfo.RemoveAt (pos) ;
		
		ResetTimer () ;

		m_ctrlScheduleList.DeleteString (iIndex) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\schedule.cpp ===
#include "stdafx.h"
#include "evtview.h"

#include "globals.h"

#include "SInfoDlg.h"
#include "schview.h"

extern CScheduleView oScheduleView ;
CScheduleInfo oSchedule ;

void
DoAction (CPtrList &p)
{
	POSITION pos ;
	SCHEDULE_ACTIONINFO *pInfo ;
	PROCESS_INFORMATION sProcessInformation ;
	STARTUPINFO sStartupInfo ;

	GetStartupInfo (&sStartupInfo) ;

	pos = p.GetHeadPosition () ;

	while (pos)
	{
		pInfo = (SCHEDULE_ACTIONINFO *)p.GetNext (pos) ;

		if (!CreateProcess (NULL, (LPWSTR)(LPCWSTR)pInfo->stParam, NULL, NULL, FALSE, 0, NULL, NULL, &sStartupInfo, &sProcessInformation))
		{
			WCHAR szBuf [100] ;

			wsprintf (szBuf, L"CreateProcess Failed : %ld", GetLastError()) ;
			AfxMessageBox (szBuf) ;
		}
	}
}

void CheckForTime ()
{
	POSITION pos = ptrlstSInfo.GetHeadPosition (), posPrev ;
	SCHEDULE_INFO *pSInfo ;
	CTime t = CTime::GetCurrentTime () ;

	while (pos)
	{
		posPrev = pos ;
		pSInfo = (SCHEDULE_INFO *) ptrlstSInfo.GetNext (pos) ;

		if (pSInfo->lstTimeInfo.GetCount() && t >= pSInfo->minTime)
		{
			DoAction (pSInfo->lstActionInfo) ;
		}

		ComputeAbsoluteTime (pSInfo) ;

		if (pSInfo->lstTimeInfo.GetCount() == 0 &&
			pSInfo->lstEventInfo.GetCount() == 0)
		{
			FreeEventList (pSInfo->lstEventInfo) ;
			FreeActionList (pSInfo->lstActionInfo) ;
			FreeTimeList (pSInfo->lstTimeInfo) ;
			delete pSInfo ;
			ptrlstSInfo.RemoveAt (posPrev) ;
		}
	}
	ResetTimer () ;
	if (oScheduleView.GetSafeHwnd())
		oScheduleView.PostMessage (WM_REFRESH, 0, 0) ;
}

void CheckForEvent (PEVTFILTER_TYPE pEvent)
{
	POSITION pos = ptrlstSInfo.GetHeadPosition (), posPrev ;
	SCHEDULE_INFO *pSInfo ;

	POSITION pos1 ;
	SCHEDULE_EVENTINFO *pEInfo ;

	while (pos)
	{
		posPrev = pos ;
		pSInfo = (SCHEDULE_INFO *) ptrlstSInfo.GetNext (pos) ;

		if (pSInfo->lstEventInfo.GetCount())
		{
			pos1 = pSInfo->lstEventInfo.GetHeadPosition () ;

			while (pos1)
			{
				pEInfo = (SCHEDULE_EVENTINFO *)pSInfo->lstEventInfo.GetNext (pos1) ;

				if ((pEInfo->dwFilter & pEvent->dwFilter) &&
					((wcslen (pEInfo->szObjectName) == 0) ||
					 (wcscmp (pEInfo->szObjectName, pEvent->szObjectName) == 0)) &&
					((wcslen (pEInfo->szSourceName) == 0) ||
					 (wcscmp (pEInfo->szSourceName, pEvent->szSourceName) == 0)))
				{
					DoAction (pSInfo->lstActionInfo) ;
					break ;
				}
			}
		}
	}
}

LRESULT CALLBACK WindowProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
	case WM_TIMER:
		CheckForTime () ;
		break ;
	case WM_GOTEVENT:
		CheckForEvent ((PEVTFILTER_TYPE)lParam) ;
		break ;
	default:
		return DefWindowProc (hWnd, msg, wParam, lParam) ;
	}
	return 0 ;
}

HWND InitWindow ()
{
	WNDCLASS sWndClass ;

	sWndClass.style = 0 ;
	sWndClass.lpfnWndProc = WindowProc ;
	sWndClass.cbClsExtra = 0 ;
	sWndClass.cbWndExtra = 0 ;
	sWndClass.hInstance = AfxGetApp()->m_hInstance ;
	sWndClass.hIcon = NULL ;
	sWndClass.hCursor = NULL ;
	sWndClass.hbrBackground = NULL ;
	sWndClass.lpszMenuName = NULL ;
	sWndClass.lpszClassName = L"EVTVIEW_SCHEDULE" ;

	RegisterClass ( &sWndClass) ;

	return CreateWindow (sWndClass.lpszClassName, L"EVTVIEW_SCHEDULE", 0, 0, 0, 0, 0, NULL, NULL, sWndClass.hInstance, NULL) ;
}

ScheduleInit ()
{
	hScheduleWnd = InitWindow () ;

	if (hScheduleWnd != NULL)
	{
	}
	else
	{
		AfxMessageBox (L"Create Window failed in Schedule Thread") ;
	}
	return 0 ;
}

void ScheduleDeInit()
{
	UnregisterClass (L"EVTVIEW_SCHEDULE", AfxGetApp()->m_hInstance) ;

	POSITION pos = ptrlstSInfo.GetHeadPosition () ;
	SCHEDULE_INFO *pSInfo ;

	while (pos)
	{
		pSInfo = (SCHEDULE_INFO *)ptrlstSInfo.GetNext (pos) ;

		FreeEventList (pSInfo->lstEventInfo) ;
		FreeActionList (pSInfo->lstActionInfo) ;
		FreeTimeList (pSInfo->lstTimeInfo) ;
		delete pSInfo ;
	}
}

void FreeEventList (CPtrList &ptrlst)
{
	POSITION pos ;

	pos = ptrlst.GetHeadPosition () ;

	while (pos)
	{
		delete (SCHEDULE_EVENTINFO *) ptrlst.GetNext (pos) ;
	}
	ptrlst.RemoveAll () ;
}

void FreeActionList (CPtrList &ptrlst)
{
	POSITION pos ;

	pos = ptrlst.GetHeadPosition () ;

	while (pos)
	{
		delete (SCHEDULE_ACTIONINFO *) ptrlst.GetNext (pos) ;
	}
	ptrlst.RemoveAll () ;
}

void FreeTimeList (CPtrList &ptrlst)
{
	POSITION pos ;

	pos = ptrlst.GetHeadPosition () ;

	while (pos)
	{
		delete (SCHEDULE_TIMEINFO *) ptrlst.GetNext (pos) ;
	}
	ptrlst.RemoveAll () ;
}

CTime GetNextTime (SCHEDULE_TIMEINFO *pInfo)
{
	CTime curTime = CTime::GetCurrentTime (), newTime ;

	SCHEDULE_TIMEINFO tmpInfo ;

	tmpInfo = *pInfo ;

	int iYear, iYearStart, iYearEnd ;
	int iMon, iMonStart, iMonEnd ;
	int iDay, iDayStart, iDayEnd ;
	int iHour, iHourStart, iHourEnd ;
	int iMin, iMinStart, iMinEnd ;
	int iSec, iSecStart, iSecEnd ;

	if (tmpInfo.iYear == -1)
	{
		iYearStart = curTime.GetYear () ;
		iYearEnd = 2038 ;
	}
	else
		iYearStart = iYearEnd = tmpInfo.iYear ;

	if (tmpInfo.iMonth == -1)
	{
		iMonStart = 1 ;
		iMonEnd = 12 ;
	}
	else
		iMonStart = iMonEnd = tmpInfo.iMonth ;

	if (tmpInfo.iDay == -1)
	{
		iDayStart = 1 ;
		iDayEnd = 31 ;
	}
	else
		iDayStart = iDayEnd = tmpInfo.iDay ;

	if (tmpInfo.iHour == -1)
	{
		iHourStart = 0 ;
		iHourEnd = 23 ;
	}
	else
		iHourStart = iHourEnd = tmpInfo.iHour ;

	if (tmpInfo.iMin == -1)
	{
		iMinStart = 0 ;
		iMinEnd = 59 ;
	}
	else
		iMinStart = iMinEnd = tmpInfo.iMin ;

	if (tmpInfo.iSec == -1)
	{
		iSecStart = 0 ;
		iSecEnd = 59 ;
	}
	else
		iSecStart = iSecEnd = tmpInfo.iSec ;

	for (iYear = iYearStart; iYear <= iYearEnd; iYear++)
	{
		for (iMon = iMonStart; iMon <= iMonEnd ; iMon++)
		{
			for (iDay = iDayStart; iDay <= iDayEnd; iDay++)
			{
				for (iHour = iHourStart; iHour <= iHourEnd; iHour++)
				{
					for (iMin = iMinStart; iMin <= iMinEnd; iMin++)
					{
						for (iSec = iSecStart; iSec <= iSecEnd; iSec++)
						{
							newTime = CTime (iYear, iMon, iDay, iHour, iMin, iSec) ;
							if (newTime > curTime)
								return newTime ;
						} // Second
					} // Minutes
				}
			} // Day
		} // Month
	} // Year

	// Give a old value so that this entry will be deleted
	newTime = curTime - CTimeSpan (1, 1, 1, 1) ;
	return newTime ;
}

void
ComputeAbsoluteTime (SCHEDULE_INFO *pSInfo)
{
	CPtrList & ptrlst = pSInfo->lstTimeInfo ;
	POSITION pos = ptrlst.GetHeadPosition (), posPrev ;
	SCHEDULE_TIMEINFO *pInfo ;
	CTime curTime = CTime::GetCurrentTime (), minTime ;
	BOOL bFirstFlag = TRUE ;

	while (pos)
	{
		posPrev = pos ;
		pInfo = (SCHEDULE_TIMEINFO *) ptrlst.GetNext (pos) ;

		pInfo->ctime = GetNextTime (pInfo) ;

		if (pInfo->ctime < curTime)
		{
			oSchedule.Terminate () ;

			delete pInfo ;
			ptrlst.RemoveAt (posPrev) ;
			continue ;
		}

		if (bFirstFlag)
		{
			minTime = pInfo->ctime ;
			bFirstFlag = FALSE ;
		}
		else if (minTime > pInfo->ctime)
			minTime = pInfo->ctime ;
	}
	pSInfo->minTime = minTime ;
}

void
ResetTimer ()
{
	KillTimer (hScheduleWnd, nIDTimer) ;

	CTime minTime ;
	BOOL bFirstFlag = TRUE ;
	POSITION pos = ptrlstSInfo.GetHeadPosition () ;
	SCHEDULE_INFO *pSInfo ;

	while (pos)
	{
		pSInfo = (SCHEDULE_INFO *) ptrlstSInfo.GetNext (pos) ;

		if (pSInfo->lstTimeInfo.GetCount() && bFirstFlag)
		{
			bFirstFlag = FALSE ;
			minTime = pSInfo->minTime ;
		}
		else if (pSInfo->lstTimeInfo.GetCount() && minTime > pSInfo->minTime)
			minTime = pSInfo->minTime ;
	}

	if (!bFirstFlag)
	{
		CTimeSpan s = minTime - CTime::GetCurrentTime () ;

		int i = s.GetTotalSeconds() ;
		TRACE (L"SetTime %d\n", i) ;
	//i = 2 ;
		nIDTimer = SetTimer (hScheduleWnd , 77, i*1000, NULL) ;
	//	nIDTimer = SetTimer (hScheduleWnd , 77, s.GetTotalSeconds()*1000, NULL) ;
	}
}

// Copies from p2 to p1
void
CopyScheduleInfo (SCHEDULE_INFO *p1, SCHEDULE_INFO *p2)
{
	SCHEDULE_TIMEINFO *pTimeInfo ;
	SCHEDULE_EVENTINFO *pEventInfo ;
	SCHEDULE_ACTIONINFO *pActionInfo ;
	POSITION pos ;

	FreeEventList (p1->lstEventInfo) ;
	FreeActionList (p1->lstActionInfo) ;
	FreeTimeList (p1->lstTimeInfo) ;

	p1->minTime = p2->minTime ;

	pos = p2->lstTimeInfo.GetHeadPosition () ;
	while (pos)
	{
		pTimeInfo = (SCHEDULE_TIMEINFO *) p2->lstTimeInfo.GetNext (pos) ;
		p1->lstTimeInfo.AddTail (new SCHEDULE_TIMEINFO(*pTimeInfo)) ;
	}
	pos = p2->lstEventInfo.GetHeadPosition () ;
	while (pos)
	{
		pEventInfo = (SCHEDULE_EVENTINFO *) p2->lstEventInfo.GetNext (pos) ;
		p1->lstEventInfo.AddTail (new SCHEDULE_EVENTINFO(*pEventInfo)) ;
	}
	pos = p2->lstActionInfo.GetHeadPosition () ;
	while (pos)
	{
		pActionInfo = (SCHEDULE_ACTIONINFO *) p2->lstActionInfo.GetNext (pos) ;
		p1->lstActionInfo.AddTail (new SCHEDULE_ACTIONINFO(*pActionInfo)) ;
	}
}

AddSchedule ()
{
	SCHEDULE_INFO *pSInfo = new SCHEDULE_INFO ;

	oSchedule.pSInfo = pSInfo ;

	if (oSchedule.DoModal () == IDOK)
	{
		ComputeAbsoluteTime (pSInfo) ;

		if (pSInfo->lstTimeInfo.GetCount() ||
			pSInfo->lstEventInfo.GetCount() )
		{
			ptrlstSInfo.AddTail (pSInfo) ;

			if (pSInfo->lstTimeInfo.GetCount())
				ResetTimer () ;

		}
		else
		{
			FreeEventList (pSInfo->lstEventInfo) ;
			FreeActionList (pSInfo->lstActionInfo) ;
			FreeTimeList (pSInfo->lstTimeInfo) ;
			delete pSInfo ;
		}
		if (oScheduleView.GetSafeHwnd())
			oScheduleView.PostMessage (WM_REFRESH, 0, 0) ;
	}
	else
	{
		FreeEventList (pSInfo->lstEventInfo) ;
		FreeActionList (pSInfo->lstActionInfo) ;
		FreeTimeList (pSInfo->lstTimeInfo) ;
		delete pSInfo ;
	}

	return 0 ;
}


ModifySchedule (SCHEDULE_INFO *pSOldInfo)
{
	int iRet ;
	
	SCHEDULE_INFO *pSInfo = new SCHEDULE_INFO ;

	CopyScheduleInfo (pSInfo, pSOldInfo) ;

	oSchedule.pSInfo = pSInfo ;

	if ((iRet = (int)oSchedule.DoModal ()) == IDOK)
	{
		ComputeAbsoluteTime (pSInfo) ;
		CopyScheduleInfo (pSOldInfo, pSInfo) ;
		ResetTimer () ;
	}

	FreeEventList (pSInfo->lstEventInfo) ;
	FreeActionList (pSInfo->lstActionInfo) ;
	FreeTimeList (pSInfo->lstTimeInfo) ;
	delete pSInfo ;

	return iRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\statusbr.cpp ===
// StatusBr.cpp : implementation file
//

#include "stdafx.h"
#include "evtview.h"
#include "StatusBr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEvtStatusBar

CEvtStatusBar::CEvtStatusBar()
{
}

CEvtStatusBar::~CEvtStatusBar()
{
}


BEGIN_MESSAGE_MAP(CEvtStatusBar, CStatusBar)
	//{{AFX_MSG_MAP(CEvtStatusBar)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_TIME, OnUpdateTime)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEvtStatusBar message handlers

void CEvtStatusBar::OnUpdateTime(CCmdUI* pCmdUI) 
{
	CTime t = CTime::GetCurrentTime () ;
	pCmdUI->SetText (t.Format(L"%H:%M:%S")) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\sinfodlg.h ===
// SInfodlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CScheduleInfo dialog

#include "globals.h"
#include "AInfoDlg.h"
#include "EInfoDlg.h"
#include "TInfoDlg.h"

class CScheduleInfo : public CDialog
{
// Construction
	CScheduleTimeInfo oTime ;
	CScheduleEventInfo oEvent ;
	CScheduleActionInfo oAction ;

	void InsertEventInfo (SCHEDULE_EVENTINFO *pEventInfo) ;
	void InsertActionInfo (SCHEDULE_ACTIONINFO *pActionInfo) ;
	void InsertTimeInfo (SCHEDULE_TIMEINFO *pTimeInfo) ;
public:
	SCHEDULE_INFO *pSInfo ;
	
	void Terminate() ;

	CScheduleInfo(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CScheduleInfo)
	enum { IDD = IDD_SCHEDULEINFO };
	CListCtrl	m_ctrlTime;
	CListCtrl	m_ctrlEvent;
	CListCtrl	m_ctrlAction;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScheduleInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CScheduleInfo)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnAddactioninfobutton();
	afx_msg void OnAddeventinfobutton();
	afx_msg void OnAddtimeinfobutton();
	afx_msg void OnRemoveactioninfobutton();
	afx_msg void OnRemoveeventinfobutton();
	afx_msg void OnRemovetimeinfobutton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	evtview.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\statusbr.h ===
// EvtStatusBr.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEvtStatusBar window

class CEvtStatusBar : public CStatusBar
{
// Construction
public:
	CEvtStatusBar();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEvtStatusBar)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEvtStatusBar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEvtStatusBar)
	afx_msg void OnUpdateTime(CCmdUI* pCmdUI);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\tinfodlg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tinfodlg.h

Abstract:




Author:

   Sivaprasad Padisetty (sivapad)    6/25/97


Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
// CScheduleTimeInfo dialog
#include "globals.h"

class CScheduleTimeInfo : public CDialog
{
// Construction
public:
    struct SCHEDULE_TIMEINFO sTimeInfo ;

    CScheduleTimeInfo(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CScheduleTimeInfo)
    enum { IDD = IDD_SCHEDULETIMEINFO };
    CComboBox    m_ctrlSecond;
    CComboBox    m_ctrlMinute;
    CComboBox    m_ctrlHour;
    CComboBox    m_ctrlYear;
    CComboBox    m_ctrlMonth;
    CComboBox    m_ctrlDay;
    BOOL    m_bFriday;
    BOOL    m_bMonday;
    BOOL    m_bSaturday;
    BOOL    m_bSunday;
    BOOL    m_bThursday;
    BOOL    m_bTuesday;
    BOOL    m_bWednesday;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScheduleTimeInfo)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CScheduleTimeInfo)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\evtview\tinfodlg.cpp ===
// ScheduleTimeInfo.cpp : implementation file
//

#include "stdafx.h"
#include "evtview.h"
#include "TInfoDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScheduleTimeInfo dialog


CScheduleTimeInfo::CScheduleTimeInfo(CWnd* pParent /*=NULL*/)
	: CDialog(CScheduleTimeInfo::IDD, pParent)
{
	//{{AFX_DATA_INIT(CScheduleTimeInfo)
	m_bFriday = FALSE;
	m_bMonday = FALSE;
	m_bSaturday = FALSE;
	m_bSunday = FALSE;
	m_bThursday = FALSE;
	m_bTuesday = FALSE;
	m_bWednesday = FALSE;
	//}}AFX_DATA_INIT
}


void CScheduleTimeInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScheduleTimeInfo)
	DDX_Control(pDX, IDC_SECOND, m_ctrlSecond);
	DDX_Control(pDX, IDC_MINUTE, m_ctrlMinute);
	DDX_Control(pDX, IDC_HOUR, m_ctrlHour);
	DDX_Control(pDX, IDC_YEAR, m_ctrlYear);
	DDX_Control(pDX, IDC_MONTH, m_ctrlMonth);
	DDX_Control(pDX, IDC_DAY, m_ctrlDay);
	DDX_Check(pDX, IDC_FRIDAY, m_bFriday);
	DDX_Check(pDX, IDC_MONDAY, m_bMonday);
	DDX_Check(pDX, IDC_SATURDAY, m_bSaturday);
	DDX_Check(pDX, IDC_SUNDAY, m_bSunday);
	DDX_Check(pDX, IDC_THURSDAY, m_bThursday);
	DDX_Check(pDX, IDC_TUESDAY, m_bTuesday);
	DDX_Check(pDX, IDC_WEDNESDAY, m_bWednesday);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScheduleTimeInfo, CDialog)
	//{{AFX_MSG_MAP(CScheduleTimeInfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleTimeInfo message handlers

struct {
	LPCWSTR pszYear ;
	int		iYear ;
} aYear [] = 
{
	{L"ANY", -1 },
	{L"1996", 1996 },
	{L"1997", 1997 },
	{NULL, 0 },
} ;

BOOL CScheduleTimeInfo::OnInitDialog() 
{
	CDialog::OnInitDialog();

	int i = 0 ;

	while (aYear[i].pszYear)
	{
		m_ctrlYear.AddString (aYear[i].pszYear) ;
		m_ctrlYear.SetItemData (i, aYear[i].iYear) ;
		i++ ;
	}

	m_ctrlMonth.SetCurSel (0) ;
	m_ctrlYear.SetCurSel (0) ;
	m_ctrlDay.SetCurSel (0) ;
	m_ctrlHour.SetCurSel (0) ;
	m_ctrlMinute.SetCurSel (0) ;
	m_ctrlSecond.SetCurSel (0) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CScheduleTimeInfo::OnOK() 
{
	UpdateData (TRUE) ;

	int iIndex ;
	sTimeInfo.iYear = (int)m_ctrlYear.GetItemData (m_ctrlYear.GetCurSel()) ;
	sTimeInfo.iMonth = ((iIndex = m_ctrlMonth.GetCurSel()) == CB_ERR|| (iIndex == 0))?-1:iIndex ;
	sTimeInfo.iDay = ((iIndex = m_ctrlDay.GetCurSel()) == CB_ERR|| (iIndex == 0))?-1:iIndex ;

	sTimeInfo.iHour = ((iIndex = m_ctrlHour.GetCurSel()) == CB_ERR|| (iIndex == 0))?-1:iIndex-1 ;
	sTimeInfo.iMin = ((iIndex = m_ctrlMinute.GetCurSel()) == CB_ERR|| (iIndex == 0))?-1:iIndex-1 ;
	sTimeInfo.iSec = ((iIndex = m_ctrlSecond.GetCurSel()) == CB_ERR|| (iIndex == 0))?-1:iIndex-1 ;

	sTimeInfo.iWeekDay = 0 ;

	if (m_bSunday)
		sTimeInfo.iWeekDay |= SCHEDULE_SUNDAY ;
	if (m_bMonday)
		sTimeInfo.iWeekDay |= SCHEDULE_MONDAY ;
	if (m_bTuesday)
		sTimeInfo.iWeekDay |= SCHEDULE_TUESDAY ;
	if (m_bWednesday)
		sTimeInfo.iWeekDay |= SCHEDULE_WEDNESDAY ;
	if (m_bThursday)
		sTimeInfo.iWeekDay |= SCHEDULE_THURSDAY ;
	if (m_bFriday)
		sTimeInfo.iWeekDay |= SCHEDULE_FRIDAY ;
	if (m_bSaturday)
		sTimeInfo.iWeekDay |= SCHEDULE_SATURDAY ;

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\leaks\leaks.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    leaks.h

Abstract:

    header for leak filter dll

Author:

    Charlie Wickham (charlwi) 28-Sep-1998

Environment:

    User Mode

Revision History:

--*/

//
// keep a table of caller and caller's caller for open handles. indexed by
// handle value divided by 4.  !leaks in clusexts will display this info.
//

typedef enum _LEAKS_HANDLE_TYPE {
    LeaksEvent = 1,
    LeaksRegistry,
    LeaksToken
} LEAKS_HANDLE_TYPE;


typedef struct _HANDLE_TABLE {
    PVOID Caller;
    PVOID CallersCaller;
    LEAKS_HANDLE_TYPE HandleType;
    BOOL InUse;
} HANDLE_TABLE, *PHANDLE_TABLE;

#define MAX_HANDLE      4096
#define HANDLE_DELTA    4
#define HINDEX( _h )    (((DWORD) _h ) / HANDLE_DELTA )

#define SetHandleTable( _h, _inuse, _htype )                        \
    {                                                               \
        RtlGetCallersAddress(&callersAddress,                       \
                             &callersCaller );                      \
        HandleTable[ HINDEX( _h )].InUse = _inuse;                  \
        HandleTable[ HINDEX( _h )].HandleType = _htype;             \
        HandleTable[ HINDEX( _h )].Caller = callersAddress;         \
        HandleTable[ HINDEX( _h )].CallersCaller = callersCaller;   \
    }

/* end leaks.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\tstpoint\tstpoint.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tstpoint.c

Abstract:

    Implementation of cluster test points

Author:

    John Vert (jvert) 11/25/1996

Revision History:

--*/
#define CLUSTER_TESTPOINT 1

#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "tstpoint.h"

VOID
Usage(
    VOID
    )
{
    fprintf(stderr,"tstpoint [dump|N] [TRIGGER [ACTION]]\n");
    fprintf(stderr,"    dump    - dumps all the testpoints\n");
    fprintf(stderr,"    N       - testpoint number\n");
    fprintf(stderr,"    TRIGGER - 'never' disable testpoint\n");
    fprintf(stderr,"              'always' enable testpoint\n");
    fprintf(stderr,"              'once' enable testpoint for single shot\n");
    fprintf(stderr,"              'target X' enable testpoint once every X calls\n");
    fprintf(stderr,"    ACTION  - 'true' return TRUE\n");
    fprintf(stderr,"              'exit' terminate process\n");
    fprintf(stderr,"              'break' break to debugger\n");
    exit(0);
}

PTESTPOINT_ENTRY
GetTestpoints(
    VOID
    )
{
    HANDLE FileMapping;
    PTESTPOINT_ENTRY TestArray;
    DWORD Status;

    FileMapping = OpenFileMappingW(FILE_MAP_READ | FILE_MAP_WRITE,
                                   FALSE,
                                   L"Cluster_Testpoints");
    if (FileMapping == NULL) {
        Status = GetLastError();
        fprintf(stderr, "Testpoint filemapping could not be opened, error %d\n",Status);
        if (Status == ERROR_FILE_NOT_FOUND) {
            fprintf(stderr, "Make sure the testpoint-enabled cluster service is running\n");
        }
        exit(Status);
    }

    TestArray = MapViewOfFile(FileMapping,
                              FILE_MAP_READ | FILE_MAP_WRITE,
                              0,0,
                              0);
    if (TestArray == NULL) {
        Status = GetLastError();
        fprintf(stderr, "Testpoint filemapping could not be mapped, error %d\n", Status);
        exit(Status);
    }
    CloseHandle(FileMapping);

    return(TestArray);
}

VOID
DumpTestpoint(
    IN PTESTPOINT_ENTRY Entry
    )
{
    PCHAR Trigger;

    printf("%ws ", Entry->TestPointName);
    switch (Entry->Trigger) {
        case TestTriggerNever:
            printf("disabled ");
            break;
        case TestTriggerAlways:
            printf("enabled permanently ");
            break;
        case TestTriggerOnce:
            printf("enabled once ");
            break;
        case TestTriggerTargetCount:
            printf("enabled on hit %d (currently %d) ",
                   Entry->TargetCount,
                   Entry->HitCount);
            break;
        default:
            printf("unknown trigger %d ", Entry->Trigger);
            break;
    }

    switch (Entry->Action) {
        case TestActionTrue:
            printf("default action ");
            break;
        case TestActionExit:
            printf("exit process ");
            break;
        case TestActionDebugBreak:
            printf("break to debugger ");
            break;
        default:
            printf("unknown action %d ", Entry->Trigger);
            break;
    }
    printf("\n");
}

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    DWORD Number;
    PTESTPOINT_ENTRY EntryArray;
    TESTPOINT_ACTION Action;
    TESTPOINT_TRIGGER Trigger;
    PCHAR *Arg;
    DWORD ArgsLeft;
    int     i;

    ArgsLeft = argc-1;
    if (ArgsLeft == 0) {
        Usage();
    }


    //
    // Open the file mapping to get at the testpoint entries
    //
    EntryArray = GetTestpoints();


    if (!lstrcmpi(argv[1], "dump"))
    {
        for (i=0; i<TestpointMax; i++)
        {
            printf("Testpoint %d ",i);
            DumpTestpoint(&EntryArray[i]);
        }
        return(0);
    }
    
    //
    // First argument is the testpoint number, make sure it is in range.
    //
    Number = atoi(argv[1]);
    if (Number >= TestpointMax) {
        fprintf(stderr,
                "testpoint %d is beyond maximum %d\n",
                Number,
                TestpointMax-1);
        exit(1);
    }
    --ArgsLeft;


    //
    // Just print out the current state of the testpoint
    //
    printf("Testpoint %d\n",Number);
    printf("  Current state: ");
    DumpTestpoint(&EntryArray[Number]);
    if (ArgsLeft == 0) {
        //
        // No change in the testpoint state, just exit.
        //
        exit(0);
    }

    Action = TestActionTrue;
    Arg = &argv[2];
    --ArgsLeft;
    if (_stricmp(*Arg, "never") == 0) {
        Trigger = TestTriggerNever;
    } else if (_stricmp(*Arg, "always") == 0) {
        Trigger = TestTriggerAlways;
    } else if (_stricmp(*Arg, "once") == 0) {
        Trigger = TestTriggerOnce;
    } else if (_stricmp(*Arg, "target") == 0) {
        if (ArgsLeft == 0) {
            Usage();
        }
        Trigger = TestTriggerTargetCount;
        EntryArray[Number].TargetCount = atoi(*(++Arg));
        --ArgsLeft;
    } else {
        Usage();
    }
    ++Arg;

    if (ArgsLeft > 0) {
        if (_stricmp(*Arg, "exit") == 0) {
            Action = TestActionExit;
        } else if (_stricmp(*Arg, "break") == 0) {
            Action = TestActionDebugBreak;
        } else if (_stricmp(*Arg, "true") == 0) {
            Action = TestActionTrue;
        } else {
            Usage();
        }
        --ArgsLeft;
        ++Arg;
    }
    EntryArray[Number].Action = Action;
    EntryArray[Number].Trigger = Trigger;

    printf("      New state: ");
    DumpTestpoint(&EntryArray[Number]);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\inc\exts.h ===
#ifndef __EXTS_h__
#define __EXTS_h__


typedef struct
{
    LPTSTR key;
    DWORD value;
} ELEMENT, *PELEMENT;

typedef struct
{
    ULONG cnt;
    PELEMENT element;
} MATCHTABLE, *PMATCHTABLE;


extern MATCHTABLE modetype, yesno, typetype;

extern DWORD tasync, period, mode;
extern DWORD type;

extern BOOLEAN                    fService;
extern BOOLEAN                    fStatus;//note to localizers - this flag is used mostly to print internal msgs
extern DWORD timesource;//for flag from LanmanServer\Parameters\timesource in registry

extern TCHAR primarysource[10*UNCLEN];
extern TCHAR *primarysourcearray[14];//15 entries possible for now
extern int arraycount;

extern TCHAR secondarydomain[DNLEN];
extern DWORD logging;


#ifdef TAPI
extern HINSTANCE thandle;
extern FARPROC lineinitialize, lineshutdown;
extern HLINEAPP hLineApp;
extern HINSTANCE hInstance;
extern VOID CallBack(DWORD hDevice, DWORD dwMsg, DWORD dwCallbackInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);
extern DWORD NumDevs;
#endif //TAPI


#ifdef CHICO
extern WORD base;
#define NetApiBufferFree(x)        // don't need this on CHICAGO
#endif

#ifdef PERF
extern __int64 perffreq;
#endif

//
//  Declared Shared Procedures/Functions
//

VOID    StopTimeService(DWORD dwNum);
VOID    TimeInit();
VOID    TimeCreateService(DWORD dwType);
VOID    LogTimeEvent(WORD type, DWORD dwNum);

LPTSTR
FindPeriodByPeriod(
    DWORD period
    );

LPTSTR
FindTypeByType(
    DWORD type
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\test\leaks\leaks.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    leaks.c

Abstract:

    A filter DLL for trying to detect memory, event, registry, and
    token handle leaks.

Author:

    Charlie Wickham/Rod Gamache

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _ADVAPI32_
#define _KERNEL32_
#include <windows.h>
#include <stdio.h>

#include "clusrtl.h"
#include "leaks.h"

HINSTANCE Kernel32Handle;
HINSTANCE Advapi32Handle;

FARPROC SystemLocalAlloc;
FARPROC SystemLocalFree;

FARPROC SystemCreateEventA;
FARPROC SystemCreateEventW;

FARPROC SystemRegOpenKeyA;
FARPROC SystemRegOpenKeyW;
FARPROC SystemRegOpenKeyExA;
FARPROC SystemRegOpenKeyExW;
FARPROC SystemRegCreateKeyA;
FARPROC SystemRegCreateKeyW;
FARPROC SystemRegCreateKeyExA;
FARPROC SystemRegCreateKeyExW;
FARPROC SystemRegCloseKey;

FARPROC SystemOpenProcessToken;
FARPROC SystemOpenThreadToken;
FARPROC SystemDuplicateToken;
FARPROC SystemDuplicateTokenEx;

FARPROC SystemCloseHandle;

#define SetSystemPointer( _h, _n ) \
    System##_n = GetProcAddress( _h, #_n );

BOOL LeaksVerbose = FALSE;

HANDLE_TABLE HandleTable[ MAX_HANDLE / HANDLE_DELTA ];


BOOLEAN
WINAPI
LeaksDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
/*++

Routine Description:

    Main DLL entrypoint

Arguments:

    DllHandle - Supplies the DLL handle.

    Reason - Supplies the call reason

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(DllHandle);
        ClRtlInitialize( FALSE );

        //
        // get pointers to the real functions
        //

        Kernel32Handle = LoadLibrary( "kernel32.dll" );
        Advapi32Handle = LoadLibrary( "advapi32.dll" );

        SetSystemPointer( Kernel32Handle, LocalAlloc );
        SetSystemPointer( Kernel32Handle, LocalFree );

        SetSystemPointer( Kernel32Handle, CreateEventA );
        SetSystemPointer( Kernel32Handle, CreateEventW );

        SetSystemPointer( Advapi32Handle, RegOpenKeyA );
        SetSystemPointer( Advapi32Handle, RegOpenKeyW );
        SetSystemPointer( Advapi32Handle, RegOpenKeyExA );
        SetSystemPointer( Advapi32Handle, RegOpenKeyExW );
        SetSystemPointer( Advapi32Handle, RegCreateKeyA );
        SetSystemPointer( Advapi32Handle, RegCreateKeyW );
        SetSystemPointer( Advapi32Handle, RegCreateKeyExA );
        SetSystemPointer( Advapi32Handle, RegCreateKeyExW );
        SetSystemPointer( Advapi32Handle, RegCloseKey );

        SetSystemPointer( Advapi32Handle, OpenProcessToken );
        SetSystemPointer( Advapi32Handle, OpenThreadToken );
        SetSystemPointer( Advapi32Handle, DuplicateToken );
        SetSystemPointer( Advapi32Handle, DuplicateTokenEx );

        SetSystemPointer( Kernel32Handle, CloseHandle );
    }

    return(TRUE);
}

//
// leaks memory header. This structure is at the front of the allocated area
// and the area behind it is returned to the caller. PlaceHolder holds the
// heap free list pointer. Signature holds ALOC or FREE.
//

#define HEAP_SIGNATURE_ALLOC 'COLA'
#define HEAP_SIGNATURE_FREE 'EERF'

typedef struct _MEM_HDR {
    PVOID   PlaceHolder;
    DWORD   Signature;
    PVOID   CallersAddress;
    PVOID   CallersCaller;
} MEM_HDR, *PMEM_HDR;

HLOCAL
WINAPI
LocalAlloc(
    UINT    uFlags,
    SIZE_T  uBytes
    )
{
    HLOCAL  memory;
    PMEM_HDR memHdr;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );


    memHdr = (PVOID)(*SystemLocalAlloc)( uFlags, uBytes + sizeof(MEM_HDR) );
    if ( !memHdr ) {
        return NULL;
    }

    memHdr->Signature = HEAP_SIGNATURE_ALLOC;
    memHdr->CallersAddress = callersAddress;
    memHdr->CallersCaller = callersCaller;

    return(memHdr+1);
}

HLOCAL
WINAPI
LocalFree(
    HLOCAL  hMem
    )
{
    PMEM_HDR memHdr = hMem;
    PVOID   callersAddress;
    PVOID   callersCaller;

    if ( memHdr ) {
        --memHdr;
        if ( memHdr->Signature == HEAP_SIGNATURE_FREE ) {
            CHAR buf[64];

            sprintf( buf, "Freeing %X a 2nd time!\n", memHdr );
            OutputDebugString( buf );
            DebugBreak();
        } else if ( memHdr->Signature == HEAP_SIGNATURE_ALLOC ) {

            RtlGetCallersAddress(&callersAddress,
                                 &callersCaller );

            memHdr->Signature = HEAP_SIGNATURE_FREE;
            memHdr->CallersAddress = callersAddress;
            memHdr->CallersCaller = callersCaller;
        } else {
            memHdr++;
        }
    }

    return( (HLOCAL)(*SystemLocalFree)(memHdr) );
}

HANDLE
WINAPI
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )
{
    HANDLE  handle;
    PVOID   callersAddress;
    PVOID   callersCaller;

    handle = (HANDLE)(*SystemCreateEventA)( 
                         lpEventAttributes,
                         bManualReset,
                         bInitialState,
                         lpName
                         );

    if ( handle != NULL ) {
        SetHandleTable( handle, TRUE, LeaksEvent );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] CreateEventA returns handle %1!X!, called from %2!X! and %3!X!\n",
                      handle,
                      callersAddress,
                      callersCaller );
    }

    return(handle);

} // CreateEventA


HANDLE
WINAPI
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    HANDLE  handle;
    PVOID   callersAddress;
    PVOID   callersCaller;

    handle = (HANDLE)(*SystemCreateEventW)( 
                         lpEventAttributes,
                         bManualReset,
                         bInitialState,
                         lpName
                         );

    if ( handle != NULL ) {
        SetHandleTable( handle, TRUE, LeaksEvent );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] CreateEventW returns handle %1!X!, called from %2!X! and %3!X!\n",
                      handle,
                      callersAddress,
                      callersCaller );
    }

    return(handle);

} // CreateEventW

LONG
APIENTRY
RegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegOpenKeyA)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegOpenKeyA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyA

LONG
APIENTRY
RegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegOpenKeyW)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegOpenKeyW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyW

LONG
APIENTRY
RegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegOpenKeyExA)(
                    hKey,
                    lpSubKey,
                    ulOptions,
                    samDesired,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegOpenKeyExA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyExA

LONG
APIENTRY
RegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegOpenKeyExW)(
                    hKey,
                    lpSubKey,
                    ulOptions,
                    samDesired,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegOpenKeyExW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyExW


LONG
APIENTRY
RegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegCreateKeyA)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegCreateKeyA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyA


LONG
APIENTRY
RegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegCreateKeyW)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegCreateKeyW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyW


LONG
APIENTRY
RegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  Reserved,
    LPSTR  lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegCreateKeyExA)(hKey,
                                      lpSubKey,
                                      Reserved,
                                      lpClass,
                                      dwOptions,
                                      samDesired,
                                      lpSecurityAttributes,
                                      phkResult,
                                      lpdwDisposition
                                      );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegCreateKeyExA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyExA

LONG
APIENTRY
RegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  Reserved,
    LPWSTR lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegCreateKeyExW)(
                    hKey,
                    lpSubKey,
                    Reserved,
                    lpClass,
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    phkResult,
                    lpdwDisposition
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegCreateKeyExW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyExW


LONG
APIENTRY
RegCloseKey(
    HKEY hKey
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemRegCloseKey)( hKey );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( hKey, FALSE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] RegCloseKey for key %1!X! returns status %2!u!, called from %3!X! and %4!X!\n",
                      hKey,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCloseKey

BOOL
WINAPI
CloseHandle(
    IN OUT HANDLE hObject
    )
{
    PVOID   callersAddress;
    PVOID   callersCaller;

    if ( HandleTable[ HINDEX( hObject )].InUse ) {

        RtlGetCallersAddress(&callersAddress,
                             &callersCaller );

        HandleTable[ HINDEX( hObject )].InUse = FALSE;
        HandleTable[ HINDEX( hObject )].Caller = callersAddress;
        HandleTable[ HINDEX( hObject )].CallersCaller = callersCaller;

        if ( LeaksVerbose ) {
            ClRtlLogPrint("[LEAKS] CloseHandle for handle %1!X!, called from %2!X! and %3!X!\n",
                          hObject,
                          callersAddress,
                          callersCaller );
        }
    }

    return (*SystemCloseHandle)( hObject );
}

BOOL
WINAPI
OpenProcessToken (
    IN HANDLE ProcessHandle,
    IN DWORD DesiredAccess,
    OUT PHANDLE TokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemOpenProcessToken)(ProcessHandle,
                                       DesiredAccess,
                                       TokenHandle);

    if ( status ) {
        SetHandleTable( *TokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] OpenProcessToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *TokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}


BOOL
WINAPI
OpenThreadToken (
    IN HANDLE ThreadHandle,
    IN DWORD DesiredAccess,
    IN BOOL OpenAsSelf,
    OUT PHANDLE TokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemOpenThreadToken)(ThreadHandle,
                                      DesiredAccess,
                                      OpenAsSelf,
                                      TokenHandle);

    if ( status ) {
        SetHandleTable( *TokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] OpenThreadToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *TokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}

BOOL
WINAPI
DuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicateTokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemDuplicateToken)(ExistingTokenHandle,
                                     ImpersonationLevel,
                                     DuplicateTokenHandle);

    if ( status ) {
        SetHandleTable( *DuplicateTokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] DuplicateToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *DuplicateTokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}

BOOL
WINAPI
DuplicateTokenEx(
    IN HANDLE hExistingToken,
    IN DWORD dwDesiredAccess,
    IN LPSECURITY_ATTRIBUTES lpTokenAttributes,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE phNewToken)
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (*SystemDuplicateTokenEx)(hExistingToken,
                                       dwDesiredAccess,
                                       lpTokenAttributes,
                                       ImpersonationLevel,
                                       TokenType,
                                       phNewToken);

    if ( status ) {
        SetHandleTable( *phNewToken, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint("[LEAKS] DuplicateTokenEx returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phNewToken,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\inc\tsapi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tsapi.h

Abstract:

    Header file for definitions and structure for the remote API interface
    for managing the NT Time Service.

Author:

    Rod Gamache (rodga) 23-Jul-1996

Revision History:

--*/

#ifndef _TSAPI_
#define _TSAPI_

DWORD
WINAPI
TSNewSource(
    IN LPWSTR ServerName,
    IN LPWSTR SourceName,
    IN DWORD Reserved
    );

#endif // ifndef _TSAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\inc\timemsgs.h ===
//  THIS FILE IS NOT USED BY TIMESERV.  GRP.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\inc\gpioctl.h ===
//  THIS FILE IS NOT USED BY TIMESERV.  GRP.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\inc\tsconfig.h ===
#ifndef __TSCONFIG_H
#define __TSCONFIG_H

#ifndef BASEONLY
#define BASEONLY 0
#endif

//note to builders: the VERBOSE (and PING/P5_DEBUG/TESTHILO/CHICO/NOVELL, etc)
// should be commented out for test & release builds!

//#define VERBOSE //for potentially interesting messages to Doug & Arnold (developers)
//#define TAPI //for using TAPI (won't work without TAPI32.DLL) - not done
//#define NOVELL //for playing around with time from Netware (won't work without two DLLs)
//#define CHICO //for trying to make things work on Windows 95 (if so, compile m ust be on x86)
//#define PING //for testing Internet delay to NIST, uses ICMP
//#define ENUM //enumerates all timesources on the network (don't include)
//#define PERF //for using QueryPerformanceFrequency/Counter
//#define P5_DEBUG //for toying around with Pentium's RDTSC instruction (10ns co unter)
//#define TESTHILO //loops so that GC-100x sub-tenths (et al) can be compared to bc620AT and adjusted
//#define AEC //for AEC-BOX code (doesn't find BREAK reliably, so not normally b uilt)
// #define TRUETIME //for TrueTime format, not tested yet
#define KENR //for CMOS

#ifdef P5_DEBUG
#define rdtsc __asm __emit 0x0F __asm __emit 0x31 //the RDTSC instruction
DWORD hi32, lo32; //where we'll put edx & eax
DWORD hi32temp, lo32temp;

#define P5START __asm {\
    __asm push edx\
    rdtsc\
    __asm mov hi32temp,edx\
    __asm pop edx\
    __asm mov lo32temp,eax\
    }
#define P5END __asm {\
    __asm push edx\
    rdtsc\
    __asm mov hi32,edx\
    __asm pop edx\
    __asm mov lo32,eax\
    }\
    printf("66MHz RDTSC diff=%.7fs\n",((float)hi32*65536*65536+lo32-((float)hi32temp*65536*65536+lo32temp))*1/66666666.7);\
    printf("166MHz RDTSC diff=%.7fs\n",((float)hi32*65536*65536+lo32-((float)hi32temp*65536*65536+lo32temp))*1/166666666.7);//display

#else //if not P5_DEBUG, we want these to be blank
#define P5START
#define P5END
#endif

#define rollover() if (++nt.wSecond >59) {nt.wSecond=0; if (++nt.wMinute >59) {nt.wMinute=0; if (++nt.wHour>23) fTimeFailed = TRUE;}}
//note unfortunately the above rollover routine will skip any leap second, but i t would be so rare anyway...

#define MAXTYPE  32        // please maintain this
#define NZ 31         // for New Nealand
#define RCC 30//for Radiocode Clocks MSF, etc
#define CMOS 29//for CMOS RTC
#define TTPC16 28//for board level PC-SG2
#define PC03XT 27//for old board from Bancomm
#define TTK 26//for Kinemetrics style
#define TTTL3 25//for TL-3 WWV
#define MOBATIME 24//for IF482 Mobaline/RS232 DCF77 receiver
#define PCLTC 23//for AEC PC-LTC/IOR (what about VITC?)
#define AECBOX 22//AEC-BOX 1/2/10/20 for VITC, etc
#define AMDAT 21//for ADC-60 MSF/DCF77 receiver
#ifdef NOVELL
#define NETWARE 20
#endif
#define HP 19 //for 58503A Time and Frequency Reference Receiver or 59551A - not tested well
#define ATOMIC 18 //for 1PPS only
#define NMEA 17
#define SPECTRACOM 16
#define BC630AT 15
#define NTP 14
#define MOTOROLA 13
#define ROCKWELL 12
#define TRIMBLE 11
#define EUROPE 10
#define COMPUTIME 9
#define NRCBBC 8
#define BC620AT 7
#define GC1001 6
#define GC1000 5
#define USNO 4
#define NISTACTS 3
#define INTERNET 2

//
// N.B. The order of the following two must remain as is and these must be the
// lowest numbered types. So keepa ya hands offa this.
//

#define PRIMARY 1
#define SECONDARY 0

#define DEFAULT_TYPE 0xFFFF

#define SERVICE 1
#define ANALYSIS 2

#if 1

#define LOCAL FALSE
#define MODEM FALSE
#define RECEIVER FALSE

#else

#define LOCAL (type==GC1000)||((type==BC620AT)&&bclocal)||(type==COMPUTIME)||(uselocal)||(type==AMDAT)||(type==MOBATIME)||(type==CMOS)
#define MODEM (type==NISTACTS)||(type==USNO)||(type==NRCBBC)||(type==EUROPE)||(type==COMPUTIME)||(type==NZ)
#define RECEIVER (type==SPECTRACOM)||(type==HP)||(type==MOTOROLA)||(type==GC1000)||(type==GC1001)||(type==ROCKWELL)||(type==TRIMBLE)||(type==AMDAT)||(type==NMEA)||(type==AECBOX)||(type==MOBATIME)||(type==TTTL3)||(type==RCC)||(type==TTK)

#endif

#define NETWORKTYPE(type) \
                 ((type == NTP) || (type == PRIMARY) || (type == SECONDARY))

#define JITTER_LIMIT 50
#define NextSkewX(x) x++
#define ModSkew(x) (x % SKEWHISTORYSIZE)
#define SECTION TEXT("timeserv")
#define PROFILE TEXT("timeserv.ini")

#define DEFAULT(x) x.element[0].key

#define CLUSTER_PERIOD 0xFFFC
#define BIDAILY_PERIOD 0xFFFF
#define TRIDAILY_PERIOD 0xFFFE
#define WEEKLY_PERIOD  0xFFFD
#define SPECIAL_PERIOD_FLOOR 0xFFFC

#if BASEONLY == 0
#define LegalType(x) (x < MAXTYPE)
#else
#define LegalType(x) ((x == PRIMARY)    \
                           ||           \
                      (x == SECONDARY)  \
                           ||           \
                      (x == NTP))
#endif

#define MAX_THREADS_IN_SERVER  8

#define TSKEY TEXT("SYSTEM\\CurrentControlSet\\Services\\TimeServ\\Parameters")

#define SECOND_TICKS    (1000L)
#define MINUTE_TICKS    (60 * SECOND_TICKS)
#define HOUR_TICKS      (60 * MINUTE_TICKS)
#define DAY_TICKS       (24 * HOUR_TICKS)

#define MAXBACKSLEW (3 * MINUTE_TICKS)       // max back correction allowed

#define CLUSTERSHORTINTERVAL (45 * MINUTE_TICKS)

#define CLUSTERLONGHOURS     (8)
#define CLUSTERLONGINTERVAL  (CLUSTERLONGHOURS * HOUR_TICKS)

//
// ERRORPART is the minimum contribution that the inherent clock frequency
// is allowed to introduce. This is used as a multiplier of the clock
// frequency to be the floor for the clock error to which a skew correction
// can be applied. In other words, if F is the number of ms per clock tick,
// then the minimum clockerror that can be used is:
//        F * 2 * ERRORPART
// The 2 is used to compensate for two clocks.
//
// If you change the value, please update the following explanation:
//
// The number 7 was chosen to give the best resolution for the "cluster"
// mode. In this mode, we wish to do a "quick", around 3 hours, slew analysis
// to ensure that the clocks are reasonably close. The value 7 means
// that a three hour sample must produce an error > 140 ms in order for
// skew correction to happen. This is the equivalent of almost 1.2 secs/day
// of error. Then we wish to lapse into a "long" cycle, namely 8 hours,
// before sampling. A 1.2 sec/day error sampled each 8 hours allows for
// 400 ms of observed error, or just within the bounds of 1/2 sec of skew
// among the cluster systems. Using 7 means we are tolerating 1 part in
// 7 of error, or around 15%. It's not great, but it's probably good
// enough.\
//
// Note also that 140 is very close to 1/2 of the minimum clock correction
// applied over 8 hours. The correction of 1 part  is about 296 ms over
// 8 hours. 1/2 of that is about 148 ms. So, using 7 not only provides
// a good management of measurement error, it also is very close
// to the minimum skew correction it makes sense to apply.  What this
// says is that in a cycle of 8 hours or more, the filter based on
// ERRORPART is probably unnecessary, hence it exists  principally
// for catching errors over smaller measurement intervals. And that
// is the intent.
//

#define ERRORPART    7

#define ERRORMINIMUM(x) (x * 2 * ERRORPART)

//
// N.B. Another factor to consider is that one tick of the system clock, or
// 100 ns, adjustment produces a change of 864 ms/day. So, in principle,
// any adjustement for a skew of less than 864 ms a day is unstable and will
// produce precesion. Of course, by changing the adjustment periodically,
// it is possible to get two clocks that disagree by less than 864 ms/day
// to come into better agreement, but it requires a constant adjustment
// of at least one of the clocks.
//

#define MAXSKEWCORRECT  30000   // max ms/day error we will correct.

#define MAXERRORTOALLOW 500    // keep it within this

#endif    // TSCONGIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\test\main.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

DWORD
TSNewSource(
    IN LPTSTR ServerName,
    IN LPTSTR SourceName,
    IN DWORD Reserved
    );

_cdecl
main(int argc, char ** argv)
{
    DWORD err;
    LPSTR server;
    LPWSTR serverName;
    WCHAR  computerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD  computerNameSize = MAX_COMPUTERNAME_LENGTH+1;

    server = getenv( "TargetSystem" );
    if ( server == NULL ) {
        printf("Please define 'TargetSystem' first!\n");
        return(1);
    }

    serverName = LocalAlloc( LMEM_ZEROINIT, (strlen(server) + 1) * sizeof(WCHAR) );
    if ( serverName == NULL ) {
        printf("Failed to allocate a %d byte buffer!\n",
            (strlen(server) + 1) * sizeof(WCHAR) );
        return(1);
    }

    if ( argc > 1 ) {
        printf("usage: %s\n", *argv);
        return(1);
    }

    mbstowcs( serverName, server, strlen(server) );

    err = GetComputerNameW( computerName, &computerNameSize );
    if ( !err  ) {
        printf("Failed to get local computer name, error %d\n", err);
        return(1);
    }

    printf("Telling %s to use local system (%ws) as a time source!\n",
        server, computerName);

    err = TSNewSource(serverName,
                      computerName,
                      0);
    printf("status = %d\n", err);

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\test\tsremote.c ===
/*
 * APIs to manage the timeservice on another machine. 
 */

#include <windows.h>
#include "tsconfig.h"
#include "stdio.h"

// data and definitions



//
// API to set the new primary target and to cycle the service. This
// is used by the cluster code to distribute new information
//

DWORD
TSNewSource(
    IN LPTSTR ServerName,
    IN LPTSTR SourceName,
    IN DWORD  Reserved
    )

/*++

Routine Description:

    Set the PrimarySource for the Time Service on the given server system to
    the specified source.

Arguments:

    ServerName - The remote system on which to set the PrimarySource.

    SourceName - The PrimarySource for the Time Service's time.

    Reserved - not used.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    HKEY hKey = 0, hKey1 = 0;
    SC_HANDLE  scHandle, scHandle1 = 0;
    PWCHAR pwszData;
    PWCHAR pwszVersion = NULL;
    DWORD err;
    DWORD dwSize, dwTotalSize;
    DWORD type;

    //
    // REG_MULTI_SZ data needs an extra NULL at the end. So copy
    // the string into a buffer large enough to add a NULL.
    //
    dwSize = wcslen(SourceName);

    dwTotalSize = (dwSize + 1) * sizeof(WCHAR);

    pwszData = LocalAlloc(LMEM_FIXED,
                          dwTotalSize);

    if(!pwszData) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wcscpy(pwszData, SourceName);
    pwszData[dwSize] = (WCHAR)0;

    //
    // Open the remote service controller.
    //
    scHandle = OpenSCManager(ServerName,
                             NULL,
                             SERVICE_START |
                             SERVICE_STOP) ;

    if (!scHandle) {
        err = GetLastError();
        goto NonStart;
    }

    //
    // Make sure the remote registry is accessible as well
    //

    err = RegConnectRegistry(ServerName,
                             HKEY_LOCAL_MACHINE,
                             &hKey);

    if ((err == ERROR_SUCCESS)
             &&
       (err = RegOpenKeyEx(hKey,
                       TSKEY,
                       0,
                       KEY_READ | KEY_WRITE,
                       &hKey1)) == ERROR_SUCCESS)

    {
        //
        // First check the Time Service version to see if we should even
        // attempt to stop it.
        //
        dwSize = 2;

retry:
        if ( pwszVersion != NULL ) {
            LocalFree(pwszVersion);
        }
        pwszVersion = LocalAlloc( LMEM_FIXED, dwSize );
        if ( pwszVersion == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        err = RegQueryValueEx(hKey1,
                              TEXT("Version"),
                              0,
                              &type,
                              (PBYTE)pwszVersion,
                              &dwSize);
        if ( err == ERROR_MORE_DATA ) {
            goto retry;
        }

        if ( (err != ERROR_FILE_NOT_FOUND) &&
             ((err != ERROR_SUCCESS) ||
             (type != REG_SZ)) ) {
            LocalFree(pwszVersion);
            return(err);
        }

        if ( (err != ERROR_FILE_NOT_FOUND) &&
             (_wcsicmp( pwszVersion, L"Base" ) != 0) )  {
            printf("Remote Time Service is not running as a base service!\n");
            LocalFree(pwszVersion);
            return(ERROR_SUCCESS);
        }
        LocalFree(pwszVersion);

        //
        //
        // Change the key now
        //

        err = RegSetValueEx(hKey1,
                            TEXT("PrimarySource"),
                            0,
                            REG_MULTI_SZ,
                            (PBYTE)pwszData,
                            dwTotalSize);

        if (err == ERROR_SUCCESS) {
            DWORD retryCount = 20;

            //
            // cycle the service.  If the service cannot be opened,
            // return no error. If the service can be opened but
            // is not started, also return no error.
            //

            scHandle1 = OpenService(scHandle,
                                    TEXT("TimeServ"),
                                    SERVICE_START |
                                    SERVICE_STOP | SERVICE_INTERROGATE);

            if (scHandle1) {
                SERVICE_STATUS ss;
                BOOL fStatus;

                fStatus = ControlService(scHandle1,
                                         SERVICE_CONTROL_INTERROGATE,
                                         &ss);
                if (!fStatus) {
                    //
                    // can't control it. If that is because it's
                    // not active, report OK.
                    //
                    err = GetLastError();
                    if (err == ERROR_SERVICE_NOT_ACTIVE) {
                        if (!StartService(scHandle1, 0, 0)) {
                            err = GetLastError();
                        } else {
                            err = ERROR_SUCCESS;
                        }
                    }
                } else if (ss.dwCurrentState == SERVICE_RUNNING) {
                    if (!ControlService(scHandle1,
                                      SERVICE_CONTROL_STOP,
                                      &ss) ) {
                        err = GetLastError();
                    } else {
                        // Wait for Service to stop.
                        ss.dwCurrentState = SERVICE_RUNNING;
                        while ( (ss.dwCurrentState != SERVICE_STOPPED) &&
                                retryCount-- ) {

                            ControlService(scHandle1,
                                             SERVICE_CONTROL_INTERROGATE,
                                             &ss);
                            Sleep(300);
                        }
                        if ( (_wcsicmp( ServerName, SourceName ) != 0) &&
                             !StartService(scHandle1, 0, 0) ) {
                           err = GetLastError();
                        }
                    }
                }
            }
        }
    }

    if (scHandle1) {
        CloseServiceHandle(scHandle1);
    }

    CloseServiceHandle(scHandle);

    if(hKey1) {
        RegCloseKey(hKey1);
    }

    if(hKey) {
        RegCloseKey(hKey);
    }

NonStart:
    LocalFree(pwszData);
    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\clusbrow\clusbrow.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:clusbrow.cpp
//
//  Contents:  To list all the clusters in the network. 
//  
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    3-24-1997   sivapad   Created
//
//----------------------------------------------------------------------------

#define UNICODE 1
#define _UNICODE 1

#include <windows.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmserver.h>
#include <windns.h>
#include <stdio.h>
#include <stdlib.h>

#define SRV101_ENTRY_COUNT 1024

void Usage ()
{
    wprintf (L"clusbrow [domain:<Domain name>] [servertype:CORE|VS]\n") ;
	exit (1) ;
}

int __cdecl
wmain (DWORD argc, WCHAR *argv[])
{
    PSERVER_INFO_101 srvInfo;
    DWORD i, dwRet, entriesRead, totalEntries ;
	DWORD serverType = SV_TYPE_CLUSTER_NT | SV_TYPE_CLUSTER_VS_NT ;
    DWORD entryCount;
    WCHAR blanks[] = L"                                                ";
    DWORD numBlanks;
	WCHAR szDomainName [DNS_MAX_NAME_BUFFER_LENGTH] ;
    LPTSTR pszDomainName = NULL ;

	// Process the command line arguments

	for (i=1; i<argc; i++)
	{
		if (_wcsnicmp (argv[i], L"domain:", 7) == 0)
		{
			swprintf (szDomainName, L"%hs", argv[i]+7) ;
			pszDomainName = szDomainName ; 
		}
		else if (_wcsnicmp (argv[i], L"servertype:", 11) == 0)
		{
            serverType = 0;
            if (_wcsnicmp( argv[i]+11, L"core", 4 ) == 0 ) {
                serverType = SV_TYPE_CLUSTER_NT;
            }

            if (_wcsnicmp( argv[i]+11, L"vs", 2 ) == 0 ) {
                serverType |= SV_TYPE_CLUSTER_VS_NT;
            }
		}
		else
		{
			Usage () ;
		}
	}

    dwRet = NetServerEnum (NULL,
                           101,
                           (LPBYTE *)&srvInfo,
                           MAX_PREFERRED_LENGTH,
                           &entriesRead,
                           &totalEntries,
                           serverType,
                           pszDomainName,
                           0) ;

    if (dwRet == NERR_Success)
    {
        wprintf(L"Number of Entries found = %u\n", totalEntries );

        for (i=0; i < entriesRead; i++) {
            numBlanks = 20 - wcslen( srvInfo->sv101_name );
            wprintf (L"%ws%.*ws", srvInfo->sv101_name, numBlanks, blanks );

            if ( srvInfo->sv101_type & SV_TYPE_CLUSTER_NT &&
                 srvInfo->sv101_type & SV_TYPE_CLUSTER_VS_NT )
            {
                wprintf(L"CORE, VS");
            } else if ( srvInfo->sv101_type & SV_TYPE_CLUSTER_NT ) {
                wprintf(L"CORE");
            } else if ( srvInfo->sv101_type & SV_TYPE_CLUSTER_VS_NT ) {
                wprintf(L"VS");
            }
            else {
                wprintf(L"????");
            }
            wprintf(L"\n");

            ++srvInfo;
        }
    }
    else
    {
         wprintf (L"Error, making the actual call to NetServerEnum dwRet=%d\n", dwRet) ;
         exit (1) ;
    }

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\capplicationwindow.cpp ===
//
// CApplicationWindow.CPP
//
// Application Window Class
//

#include "stdafx.h"
#include <commctrl.h>
#include <shellapi.h>
#include "commdlg.h"
#include "resource.h"
#include "CApplicationWindow.h"
#include "CFindDialog.h"

#define CAPPLICATIONWINDOWCLASS TEXT("CApplicationWindowClass")
#define WINDOWMENU 1

BOOL g_fCApplicationWindowClassRegistered = FALSE;
BOOL g_fCApplicationWindowDestroyed = FALSE;

// these are used to track the next occurrence of the phrases
LPTSTR g_pszDispatch;
LPTSTR g_pszDispatch2;
LPTSTR g_pszCompleted;
    
//
// Constructor
//
CApplicationWindow::CApplicationWindow( )
{
    BOOL b;
    LPTSTR psz;
    LONG sx = GetSystemMetrics( SM_CXFULLSCREEN );
    LPTSTR lpCmdLine;

    Cleanup( TRUE );

    if ( !g_fCApplicationWindowClassRegistered )
    {
        WNDCLASSEX wcex;

        wcex.cbSize         = sizeof(WNDCLASSEX);
        wcex.style			= CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc	= (WNDPROC)CApplicationWindow::WndProc;
        wcex.cbClsExtra		= 0;
        wcex.cbWndExtra		= 0;
        wcex.hInstance		= g_hInstance;
        wcex.hIcon			= LoadIcon(g_hInstance, (LPCTSTR) IDI_CLUSLOG );
        wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground	= (HBRUSH) COLOR_GRAYTEXT; //NULL;
        wcex.lpszMenuName	= (LPCSTR)IDC_SOL;
        wcex.lpszClassName	= CAPPLICATIONWINDOWCLASS;
        wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR) IDI_SMALL );

        RegisterClassEx(&wcex);
    }

    HANDLE hFile;

    hFile = CreateFile( "filter.txt",
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
    if ( hFile != INVALID_HANDLE_VALUE )
    {    
        LONG nLength = GetFileSize( hFile, NULL );

        nLength++; // one for NULL

        g_pszFilters = (LPTSTR) LocalAlloc( LPTR, nLength );
        if ( g_pszFilters )
        {
            DWORD dwRead; // dummy
            ReadFile( hFile, g_pszFilters, nLength, &dwRead, NULL );

            g_pszFilters[nLength-1] = 0;

            CloseHandle( hFile );

            g_nComponentFilters = 0;
            psz = g_pszFilters;
            while ( psz < &g_pszFilters[nLength-1] )
            {
                LPTSTR pszStart = psz;
                while ( *psz && *psz != 13 )
                {
                    psz++;
                }

                psz += 2;

                g_nComponentFilters++;
            }

            g_pfSelectedComponent = (BOOL*) LocalAlloc( LPTR, g_nComponentFilters * sizeof(BOOL) );
        }
    }

    _hWnd = CreateWindowEx( WS_EX_ACCEPTFILES,
                            CAPPLICATIONWINDOWCLASS, 
                            TEXT("Cluster Log Analyzer"), 
                            WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS,
                            CW_USEDEFAULT, 
                            CW_USEDEFAULT, 
                            CW_USEDEFAULT, 
                            CW_USEDEFAULT, 
                            NULL, 
                            NULL,
                            g_hInstance, 
                            (LPVOID) this);
    if (!_hWnd)
    {
        return;
    }

    _hMenu = CreatePopupMenu( );

    MENUITEMINFO mii;
    ZeroMemory( &mii, sizeof(mii) );
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STRING | MIIM_STATE | MIIM_ID;
    mii.fState = MFS_CHECKED;
    mii.wID = IDM_FIRST_CS_FILTER ;

    psz = g_pszFilters;
    if ( psz )
    {
        while ( *psz && mii.wID < IDM_LAST_CS_FILTER )
        {
            mii.dwTypeData = psz;
            while ( *psz && *psz != 13 )
            {
                psz++;
            }
            if ( *psz == 13 )
            {
                *psz = 0;
                psz++;
                if ( *psz )
                {
                    psz++;
                }
            }
            mii.wID++;
            mii.cch = (UINT)(psz - mii.dwTypeData);
            b = InsertMenuItem( _hMenu, -1, TRUE, &mii );
        }
    }

    HMENU hMenu = GetSubMenu( GetMenu( _hWnd ), 2 );
    b = AppendMenu( hMenu, MF_POPUP, (UINT_PTR) _hMenu, "&Cluster Service" );

    DrawMenuBar( _hWnd );
    
    ShowWindow( _hWnd, SW_SHOW );
    UpdateWindow( _hWnd );

    lpCmdLine = GetCommandLine( );
	if ( lpCmdLine )
	{
        if ( lpCmdLine[0] == '\"' )
        {
            lpCmdLine++;
            while ( *lpCmdLine  && *lpCmdLine != '\"' )
            {
                lpCmdLine++;
            }
            if ( *lpCmdLine )
            {
                lpCmdLine++;
            }
            if ( *lpCmdLine )
            {
                lpCmdLine++;
            }
        }
        else
        {
            while ( *lpCmdLine && *lpCmdLine != 32 )
            {
                lpCmdLine++;
            }
            if ( *lpCmdLine )
            {
                lpCmdLine++;
            }
        }
        while ( lpCmdLine[0] )
        {
            LPSTR psz = strchr( lpCmdLine, 32 );
            if ( psz )
            {
                *psz = 0;
            }

            if ( lpCmdLine[1] != ':' 
              && lpCmdLine[1] != '\\' )
            {
                LPTSTR pszFilename = (LPTSTR) 
                    LocalAlloc( LMEM_FIXED, MAX_PATH * sizeof(TCHAR) );
                if ( pszFilename )
                {
                    DWORD dwRead;

                    dwRead = GetCurrentDirectory( MAX_PATH, pszFilename );
                    if ( dwRead >= MAX_PATH )
                    {
                        LocalFree( pszFilename );

                        pszFilename = (LPTSTR) 
                            LocalAlloc( LMEM_FIXED, 
                                        ( dwRead + MAX_PATH ) * sizeof(TCHAR) );
                        if ( pszFilename )
                        {
                            dwRead = GetCurrentDirectory( MAX_PATH, pszFilename );
                        }
                    }

                    if ( pszFilename 
                      && dwRead != 0 )
                    {
                        strcat( pszFilename, TEXT("\\") );
                        strcat( pszFilename, lpCmdLine );
		                _LoadFile( pszFilename );
                    }

                }
                else
                {
                    break;
                }
            }

            if ( *lpCmdLine )
            {
		        _LoadFile( lpCmdLine );
            }

            lpCmdLine += lstrlen( lpCmdLine );
            if ( psz )
            {
                lpCmdLine++;
                *psz = 32;
            }
        }
	}
}

//
// Destructor
//
CApplicationWindow::~CApplicationWindow( )
{
    Cleanup( );
    ShowWindow( _hWnd, SW_HIDE );
}

//
//
//
HRESULT
CApplicationWindow::Cleanup( 
    BOOL fInitializing  // = FALSE
    )
{
    if ( !fInitializing )
    {
        for( ULONG nFile = 0; nFile < _nFiles; nFile++ )
        {
            LocalFree( _pFiles[ nFile ] );
            LocalFree( _pszFilenames[ nFile ] );
            LocalFree( _pNodes[ nFile ] );
        }
    }

    _nFiles = 0;
    _cTotalLineCount = 0;
    _fVertSBVisible = FALSE;
    _uStartSelection = 0;
    _uEndSelection = 0;
    _uPointer = 0;
    _pLines = 0;

    ZeroMemory( &_LineFinder, sizeof(_LineFinder) );
    _uFinderLength = 0;

    ShowScrollBar( _hWnd, SB_VERT, FALSE );

    return S_OK;
}

//
// _CalculateOffset( )
//
HRESULT
CApplicationWindow::_CalculateOffset( 
    FILETIME * pftOper1,
    FILETIME * pftOper2,
    INT      * pnDir,
    FILETIME * pftOffset
    )
{
    *pnDir = CompareFileTime( pftOper1, pftOper2 );
    if ( *pnDir > 0 )
    {
        pftOffset->dwHighDateTime = pftOper1->dwHighDateTime - pftOper2->dwHighDateTime;
        pftOffset->dwLowDateTime  = pftOper1->dwLowDateTime  - pftOper2->dwLowDateTime;
        if ( pftOper1->dwLowDateTime < pftOper2->dwLowDateTime )
        {
            pftOffset->dwHighDateTime++;
        }
    }
    else if ( *pnDir < 0 )
    {
        pftOffset->dwHighDateTime = pftOper2->dwHighDateTime - pftOper1->dwHighDateTime;
        pftOffset->dwLowDateTime  = pftOper2->dwLowDateTime  - pftOper1->dwLowDateTime;
        if ( pftOper1->dwLowDateTime > pftOper2->dwLowDateTime )
        {
            pftOffset->dwHighDateTime--;
        }
    }

    return S_OK;
}



// 
// _FindSequencePoint( )
//
BOOL
CApplicationWindow::_FindSequencePoint(
    LPTSTR * ppszSequence,
    ULONG * pnSequence
    )
{

    while( *ppszSequence )
    {
        if ( *ppszSequence > g_pszDispatch )
        {
            g_pszDispatch = strstr( *ppszSequence, "dispatching seq " ) - 1;
        }
        if ( *ppszSequence > g_pszCompleted )
        {
            g_pszCompleted = strstr( *ppszSequence, "completed update seq " ) - 1;
        }
        if ( *ppszSequence > g_pszDispatch2 )
        {
            g_pszDispatch2 = strstr( *ppszSequence, "Dispatching seq " ) - 1;
        }

        if ( g_pszDispatch < g_pszCompleted )
        {
            (*ppszSequence) = g_pszDispatch + sizeof("dispatching seq ") - 1;
            if ( pnSequence )
            {
                *pnSequence = atol ( *ppszSequence );
                (*pnSequence) *= 3;
            }
            break;
        }

        if ( g_pszDispatch2 < g_pszCompleted )
        {
            (*ppszSequence) = g_pszDispatch2 + sizeof("Dispatching seq ") - 1;
            if ( pnSequence )
            {
                *pnSequence = atol ( *ppszSequence );
                (*pnSequence) *= 3;
                (*pnSequence)++;
            }
            break;
        }

        if ( g_pszCompleted + 1 != NULL )
        {
            (*ppszSequence) = g_pszCompleted + sizeof("completed update seq ") - 1;
            if ( pnSequence )
            {
                *pnSequence = atol ( *ppszSequence );
                (*pnSequence) *= 3;
                (*pnSequence)++;
                (*pnSequence)++;
            }
            break;
        }

        *ppszSequence = NULL;
        return FALSE;
    }

    return TRUE;
}

//
// _RetrieveTimeDate( )
//
HRESULT
CApplicationWindow::_RetrieveTimeDate(
    LPTSTR pszCurrent,
    SYSTEMTIME * pst,
    LPTSTR * ppszFinal
    )
{
    if ( ppszFinal )
    {
        *ppszFinal = pszCurrent;
    }

    // Find the thread and process IDs
    while ( *pszCurrent && *pszCurrent != ':' && *pszCurrent != 10 )
    {
        pszCurrent++;
    }
    if ( *pszCurrent != ':' )
        return S_FALSE;

    pszCurrent++;
    if ( *pszCurrent != ':' )
        return S_FALSE;

    pszCurrent++;

    // Find Time/Date stamp which is:
    // ####/##/##-##:##:##.###<space>
    pst->wYear = (WORD) atol( pszCurrent );

    while (  *pszCurrent >= '0' && *pszCurrent <= '9' )
    {
        pszCurrent++;
    }
    if ( *pszCurrent == '-' )
    {
        //
        // The "year" we got above should really be the day.
        // We'll replace the year with zero and the month with one.
        //
        pst->wDay = pst->wYear;
        pst->wYear = 0;
        pst->wMonth = 1;
        goto SkipDate;
    }
    if ( *pszCurrent != '/' )
        return S_FALSE;

    pszCurrent++;

    pst->wMonth = (WORD) atol( pszCurrent );

    while (  *pszCurrent >= '0' && *pszCurrent <= '9' )
    {
        pszCurrent++;
    }
    if ( *pszCurrent != '/' )
        return S_FALSE;

    pszCurrent++;

    pst->wDay = (WORD) atol( pszCurrent );

    while (  *pszCurrent >= '0' && *pszCurrent <= '9' )
    {
        pszCurrent++;
    }
    if ( *pszCurrent != '-' ) 
        return S_FALSE;

SkipDate:
    pszCurrent++;

    pst->wHour = (WORD) atol( pszCurrent );

    while (  *pszCurrent >= '0' && *pszCurrent <= '9' )
    {
        pszCurrent++;
    }
    if ( *pszCurrent != ':' )
        return S_FALSE;

    pszCurrent++;

    pst->wMinute = (WORD) atol( pszCurrent );

    while (  *pszCurrent >= '0' && *pszCurrent <= '9' )
    {
        pszCurrent++;
    }
    if ( *pszCurrent != ':' )
        return S_FALSE;

    pszCurrent++;

    pst->wSecond = (WORD) atol( pszCurrent );

    while (  *pszCurrent >= '0' && *pszCurrent <= '9' )
    {
        pszCurrent++;
    }
    if ( *pszCurrent != '.' )
        return S_FALSE;

    pszCurrent++;

    pst->wMilliseconds = (WORD) atol( pszCurrent );

    while (  *pszCurrent >= '0' && *pszCurrent <= '9' )
    {
        pszCurrent++;
    }

    if ( ppszFinal )
    {
        *ppszFinal = pszCurrent;
    }

    return S_OK;
}

//
// _GetFilename( )
//
HRESULT
CApplicationWindow::_GetFilename( 
    LPTSTR pszFilename, 
    LPTSTR pszFilenameOut,
    LONG * pcch
    )
{
    LONG cch = 0;

    if ( g_fShowServerNames && pszFilename[ 0 ] == '\\' && pszFilename[ 1 ] == '\\' )
    {
        LPTSTR psz = &pszFilename[ 2 ];
        while ( *psz && *psz != '\\' )
        {
            psz++;
            cch++;
        }
        psz--;
        cch += 2;
    }
    else if ( strchr( pszFilename, '\\' ) )
    {
        pszFilename = pszFilename + lstrlen( pszFilename );
        while ( *pszFilename != '\\' )
        {
            pszFilename--;
            cch++;
        }
        pszFilename++;
        cch--;
    }
    else
    {
        cch = lstrlen( pszFilename );
    }
    
    if ( pszFilenameOut )
    {
        if ( !pcch )
            return E_POINTER;

        if ( cch >= *pcch )
        {
            cch = *pcch - 1;
        }
        strncpy( pszFilenameOut, pszFilename, cch );
        pszFilenameOut[ cch ] = 0;
    }
    if ( pcch )
    {
        *pcch = cch;
    }

    return S_OK;
}

//
// _StatusWndProc( )
//
LRESULT CALLBACK
CApplicationWindow::_StatusWndProc( 
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    return 0;
}


//
// _CombineFiles( )
//
HRESULT
CApplicationWindow::_CombineFiles( )
{
    HRESULT     hr;             // general purpose HRESULT and return code
    BOOL        b;              // general purpose return BOOL
    ULONG       nFileLineCount; // counter of the lines in the file
    ULONG       nSequence;      // ID of current sequence
    ULONG       nNextSequence;  // ID of the next squence
    LPTSTR      pszSequence;    // next sequence location
    LPTSTR      pszCurrent;     // current parse location within file
    BOOL        fSyncPoint;     // flag indicating a sync point was encountered
    SYSTEMTIME  st;             // used to convert "line time" to a filetime.
    FILETIME    ft;             // current lines filetime
    FILETIME    ftOffset;       // current filetime offset
    INT         nDir;           // offset direction

    MSG         msg;            // message pumping
    HWND        hwndProcessing; // processing window handle
    HWND        hwndStatus;     // progress bar window handle

    SCROLLINFO  si;             // verticle scroll bar

    LINEPOINTER * pLastSyncPoint;   // last place a sync point in other files was encountered
    LINEPOINTER * pInsertionPoint;  // next place a node will be inserted
    LINEPOINTER * pNewLine;         // next structure to be used as a node

    CWaitCursor Wait;           // show the hour glass

    si.cbSize = sizeof(si);
    si.fMask = SIF_RANGE | SIF_PAGE;
    GetScrollInfo( _hWnd, SB_VERT, &si );
    si.fMask = SIF_RANGE;

    ZeroMemory( &ftOffset, sizeof(ftOffset) );
    nDir = 0;
    g_pszDispatch = NULL;
    g_pszDispatch2 = NULL;
    g_pszCompleted = NULL;

    // scan to figure out the line count of the new file
    nFileLineCount = 0;
    pszCurrent = _pFiles[ _nFiles ];
    while ( *pszCurrent )
    {
        if ( *pszCurrent == 10 )
        {
            nFileLineCount++;
        }

        pszCurrent++;
    }

    if ( !_pLines )
    {
        // add one more for the root node
        nFileLineCount++;
    }

    // allocate all the memory up front to avoid fragmenting memory as well as
    // descreasing the number of heap calls
    _pNodes[ _nFiles ] = (LINEPOINTER *) LocalAlloc( LMEM_FIXED, nFileLineCount * sizeof(LINEPOINTER) );
    if ( !_pNodes[ _nFiles ] )
    {
        return E_OUTOFMEMORY;
    }

    pNewLine = _pNodes[ _nFiles ];

    if ( !_pLines )
    {
        _pLines = pNewLine;
        ZeroMemory( _pLines, sizeof(LINEPOINTER) );
        pNewLine++;
    }

    // Create wait modeless dialog
    hwndProcessing = CreateDialog( g_hInstance,
                                   MAKEINTRESOURCE(IDD_PROCESSING), 
                                   _hWnd,
                                   (DLGPROC) CApplicationWindow::_StatusWndProc );

    hwndStatus = GetDlgItem( hwndProcessing, IDC_P_STATUS );
    SendMessage( hwndStatus, PBM_SETRANGE32, 0, nFileLineCount );
    SendMessage( hwndStatus, PBM_SETPOS, 0, 0 );
    SendMessage( hwndStatus, PBM_SETSTEP, 1, 0 );
    SetWindowText( GetDlgItem( hwndProcessing, IDC_S_FILENAME ), _pszFilenames[ _nFiles ] );

    // Find the first sync point
    nNextSequence = nSequence = 0;
    pszSequence = _pFiles[ _nFiles ];
    if ( _FindSequencePoint( &pszSequence, &nNextSequence ) )
    {
RetrySequencing:
        if ( _nFiles )
        {
            LINEPOINTER * lp = _pLines;
            while ( lp->pNext
                && nNextSequence != lp->uSequenceNumber )
            {
                lp = lp->pNext;
                // pump some messages....
                if ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
                {
                    if ( !IsDialogMessage( g_hwndFind, &msg ) )
                    {
                        TranslateMessage( &msg );
    	                DispatchMessage( &msg );
                    }
                    if ( g_fCApplicationWindowDestroyed )
                    {
                        return E_FAIL; // not break!
                    }
                }
            }

            if ( nNextSequence == lp->uSequenceNumber )
            {
                pszCurrent = pszSequence;
                while( pszCurrent >= _pFiles[ _nFiles ] && *pszCurrent != 10 )
                {
                    pszCurrent--;
                }

                pszCurrent++;

                hr = _RetrieveTimeDate( pszCurrent, &st, NULL );
                b = SystemTimeToFileTime( &st, &ft );
                _CalculateOffset( &ft, &lp->Time, &nDir, &ftOffset );

                nSequence = nNextSequence - 1;
            }
            else 
            {
                if ( _FindSequencePoint( &pszSequence, &nNextSequence ) )
                    goto RetrySequencing;

                nNextSequence = nSequence = 0;
            }
        }
        else
        {
            nSequence = nNextSequence - 1;
        }
    }

    nFileLineCount = 1;
    pszCurrent = _pFiles[ _nFiles ];
    pInsertionPoint = _pLines;

    while ( *pszCurrent )
    {
        LPTSTR pszStart = pszCurrent;

        // this will parse past the PID.TID and Time/Date
        hr = _RetrieveTimeDate( pszCurrent, &st, &pszCurrent );

        b = SystemTimeToFileTime( &st, &ft );

        // skip spaces
        while ( *pszCurrent == 32)
        {
            pszCurrent++;
        }

        // fill in preliminary info
        pNewLine->fFiltered       = FALSE;
        pNewLine->nFile           = _nFiles;
        pNewLine->nLine           = nFileLineCount;
        pNewLine->psLine          = pszStart;

        // note warning level of line
        //
        if ( _stricmp( "INFO", pszCurrent ))
        {
            pNewLine->WarnLevel = WarnLevelInfo;
        }
        else if ( _stricmp( "WARN", pszCurrent ))
        {
            pNewLine->WarnLevel = WarnLevelWarn;
        }
        else if ( _stricmp( "ERR ", pszCurrent ))
        {
            pNewLine->WarnLevel = WarnLevelError;
        }
        else
        {
            pNewLine->WarnLevel = WarnLevelUnknown;
        }

        if ( pNewLine->WarnLevel != WarnLevelUnknown )
        {
            // skip chars, then spaces only if we found the tag
            while ( *pszCurrent != 32)
            {
                pszCurrent++;
            }
            while ( *pszCurrent == 32)
            {
                pszCurrent++;
            }
        }

        // [OPTIONAL] Cluster component which looks like: 
        // [<id...>]
        if ( *pszCurrent == '[' )
        {
            LPTSTR pszComponentTag = pszCurrent;

            while ( *pszCurrent && *pszCurrent != ']' && *pszCurrent >= 32 )
            {
                pszCurrent++;
            }
            if ( *pszCurrent < 32 )
            {
                pszCurrent = pszComponentTag;
                goto NoComponentTryResouce;
            }

            pszCurrent++;

            // found component
            USHORT nFilterId = 0;
            LONG   nLen      = (LONG)(pszCurrent - pszComponentTag - 2);
            LPTSTR psz       = g_pszFilters;
            while ( nFilterId < g_nComponentFilters )
            {
                if ( nLen == lstrlen( psz )
                  && _strnicmp( pszComponentTag + 1, psz, nLen ) == 0 )
                {
                    pNewLine->nFilterId = nFilterId + 1;
                    if ( g_pfSelectedComponent[ nFilterId ] )
                    {
                        pNewLine->fFiltered = TRUE;
                    }
                    break;
                }

                while ( *psz )
                {
                    psz++;
                }
                psz += 2;

                nFilterId++;
            }
        }
        else
        {
            // [OPTIONAL] If not a component, see if there is a res type
NoComponentTryResouce:
            LPTSTR pszResType = pszCurrent;

            while ( *pszCurrent && *pszCurrent != ':' && *pszCurrent >= 32 )
            {
                pszCurrent++;
            }

            if ( *pszCurrent >= 32 )
            {
                pszCurrent++;

                // found a restype
                pNewLine->nFilterId = g_nComponentFilters + 1; // TODO: make more dynamic
                if ( g_fResourceNoise )
                {
                    pNewLine->fFiltered = TRUE;
                }
            }
        }

        // Find the beggining of the next line
        while ( *pszCurrent && *pszCurrent != 10 )
        {
            pszCurrent++;
        }
        if ( *pszCurrent )
        {
            pszCurrent++;
        }

        // See if we just past a sync point
        if ( pszSequence && pszCurrent > pszSequence )
        {
            fSyncPoint = TRUE;
            nSequence = nNextSequence;

            // find the next sync point
            _FindSequencePoint( &pszSequence, &nNextSequence );
            if ( _nFiles )
            {
                // if we are out of sync, move the insertion point ahead
                if ( pInsertionPoint->pNext != NULL 
                  && nSequence >= pInsertionPoint->uSequenceNumber )
                {
                    for( pLastSyncPoint = pInsertionPoint; pLastSyncPoint->pNext; pLastSyncPoint = pLastSyncPoint->pNext )
                    {
                        if ( pLastSyncPoint->nFile != _nFiles 
                          && ( nSequence < pLastSyncPoint->uSequenceNumber 
                            || ( pLastSyncPoint->fSyncPoint 
                              && nSequence == pLastSyncPoint->uSequenceNumber ) ) )
                        {
                            break;
                        }
                    }

                    if ( pLastSyncPoint 
                      && pLastSyncPoint->pNext 
                      && nSequence == pLastSyncPoint->uSequenceNumber )
                    {
                        pInsertionPoint = pLastSyncPoint;
                        _CalculateOffset( &ft, &pInsertionPoint->Time, &nDir, &ftOffset );
                    }
                }
            }
        }
        else
        {
            fSyncPoint = FALSE;
        }

        // adjust time to compensate for time deviations
        if ( nDir > 0 )
        {   // if we are ahead, subtract
            if ( ft.dwLowDateTime - ftOffset.dwLowDateTime > ft.dwLowDateTime )
            {
                ft.dwHighDateTime--;
            }
            ft.dwLowDateTime  -= ftOffset.dwLowDateTime;
            ft.dwHighDateTime -= ftOffset.dwHighDateTime;
        }
        else if ( nDir < 0 )
        {   // if we are behind, add
            if ( ft.dwLowDateTime + ftOffset.dwLowDateTime < ft.dwLowDateTime )
            {
                ft.dwHighDateTime++;
            }
            ft.dwLowDateTime  += ftOffset.dwLowDateTime;
            ft.dwHighDateTime += ftOffset.dwHighDateTime;
        }
        // else if nDir == 0, nothing to do

#if defined(_DEBUG) && defined(VERIFY_SYNC_POINTS)
        if ( fSyncPoint && _nFiles != 0 )
        {
            INT n = CompareFileTime( &ft, &pInsertionPoint->Time );
            if ( n != 0 )
            {
                DebugBreak( );
            }
        }
#endif // defined(_DEBUG) && defined(VERIFY_SYNC_POINTS)

        // Find the place to insert it
        while( pInsertionPoint->pNext )
        {
            if ( nSequence < pInsertionPoint->pNext->uSequenceNumber 
              && pInsertionPoint->pNext->nFile != _nFiles )
            {
                break;
            }
            INT n = CompareFileTime( &ft, &pInsertionPoint->pNext->Time );
            if ( n < 0 )
                break;
            pInsertionPoint = pInsertionPoint->pNext;
        }

        // fill-in rest of the LINEPOINTER structure
        pNewLine->Time            = ft;
        pNewLine->fSyncPoint      = fSyncPoint;
        pNewLine->uSequenceNumber = nSequence;

        // insert node into line list
        pNewLine->pNext        = pInsertionPoint->pNext;
        pNewLine->pPrev        = pInsertionPoint;
        if ( pInsertionPoint->pNext != NULL )
        {
            pInsertionPoint->pNext->pPrev = pNewLine;
        }
        pInsertionPoint->pNext = pNewLine;
        pInsertionPoint = pNewLine;
        pNewLine++;

        // dump line counts
        nFileLineCount++;
        _cTotalLineCount++;

        // synchonize the scroll bar, don't redraw it
        if ( _cTotalLineCount > 100 && _cTotalLineCount > si.nPage )
        {
            si.nMax = _cTotalLineCount;
            SetScrollInfo( _hWnd, SB_VERT, &si, FALSE );
        }

        SendMessage( hwndStatus, PBM_STEPIT, 0, 0 );

#if defined(_DEBUG) && defined(SLOW_FILL)
        if ( _nFiles )
        {
            InvalidateRect( _hWnd, NULL, TRUE );
            for( ULONG a = 0; a < 999999 ; a++ )
            {
#endif // defined(_DEBUG) && defined(SLOW_FILL)
                // pump some messages....
                if ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
                {
                    if ( !IsDialogMessage( g_hwndFind, &msg ) )
                    {
                        TranslateMessage( &msg );
    	                DispatchMessage( &msg );
                    }
                    if ( g_fCApplicationWindowDestroyed )
                    {
                        return E_FAIL; // not break!
                    }
                }
#if defined(_DEBUG) && defined(SLOW_FILL)
            }
        }
#endif // defined(_DEBUG) && defined(SLOW_FILL)
    }

    DestroyWindow( hwndProcessing );

    _nFiles++;

    if ( !_fVertSBVisible 
      && _yWindow < (LONG)(_cTotalLineCount * _tm.tmHeight) )
    {
        _fVertSBVisible = TRUE;
        EnableScrollBar( _hWnd, SB_VERT, ESB_ENABLE_BOTH );
        ShowScrollBar( _hWnd, SB_VERT, TRUE );
    }
    else if ( _fVertSBVisible
           && _yWindow >= (LONG)(_cTotalLineCount * _tm.tmHeight) )
    {
        _fVertSBVisible = FALSE;
        //EnableScrollBar( _hWnd, SB_VERT, ESB_ENABLE_BOTH );
        ShowScrollBar( _hWnd, SB_VERT, FALSE );
    }

    si.cbSize = sizeof(si);
    si.fMask  = SIF_RANGE;
    si.nMin   = 0;
    si.nMax   = _cTotalLineCount;
    SetScrollInfo( _hWnd, SB_VERT, &si, TRUE );
    
    InvalidateRect( _hWnd, NULL, TRUE );

    return S_OK;
}

//
// _LoadFile( )
//
HRESULT
CApplicationWindow::_LoadFile( 
    LPTSTR pszFilename )
{
    HRESULT  hr;
    DWORD    dwRead;
    HANDLE   hFile;
    ULONG    nLength;
    LONG     xMargin;

    _pszFilenames[ _nFiles ] = (LPTSTR) LocalAlloc( LMEM_FIXED, ( lstrlen( pszFilename ) + 1 ) * sizeof(TCHAR) );
    if ( !_pszFilenames[ _nFiles ] )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    strcpy( _pszFilenames[ _nFiles ], pszFilename );

    _GetFilename( _pszFilenames[ _nFiles ], NULL, &xMargin );
    xMargin += 7 + 2;       // line number and file number
    xMargin *= _xSpace;

    if ( xMargin > _xMargin )
    {
        _xMargin = xMargin;
    }

    hFile = CreateFile( _pszFilenames[ _nFiles ],
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError( ) );
        goto Error;
    }

    nLength = GetFileSize( hFile, NULL );
    if ( nLength == 0xFFFFffff && GetLastError( ) != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( GetLastError( ) );
        goto Error;
    }

    nLength++; // one for NULL

#if defined(_DEBUG)
    _pFiles[ _nFiles ] = (LPTSTR) LocalAlloc( LPTR, nLength );
#else
    _pFiles[ _nFiles ] = (LPTSTR) LocalAlloc( LMEM_FIXED, nLength );
#endif
    if ( !_pFiles[ _nFiles ] )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if ( !ReadFile( hFile, _pFiles[ _nFiles ], nLength, &dwRead, NULL ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError( ) );
        goto Error;
    }

    hr = _CombineFiles( );

Cleanup:
    if ( hFile != INVALID_HANDLE_VALUE )
        CloseHandle( hFile );

    return hr;

Error:
    if ( _pFiles[ _nFiles ] )
    {
        LocalFree( _pFiles[ _nFiles ] );
        _pFiles[ _nFiles ] = NULL;
    }

    MessageBox( _hWnd, pszFilename, TEXT("File Error"), MB_ICONEXCLAMATION | MB_OK );
    goto Cleanup;
}

//
// _PaintLine( )
//
HRESULT
CApplicationWindow::_PaintLine( 
    PAINTSTRUCT * pps, 
    LINEPOINTER * pCurrent, 
    LONG wxStart,
    LONG wy,
    COLORREF crText,
    COLORREF crDark, 
    COLORREF crNormal, 
    COLORREF crHightlite 
    )
{
    LPTSTR  pszStartLine;       // beginning of line (PID/TID)
    LPTSTR  pszStartTimeDate;   // beginning of time/data stamp
    LPTSTR  pszStartComponent;  // beginning of component name
    LPTSTR  pszStartResType;    // beginning of a resource component
    LPTSTR  pszStartText;       // beginning of text
    LPTSTR  pszCurrent;         // current position and beginning of text
    TCHAR   szFilename[ 40 ];
    LONG    cchFilename;

    SIZE size;
    RECT rect;
    RECT rectResult;

    LONG wx = wxStart;
    LONG wxTextStart;

    if ( pCurrent->psLine )
    {
        pszCurrent = pCurrent->psLine;

        // draw node number
        SetRect( &rect,
                 wx,
                 wy,
                 wx + _xSpace * 2,
                 wy + _tm.tmHeight );
        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            TCHAR szBuf[ 2 ];

            SetBkColor( pps->hdc, GetSysColor( COLOR_WINDOW ) );
            SetTextColor( pps->hdc, GetSysColor( COLOR_WINDOWTEXT ) );

            DrawText( pps->hdc, 
                      szBuf, 
                      wsprintf( szBuf, TEXT("%1u "), pCurrent->nFile ), 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += 2 * _xSpace;

        // Draw Filename
        cchFilename = sizeof(szFilename)/sizeof(szFilename[0]);
        _GetFilename( _pszFilenames[ pCurrent->nFile ], szFilename, &cchFilename );

        SetRect( &rect,
                 wx,
                 wy,
                 _xMargin,
                 wy + _tm.tmHeight );

        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            SetBkColor( pps->hdc, crNormal );
            SetTextColor( pps->hdc, crText );

            HBRUSH hBrush;
            hBrush = CreateSolidBrush( crNormal );
            FillRect( pps->hdc, &rect, hBrush );
            DeleteObject( hBrush );

            DrawText( pps->hdc, 
                      szFilename,
                      cchFilename, 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += _xMargin - ( 7 * _xSpace - 2 * _xSpace );

        // draw line number
        SetRect( &rect,
                 wx,
                 wy,
                 wx + 7 * _xSpace,
                 wy + _tm.tmHeight );
        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            TCHAR szBuf[ 8 ];

            SetTextColor( pps->hdc, crText );

            SetBkColor( pps->hdc, crDark );
            DrawText( pps->hdc, 
                      szBuf, 
                      wsprintf( szBuf, TEXT("%07.7u"), pCurrent->nLine ), 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += 7 * _xSpace;

        SetRect( &rect,
                 wx,
                 wy,
                 wx + _xSpace,
                 wy + _tm.tmHeight );

        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            SetBkColor( pps->hdc, crNormal );
            SetTextColor( pps->hdc, crText );

            DrawText( pps->hdc, 
                      " ",
                      1, 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += _xSpace;

//
// KB: This is what a typical cluster log line looks like.
// 000003fc.00000268::1999/07/19-19:14:45.548 [EVT] Node up: 2, new UpNodeSet: 0002
// 000003fc.00000268::1999/07/19-19:14:45.548 [EVT] EvOnline : calling ElfRegisterClusterSvc
// 000003fc.00000268::1999/07/19-19:14:45.548 [GUM] GumSendUpdate: queuing update	type 2 context 19
// 000003fc.00000268::1999/07/19-19:14:45.548 [GUM] GumSendUpdate: Dispatching seq 2585	type 2 context 19 to node 1
// 000003fc.00000268::1999/07/19-19:14:45.548 [NM] Received update to set extended state for node 1 to 0
// 000003fc.00000268::1999/07/19-19:14:45.548 [NM] Issuing event 0.
// 000003fc.00000268::1999/07/19-19:14:45.548 [GUM] GumSendUpdate: completed update seq 2585	type 2 context 19
// 0000037c.000003a0::1999/07/19-19:14:45.548 Physical Disk: AddVolume : \\?\Volume{99d8d508-39fa-11d3-a200-806d6172696f}\ 'C', 7 (11041600)
// 0000037c.000003a0::1999/07/19-19:14:45.558 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d503-39fa-11d3-a200-806d6172696f}), error 170
// 0000037c.000003a0::1999/07/19-19:14:45.568 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d504-39fa-11d3-a200-806d6172696f}), error 170
// 0000037c.000003a0::1999/07/19-19:14:45.568 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d505-39fa-11d3-a200-806d6172696f}), error 170
// 0000037c.000003a0::1999/07/19-19:14:45.578 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d506-39fa-11d3-a200-806d6172696f}), error 170
// 0000037c.000003a0::1999/07/19-19:14:45.578 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d501-39fa-11d3-a200-806d6172696f}), error 1
//

        pszStartResType = 
            pszStartComponent = NULL;
        pszStartLine =
            pszStartText = 
            pszStartTimeDate = 
            pszCurrent = pCurrent->psLine;

        // Find the thread and process IDs
        while ( *pszCurrent && *pszCurrent != ':' && *pszCurrent >= 32 )
        {
            pszCurrent++;
        }
        if ( *pszCurrent < 32 )
        {
            goto DrawRestOfLine;
        }

        pszCurrent++;
        if ( *pszCurrent != ':' )
        {
            goto DrawRestOfLine;
        }

        pszCurrent++;

        // Find Time/Date stamp which is:
        // ####/##/##-##:##:##.###<space>
        pszStartTimeDate = pszCurrent;

        while ( *pszCurrent && *pszCurrent != ' ' && *pszCurrent >= 32 )
        {
            pszCurrent++;
        }
        if ( *pszCurrent < 32 )
        {
            goto DrawRestOfLine;
        }

        pszCurrent++;

        if ( pCurrent->WarnLevel != WarnLevelUnknown )
        {
            // skip warn/info/err tag
            //
            while ( *pszCurrent != 32)
            {
                pszCurrent++;
            }
            while ( *pszCurrent == 32)
            {
                pszCurrent++;
            }
        }

        pszStartText = pszCurrent;

        // [OPTIONAL] Cluster component which looks like: 
        // [<id...>]
        if ( *pszCurrent == '[' )
        {
            while ( *pszCurrent && *pszCurrent != ']' && *pszCurrent >= 32 )
            {
                pszCurrent++;
            }
            if ( *pszCurrent < 32 )
            {
                goto NoComponentTryResouce;
            }

            pszCurrent++;

            pszStartComponent = pszStartText;
            pszStartText = pszCurrent;
        }
        else
        {
            // [OPTIONAL] If not a component, see if there is a res type
NoComponentTryResouce:
            pszCurrent = pszStartText;

            while ( *pszCurrent && *pszCurrent != ':' && *pszCurrent >= 32 )
            {
                pszCurrent++;
            }

            if ( *pszCurrent >= 32 )
            {
                pszCurrent++;

                pszStartResType = pszStartText;
                pszStartText = pszCurrent;
            }
        }

        // Draw PID and TID
        GetTextExtentPoint32( pps->hdc, 
                              pszStartLine, 
                              (int)(pszStartTimeDate - pszStartLine - 2), 
                              &size );

        SetRect( &rect,
                 wx,
                 wy,
                 wx + size.cx,
                 wy + _tm.tmHeight );

        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            SetBkColor( pps->hdc, crNormal );               
            SetTextColor( pps->hdc, crText );

            DrawText( pps->hdc, 
                      pszStartLine,
                      (int)(pszStartTimeDate - pszStartLine - 2), 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += size.cx;

        GetTextExtentPoint32( pps->hdc, 
                              "::", 
                              2, 
                              &size );

        SetRect( &rect,
                 wx,
                 wy,
                 wx + size.cx,
                 wy + _tm.tmHeight );

        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            SetBkColor( pps->hdc, crNormal );
            SetTextColor( pps->hdc, crText );

            DrawText( pps->hdc, 
                      "::",
                      2, 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += size.cx;

        // Draw Time/Date
        pszCurrent = ( pszStartComponent ? 
                       pszStartComponent :
                       ( pszStartResType ?
                         pszStartResType :
                         pszStartText )
                             ) - 1;
        GetTextExtentPoint32( pps->hdc, 
                              pszStartTimeDate, 
                              (int)(pszCurrent - pszStartTimeDate), 
                              &size );

        SetRect( &rect,
                 wx,
                 wy,
                 wx + size.cx,
                 wy + _tm.tmHeight );

        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            SetBkColor( pps->hdc, crDark );
            SetTextColor( pps->hdc, crText );

            DrawText( pps->hdc, 
                      pszStartTimeDate, 
                      (int)(pszCurrent - pszStartTimeDate), 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += size.cx;

        SetRect( &rect,
                 wx,
                 wy,
                 wx + _xSpace,
                 wy + _tm.tmHeight );

        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            SetBkColor( pps->hdc, crNormal );
            SetTextColor( pps->hdc, crText );

            DrawText( pps->hdc, 
                      " ",
                      1, 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += _xSpace;

#ifdef _DEBUG
        // draw sequence number
        SetRect( &rect,
                 wx,
                 wy,
                 wx + 7 * _xSpace,
                 wy + _tm.tmHeight );
        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            TCHAR szBuf[ 8 ];

            SetTextColor( pps->hdc, crText );
            SetBkColor( pps->hdc, crNormal );

            DrawText( pps->hdc, 
                      szBuf, 
                      wsprintf( szBuf, TEXT("#%7u%s"), 
                                pCurrent->uSequenceNumber,// / 2,
                                pCurrent->fSyncPoint ? "*" : " " ), 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx += 9 * _xSpace;
#endif

        // Draw component
        if ( pszStartComponent )
        {
            SetRect( &rect,
                     wx,
                     wy,
                     wx + 10 * _xSpace,
                     wy + _tm.tmHeight );

            if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
            {
                SetBkColor( pps->hdc, crNormal );
                SetTextColor( pps->hdc, crText );

                DrawText( pps->hdc, 
                          "          ",
                          10, 
                          &rect, 
                          DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
            }

            GetTextExtentPoint32( pps->hdc, 
                                  pszStartComponent, 
                                  (int)(pszStartText - pszStartComponent), 
                                  &size );

            SetRect( &rect,
                     wx,
                     wy,
                     wx + size.cx,
                     wy + _tm.tmHeight );

            if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
            {
                SetBkColor( pps->hdc, crNormal );
                SetTextColor( pps->hdc, crText );

                DrawText( pps->hdc, 
                          pszStartComponent, 
                          (int)(pszStartText - pszStartComponent), 
                          &rect, 
                          DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
            }

            wx += 10 * _xSpace;
        }

        if ( pszStartResType )
        {
            GetTextExtentPoint32( pps->hdc, 
                                  pszStartResType, 
                                  (int)(pszStartText - pszStartResType), 
                                  &size );

            SetRect( &rect,
                     wx,
                     wy,
                     wx + size.cx,
                     wy + _tm.tmHeight );

            if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
            {
                SetBkColor( pps->hdc, crNormal );
                SetTextColor( pps->hdc, crText );

                DrawText( pps->hdc, 
                          pszStartResType, 
                          (int)(pszStartText - pszStartResType), 
                          &rect, 
                          DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
            }

            wx += size.cx;
        }

DrawRestOfLine:
        pszCurrent = pszStartText;
        wxTextStart = wx;

        while ( *pszCurrent && *pszCurrent != 13 )
        {
            pszCurrent++;
        }

        SetRect( &rect,
                 wx,
                 wy,
                 _xWindow,
                 wy + _tm.tmHeight );

        if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
        {
            SetBkColor( pps->hdc, crNormal );
            SetTextColor( pps->hdc, crText );

            HBRUSH hBrush;
            hBrush = CreateSolidBrush( crNormal );
            FillRect( pps->hdc, &rect, hBrush );
            DeleteObject( hBrush );

            DrawText( pps->hdc, 
                      pszStartText, 
                      (int)(pszCurrent - pszStartText), 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_EXPANDTABS );
        }

        // See if "Finder" needs to paint on this line
        if ( pCurrent->nFile == _LineFinder.nFile
          && pCurrent->nLine == _LineFinder.nLine )
        {
            wx = wxTextStart;

            if ( pszStartResType )
            {
                GetTextExtentPoint32( pps->hdc, 
                                      pszStartResType, 
                                      (int)(_LineFinder.psLine - pszStartResType), 
                                      &size );
                wx += size.cx;
            }
            else
            {
                GetTextExtentPoint32( pps->hdc, 
                                      pszStartText, 
                                      (int)(_LineFinder.psLine - pszStartText), 
                                      &size );
                wx += size.cx;
            }

            GetTextExtentPoint32( pps->hdc, 
                                  _LineFinder.psLine, 
                                  _uFinderLength, 
                                  &size
                                  );

            SetRect( &rect,
                     wx,
                     wy,
                     wx + size.cx,
                     wy + _tm.tmHeight );

            if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
            {
                SetBkColor( pps->hdc, crHightlite );
                SetTextColor( pps->hdc, ~crHightlite );

                DrawText( pps->hdc, 
                          _LineFinder.psLine, 
                          _uFinderLength, 
                          &rect, 
                          DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
            }

        }

        wx = _xWindow;
    }

    // fill in the rest of the line
    SetRect( &rect,
             wx,
             wy,
             _xWindow,
             wy + _tm.tmHeight );

    if ( IntersectRect( &rectResult, &pps->rcPaint, &rect ) )
    {
        SetBkColor( pps->hdc, crNormal );
        SetTextColor( pps->hdc, crText );

        HBRUSH hBrush;
        hBrush = CreateSolidBrush( crNormal );
        FillRect( pps->hdc, &rect, hBrush );
        DeleteObject( hBrush );
    }

    return S_OK;
}

//
// _OnPaint( )
//
LRESULT
CApplicationWindow::_OnPaint(
    WPARAM wParam,
    LPARAM lParam )
{
    HDC     hdc;
    LONG    wxStart;
    LONG    wy;
    RECT    rect;
    RECT    rectResult;

    ULONG nLineCount;
    LINEPOINTER * pCurrent;

    SCROLLINFO  si;
    PAINTSTRUCT ps;

    static COLORREF crBkColor[ MAX_OPEN_FILES ] = {
        0xFFE0E0,
        0xE0FFE0,
        0xE0E0FF,
        0xFFFFE0,
        0xE0FFFF,
        0xFFE0FF,
        0xE0E0E0,
        0xC0C0C0,
        0x909090,
        0x000000 
    };

    static COLORREF crBkColorDarker[ MAX_OPEN_FILES ] = {
        0xFFC0C0,
        0xC0FFC0,
        0xC0C0FF,
        0xFFFFC0,
        0xC0FFFF,
        0xFFC0FF,
        0xC0C0C0,
        0xA0A0A0,
        0x707070,
        0x101010 
    };

    static COLORREF crBkColorHighlite[ MAX_OPEN_FILES ] = {
        0xFF0000,
        0x00FF00,
        0x0000FF,
        0xFFFF00,
        0x00FFFF,
        0xFF00FF,
        0x101010,
        0x404040,
        0x606060,
        0xFFFFFF 
    };
        
    si.cbSize = sizeof(si);
    si.fMask  = SIF_POS;
    GetScrollInfo( _hWnd, SB_HORZ, &si );

    wxStart = si.nPos;

    si.cbSize = sizeof(si);
    si.fMask  = SIF_POS | SIF_PAGE;
    GetScrollInfo( _hWnd, SB_VERT, &si );

    hdc = BeginPaint( _hWnd, &ps);

    if ( !_pLines )
        goto EndPaint;

    SetBkMode( hdc, OPAQUE );
    SelectObject( hdc, g_hFont );

    nLineCount = 0;
    pCurrent = _pLines;
    while ( pCurrent && nLineCount < (ULONG) si.nPos )
    {
        if ( !pCurrent->fFiltered )
        {
            nLineCount++;
        }
        pCurrent = pCurrent->pNext;
    }

    wy = 0;
    while ( pCurrent 
         && nLineCount <= si.nPos + si.nPage + 1 )
    {
        // ignore filtered lines
        if ( pCurrent->fFiltered )
        {
            pCurrent = pCurrent->pNext;
            continue;
        }

        if ( nLineCount >= _uStartSelection 
          && nLineCount <= _uEndSelection )
        {
            _PaintLine( &ps, 
                        pCurrent, 
                        -wxStart, 
                        wy, 
                        GetSysColor( COLOR_WINDOWTEXT ), 
                        crBkColorHighlite[ pCurrent->nFile ],
                        crBkColorHighlite[ pCurrent->nFile ], 
                        crBkColorDarker[ pCurrent->nFile ]
                        );
        }
        else
        {
            _PaintLine( &ps, 
                        pCurrent, 
                        -wxStart, 
                        wy, 
                        GetSysColor( COLOR_WINDOWTEXT ), 
                        crBkColorDarker[ pCurrent->nFile ], 
                        crBkColor[ pCurrent->nFile ], 
                        crBkColorHighlite[ pCurrent->nFile ] 
                        );
        }

        wy += _tm.tmHeight;
        nLineCount++;
        pCurrent = pCurrent->pNext;
    }

    // Fill the rest with normal background color
    SetRect( &rect,
             0,
             wy,
             _xWindow,
             _yWindow );
    if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
    {
        HBRUSH hBrush;
        hBrush = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
        FillRect( hdc, &rect, hBrush );
        DeleteObject( hBrush );
    }
    
EndPaint:
    EndPaint(_hWnd, &ps);
    return 0;
}

//
// _FindNext( )
//
LRESULT
CApplicationWindow::_FindNext( 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    SCROLLINFO si;
    LPTSTR     pszSearch;
    LPTSTR     psz;
    ULONG      n; // general counter

    LPTSTR pszSearchString = (LPTSTR) lParam;   // NEEDS TO BE FREEd!!!
    WPARAM wFlags          = wParam;

    CWaitCursor Wait;

    _uFinderLength = lstrlen( pszSearchString );

    if( wFlags & FIND_UP )
    {
        //
        // TODO: Make a better "up" search
        //
        if ( _LineFinder.pPrev )
        {
            CopyMemory( &_LineFinder, _LineFinder.pPrev, sizeof(LINEPOINTER) );
        }
        else
        {
            LINEPOINTER * lpLast;
            LINEPOINTER * lp = _pLines;
            while( lp )
            {
                lpLast = lp;
                lp = lp->pNext;
            }

            CopyMemory( &_LineFinder, lpLast, sizeof(LINEPOINTER) );
        }
    }
    else // find down
    {
        if ( _LineFinder.psLine )
        {
            // see if there is another instance on the same line
            psz = _LineFinder.psLine;
            for( n = 0; n < _uFinderLength; n++ )
            {
                if ( !*psz || *psz == 10 )
                    break;

                psz++;
            }

            if ( *psz && *psz != 10 )
                goto ResumeSearch;        
        }
    }

    if ( _LineFinder.psLine == NULL )
    {
        CopyMemory( &_LineFinder, _pLines->pNext, sizeof(LINEPOINTER) );
    }

    for(;;)
    {
        psz = _LineFinder.psLine;
        if ( !psz )
            break;

        // skip PID/TID and time/date
        while ( *psz && *psz != 10 )
        {
            if ( *psz == ':' )
            {
                psz++;
                if ( *psz == ':' )
                {
                    break;
                }
            }
            psz++;
        }

        while ( *psz && *psz != 10 )
        {
            if ( *psz == 32 )
            {
                psz++;
                break;
            }
            psz++;
        }

        if ( _LineFinder.WarnLevel != WarnLevelUnknown )
        {
            // skip info/warn/err tag
            while ( *psz != 32)
            {
                psz++;
            }
            while ( *psz == 32)
            {
                psz++;
            }
        }

        // skip components
        if ( *psz == '[' )
        {
            while ( *psz && *psz != ']' )
            {
                psz++;
            }
        }

        if ( *psz == 10 )
            goto NextLine;

        if ( !*psz )
            break;

ResumeSearch:
        pszSearch = pszSearchString;
        while ( *psz != 10 )
        {
            if ( ( wFlags & FIND_MATCHCASE ) 
              &&  *psz != *pszSearch ) 
            {
                goto ResetMatch;
            }
                
            if ( toupper( *psz ) == toupper( *pszSearch ) )
            {
                pszSearch++;
                if ( !*pszSearch )
                {
                    ULONG cLine;
                    LINEPOINTER * lp;

                    if ( wFlags & FIND_WHOLE_WORD 
                        && isalnum( psz[ 1 ] ) )
                    {
                        psz++; // need to bump
                        goto ResetMatch;
                    }

                    _LineFinder.psLine = psz - _uFinderLength + 1;

                    // find the line
                    lp = _pLines;
                    cLine  = 0;
                    while( lp )
                    {
                        if ( lp->nFile == _LineFinder.nFile 
                          && lp->nLine == _LineFinder.nLine )
                        {
                            break;
                        }

                        if ( !lp->fFiltered )
                        {
                            cLine++;
                        }

                        lp = lp->pNext;
                    }

                    _uPointer = _uStartSelection = _uEndSelection = cLine;

                    si.cbSize = sizeof(si);
                    si.fMask  = SIF_PAGE;
                    GetScrollInfo( _hWnd, SB_VERT, &si );

                    si.fMask = SIF_POS;
                    si.nPos = cLine - si.nPage / 2;
                    SetScrollInfo( _hWnd, SB_VERT, &si, TRUE );

                    InvalidateRect( _hWnd, NULL, FALSE );

                    LocalFree( pszSearchString );
                    return 1;
                }
            }
            else
            {
ResetMatch:
                psz -= ( pszSearch - pszSearchString );
                pszSearch = pszSearchString;
            }

            if ( !*psz )
                break;

            psz++;
        }

NextLine:
        if ( wFlags & FIND_UP )
        {
            if ( _LineFinder.pPrev != NULL )
            {
                CopyMemory( &_LineFinder, _LineFinder.pPrev, sizeof(LINEPOINTER) );
            }
            else
            {
                break; // end of search
            }
        }
        else // find down
        {
            if ( _LineFinder.pNext != NULL )
            {
                CopyMemory( &_LineFinder, _LineFinder.pNext, sizeof(LINEPOINTER) );
            }
            else
            {
                break; // end of search
            }
        }
    }

    // not found
    ZeroMemory( &_LineFinder, sizeof(LINEPOINTER) );
    if ( wFlags & FIND_UP )
    {
        _LineFinder.nLine = 0;
    }
    else
    {
        _LineFinder.nLine = _cTotalLineCount;
    }
    LocalFree( pszSearchString );
    return 0;
}

//
// _MarkAll( )
//
LRESULT
CApplicationWindow::_MarkAll( 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    WPARAM wFlags = wParam;
    LPTSTR pszSearchString = (LPTSTR) lParam;
    LocalFree( pszSearchString );
    return 0;
}

//
// _OnSize( )
//
LRESULT
CApplicationWindow::_OnSize( 
    LPARAM lParam )
{
    HDC     hdc;
    SIZE    size;
    HGDIOBJ hObj;
    TCHAR   szSpace[ 1 ] = { TEXT(' ') };

    SCROLLINFO si;

    _xWindow = LOWORD( lParam );
    _yWindow = HIWORD( lParam );
    
    hdc   = GetDC( _hWnd );
    hObj  = SelectObject( hdc, g_hFont );
    GetTextMetrics( hdc, &_tm );

    GetTextExtentPoint32( hdc, szSpace, 1, &size );
    _xSpace = size.cx;

    si.cbSize = sizeof(si);
    si.fMask  = SIF_RANGE | SIF_PAGE;
    si.nMin   = 0;
    si.nMax   = _cTotalLineCount;
    si.nPage  = _yWindow / _tm.tmHeight;

    SetScrollInfo( _hWnd, SB_VERT, &si, FALSE );

    si.fMask  = SIF_RANGE | SIF_PAGE;
    si.nMin   = 0;
    si.nMax   = 1000;
    si.nPage  = _xWindow / _tm.tmHeight;
    SetScrollInfo( _hWnd, SB_HORZ, &si, FALSE );

    // cleanup the HDC
    SelectObject( hdc, hObj );
    ReleaseDC( _hWnd, hdc );

    return 0;
}

//
// _OnMouseWheel( )
//
LRESULT
CApplicationWindow::_OnMouseWheel( SHORT iDelta )
{
    if ( iDelta > 0 )
    {
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEUP, 0 );
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEUP, 0 );
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEUP, 0 );
    }
    else if ( iDelta < 0 )
    {
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEDOWN, 0 );
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEDOWN, 0 );
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEDOWN, 0 );
    }
    return 0;
}

//
// _OnVerticalScroll( )
//
LRESULT
CApplicationWindow::_OnVerticalScroll(
    WPARAM wParam,
    LPARAM lParam )
{
    SCROLLINFO si;
    RECT rect;

    INT  nScrollCode   = LOWORD(wParam); // scroll bar value 
    INT  nPos;
    //INT  nPos          = HIWORD(wParam); // scroll box position 
    //HWND hwndScrollBar = (HWND) lParam;  // handle to scroll bar

    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    GetScrollInfo( _hWnd, SB_VERT, &si );

    nPos = si.nPos;


    switch( nScrollCode )
    {
    case SB_BOTTOM:
        si.nPos = si.nMax;
        break;

    case SB_THUMBPOSITION:
        si.nPos = nPos;
        break;

    case SB_THUMBTRACK:
        si.nPos = si.nTrackPos;
        break;

    case SB_TOP:
        si.nPos = si.nMin;
        break;

    case SB_LINEDOWN:
        si.nPos += 1;
        break;

    case SB_LINEUP:
        si.nPos -= 1;
        break;

    case SB_PAGEDOWN:
        si.nPos += si.nPage;
        InvalidateRect( _hWnd, NULL, FALSE );
        break;

    case SB_PAGEUP:
        si.nPos -= si.nPage;
        InvalidateRect( _hWnd, NULL, FALSE );
        break;
    }

    si.fMask = SIF_POS;
    SetScrollInfo( _hWnd, SB_VERT, &si, TRUE );
    GetScrollInfo( _hWnd, SB_VERT, &si );

    if ( si.nPos != nPos )
    {
        ScrollWindowEx( _hWnd, 
                        0, 
                        (nPos - si.nPos) * _tm.tmHeight, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL, 
                        SW_INVALIDATE );

        SetRect( &rect, 0, ( _uPointer - si.nPos - 1 ) * _tm.tmHeight, _xWindow, ( _uPointer - si.nPos + 2 ) * _tm.tmHeight );
        InvalidateRect( _hWnd, &rect, FALSE );
    }

    return 0;
}
//
// _OnHorizontalScroll( )
//
LRESULT
CApplicationWindow::_OnHorizontalScroll(
    WPARAM wParam,
    LPARAM lParam )
{
    SCROLLINFO si;

    INT  nScrollCode   = LOWORD(wParam); // scroll bar value 
    INT  nPos;
    //INT  nPos          = HIWORD(wParam); // scroll box position 
    //HWND hwndScrollBar = (HWND) lParam;  // handle to scroll bar

    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    GetScrollInfo( _hWnd, SB_HORZ, &si );

    nPos = si.nPos;

    switch( nScrollCode )
    {
    case SB_BOTTOM:
        si.nPos = si.nMax;
        break;

    case SB_THUMBPOSITION:
        si.nPos = nPos;
        break;

    case SB_THUMBTRACK:
        si.nPos = si.nTrackPos;
        break;

    case SB_TOP:
        si.nPos = si.nMin;
        break;

    case SB_LINEDOWN:
        si.nPos += 1;
        break;

    case SB_LINEUP:
        si.nPos -= 1;
        break;

    case SB_PAGEDOWN:
        si.nPos += si.nPage;
        break;

    case SB_PAGEUP:
        si.nPos -= si.nPage;
        break;
    }

    si.fMask = SIF_POS;
    SetScrollInfo( _hWnd, SB_HORZ, &si, TRUE );
    GetScrollInfo( _hWnd, SB_HORZ, &si );

    if ( si.nPos != nPos )
    {
        ScrollWindowEx( _hWnd, 
                        (nPos - si.nPos),
                        0, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL, 
                        SW_INVALIDATE );
    }

    return 0;
}

//
// _FillClipboard( )
//
HRESULT
CApplicationWindow::_FillClipboard( )
{
    HANDLE hClip;
    LPTSTR pszClip;
    LPTSTR psz;
    ULONG  dwSize;
    ULONG  nLine;
    TCHAR  szFilename[ 40 ];
    LONG   cchFilename;
    LINEPOINTER * pCurLine;
    LINEPOINTER * pSelectionStart;

    LONG   cchMargin   = ( _xMargin / _xSpace ) + 2;

                             //0 cluster1.log 0000006 5c4.57c::1999/07/26-21:56:24.682 [EP] Initialization...                               
    static TCHAR szHeader[] = "  Log/Nodename";
    static TCHAR szHeader2[] = "Line### PIDxxxxx.TIDxxxxx  Year/MM/DD-HH-MM-SS.HsS Log Entry\n\n";

    if ( cchMargin < sizeof(szHeader) + 8 )
    {
        cchMargin = sizeof(szHeader) + 8;
    }

    //
    // Find the start of the line
    //
    pSelectionStart = _pLines;
    for( nLine = 0; nLine < _uStartSelection; nLine++ )
    {
        pSelectionStart = pSelectionStart->pNext;
    }

    //
    // Tally up the line sizes
    //
    dwSize   = cchMargin - 8;
    dwSize  += sizeof(szHeader2) - 1;
    pCurLine = pSelectionStart;
    for( ; nLine <= _uEndSelection; nLine++ )
    {
        psz = pCurLine->psLine;
        if ( psz == NULL )
            break;

        while( *psz && *psz != 10 )
        {
            psz++;
        }
        if ( *psz )
        {
            psz++; // inlude LF
        }

        dwSize += (ULONG)(psz - pCurLine->psLine);
        pCurLine = pCurLine->pNext;
    }

    // Add file and line number for every line
    dwSize += ( _uEndSelection - _uStartSelection + 1 ) * cchMargin;

    dwSize++; // add one for NULL terminator

    hClip = (LPTSTR) GlobalAlloc( LMEM_MOVEABLE | GMEM_DDESHARE, dwSize * sizeof(*pszClip) );
    if ( !hClip )
        return E_OUTOFMEMORY;

    pszClip = (LPTSTR) GlobalLock( hClip );

    for ( LONG n = 0; n < cchMargin; n++ )
    {
        pszClip[ n ] = 32;
    }
    CopyMemory( pszClip, szHeader, sizeof(szHeader) - 1 );
    pszClip += cchMargin - 8;
    CopyMemory( pszClip, szHeader2, sizeof(szHeader2) - 1 );
    pszClip += sizeof(szHeader2) - 1;

    pCurLine = pSelectionStart;
    for( nLine = _uStartSelection; nLine <= _uEndSelection; nLine++ )
    {
        for ( LONG n = 0; n < cchMargin; n++ )
        {
            pszClip[ n ] = 32;
        }

        // file number
        _snprintf( pszClip, 1, "%1u", pCurLine->nFile );
        pszClip += 2;
        
        // filename
        cchFilename = cchMargin - 10;
        _GetFilename( _pszFilenames[ pCurLine->nFile ], szFilename, &cchFilename );
        _snprintf( pszClip, cchFilename, "%s", szFilename );
        pszClip += cchMargin - 10;

        // line number
        _snprintf( pszClip, 7, "%07.7u", pCurLine->nLine );
        pszClip += 7;

        pszClip++;
        
        psz = pCurLine->psLine;
        if ( psz == NULL )
            break;
        while( *psz && *psz != 10 )
        {
            psz++;
        }
        if ( *psz )
        {
            psz++; // inlude LF
        }

        CopyMemory( pszClip, pCurLine->psLine, psz - pCurLine->psLine );
        pszClip += psz - pCurLine->psLine;

        pCurLine = pCurLine->pNext;
    }
    
    *pszClip = 0; // terminate

    GlobalUnlock( hClip );

    if ( OpenClipboard( _hWnd ) )
    {
        SetClipboardData( CF_TEXT, hClip );
        CloseClipboard( );
    }

    return S_OK;
}


//
// _ApplyFilters( )
//
HRESULT
CApplicationWindow::_ApplyFilters( )
{
    SCROLLINFO si;

    ULONG         nLineCount = 0;
    LINEPOINTER * lp         = _pLines;

    while( lp )
    {
        lp->fFiltered = FALSE;

        if ( lp->nFilterId == g_nComponentFilters + 1 )
        {
            if ( g_fResourceNoise )
            {
                lp->fFiltered = TRUE;
            }
        }
        else if ( lp->nFilterId !=0 
               && lp->nFilterId <= g_nComponentFilters )
        {
            if ( g_pfSelectedComponent[ lp->nFilterId - 1 ] )
            {
                lp->fFiltered = TRUE;
            }
        }

        if ( ! lp->fFiltered )
        {
            nLineCount++;
        }

        lp = lp->pNext;
    }

    InvalidateRect( _hWnd, NULL, FALSE );

    // Update scroll bar
    si.cbSize = sizeof(si);
    si.fMask = SIF_RANGE;
    GetScrollInfo( _hWnd, SB_VERT, &si );
    si.nMax = nLineCount;
    SetScrollInfo( _hWnd, SB_VERT, &si, TRUE );

    return S_OK;
}

//
// _OnCommand( )
//
LRESULT
CApplicationWindow::_OnCommand(
    WPARAM wParam,
    LPARAM lParam )
{
	INT wmId    = LOWORD(wParam); 
	INT wmEvent = HIWORD(wParam); 
	// Parse the menu selections:
	switch (wmId)
	{
		case IDM_ABOUT:
		   DialogBox( g_hInstance, (LPCTSTR)IDD_ABOUTBOX, _hWnd, (DLGPROC)About);
		   break;

		case IDM_EXIT:
            {		   
                DestroyWindow( _hWnd );
            }
            break;

        case IDM_FILE_REFRESH:
            {
                ULONG n;
                ULONG nFiles = _nFiles;
                LPTSTR pszFilenames[ MAX_OPEN_FILES ];

                for( n = 0; n < nFiles; n++ )
                {
                    pszFilenames[ n ] = _pszFilenames[ n ];
                    _pszFilenames[ n ] = NULL;
                }

                Cleanup( );

                for( n = 0; n < nFiles; n++ )
                {
                    _LoadFile( pszFilenames[ n ] );
                    LocalFree( pszFilenames[ n ] );
                }
            }
            break;

        case IDM_NEW_FILE:
            {
                Cleanup( );
                InvalidateRect( _hWnd, NULL, TRUE );
            }
            break;

        case IDM_OPEN_FILE:
            {
                LPTSTR psz;
                TCHAR  szFilters[ MAX_PATH ];
                TCHAR  szFilename[ MAX_PATH ];
                LPTSTR pszFilenameBuffer
                    = (LPTSTR) LocalAlloc( LPTR, 8 * MAX_PATH );

                ZeroMemory( szFilters, sizeof(szFilters) );
                ZeroMemory( _szOpenFileNameFilter, sizeof(_szOpenFileNameFilter) );
                LoadString( g_hInstance, IDS_OPEN_FILE_FILTERS, szFilters, MAX_PATH );
                for ( psz = szFilters; *psz; psz++ )
                {
                    if ( *psz == TEXT(',') )
                    {
                        *psz = TEXT('\0');
                    }
                }

                OPENFILENAME ofn;
                ZeroMemory( &ofn, sizeof(ofn) );
                ofn.lStructSize       = sizeof(ofn);
                ofn.hwndOwner         = _hWnd;
                ofn.hInstance         = g_hInstance;
                ofn.lpstrFilter       = szFilters;
                // ofn.lpfnHook         = NULL;
                ofn.Flags             = OFN_ENABLESIZING 
                                      | OFN_FILEMUSTEXIST 
                                      | OFN_EXPLORER
                                      | OFN_ALLOWMULTISELECT;
                // ofn.lCustData         = 0;
                ofn.lpstrCustomFilter = _szOpenFileNameFilter;
                // ofn.lpstrDefExt       = NULL;
                ofn.lpstrFile         = pszFilenameBuffer;
                // ofn.lpstrFileTitle    = NULL;
                // ofn.lpstrInitialDir   = NULL;
                // ofn.lpstrTitle        = NULL;
                // ofn.lpTemplateName    = NULL;
                // ofn.nFileExtension    = 0;
                // ofn.nFileOffset       = 0;
                // ofn.nFilterIndex      = 1;
                ofn.nMaxCustFilter    = MAX_PATH;
                ofn.nMaxFile          = 8 * MAX_PATH;
                // ofn.nMaxFileTitle     = 0;
            
                if ( GetOpenFileName( &ofn ) )
                {
                    LPTSTR pszFilename = pszFilenameBuffer + ofn.nFileOffset;
                    strcpy( szFilename, pszFilenameBuffer );
                    szFilename[ ofn.nFileOffset - 1] = '\\';
                    while ( *pszFilename )
                    {
                        strcpy( &szFilename[ ofn.nFileOffset ], pszFilename );
                        _LoadFile( szFilename );
                        pszFilename += lstrlen( pszFilename ) + 1;
                    }
                }
				else
				{
					DWORD dwErr = GetLastError( );
				}

                LocalFree( pszFilenameBuffer );
            }
            break;

        case IDM_ALL_ON:
            {
                ULONG nItems = GetMenuItemCount( _hMenu );
                for( ULONG n = 0; n < nItems; n++ )
                {
                    MENUITEMINFO mii;
                    ZeroMemory( &mii, sizeof(mii) );
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_STATE;
                    mii.fState = MFS_CHECKED;
                    SetMenuItemInfo( _hMenu, n, TRUE, &mii );
                    g_pfSelectedComponent[ n ] = FALSE;
                }

                LINEPOINTER * lp = _pLines;
                while( lp )
                {
                    lp->fFiltered = FALSE;
                    lp = lp->pNext;
                }

                _ApplyFilters( );
            }
            break;

        case IDM_EDIT_COPY:
            {
                _FillClipboard( );
            }
            break;

        case IDM_FILTER_SHOWSERVERNAME:
            {
                HMENU hMenu = GetSubMenu( GetMenu( _hWnd ), 2 );
                MENUITEMINFO mii;
                ZeroMemory( &mii, sizeof(mii) );
                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_STATE;
                GetMenuItemInfo( hMenu, IDM_FILTER_SHOWSERVERNAME, FALSE, &mii );
                g_fShowServerNames = ( ( mii.fState & MFS_CHECKED ) == MFS_CHECKED );
                mii.fState = g_fShowServerNames ? 0 : MFS_CHECKED;
                SetMenuItemInfo( hMenu, IDM_FILTER_SHOWSERVERNAME, FALSE, &mii );
            }
            break;

        case IDM_FILTER_RESOURCENOISE:
            {
                HMENU hMenu = GetSubMenu( GetMenu( _hWnd ), 2 );
                MENUITEMINFO mii;
                ZeroMemory( &mii, sizeof(mii) );
                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_STATE;
                GetMenuItemInfo( hMenu, IDM_FILTER_RESOURCENOISE, FALSE, &mii );
                g_fResourceNoise = ( ( mii.fState & MFS_CHECKED ) == MFS_CHECKED );
                mii.fState = g_fResourceNoise ? 0 : MFS_CHECKED;
                SetMenuItemInfo( hMenu, IDM_FILTER_RESOURCENOISE, FALSE, &mii );
                _ApplyFilters( );
            }
            break;

        case IDM_EDIT_FIND:
            if ( !g_hwndFind )
            {
                new CFindDialog( _hWnd );
            }
            else
            {
                ShowWindow( g_hwndFind, SW_SHOW );
            }
            break;

        case IDM_ALL_OFF:
            {
                ULONG nItems = GetMenuItemCount( _hMenu );
                for( ULONG n = 0; n < nItems; n++ )
                {
                    MENUITEMINFO mii;
                    ZeroMemory( &mii, sizeof(mii) );
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_STATE;
                    mii.fState = 0;
                    SetMenuItemInfo( _hMenu, n, TRUE, &mii );
                    g_pfSelectedComponent[ n ] = TRUE;
                }
                _ApplyFilters( );
            }
            break;

    	default:
            if ( wmId >= IDM_FIRST_CS_FILTER && wmId <= IDM_LAST_CS_FILTER )
            {
                MENUITEMINFO mii;
                ZeroMemory( &mii, sizeof(mii) );
                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_STATE;
                GetMenuItemInfo( _hMenu, wmId, FALSE, &mii );
                g_pfSelectedComponent[ wmId - IDM_FIRST_CS_FILTER - 1 ] = ( ( mii.fState & MFS_CHECKED ) == MFS_CHECKED );
                mii.fState = g_pfSelectedComponent[ wmId - IDM_FIRST_CS_FILTER - 1 ] ? 0 : MFS_CHECKED;
                SetMenuItemInfo( _hMenu, wmId, FALSE, &mii );
                _ApplyFilters( );
            }
            break;
	}

    return 0;
}

//
// _OnDestroyWindow( )
//
LRESULT
CApplicationWindow::_OnDestroyWindow( )
{
    g_fCApplicationWindowDestroyed = TRUE;
	PostQuitMessage(0);
    delete this;
    return 0;
}

//
// _OnCreate( )
//
LRESULT
CApplicationWindow::_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT pcs )
{
    _hWnd = hwnd;

    SetWindowLongPtr( _hWnd, GWLP_USERDATA, (LONG_PTR)this );

    return 0;
}

//
// _OnKeyDown( )
//
// Returns FALSE is the default window proc should also
// take a crack at it.
//
// Returns TRUE to stop processing the message.
//
BOOL
CApplicationWindow::_OnKeyDown( WPARAM wParam, LPARAM lParam )
{
    RECT rect;
    SCROLLINFO si;
    ULONG uOldPointer = _uPointer;
    BOOL lResult = FALSE;

    si.cbSize = sizeof(si);
    si.fMask = SIF_POS | SIF_PAGE;
    GetScrollInfo( _hWnd, SB_VERT, &si );

    SetRect( &rect, 0, ( _uPointer - si.nPos ) * _tm.tmHeight, _xWindow, ( _uPointer - si.nPos + 1 ) * _tm.tmHeight );

    if ( wParam == VK_PRIOR 
      || wParam == VK_UP 
      || wParam == VK_HOME
      || wParam == VK_END 
      || wParam == VK_NEXT 
      || wParam == VK_DOWN )
    {
        if ( _fSelection )
        {
            if ( GetKeyState( VK_SHIFT ) >= 0 )
            {
                _fSelection = FALSE;
                InvalidateRect( _hWnd, NULL, FALSE );
            }
        }
        else
        {
            if ( GetKeyState( VK_SHIFT ) < 0 )
            {
                _fSelection = TRUE;
                InvalidateRect( _hWnd, NULL, FALSE );
            }
        }
    }

    switch ( wParam )
    {
    case VK_PRIOR:
        _uPointer -= si.nPage - 1;
    case VK_UP:
        _uPointer--;
        if ( _uPointer >= _cTotalLineCount )
        {
            _uPointer = _cTotalLineCount - 1;
        }
        if ( GetKeyState( VK_SHIFT ) < 0 )
        {
            if ( uOldPointer == _uStartSelection )
            {
                _uStartSelection = _uPointer;
            }
            else
            {
                _uEndSelection = _uPointer;
            }
            InvalidateRect( _hWnd, NULL, FALSE );
        }
        else
        {
            _uStartSelection = _uEndSelection = _uPointer;
            if ( _uPointer < (ULONG) si.nPos )
            {
                if ( wParam == VK_UP )
                {
                    SendMessage( _hWnd, WM_VSCROLL, SB_LINEUP, 0 );
                    GetScrollInfo( _hWnd, SB_VERT, &si );
                }
            }
            else
            {
                rect.top -= _tm.tmHeight;
                InvalidateRect( _hWnd, &rect, FALSE );
            }
        }
        if ( wParam == VK_PRIOR )
        {
             SendMessage( _hWnd, WM_VSCROLL, SB_PAGEUP, 0 );
        }
        else if ( _uPointer < (ULONG) si.nPos )
        {
            si.fMask = SIF_POS;
            si.nPos = _uPointer;
            SetScrollInfo( _hWnd, SB_VERT, &si, TRUE );
            InvalidateRect( _hWnd, NULL, FALSE );
        }
        lResult = TRUE;
        break;

    case VK_NEXT:
        _uPointer += si.nPage - 1;
    case VK_DOWN:
        _uPointer++;
        if ( _uPointer >= _cTotalLineCount )
        {
            _uPointer = _cTotalLineCount - 1;
        }
        if ( GetKeyState( VK_SHIFT ) < 0 )
        {
            if ( uOldPointer == _uEndSelection )
            {
                _uEndSelection = _uPointer;
            }
            else
            {
                _uStartSelection = _uPointer;
            }
            InvalidateRect( _hWnd, NULL, FALSE );
        }
        else
        {
            _uStartSelection = _uEndSelection = _uPointer;
            if ( _uPointer > si.nPos + si.nPage )
            {
                if ( wParam == VK_DOWN )
                {
                    SendMessage( _hWnd, WM_VSCROLL, SB_LINEDOWN, 0 );
                    GetScrollInfo( _hWnd, SB_VERT, &si );
                }
            }
            else
            {
                rect.bottom += _tm.tmHeight;
                InvalidateRect( _hWnd, &rect, FALSE );
            }
        }
        if ( wParam == VK_NEXT )
        {
            SendMessage( _hWnd, WM_VSCROLL, SB_PAGEDOWN, 0 );
        }
        else if ( _uPointer > si.nPos + si.nPage )
        {
            si.fMask = SIF_POS;
            si.nPos = _uPointer;
            SetScrollInfo( _hWnd, SB_VERT, &si, TRUE );
            InvalidateRect( _hWnd, NULL, FALSE );
        }
        lResult = TRUE;
        break;

    case VK_HOME:
        _LineFinder.nLine = 0;
        _LineFinder.psLine = NULL;
        _uPointer = 0;
        if ( GetKeyState( VK_SHIFT ) < 0 )
        {
            if ( uOldPointer == _uEndSelection )
            {
                _uEndSelection = _uStartSelection;
            }
            _uStartSelection = 0;
        }
        else
        {
            _uEndSelection = _uStartSelection = _uPointer;
        }
        if ( uOldPointer < si.nPage )
        {
            InvalidateRect( _hWnd, &rect, FALSE );
            SetRect( &rect, 0, ( _uPointer - si.nPos ) * _tm.tmHeight, _xWindow, ( _uPointer - si.nPos + 1 ) * _tm.tmHeight );
            InvalidateRect( _hWnd, &rect, FALSE );
        }
        else
        {
            SendMessage( _hWnd, WM_VSCROLL, SB_TOP, 0 );
        }
        lResult = TRUE;
        break;

    case VK_END:
        _LineFinder.nLine = _cTotalLineCount;
        _LineFinder.psLine = NULL;
        _uPointer = _cTotalLineCount - 1;
        if ( GetKeyState( VK_SHIFT ) < 0 )
        {
            if ( uOldPointer == _uStartSelection )
            {
                _uStartSelection = _uEndSelection;
            }
            _uEndSelection = 0;
        }
        else
        {
            _uEndSelection = _uStartSelection = _uPointer;
        }
        if ( uOldPointer > _cTotalLineCount - si.nPage )
        {
            InvalidateRect( _hWnd, &rect, FALSE );
            SetRect( &rect, 0, ( _uPointer - si.nPos ) * _tm.tmHeight, _xWindow, ( _uPointer - si.nPos + 1 ) * _tm.tmHeight );
            InvalidateRect( _hWnd, &rect, FALSE );
        }
        else
        {
            SendMessage( _hWnd, WM_VSCROLL, SB_BOTTOM, 0 );
        }
        lResult = TRUE;
        break;

    case VK_LEFT:
        SendMessage( _hWnd, WM_HSCROLL, SB_PAGEUP, 0 );
        break;

    case VK_RIGHT:
        SendMessage( _hWnd, WM_HSCROLL, SB_PAGEDOWN, 0 );
        break;

    case VK_F5: // refresh
        PostMessage( _hWnd, WM_COMMAND, IDM_FILE_REFRESH, 0 );
        break;

    case 'F':
        if ( GetKeyState( VK_CONTROL ) < 0 )
        {
            PostMessage( _hWnd, WM_COMMAND, IDM_EDIT_FIND, 0 );
        }
        break;

    case 'A':
        if ( GetKeyState( VK_CONTROL ) < 0 )
        {
            PostMessage( _hWnd, WM_COMMAND, IDM_OPEN_FILE, 0 );
        }
        break;

    case 'C':
        if ( GetKeyState( VK_CONTROL ) < 0 )
        {
            PostMessage( _hWnd, WM_COMMAND, IDM_EDIT_COPY, 0 );
        }
        break;
    }

    return lResult;
}

//
// _OnLeftButtonDown( )
//
LRESULT
CApplicationWindow::_OnLeftButtonDown( 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    SCROLLINFO si;

    DWORD fwKeys = (DWORD) wParam;
    DWORD      x = GET_X_LPARAM( lParam );
    DWORD      y = GET_Y_LPARAM( lParam );

    si.cbSize = sizeof(si);
    si.fMask  = SIF_POS;
    GetScrollInfo( _hWnd, SB_VERT, &si );

    _uPointer = si.nPos + y / _tm.tmHeight;
    InvalidateRect( _hWnd, NULL, FALSE );

    if ( fwKeys & MK_SHIFT )
    {
        if ( _uPointer < _uStartSelection )
        {
            _uStartSelection = _uPointer;
        }
        else if ( _uPointer > _uEndSelection )
        {
            _uEndSelection = _uPointer;
        }
    }
    else
    {
        _uStartSelection = _uEndSelection = _uPointer;
    }

    return FALSE;
}


//
// WndProc( )
//
LRESULT CALLBACK
CApplicationWindow::WndProc( 
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    CApplicationWindow * paw = (CApplicationWindow *) GetWindowLongPtr( hWnd, GWLP_USERDATA );

    if ( paw != NULL )
    {
        switch( uMsg )
        {
        case WM_COMMAND:
            return paw->_OnCommand( wParam, lParam );

	    case WM_PAINT:
            return paw->_OnPaint( wParam, lParam );

        case WM_DESTROY:
            SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR)NULL );
            return paw->_OnDestroyWindow( );

        case WM_SIZE:
            return paw->_OnSize( lParam );

        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
            if ( paw->_OnKeyDown( wParam, lParam ) )
                return 0;
            break; // do default as well

        case WM_VSCROLL:
            return paw->_OnVerticalScroll( wParam, lParam );

        case WM_HSCROLL:
            return paw->_OnHorizontalScroll( wParam, lParam );

        case WM_MOUSEWHEEL:
            return paw->_OnMouseWheel( HIWORD(wParam) );

        case WM_FIND_NEXT:
            return paw->_FindNext( wParam, lParam );

        case WM_MARK_ALL:
            return paw->_MarkAll( wParam, lParam );

        case WM_ERASEBKGND:
            goto EraseBackground;

        case WM_LBUTTONDOWN:
            return paw->_OnLeftButtonDown( wParam, lParam );
        }

        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    if ( uMsg == WM_CREATE )
    {
        LPCREATESTRUCT pcs = (LPCREATESTRUCT) lParam;
        paw = (CApplicationWindow *) pcs->lpCreateParams;
        return paw->_OnCreate( hWnd, pcs );
    }

    if ( uMsg == WM_ERASEBKGND )
    {
EraseBackground:
        RECT    rectWnd;
        HBRUSH  hBrush;
        HDC     hdc = (HDC) wParam;

        GetClientRect( hWnd, &rectWnd );
        
#if defined(DEBUG_PAINT)
        hBrush = CreateSolidBrush( 0xFF00FF );
#else
        hBrush = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
#endif
        FillRect( hdc, &rectWnd, hBrush );
        DeleteObject( hBrush );

        return TRUE;
    }

    return DefWindowProc( hWnd, uMsg, wParam, lParam );
}

// Mesage handler for about box.
LRESULT CALLBACK 
CApplicationWindow::About(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
			return TRUE;

	case WM_COMMAND:
		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
		{
			EndDialog(hDlg, LOWORD(wParam));
			return TRUE;
		}
		break;

	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\timeserv\timeini.c ===
//#include <string.h>
#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <stdio.h>
//#include <stdlib.h>
#include <lm.h>
#include <winsock.h>
#include "timemsg.h"
#include "tsconfig.h"             // takes in random config stuff

#include "exts.h"

//
//  Forward Procedure/Function Declarations
//

VOID
SuckIniFile();

DWORD
LookUpInt(LPTSTR key);

DWORD
LookUpValue(LPTSTR key, PMATCHTABLE match, LPTSTR xx, LPTSTR value);


VOID
TimeCreateService(DWORD starttype)
{
    SC_HANDLE schSCManager, schService;


    schSCManager = OpenSCManager(
             NULL,                   // local machine
             NULL,                   // ServicesActive database
             SC_MANAGER_ALL_ACCESS); // full access rights

    if (schSCManager == NULL)
        StopTimeService(MSG_SCM_FAILED);

    schService = CreateService(
           schSCManager,              // SCManager database
           TEXT("TimeServ"),        // name of service
           TEXT("Time Service"),                // display name
           SERVICE_ALL_ACCESS,        // desired access
           SERVICE_WIN32_OWN_PROCESS, // service type
           starttype,      // start type

           SERVICE_ERROR_NORMAL,      // error control type
           TEXT("%SystemRoot%\\system32\\timeserv.exe"),        // service's binary
           NULL,                      // no load ordering group
           NULL,                      // no tag identifier
           ((type==PRIMARY)||(type==SECONDARY)||(type==NTP))?TEXT("LanmanWorkstation\0"):NULL, // dependencies
       //note that the above is set when the service is created, not every -update (should it be?)
       //bugbug this means you can't swich from network to non-network on a non-network machine
           NULL,                      // LocalSystem account
           NULL);                     // no password

    if (schService == NULL)
    {
        StopTimeService(MSG_CS_FAILED);//is common reason forgetting to copy to %SystemRoot%\system?
    }
#ifdef VERBOSE
    else
    {
        if (fStatus)
        {
            printf("CreateService SUCCESS\n");
        }
    }
#endif


    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
}

VOID
TimeInit()
{
    HKEY hKey, hKey2;
    LPTSTR pwszType;
    DWORD dwTypeSize, dwLen;
    DWORD status;

    SuckIniFile();


 // Add your source name as a subkey under the Application
 // key in the EventLog service portion of the registry.

    if (RegCreateKey(HKEY_LOCAL_MACHINE,TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\TimeServ"),&hKey))
    {
        if (!fService)
            printf("An early failure occured, probably due to inadequate privileges\n");    
            StopTimeService(MSG_EVENT_KEY);
    }

// Add the Event ID message-file name to the subkey. 


    if (RegSetValueEx(hKey,             // subkey handle
                      TEXT("EventMessageFile"),       // value name 
                      0,                        // must be zero 
                      REG_EXPAND_SZ,            // value type 
                      (CONST BYTE *)TEXT("%SystemRoot%\\System32\\TimeServ.dll"),           // address of value data 
                      _tcslen(TEXT("%SystemRoot%\\System32\\TimeServ.dll"))*sizeof(TCHAR) + sizeof(TCHAR)))       // length of value data  
        StopTimeService(MSG_EVENT_MSG);

// Set the supported types flags. 

    dwLen = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
            EVENTLOG_INFORMATION_TYPE;//not really a length

    if (RegSetValueEx(hKey,      // subkey handle         
                      TEXT("TypesSupported"),  // value name                  
                      0,                 // must be zero                 
                      REG_DWORD,         // value type                   
                      (LPBYTE) &dwLen,  // address of value data        
                      sizeof(DWORD)))    // length of value data         
        StopTimeService(MSG_EVENT_TYPES);


    RegCloseKey(hKey);
//should the above eventlog stuff move down lower, under starttype (so it isn't repeated when run with -update)?

    status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,TEXT("SYSTEM\\CurrentControlSet\\Services\\TimeServ\\Parameters"),0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey,&dwLen);
    if ( status != ERROR_SUCCESS )
        StopTimeService(MSG_EVENT_TYPES);
    pwszType = FindTypeByType(type);
    dwTypeSize = (_tcslen(pwszType) * sizeof(_TCHAR)) + sizeof(_TCHAR);
    status = RegSetValueEx(hKey,TEXT("Type"),0,REG_SZ,(CONST BYTE *)pwszType, dwTypeSize);
    if ( status != ERROR_SUCCESS )
        StopTimeService(MSG_EVENT_TYPES);
    pwszType = FindTypeByType(type);
    status = RegSetValueEx(hKey,TEXT("TAsync"),0,REG_DWORD,(CONST BYTE *)&tasync,sizeof(DWORD));
    pwszType = FindTypeByType(type);
    status = RegSetValueEx(hKey,TEXT("Mode"),0,REG_DWORD,(CONST BYTE *)&mode,sizeof(DWORD));
    pwszType = FindTypeByType(type);
    status = RegSetValueEx(hKey,TEXT("Log"),0,REG_DWORD,(CONST BYTE *)&logging,sizeof(DWORD));
    pwszType = FindTypeByType(type);
    if(pwszType = FindPeriodByPeriod(period))
    {
        dwTypeSize = (_tcslen(pwszType) * sizeof(_TCHAR)) + sizeof(_TCHAR);
        status = RegSetValueEx(hKey,TEXT("Period"),0,REG_SZ,(CONST BYTE *)pwszType, dwTypeSize);
        if ( status != ERROR_SUCCESS )
            StopTimeService(MSG_EVENT_TYPES);
    }
    else
    {
        status = RegSetValueEx(hKey,TEXT("Period"),0,REG_DWORD,(CONST BYTE *)&period,sizeof(DWORD));
        if ( status != ERROR_SUCCESS )
            StopTimeService(MSG_EVENT_TYPES);
    }

    switch(type)
    {
    case PRIMARY:
    {
        int i;

        dwLen = 0;
        for(i = 0; i < arraycount; i++)
        {
            ULONG len = _tcslen(primarysourcearray[i]) + 1;

            memcpy(&primarysource[dwLen],
                    primarysourcearray[i],
                    len * sizeof(TCHAR));
            dwLen += len;
        }               // copy all string

// We have all of the primaries in the string with nulls between them. We need
// to add a NULL to the end and compute the total size in bytes

        if(!i)                  // if no strings ...
        {
            primarysource[0] = 0;
            dwLen = 1;
        }                       // have to special case no strings
        primarysource[dwLen++] = 0; // double NULL

// dwLen contains the count of wide characters, including the extra NULL
// character at the end.

        status = RegSetValueEx(hKey,TEXT("PrimarySource"),0,REG_MULTI_SZ,(CONST BYTE *)primarysource,dwLen * sizeof(TCHAR));
        if ( status != ERROR_SUCCESS )
            StopTimeService(MSG_EVENT_TYPES);
        break;
    }
    case SECONDARY:
    {
        dwLen = _tcslen(secondarydomain)*sizeof(TCHAR)+sizeof(TCHAR);
        status = RegSetValueEx(hKey,TEXT("SecondaryDomain"),0,REG_SZ,(CONST BYTE *)secondarydomain,dwLen);
        if ( status != ERROR_SUCCESS )
            StopTimeService(MSG_EVENT_TYPES);
        break;
    }

    RegCloseKey(hKey);

    if (!timesource)
        if((type!=SECONDARY)
               &&
           (mode==SERVICE))
    {//if not specified, but reasonably expected
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TEXT("SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters"),0,KEY_QUERY_VALUE|KEY_SET_VALUE,&hKey);
        if ( status != ERROR_SUCCESS ) {
            printf( "Failed to open LanmanServer Parameters key\n" );
            return;
        }
        dwLen = sizeof(DWORD);  
        status = RegQueryValueEx(hKey,TEXT("timesource"),NULL,NULL,(LPBYTE)&timesource,&dwLen);//get the setting
        if ( status != ERROR_SUCCESS || !timesource) {//still not set?
            LogTimeEvent(EVENTLOG_INFORMATION_TYPE,MSG_TIMESOURCE);
        }
        RegCloseKey(hKey);
    }
    else
    { //if specified (or picked up - for simplicity we just set it again)
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TEXT("SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters"),0,KEY_QUERY_VALUE|KEY_SET_VALUE,&hKey);
        if ( status != ERROR_SUCCESS ) {
            printf( "Failed to open LanmanServer Parameters key\n" );
            return;
        }
        status = RegSetValueEx(hKey,TEXT("timesource"),0,REG_DWORD,(CONST BYTE *)&mode,sizeof(DWORD));//mode is non-zero
        if ( status != ERROR_SUCCESS ) {
            printf( "Failed to set value for timesource mode\n" );
        }
        RegCloseKey(hKey);
    }
    //note: we don't ever reset timesource=no if someone runs -update, is that important?
    }    
}


VOID
SuckIniFile()
{
    DWORD dwLen;

    mode = LookUpValue(TEXT("Mode"), &modetype, DEFAULT(modetype), 0);
    logging = LookUpValue(TEXT("Log"), &yesno, DEFAULT(yesno), 0);
    type = LookUpValue(TEXT("Type"), &typetype, DEFAULT(typetype), 0);

    // Now get a real int from the file
    period = LookUpInt(TEXT("Period"));

    timesource = LookUpValue(TEXT("TimeSource"), &yesno, DEFAULT(yesno), 0);

    if (type==PRIMARY) {
        dwLen = sizeof(primarysource)+sizeof(TCHAR);
        LookUpValue(TEXT("PrimarySource"), 0, TEXT(""), primarysource);
        if (primarysource[0])
        {
            TCHAR * ptr = primarysource;
            arraycount=0;
            while(1)
            {
                primarysourcearray[arraycount++] = ptr;
                ptr = _tcschr(ptr, TEXT(';'));
                if(!ptr)
                {
                    break;
                }
                *ptr++ = TEXT('\0');
            }

        }
    }

    if (type==SECONDARY)
    {
        LookUpValue(TEXT("SecondaryDomain"), 0, TEXT(""), secondarydomain);
    }

}

DWORD
LookUpValue(    LPTSTR Key,
        PMATCHTABLE match,
        LPTSTR xx,
        LPTSTR value)
{
    TCHAR temp[255];
    TCHAR * defer = TEXT("");
    BOOL fMatch;
    TCHAR *ptr;
    DWORD retVal;

    if(!(ptr = value))
    {
        ptr = temp;
    }
    GetPrivateProfileString(SECTION, Key, xx, ptr, 255, PROFILE);
    if(match)
    {
        ULONG x;

        fMatch = FALSE;
        for(x = 0; x < match->cnt; x++)
        {
            if(!_tcsicmp(ptr, match->element[x].key))
            {
                retVal = match->element[x].value;
                fMatch = TRUE;
                break;
            }
        }
    }
    else
    {
        fMatch = TRUE;
    }
#ifdef VERBOSE
    if(fStatus)
    {
        if(!fMatch)
        {
            TCHAR * defer = TEXT("");
            
            ULONG x;

#ifdef UNICODE                  
            printf("%ls value of %ls did not match one of:\n",
#else
            printf("%s value of %s did not match one of:\n",
#endif
                Key, ptr);

            for(x = 0; x< match->cnt; x++)
            {
#ifdef UNICODE                          
                printf("                %ls\n",
#else
                printf("                %s\n",
#endif
                    match->element[x].key);
                if(!_tcsicmp(xx, match->element[x].key))
                {
                    retVal = match->element[x].value;
                    defer = match->element[x].key;
                }
            }
#ifdef UNICODE                  
            printf("        Using default value %ls\n", defer);
#else
            printf("        Using default value %s\n", defer);
#endif
        }
        else
        {
#ifdef UNICODE                  
            printf("%ls = %ls\n", Key, ptr);
#else
            printf("%s = %s\n", Key, ptr);
#endif
        }
    }
#endif //verbose - note from Doug "hopefully the above was really meant to be fStatus"
    return(retVal);
}

DWORD
LookUpInt(LPTSTR key)
{
        //Wrapper for GetPrivateProfileInt so we can do the
        // status stuff in one place
        // Default is always 0

    DWORD retVal;

    retVal = GetPrivateProfileInt(SECTION, key, 0, PROFILE);
#ifdef VERBOSE  
    if(fStatus)
    {
#ifdef UNICODE          
        printf("%ls = %d\n", key, retVal);
#else
        printf("%s = %d\n", key, retVal);
#endif
    }
#endif
    return(retVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\capplicationwindow.h ===
//
// CApplicationWindow.H
//
// Application Window Class
//
#ifndef _CAPPLICATIONWINDOW_H_
#define _CAPPLICATIONWINDOW_H_

#define MAX_OPEN_FILES 10
typedef enum _WARNLEVEL {
    WarnLevelUnknown,
    WarnLevelInfo,
    WarnLevelWarn,
    WarnLevelError
} WARNLEVEL;

// 
// Structures
//
typedef struct _LINEPOINTER {
    struct _LINEPOINTER *pNext;     // next line
    struct _LINEPOINTER *pPrev;     // previous line
    LPTSTR      psLine;             // pointer to beggining of line
    ULONG       uSequenceNumber;    // sequence number affliation
    FILETIME    Time;               // adjusted time
    ULONG       nFile;              // file that this line came from
    ULONG       nLine;              // orginal files line number
    ULONG       nFilterId;          // which filter can filter this line
    WARNLEVEL   WarnLevel;          // line warning level
    BOOL        fSyncPoint:1;       // this line being used to synchronize
    BOOL        fFiltered:1;        // TRUE if the line shouldn't be shown
} LINEPOINTER, * LPLINEPOINTER;

//
// CApplicationWindow
//
class
CApplicationWindow
{
private: // data
    HWND            _hWnd;      // our window handle
    HMENU           _hMenu;     // Filter menu handle

    TCHAR           _szOpenFileNameFilter[ MAX_PATH ];

    TEXTMETRIC      _tm;	    // text metrics of text font
	LONG	        _xSpace;	// size of a space
	LONG	        _xWindow;	// window max X
	LONG	        _yWindow;	// window max Y
    LONG            _xMargin;   // margin size
    BOOL	        _fVertSBVisible:1;	// is the vertical scroll bar visible?

    ULONG           _nFiles;    // number of files open
    LPTSTR          _pFiles[ MAX_OPEN_FILES ];
    LINEPOINTER *   _pNodes[ MAX_OPEN_FILES ];
    LPTSTR          _pszFilenames[ MAX_OPEN_FILES ];
    LINEPOINTER *   _pLines;
    ULONG           _cTotalLineCount;
    LINEPOINTER     _LineFinder;
    ULONG           _uFinderLength;

    ULONG           _uPointer;          // current line
    ULONG           _uStartSelection;   // used to highlite and copy text.
    ULONG           _uEndSelection;
    BOOL            _fSelection:1;      // if we are in selection mode

private: // methods
    ~CApplicationWindow( );
    HRESULT
        Cleanup( BOOL fInitializing = FALSE );
    LRESULT
        _OnVerticalScroll( WPARAM wParam, LPARAM lParam );
    LRESULT
        _OnHorizontalScroll( WPARAM wParam, LPARAM lParam );
    LRESULT 
        _OnCommand( WPARAM wParam, LPARAM lParam );
    HRESULT
        _PaintLine( PAINTSTRUCT * pps, LINEPOINTER *pCurrent, LONG wxStart, 
                    LONG wy, COLORREF crText, COLORREF crDark, 
                    COLORREF crNormal, COLORREF crHightlite );
    LRESULT
        _OnPaint( WPARAM wParam, LPARAM lParam );
    LRESULT
        _OnDestroyWindow( );
    LRESULT
        _OnCreate( );
    static LRESULT CALLBACK 
        About( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT
        _SaveAllFiles( );

    static BOOL CALLBACK 
        _EnumSaveAllFiles( HWND hWnd, LPARAM lParam );
    HRESULT
        _LoadFile( LPTSTR pszFilename );
    BOOL
        _FindSequencePoint( LPTSTR * ppszSequence, ULONG * pnSequence );
    HRESULT
        _CalculateOffset( FILETIME * pftOper1, FILETIME * pftOper2, 
                          INT * pnDir, FILETIME * pftOffset );
    HRESULT
        _RetrieveTimeDate( LPTSTR pszCurrent, SYSTEMTIME * pst, OUT LPTSTR * ppszFinal );
    BOOL
        _OnKeyDown( WPARAM wParam, LPARAM lParam );
    HRESULT
        _UpdateTitle( );
    LRESULT
        _OnCloseWindow( );
	LRESULT
		_OnCreate( HWND hwnd, LPCREATESTRUCT pcs );
	LRESULT
		_OnSize( LPARAM lParam );
	LRESULT
		_OnMouseWheel( SHORT iDelta );
    LRESULT
        _FindNext( WPARAM wParam, LPARAM lParam );
    LRESULT
        _MarkAll( WPARAM wParam, LPARAM lParam );
    HRESULT
        _FillClipboard( );
    HRESULT
        _GetFilename( LPTSTR pszFilename, LPTSTR pszFilenameOut, LONG * pcch );
    HRESULT
        _CombineFiles( );
    static LRESULT CALLBACK
        _StatusWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    HRESULT
        _ApplyFilters( );
    LRESULT
        _OnLeftButtonDown( WPARAM wParam, LPARAM lParam );

public:
    CApplicationWindow( );
    static LRESULT CALLBACK
        WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
};

typedef CApplicationWindow CAPPLICATIONWINDOW;
typedef CApplicationWindow * PCAPPLICATIONWINDOW, *LPCAPPLICATIONWINDOW;


#endif // _CAPPLICATIONWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\timeserv\timenet.c ===
//#include <string.h>
#include <windows.h>
#include <tchar.h>
//#include <stdio.h>
#include <stdlib.h>

#include <lm.h>

//
// Where we save the name of the machine used in the last successful
// secondary operation. Once we find a machine, we keep using it until
// it fails to respond.
//
TCHAR *  pwszLastServerName;

DWORD
GetDefaultServerName(TCHAR * Server,
                     TCHAR * Domain)
{
    LPSERVER_INFO_100 lpsi;
    NET_API_STATUS api;
    DWORD dwLen;
    DWORD dwLen2;


    if(pwszLastServerName)
    {
        _tcscpy(Server, pwszLastServerName);
    }
    else
    {

        api = NetServerEnum(NULL,
                            100,
                            (LPBYTE *)&lpsi,
                            MAX_PREFERRED_LENGTH,
                            &dwLen,
                            &dwLen2,
                            SV_TYPE_TIME_SOURCE,
                            Domain,
                            NULL);
        if(api || !dwLen)
        {
            return(ERROR_BAD_NET_NAME);
        }

        //
        // get a name at random
        //

        _tcscpy(Server, TEXT("\\\\"));
        _tcscat(Server, lpsi[rand() % dwLen].sv100_name);
        pwszLastServerName = LocalAlloc(LMEM_FIXED,
                                        (_tcslen(Server) + 1) * sizeof(TCHAR));
        if(pwszLastServerName)
        {
            _tcscpy(pwszLastServerName, Server);
        }
        NetApiBufferFree(lpsi);
    }
    return(NO_ERROR);
}

//
// Called when the saved machine name fails to respond. This will clear
// the saved name so that the next call to GetDefaultServerName selects
// another machine.
//
VOID
ClearDefaultServerName()
{
    if(pwszLastServerName)
    {
        LocalFree(pwszLastServerName);
        pwszLastServerName = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\timeserv\timeserv\timeserv.c ===
///////////////////////////////////////////////////////
//
//  Timeserv v1.21 by Douglas W. Hogarth  12/4/95
//              with contributions from Arnold Miller
//
//      The time service will respond to the basic
//      service controller functions, i.e. Start,
//      Stop, and Pause.
//


#define FD_SETSIZE 4 //we don't need the default 64 sockets of winsock

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>

//#define TimePrint DbgPrint
#define TimePrint printf

//
// LanMan prototypes and definitions
//

#include <lm.h>

#include <time.h>
//#include <stddef.h>       // ???
#include <math.h>
#include <mmsystem.h>
#include <winsock.h>
#if SVCDLL != 0
#include "services.h"
#endif
#include "timemsg.h"
#include "tsconfig.h"             // assorted config definitions

#include "exts.h"

#define countof(array)  (sizeof(array)/sizeof(array[0]))
                    
#define LONGTIME    DAY_TICKS
#define SHORTINTERVAL CLUSTERSHORTINTERVAL

//
// Definitions for ComputeDelay coroutines
//

typedef struct _CDContext
{
    PVOID  pvArg;        // whatever the caller needs to point to
    PVOID  pvArg1;
    LONG (*CallBack)(struct _CDContext *pcdc, DWORD reason);
    LPSYSTEMTIME lps;
    DWORD  cRetryCount;
    DWORD  dwTypeOf;
    PDWORD pdwZone;
    PDWORD pdwInterval;
} CDCONTEXT, *PCDCONTEXT;

//
// the reasons
//

#define CDREASON_INIT    1
#define CDREASON_TRY     2
#define CDREASON_FAIL    3
#define CDREASON_GETTIME 4
#define CDREASON_DELAY   5

//
// and types
//

#define CDTYPE_LM       1

//
// manifest return codes

#define BAD_VALUE  -2
#define TIMED_OUT  -3

//
// The LanMan coroutine
//

LONG
LMTry(PCDCONTEXT pcdc,
      DWORD      dwReason
);

// Now the elements and tables we need

ELEMENT e_yesno[] = { {TEXT("No"), 0}, {TEXT("Yes"), 1}};
MATCHTABLE yesno = {countof(e_yesno), e_yesno};

ELEMENT e_mode[] = {{TEXT("Service"), SERVICE}, {TEXT("Analysis"), ANALYSIS}};
MATCHTABLE modetype = {countof(e_mode), e_mode};

ELEMENT e_type[] =
{
            {TEXT("Default"),DEFAULT_TYPE},     // this is the default ...
            {TEXT("Secondary"), SECONDARY},
            {TEXT("Primary"), PRIMARY},
};
MATCHTABLE typetype = {countof(e_type), e_type};

#define SKEWHISTORYSIZE 3

//
// tasync meanings:
// 0 => do time drift the old timeserv way
// bit 0 set -> don't do it at all
// bit 1 set => save in registry
// bit 2 don't do skew averaging and analysis but do adjust for skew
// bit 3 do long-range skew analysis
//

#define TA_DONT 0x1
#define TA_SAVE 0x2
#define TA_SET 0x4
#define TA_ANAL 0x8
#define TA_NOBACK 0x10

//
// The following long list of globals is historical. At one time,
// all of the code was in one source module with extensive sharing
// of the global data. Rather than rewrite the code, which would have
// mandated an enormous testing effort, the sharing model was
// retained.
//

BOOLEAN fNetworkSynch,
        fAdjForcedOn = FALSE,
        firstpass = TRUE,
        fBeenThere = FALSE;
DWORD	dwWaitResult, Sleepy;
LONG	interval;
SYSTEMTIME nt, st;
UINT  count=0, position=0;
BOOLEAN fShutServer, fTimeFailed;
LONG                    lThreads;
DWORD tasync=0, period=0, mode=SERVICE, Orgtype=DEFAULT_TYPE;
DWORD type;
HANDLE                  hServDoneEvent = NULL;
SERVICE_STATUS          ssStatus;       // current status of the service

SERVICE_STATUS_HANDLE   sshStatusHandle;
HANDLE                  threadHandle;
BOOLEAN                 fService = TRUE,//this flag isn't intended to be documented
                        fStatus = FALSE,//note to localizers - this flag is used mostly to print internal msgs
                        fRand = TRUE;
DWORD adj=100144, incr=100144, incr2;
DWORD b_adj = 0;
DWORD b_time;
DWORD timesource=FALSE;//for flag from LanmanServer\Parameters\timesource in registry
TCHAR primarysource[10*UNCLEN];
TCHAR *primarysourcearray[14]={TEXT("\\\\TIMESOURCE")};//15 entries possible for now
int arraycount=1;
TCHAR secondarydomain[DNLEN]=TEXT(""); // default means use current domain/workgroup 

struct tm *newtime;
SYSTEMTIME LastNetSyncTime;//this is static so that it inits to 0

//
//  Forward Procedure/Function Declarations:
//


VOID    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID    WINAPI   service_ctrl(DWORD dwCtrlCode);
BOOL    ReportStatusToSCMgr(DWORD dwCurrentState,
                DWORD dwWin32ExitCode,
                DWORD dwCheckPoint,
                DWORD dwWaitHint);
VOID    CheckSlewBack(PLONG pinterval);
VOID    worker_thread(VOID *notUsed);
long    TimeDiff(SYSTEMTIME *st, SYSTEMTIME *nt);
VOID    CMOSSynchSet(BOOL fAdjForcedOn, BOOL fChange);
VOID    SetAdjInRegistry(DWORD adj, double * skew);
BOOL    BeenSoLongNow();

DWORD
WaitForSleepAndSkew(
    HANDLE hEvent,
    LONG   lSleepTime);

DWORD
FindTypeByName(
    LPTSTR Name
    );

LONG SetTimeNow(
    LONG clockerror,
    BOOL fAdjForcedOn
    );

VOID
TsUpTheThread();

DWORD
ComputeDelay(
             PLONG  plDelay,
             PCDCONTEXT pcdc);

LONG
CompensatedTime(LONG lTime);

BOOL
ConsoleHandler(DWORD dwCtrlType);

VOID
PutTime(PULONG pTime, ULONG ulIncrement);

VOID Clearbabs();

DWORD version=0;
DWORD logging = FALSE;
int delayadj=50;//default 50+8ms will be added, since the USNO does not advance
DWORD uselocal=FALSE; //if Spectracom NETCLOCK local or HP local or PCLTC local

LARGE_INTEGER li1900 = {0xfde04000,
                        0x14f373b};

DWORD
GetDefaultServerName(TCHAR * Server,
                     TCHAR * Domain);

VOID
ClearDefaultServerName();


#ifdef PERF
__int64 perffreq;
#endif

VOID
SetTSTimeRes(DWORD adj);

LPTSTR PeriodNames[] = {
                 TEXT("SpecialSkew"),
                 TEXT("Weekly"),
                 TEXT("Tridaily"),
                 TEXT("BiDaily") };

float flTSTimeRes;
LONG  lTSTimeRes;

LPTSTR
FindPeriodByPeriod(DWORD period)
{
    if(period >= SPECIAL_PERIOD_FLOOR)
    {
        return(PeriodNames[period - SPECIAL_PERIOD_FLOOR]);
    }
    return(0);
}

DWORD
FindPeriodByName(
    LPTSTR Name
    )
{
    DWORD dwX;
    LPTSTR *pNames = &PeriodNames[0];
    LPTSTR *pNamesEnd = &PeriodNames[0xFFFF - SPECIAL_PERIOD_FLOOR];

    for(dwX = 0; pNames <= pNamesEnd; dwX++, pNames++)
    {
        if(_tcsicmp(Name, *pNames) == 0)
        {
            return(SPECIAL_PERIOD_FLOOR + dwX);
        }
    }
    return(0);
}


DWORD
FindTypeByName(
    LPTSTR Name
    )
{
    DWORD dwCnt;
    PELEMENT pel;

    pel = typetype.element;
    dwCnt = typetype.cnt;

    for(; dwCnt; dwCnt--, pel++)
    {
        if(_tcsicmp(Name, pel->key) == 0)
        {
            return(pel->value);
        }
    }
    return(DEFAULT_TYPE);
}

LPTSTR
FindTypeByType(
    DWORD type
    )
{
    DWORD dwCnt;
    PELEMENT pel;

    pel = typetype.element;
    dwCnt = typetype.cnt;

    for(; dwCnt; dwCnt--, pel++)
    {
        if(type == pel->value)
        {
            return(pel->key);
        }
    }
    return(typetype.element->key);
}



//  main() --
//      all main does is call StartServiceCtrlDispatcher
//      to register the main service thread.  When the
//      API returns, the service has stopped, so exit.
//
#if SVCDLL == 0          // if we are our own EXE
VOID
_cdecl
main(int argc, char **argv)
{
#else                // otherwise, we are a server service thread
LMSVCS_ENTRY_POINT(
    DWORD NumArgs,
    LPTSTR *ArgsArray,
    PLMSVCS_GLOBAL_DATA LmsvcsGlobalData,
    HANDLE SvcRefHandle
    )
{
    int argc = 1;
    char * ouname = "TimeServ";
    char ** argv = &ourname;
#endif
    HANDLE hToken;
    PTOKEN_PRIVILEGES ptkp=NULL;

    SERVICE_TABLE_ENTRY dispatchTable[] = {
        { TEXT("TimeServ"), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };
    int i;
    BOOL inifile=FALSE;
    DWORD starttype=FALSE;

// grab the args first
    for(i = 1; i < argc; i++)
    {
    // We're some args. Let's parse them
        
        _strlwr(argv[i]);
        if(!strcmp("-noservice", argv[i]) || !strcmp("/noservice", argv[i]))
        {
            fService = FALSE;     // run as a console app
        } else
        if(!strcmp("-status", argv[i]) || !strcmp("/status", argv[i]))
        {
            fService = FALSE;
            fStatus = TRUE;
        } else
        if (!strcmp("-automatic", argv[i]) || !strcmp("/automatic", argv[i]))
           // this means create the service, to start automatically,
           // should it be localized?
        {
            fService = FALSE;
            starttype = SERVICE_AUTO_START;
            inifile = TRUE;
        } else
        if (!strcmp("-manual", argv[i]) || !strcmp("/manual", argv[i]))//this means create the service, to start manually, should it be localized?
        {
            fService = FALSE;
            starttype = SERVICE_DEMAND_START;
            inifile = TRUE;
        } else
        if (!strcmp("-update", argv[i]) || !strcmp("/update", argv[i]))//this means update any settings by reading the ini file, should it be localized?
            inifile = TRUE;

        // should we allow a -RTC/RTC here to jamp bc620AT from PC's time?

        else
        {
            TimePrint("TimeServ [-automatic]|[-manual]|[-update]\n");//should this be localized?
            //use: -noservice -status\n");
            exit(1);
        }
    }
    
    // Get the current process token handle 
    // so we can get set-time privilege. 

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
    {
        return;
    }

    // Get the LUID for system-time & increase priority privileges. 

    ptkp = (PTOKEN_PRIVILEGES)malloc (sizeof(TOKEN_PRIVILEGES) +
        (2-ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if ( !ptkp ) {
        return;
    }

    LookupPrivilegeValue(NULL,
                         SE_INC_BASE_PRIORITY_NAME, 
                         &(ptkp->Privileges[0].Luid));
    LookupPrivilegeValue(NULL,
                         SE_SYSTEMTIME_NAME,
                         &(ptkp->Privileges[1].Luid));

    //note: some build stopped requiring ATP for system-time, but we do it anyway
    
    ptkp->PrivilegeCount = 2;  // two privileges to set  
    ptkp->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    ptkp->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    // Get set-time & increase priority privilege for this process. 

    AdjustTokenPrivileges(hToken, FALSE, ptkp, 0, NULL, 0);
    
    // Cannot test return value of AdjustTokenPrivileges. 

    if (GetLastError() != ERROR_SUCCESS)
    {
        return;
    }

    free(ptkp);

    version=GetVersion();
    if (version &0x80000000)
    {
        TimePrint("Unsupported on Windows %d.%02d!\n",version&0xff,(version&0xff00)>>8);
    }
    version = ((version&0xff)<<8)+((version&0xff00)>>8);//swap the order so that we can compare
    {//!chicago
        BOOL taflag;

        GetSystemTimeAdjustment(&adj,&incr,&taflag);
        if (adj!=incr)
        {
            if (fStatus)
                TimePrint("%d Adj!=Incr %d\n",adj,incr);
            if (abs(adj-incr)>(incr/1000.0+.5)) {
                adj=incr;
#ifdef VERBOSE
                if (fStatus)
                    TimePrint("Differs by >.1%%, resetting Adj=Incr\n");
#endif          
                SetSystemTimeAdjustment(adj,taflag);
                SetTSTimeRes(adj);
            }
        }
        incr2 = incr / 2;
#ifdef PERF     
        if (!QueryPerformanceFrequency(&perffreq))
        {
#ifdef VERBOSE
        if (fStatus)
            TimePrint("QueryPerformanceFrequency failed\n");
#endif
#define TESTPERIOD 18000 //180000 gives a good estimate, 18000 reasonable, 10000 okay, 5000 misses it 
        }
#ifdef VERBOSE  
        else
        {
            __int64 perfctr1, perfctr2;
            int x;
            if (fStatus)            
                TimePrint("QueryPerformance resolution %fus\nTesting, please wait %d seconds...\n",1000000.0/perffreq,(int)(TESTPERIOD/1000.0+.5));
            QueryPerformanceCounter(&perfctr1);
            Sleep(TESTPERIOD);
            QueryPerformanceCounter(&perfctr2);             
            if (abs(TESTPERIOD-(long)((1000.0/perffreq)*(perfctr2-perfctr1)+.5)>(2*adj/10000.0+.5)))//more than two ticks diff?
if (fStatus)
                TimePrint("Scheduler and QueryPerformanceCounter don't appear to agree, assume\n QPF off by ~%.3f%% (should be ~%.3fMHz, not %.3fMHz)!\n",
                fabs(100-(((1000.0/perffreq)*(perfctr2-perfctr1))/TESTPERIOD)*100),
                (perffreq-perffreq*(double)(1.0-(((1000.0/perffreq)*(perfctr2-perfctr1))/TESTPERIOD)))/1000000.0,perffreq/1000000.0);
            QueryPerformanceCounter(&perfctr1);
            for (x=0; x<32765; x++)
            {
                QueryPerformanceCounter(&perfctr2);
                if (perfctr2<perfctr1)
                {
                    if (fStatus)
                        TimePrint("QueryPerformanceCounter ran backwards (or rolled over): %ld came after %ld!\n",perfctr2,perfctr1);
                }
                else
                    perfctr1=perfctr2;
                if ((x/1000.0)==(x/1000)) 
                    Sleep(0);//give up our time slice ~32 times
            }               
        }
#endif
#endif
    }//!chicago


#ifdef VERBOSE          
    {
        SYSTEMTIME st;
        int oldms, avgms;
        //the following code tries to find time resolution,
        //in case it ever gets better than our assumption
        Sleep(500);//give up our timeslice & wait
        GetSystemTime(&st);
        do {
            oldms=st.wMilliseconds;
            GetSystemTime(&st);
        } while (oldms==st.wMilliseconds);
        if (oldms>st.wMilliseconds)
            oldms-=1000;
        avgms=st.wMilliseconds-oldms;
        do {
            oldms=st.wMilliseconds;
            GetSystemTime(&st);
        } while (oldms==st.wMilliseconds);
        if (oldms>st.wMilliseconds)
            oldms-=1000;
        avgms=(avgms+(st.wMilliseconds-oldms))/2;
        if (abs(avgms-(int)(adj/10000.0+.5))>1)
            if (fStatus)                    
                TimePrint("Note: Resolution appears to be %dms, but we set to %.4fms\n",avgms,adj/10000.0);
    }
#endif          


    if (inifile)
    { 
        TimeInit();
    }

    if (starttype)//either automatic or manual specified
    {
        TimeCreateService(starttype);
        exit(0);
    }
    if (inifile && fService)
        exit(0);

    if(fService)
        StartServiceCtrlDispatcher(dispatchTable);
    else
        service_main(0, 0);
}

//  service_main() --
//      this function takes care of actually starting the service,
//      informing the service controller at each step along the way.
//      After launching the worker thread, it waits on the event
//      that the worker thread will signal at its termination.
//
VOID
service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{
    DWORD                   TID = 0;
    DWORD                   dwWait;

    if(fService)
    {
        // register our service control handler:
        //
        sshStatusHandle = RegisterServiceCtrlHandler(
                        TEXT("TimeServ"),
                        service_ctrl);

        if (!sshStatusHandle)
        {
            goto cleanup;
        }

        // SERVICE_STATUS members that don't change in example
        //

        ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
        ssStatus.dwServiceSpecificExitCode = 0;


        // report the status to Service Control Manager.
        //
        if (!ReportStatusToSCMgr(
                   SERVICE_START_PENDING, // service state
                   NO_ERROR,              // exit code
                   1,                     // checkpoint
                   3000))                 // wait hint
        {
            goto cleanup;
        } 
    }                   // if fService

    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServDoneEvent = CreateEvent(
                                NULL,    // no security attributes
                                TRUE,    // manual reset event
                                FALSE,   // not-signalled
                                NULL);   // no name

    if (hServDoneEvent == (HANDLE)NULL)
    {
        goto cleanup;
    }

    if(fService)
    {

        // report the status to the service control manager.
        //
        if (!ReportStatusToSCMgr(
                              SERVICE_START_PENDING, // service state
                              NO_ERROR,              // exit code
                              2,                     // checkpoint
                              3000))                 // wait hint
        {
            goto cleanup;
        }

    }                   // if fService


    // start the thread that performs the work of the service.
    //
    threadHandle = CreateThread(
                             NULL,       // security attributes
                             0,          // default stack size
                             (LPTHREAD_START_ROUTINE)worker_thread,
                             NULL,       // argument to thread
                             0,          // thread creation flags
                             &TID);      // pointer to thread ID

    if (!threadHandle)
    {
        goto cleanup;
    }

    if(fService)
    {
        // report the status to the service control manager.
        //
        if (!ReportStatusToSCMgr(
                       SERVICE_RUNNING, // service state
                       NO_ERROR,        // exit code
                       0,               // checkpoint
                       0))              // wait hint
        {
            StopTimeService(MSG_SSS_FAILED);
        }

    }           // if fService

    // wait indefinitely until hServDoneEvent is signaled.
    //
    dwWait = WaitForSingleObject(
                 hServDoneEvent,  // event object
                 INFINITE);       // wait indefinitely


    //
    // Service termination. Wait for the worker thread to complete.
    // Since this may take a while, time out after 5 secs to update
    // the service controller and do that until it exits.
    // 
    while(WaitForSingleObject(threadHandle, 5000) == WAIT_TIMEOUT)
    {
        if(sshStatusHandle)
        {
            ReportStatusToSCMgr(
                SERVICE_STOP_PENDING, // current state
                NO_ERROR,             // exit code
                1,                    // checkpoint
                6000);                // waithint
        }
    }

    //
    // Set the time to insure the hardware CMOS clock is "accurate"
    //
    TsUpTheThread();
    GetSystemTime(&st);
    SetSystemTime(&st);

cleanup:

    if(threadHandle)
    {
        CloseHandle(threadHandle);
    }

    if (hServDoneEvent != NULL)
    {
        CloseHandle(hServDoneEvent);
    }
   
   // Now disable set-time & increase priority privileges. 

//    ptkp->Privileges[0].Attributes = 0;
//    ptkp->Privileges[1].Attributes = 0;

//    AdjustTokenPrivileges(hToken, FALSE, ptkp, 0, NULL, 0);

//    if (GetLastError() != ERROR_SUCCESS)
//    {
//        StopTimeService(MSG_ATPD_FAILED);
//    }
    // try to report the stopped status to the service control manager.
    //
    if(fService)
    {
        if (sshStatusHandle)
        {
            (VOID)ReportStatusToSCMgr(
                   SERVICE_STOPPED,
                    NO_ERROR,
                    0,
                    0);
        }
    }

    // When SERVICE MAIN FUNCTION returns in a single service
    // process, the StartServiceCtrlDispatcher function in
    // the main thread returns, terminating the process.
    //
    return;
}

// ReportStatusToSCMgr() --
//      This function is called by the ServMainFunc() and
//      ServCtrlHandler() functions to update the service's status
//      to the service control manager.
//
BOOL
ReportStatusToSCMgr(DWORD dwCurrentState,
            DWORD dwWin32ExitCode,
            DWORD dwCheckPoint,
            DWORD dwWaitHint)
{
    BOOL fResult;

    // Disable control requests until the service is started.
    //
    if (dwCurrentState == SERVICE_START_PENDING)
    {
        ssStatus.dwControlsAccepted = 0;
    }
    else
    {
        ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                      SERVICE_ACCEPT_PAUSE_CONTINUE;
    }

    // These SERVICE_STATUS members are set from parameters.
    //
    ssStatus.dwCurrentState = dwCurrentState;
    ssStatus.dwWin32ExitCode = dwWin32ExitCode;
    ssStatus.dwCheckPoint = dwCheckPoint;

    ssStatus.dwWaitHint = dwWaitHint;

    // Report the status of the service to the service control manager.
    //
    if (!(fResult = SetServiceStatus(
                          sshStatusHandle,    // service reference handle
                          &ssStatus)))
    {      

        // If an error occurs, stop the service.
        //
        StopTimeService(MSG_SSS_FAILED);
    }
    return fResult;
}

//  service_ctrl() --
//      this function is called by the Service Controller whenever
//      someone calls ControlService in reference to our service.
//
VOID
WINAPI
service_ctrl(DWORD dwCtrlCode)
{
    DWORD  dwState = SERVICE_RUNNING;

    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {

    // Pause the service if it is running.
    //
    case SERVICE_CONTROL_PAUSE:

        if (ssStatus.dwCurrentState == SERVICE_RUNNING)
        {
            SuspendThread(threadHandle);
            dwState = SERVICE_PAUSED;
        }
        break;

    // Resume the paused service.
    //
    case SERVICE_CONTROL_CONTINUE:

        if (ssStatus.dwCurrentState == SERVICE_PAUSED)
        {
            ResumeThread(threadHandle);
            dwState = SERVICE_RUNNING;
        }
        break;

    // Stop the service.
    //
    case SERVICE_CONTROL_STOP:

        dwState = SERVICE_STOP_PENDING;

        // Report the status, specifying the checkpoint and waithint,
        //  before setting the termination event.
        //
        ReportStatusToSCMgr(
            SERVICE_STOP_PENDING, // current state
            NO_ERROR,             // exit code
            1,                    // checkpoint
            3000);                // waithint

        SetEvent(hServDoneEvent);
        return;

    // Update the service status.
    //
    case SERVICE_CONTROL_INTERROGATE:
        break;

    // invalid control code
    //
    default:
        break;

    }

    // send a status response.
    //
    ReportStatusToSCMgr(dwState, NO_ERROR, 0, 0);
}



//  worker_thread() --
//      this function does the actual nuts and bolts work that
//      the service requires.  It will also Pause or Stop when
//      asked by the service_ctrl function.
//
VOID
worker_thread(VOID *notUsed)
{
    HKEY hKey, hKey2;
    DWORD dwLen;
    BOOL bigskew=FALSE, leapflag=FALSE;
    DWORD tempadj;//assume ~10ms for pre-Daytona
    long clockerror, preverror, currdiff, prevdiff, lostinterval=0;
    long absclockerror;
    double drift, meandrift=0, skew, stability, sumsquaresdrift=0, sumsquaresdiff=0;
    DWORD samples = 0, iskewx = 0;
    LONG  lJitter, lOldJitter;
    int i;
    WSADATA wsadata;
    DWORD   status;

    
// remember last primary we found. We do this to avoid hopping around the net
// as we assume primaries are rare resources.

    UINT CurrentPrimary=0;

    InterlockedIncrement(&lThreads);

    WSAStartup(MAKEWORD(1,1),&wsadata); // just in case

   
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TSKEY,0,KEY_QUERY_VALUE|KEY_SET_VALUE,&hKey);
    if ( status != ERROR_SUCCESS ) {
        TimePrint( "Failed to open TSKEY.\n" );
        StopTimeService(MSG_EVENT_KEY);
    }

    dwLen = sizeof(DWORD);  
    status = RegQueryValueEx(hKey,TEXT("TAsync"),NULL,NULL,(LPBYTE)&tasync,&dwLen);
    if ( status != ERROR_SUCCESS ) {
        TimePrint( "Failed to read TAsync value. continuing...\n" );
        //StopTimeService(MSG_EVENT_KEY);
    }
    status = RegQueryValueEx(hKey,TEXT("Mode"),NULL,NULL,(LPBYTE)&mode,&dwLen);
    if ( status != ERROR_SUCCESS ) {
        TimePrint( "Failed to read MODE value. continuing...\n" );
        //StopTimeService(MSG_EVENT_KEY);
    }
    status = RegQueryValueEx(hKey,TEXT("Log"),NULL,NULL,(LPBYTE)&logging,&dwLen);
    if ( status != ERROR_SUCCESS ) {
        TimePrint( "Failed to read LOG value. continuing...\n" );
        //StopTimeService(MSG_EVENT_KEY);
    }
    {
        TCHAR tsKey[200];
        DWORD dwTypeOfKey, dwLen1 = sizeof(tsKey);

        if(RegQueryValueEx(hKey,
                        TEXT("Type"),
                        NULL,
                        &dwTypeOfKey,
                        (LPBYTE)tsKey,
                        &dwLen1) == NO_ERROR)
        {
            switch(dwTypeOfKey)
            {
                case REG_DWORD:             // old style numeric value
                    Orgtype = *(PDWORD)tsKey;
                    break;
                case REG_SZ:
                    Orgtype = FindTypeByName(tsKey);
                    break;
                default:
                    Orgtype = DEFAULT_TYPE;
                    if(fStatus)
                    {
                        TimePrint("Invalid registry type %d\n", dwTypeOfKey);
                    }
            }
        }
        else
        {
            Orgtype = DEFAULT_TYPE;
        }

        if(NETWORKTYPE(Orgtype)
              ||
           (Orgtype == DEFAULT_TYPE) )
        {
            fNetworkSynch = TRUE;
        }
        else
        {
            fNetworkSynch = FALSE;
        }
    }
    {
        TCHAR tsKey[200];
        DWORD dwTypeOfKey, dwLen1 = sizeof(tsKey);

        if(RegQueryValueEx(hKey,
                        TEXT("Period"),
                        NULL,
                        &dwTypeOfKey,
                        (LPBYTE)tsKey,
                        &dwLen1) == NO_ERROR)
        {
            switch(dwTypeOfKey)
            {
                case REG_DWORD:             // old style numeric value
                    period = *(PDWORD)tsKey;
                    break;
                case REG_SZ:
                    period = FindPeriodByName(tsKey);
                    break;
                default:
                    period = 0;
                    if(fStatus)
                    {
                        TimePrint("Invalid registry period %d\n", dwTypeOfKey);
                    }
            }
        }
        else
        {
            period = 0;
        }
    }
    status = RegQueryValueEx(hKey,TEXT("RandomPeriod"),NULL,NULL,(LPBYTE)&fRand,&dwLen);
    if ( status != ERROR_SUCCESS ) {
#if 0
        TimePrint( "Failed to read RandomPeriod value.\n" );
        StopTimeService(MSG_EVENT_KEY);
#endif
        fRand = 0;
    }

    //
    // sanity check the type
    //

    if(!LegalType(Orgtype))
    {
        Orgtype = DEFAULT_TYPE;
    }

    if(Orgtype == DEFAULT_TYPE)
    {
        //
        // an unconfigured service. We look for a LanMan
        // timesource
        //
 
    }

    type = Orgtype;

    if (!period)
    {
        switch (type) {
            case DEFAULT_TYPE:
                period = CLUSTER_PERIOD;
                break;
            case PRIMARY:
            case SECONDARY:
                period=3; //every "shift" (8 hours)
        }
    }

    if((period == CLUSTER_PERIOD)
             &&
       !tasync)
    {
        tasync = TA_SAVE | TA_ANAL;         // allow skew setting in this case
    }
    
    
    //
    // seed the random number generator.
    // This is not a very good seeding, especially if the machines are
    // well-time synchronized. But what is better?
    //

    srand((unsigned)time(NULL));

    if (tasync & TA_SAVE)
    {
        if(!RegQueryValueEx(hKey,TEXT("Adj"),NULL,NULL,(LPBYTE)&adj,&dwLen))
        {
            if (dwLen==sizeof(DWORD))
            {
                if (fStatus)
                { 
                    TimePrint("Using sticky Adj %d\n",adj);
                }
            }
        }
    }

    dwLen = sizeof(primarysource)+sizeof(TCHAR);
    if (!RegQueryValueEx(hKey,TEXT("PrimarySource"),NULL,NULL,(LPBYTE)primarysource,&dwLen))
    {
        //parse out into an array of strings for convenience
        arraycount=0;
        position=0;
        while((TCHAR)primarysource[position]!=UNICODE_NULL)
        {
            TCHAR * ptr;
            //we cheat by assigning here, assume we have enough pointers
            primarysourcearray[arraycount]=&primarysource[position];
            ptr = _tcschr(&primarysource[position],(TCHAR)0);//UNICODE_NULL

            if (NULL == ptr)
                break;

            //we could compare to our assumption if we want to keep cheating
            arraycount++;

            //you get a huge offset if you don't subtract the start
            //since dwLen < 2^32 it is reasonable that position < 2^32

            position=(UINT)(ptr+1-primarysource);
        }
    }

    dwLen = sizeof(secondarydomain)+sizeof(TCHAR);
    status = RegQueryValueEx(hKey,TEXT("SecondaryDomain"),NULL,NULL,(LPBYTE)secondarydomain,&dwLen);
    if ( status != ERROR_SUCCESS ) {
#if 0
        TimePrint( "Failed to read SecondaryDomain value.\n" );
        StopTimeService(MSG_EVENT_KEY);
#endif
    }

    RegCloseKey(hKey);

    //
    // Before we enter the main loop, set our priority ...
    //
    // boost priority to help ensure accuracy 
    
    TsUpTheThread();

    //
    // if permitted, turn off the kernel's periodic CMOS time synch
    //
        
    CMOSSynchSet(fAdjForcedOn, FALSE);

    //
    // the main loop
    // this is executed each time we wish to synchronize time. In order
    // to minimize resource consumption, and assuming a time synch
    // is done infrequently, this loop must acquire all of the resources
    // each time. This trade-off is deemed the right one.
    //

    while (1)
    {
        BOOL fSetTime = FALSE;

        Sleepy = 0;
        dwWaitResult = WAIT_TIMEOUT;
    
        if(type == DEFAULT_TYPE)
        {
            type = PRIMARY;
        }

        fTimeFailed = FALSE; //start with assumption that things are working


    //
    // see about the PRIMARY and SECONDARY modes. Note we don't check
    // fTimeFailed since there is no prelimary processing as with
    // many of the other modes
    //

    //
    // N.B. we can't do this as a switch since we may be doing DEAULT
    // and therefore mode switching can take place ...
    //
    if((type <= PRIMARY) )
    {
        DWORD dwInterval, dwZone;

        if(type == PRIMARY)
        {
            fTimeFailed = TRUE;

            // if we've no primary yet, find one. Else use the last
            // one.

            if(!(count = CurrentPrimary))
            {
                count=0; // start at top of list (not really a count)
            }
            else
                count--;
            position=count;
            do 
            {
                CDCONTEXT cdc;
                LPTIME_OF_DAY_INFO lptod = 0;

                cdc.CallBack = LMTry;
                cdc.pvArg = (PVOID)&lptod;
                cdc.lps = &nt;
                cdc.pdwZone = &dwZone,
                cdc.pdwInterval = &dwInterval;
                cdc.pvArg1 = (PVOID)primarysourcearray[position++];
                cdc.dwTypeOf = CDTYPE_LM;

                // try this machine

                if (!ComputeDelay(
                                  &lJitter,
                                  &cdc))
                {
                    fTimeFailed = FALSE;
                    if (fStatus)
                        TimePrint("%ls ",primarysourcearray[position-1]);                          
                    CurrentPrimary = position;
                    break;
                }
                else                    // failed
                {
                    // failed. So we have no current primary

                    CurrentPrimary = 0;
                }
            }
            while ((position = (position % arraycount)) != count);//until the list would start repeating
            if (fTimeFailed)
            {
                LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_PRIMARY_FAILED);
            }
        }
        else                   // SECONDARY
        {
            TCHAR servername[UNCLEN];

            fTimeFailed = FALSE;
            // If either call fails, or returns no servers, complain

            if(GetDefaultServerName(servername,
                                    secondarydomain[0] ?
                                       secondarydomain : NULL))
            {
                //
                // No time servers located. If this is a default
                // configuration, turn on the CMOS time synch until
                // we can locate one of these guys
                //
                //LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_SECONDARY_FAILED);

//
// BUGBUG. When we have the proper API for CMOS time synch, the following
// should change type to CMOS and continue. This implies that the code
// block for doing CMOS should be after this one ...
// ASM
                if((type != Orgtype)
                         &&
                    BeenSoLongNow())
                {

                    CMOSSynchSet(fAdjForcedOn = TRUE, FALSE);
                }
                fTimeFailed = TRUE;
            }
            else
            {
                CDCONTEXT cdc;
                LPTIME_OF_DAY_INFO lptod = 0;

                cdc.CallBack = LMTry;
                cdc.pvArg = (PVOID)&lptod;
                cdc.lps = &nt;
                cdc.pdwZone = &dwZone,
                cdc.pdwInterval = &dwInterval;
                cdc.pvArg1 = (PVOID)servername;
                cdc.dwTypeOf = CDTYPE_LM;

                // Got some servers


                 if(fAdjForcedOn)
                 {
                     CMOSSynchSet(fAdjForcedOn = FALSE, FALSE);
                 }
                if (ComputeDelay(
                                 &lJitter,
                                 &cdc) )
                {
                    fTimeFailed = TRUE;
                    ClearDefaultServerName();
                    LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_TOD_FAILED);
                }
                else
                {
            //if firstpass, maybe we should log what server was used?
                    if (fStatus)
                    {
                        TimePrint("%ls ",servername);
                    }
                }
            }
        }

        if (!fTimeFailed)
        {
    
#ifdef VERBOSE
        if(fStatus)
        {
            TimePrint("interval=%ld", dwInterval);
            TimePrint(", timezone=%ld\n", dwZone);
        }
        if (fStatus && (abs(dwZone)>24*60))
        {
            TimePrint("timezone value seems bogus!\n");
        }
#endif

        }
#ifdef ENUM//we don't really want to do this, it takes over 40 minutes on the MS corpnet...
        else
        {
            EnumerateFunc(NULL); // show the timesource for each domain/workgroup on the network! 
        }
#endif
    }


    if (!fTimeFailed)
    {
        if (nt.wYear < 1900) { //this won't hurt, but does any "type" still use this?
#ifdef VERBOSE
if (fStatus)
        TimePrint("hmm, year<1900 code is still used by this type\n");
#endif
        nt.wYear += 1900;  // start of 20th century 
        }

#ifdef VERBOSE
        if (nt.wYear > (1994+1900)) {
            if (fStatus)
                TimePrint("hmm, year+1900 wasn't supposed to be used by this type\n");
            nt.wYear -=1900;
        }
#endif
    //we'll perform a sanity check here

        if (nt.wYear < 1995) { //are we trying to set a date before this program was released?
            fTimeFailed = TRUE;
            LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_TOOEARLY);
            if(fStatus)
            {
                TimePrint("Year = %d\n", nt.wYear);
            }
            goto finishedset; //get out
        }               

    //what about if we are trying to set exact leap second (23:59:60)?
    //nt.wYear=1995; nt.wMonth=12; nt.wDay=31;nt.wHour=23; nt.wMinute=59; nt.wSecond=60;//bugbug force test (use UTC type)
        if (nt.wSecond==60) {
#ifdef VERBOSE
if (fStatus) TimePrint("We're trying to set during a leap second (-59:60), so using -59:59!\n");
#endif
            nt.wSecond=59;//fake it since NT will complain (tested on 3.51)
        //ideally we'd like to slew backwards, but this is so rare...
            leapflag=TRUE;//let later code know (for error adjust and logging)
        }

        if (LOCAL)
            GetLocalTime(&st); //fyi: this seems to take around 44us
        else
            GetSystemTime(&st);

        clockerror = TimeDiff(&st,&nt);//fyi: this seems to take around 36us@66(25us@133) double, or 30us __int64
    
        absclockerror = abs(clockerror);

        //we'll perform another sanity check here

        if ((absclockerror > (HOUR_TICKS * 12))&& !firstpass) { //did we see error of > half day during loop?
            fTimeFailed = TRUE;
            LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_TOOBIG);
            goto finishedset; //get out
        }

        //
        // see if we need to set the time. We don't do this
        // if we are using time skewing instead. 
        //

        if (firstpass
               ||
            (
              (tasync & (TA_SET | TA_DONT))
                 ||
              (!tasync)
                 ||
              (iskewx >= (SKEWHISTORYSIZE - 1))
            ) )
        {
            clockerror = SetTimeNow(clockerror, fAdjForcedOn);
            absclockerror = abs(clockerror);
 
            fSetTime = TRUE;
        }
    
    }//!fTimeFailed
finishedset://this label is the exit from two sanity checks

    if (!fTimeFailed)
    {
        if (logging) {
            if (absclockerror<500)
                LogTimeEvent(EVENTLOG_INFORMATION_TYPE,MSG_TIMESET_SMALL);
            else
                LogTimeEvent(EVENTLOG_INFORMATION_TYPE,MSG_TIMESET_LARGE);
        }
        if (fStatus) {
            TimePrint("Time was -%02u:%02u.%03u\n", st.wMinute, st.wSecond, st.wMilliseconds);
            TimePrint("Time is  -%02u:%02u.%03u\n", nt.wMinute, nt.wSecond, nt.wMilliseconds);
            TimePrint("Error %ldms\n",clockerror);
        }
        
        if (LOCAL)
            GetSystemTime(&nt); //get the UTC date (instead of local)
        
    //whether clock is UTC or not, we might get a leap second and want to account for it
        if (leapflag||((abs(clockerror-1000)<(24*60*60*1000.0 / (adj*2))) && !firstpass && ((nt.wMonth==1)||(nt.wMonth==7)) && (nt.wDay==1))) {//Jan or July 1st error +1s (+/-skew)?
            leapflag=FALSE;
            clockerror -= 1000;//for stats/skew, let's pretend it didn't happen
            absclockerror = abs(clockerror);
            LogTimeEvent(EVENTLOG_INFORMATION_TYPE,MSG_LEAP);//let 'em know
#ifdef VERBOSE
if (fStatus)                    
        TimePrint("Oops, Error actually %ldms\n",clockerror);
#endif

        }

    
        if (!firstpass)
        {
            float flabsSkew;

            //
            // compute the skew for this
            //

            skew = ((float)(DAY_TICKS) /
                        (lostinterval+interval*(samples+1))) * clockerror;

            if (fStatus)
            {
                TimePrint("Skew %.4fms/d, samples = %d \n",skew, samples);
            }

            flabsSkew = (float)fabs(skew);

            NextSkewX(iskewx);
            if(!fSetTime)
            {
                samples++;
            }
            else
            {
                samples = 0;
            }

            if(!(tasync & TA_DONT)
                  &&
               ( tasync
                   ||
                 !fNetworkSynch) )
            {
                //
                // sanity check the skew. It must be less than 30 secs
                // a day, and if we are calibrated, less than 1 sec per day
                //
                //

                if(flabsSkew > MAXSKEWCORRECT)
                {
                    //
                    // it's too large to believe.
                    //

                    if (!bigskew)
                    {
                        LogTimeEvent(EVENTLOG_INFORMATION_TYPE,MSG_TOO_MUCH_SKEW);
                        bigskew=TRUE;//don't want to generate the log event repeatedly
                    }
                    if((adj != incr)
                           &&
                        fNetworkSynch)
                    {
                        adj = incr;
                        CMOSSynchSet(fAdjForcedOn, TRUE);
                        if(fStatus)
                        {
                             TimePrint("Resetting adj after skew failure\n");
                        }
                    }
                    //
                    // we do the loop again to set a time. And we
                    // recompute everything from starters.
                    //
                    // BUGBUG. Should we reset the adjustment?
                    //
                    if(fStatus)
                    {
                        TimePrint("Skew is bad. Starting over\n");
                    }
                    iskewx = samples = 0;
                    lostinterval = 0;
                    firstpass = TRUE;        // start anew as we are out of synch
                    Clearbabs();
                    continue;
                }
                else
                {

                    //
                    // we have the skew. 
                    // See if time to assess whether to use it
                    //

                    if((!tasync)
                           ||
                        (tasync & TA_SET)
                           ||
                        (iskewx >= SKEWHISTORYSIZE)
                           ||
                        (absclockerror >= MAXERRORTOALLOW) )
                    {


                        if ((flabsSkew > (24*60*60*1000.0 / (adj*2)))
                                      &&
                            ((tasync & TA_SET)
                                      ||
                             !(tasync & TA_ANAL)
                                      ||
                             (absclockerror >= lTSTimeRes)) )
                        {
                            DWORD oldadj;

                            if(!fSetTime)
                            {
                                //
                                // Get here when we are doing skew analysis
                                // and the error exceeded the minimum.
                                // Force a time setting now.

                                if(fStatus)
                                {
                                    TimePrint("Force time set and retry\n");
                                }
                                iskewx = SKEWHISTORYSIZE - 1;
                                Clearbabs();
                                continue;
                            }
                            oldadj = adj;
                            adj -= (DWORD)
                                   (adj * (skew / (24*60*60*1000.0))+.5*((skew<0)?-1:1));//weird round for neg skew
                            if (adj!=oldadj)
                                 LogTimeEvent(EVENTLOG_INFORMATION_TYPE,
                                              MSG_CHANGE);
                            if (fStatus)
                            {
                                TimePrint("Changing Adj to %d\n",adj);
                            }
                            if (tasync & TA_SAVE)
                            {
                                SetAdjInRegistry(adj, &skew);
                            }

                            if(!b_adj)
                            {
                               SetSystemTimeAdjustment(adj,
                                                       FALSE); 
                               SetTSTimeRes(adj);
                            }

                            //
                            // if doing skew analysis and the adjustment
                            // is more than two ticks, restart the
                            // analysis. This is done since a large adjustment
                            // is ill-advised and can
                            // cause an error of more than 500 ms. And this
                            // is unfortunate. Once the clocks are properly
                            // calibrated, the ongoing adjustments should
                            // be small. Two ticks may also be too large,
                            // but one tick may be too small and may
                            // cause a restart unnecessarily. The granularity
                            // of the hardware clock makes this a difficult
                            // problem

                            if((tasync & TA_ANAL)
                                    &&
                               (abs(adj - oldadj) > 2) )
                            {
                                if(fStatus)
                                {
                                    TimePrint("Skew change too big. Restarting analysis\n");
                                }
                                iskewx = samples = 0;
                                lostinterval = 0;
                                firstpass = TRUE;
                            }
                                
                                   
                            
                        }

                    }
                }
            }
        }   // firstpass                       

        lostinterval=0;  // all intervals now accounted for

    }//!fTimeFailed
    else
    {
        //
        // here on a failure. Throw away any skew history and accumulate
        // intervals in lostinterval so we get the proper skew computation
        // when this thing ever works again.

        samples = iskewx = 0;
        lostinterval+=interval;//add interval to a temporary
    }

    lOldJitter = lJitter;

    switch(period)
    {
        case BIDAILY_PERIOD:
            interval = DAY_TICKS * 2;   //every two days
            break;

        case TRIDAILY_PERIOD:
            interval = DAY_TICKS * 3;   //every three days
            break;

        case WEEKLY_PERIOD:
            interval = DAY_TICKS * 7;   //every week
            break;

        case CLUSTER_PERIOD:
            //
            // special hack for cluster support. 
            // This synchs each CLUSTERSHORTINTERVAL for SKEWHISTORYSIZE tries
            // and then goes into a longer poll. Other areas
            // of this code fiddle with iskewx controlling this
            // cycle
            // N.B. This code makes an important assumption that should
            // be noted and described. The skew adjustment has an inherent
            // error. This is because a change of +- one unit of the
            // clock adjustment results in a change of +- 864 ms/day.
            // Hence, if the actual clock error is not an integral multiple
            // of this, the clock skew adjustment will either overcompensate
            // or undercompensate. In addition, errors introduced by
            // communication delays, temperature-induced clock errors,
            // computational rounding errors, etc. all contribute to
            // error. But taking 864 as a nominal value, the actual
            // error that can happen is 1/2 of this (actually 1/2 is
            // the least-uuper-bound of the errror) or 432 ms/day. Since
            // we know there is measurement error, let's call it 1/2 sec
            // per day. This is the maximum variance allowed, so
            // it becomes intolerable. But, if we sample the time
            // more often than once-a-day, so each 8 hours, then the
            // maximum error from mis-compensation will be 1/3 of
            // 1/2 sec a day, or 1/6 sec/day. This is well within
            // spec. So, these intervals are selected with this in
            // mind and avoids requiring a computation of the mis-compensation
            // and a dynamic setting of the interval. So, changing these
            // interval values must take all this into consideration.
            //
            if(iskewx < SKEWHISTORYSIZE)
            {

                interval = CLUSTERSHORTINTERVAL;
            }
            else
            {
                //
                // now that it's calibrated, resynch at the long interval
                //

               
                interval =  CLUSTERLONGINTERVAL;
            }
            break;

        default:
            if (period)
            {
                interval = DAY_TICKS / period;
            }
    }
 
    
    if ((type==PRIMARY)||(type==SECONDARY))
    {
        LONG stagger, bias;

        // either primary or secondary. Compute sleep stuff.

        if(!fTimeFailed)
        {
            GetSystemTime(&LastNetSyncTime);
        } else
        {
            if((interval > SHORTINTERVAL)
                         &&
               BeenSoLongNow())
            {
                samples = iskewx = 0;   // if analyzing, start anew
                interval = SHORTINTERVAL;
                LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_LONG_TIME);
            }
        }
        // This is the common Sleep for both secondary time sources and
        // client machines. The interval adjustment is the same since
        // both use the network. We do a bit of a randomizer to try
        // to stagger the load on the server
    
        if(fRand)
        {
            if(type != SECONDARY)
            {
                stagger = 60 * 10;
            }
            else
            {
                stagger = 60 * 10 * 10;
            }
            stagger = min(stagger*10L, interval/100) / 10;
            bias = rand() % stagger;
        //the above rand() returns a max of 32K, so we reduced by 100x
        }
        else
        {
           bias = stagger = 0;
        }
#ifdef VERBOSE
        if(fStatus)
    
            TimePrint("Computed stagger is %ldms, bias is %ldms\n",
                        stagger*100, bias*100);
    
#endif
        interval += (bias*100);
        Sleepy = (interval - 40L);  // less length of set 
    }

    if(type != Orgtype)
    {
        type = DEFAULT_TYPE;     // anew the next time around
    }

    if (!fTimeFailed)
    {
        firstpass = FALSE;
    }

    if(fStatus)
    {
        fflush(stdout);
    }


    if(dwWaitResult == WAIT_TIMEOUT)
    {
        dwWaitResult = WaitForSleepAndSkew(hServDoneEvent,
                                           Sleepy);
    }
    if(!dwWaitResult)
    {
        break;
    }

    }              // while 1 loop

    ClearDefaultServerName();

    WSACleanup();

    InterlockedDecrement(&lThreads);
}

DWORD
WaitForSleepAndSkew(
    HANDLE hEvent,
    LONG   lSleep)
{
    DWORD dwWait;

    if(b_adj)
    {
        //
        // If this is a service, establish a Control-C handler. If
        // this is running on the console, allow Contorl-C to
        // be used as a debugging aid. It is likely there is no
        // correct answer to when Control-C should be trapped,
        // so if you wish to change this, and have a good reason,
        // go for it.
        //
        if(fService)
        {
            SetConsoleCtrlHandler(ConsoleHandler, TRUE);
        }

        SetSystemTimeAdjustment(b_adj, fAdjForcedOn);

        dwWait = WaitForSingleObject(
                            hEvent,
                            CompensatedTime(b_time));
            
        if(fService)
        {
            SetConsoleCtrlHandler(ConsoleHandler, FALSE);
        }
        if(fStatus)
        {
            TimePrint("Back adjustment complete\n");
        }
        Clearbabs();
    }
    else
    {
        dwWait = WAIT_TIMEOUT;
    }

    if((dwWait == WAIT_TIMEOUT)
              ||
        lSleep)
    {
        dwWait = WaitForSingleObject(
                             hEvent,
                             CompensatedTime(lSleep - b_time));
    }
    return(dwWait);
}


long
TimeDiff(SYSTEMTIME *st, SYSTEMTIME *nt)
{
struct _FILETIME oldtime, newtime; 
long clockerror;
double tempold, tempnew;
//__int64 tempold, tempnew;//MS specific, saves around 6us

//what will TimeDiff routine do if one of the times is leap second (23:59:60)?
//we call it from modem routines in order to detect line noise

    SystemTimeToFileTime(st,&oldtime);
    SystemTimeToFileTime(nt,&newtime);
    tempold=((oldtime.dwHighDateTime*(4294967296.0))+(oldtime.dwLowDateTime));
    tempnew=((newtime.dwHighDateTime*(4294967296.0))+(newtime.dwLowDateTime));
    //tempold=((oldtime.dwHighDateTime*(4294967296))+(oldtime.dwLowDateTime));
    //tempnew=((newtime.dwHighDateTime*(4294967296))+(newtime.dwLowDateTime));
    clockerror=(long)((tempold-tempnew)/10000);
    return(clockerror);//error in ms
}

WORD YearFromMJD(mjd)
//(this routine is from USNO mjddoy)
//The algorithm is based on the Fliegel/van Flandern paper in COMM of the ACM 11/#10 p.657 Oct. 1968
long mjd;
{
long year, month;
long l, n;
l = mjd +2400001+ 68569;//the ...1 is because MJD started .5 day before JD
n = 4*l/146097;
l = l - (146097*n + 3)/4l;
year = 4000*(l + 1)/1461001;
l = l - 1461l* year/4l + 31;
month = 80*l/2447l;
l = month/11l;
year = 100*(n - 49) + year + l;
return((WORD)year);
}

LONG
LMTry(PCDCONTEXT pcdc, DWORD dwReason)
{
    LPTIME_OF_DAY_INFO lptod, *lptodOld;
    NET_API_STATUS netstatus;
    LPSYSTEMTIME lpSysTime;
    LPTSTR Server = (LPTSTR)pcdc->pvArg1;

    switch(dwReason)
    {

     case CDREASON_INIT:

        if((netstatus = NetRemoteTOD(Server, (LPBYTE *)&lptod)))
        {
            return((LONG)netstatus);
        }
        NetApiBufferFree(lptod);//free the serverenum buffer
        return(0);

     case CDREASON_TRY:

        lptodOld = (LPTIME_OF_DAY_INFO *)pcdc->pvArg;

        if(!(netstatus = NetRemoteTOD(Server, (LPBYTE *)&lptod)))
        {
        
             if(*lptodOld)
             {
                 NetApiBufferFree(*lptodOld);//free the serverenum buffer
             }
             *lptodOld = lptod;
             return(0);
        }
        return((LONG)netstatus);

     case CDREASON_FAIL:
        
        lptodOld = (LPTIME_OF_DAY_INFO *)pcdc->pvArg;
        if(*lptodOld)
        {
            NetApiBufferFree(*lptodOld);//free the serverenum buffer
        }
        *lptodOld = 0;
        return(0);

     case CDREASON_GETTIME:

        lptodOld = (LPTIME_OF_DAY_INFO *)pcdc->pvArg;
        lptod = *lptodOld;
        lpSysTime = pcdc->lps;

        lpSysTime->wYear = (WORD)lptod->tod_year;
        lpSysTime->wMonth = (WORD)lptod->tod_month;
        lpSysTime->wDayOfWeek = (WORD)lptod->tod_weekday;
        lpSysTime->wDay = (WORD)lptod->tod_day;
        lpSysTime->wHour = (WORD)lptod->tod_hours;
        lpSysTime->wMinute = (WORD)lptod->tod_mins;
        lpSysTime->wSecond = (WORD)lptod->tod_secs;
        lpSysTime->wMilliseconds = (WORD)(lptod->tod_hunds*10);
        *pcdc->pdwInterval = lptod->tod_tinterval;
        *pcdc->pdwZone = lptod->tod_timezone;

        NetApiBufferFree(lptod);
        *lptodOld = 0;
        return(0);

     case CDREASON_DELAY:
        return(0);
    }
    return(BAD_VALUE);          // just in case
}

            
                
// Routine to compute round-trip delay to a time server.
// It ties to get the time up to CYCLE times. If the error from
// two consecutive calls is within 10% of one another, it uses
// that value. Else, it averages the errors. It then adjust the
// return time ...
// Args:
//      Server          The name of the server to try
//      

// BUGBUG. Make CYCLE configurable? douhgo, do you want to do this?

#define CYCLE 10                // a number

DWORD
ComputeDelay(PLONG  plDelay,
             PCDCONTEXT pcdc)
{
    ULONG oldDelay=0;
    ULONG i;
    LONG avg, delay, lastdelay;
    ULONG Iter = 0;
    LONG err;
    LPSYSTEMTIME lpSysTime = pcdc->lps;

// We do one stab at it outside of the loop. This is to try to eliminate the
// first time setup cost of the SMB cha-cha. If it fails, we give up. If
// it succeeds, we throw it away and enter the timing loop.

    pcdc->cRetryCount = 0;
    err = pcdc->CallBack(pcdc, CDREASON_INIT);
    if(err)
    {
        return((DWORD)err);
    }

startover:
    for(i = 0, avg = 0; i < CYCLE; i++)
    {
#ifdef PERF
        __int64 perfctr1, perfctr2;
        //if (perffreq)//bugbug we assume it is supported
        QueryPerformanceCounter(&perfctr1);
#else           
        timeBeginPeriod(9);//we'll request better resolution for the duration of the NetRemoteTOD
        delay = timeGetTime();//snapshot the running ms counter
#endif
        err = pcdc->CallBack(pcdc, CDREASON_TRY);
        if(!err)
        {
#ifdef PERF
            QueryPerformanceCounter(&perfctr2);
            delay = (long)((1000.0/perffreq)*(perfctr2-perfctr1)+.5);
#else                   
            delay = (timeGetTime()-delay);//difference in milliseconds
            timeEndPeriod(9);//back to normal
#endif                  
            pcdc->cRetryCount = 0;
            delay -= pcdc->CallBack(pcdc, CDREASON_DELAY);

#ifdef VERBOSE
            if(fStatus)
            {
                TimePrint("Round trip was %dms\n", delay);
            }
#endif
            
// Check if we've converged ...

#ifdef PERF
            if(
#else                   
                // if the delay is less than the timing
                // precision (10 ms), we might as well
                // assume convergence.
            if((delay < (adj/10000.0+.5))   ||
#endif
               (oldDelay &&
               (abs(delay - oldDelay) < ((delay + 5) / (adj/10000.0+.5))))
                      ||
               (i &&
               (abs(delay - lastdelay) < ((delay + 5) / (adj/10000.0+.5)))))
            {
                break;
            }
            lastdelay = delay;
            avg += delay;
        }
        else
        {
            if(fStatus)
                TimePrint("NetRemoteTOD failed in delay computation -- abandoning it\n");//logging should occur elsewhere
                //note: we've seen that when RDR isn't started
            pcdc->CallBack(pcdc, CDREASON_FAIL);
#ifndef PERF    
            timeEndPeriod(9);//back to normal
#endif                  
            if(err == TIMED_OUT)
            {
               --i;
               continue;          // go again
            }
            return((DWORD)err);
        }
    }

    err = pcdc->CallBack(pcdc, CDREASON_GETTIME);

    if(i >= CYCLE)
    {
        ULONG newdelay =
            ((avg + CYCLE - 1) / CYCLE);
        ULONG udiff;

        if((udiff = abs(newdelay - delay)) > ((newdelay + 5) / 10))
        {
#ifdef VERBOSE
        if(fStatus)
        
            TimePrint("Lastdelay %d is more than 10 percent off of the average %d\n", delay, newdelay);
        
#endif
        if(Iter++)
        {
            // if this is the second time, we need
            // to be more circumspect ...
            // so we check if it is within 20%. If
            // so we use it anyway. If not, we give up
            // and return an error saying we couldn't
            // find the machine.

            if(udiff <= ((newdelay + 3) / 5))
            {
#ifdef VERBOSE
                if(fStatus)
                
                    TimePrint("But less than 20 percent, so use it\n");
                
#endif
                goto useit;
            }
            else
            {
                LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_DELAY_FAIL);//no specific server mentioned
                if(fStatus)
                    TimePrint("Could not get delay convergence, so not using time\n");
                return(0xff); // ?????????
            }
        }
renewit:
        pcdc->CallBack(pcdc, CDREASON_FAIL);   // just in case
        oldDelay = avg;
        goto startover;
        }
useit:
        delay = newdelay;                   // within tolerance. Use it
    }
    
// compute one-way delay. This is not symmetric, so we can't just take 1/2 half
// of the round-trip delay. The computation is based on Dougho's empirical
// observations.

    //Rx about 398 bytes for 444 Tx(.472684), plus "roundtrip" overhead
    //or is it really Rx 660 bytes for ~773 Tx(.46057)?
    //should fudge be 15 instead of 38?

    if(pcdc->dwTypeOf == CDTYPE_LM)
    {
        delay = (long)(delay * .4666) + (delay > 99 ? 15 : 0);
    }
    else
    {
        //
        // if not LanMan, consider it symmetric
        //
        delay = (long)(delay * .5);
    }


    *plDelay = delay;        // return delay in ms

    if(fStatus)
    {
        TimePrint("ComputeDelay one-way delay is %d\n", delay);
    }

// Now adjust the time based on the delay ...
// We do it by increasing the hundredths by the computed delay. If that puts
// over a second, we adjust the elpased seconds and readjust hundredths.
// CAUTION CAUTION CAUTION. This assumes the computation of time uses only
// these two values. if it uses others, then this adjustment has to be
// updated.

//One more hack before we are really done. This is a sanity check to ensure
// the computed delay actually makes sense. Like the computation above, it
// is based on empirical measures of a typical environment.

    if (delay > 30000) { //a little more than the largest value seen over RAS
            LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_DELAY_FAIL);//no specific server mentioned
            if (fStatus)
                TimePrint("Delay too large (not trusted), so not using time \n");
                return(0xff);
    }
    else
    {

        lpSysTime->wMilliseconds += (WORD)delay;  // account for delay
        if(lpSysTime->wMilliseconds >= 1000)
        {
            lpSysTime->wSecond += lpSysTime->wMilliseconds / 1000;  // up the seconds
            lpSysTime->wMilliseconds %= 1000;
            if(lpSysTime->wSecond >= 60)
            {
                lpSysTime->wMinute += lpSysTime->wSecond / 60;
                lpSysTime->wSecond %= 60;
                if(lpSysTime->wMinute >= 60)
                {
                    lpSysTime->wHour += lpSysTime->wMinute / 60;
                    lpSysTime->wMinute %= 60;
                    if(lpSysTime->wHour >= 24)
                    {
                        goto renewit;     // bail in this case
                    }
                }
            }
                     
        }
    }
    return(err);
}


// The StopTimeService function can be used by any thread to report an
//  error, or stop the service.
//
VOID
StopTimeService(DWORD dwNum)
{
    // Use event logging to log the error.
    //
    LogTimeEvent(EVENTLOG_ERROR_TYPE, dwNum);
    
    // Set a termination event to stop SERVICE MAIN FUNCTION.
    //
    SetEvent(hServDoneEvent);
}

VOID
LogTimeEvent(WORD type, DWORD dwNum)
{
    HANDLE  hEventSource;
    
    // Use event logging to log
    //

    hEventSource = RegisterEventSource(NULL,
                TEXT("TimeServ"));

    if (hEventSource != NULL) {
        ReportEvent(hEventSource, // handle of event source
        type,                             // event type
        0,                    // event category
        dwNum,                    // event ID
        NULL,                 // current user's SID
        0,                    // strings in lpszStrings
        0,                    // no bytes of raw data
        NULL,          // array of error strings
        NULL);                // no raw data

        (VOID) DeregisterEventSource(hEventSource);
    }
if (fStatus)    
    TimePrint("%x reported to Application Log in Event Viewer\n", dwNum);
    
    
}
VOID
CMOSSynchSet(BOOL fFlag, BOOL fChange)
{
    if (!(tasync &  TA_DONT))
    {
        SetSystemTimeAdjustment(adj,fFlag); // FALSE means no CMOS sync
        SetTSTimeRes(adj);
        if(fChange && (tasync & TA_SAVE))
        {
            SetAdjInRegistry(adj , 0);
        }
    }
}
BOOL
BeenSoLongNow()
{
    //
    // Called to see if the last network synch happend a long time ago
    //

    SYSTEMTIME now;

    GetSystemTime(&now);

    if(TimeDiff(&LastNetSyncTime, &now) > (LONGTIME))
    {
        return(TRUE);
    }
    return(FALSE);
}


LONG
SetTimeNow(
    LONG clockerror,
    BOOL fAdjForcedOn
    )
{
/*++
Routine Description:
   Set the time now based on the obtained time stamp. This performs
   various sanity checks before doing the setting, and determines
   the best method of adjusting the clock. The code has been broken
   out into a separate routine to allow for various analysis modes
   that might be useful to implement in the future.
--*/
    DWORD tempadj;
    LONG absclockerror = abs(clockerror);

    if(fStatus)
    {
        TimePrint("SetTimeNow\n ");
    }
    if(absclockerror > flTSTimeRes)
    {
        //
        // the error must be greater than the clock resolution
        //
        if (!(tasync & TA_DONT) 
                  &&
            (clockerror > 0)
                  &&
            (clockerror < MAXBACKSLEW) )
        { 
            //
            // On NT, check if time needs to be set backwards. If
            // so, we will try doing it using a time adjustment
            // instead of the rude alternative. 
            // The technique is to slow the clock by 1/2 for small
            // errors and by 1/4 for large errors.
            //

                if(clockerror > (15 * 1000))
                {
                    //
                    // large error. Use big stick
                    //

                    b_adj = (adj + 2) / 4;      // round nearest
                    b_time = (clockerror * 4) / 3;  // round down
                }
                else
                {
                    b_adj = (adj + 1) / 2;      // round nearest
                    b_time = clockerror * 2;
                }
                
                if(fStatus)
                {
                     TimePrint("Skewing for backwards, badj, btime = %d %d\n",
                                 b_adj, b_time);
                }
        }
        else
        if (LOCAL)
        {
        //clock is not UTC, so we might notice DST switch at
        // different time than NT does...
            TIME_ZONE_INFORMATION tzi;
            DWORD tzmode;
            int dstflag = 0;
        
            tzmode = GetTimeZoneInformation(&tzi);
            if ((tzmode==TIME_ZONE_ID_DAYLIGHT)||(tzmode==TIME_ZONE_ID_STANDARD)) {//not error or missing
//BUGBUG: we should limit this stuff to dates near the change
                if (((absclockerror+(1000*60*tzi.DaylightBias)) <
                      (24*60*60*1000.0 / (adj*2)))
                           &&
                    !firstpass) {//1st error +1hr (+/-skew)?
#ifdef VERBOSE
if (fStatus)                    
            if (tzmode==TIME_ZONE_ID_DAYLIGHT)
                TimePrint("Suspect reference changed from DST ahead of system\n");
            else
                TimePrint("Suspect reference has not changed to DST yet\n");
#endif                
                    dstflag = -1;
                }
                if (((absclockerror-(1000*60*tzi.DaylightBias))<(24*60*60*1000.0 / (adj*2))) && !firstpass) {//1st error -1hr (+/-skew)?
#ifdef VERBOSE
if(fStatus)
                if (tzmode==TIME_ZONE_ID_STANDARD)
                    TimePrint("Suspect reference changed to DST ahead of system\n");
                else
                    TimePrint("Suspect reference has not changed from DST yet\n");
#endif                  
                    dstflag = +1;
                }
                if (dstflag) {
                    fTimeFailed = TRUE;
                    LogTimeEvent(EVENTLOG_WARNING_TYPE,MSG_DST);//warn 'em
                    clockerror -= dstflag*1000*60*tzi.DaylightBias;//for stats/skew, let's pretend it didn't happen
#ifdef VERBOSE
if (fStatus)                    
            TimePrint("Suspect Error would be %ldms, but we're not setting\n",clockerror);
#endif
                }
            }
    
            if (!fTimeFailed)//check one last time, in case of DST sync problem
            {
                fBeenThere = TRUE;
                if (!SetLocalTime(&nt)) //fyi: this seems to take around 3ms
                    StopTimeService(MSG_SLT_FAILED);
           }
        }   // LOCAL
        else         // it UTC time
        {
            fBeenThere = TRUE;
            if (!SetSystemTime(&nt))  // set the system time 
            {
                StopTimeService(MSG_SST_FAILED);
            }
        }
    }   // clockerror > reslution
    return(clockerror);
}

VOID
SetTSTimeRes(DWORD adj)
{
    //
    // compute the number of ms in a clock tick and derive from
    // that the minimum error which we can apply skew correction
    // to. This latter is computed using ERRORPART whose meaning
    // and value are described in tsconfig.h
    //
    flTSTimeRes = (float)(adj / 10000.0) + (float)0.5;
    lTSTimeRes = ERRORMINIMUM((LONG)flTSTimeRes);
}

VOID
SetAdjInRegistry(
    DWORD adj,
    double * skew   
   )
{
    HKEY hKey;
    CHAR Buffer[100];
    DWORD status;

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 TEXT("SYSTEM\\CurrentControlSet\\Services\\TimeServ\\Parameters"),
                 0,
                 KEY_QUERY_VALUE|KEY_SET_VALUE,
                 &hKey);

    if ( status != ERROR_SUCCESS ) {
        // If we fail, then use default value
        return;
    }

    status = RegSetValueEx(hKey,
                 TEXT("Adj"),
                 0,
                 REG_DWORD,
                 (CONST BYTE *)&adj,
                 sizeof(DWORD));//to allow "sticky"

    if(skew)
    {
        sprintf(Buffer, "%.4f", *skew);

        status = RegSetValueExA(hKey,
                      "msSkewPerDay",
                      0,
                      REG_SZ,
                      (CONST BYTE *)Buffer,
                      strlen(Buffer) + 1);
    }

    RegCloseKey(hKey);
}

VOID
Clearbabs()
{
    if(b_adj)
    {
        SetSystemTimeAdjustment(adj,
                                fAdjForcedOn); 
        SetTSTimeRes(adj);
        b_adj = 0;
    }
}

//
// Control-C handler. This is the handler in effect when time is being
// slewed backwards. If it is called, the assumption is that the
// service is about to be terminated, so all it does is to restore the
// nominal value for the time adjustment and return allowing other
// handlers a chance to do as they please.
//
BOOL
ConsoleHandler(DWORD dwType)
{
    Clearbabs();
    return(FALSE);
}

//
// Compute an actual sleep time given a nominal sleep time. This
// adjusts the sleep time based on the in-force time adjustment
//
LONG
CompensatedTime(LONG lTime)
{
    LONG ldiff = (LONG)incr - (LONG)adj;
    LONG lquot = lTime * ldiff;
    LONG ldelta = (lquot + ((LONG)incr2)) / (LONG)incr;

    return(lTime + ldelta);
}

//
// Set the thread priority as high as we can
//
VOID
TsUpTheThread()
{
    if(
       (!SetThreadPriority(GetCurrentThread(),
                           THREAD_PRIORITY_TIME_CRITICAL))
                   &&
       fStatus)
    {
        TimePrint("Failed to set thread priority %d\n", GetLastError());
    }
}


//
// NT-only version. Faster and more accurate
//
VOID
PutTime(PULONG pTime, ULONG ulIncr)
{
    LARGE_INTEGER liTime;
    DWORD  dwMs;

    //
    // put the current time into the quadword pointed to by the arg
    // The argument points to two consecutive ULONGs in which  the
    // time in seconds goes into the first work and the fractional
    // time in seconds in the second word.


    NtQuerySystemTime(&liTime);
    if(ulIncr)
    {
        liTime.QuadPart += RtlEnlargedIntegerMultiply((LONG)ulIncr,
                                                       10000).QuadPart;
    }

    //
    // Seconds is simply the time difference
    //
    *pTime = htonl((ULONG)((liTime.QuadPart - li1900.QuadPart) / 10000000));

    //
    // Ms is the residue from the seconds calculation.
    //
    dwMs = (DWORD)(((liTime.QuadPart - li1900.QuadPart) % 10000000) / 10000);

//    RtlTimeToSecondsSince1970(&liTime, temptime);

    //
    // time base in the beginning of the year 1900
    //

//    temptime = htonl(temptime+(unsigned long)(365.2422*70*24*60*60+3974.4));

//    RtlTimeToTimeFields(&liTime, &tf);

    *(1 + pTime) = htonl((unsigned long)
                     (.5+0xFFFFFFFF*(double)(dwMs/1000.0)));
    //hmm, would adding half of Incr make us slightly more accurate (consider  rollover)?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\cfilewindow.cpp ===
/*

  CFileWindow.CPP

  File window class

*/

#include "stdafx.h"
#include <commdlg.h>
#include "resource.h"
#include "cfilewindow.h"

#define BUFFER_GROW_SIZE 1024

#define CURSOR_BLINK     1000
#define LEFT_MARGIN_SIZE 40

#define MIN( _arg1, _arg2 ) (( _arg1 < _arg2 ? _arg1 : _arg2 ))
#define MAX( _arg1, _arg2 ) (( _arg1 > _arg2 ? _arg1 : _arg2 ))

#define DUMP_RECT( _rect ) { TCHAR sz[MAX_PATH]; wsprintf( sz, "( L%u, %T%u, R%u, B%u )", _rect.left, _rect.top, _rect.right, _rect.bottom ); OutputDebugString( sz ); }

//#define DEBUG_PAINT

//
// Constructor
//
CFileWindow::CFileWindow( 
    HWND hParent )
{
    TCHAR szTitle[ MAX_PATH ];

    _hParent        = hParent;
    _pszFilename    = NULL;
    _nLength        = 0;
    _pLine          = NULL;

    LoadString( g_hInstance,
                IDS_UNTITLED,
                szTitle,
                sizeof(szTitle)/sizeof(szTitle[0]) );

       _hWnd = CreateWindowEx( WS_EX_ACCEPTFILES,
                               CFILEWINDOWCLASS, 
                               szTitle, 
                               WS_OVERLAPPEDWINDOW 
                               | WS_CLIPSIBLINGS,
                               CW_USEDEFAULT, 
                               0, 
                               CW_USEDEFAULT, 
                               0, 
                               NULL, 
                               NULL,
                               g_hInstance, 
                               (LPVOID) this);
    if (!_hWnd)
    {
        return;
    }

    ShowWindow( _hWnd, SW_NORMAL );
    UpdateWindow( _hWnd );
}

//
// Destructor
//
CFileWindow::~CFileWindow( )
{
	if ( _pszFilename )
		LocalFree( _pszFilename );

    if ( _pLine )
        LocalFree( _pLine );
}

//
// _UpdateTitle( )
//
HRESULT
CFileWindow::_UpdateTitle( )
{
    TCHAR  szTitleBar[ MAX_PATH * 2 ];
    LPTSTR pszTitle;

    if ( _pszFilename )
    {
        pszTitle = strrchr( _pszFilename, TEXT('\\') );
        if ( pszTitle )
        {
            INT   iResult;
            TCHAR ch;
            TCHAR szCWD[ MAX_PATH ];

            GetCurrentDirectory( MAX_PATH, szCWD );

            ch = *pszTitle;                         // save
            *pszTitle = 0;                          // terminate
            iResult = strcmp( szCWD, _pszFilename );// compare
            *pszTitle = ch;                         // restore
            pszTitle++;                             // skip past the slash
            if ( iResult != 0 )
            {
                pszTitle = _pszFilename;
            }
        }
        else
        {
            pszTitle = _pszFilename;
        }

        strcpy( szTitleBar, pszTitle );
    }
    else
    {
        LoadString( g_hInstance,
                    IDS_UNTITLED,
                    szTitleBar,
                    sizeof(szTitleBar)/sizeof(szTitleBar[0]) );
    }

    SetWindowText( _hWnd, szTitleBar );

    return S_OK;
}

//
// SetInformation( )
//
HRESULT
CFileWindow::SetInformation( 
    ULONG nNode,
    LPTSTR pszFilename,
    LINEPOINTER * pLineBuffer, 
    ULONG nLineCount )
{
    SCROLLINFO si;

    if ( pszFilename )
    {
        if ( _pszFilename )
            LocalFree( _pszFilename );

        _pszFilename = pszFilename;
        _UpdateTitle( );
    }

    _nNode = nNode;
    _pLine = pLineBuffer;
    _nLineCount = nLineCount;

    if ( !_fVertSBVisible 
      && _yWindow < (LONG)(_nLineCount * _tm.tmHeight) )
    {
        _fVertSBVisible = TRUE;
        EnableScrollBar( _hWnd, SB_VERT, ESB_ENABLE_BOTH );
        ShowScrollBar( _hWnd, SB_VERT, TRUE );
    }
    else if ( _fVertSBVisible
           && _yWindow >= (LONG)(_nLineCount * _tm.tmHeight) )
    {
        _fVertSBVisible = FALSE;
        //EnableScrollBar( _hWnd, SB_VERT, ESB_ENABLE_BOTH );
        ShowScrollBar( _hWnd, SB_VERT, FALSE );
    }

    si.cbSize = sizeof(si);
    si.fMask  = SIF_RANGE;
    si.nMin   = 0;
    si.nMax   = _nLineCount;
    SetScrollInfo( _hWnd, SB_VERT, &si, TRUE );

    InvalidateRect( _hWnd, NULL, TRUE );

    return S_OK;
}

//
// _OnPaint( )
//
LRESULT
CFileWindow::_OnPaint(
    WPARAM wParam,
    LPARAM lParam )
{
    HDC     hdc;
    TCHAR   szBuf[ 6 ]; // max 5-digits
    LONG    y;
    LONG    wx;         // window coords
    LONG    wy;
    RECT    rect;
    RECT    rectResult;
    SIZE    size;
    LPTSTR  pszStartLine;       // beginning of line (PID/TID)
    LPTSTR  pszStartTimeDate;   // beginning of time/data stamp
    LPTSTR  pszStartComponent;  // beginning of component name
    LPTSTR  pszStartResType;    // beginning of a resource component
    LPTSTR  pszStartText;       // beginning of text
    LPTSTR  pszCurrent;         // current position and beginning of text

    SCROLLINFO  si;
    PAINTSTRUCT ps;

#if 0
#if defined(_DEBUG)
    static DWORD cPaint = 0;
    {
        TCHAR szBuf[ MAX_PATH ];
        wsprintf( szBuf, "%u paint\n", ++cPaint );
        OutputDebugString( szBuf );
    }
#endif
#endif

    si.cbSize = sizeof(si);
    si.fMask  = SIF_POS | SIF_PAGE;
    GetScrollInfo( _hWnd, SB_VERT, &si );

    hdc = BeginPaint( _hWnd, &ps);

    if ( !_pLine )
        goto EndPaint;

    SetBkMode( hdc, OPAQUE );
    SelectObject( hdc, g_hFont );

    y  = si.nPos;

    wy = 0;
    while ( y <= (LONG)(si.nPos + si.nPage) 
         && y < _nLineCount )
    {
        // draw line number
        SetRect( &rect,
                 0,
                 wy,
                 LEFT_MARGIN_SIZE,
                 wy + _tm.tmHeight );
        if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
        {
            //FillRect( hdc, &rect, g_pConfig->GetMarginColor( ) );

            SetBkColor( hdc, GetSysColor( COLOR_GRAYTEXT ) );
            SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );

            DrawText( hdc, 
                      szBuf, 
                      wsprintf( szBuf, TEXT("%05.5u"), y ), 
                      &rect, 
                      DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
        }

        wx = LEFT_MARGIN_SIZE;

        if ( _pLine[ y ].psLine )
        {

//
// KB: This is what a typical cluster log line looks like.
// 3fc.268::1999/07/19-19:14:45.548 [EVT] Node up: 2, new UpNodeSet: 0002
// 3fc.268::1999/07/19-19:14:45.548 [EVT] EvOnline : calling ElfRegisterClusterSvc
// 3fc.268::1999/07/19-19:14:45.548 [GUM] GumSendUpdate: queuing update	type 2 context 19
// 3fc.268::1999/07/19-19:14:45.548 [GUM] GumSendUpdate: Dispatching seq 2585	type 2 context 19 to node 1
// 3fc.268::1999/07/19-19:14:45.548 [NM] Received update to set extended state for node 1 to 0
// 3fc.268::1999/07/19-19:14:45.548 [NM] Issuing event 0.
// 3fc.268::1999/07/19-19:14:45.548 [GUM] GumSendUpdate: completed update seq 2585	type 2 context 19
// 37c.3a0::1999/07/19-19:14:45.548 Physical Disk: AddVolume : \\?\Volume{99d8d508-39fa-11d3-a200-806d6172696f}\ 'C', 7 (11041600)
// 37c.3a0::1999/07/19-19:14:45.558 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d503-39fa-11d3-a200-806d6172696f}), error 170
// 37c.3a0::1999/07/19-19:14:45.568 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d504-39fa-11d3-a200-806d6172696f}), error 170
// 37c.3a0::1999/07/19-19:14:45.568 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d505-39fa-11d3-a200-806d6172696f}), error 170
// 37c.3a0::1999/07/19-19:14:45.578 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d506-39fa-11d3-a200-806d6172696f}), error 170
// 37c.3a0::1999/07/19-19:14:45.578 Physical Disk: AddVolume: GetPartitionInfo(\??\Volume{99d8d501-39fa-11d3-a200-806d6172696f}), error 1
//

            if ( _pLine[ y ].nFile != _nNode )
                goto SkipLine;

            pszStartResType = 
                pszStartComponent = NULL;
            pszStartLine =
                pszStartText = 
                pszStartTimeDate = 
                pszCurrent = _pLine[ y ].psLine;

            // Find the thread and process IDs
            while ( *pszCurrent && *pszCurrent != ':' && *pszCurrent >= 32 )
            {
                pszCurrent++;
            }
            if ( *pszCurrent < 32 )
                goto DrawRestOfLine;

            pszCurrent++;
            if ( *pszCurrent != ':' )
                goto DrawRestOfLine;

            pszCurrent++;

            // Find Time/Date stamp which is:
            // ####/##/##-##:##:##.###<space>
            pszStartTimeDate = pszCurrent;

            while ( *pszCurrent && *pszCurrent != ' ' && *pszCurrent >= 32 )
            {
                pszCurrent++;
            }
            if ( *pszCurrent < 32 )
                goto DrawRestOfLine;

            pszCurrent++;

            pszStartText = pszCurrent;

            // [OPTIONAL] Cluster component which looks like: 
            // [<id...>]
            if ( *pszCurrent == '[' )
            {
                while ( *pszCurrent && *pszCurrent != ']' && *pszCurrent >= 32 )
                {
                    pszCurrent++;
                }
                if ( *pszCurrent < 32 )
                    goto NoComponentTryResouce;

                pszCurrent++;

                pszStartComponent = pszStartText;
                pszStartText = pszCurrent;
            }
            else
            {
                // [OPTIONAL] If not a component, see if there is a res type
NoComponentTryResouce:
                pszCurrent = pszStartText;

                while ( *pszCurrent && *pszCurrent != ':' && *pszCurrent >= 32 )
                {
                    pszCurrent++;
                }

                if ( *pszCurrent >= 32 )
                {
                    pszCurrent++;

                    pszStartResType = pszStartText;
                    pszStartText = pszCurrent;
                }
            }

            if ( pszStartComponent )
            {
                DWORD n = 0;
                LONG nLen = pszStartText - pszStartComponent - 2;
                LPTSTR psz = g_pszFilters;
                while ( n < g_nComponentFilters )
                {
                    if ( g_pfSelectedComponent[ n ] 
                      && ( nLen == lstrlen( psz ) )
                      && ( _strnicmp( pszStartComponent + 1, psz, nLen ) == 0 ) )
                      goto SkipLine;

                    while ( *psz )
                    {
                        psz++;
                    }
                    psz += 2;

                    n++;
                }
            }
#if 0
            if ( pszStartResType )
            {
                if ( !g_fNetworkName 
                  && _strnicmp( pszStartResType, "Network Name", sizeof("Network Name") - 1 ) == 0 )
                    goto SkipLine;
                if ( !g_fGenericService 
                  && _strnicmp( pszStartResType, "Generic Service", sizeof("Generic Service") - 1 ) == 0 )
                    goto SkipLine;
                if ( !g_fPhysicalDisk 
                  && _strnicmp( pszStartResType, "Physical Disk", sizeof("Physical Disk") - 1 ) == 0 )
                    goto SkipLine;
                if ( !g_fIPAddress
                  && _strnicmp( pszStartResType, "IP Address", sizeof("IP Address") - 1 ) == 0 )
                    goto SkipLine;
                if ( !g_fGenericApplication 
                  && _strnicmp( pszStartResType, "Generic Application", sizeof("Generic Application") - 1 ) == 0 )
                    goto SkipLine;
                if ( !g_fFileShare
                  && _strnicmp( pszStartResType, "File Share", sizeof("File Share") - 1 ) == 0 )
                    goto SkipLine;
            }
#endif

            // Draw PID and TID
            GetTextExtentPoint32( hdc, 
                                  pszStartLine, 
                                  pszStartTimeDate - pszStartLine - 2, 
                                  &size );

            SetRect( &rect,
                     wx,
                     wy,
                     wx + size.cx,
                     wy + _tm.tmHeight );

            if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
            {
                SetBkColor( hdc, 0xFF8080 );
                SetTextColor( hdc, 0x000000 );

                DrawText( hdc, 
                          pszStartLine,
                          pszStartTimeDate - pszStartLine - 2, 
                          &rect, 
                          DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
            }

            wx += size.cx;

            GetTextExtentPoint32( hdc, 
                                  "::", 
                                  2, 
                                  &size );

            SetRect( &rect,
                     wx,
                     wy,
                     wx + size.cx,
                     wy + _tm.tmHeight );

            if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
            {
                SetBkColor( hdc, 0xFFFFFF );
                SetTextColor( hdc, 0x000000 );

                DrawText( hdc, 
                          "::",
                          2, 
                          &rect, 
                          DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
            }

            wx += size.cx;

            // Draw Time/Date
            pszCurrent = ( pszStartComponent ? 
                           pszStartComponent :
                           ( pszStartResType ?
                             pszStartResType :
                             pszStartText )
                                 ) - 1;
            GetTextExtentPoint32( hdc, 
                                  pszStartTimeDate, 
                                  pszCurrent - pszStartTimeDate, 
                                  &size );

            SetRect( &rect,
                     wx,
                     wy,
                     wx + size.cx,
                     wy + _tm.tmHeight );

            if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
            {
                SetBkColor( hdc, 0x80FF80 );
                SetTextColor( hdc, 0x000000 );

                DrawText( hdc, 
                          pszStartTimeDate, 
                          pszCurrent - pszStartTimeDate, 
                          &rect, 
                          DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
            }

            wx += size.cx;

            // Draw component
            if ( pszStartComponent )
            {
                GetTextExtentPoint32( hdc, 
                                      pszStartComponent, 
                                      pszStartText - pszStartComponent, 
                                      &size );

                SetRect( &rect,
                         wx,
                         wy,
                         wx + size.cx,
                         wy + _tm.tmHeight );

                if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
                {
                    SetBkColor( hdc, GetSysColor( COLOR_WINDOW )  );
                    SetTextColor( hdc, 0x800000 );

                    DrawText( hdc, 
                              pszStartComponent, 
                              pszStartText - pszStartComponent, 
                              &rect, 
                              DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
                }

                wx += size.cx;
            }

            if ( pszStartResType )
            {
                GetTextExtentPoint32( hdc, 
                                      pszStartResType, 
                                      pszStartText - pszStartResType, 
                                      &size );

                SetRect( &rect,
                         wx,
                         wy,
                         wx + size.cx,
                         wy + _tm.tmHeight );

                if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
                {
                    SetBkColor( hdc, GetSysColor( COLOR_WINDOW )  );
                    SetTextColor( hdc, 0x008000 );

                    DrawText( hdc, 
                              pszStartResType, 
                              pszStartText - pszStartResType, 
                              &rect, 
                              DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
                }

                wx += size.cx;
            }

DrawRestOfLine:
            pszCurrent = pszStartText;

            while ( *pszCurrent && *pszCurrent != 13 )
            {
                pszCurrent++;
            }

            GetTextExtentPoint32( hdc, 
                                  pszStartText, 
                                  pszCurrent - pszStartText, 
                                  &size );

            SetRect( &rect,
                     wx,
                     wy,
                     wx + size.cx,
                     wy + _tm.tmHeight );

            if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
            {
                SetBkColor( hdc, GetSysColor( COLOR_WINDOW )  );
                SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT )  );

                DrawText( hdc, 
                          pszStartText, 
                          pszCurrent - pszStartText, 
                          &rect, 
                          DT_NOCLIP /*| DT_NOPREFIX */ | DT_SINGLELINE );
            }

            wx += size.cx;
        }

SkipLine:
        SetRect( &rect,
                 wx,
                 wy,
                 _xWindow,
                 wy + _tm.tmHeight );
        if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
        {
            HBRUSH hBrush;
            hBrush = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
            FillRect( hdc, &rect, hBrush );
            DeleteObject( hBrush );
        }

        wy += _tm.tmHeight;
        y++;
    }

    SetRect( &rect,
             wx,
             wy,
             _xWindow,
             wy + _tm.tmHeight );
    if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
    {
        HBRUSH hBrush;
        hBrush = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
        FillRect( hdc, &rect, hBrush );
        DeleteObject( hBrush );
    }

    SetRect( &rect,
             0,
             wy + _tm.tmHeight,
             LEFT_MARGIN_SIZE,
             _yWindow );
    if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
    {
        HBRUSH hBrush;
        hBrush = CreateSolidBrush( GetSysColor( COLOR_GRAYTEXT ) );
        FillRect( hdc, &rect, hBrush );
        DeleteObject( hBrush );
    }

    SetRect( &rect,
             LEFT_MARGIN_SIZE,
             wy + _tm.tmHeight,
             _xWindow,
             _yWindow );
    if ( IntersectRect( &rectResult, &ps.rcPaint, &rect ) )
    {
        HBRUSH hBrush;
        hBrush = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
        FillRect( hdc, &rect, hBrush );
        DeleteObject( hBrush );
    }
    
EndPaint:
    EndPaint(_hWnd, &ps);
    return 0;
}

//
// _OnCommand( )
//
LRESULT
CFileWindow::_OnCommand(
    WPARAM wParam,
    LPARAM lParam )
{
    UINT cmd = LOWORD(wParam);
    switch ( cmd )
    {
    // Pass these back up
    case IDM_OPEN_FILE:
        return SendMessage( GetParent( GetParent( _hWnd ) ), WM_COMMAND, IDM_OPEN_FILE, 0 );

    case IDM_NEW_FILE:
        return SendMessage( GetParent( GetParent( _hWnd ) ), WM_COMMAND, IDM_NEW_FILE, 0 );

    default:
        break;
    }
    return DefWindowProc( _hWnd, WM_COMMAND, wParam, lParam);
}


//
// _OnCloseWindow( )
//
LRESULT
CFileWindow::_OnCloseWindow( )
{
    return 0;
}

//
// _OnDestroyWindow( )
//
LRESULT
CFileWindow::_OnDestroyWindow( )
{
    delete this;
    return 0;
}

//
// _OnFocus( )
//
LRESULT
CFileWindow::_OnFocus(
    WPARAM wParam,
    LPARAM lParam )
{
    return 0;
}

//
// _OnKillFocus( )
//
LRESULT
CFileWindow::_OnKillFocus(
    WPARAM wParam,
    LPARAM lParam )
{
    HideCaret( _hWnd );
    DestroyCaret( );
    return 0;
}

//
// _OnTimer( )
//
LRESULT
CFileWindow::_OnTimer(
    WPARAM wParam,
    LPARAM lParam )
{
    OutputDebugString( "Timer!\n" );
    return 0;
}

//
// _OnKeyUp( )
//
BOOL
CFileWindow::_OnKeyUp( 
    WPARAM wParam,
    LPARAM lParam )
{
    return FALSE;
}


//
// _OnVerticalScroll( )
//
LRESULT
CFileWindow::_OnVerticalScroll(
    WPARAM wParam,
    LPARAM lParam )
{
    SCROLLINFO si;

    INT  nScrollCode   = LOWORD(wParam); // scroll bar value 
    INT  nPos;
    //INT  nPos          = HIWORD(wParam); // scroll box position 
    //HWND hwndScrollBar = (HWND) lParam;  // handle to scroll bar

    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    GetScrollInfo( _hWnd, SB_VERT, &si );

    nPos = si.nPos;

    switch( nScrollCode )
    {
    case SB_BOTTOM:
        si.nPos = si.nMax;
        break;

    case SB_THUMBPOSITION:
        si.nPos = nPos;
        break;

    case SB_THUMBTRACK:
        si.nPos = si.nTrackPos;
        break;

    case SB_TOP:
        si.nPos = si.nMin;
        break;

    case SB_LINEDOWN:
        si.nPos += 1;
        break;

    case SB_LINEUP:
        si.nPos -= 1;
        break;

    case SB_PAGEDOWN:
        si.nPos += si.nPage;
        break;

    case SB_PAGEUP:
        si.nPos -= si.nPage;
        break;
    }

    si.fMask = SIF_POS;
    SetScrollInfo( _hWnd, SB_VERT, &si, TRUE );
    GetScrollInfo( _hWnd, SB_VERT, &si );

    if ( si.nPos != nPos )
    {
        ScrollWindowEx( _hWnd, 
                        0, 
                        (nPos - si.nPos) * _tm.tmHeight, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL, 
                        SW_INVALIDATE );
    }

    return 0;
}

//
// _OnCreate( )
//
LRESULT
CFileWindow::_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT pcs )
{
    _hWnd = hwnd;

    SetWindowLong( _hWnd, GWL_USERDATA, (LONG) this );

    _UpdateTitle( );

    return 0;
}


//
// _OnSize( )
//
LRESULT
CFileWindow::_OnSize( 
    LPARAM lParam )
{
    HDC     hdc;
    SIZE    size;
    HGDIOBJ hObj;
    TCHAR   szSpace[ 1 ] = { TEXT(' ') };

    SCROLLINFO si;

    _xWindow = LOWORD( lParam );
    _yWindow = HIWORD( lParam );
    
    hdc   = GetDC( _hWnd );
    hObj  = SelectObject( hdc, g_hFont );
    GetTextMetrics( hdc, &_tm );

    GetTextExtentPoint32( hdc, szSpace, 1, &size );
    _xSpace = size.cx;

    si.cbSize = sizeof(si);
    si.fMask  = SIF_RANGE | SIF_PAGE;
    si.nMin   = 0;
    si.nMax   = _nLineCount;
    si.nPage  = _yWindow / _tm.tmHeight;

    SetScrollInfo( _hWnd, SB_VERT, &si, FALSE );

    // cleanup the HDC
    SelectObject( hdc, hObj );
    ReleaseDC( _hWnd, hdc );

    return 0;
}

//
// _OnMouseWheel( )
//
LRESULT
CFileWindow::_OnMouseWheel( SHORT iDelta )
{
    if ( iDelta > 0 )
    {
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEUP, 0 );
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEUP, 0 );
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEUP, 0 );
    }
    else if ( iDelta < 0 )
    {
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEDOWN, 0 );
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEDOWN, 0 );
        SendMessage( _hWnd, WM_VSCROLL, SB_LINEDOWN, 0 );
    }
    return 0;
}

//
// WndProc( )
//
LRESULT CALLBACK
CFileWindow::WndProc( 
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    CFileWindow * pfw = (CFileWindow *) GetWindowLong( hWnd, GWL_USERDATA );

    if ( pfw != NULL )
    {
        switch( uMsg )
        {
        case WM_COMMAND:
            return pfw->_OnCommand( wParam, lParam );

        case WM_PAINT:
            return pfw->_OnPaint( wParam, lParam );

        case WM_CLOSE:
            return pfw->_OnCloseWindow( );

        case WM_DESTROY:
            SetWindowLong( hWnd, GWL_USERDATA, NULL );
            return pfw->_OnDestroyWindow( );

        case WM_SETFOCUS:
            pfw->_OnFocus( wParam, lParam );
            break;  // don't return!

        case WM_KILLFOCUS:
            return pfw->_OnKillFocus( wParam, lParam );

        case WM_TIMER:
            return pfw->_OnTimer( wParam, lParam );

        case WM_SIZE:
            return pfw->_OnSize( lParam );

        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
            if ( pfw->_OnKeyDown( wParam, lParam ) )
                return 0;
            break; // do default as well

        case WM_KEYUP:
        case WM_SYSKEYUP:
            if ( pfw->_OnKeyUp( wParam, lParam ) )
                return 0;
            break;

        case WM_VSCROLL:
            return pfw->_OnVerticalScroll( wParam, lParam );

        case WM_MOUSEWHEEL:
            return pfw->_OnMouseWheel( HIWORD(wParam) );
        }
    }

    if ( uMsg == WM_CREATE )
    {
        LPCREATESTRUCT pcs = (LPCREATESTRUCT) lParam;
        //LPMDICREATESTRUCT pmdics = (LPMDICREATESTRUCT) pcs->lpCreateParams;
        //pfw = (CFileWindow *) pmdics->lParam;
        pfw = (CFileWindow *) pcs->lpCreateParams;
        return pfw->_OnCreate( hWnd, pcs );
    }

    if ( uMsg == WM_ERASEBKGND )
    {
        RECT    rect;
        RECT    rectWnd;
    
        HDC     hdc = (HDC) wParam;
        HBRUSH  hBrush;
#if defined(DEBUG_PAINT)
        hBrush = CreateSolidBrush( 0xFF00FF );
#else
        hBrush = CreateSolidBrush( GetSysColor( COLOR_GRAYTEXT ) );
#endif

        GetClientRect( hWnd, &rectWnd );
        SetRect( &rect, 
                 0, 
                 0, 
                 LEFT_MARGIN_SIZE, 
                 rectWnd.bottom );
        FillRect( hdc, &rect, hBrush );
        DeleteObject( hBrush );
        
#if defined(DEBUG_PAINT)
        hBrush = CreateSolidBrush( 0xFF00FF );
#else
        hBrush = CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
#endif
        SetRect( &rect, 
                 LEFT_MARGIN_SIZE, 
                 0, 
                 rectWnd.right, 
                 rectWnd.bottom );

        FillRect( hdc, &rect, hBrush );
        DeleteObject( hBrush );

        return TRUE;
    }

    return DefWindowProc( hWnd, uMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\cfinddialog.h ===
//
// CFindDialog.h
//
// Find Dialog Class
//


#ifndef _CFINDDIALOG_H_
#define _CFINDDIALOG_H_

//
// CFindDialog
//
class
CFindDialog
{
private: // data
    HWND _hDlg;
    HWND _hParent;

private: // methods
    static LRESULT CALLBACK 
        DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT
        _OnCommand( WPARAM wParam, LPARAM lParam );
    LRESULT
        _OnInitDialog( HWND hDlg );
    LRESULT
        _OnDestroyWindow( );

public:  // methods
    CFindDialog( HWND hParent );
    ~CFindDialog( );
};

#endif // _CFINDDIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\cluslog.h ===
#if !defined(AFX_SOL_H__9FB3A830_F9D4_11D2_AFC8_0000E8289FA8__INCLUDED_)
#define AFX_SOL_H__9FB3A830_F9D4_11D2_AFC8_0000E8289FA8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"

#endif // !defined(AFX_SOL_H__9FB3A830_F9D4_11D2_AFC8_0000E8289FA8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\cluslog.cpp ===
// sol.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"
#include "CApplicationWindow.h"
#include "CFileWindow.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE        g_hInstance; // current instance

DWORD g_nComponentFilters = 0;
LPTSTR g_pszFilters = NULL;
BOOL *g_pfSelectedComponent = NULL;

BOOL g_fNetworkName  = FALSE;
BOOL g_fGenericService  = FALSE;
BOOL g_fPhysicalDisk  = FALSE;
BOOL g_fIPAddress = FALSE;
BOOL g_fGenericApplication  = FALSE;
BOOL g_fFileShare = FALSE;
BOOL g_fResourceNoise = FALSE;
BOOL g_fShowServerNames = FALSE;

HFONT g_hFont = NULL;
HWND g_hwndFind = NULL;

int APIENTRY 
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;
    CApplicationWindow *pApp;
    LOGFONT logFont;

	// Initialize global strings
    g_hInstance = hInstance; // Store instance handle in our global variable

    // Just the font
    ZeroMemory( &logFont, sizeof(logFont) );
    logFont.lfHeight         = 10;
    logFont.lfWeight         = FW_NORMAL;
    logFont.lfCharSet        = DEFAULT_CHARSET;
    logFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    strcpy( logFont.lfFaceName, TEXT("Courier") );
    g_hFont = CreateFontIndirect( &logFont );
    if ( g_hFont == NULL )
        return GetLastError( );

    pApp = new CApplicationWindow( );
    if ( !pApp ) return -1;

	hAccelTable = LoadAccelerators( hInstance, (LPCTSTR)IDC_SOL );

	// Main message loop:
	while ( GetMessage( &msg, NULL, 0, 0 ) ) 
	{
        if ( !IsDialogMessage( g_hwndFind, &msg ) )
        {
            TranslateMessage( &msg );
    	    DispatchMessage( &msg );
        }
	}

    DeleteObject( g_hFont );

	return (int)msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\cfilewindow.h ===
//
// CFileWindow.H
//
// File window class
//
//



#ifndef _CFILEWINDOW_H_
#define _CFILEWINDOW_H_

//
// Definitions
//
#define CFILEWINDOWCLASS TEXT("CFileWindowClass")

// 
// Functions
//

//
// CFileWindow
//
class
CFileWindow
{
private: // data
    HWND    _hParent;       // parent window handle
    HWND    _hWnd;          // our window handle

    LONG    _nLength;			// current file length
    LONG    _nLineCount;		// number of lines

    BOOL	_fVertSBVisible:1;	// is the vertical scroll bar visible?

    //LPTSTR  _pszEditBuffer;		// edit buffer
    LPTSTR  _pszFilename;		// full filename

    LINEPOINTER *   _pLine;     // Line index

    ULONG   _nNode;             // file/node number

private: // methods
    ~CFileWindow( );
    LRESULT 
        _OnCommand( WPARAM wParam, LPARAM lParam );
    LRESULT
        _OnPaint( WPARAM wParam, LPARAM lParam );
    LRESULT
        _OnDestroyWindow( );
    HRESULT
        _LoadFile( LPTSTR pszFilename );
    LRESULT
        _OnFocus( WPARAM wParam, LPARAM lParam );
    LRESULT
        _OnKillFocus( WPARAM wParam, LPARAM lParam );
    LRESULT
        _OnTimer( WPARAM wParam, LPARAM lParam );
    BOOL
        _OnKeyDown( WPARAM wParam, LPARAM lParam );
    BOOL
        _OnKeyUp( WPARAM wParam, LPARAM lParam );
    HRESULT
        _UpdateTitle( );
    LRESULT
        _OnCloseWindow( );
    LRESULT
        _OnVerticalScroll( WPARAM wParam, LPARAM lParam );
	LRESULT
		_OnCreate( HWND hwnd, LPCREATESTRUCT pcs );
	LRESULT
		_OnSize( LPARAM lParam );
	LRESULT
		_OnMouseWheel( SHORT iDelta );
    HRESULT
        _ParseFile( );
    static DWORD WINAPI
        _ParseFileThread( LPVOID pParams );

public:
    CFileWindow( HWND hParent );
    static LRESULT CALLBACK
        WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    HRESULT
        SetInformation( ULONG nNode, LPTSTR pszFilename, LINEPOINTER * pLineBuffer, ULONG nLineCount );
    HRESULT
        GetWindow( HWND * phWnd )
    {
        *phWnd = _hWnd;
        return S_OK;
    }
};

typedef CFileWindow CFILEWINDOW;
typedef CFileWindow * PCFILEWINDOW, *LPCFILEWINDOW;


#endif // _CFILEWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\cfinddialog.cpp ===
//
// CFindDialog.CPP
//
// Find Dialog Class
//

#include "stdafx.h"
#include "resource.h"
#include "CFindDialog.h"

//
// Ctor
//
CFindDialog::CFindDialog( 
    HWND hParent 
    )
{
    if ( !g_hwndFind )
    {        
        _hParent = hParent;
        _hDlg = CreateDialogParam( g_hInstance, 
                                   MAKEINTRESOURCE( IDD_FIND ), 
                                   _hParent, 
                                   (DLGPROC) CFindDialog::DlgProc,
                                   (LPARAM) this 
                                   );
        g_hwndFind = _hDlg;
    }
}

//
// Dtor
//
CFindDialog::~CFindDialog( )
{
    DestroyWindow( _hDlg );
    g_hwndFind = NULL;
}

//
// _OnCommand( )
//
LRESULT
CFindDialog::_OnCommand( 
    WPARAM wParam, 
    LPARAM lParam )
{
    WORD wId = LOWORD(wParam);

    switch ( wId )
    {
    case IDCANCEL:
        ShowWindow( _hDlg, SW_HIDE );
        return TRUE;

    case IDC_B_MARK_ALL:
    case IDC_B_FIND_NEXT:
        {
            LPTSTR pszSearchString;
            DWORD  dwLen;
            WPARAM wFlags;
            HWND   hwnd;

            wFlags = 0;

            if ( Button_GetCheck( GetDlgItem( _hDlg, IDC_R_UP ) ) == BST_CHECKED )
            {
                wFlags |= FIND_UP;
            }

            if ( Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MATCH_CASE ) ) == BST_CHECKED )
            {
                wFlags |= FIND_MATCHCASE;
            }

            if ( Button_GetCheck( GetDlgItem( _hDlg, IDC_C_MATCH_WHOLE_WORD_ONLY ) ) == BST_CHECKED )
            {
                wFlags |= FIND_WHOLE_WORD;
            }

            hwnd = GetDlgItem( _hDlg, IDC_CB_FIND_WHAT );
            dwLen = Edit_GetTextLength( hwnd ) + 1;
            if ( dwLen )
            {
                pszSearchString = (LPTSTR) LocalAlloc( LMEM_FIXED, dwLen * sizeof(TCHAR) );
                if ( pszSearchString )
                {
                    Edit_GetText( hwnd, pszSearchString, dwLen );
                    if ( wId == IDC_B_MARK_ALL )
                    {
                        PostMessage( _hParent, WM_MARK_ALL, wFlags, (LPARAM) pszSearchString );
                    }
                    else
                    {
                        PostMessage( _hParent, WM_FIND_NEXT, wFlags, (LPARAM) pszSearchString );
                    }

                    hwnd = GetDlgItem( _hDlg, IDC_CB_FIND_WHAT );

                    if ( ComboBox_FindString( hwnd, -1, pszSearchString ) == CB_ERR )
                    {
                        ComboBox_InsertString( hwnd, -1, pszSearchString );
                    }
                }
            }
        }
        return TRUE;
    }

    return 0;
}

//
// _OnInitDialog( )
//
LRESULT
CFindDialog::_OnInitDialog( 
    HWND hDlg
    )
{
    _hDlg = hDlg;

    SetWindowLongPtr( _hDlg, GWLP_USERDATA, (LONG_PTR) this );

    Button_SetCheck( GetDlgItem( _hDlg, IDC_R_DOWN ), BST_CHECKED );

    return 0;
}

//
// _OnDestroyWindow( )
//
LRESULT
CFindDialog::_OnDestroyWindow( )
{
    return 0;
}


//
// DlgProc( )
//
LRESULT
CALLBACK
CFindDialog::DlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam )
{
    CFindDialog * pfd = (CFindDialog *) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( pfd != NULL )
    {
        switch( uMsg )
        {
        case WM_COMMAND:
            return pfd->_OnCommand( wParam, lParam );

        case WM_DESTROY:
            SetWindowLongPtr( hDlg, GWLP_USERDATA, (LONG_PTR)NULL );
            return pfd->_OnDestroyWindow( );

        case WM_SHOWWINDOW:
            if ( wParam )
            {
                SetFocus( GetDlgItem( hDlg, IDC_CB_FIND_WHAT ) );
            }
            break;

        default:
            break; // fall thru
        }

    }

    if ( uMsg == WM_INITDIALOG )
    {
        pfd = (CFindDialog *) lParam;
        return pfd->_OnInitDialog( hDlg );
    }

    return 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	sol.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cluslog.rc
//
#define IDC_MYICON                      2
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDI_CLUSLOG                     106
#define IDI_SMALL                       108
#define IDC_SOL                         109
#define IDD_DIALOG1                     131
#define IDD_HORN_DOCK_BAR               134
#define IDD_FIND                        135
#define IDD_PROCESSING                  136
#define IDC_CS                          1000
#define IDM_NEW_FILE                    1001
#define IDC_B_FIND_NEXT                 1001
#define IDM_CLOSE_FILE                  1002
#define IDC_B_MARK_ALL                  1002
#define IDM_OPEN_FILE                   1003
#define IDS_OPEN_FILE_FILTERS           1004
#define IDC_CB_FIND_WHAT                1004
#define IDS_UNTITLED                    1005
#define IDC_C_MATCH_WHOLE_WORD_ONLY     1005
#define IDC_C_MATCH_CASE                1006
#define IDM_ALL_OFF                     1007
#define ID_EDIT_COPY                    1008
#define IDM_EDIT_COPY                   1008
#define IDC_R_UP                        1008
#define ID_EDIT_FIND                    1009
#define IDM_EDIT_FIND                   1009
#define IDC_R_DOWN                      1009
#define IDC_P_STATUS                    1009
#define IDC_S_FILENAME                  1011
#define IDM_SHOW_REAL_LINENUMBERS       1012
#define IDM_FILE_REFRESH                1013
#define IDM_FILTER_RESOURCENOISE        1014
#define IDM_FILTER_SHOWSERVERNAME       1015
#define IDM_ALL_ON                      2000
#define IDM_FIRST_CS_FILTER             32000
#define IDM_LAST_CS_FILTER              32050
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         1016
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluslog\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#if 0 // turn this on to build in MSDEV
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
#define _WIN32_WINDOWS  0x401
#define WINVER 0x500
#endif

#if DBG == 1
#define _DEBUG
#endif

// Windows Header Files:
#include <windows.h>
#include <windowsx.h>

// C RunTime Header Files
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

extern HINSTANCE g_hInstance;
extern HFONT g_hFont;

extern DWORD g_nComponentFilters;
extern LPTSTR g_pszFilters;
extern BOOL *g_pfSelectedComponent;
extern BOOL g_fNetworkName;
extern BOOL g_fGenericService;
extern BOOL g_fPhysicalDisk;
extern BOOL g_fIPAddress;
extern BOOL g_fGenericApplication;
extern BOOL g_fFileShare;
extern HWND g_hwndFind;
extern BOOL g_fResourceNoise;
extern BOOL g_fShowServerNames;

//
// Defines
//
#define WM_FIND_NEXT WM_USER            // wParam == Flags, lParam == Search String
#define WM_MARK_ALL  WM_USER + 1        // wParam == Flags, lParam == Search String

// Flags for WM_FIND_NEXT and WM_MARK_ALL
#define FIND_UP             0x01
#define FIND_MATCHCASE      0x02
#define FIND_WHOLE_WORD     0x04

//
// CWaitCursor
//
class
CWaitCursor
{
private:
    HCURSOR _hCursor;

public:
    CWaitCursor( ) { _hCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( _hCursor ); };
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluspw\cluspw.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cluspw.h

Abstract:

    header file for cluster password utility

Author:

    Charlie Wickham (charlwi) 26-Jul-1999

Environment:

    User Mode

Revision History:

--*/

//
// general defines
//

#define TrueOrFalse( arg )  (( arg ) ? "TRUE" : "FALSE")

#define CLUSPW_DISPLAY_NAME         L"Cluster Password Utility"
#define CLUSPW_SERVICE_NAME         L"cluspass"
#define CLUWPW_SERVICE_BINARY_NAME  L"cluspwsvc.exe"
//
// used to indicate severity of output msgs
//

typedef enum _MSG_SEVERITY {
    MsgSeverityFatal = 1,
    MsgSeverityInfo,
    MsgSeverityVerbose
} MSG_SEVERITY;

//
// msgs sent back by clients to inform us of final status
//

#define MAX_PIPE_MSG    512

typedef enum _MSG_TYPE {
    MsgTypeFinalStatus = 1,
    MsgTypeString
} MSG_TYPE;

typedef struct _PIPE_RESULT_MSG {
    MSG_TYPE        MsgType;
    DWORD           Status;
    WCHAR           NodeName[ MAX_COMPUTERNAME_LENGTH ];
    MSG_SEVERITY    Severity;
    CHAR            MsgBuf[ MAX_PIPE_MSG ];
} PIPE_RESULT_MSG, *PPIPE_RESULT_MSG;

//
// global defs
//

extern WCHAR               NodeName[ MAX_COMPUTERNAME_LENGTH + 1 ];
extern LPWSTR      ResultPipeName;
extern HANDLE              PipeHandle;
extern LPWSTR              UserName;
extern LPWSTR              DomainName;
extern LPWSTR      NewPassword;

//
// func protos
//

VOID
PrintMsg(
    MSG_SEVERITY Severity,
    LPSTR FormatString,
    ...
    );

DWORD
ChangeCachedPassword(
    IN LPWSTR AccountName,
    IN LPWSTR DomainName,
    IN LPWSTR NewPassword
    );

VOID
ServiceStartup(
    VOID
    );

DWORD
ParseArgs(
    INT argc,
    WCHAR *argv[]
    );

/* end cluspw.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluspw\service.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.c

Abstract:

    part of app that runs as an NT service.

Author:

    Charlie Wickham (charlwi) 03-Oct-1999

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#define LOG_CURRENT_MODULE  LOG_MODULE_CLUSPW

#include <windows.h>
#include <winsvc.h>
#include <stdio.h>

#include "clusrtl.h"
#include "cluspw.h"

/* External */

/* Static */

SERVICE_STATUS  ServiceStatus = {
                    SERVICE_WIN32_OWN_PROCESS, // dwServiceType
                    SERVICE_RUNNING,           // dwCurrentState
                    0,                         // dwControlsAccepted
                    ERROR_SUCCESS,             // dwWin32ExitCode
                    ERROR_SUCCESS,             // dwServiceSpecificExitCode
                    1,                         // dwCheckPoint
                    30000                      // dwWaitHint - 30 seconds
};

/* Forward */
/* End Forward */

VOID
DbgPrint(
    PCHAR FormatString,
    ...
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    CHAR    szOutBuffer[1024];
    va_list argList;

    va_start( argList, FormatString );

    FormatMessageA(FORMAT_MESSAGE_FROM_STRING,
                   FormatString,
                   0,
                   0,
                   szOutBuffer,
                   sizeof(szOutBuffer) / sizeof(szOutBuffer[0]),
                   &argList);

    va_end( argList );

    OutputDebugStringA( szOutBuffer );
}

VOID WINAPI
ControlHandler(
    DWORD fdwControl   // requested control code
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DbgPrint("Received service control %1!08X!\n", fdwControl);
    return;
}

VOID WINAPI
ServiceMain(
    DWORD  argc,
    LPTSTR argv[]
    )
{
    PIPE_RESULT_MSG resultMsg;
    DWORD           nodeNameSize = sizeof( NodeName );
    BOOL            success;
    DWORD           bytesWritten;
    WCHAR           cluspwFile[ MAX_PATH ];
    DWORD           byteCount;
    DWORD           status;
    SERVICE_STATUS_HANDLE   statusHandle;

    //
    // Initialize service to receive service requests by registering the
    // control handler.
    //
    statusHandle = RegisterServiceCtrlHandler( CLUSPW_SERVICE_NAME, ControlHandler );
    if ( statusHandle == NULL ) {
        status = GetLastError();
        DbgPrint("can't get service status handle - %1!u!\n", status);
        return;
    }

    SetServiceStatus(statusHandle, &ServiceStatus);

    //
    // parse the args used to start the service
    //
    status = ParseArgs( argc, argv );
    if ( status != ERROR_SUCCESS ) {
        DbgPrint("ParseArgs failed - %1!d!\n", status);
        goto cleanup;
    }

    //
    // get the node name to stuff in each result msg
    //
#if (_WIN32_WINNT > 0x04FF)
    success = GetComputerNameEx(ComputerNamePhysicalNetBIOS,
                                NodeName,
                                &nodeNameSize);
#else
    success = GetComputerName( NodeName, &nodeNameSize );
#endif
    if ( !success ) {
        status = GetLastError();
        DbgPrint("GetComputerName failed - %1!d!\n", status );
        status = ERROR_SUCCESS;
    }

    DbgPrint( "Opening pipe %1!ws!\n", ResultPipeName );

    //
    // open the named pipe on which to write msgs and final result
    //
    success = WaitNamedPipe( ResultPipeName, NMPWAIT_WAIT_FOREVER );
    if ( success ) {
        PipeHandle = CreateFile(ResultPipeName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL);
        if ( PipeHandle == INVALID_HANDLE_VALUE ) {
            status = GetLastError();
            DbgPrint("CreateFile on result pipe failed - %1!d!\n", status );
        }
    }
    else {
        status = GetLastError();
        DbgPrint("WaitNamedPipe on result pipe failed - %1!d!\n", status );
        goto cleanup;
    }

    //
    // update the password cache
    //
    wcscpy( resultMsg.NodeName, NodeName );
    resultMsg.MsgType = MsgTypeFinalStatus;
    resultMsg.Status = ChangeCachedPassword(UserName,
                                            DomainName,
                                            NewPassword);

    if ( resultMsg.Status == ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
                      "[CPW] Cluster service account password successfully updated.\n");
        CL_LOGCLUSINFO( SERVICE_PASSWORD_CHANGE_SUCCESS );
    } else {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPW] Cluster service account password update failed - %u.\n",
                      status);

        ClusterLogEvent0(LOG_CRITICAL,
                         LOG_CURRENT_MODULE,
                         __FILE__,
                         __LINE__,
                         SERVICE_PASSWORD_CHANGE_FAILED,
                         sizeof( resultMsg.Status ),
                         (PVOID)&resultMsg.Status);
    }

    DbgPrint("Final Result: %1!d!\n", resultMsg.Status );

    success = WriteFile(PipeHandle,
                        &resultMsg,
                        sizeof( resultMsg ),
                        &bytesWritten,
                        NULL);
    if ( !success ) {
        DbgPrint("WriteFile failed in wmain - %1!d!\n", GetLastError() );
        DbgPrint("final status: %1!d!\n", resultMsg.Status);
    }

    CloseHandle( PipeHandle );

    //
    // let SCM know we're shutting down
    //
cleanup:
    ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ServiceStatus.dwWin32ExitCode = status;
    SetServiceStatus(statusHandle, &ServiceStatus);

} // ServiceMain

VOID
ServiceStartup(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    SERVICE_TABLE_ENTRY dispatchTable[] = {
        { CLUSPW_SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain },
        { NULL, NULL }
    };
    DWORD   status;
    DWORD   logLevel = 0;

    status = ClRtlInitialize( FALSE, &logLevel );
    if ( status != ERROR_SUCCESS ) {
        DbgPrint("Couldn't initialize cluster RTL - %d\n", status );
    } else {
        ClRtlLogPrint(LOG_NOISE,
                      "[CPW] Initiating cluster service account password update\n");
    }

    CL_LOGCLUSINFO( SERVICE_PASSWORD_CHANGE_INITIATED );

    //
    // this part runs on the cluster nodes; validate that we're really
    // running in the correct environment
    //
#if 0
    byteCount = GetModuleFileName( NULL, cluspwFile, sizeof( cluspwFile ));
    if ( wcsstr( cluspwFile, L"admin$" ) == NULL ) {
        DbgPrint("-z is not a valid option\n");
        return ERROR_INVALID_PARAMETER;
    }
#endif

    if ( !StartServiceCtrlDispatcher(dispatchTable)) {
        status = GetLastError();
        DbgPrint("StartServiceCtrlDispatcher failed - %1!d!\n", status);
    }

} // ServiceMain

/* end service.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluspw\cluspw.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cluspw.c

Abstract:

    cluster password utility. Co-ordinates changing the cluster service domain
    account password on all nodes in the cluster and updating the LSA's local
    password cache

    This implementation currently assumes that the domain of the service
    account and the cluster node's domain are the same (which is bad). If the
    two domains are different, this will affect whether the secure channel is
    reset (no point in resetting the channel if the password domain is
    different from the machine domain). This configuration increases the risk
    of the cluster falling apart since we're dependent upon the secure channel
    of node's DC to be pointed at the PDC of the account domain which seems
    pretty unlikely.

    In order to make this work reliably, we have to force replication of the
    password to eliminate the race between password replication and netlogon
    resetting the secure channel to a DC that doesn't have the updated
    password. Using kerberos for intra-cluster comm would help in this
    respect.

Author:

    Charlie Wickham (charlwi) 22-Jul-1999

Environment:

    User mode

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#define CMDWINDOW

#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <windns.h>
#include <stdio.h>
#include <stdlib.h>

#if (_WIN32_WINNT > 0x4FF)
#include <dsgetdc.h>
#endif

#include <clusapi.h>
#include <resapi.h>

#include "cluspw.h"

//
// struct for each node in the cluster.
//

typedef struct _CLUSTER_NODE_DATA {
    struct  _CLUSTER_NODE_DATA *    NextNode;
    WCHAR                           NodeName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    HNODE                           NodeHandle;
    CLUSTER_NODE_STATE              NodeState;
    SC_HANDLE                       ClussvcHandle;  // handle to SCM clussvc entry on this node
    SC_HANDLE                       PasswordHandle; // handle to password utility service
    DWORD                           ServiceState;
} CLUSTER_NODE_DATA, *PCLUSTER_NODE_DATA;

#if 0
//
// used to build property lists for setting group and resource command and
// private properties
//

typedef struct _FAILOVER_PARAMBLOCK {
    DWORD  FailoverThresholdValue;
}
FAILOVER_PARAMBLOCK, *PFAILOVER_PARAMBLOCK;

typedef struct _RESOURCE_COMMONPROPS {
    DWORD RestartAction;
} RESOURCE_COMMONPROPS, *PRESOURCE_COMMONPROPS;

typedef struct _RESOURCE_PRIVATEPROPS {
    LPWSTR  CommandLine;
    LPWSTR  CurrentDirectory;
    DWORD   InteractWithDesktop;
} RESOURCE_PRIVATEPROPS, *PRESOURCE_PRIVATEPROPS;
#endif

PCHAR ClusterNodeState[] = {
    "Up",
    "Down",
    "Paused",
    "Joining"
};

/* Globals */

HCLUSTER            ClusterHandle;
PCLUSTER_NODE_DATA  NodeList;
LPWSTR              DomainName;
LPWSTR              UserName;
HGROUP              PWGroup;            // cluster password group
HRESOURCE           PWResource;         // cluster password resource
WCHAR               NodeName[ MAX_COMPUTERNAME_LENGTH + 1 ];
HANDLE              PipeHandle;

//
// cmd line args
//
BOOL        AttemptRecovery;
BOOL        Unattended;
DWORD       StartingPhase = 1;
BOOL        QuietOutput;
BOOL        VerboseOutput;
BOOL        RefreshCache;
LPWSTR      NewPassword;
LPWSTR      OldPassword;
LPWSTR      ClusterName;
BOOL        RunInCmdWindow;
LPWSTR      ResultPipeName;



VOID
PrintMsg(
    MSG_SEVERITY Severity,
    LPSTR FormatString,
    ...
    )

/*++

Routine Description:

    print out the message based on the serverity of the error and the setting
    of QuietOutput

Arguments:

    Severity - indicates importance level of msg

    FormatMessage - pointer to ANSI format string

    other args as appropriate

Return Value:

    None

--*/

{
    PIPE_RESULT_MSG resultMsg;
    va_list         ArgList;
    
    va_start(ArgList, FormatString);

    switch ( Severity ) {
    case MsgSeverityFatal:
        _vsnprintf( resultMsg.MsgBuf, sizeof( resultMsg.MsgBuf ), FormatString, ArgList );
        break;

    case MsgSeverityInfo:
        if ( !QuietOutput ) {
            _vsnprintf( resultMsg.MsgBuf, sizeof( resultMsg.MsgBuf ), FormatString, ArgList );
        }
        else {
            resultMsg.MsgBuf[0] = 0;
        }
        break;

    case MsgSeverityVerbose:
        if ( !QuietOutput && VerboseOutput ) {
            _vsnprintf( resultMsg.MsgBuf, sizeof( resultMsg.MsgBuf ), FormatString, ArgList );
        }
        else {
            resultMsg.MsgBuf[0] = 0;
        }
        break;
    }        

    va_end(ArgList);

    if ( resultMsg.MsgBuf[0] != 0 ) {
        if ( RefreshCache && PipeHandle != INVALID_HANDLE_VALUE ) {
            BOOL    success;
            DWORD   bytesWritten;
            DWORD   status;

            resultMsg.MsgType = MsgTypeString;
            resultMsg.Severity = Severity;
            wcscpy( resultMsg.NodeName, NodeName );


            success = WriteFile(PipeHandle,
                                &resultMsg,
                                sizeof( resultMsg ),
                                &bytesWritten,
                                NULL);
            if ( !success ) {
                status = GetLastError();
                printf("WriteFile failed in PrintMsg - %d\n", status );
                printf("%s\n", resultMsg.MsgBuf );
            }

            if ( RunInCmdWindow ) {
                printf( resultMsg.MsgBuf );
            }
        }
        else {
            printf( resultMsg.MsgBuf );
        }
    }
} // PrintMsg

DWORD
RefreshPasswordCaches(
    VOID
    )

/*++

Routine Description:

    Start the password service on each node

Arguments:

    None

Return Value:

    None

--*/

{
    PCLUSTER_NODE_DATA      nodeData;
    BOOL                    success;
    DWORD                   status = ERROR_SUCCESS;
    WCHAR                   resultPipeName[ MAX_PATH ] = L"\\\\";
    DWORD                   pipeNameSize = (sizeof(resultPipeName) / sizeof( WCHAR )) - 2;
    DWORD                   argCount;
    LPWSTR                  argVector[ 6 ];
    SERVICE_STATUS_PROCESS  serviceStatus;
    DWORD                   bytesNeeded;
    BOOL                    continueToPoll;

    //
    // get our physical netbios name to include on the cmd line arg
    //
#if (_WIN32_WINNT > 0x4FF)
    success = GetComputerNameEx(ComputerNamePhysicalNetBIOS,
                                &resultPipeName[2],
                                &pipeNameSize);
#else
    success = GetComputerName( &resultPipeName[2], &pipeNameSize);
#endif

    wcscat( resultPipeName, L"\\pipe\\cluspw" );

    //
    // loop through the cluster nodes
    //
    nodeData = NodeList;
    while ( nodeData != NULL ) {
        if ( nodeData->NodeState == ClusterNodeUp ) {

            PrintMsg(MsgSeverityVerbose,
                     "Starting password service on node %ws\n",
                     nodeData->NodeName);

            argCount = 0;                         
            if ( VerboseOutput ) {
                argVector[ argCount++ ] = L"-v";
            }
            argVector[ argCount++ ] = L"-z";
            argVector[ argCount++ ] = DomainName;
            argVector[ argCount++ ] = UserName;
            argVector[ argCount++ ] = NewPassword;
            argVector[ argCount++ ] = resultPipeName;

            success = StartService(nodeData->PasswordHandle,
                                   argCount,
                                   argVector);

            if ( !success ) {
                PrintMsg(MsgSeverityInfo,
                         "Failed to start password service on node %ws - %d\n",
                         nodeData->NodeName,
                         GetLastError());
            }

            nodeData->ServiceState = SERVICE_START_PENDING;
        }
        nodeData = nodeData->NextNode;
    }

#if 0
    // this code is of dubious use since we get back access denied on the
    // QuerySeviceStatusEx calls. This would follow since the password utility
    // has probably already updated the caches, potentially invalidating the
    // credentials we're using to run the client portion of the utility.
    //
    // periodically poll the node list, waiting for each service invocation to
    // finish
    do {
        Sleep( 1000 );
        nodeData = NodeList;
        continueToPoll = FALSE;

        while ( nodeData != NULL ) {
            if ( nodeData->NodeState == ClusterNodeUp && nodeData->ServiceState != SERVICE_STOPPED ) {
                if ( QueryServiceStatusEx(nodeData->PasswordHandle,
                                          SC_STATUS_PROCESS_INFO,
                                          (LPBYTE)&serviceStatus, 
                                          sizeof(serviceStatus),
                                          &bytesNeeded ) )
                {
                    PrintMsg(MsgSeverityInfo,
                             "Password service state on %ws is %u\n",
                             nodeData->NodeName,
                             serviceStatus.dwCurrentState);

                    nodeData->ServiceState = serviceStatus.dwCurrentState;
                    if ( serviceStatus.dwCurrentState != SERVICE_STOPPED ) {
                        continueToPoll = TRUE;
                    }
                } else {
                    status = GetLastError();

                    PrintMsg(MsgSeverityInfo,
                             "Query Service Status failed for node %ws - %u.\n",
                             nodeData->NodeName,
                             status );
                }
            }
            nodeData = nodeData->NextNode;
        }
    } while ( continueToPoll );
#endif

    return status;
} // RefreshPasswordCaches

DWORD
ChangePasswordWithSCMs(
    VOID
    )

/*++

Routine Description:

    Change the password with each SCM

Arguments:

    None

Return Value:

    None

--*/

{
    PCLUSTER_NODE_DATA nodeData;
    BOOL success;
    DWORD status = ERROR_SUCCESS;

    nodeData = NodeList;
    while ( nodeData != NULL ) {
        PrintMsg(MsgSeverityVerbose,
                 "Changing SCM password on node %ws\n",
                 nodeData->NodeName);

        success = ChangeServiceConfig(nodeData->ClussvcHandle,
                                      SERVICE_NO_CHANGE,
                                      SERVICE_NO_CHANGE,
                                      SERVICE_NO_CHANGE,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NewPassword,
                                      NULL);

        if ( !success ) {
            status = GetLastError();
            PrintMsg(MsgSeverityFatal,
                     "Problem changing password with node %ws's service controller. error %d\n",
                     nodeData->NodeName, status);
            break;
        }

        nodeData = nodeData->NextNode;
    }

    return status;
} // ChangePasswordWithSCMs

#if 0
DWORD
CreatePasswordGroup(
    VOID
    )

/*++

Routine Description:

    Create a new group with a generic app resource to run cluspw on each node.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if all went ok

--*/

{
    DWORD status;
    FAILOVER_PARAMBLOCK failoverBlock;
    RESUTIL_PROPERTY_ITEM failoverPropTable[] = {
        { L"FailoverThreshold", NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, 0,
           FIELD_OFFSET( FAILOVER_PARAMBLOCK, FailoverThresholdValue ) },
        { 0 }
    };
    DWORD bytesReturned;
    DWORD bytesRequired;

    PWGroup = CreateClusterGroup( ClusterHandle, PASSWORD_GROUP_NAME );
    if ( PWGroup == NULL && GetLastError() == ERROR_OBJECT_ALREADY_EXISTS ) {
        //
        // try to open the existing group
        //
        PrintMsg(MsgSeverityVerbose, "Opening existing pw group\n");
        PWGroup = OpenClusterGroup( ClusterHandle, PASSWORD_GROUP_NAME );
    }

    if ( PWGroup != NULL ) {
        PVOID failoverPropList = NULL;
        DWORD failoverPropListSize = 0;

        //
        // set failover threshold to zero. first call gets size needed to hold
        // prop list
        //
        failoverBlock.FailoverThresholdValue = 0;
        status = ResUtilPropertyListFromParameterBlock(failoverPropTable,
                                                       NULL,
                                                       &failoverPropListSize,
                                                       (LPBYTE) &failoverBlock,
                                                       &bytesReturned,
                                                       &bytesRequired );

        if ( status == ERROR_MORE_DATA ) {
            failoverPropListSize = bytesRequired;
            failoverPropList = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, failoverPropListSize );

            status = ResUtilPropertyListFromParameterBlock(failoverPropTable,
                                                           failoverPropList,
                                                           &failoverPropListSize,
                                                           (LPBYTE) &failoverBlock,
                                                           &bytesReturned,
                                                           &bytesRequired );

            if ( status != ERROR_SUCCESS ) {
                PrintMsg(MsgSeverityFatal,
                         "Couldn't create property list to set Failover Threshold. error %d\n",
                         status);
                return status;
            }
        }
        else if ( status != ERROR_SUCCESS ) {
            PrintMsg(MsgSeverityFatal,
                     "Couldn't determine size of property list for Failover Threshold. error %d\n",
                     status);
            return status;
        }

        PrintMsg(MsgSeverityVerbose, "Setting FailoverThreshold property\n");

        status = ClusterGroupControl(PWGroup,
                                     NULL,
                                     CLUSCTL_GROUP_SET_COMMON_PROPERTIES,
                                     failoverPropList,
                                     failoverPropListSize,
                                     NULL,
                                     0,
                                     NULL);
        HeapFree( GetProcessHeap(), 0, failoverPropList );
 
        if ( status == ERROR_SUCCESS ) {

            //
            // now create the generic app resource in the group
            //
            PWResource = CreateClusterResource(PWGroup,
                                               PASSWORD_RESOURCE_NAME,
                                               L"Generic Application",
                                               0);
            if ( PWResource == NULL && GetLastError() == ERROR_OBJECT_ALREADY_EXISTS ) {
                PrintMsg(MsgSeverityVerbose, "Opening existing pw resource\n");
                         
                PWResource = OpenClusterResource(ClusterHandle,
                                                 PASSWORD_RESOURCE_NAME);
            }

            if ( PWResource != NULL ) {
                RESOURCE_COMMONPROPS commonProps;
                RESUTIL_PROPERTY_ITEM commonPropTable[] = {
                    { L"RestartAction", NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, 0,
                      FIELD_OFFSET( RESOURCE_COMMONPROPS, RestartAction ) },
                    { 0 }
                };
                PVOID propList = NULL;
                DWORD propListSize = 0;

                //
                // set the common props
                //
                commonProps.RestartAction = ClusterResourceDontRestart;
                status = ResUtilPropertyListFromParameterBlock(commonPropTable,
                                                               NULL,
                                                               &propListSize,
                                                               (LPBYTE) &commonProps,
                                                               &bytesReturned,
                                                               &bytesRequired );

                if ( status == ERROR_MORE_DATA ) {
                    propList = HeapAlloc( GetProcessHeap(), 0, bytesRequired );
                    propListSize = bytesRequired;

                    status = ResUtilPropertyListFromParameterBlock(commonPropTable,
                                                                   propList,
                                                                   &propListSize,
                                                                   (LPBYTE) &commonProps,
                                                                   &bytesReturned,
                                                                   &bytesRequired );
                    if ( status != ERROR_SUCCESS ) {
                        PrintMsg(MsgSeverityFatal,
                                 "Couldn't create property list to set Restart Action. error %d\n",
                                 status);
                        return status;
                    }
                }
                else if ( status != ERROR_SUCCESS ) {
                    PrintMsg(MsgSeverityFatal,
                             "Couldn't determine size of property list for Restart Action. error %d\n",
                             status);
                    return status;
                }

                PrintMsg(MsgSeverityVerbose, "Setting RestartAction property\n");

                status = ClusterResourceControl(PWResource,
                                                NULL,
                                                CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES,
                                                propList,
                                                propListSize,
                                                NULL,
                                                0,
                                                NULL);
                HeapFree( GetProcessHeap(), 0, propList );
            }
            else {
                status = GetLastError();
                PrintMsg(MsgSeverityFatal,
                         "Couldn't create Generic Application resource for "
                         "password utility. error %d\n",
                         status);
            }
        }
        else {
            PrintMsg(MsgSeverityFatal,
                     "Couldn't set failover threshold for password group. error %d\n",
                     status);
        }
    }
    else {
        status = GetLastError();
        PrintMsg(MsgSeverityFatal,
                 "Couldn't create group for password utility. error %d\n",
                 status);
    }

    return status;
} // CreatePasswordGroup
#endif

DWORD
CopyNodeApplication(
    VOID
    )

/*++

Routine Description:

    for each node that has a valid SCM handle, copy the password cache update
    program to \\node\admin$\cluster. This corresponds to the node's area
    represented by the SystemRoot env. var.

Arguments:

    None

Return Value:

    None

--*/

{
    PCLUSTER_NODE_DATA nodeData;
    WCHAR destFile[ MAX_PATH ];
    WCHAR cluspwFile[ MAX_PATH ];
    BOOL success;
    DWORD status = ERROR_SUCCESS;
    DWORD byteCount;

    PrintMsg(MsgSeverityInfo, "Copying cache refresh utility to cluster nodes\n");

    byteCount = GetModuleFileName( NULL, cluspwFile, sizeof( cluspwFile ));
    if ( byteCount == 0 ) {
        PrintMsg(MsgSeverityFatal, "Unable to determine cluspw's file path\n");
        return ERROR_FILE_NOT_FOUND;
    }

    nodeData = NodeList;
    while ( nodeData != NULL ) {
        if ( nodeData->NodeState == ClusterNodeUp ) {
            wsprintf( destFile, L"\\\\%ws\\admin$\\" CLUWPW_SERVICE_BINARY_NAME, nodeData->NodeName );
            PrintMsg(MsgSeverityVerbose, "Copying %ws to %ws\n", cluspwFile, destFile);
            success = CopyFile( cluspwFile, destFile, FALSE );
            if ( !success ) {
                status = GetLastError();
                PrintMsg(MsgSeverityFatal,
                         "Problem copying %ws to %ws. error %d\n",
                         cluspwFile, destFile, status);
                break;
            }
        }

        nodeData = nodeData->NextNode;
    }

    return status;
} // CopyNodeApplication

DWORD
CheckDCAvailability(
    VOID
    )

/*++

Routine Description:

    using DomainName, try to contact the DC to make sure the password change
    can happen

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything worked

--*/

{
    DWORD                   status;
    PCLUSTER_NODE_DATA      nodeData;
#if (_WIN32_WINNT > 0x4FF)
    PDOMAIN_CONTROLLER_INFO domainInfo;
#else
    PBYTE                   pdcName;
#endif
    WCHAR                   secureChannel[ MAX_PATH ];
    PWSTR                   newSecureChannel = secureChannel;
    DWORD                   pdcNameLength;
    DWORD                   scNameLength;
    DWORD                   nameLength;

    PrintMsg(MsgSeverityInfo, "Checking on Domain controller availability\n");

#if (_WIN32_WINNT > 0x4FF)
    PrintMsg(MsgSeverityVerbose,
             "Calling DsGetDcName for domain %ws\n",
             DomainName);

    //
    // get the PDC for this domain. The password change is handled by this node.
    //
    status = DsGetDcName(NULL,
                         DomainName,
                         NULL,              // no guid
                         NULL,              // no sitename
                         DS_PDC_REQUIRED | DS_IS_FLAT_NAME,
                         &domainInfo);

    if ( status == ERROR_NO_SUCH_DOMAIN ) {

        PrintMsg(MsgSeverityVerbose,
                 "Calling DsGetDcName again with force rediscovery\n");

        //
        // try again this time specifying the rediscovery flag.
        //
        status = DsGetDcName(NULL,
                             DomainName,
                             NULL,              // no guid
                             NULL,              // no sitename
                             DS_FORCE_REDISCOVERY | DS_PDC_REQUIRED | DS_IS_FLAT_NAME,
                             &domainInfo);
    }
#else
    PrintMsg(MsgSeverityVerbose,
             "Calling NetGetDCName for domain %ws on node %ws\n",
             DomainName, nodeData->NodeName);

    status = NetGetDCName(NodeList->NodeName,
                          DomainName,
                          &pdcName);
#endif

    if ( status != ERROR_SUCCESS ) {
        PrintMsg(MsgSeverityFatal,
                 "Trouble contacting domain controller for %ws. error %d\n",
                 DomainName, status);
    }

    //
    // change the secure channels of the cluster nodes to point to the PDC.
    //
    secureChannel[0] = UNICODE_NULL;
    wcscpy( secureChannel, DomainName );
    wcscat( secureChannel, L"\\" );
    wcscat( secureChannel, &domainInfo->DomainControllerName[2] );
    wcscat( secureChannel, L"." );
    wcscat( secureChannel, domainInfo->DnsForestName );
    pdcNameLength = wcslen( &domainInfo->DomainControllerName[2] ) +
        sizeof( L'.') +
        wcslen( domainInfo->DnsForestName );

    nodeData = NodeList;
    while ( nodeData != NULL ) {
        PNETLOGON_INFO_2    netlogonInfo2;

        //
        // query for the secure channel
        //
        status = I_NetLogonControl2(nodeData->NodeName,
                                    NETLOGON_CONTROL_TC_QUERY,
                                    2,
                                    (LPBYTE)&DomainName,
                                    (LPBYTE *)&netlogonInfo2 );

        if ( status != ERROR_SUCCESS ) {
            PrintMsg(MsgSeverityFatal,
                     "Couldn't query for secure channel. error %u\n",
                     status);
            break;
        }

        scNameLength = wcslen( netlogonInfo2->netlog2_trusted_dc_name );
        nameLength = scNameLength <= pdcNameLength ? scNameLength : pdcNameLength;

        if ( _wcsnicmp(domainInfo->DomainControllerName,
                       netlogonInfo2->netlog2_trusted_dc_name,
                       nameLength) != 0 )
            {

                PrintMsg(MsgSeverityInfo,
                         "Changing secure channel for node %ws from %ws to %ws\n",
                         nodeData->NodeName,
                         netlogonInfo2->netlog2_trusted_dc_name,
                         domainInfo->DomainControllerName);
        
                status = I_NetLogonControl2(nodeData->NodeName,
                                            NETLOGON_CONTROL_REDISCOVER,
                                            2,
                                            (LPBYTE)&newSecureChannel,
                                            (LPBYTE *)&netlogonInfo2 );

                if ( status != ERROR_SUCCESS ) {
                    PrintMsg(MsgSeverityFatal,
                             "Couldn't set secure channel to %ws. error %u\n",
                             newSecureChannel, status);
                    break;
                }
            }
        nodeData = nodeData->NextNode;
    }

#if (_WIN32_WINNT > 0x4FF)
    NetApiBufferFree( domainInfo );
#else
    NetApiBufferFree( pdcName );
#endif

    return status;
} // CheckDCAvailability

DWORD
GetClusterServiceData(
    LPWSTR              NodeName,
    PCLUSTER_NODE_DATA  NodeData
    )

/*++

Routine Description:

    Get a handle the SCM on the specified node and look up the cluster service
    account info if we don't have it already

Arguments:

    NodeName - node to connect to

    NodeData - database entry for this node

Return Value:

    ERROR_SUCCESS if ok

--*/

{
    SC_HANDLE   scmHandle;
    DWORD       status = ERROR_SUCCESS;

    //
    // get a handle to the SCM on this node
    //
    scmHandle = OpenSCManager( NodeName, NULL, GENERIC_WRITE );
    if ( scmHandle != NULL ) {
        SC_HANDLE svcHandle;

        PrintMsg(MsgSeverityVerbose, "    got SCM Handle\n");

        //
        // get the domain of the cluster service account
        //
        NodeData->ClussvcHandle = OpenService(scmHandle,
                                              L"clussvc",
                                              GENERIC_WRITE |
                                              SERVICE_QUERY_CONFIG |
                                              SERVICE_CHANGE_CONFIG);

        if ( NodeData->ClussvcHandle != NULL ) {
            PrintMsg(MsgSeverityVerbose, "    got SCM cluster service Handle\n");

            if ( DomainName == NULL ) {
                LPQUERY_SERVICE_CONFIG serviceConfig;
                DWORD bytesNeeded;
                BOOL success;

                PrintMsg(MsgSeverityVerbose, "    Getting domain name\n");

                //
                // query with no buffer to get the size
                //
                success = QueryServiceConfig(NodeData->ClussvcHandle,
                                             NULL,
                                             0,
                                             &bytesNeeded);
                if ( !success ) {
                    status = GetLastError();
                    if ( status == ERROR_INSUFFICIENT_BUFFER ) {

                        serviceConfig = HeapAlloc( GetProcessHeap(), 0, bytesNeeded );
                        if ( serviceConfig == NULL ) {
                            PrintMsg(MsgSeverityFatal,
                                     "Cannot allocate memory for service config data\n");
                            return GetLastError();
                        }

                        if ( QueryServiceConfig(NodeData->ClussvcHandle,
                                                serviceConfig,
                                                bytesNeeded,
                                                &bytesNeeded))
                            {
                                PWCHAR slash;

                                PrintMsg(MsgSeverityVerbose,
                                         "    domain account = %ws\n",
                                         serviceConfig->lpServiceStartName);

                                DomainName = serviceConfig->lpServiceStartName;
                                slash = wcschr( DomainName, L'\\' );
                                if ( slash == NULL ) {
                                    PrintMsg(MsgSeverityFatal,
                                             "Can't find backslash separator in domain account string\n");
                                    return ERROR_INVALID_PARAMETER;
                                }
                                *slash = UNICODE_NULL;
                                UserName = slash + 1;
                            }

                        //
                        // we don't free serviceConfig since the global var DomainName
                        // is pointing into it some where. yucky but effective
                        //
                    }
                    else {
                        PrintMsg(MsgSeverityFatal,
                                 "Unable to obtain domain name for cluster "
                                 "service account. error %d\n",
                                 status);
                    }
                }
                else {
                    PrintMsg(MsgSeverityFatal,
                             "QueryServiceConfig should have failed but didn't!\n");
                    status = ERROR_INVALID_PARAMETER;
                }
            }

            //
            // now create an entry for the password utility on this node. try
            // opening first just in case we didn't clean up from the last time.
            //
            if ( NodeData->NodeState == ClusterNodeUp ) {
                
                NodeData->PasswordHandle = OpenService(scmHandle,
                                                       CLUSPW_SERVICE_NAME,
                                                       SERVICE_START | DELETE);

                if ( NodeData->PasswordHandle == NULL ) {
                    status = GetLastError();
                    if ( status == ERROR_SERVICE_DOES_NOT_EXIST ) {
                        DWORD   serviceType;
                        WCHAR   serviceAccount[512];

                        serviceType = SERVICE_WIN32_OWN_PROCESS;
                        if ( RunInCmdWindow ) {
                            serviceType |= SERVICE_INTERACTIVE_PROCESS;
                        }

                        wcscpy( serviceAccount, DomainName );
                        wcscat( serviceAccount, L"\\" );
                        wcscat( serviceAccount, UserName );

                        NodeData->PasswordHandle = CreateService(
                                                       scmHandle,
                                                       CLUSPW_SERVICE_NAME,
                                                       CLUSPW_DISPLAY_NAME,
                                                       SERVICE_START | DELETE,
                                                       serviceType,
                                                       SERVICE_DEMAND_START,
                                                       SERVICE_ERROR_IGNORE,
                                                       L"%windir%\\" CLUWPW_SERVICE_BINARY_NAME,
                                                       NULL,                      // name of load ordering group
                                                       NULL,                      // receives tag identifier
                                                       NULL,                      // array of dependency names
                                                       NULL,                      // service account name 
                                                       NULL                       // account password
                                                       );
                    }
                }

                if ( NodeData->PasswordHandle == NULL ) {
                    status = GetLastError();
                    PrintMsg(MsgSeverityFatal,
                             "Unable to open/create password service with service controller on "
                             "node %ws. error %d\n",
                             NodeName, status);
                } else {
                    PrintMsg(MsgSeverityVerbose, "    created password service\n");
                    status = ERROR_SUCCESS;
                }
                //
                // call ChangeServiceConfig to set wait hint and the like
                //
            }
        }
        else {
            status = GetLastError();
            PrintMsg(MsgSeverityFatal,
                     "Unable to open cluster service with service controller on "
                     "node %ws. error %d\n",
                     NodeName, status);
        }

        CloseServiceHandle( scmHandle );
    }
    else {
        status = GetLastError();
        PrintMsg(MsgSeverityFatal,
                 "Unable to connect to service controller on node %ws. error %d\n",
                 NodeName, status);
    }

    return status;
} // GetClusterServiceData

DWORD
BuildNodeList(
    VOID
    )

/*++

Routine Description:

    open the cluster, get the names and states of the nodes in the cluster,
    and then open service controller handles to the cluster service on these
    nodes. create the password utility service on each node

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything just peachy

--*/

{
    DWORD status = ERROR_SUCCESS;

    PrintMsg(MsgSeverityInfo, "Opening cluster %ws\n", ClusterName );

    ClusterHandle = OpenCluster( ClusterName );
    if ( ClusterHandle != NULL ) {
        HCLUSENUM           nodeEnum;
        CLUSTERVERSIONINFO  clusterInfo;
        DWORD               size = 0;

        //
        // check that there are no NT4 nodes in the cluster. We're not
        // prepared to deal with that just yet.
        //
        clusterInfo.dwVersionInfoSize = sizeof( CLUSTERVERSIONINFO );
        status = GetClusterInformation( ClusterHandle, NULL, &size, &clusterInfo );
        if ( status != ERROR_SUCCESS ) {
            PrintMsg(MsgSeverityFatal,
                     "Failed to get cluster information: error %d\n",
                     status);
            return status;
        }

        if ( CLUSTER_GET_MAJOR_VERSION( clusterInfo.dwClusterHighestVersion ) < NT5_MAJOR_VERSION ) {
            PrintMsg(MsgSeverityFatal, "All cluster nodes must be running Windows 2000 or later\n");
            return ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
        }

        //
        // enum the nodes in the cluster
        //
        nodeEnum = ClusterOpenEnum( ClusterHandle, CLUSTER_ENUM_NODE );
        if ( nodeEnum != NULL ) {
            DWORD enumIndex;
            DWORD objType;
            WCHAR nodeName[ MAX_COMPUTERNAME_LENGTH+1 ];
            DWORD nodeNameSize;

            for ( enumIndex = 0; ; enumIndex++ ) {

                nodeNameSize = sizeof( nodeName );
                status = ClusterEnum(nodeEnum, enumIndex, &objType, nodeName, &nodeNameSize );
                if ( status == ERROR_SUCCESS ) {
                    PCLUSTER_NODE_DATA nodeData;

                    PrintMsg(MsgSeverityVerbose,
                             "Enum = %d, Name = %ws\n",
                             enumIndex, nodeName);

                    //
                    // found a node. allocate space for node data, push it
                    // onto the list of nodes, get its state in the
                    // cluster. get a SCM handle to the cluster service.
                    //
                    nodeData = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof( CLUSTER_NODE_DATA ));
                    if ( nodeData == NULL ) {
                        PrintMsg(MsgSeverityFatal,
                                 "Cannot allocate memory for node data\n");
                        status = GetLastError();
                        break;
                    }

                    nodeData->NextNode = NodeList;
                    NodeList = nodeData;

                    wcscpy( nodeData->NodeName, nodeName );
                    nodeData->NodeHandle = OpenClusterNode( ClusterHandle, nodeName );
                    if ( nodeData->NodeHandle == NULL ) {
                        status = GetLastError();
                        PrintMsg(MsgSeverityFatal,
                                 "Cannot get handle to cluster on node %ws. error %d\n",
                                 nodeName,
                                 status);
                        break;
                    }

                    nodeData->NodeState = GetClusterNodeState( nodeData->NodeHandle );
                    if ( nodeData->NodeState == ClusterNodeStateUnknown ) {
                        status = GetLastError();
                        PrintMsg(MsgSeverityInfo,
                                 "Cannot determine state of cluster service on node %ws. error %d",
                                 nodeName,
                                 status);

                        break;
                    }
                    else if ( nodeData->NodeState <= ClusterNodeJoining ) {
                        PrintMsg(MsgSeverityVerbose,
                                 "    state = %s\n",
                                 ClusterNodeState [nodeData->NodeState] );
                    }

                    PrintMsg(MsgSeverityInfo,
                             "Node %ws is %s\n",
                             nodeName,
                             ClusterNodeState [nodeData->NodeState]);

                    if ( nodeData->NodeState == ClusterNodePaused ) {
                        PrintMsg(MsgSeverityFatal,
                                 "No node can be in the paused state\n");
                        status = ERROR_CLUSTER_NODE_PAUSED;
                        break;
                    }

                    status = GetClusterServiceData(nodeName, nodeData);
                    if ( status != ERROR_SUCCESS ) {
                        break;
                    }

                }
                else if ( status == ERROR_NO_MORE_ITEMS ) {
                    status = ERROR_SUCCESS;
                    break;
                }
                else {
                    PrintMsg(MsgSeverityFatal,
                             "Failed to obtain list of nodes in cluster: error %d\n",
                             status);
                    break;
                }
            }

            ClusterCloseEnum( nodeEnum );
        }
        else {
            status = GetLastError();
            PrintMsg(MsgSeverityFatal,
                     "Failed to get node enum handle: error %d\n",
                     status);
        }
    }
    else {
        status = GetLastError();
        PrintMsg(MsgSeverityFatal, "OpenCluster failed: error %d\n", status);
    }

    return status;
} // BuildNodeList

DWORD
BuildEveryoneSD(
    PSECURITY_DESCRIPTOR *  SD,
    ULONG *                 SizeSD
    )
/*++

Routine Description:

    Build a security descriptor to control access to
    the cluster API

    Modified permissions in ACEs in order to augment cluster security
    administration.

Arguments:

    SD - Returns a pointer to the created security descriptor. This
        should be freed by the caller.

    SizeSD - Returns the size in bytes of the security descriptor

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD                       Status;
    HANDLE                      Token;
    PACL                        pAcl = NULL;
    DWORD                       cbDaclSize;
    PSECURITY_DESCRIPTOR        psd;
    PSECURITY_DESCRIPTOR        NewSD;
    BYTE                        SDBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PACCESS_ALLOWED_ACE         pAce;
    PSID                        pOwnerSid = NULL;
    PSID                        pSystemSid = NULL;
    PSID                        pServiceSid = NULL;
    PULONG                      pSubAuthority;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    ULONG                       NewSDLen;

    psd = (PSECURITY_DESCRIPTOR) SDBuffer;

    //
    // allocate and init the SYSTEM sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSystemSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    pOwnerSid = pSystemSid;

    //
    // Set up the DACL that will allow admins all access.
    // It should be large enough to hold 3 ACEs and their SIDs
    //

    cbDaclSize = ( 3 * sizeof( ACCESS_ALLOWED_ACE ) ) +
        GetLengthSid( pSystemSid );

    pAcl = (PACL) HeapAlloc( GetProcessHeap(), 0, cbDaclSize );
    if ( pAcl == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION );
    InitializeAcl( pAcl,  cbDaclSize, ACL_REVISION );

    //
    // Add the ACE for the SYSTEM account to the DACL
    //
    if ( !AddAccessAllowedAce( pAcl,
                               ACL_REVISION,
                               GENERIC_READ | GENERIC_WRITE,
                               pSystemSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !GetAce( pAcl, 0, (PVOID *) &pAce ) ) {

        Status = GetLastError();
        goto error_exit;
    }

    pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    if ( !SetSecurityDescriptorDacl( psd, TRUE, pAcl, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorOwner( psd, pOwnerSid, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorGroup( psd, pOwnerSid, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorSacl( psd, TRUE, NULL, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    NewSDLen = 0 ;

    if ( !MakeSelfRelativeSD( psd, NULL, &NewSDLen ) ) {
        Status = GetLastError();
        if ( Status != ERROR_INSUFFICIENT_BUFFER ) {    // Duh, we're trying to find out how big the buffer should be?
            goto error_exit;
        }
    }

    NewSD = HeapAlloc( GetProcessHeap(), 0, NewSDLen );
    if ( NewSD ) {
        if ( !MakeSelfRelativeSD( psd, NewSD, &NewSDLen ) ) {
            Status = GetLastError();
            goto error_exit;
        }

        Status = ERROR_SUCCESS;
        *SD = NewSD;
        *SizeSD = NewSDLen;
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

error_exit:
    if ( pSystemSid != NULL ) {
        FreeSid( pSystemSid );
    }

    if ( pAcl != NULL ) {
        HeapFree( GetProcessHeap(), 0, pAcl );
    }

    return( Status );

}  // *** BuildEveryoneSD

DWORD WINAPI
ResultPipeThread(
    LPVOID Param
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE          PipeHandle;
    DWORD           status = ERROR_SUCCESS;
    HANDLE          okToGoEvent = Param;
    PIPE_RESULT_MSG resultMsg;
    BOOL            success;
    BOOL            connected;
    DWORD           bytesRead;
#if 0
    PSECURITY_DESCRIPTOR everyoneSD;
    SECURITY_ATTRIBUTES secAttrib;
    DWORD           sdSize;

    status = BuildEveryoneSD( &everyoneSD, &sdSize );
    secAttrib.nLength = sizeof( secAttrib );
    secAttrib.lpSecurityDescriptor = everyoneSD;
    secAttrib.bInheritHandle = FALSE;
#endif

    PipeHandle = CreateNamedPipe(L"\\\\.\\pipe\\cluspw",
                                 PIPE_ACCESS_DUPLEX,
                                 PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
                                 1,                     // one instance
                                 0,
                                 3 * sizeof(PIPE_RESULT_MSG),
                                 NMPWAIT_USE_DEFAULT_WAIT,
                                 NULL /*&secAttrib*/ );

#if 0
    HeapFree( GetProcessHeap(), 0, everyoneSD );
#endif

    if ( PipeHandle != INVALID_HANDLE_VALUE ) {

        //
        // signal it is ok for the main thread to continue
        //
        SetEvent( okToGoEvent );

        do {
            connected = ConnectNamedPipe(PipeHandle, NULL) ? 
                TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); 

            if ( !connected ) {
                status = GetLastError();
                PrintMsg(MsgSeverityFatal,
                         "Client failed to connect to result pipe. error %d\n",
                         status);
                return status;
            }

            success = ReadFile(PipeHandle,
                               &resultMsg,
                               sizeof( resultMsg ),
                               &bytesRead,
                               NULL);

            if ( !success ) {
                status = GetLastError();
                PrintMsg(MsgSeverityFatal,
                         "Failed to read from result pipe. error %d\n",
                         status);
                DisconnectNamedPipe( PipeHandle );
                continue;
            }

            switch ( resultMsg.MsgType ) {
            case MsgTypeString:
                PrintMsg(resultMsg.Severity,
                         "%ws: %hs",
                         resultMsg.NodeName,
                         resultMsg.MsgBuf);
                break;

            case MsgTypeFinalStatus:
                PrintMsg(MsgSeverityInfo,
                         "Node %ws returned a status of %u.\n",
                         resultMsg.NodeName,
                         resultMsg.Status);
                DisconnectNamedPipe( PipeHandle );
                break;

            default:
                PrintMsg(MsgSeverityFatal,
                         "Received message with invalid type from node %ws\n",
                         resultMsg.NodeName);
            }
        } while (TRUE );
    }
    else {
        status = GetLastError();
        PrintMsg(MsgSeverityFatal,
                 "Unable to create pipe for reporting results. error %d\n",
                 status);
    }

    return status;
} // ResultPipeThread

DWORD
ParseArgs(
    INT argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    INT i;
    DWORD status = ERROR_SUCCESS;
    DWORD argCount = argc - 1;      // skip program name 

    for ( i=1; i<argc; i++ ) {

        if ( argv[i][0] == '/' || argv[i][0] == '-' ) {

            switch ( towupper(argv[i][1]) ) {
#ifdef CMDWINDOW
            case 'C':
                RunInCmdWindow = TRUE;
                break;
#endif

            case 'U':
                Unattended = TRUE;
                break;

            case 'P':
                if ( _wcsnicmp( argv[i]+1, L"phase", 5 ) == 0 ) {
                    wchar_t *   numStart;

                    numStart = wcspbrk( argv[i], L"0123456789" );
                    if ( numStart != NULL ) {
                        StartingPhase = _wtoi( numStart );
                    }
                    else {
                        ++i;
                        StartingPhase = _wtoi( argv[i] );
                    }

                    if ( StartingPhase < 1 || StartingPhase > 3 ) {
                        PrintMsg( MsgSeverityFatal,
                                  "StartingPhase must be between 1 and 3, inclusive\n" );
                        return ERROR_INVALID_PARAMETER;
                    }
                }
                else {
                    printf("Unknown option: %ws\n", argv[i]);
                    return ERROR_INVALID_PARAMETER;
                }
                break;

            case 'Z':
                RefreshCache = TRUE;
                break;

            case 'R':
                AttemptRecovery = TRUE;
                break;

            case 'Q':
                QuietOutput = TRUE;
                break;

            case 'V':
                VerboseOutput = TRUE;
                break;

            default:
                printf("Unknown option: %ws\n", argv[i]);
                return ERROR_INVALID_PARAMETER;
            }
        }
        else if ( RefreshCache ) {
            if ( argCount > 4 ) {
                PrintMsg(MsgSeverityFatal,
                         "Not enough args specified for password cache refresh\n");
                return ERROR_INVALID_PARAMETER;
            }

            DomainName = argv[i];
            UserName = argv[i+1];
            NewPassword = argv[i+2];
            ResultPipeName = argv[i+3];
            break;
        }
        else if ( ClusterName == NULL ) {
            //
            // accept dot as the cluster on this node
            //
            if ( argv[i][0] != L'.' ) {
                ClusterName = argv[i];
            }
        }
        else if ( OldPassword == NULL ) {
            OldPassword = argv[i];
        }
        else if ( NewPassword == NULL ) {
            NewPassword = argv[i];
        }
        else {
            printf("Too many arguments specified\n");
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        --argCount;
    }

    PrintMsg(MsgSeverityVerbose,
             "Unattend = %s, Quiet = %s, Phase = %d, Verbose = %s, Refresh = %s\n",
             TrueOrFalse( Unattended ),
             TrueOrFalse( QuietOutput ),
             StartingPhase,
             TrueOrFalse( VerboseOutput ),
             TrueOrFalse( RefreshCache ));
    PrintMsg(MsgSeverityVerbose,
             "Recovery = %s\n",
             TrueOrFalse( AttemptRecovery ));

    PrintMsg(MsgSeverityVerbose,
             "Cluster Name = %ws, Old Password = %ws, New Password = %ws\n",
             ClusterName, OldPassword, NewPassword);
    PrintMsg(MsgSeverityVerbose,
             "Domain = %ws, User = %ws, ResultPipe = %ws\n",
             DomainName, UserName, ResultPipeName); 

    //
    // validate that we got we need for based on the starting phase
    //
    if ( RefreshCache ) {
        if ( NewPassword == NULL ) {
            PrintMsg(MsgSeverityFatal, "Missing password argument for -z\n" );
            status = ERROR_INVALID_PARAMETER;
        }
    }
    else if ( StartingPhase == 1 ) {
        LPSTR Msg;

        if ( ClusterName == NULL ) {
            Msg = "Cluster Name argument is missing\n";
        }
        else if ( OldPassword == NULL ) {
            Msg = "Old password argument is missing\n";
        }
        else if ( NewPassword == NULL) {
            Msg = "New password argument is missing\n";
        }
        else {
            Msg = NULL;
        }

        if ( Msg != NULL ) {
            PrintMsg(MsgSeverityFatal, Msg );
            status = ERROR_INVALID_PARAMETER;
        }
    }

    if ( QuietOutput && VerboseOutput ) {
        PrintMsg(MsgSeverityFatal, "Quiet and verbose options are mutally exclusive\n");
        status = ERROR_INVALID_PARAMETER;
    }

    return status;
} // ParseArgs

VOID
PrintUsage(
    VOID
    )

/*++

Routine Description:

    print the help msg

Arguments:

    None

Return Value:

    None

--*/

{
    printf("\n");
    printf("cluspw [/quiet] [/verbose] [/phase#] <cluster name> <old password> <new password>\n");
    printf("       /quiet - quiet mode; only print errors\n");
    printf("       /verbose - verbose mode; extra info\n");
    printf("       /phase - starting phase: 1, 2, or 3. Default is 1\n");
    printf("                Phase 1: set the password at the DC\n");
    printf("                Phase 2: update the password caches on each cluster node\n");
    printf("                Phase 3: update the password with each node's service controller\n");
} // PrintUsage

VOID
CleanUp(
    VOID
    )

/*++

Routine Description:

    remove the turds we left around

Arguments:

    None

Return Value:

    None

--*/

{
    PCLUSTER_NODE_DATA      nodeData;
    WCHAR                   destFile[ MAX_PATH ];
    DWORD                   status;
    CLUSTER_RESOURCE_STATE  resState;
    BOOL                    bSuccess;

    //
    // cleanup the broker program if it was copied to the node.
    //
    nodeData = NodeList;
    while ( nodeData != NULL ) {
        if ( nodeData->ClussvcHandle != NULL ) {
            if ( nodeData->NodeState == ClusterNodeUp && StartingPhase < 3 ) {
                wsprintf( destFile, L"\\\\%ws\\admin$\\" CLUWPW_SERVICE_BINARY_NAME, nodeData->NodeName );
                PrintMsg(MsgSeverityVerbose, "Deleting %ws\n", destFile);
                DeleteFile( destFile );
            }

            if ( nodeData->PasswordHandle != NULL ) {
                bSuccess = DeleteService( nodeData->PasswordHandle );
                if ( !bSuccess ) {
                    PrintMsg(MsgSeverityInfo,
                             "Unable to delete cluster password service entry on %ws - status %d\n",
                             nodeData->NodeName,
                             GetLastError());
                }

                CloseServiceHandle( nodeData->PasswordHandle );
            }

            CloseServiceHandle( nodeData->ClussvcHandle );
        }

        if ( nodeData->NodeHandle != NULL ) {
            CloseClusterNode( nodeData->NodeHandle );
        }

        nodeData = nodeData->NextNode;
    }

    if ( ClusterHandle != NULL ) {
        CloseCluster( ClusterHandle );
    }
} // CleanUp

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    main routine for utility

Arguments:

    standard command line args

Return Value:

    0 if it worked successfully

--*/

{
    DWORD           status;
    DWORD           waitStatus;
    NET_API_STATUS  netStatus;
    HANDLE          pipeThread;
    HANDLE          okToGoEvent;
    DWORD           threadId;
    HANDLE          handleArray[2];
    PWCHAR          invokedAs;

    //
    // checked to see how we were invoked.
    //
    invokedAs = wcsrchr( argv[0], L'\\' );
    if ( invokedAs == NULL ) {
        invokedAs = argv[0];
    } else {
        ++invokedAs;
    }

    if ( argc == 1 ) {
        if ( _wcsicmp( invokedAs, CLUWPW_SERVICE_BINARY_NAME ) == 0 ) {
            ServiceStartup();
        } else {
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }
    }
    else {
        status = ParseArgs( argc, argv );
        if ( status != ERROR_SUCCESS ) {
            PrintUsage();
            return status;
        }

        //
        // create an event for the result pipe thread to signal that is it
        // ready to receive msgs
        //
        okToGoEvent = CreateEvent(NULL,     // no security
                                  FALSE,    // auto-reset
                                  FALSE,    // not signalled
                                  NULL);    // no name

        if ( okToGoEvent == NULL ) {
            status = GetLastError();
            PrintMsg(MsgSeverityFatal, "Couldn't create \"Ok to go\" event. error %d\n",
                     status);

            return status;
        }

        //
        // create a thread for the routine that creates a named pipe used by the
        // clients to report their status
        //
        pipeThread = CreateThread(NULL,
                                  0,
                                  ResultPipeThread,
                                  okToGoEvent,
                                  0,
                                  &threadId);
        if ( pipeThread == NULL ) {
            status = GetLastError();
            PrintMsg(MsgSeverityFatal, "Couldn't create thread for result pipe. error %d\n",
                     status);

            return status;
        }

        //
        // now wait for one to be signalled. If it's the event, then all is
        // well. Otherwise, our pipe thread died.
        //
        handleArray[0] = pipeThread;
        handleArray[1] = okToGoEvent;
        status = WaitForMultipleObjects( 2, handleArray, FALSE, INFINITE );

        if (( status - WAIT_OBJECT_0 ) == 0 ) {
            goto error_exit;
        }

        //
        // find all the nodes in the specified cluster and build up a database
        // (among other things) about them
        //
        status = BuildNodeList();
        if ( status != ERROR_SUCCESS ) {
            return status;
        }

        status = CheckDCAvailability();
        if ( status != ERROR_SUCCESS ) {
            return status;
        }

        if ( StartingPhase != 3 ) {
            status = CopyNodeApplication();
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

#if 0
            status = CreatePasswordGroup();
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }
#endif
        }

        switch ( StartingPhase ) {
        case 1:
            //
            // change password at DC
            //
            PrintMsg(MsgSeverityInfo, "Phase 1: Changing password at DC\n");
            netStatus = NetUserChangePassword(DomainName,  
                                              UserName,    
                                              OldPassword, 
                                              NewPassword);

            if ( netStatus != ERROR_SUCCESS ) {
                PrintMsg(MsgSeverityFatal,
                         "Couldn't change the password at the domain controller. error %d\n",
                         netStatus);
                goto error_exit;
            }

        case 2:
            //
            // run the broker to change the password cache. we have to
            // continue if the broker failed since the p/w has been changed at
            // the DC. If the cluster falls apart, we still need to reset the
            // SCM's p/w so it can restart
            //
            PrintMsg(MsgSeverityInfo,
                     "Phase 2: Refreshing password cache on each cluster node.\n");
            RefreshPasswordCaches();

        case 3:
            PrintMsg(MsgSeverityInfo,
                     "Phase 3: Updating password with Service Controller on each cluster node.\n");
            status = ChangePasswordWithSCMs();
        }


error_exit:
        //
        // see if the pipe handle was signalled and report its status
        //
        waitStatus = WaitForSingleObject( pipeThread, 0 );
        if ( waitStatus == WAIT_OBJECT_0 ) {
            GetExitCodeThread( pipeThread, &status );
        }

        CleanUp();
    }

    return status;
} // wmain

#if 0

//
// old version that tried to use genapp resources. Keeping this code around
// since it shows how to use prop lists
//
DWORD
RefreshPasswordCaches(
    VOID
    )

/*++

Routine Description:

    Start our service on each node

Arguments:

    None

Return Value:

    None

--*/

{
    PCLUSTER_NODE_DATA nodeData;
    BOOL success;
    DWORD status;
    CLUSTER_RESOURCE_STATE resState;
    PVOID propList = NULL;
    DWORD propListSize = 0;
    WCHAR cmdBuff[ 512 ];
    RESOURCE_PRIVATEPROPS privateProps;
    RESUTIL_PROPERTY_ITEM privatePropTable[] = {
        { L"CommandLine", NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0,
          FIELD_OFFSET( RESOURCE_PRIVATEPROPS, CommandLine ) },
        { L"CurrentDirectory", NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0,
          FIELD_OFFSET( RESOURCE_PRIVATEPROPS, CurrentDirectory ) },
        { L"InteractWithDesktop", NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, 0,
          FIELD_OFFSET( RESOURCE_PRIVATEPROPS, InteractWithDesktop ) },
        { 0 }
    };
    DWORD bytesReturned;
    DWORD bytesRequired;
    WCHAR resultPipeName[ MAX_PATH ] = L"\\\\";
    DWORD pipeNameSize = (sizeof(resultPipeName) / sizeof( WCHAR )) - 2;

    //
    // get our physical netbios name to include on the cmd line arg
    //
#if (_WIN32_WINNT > 0x4FF)
    success = GetComputerNameEx(ComputerNamePhysicalNetBIOS,
                                &resultPipeName[2],
                                &pipeNameSize);
#else
    success = GetComputerName( &resultPipeName[2], &pipeNameSize);
#endif

    wcscat( resultPipeName, L"\\pipe\\cluspw" );

    //
    // loop through the cluster nodes
    //
    nodeData = NodeList;
    while ( nodeData != NULL ) {
        if ( nodeData->NodeState == ClusterNodeUp ) {

            PrintMsg(MsgSeverityVerbose,
                     "Moving PW Group to node %ws\n",
                     nodeData->NodeName);

            status = MoveClusterGroup( PWGroup, nodeData->NodeHandle );
            if ( status != ERROR_SUCCESS ) {
                PrintMsg(MsgSeverityFatal,
                         "Problem moving Password group to node %ws. error %d\n",
                         nodeData->NodeName, status);
                break;
            }

            //
            // set the private props for our resource. The app is copied to
            // the admin$ share on each node which is on the default path that
            // is given to all users.
            //
            wsprintf(cmdBuff,
                     L"%wscluspw.exe %ws-z %ws %ws %ws %ws",
                     RunInCmdWindow ? L"cmd /k " : L"",
                     nodeData->NodeName,
                     VerboseOutput ? L"-v " : L"",
                     DomainName,
                     UserName,
                     NewPassword,
                     resultPipeName);

            privateProps.InteractWithDesktop = RunInCmdWindow;
            privateProps.CommandLine = cmdBuff;

            PrintMsg(MsgSeverityVerbose, "cmd line: %ws\n", cmdBuff );

            privateProps.CurrentDirectory = L".";
            propListSize = 0;

            status = ResUtilPropertyListFromParameterBlock(privatePropTable,
                                                           NULL,
                                                           &propListSize,
                                                           (LPBYTE) &privateProps,
                                                           &bytesReturned,
                                                           &bytesRequired );

            if ( status == ERROR_MORE_DATA ) {
                propList = HeapAlloc( GetProcessHeap(), 0, bytesRequired );
                propListSize = bytesRequired;

                status = ResUtilPropertyListFromParameterBlock(privatePropTable,
                                                               propList,
                                                               &propListSize,
                                                               (LPBYTE) &privateProps,
                                                               &bytesReturned,
                                                               &bytesRequired );
                if ( status != ERROR_SUCCESS ) {
                    PrintMsg(MsgSeverityFatal,
                             "Couldn't create property list to set Generic App properties. error %d\n",
                             status);
                    return status;
                }
            }
            else if ( status != ERROR_SUCCESS ) {
                PrintMsg(MsgSeverityFatal,
                         "Couldn't determine size of property list for Generic App properties. error %d\n",
                         status);
                return status;
            }

            PrintMsg(MsgSeverityVerbose, "Setting GenApp properties\n");

            status = ClusterResourceControl(PWResource,
                                            NULL,
                                            CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                            propList,
                                            propListSize,
                                            NULL,
                                            0,
                                            NULL);
            HeapFree( GetProcessHeap(), 0, propList );

            status = OnlineClusterResource( PWResource );
            if ( status == ERROR_IO_PENDING || status == ERROR_SUCCESS ) {
                //
                // wait until the resource has finished running
                //
                do {
                    Sleep( 250 );
                    resState = GetClusterResourceState(PWResource, NULL, NULL, NULL, NULL);
                    if ( resState == ClusterResourceFailed || resState == ClusterResourceOffline ) {
                        break;
                    }
                } while ( TRUE );

                status = ERROR_SUCCESS;
            }
            else {
                PrintMsg(MsgSeverityFatal,
                         "Problem bringing Password resource online on node %ws. error %d\n",
                         nodeData->NodeName, status);
                break;
            }
        }

        nodeData = nodeData->NextNode;
    }

    return status;
} // RefreshPasswordCaches
#endif

/* end cluspw.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\compobj\compobj.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    compobj.c

Abstract:

    GetComputerObjectName utility.

Author:

    Charlie Wickham (charlwi) 22-Jul-1999

Environment:

    User mode

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

//#define COBJMACROS

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <lm.h>
#include <lmaccess.h>

#include <objbase.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>

#define SECURITY_WIN32
#include <security.h>

#include "clusvmsg.h"
#include "clusrtl.h"

#define ADD     1
#define DEL     2
#define QUERY   3
#define GUID    4

struct _NAMES {
    PWCHAR                  Title;
    EXTENDED_NAME_FORMAT    Code;
} Names[] = {
    L"FQDN\t\t",    NameFullyQualifiedDN,
    L"SAM\t\t",     NameSamCompatible,
    L"Display\t\t", NameDisplay,
    L"UID\t\t",     NameUniqueId,
    L"Canonical\t", NameCanonical,
    L"UserPrin\t\t",    NameUserPrincipal,
    L"Can EX\t\t",  NameCanonicalEx,
    L"SPN\t\t",     NameServicePrincipal
};

PCHAR ADSTypeNames[] = {
	"INVALID",
	"DN_STRING",
	"CASE_EXACT_STRING",
	"CASE_IGNORE_STRING",
	"PRINTABLE_STRING",
	"NUMERIC_STRING",
	"BOOLEAN",
	"INTEGER",
	"OCTET_STRING",
	"UTC_TIME",
	"LARGE_INTEGER",
	"PROV_SPECIFIC",
	"OBJECT_CLASS",
	"CASEIGNORE_LIST",
	"OCTET_LIST",
	"PATH",
	"POSTALADDRESS",
	"TIMESTAMP",
	"BACKLINK",
	"TYPEDNAME",
	"HOLD",
	"NETADDRESS",
	"REPLICAPOINTER",
	"FAXNUMBER",
	"EMAIL",
	"NT_SECURITY_DESCRIPTOR",
	"UNKNOWN",
	"DN_WITH_BINARY",
	"DN_WITH_STRING"
};

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    main routine for utility

Arguments:

    standard command line args

Return Value:

    0 if it worked successfully

--*/

{
    WCHAR       buffer[512];
    DWORD       bufSize;
    BOOL        success;
    DWORD       i;
    USER_INFO_1 netUI1;
    DWORD       badParam;
    DWORD       status;
    PWCHAR      dcName = argv[2];
    PWCHAR      machineName = NULL;
    DWORD       opCode;
    WCHAR       bindingString[512];
    HRESULT     hr;

    if ( argc == 1 ){
        printf("%ws -add dcName nodename pwd\n", argv[0]);
        printf("%ws -del dcName nodename\n", argv[0]);
        printf("%ws -query domain [nodename]\n", argv[0]);
        printf("%ws -guid objectGUID attr [attr ...]\n", argv[0]);
        return 0;
    }

    if ( _wcsnicmp( argv[1], L"-add", 4 ) == 0 ) {
        if ( argc < 5 ) {
            printf("%ws -add dcName nodename pwd\n", argv[0]);
            return 0;
        }
        opCode = ADD;
        dcName = argv[2];
        machineName = argv[3];
    }
    else if ( _wcsnicmp( argv[1], L"-del", 4 ) == 0 ) {
        if ( argc < 4 ) {
            printf("%ws -del dcName nodename\n", argv[0]);
            return 0;
        }
        opCode = DEL;
        dcName = argv[2];
        machineName = argv[3];
    }
    else if ( _wcsnicmp( argv[1], L"-query", 6 ) == 0 ) {
        opCode = QUERY;
        if ( argc > 3 ) {
            machineName = argv[3];
        }            
    }
    else if ( _wcsnicmp( argv[1], L"-guid", 5 ) == 0 ) {
        if ( argc < 4 ) {
            printf("%ws -guid objectGUID attr [attr ...]\n", argv[0]);
            return 0;
        }
        opCode = GUID;
    }
    else {
        printf("%ws -add dcName nodename pwd\n", argv[0]);
        printf("%ws -del dcName nodename\n", argv[0]);
        printf("%ws -query domain [nodename attr [attr ...]]\n", argv[0]);
        printf("%ws -guid objectGUID attr [attr ...]\n", argv[0]);
        return 0;
    }

    if ( opCode == ADD ) {
        PWCHAR machinePwd = argv[4];

        RtlZeroMemory( &netUI1, sizeof( netUI1 ) );

        //
        // Initialize it..
        //
        netUI1.usri1_name       = machineName;
        netUI1.usri1_password   = machinePwd;
        netUI1.usri1_flags      = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
        netUI1.usri1_priv       = USER_PRIV_USER;
        netUI1.usri1_comment    = L"Server cluster virtual network name";

        status = NetUserAdd( dcName, 1, (PBYTE)&netUI1, &badParam );

        if ( status == NERR_Success ) {
            printf("NetUserAdd is successful.\n");
        } else {
            printf( "NetUserAdd on '%ws' for '%ws' failed: 0x%X - params = %d\n",
                    dcName, machineName, status, badParam );
            return status;
        }
    }
    else if ( opCode == DEL ) {
        status = NetUserDel( dcName, machineName );
        if ( status == NERR_Success ) {
            printf("NetUserDel is successful.\n");
        } else {
            printf( "NetUserDel on '%ws' for '%ws' failed: 0x%X\n", dcName, machineName, status );
            return status;
        }
    }
    else if ( opCode == QUERY ) {
        dcName = argv[2];

        printf("Output from GetComputerObjectName()\n");
        for ( i = 0; i < sizeof(Names)/sizeof(struct _NAMES); ++i ) {
            //
            // loop through the different name variants, printing the associated result
            //
            bufSize = 512;
            success = GetComputerObjectName(Names[i].Code,
                                            buffer, &bufSize);

            if ( success ) {
                printf("%ws%ws\n\n", Names[i].Title, buffer );
            } else {
                printf("\nFAILED: %.*ws (%d)\n\n",
                       (wcschr(Names[i].Title, L'\t') - Names[i].Title),
                       Names[i].Title,
                       GetLastError());
            }
        }

        if ( machineName != NULL ) {
            WCHAR           compName[ 256 ];
            BOOL            success;
            DWORD           compNameSize = sizeof( compName ) / sizeof( WCHAR );

            printf("IADs_Computer output\n\n");

            if ( machineName == NULL ) {
                success = GetComputerName( compName, &compNameSize );
                if ( success ) {
                    machineName = compName;
                } else {
                    printf("GetComputerName failed - %u\n", status = GetLastError() );
                    return status;
                }
            }

            hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
            if ( SUCCEEDED( hr )) {
                IADsComputer    *pComp;

                wsprintf( bindingString, L"WinNT://%ws/%ws,computer", dcName, machineName );
                printf("Connecting to: %ws\n", bindingString );
                hr = ADsGetObject( bindingString, IID_IADsComputer, (void **)&pComp );

                if ( SUCCEEDED( hr )) {
                    BSTR bstr;
                    IADs *pADs;

                    hr = pComp->QueryInterface(IID_IADs, (void**) &pADs);
                    if ( SUCCEEDED( hr )) {

                        if( S_OK == pADs->get_Name(&bstr) ) {
                            printf("Object Name: %S\n",bstr);
                        }

                        if( S_OK == pADs->get_GUID(&bstr) ) {
                            printf("Object GUID: %S\n",bstr);
                        }

                        if( S_OK == pADs->get_ADsPath(&bstr) ) {
                            printf("Object path: %S\n",bstr);
                        }

                        if( S_OK == pADs->get_Class(&bstr) ) {
                            printf("Object class: %S\n",bstr);
                        }

                        if( S_OK == pADs->get_Schema(&bstr) ) {
                            printf("Schema: %S\n",bstr);
                        }

                        IADsClass *pCls;

                        hr = ADsGetObject(bstr,IID_IADsClass, (void**)&pCls);
                        if ( hr == S_OK) {
                            if( S_OK == pCls->get_Name(&bstr) ) {
                                printf("Class name is %S\n", bstr);
                            }
                            pCls->Release();
                        }

                        hr = pComp->get_ComputerID( &bstr);
                        if ( SUCCEEDED( hr )) {
                            printf("Computer ID: %S\n",bstr);
                            SysFreeString(bstr);
                        } else {
                            printf("Computer ID: error = %X\n",hr);
                        }

                        hr = pComp->get_Description( &bstr );
                        if ( SUCCEEDED( hr )) {
                            printf("Description: %S\n",bstr);
                            SysFreeString(bstr);
                        } else {
                            printf("Description: error = %X\n",hr);
                        }

                        hr = pComp->get_OperatingSystem( &bstr );
                        if ( SUCCEEDED( hr )) {
                            printf("OS: %S\n",bstr);
                            SysFreeString(bstr);
                        } else {
                            printf("Description: error = %X\n",hr);
                        }

                        hr = pComp->get_OperatingSystemVersion( &bstr );
                        if ( SUCCEEDED( hr )) {
                            printf("OS Version: %S\n",bstr);
                            SysFreeString(bstr);
                        } else {
                            printf("Description: error = %X\n",hr);
                        }

                        hr = pComp->get_Role( &bstr );
                        if ( SUCCEEDED( hr )) {
                            printf("Role: %S\n",bstr);
                            SysFreeString(bstr);
                        } else {
                            printf("Role: error = %X\n",hr);
                        }
                        pADs->Release();
                    }
                    pComp->Release();

                } else {
                    printf("ADsGetObject(IADs_Computer) failed for %ws - 0x%X\n", bindingString, hr );
                }

                //
                // now bind to the Directory Object for this computer object
                // and get attributes passed in through the cmd line that are
                // not available through IComputer.
                //
                IDirectoryObject *  pDir ;
                DWORD               dwNumAttr = argc - 4;

                if ( dwNumAttr > 0 ) {
                    printf("\nIDirectoryObject output\n\n" );

                    bufSize = 512;
                    if ( GetComputerObjectName(NameFullyQualifiedDN, buffer, &bufSize)) {

                        wsprintf( bindingString, L"LDAP://%ws", buffer );
                        printf("Connecting to: %ws\n", bindingString );
                        hr = ADsGetObject( bindingString, IID_IDirectoryObject, (void **)&pDir );

                        if ( SUCCEEDED( hr )) {
                            ADS_ATTR_INFO * pAttrInfo=NULL;
                            DWORD           dwReturn;
                            LPWSTR *        pAttrNames = &argv[4];

                            hr = pDir->GetObjectAttributes( pAttrNames, 
                                                            dwNumAttr, 
                                                            &pAttrInfo, 
                                                            &dwReturn );
 
                            if ( SUCCEEDED(hr) ) {
                                for(DWORD idx=0; idx < dwReturn;idx++, pAttrInfo++ ) {
                                    printf( "Attr Name: %ws\n", pAttrInfo->pszAttrName );
                                    printf( "Attr Type: %s (%u)\n",
                                            ADSTypeNames[pAttrInfo->dwADsType],
                                            pAttrInfo->dwADsType );
                                    printf( "Attr Num Values: %u\n", pAttrInfo->dwNumValues );
                                    if ( pAttrInfo->dwADsType == ADSTYPE_CASE_EXACT_STRING ||
                                         pAttrInfo->dwADsType == ADSTYPE_DN_STRING          ||
                                         pAttrInfo->dwADsType == ADSTYPE_CASE_IGNORE_STRING ||
                                         pAttrInfo->dwADsType == ADSTYPE_PRINTABLE_STRING ||
                                         pAttrInfo->dwADsType == ADSTYPE_NUMERIC_STRING)
                                        {
                                            for (DWORD val=0; val < pAttrInfo->dwNumValues; val++, pAttrInfo->pADsValues++) 
                                                printf("  %ws\n", pAttrInfo->pADsValues->CaseIgnoreString);
                                        }
                                    else if ( pAttrInfo->dwADsType == ADSTYPE_BOOLEAN ) {
                                        printf("  %ws\n", pAttrInfo->pADsValues->Boolean ? L"TRUE" : L"FALSE");
                                    }
                                    else if ( pAttrInfo->dwADsType == ADSTYPE_INTEGER ) {
                                        printf("  %u\n", pAttrInfo->pADsValues->Integer );
                                    }
                                    else if ( pAttrInfo->dwADsType == ADSTYPE_OBJECT_CLASS ) {
                                        printf("  %ws\n", pAttrInfo->pADsValues->ClassName );
                                    }
                                    else if ( pAttrInfo->dwADsType == ADSTYPE_NT_SECURITY_DESCRIPTOR ) {
                                        PSECURITY_DESCRIPTOR    pSD = pAttrInfo->pADsValues->SecurityDescriptor.lpValue;
                                        DWORD                   sdLength = pAttrInfo->pADsValues->SecurityDescriptor.dwLength;
                                        if ( IsValidSecurityDescriptor( pSD )) {
                                            ClRtlExamineSD( pSD, "    " );
                                        } else {
                                            printf("  SD is invalid\n" );
                                        }
                                    }
                                }
                            }

                            pDir->Release();

                        } else {
                            printf("ADsGetObject(IDirectoryObject) failed for %ws - 0x%X\n", bindingString, hr );
                        }
                    } else {
                        printf("GetComputerObjectName failed - %u\n", GetLastError());
                    }
                }
            } else {
                printf("CoInitializeEx failed - %X\n", hr );
            }
        }
    }
    else if ( opCode == GUID ) {
        IDirectoryObject *  pDir = NULL;
        LPWSTR              objectGuid = argv[2];
        DWORD               dwNumAttr = argc - 3;
        LPWSTR *            pAttrNames = &argv[3];
        IADs *              pADs;

        hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
        if ( SUCCEEDED( hr )) {

            //
            // GUID bindings are of the form with or without hyphens. With
            // hyphens uses the standard notation and observes the byte
            // ordering approprite for that format. Without hyphens is a
            // stream of bytes, i.e., the first 4 bytes are in reverse order
            // as compared to the hypenated version
            //
            // Without hyphens: 2deb53aa57a6d211bbcd00105a24d6db
            // With hyphens:    aa53eb2d-a657-11d2-bbcd-00105a24d6db
            //
            wsprintf( bindingString, L"LDAP://<GUID=%ws>", objectGuid );
            printf("Connecting to: %ws\n", bindingString );
            hr = ADsGetObject( bindingString, IID_IDirectoryObject, (void **)&pDir );

            if ( SUCCEEDED( hr )) {
                ADS_ATTR_INFO * pAttrInfo=NULL;
                DWORD           dwReturn;

                hr = pDir->GetObjectAttributes( pAttrNames, 
                                                dwNumAttr, 
                                                &pAttrInfo, 
                                                &dwReturn );
 
                if ( SUCCEEDED(hr) ) {
                    for(DWORD idx=0; idx < dwReturn;idx++, pAttrInfo++ ) {
                        printf( "Attr Name: %ws\n", pAttrInfo->pszAttrName );
                        printf( "Attr Type: %s (%u)\n",
                                ADSTypeNames[pAttrInfo->dwADsType],
                                pAttrInfo->dwADsType );
                        printf( "Attr Num Values: %u\n", pAttrInfo->dwNumValues );
                        if ( pAttrInfo->dwADsType == ADSTYPE_CASE_EXACT_STRING ||
                             pAttrInfo->dwADsType == ADSTYPE_DN_STRING          ||
                             pAttrInfo->dwADsType == ADSTYPE_CASE_IGNORE_STRING ||
                             pAttrInfo->dwADsType == ADSTYPE_PRINTABLE_STRING ||
                             pAttrInfo->dwADsType == ADSTYPE_NUMERIC_STRING)
                            {
                                for (DWORD val=0; val < pAttrInfo->dwNumValues; val++, pAttrInfo->pADsValues++) 
                                    printf("  %ws\n", pAttrInfo->pADsValues->CaseIgnoreString);
                            }
                        else if ( pAttrInfo->dwADsType == ADSTYPE_BOOLEAN ) {
                            printf("  %ws\n", pAttrInfo->pADsValues->Boolean ? L"TRUE" : L"FALSE");
                        }
                        else if ( pAttrInfo->dwADsType == ADSTYPE_INTEGER ) {
                            printf("  %u\n", pAttrInfo->pADsValues->Integer );
                        }
                        else if ( pAttrInfo->dwADsType == ADSTYPE_OBJECT_CLASS ) {
                            printf("  %ws\n", pAttrInfo->pADsValues->ClassName );
                        }
                        else if ( pAttrInfo->dwADsType == ADSTYPE_NT_SECURITY_DESCRIPTOR ) {
                            PSECURITY_DESCRIPTOR    pSD = pAttrInfo->pADsValues->SecurityDescriptor.lpValue;
                            DWORD                   sdLength = pAttrInfo->pADsValues->SecurityDescriptor.dwLength;
                            if ( IsValidSecurityDescriptor( pSD )) {
                                ClRtlExamineSD( pSD, "    " );
                            } else {
                                printf("  SD is invalid\n" );
                            }
                        }
                    }
                }

                hr = pDir->QueryInterface(IID_IADs, (void**) &pADs);
                if ( SUCCEEDED( hr )) {
                    BSTR bstr;

                    if( S_OK == pADs->get_Name(&bstr) ) {
                        printf("Object Name: %S\n",bstr);
                    }

                    if( S_OK == pADs->get_GUID(&bstr) ) {
                        printf("Object GUID: %S\n",bstr);
                    }

                    if( S_OK == pADs->get_ADsPath(&bstr) ) {
                        printf("Object path: %S\n",bstr);
                    }

                    if( S_OK == pADs->get_Class(&bstr) ) {
                        printf("Object class: %S\n",bstr);
                    }

                    if( S_OK == pADs->get_Schema(&bstr) ) {
                        printf("Schema: %S\n",bstr);
                    }
                    pADs->Release();
                }

                pDir->Release();

            } else {
                printf("ADsGetObject(IADs) failed for %ws - 0x%X\n", bindingString, hr );
            }
        }
    }
} // wmain

/* end compobj.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\cluspw\refrshpw.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    refrshpw.c

Abstract:

    refresh the cached password for the specified account in the LSA on a
    node. derived from test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    26-Jul-99 (charlwi) Charlie Wickham
        modified to handle updating a password (from Mike Swift or Scott Field)

--*/


//
// Common include files.
//

#define SECURITY_WIN32

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <stdio.h>      // printf
#include <ntmsv1_0.h>

#include "cluspw.h"

DWORD
ChangeCachedPassword(
    IN LPWSTR AccountName,
    IN LPWSTR DomainName,
    IN LPWSTR NewPassword
    )
{
    PMSV1_0_CHANGEPASSWORD_REQUEST Request = NULL;
    HANDLE LogonHandle = NULL;
    ULONG Dummy;
    ULONG RequestSize = 0;
    ULONG PackageId = 0;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus = STATUS_SUCCESS, Status = STATUS_SUCCESS;
    BOOLEAN Trusted = TRUE;
    BOOLEAN WasEnabled;
    PBYTE Where;
    STRING Name;

    //
    // Turn on the TCB privilege
    //

    PrintMsg(MsgSeverityVerbose, "Adjusting TCB privilege\n");
    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status)) {
        PrintMsg(MsgSeverityInfo, "Failed to Adjust TCB privilege. status %X\n", Status);
        Trusted = FALSE;
    }

    RtlInitString( &Name, "Cluspw" );

    PrintMsg(MsgSeverityVerbose, "Connecting to LSA\n");
    if (Trusted) {
        Status = LsaRegisterLogonProcess( &Name, &LogonHandle, &Dummy );
    }
    else {
        Status = LsaConnectUntrusted( &LogonHandle );
    }

    if (!NT_SUCCESS(Status)) {
        PrintMsg(MsgSeverityFatal,
                 "Failed to register cluspw as a logon process: %08X\n",
                 Status);
        return Status;
    }

    RtlInitString( &Name, MSV1_0_PACKAGE_NAME );

    PrintMsg(MsgSeverityVerbose, "Looking up authentication package\n");
    Status = LsaLookupAuthenticationPackage( LogonHandle, &Name, &PackageId );
    if (!NT_SUCCESS(Status)) {
        PrintMsg(MsgSeverityFatal,
                 "Failed to lookup authentication package %Z: %08X\n",
                 &Name,
                 Status);
        return Status;
    }


    RequestSize = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) +
        (wcslen(AccountName) +
         wcslen(DomainName) +
         wcslen(NewPassword) + 3) * sizeof(WCHAR);

    Request = (PMSV1_0_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT,RequestSize);
    if ( Request == NULL ) {
        PrintMsg(MsgSeverityFatal, "Failed to allocate memory for cache update request.\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Where = (PBYTE) (Request + 1);
    Request->MessageType = MsV1_0ChangeCachedPassword;
    wcscpy( (LPWSTR) Where, DomainName );
    RtlInitUnicodeString( &Request->DomainName, (LPWSTR) Where );
    Where += Request->DomainName.MaximumLength;

    wcscpy((LPWSTR) Where, AccountName );
    RtlInitUnicodeString( &Request->AccountName, (LPWSTR) Where );
    Where += Request->AccountName.MaximumLength;

    wcscpy((LPWSTR) Where, NewPassword );
    RtlInitUnicodeString( &Request->NewPassword, (LPWSTR) Where );
    Where += Request->NewPassword.MaximumLength;

    //
    // Make the call
    //
    PrintMsg(MsgSeverityVerbose, "Calling LSA to update the cache\n");
    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          Request,
                                          RequestSize,
                                          &Response,
                                          &ResponseSize,
                                          &SubStatus);


    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus)) {
        DWORD winStatus;
        DWORD winSubStatus;

        winStatus = RtlNtStatusToDosError( Status );
        winSubStatus = RtlNtStatusToDosError( SubStatus );

        if ( winStatus == ERROR_MR_MID_NOT_FOUND ) {
            winStatus = Status;
        }
        if ( winSubStatus == ERROR_MR_MID_NOT_FOUND ) {
            winSubStatus = SubStatus;
        }
        PrintMsg(MsgSeverityFatal,
                 "Updating password cache failed: status = 0x%08X, substatus = 0x%08X\n",
                 winStatus,
                 winSubStatus);
        if ( Status == STATUS_SUCCESS ) {
            Status = SubStatus;
        }
    }
    else {
        PrintMsg(MsgSeverityVerbose, "LSA returned success\n");
    }

    if (LogonHandle != NULL) {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\dsrole\dsrole.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dsrole.c

Abstract:

    utility to dump output of DsRoleGetPrimaryDomainInformation

Author:

    Charlie Wickham (charlwi) 03-Nov-00

Environment:

    User mode

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <dsrole.h>

PWSTR RoleNames[] = {
    L"StandaloneWorkstation",
    L"MemberWorkstation",
    L"StandaloneServer",
    L"MemberServer",
    L"BackupDomainController",
    L"PrimaryDomainController "
};

typedef struct _FLAG_DATA {
    ULONG   Flag;
    PWCHAR  Name;
} FLAG_DATA;

FLAG_DATA FlagData[] = {
    { DSROLE_PRIMARY_DS_RUNNING,            L"DS running on this node" },
    { DSROLE_PRIMARY_DS_MIXED_MODE,         L"DS running in mixed mode" },
    { DSROLE_UPGRADE_IN_PROGRESS,           L"Node is upgrading" },
    { DSROLE_PRIMARY_DOMAIN_GUID_PRESENT, L"Valid GUID" }
};

typedef WCHAR GUIDSTR[32 * 3];
VOID formatGuid(LPGUID Guid, PWCHAR buf)
{
    //
    // GUIDs look like this: 4082164E-A4B5-11D2-89C3-E37CB6BB13FC
    //
    wsprintfW(
        buf,
        L"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
        Guid->Data1, Guid->Data2, Guid->Data3,
        Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3],
        Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]
        );
}

PWCHAR
InterpretFlagData(
    ULONG   Flags
    )

{
    static WCHAR    buffer[1024] = { UNICODE_NULL };
    BOOL            addComma = FALSE;
    DWORD           i;

    for ( i = 0; i < sizeof(FlagData)/sizeof(FLAG_DATA); ++i ) {
        if ( FlagData[i].Flag & Flags ) {
            if ( addComma ) {
                wcscat( buffer, L", " );
            }

            wcscat( buffer, FlagData[i].Name );
            addComma = TRUE;
        }
    }

    return buffer;
}

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    main routine for utility

Arguments:

    standard command line args

Return Value:

    0 if it worked successfully

--*/

{
    DWORD                               status;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   domainInfo;

    status = DsRoleGetPrimaryDomainInformation(argv[1],
                                               DsRolePrimaryDomainInfoBasic,
                                               (PBYTE *)&domainInfo);
    printf("status = %u\n", status );
    printf("machine role = %ws\n"
           "flags = %08X (%ws)\n"
           "flat name = %ws\n"
           "dns name = %ws\n"
           "forest name = %ws\n",
           RoleNames[domainInfo->MachineRole],
           domainInfo->Flags, InterpretFlagData( domainInfo->Flags ),
           domainInfo->DomainNameFlat,
           domainInfo->DomainNameDns,
           domainInfo->DomainForestName);

    if ( domainInfo->Flags & DSROLE_PRIMARY_DOMAIN_GUID_PRESENT ) {
        WCHAR guidBuf[ 64 ];

        formatGuid( &domainInfo->DomainGuid, guidBuf );
        printf("domain Guid = %ws\n", guidBuf );
    }

    return 0;
} // wmain

/* end dsrole.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\ipaddr\ipaddr.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ipaddr.c

Abstract:

    add/del ip addresses to an adapter

Author:

    Charlie Wickham (charlwi) 03-Nov-00

Environment:

    User mode

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <winsock2.h>
#include <iphlpapi.h>

typedef enum {
    OpAdd = 1,
    OpDel,
    OpCycle
} OPERATION;

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    main routine for utility

Arguments:

    -add <Adapter name> <Ip addr>
    -del <NTE context>
    -cycle <Adapter name> <Ip addr>

Return Value:

    0 if it worked successfully

--*/

{
    DWORD           status;
    DWORD           adapterIndex;
    struct in_addr  ipAddress;
    struct in_addr  ipMask;
    OPERATION       opCode;
    DWORD           nteContext;
    DWORD           nteInstance;
    HANDLE          mprConfig;
    WCHAR           guidName[64] = L"\\DEVICE\\TCPIP_";

    if ( argc < 2 ) {
        printf("%ws -add <adapter name> address mask\n", argv[0] );
        printf("%ws -cycle <adapter name> address mask <cycle sleep time>\n", argv[0] );
        printf("%ws -del <NTE context>\n", argv[0] );
        return 0;
    }

    switch (*(argv[1]+1)) {
    case L'a':
    case L'A':
        opCode = OpAdd;
        break;

    case L'd':
    case L'D':
        opCode = OpDel;
        break;

    case L'c':
    case L'C':
        opCode = OpCycle;
        break;

    default:
        printf("invalid command: use -add, -del, or -cycle\n");
        return 0;
    }

    if ( opCode == OpAdd && argc < 5 ) {
        printf("invalid arg: %ws -add <adapter name> address mask\n", argv[0] );
        return 0;
    }
    else if ( opCode == OpCycle && argc < 6 ) {
        printf("invalid arg: %ws -cycle <adapter name> address mask <cycle sleep time>\n", argv[0] );
        return 0;
    }
    else if ( opCode == OpDel && argc < 3 ) {
        printf("invalid arg: %ws -del <NTE context>\n", argv[0] );
        return 0;
    }

    if ( opCode == OpAdd || opCode == OpCycle ) {
        DWORD byte1;
        DWORD byte2;
        DWORD byte3;
        DWORD byte4;

        status = MprConfigServerConnect( NULL, &mprConfig );
        if ( status != NO_ERROR ) {
            printf("Can't get handle to MprConfig - %u\n", status );
            return status;
        }

        status = MprConfigGetGuidName(mprConfig, argv[2], &guidName[14], sizeof(guidName ));
        if (status != NO_ERROR ) {
            printf("Can't get GUID name for '%ws' - %u\n", argv[2], status );
        }

        status = GetAdapterIndex( guidName, &adapterIndex );
        if ( status != NO_ERROR ) {
            printf("Error getting adapter index for '%ws' - %u\n",
                   guidName, status);
            return status;
        }

        swscanf(argv[3], L"%u.%u.%u.%u",
                &byte1,
                &byte2,
                &byte3,
                &byte4);

        ipAddress.S_un.S_un_b.s_b1 = (CHAR)byte1;
        ipAddress.S_un.S_un_b.s_b2 = (CHAR)byte2;
        ipAddress.S_un.S_un_b.s_b3 = (CHAR)byte3;
        ipAddress.S_un.S_un_b.s_b4 = (CHAR)byte4;

        swscanf(argv[4], L"%u.%u.%u.%u",
                &byte1,
                &byte2,
                &byte3,
                &byte4);

        ipMask.S_un.S_un_b.s_b1 = (CHAR)byte1;
        ipMask.S_un.S_un_b.s_b2 = (CHAR)byte2;
        ipMask.S_un.S_un_b.s_b3 = (CHAR)byte3;
        ipMask.S_un.S_un_b.s_b4 = (CHAR)byte4;
    }

    if ( opCode == OpAdd ) {
        status = AddIPAddress((IPAddr)ipAddress.s_addr,
                              (IPMask)ipMask.s_addr,
                              adapterIndex,
                              &nteContext,
                              &nteInstance);

        if ( status == NO_ERROR ) {
            printf("Added IP address %ws with mask %ws to adapter '%ws'\n",
                   argv[3], argv[4], argv[2]);
            printf("NTE context to use with delete: %u\n", nteContext);
        }
        else {
            printf("Failed to add IP address %ws with mask %ws to adapter '%ws' - %u\n",
                   argv[3], argv[4], argv[2], status);
        }
    }
    else if ( opCode == OpDel ) {
        nteContext = _wtoi( argv[2] );
        status = DeleteIPAddress( nteContext );
        printf("Delete status = %u\n", status );
    }
    else if ( opCode == OpCycle ) {
        DWORD   sleepTime = _wtoi( argv[5] );

        do {
            status = AddIPAddress((IPAddr)ipAddress.s_addr,
                                  (IPMask)ipMask.s_addr,
                                  adapterIndex,
                                  &nteContext,
                                  &nteInstance);

            if ( status == NO_ERROR ) {
                printf("Added IP address %ws with mask %ws to adapter '%ws'\n",
                       argv[3], argv[4], argv[2]);
                printf("NTE context to use with delete: %u\n", nteContext);
            }
            else {
                printf("Failed to add IP address %ws with mask %ws to adapter '%ws' - %u\n",
                       argv[3], argv[4], argv[2], status);
                return status;
            }

            Sleep( sleepTime * 1000 );

            status = DeleteIPAddress( nteContext );
            printf("Delete status = %u\n", status );

            Sleep( sleepTime * 1000 );
        } while ( TRUE );
    }

    return 0;
} // wmain

/* end ipaddr.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\holdrpc\holdrpc.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    holdrpc.c

Abstract:

    utility to test hold intracluster RPC feature

Author:

    Charlie Wickham (charlwi) 22-Jul-1999

Environment:

    User mode

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#define CMDWINDOW

#include "cluster.h"
#include "api_rpc.h"

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    main routine for utility. first arg is sleep time in seconds. 2nd through
    Nth arg are node names of cluster nodes

Arguments:

    standard command line args

Return Value:

    0 if it worked successfully

--*/

{
    DWORD           status;
    PWCHAR  lpszClusterName;
    WCHAR *strBinding = NULL;
    RPC_BINDING_HANDLE rpcHandle[10];
    DWORD numNodes;
    DWORD sleepTime;
    DWORD i;

    sleepTime = _wtoi( argv[1] );

    argc -= 2;
    numNodes = 0;
    while ( argc-- ) {
        lpszClusterName = argv[2 + numNodes];
        printf("Contacting node %ws\n", lpszClusterName );

        //
        // Determine which node we should connect to. If someone has
        // passed in NULL, we know we can connect to the cluster service
        // over LPC. Otherwise, use RPC.
        //
        if ((lpszClusterName == NULL) ||
            (lpszClusterName[0] == '\0')) {

            status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                              L"ncalrpc",
                                              NULL,
                                              L"clusapi",
                                              NULL,
                                              &strBinding);
            if (status != RPC_S_OK) {
                goto error_exit;
            }

            status = RpcBindingFromStringBindingW(strBinding, &rpcHandle[numNodes]);
            RpcStringFreeW(&strBinding);
            if (status != RPC_S_OK) {
                goto error_exit;
            }
        } else {

            //
            // Try to connect directly to the cluster.
            //
            status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                              L"ncadg_ip_udp",
                                              (LPWSTR)lpszClusterName,
                                              NULL,
                                              NULL,
                                              &strBinding);
            if (status != RPC_S_OK) {
                goto error_exit;
            }
            status = RpcBindingFromStringBindingW(strBinding, &rpcHandle[numNodes]);
            RpcStringFreeW(&strBinding);
            if (status != RPC_S_OK) {
                goto error_exit;
            }

            //
            // Resolve the binding handle endpoint
            //
            status = RpcEpResolveBinding(rpcHandle[numNodes],
                                         clusapi_v2_0_c_ifspec);
            if (status != RPC_S_OK) {
                goto error_exit;
            }
        }


        status = RpcBindingSetAuthInfoW(rpcHandle[numNodes],
                                        NULL,
                                        RPC_C_AUTHN_LEVEL_CONNECT,
                                        RPC_C_AUTHN_WINNT,
                                        NULL,
                                        RPC_C_AUTHZ_NAME);
        if (status != RPC_S_OK) {
            goto error_exit;
        }
        ++numNodes;
    }

    //
    // issue hold
    //
    for( i = 0; i < numNodes; ++i ) {
        status = ApiHoldRpcCalls(rpcHandle[i]);
        printf("Hold status for node %u = %u\n", i, status );
    }

    Sleep( sleepTime * 1000 );

    //
    // issue release
    //
    for( i = 0; i < numNodes; ++i ) {
        status = ApiReleaseRpcCalls(rpcHandle[i]);
        printf("Release status for node %u = %u\n", i, status );
    }

    for( i = 0; i < numNodes; ++i ) {
        RpcBindingFree( &rpcHandle[i] );
    }
    return 0;

error_exit:
    printf("died: status = %u\n", status );
    return status;

} // wmain

/* end holdrpc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\utils\whackspn\whackspn.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       whackspn.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-30-98   RichardW   Created
//
//----------------------------------------------------------------------------

#define LDAP_UNICODE    1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define SECURITY_WIN32
#include <rpc.h>
#include <sspi.h>
#include <secext.h>
#include <lm.h>
#include <winsock2.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>
#include <ntdsapi.h>
#include <stdio.h>
#include <stdlib.h>

#define NlPrint(x)  DPrint x;
#define NL_CRITICAL 0
#define NL_MISC     0

HANDLE  hGC ;

BOOL AddDollar = TRUE;

VOID
DPrint(
    DWORD   Level,
    PCHAR   FormatString,
    ...
    )
{
    va_list ArgList;

    va_start(ArgList, FormatString);
    vprintf( FormatString, ArgList );
    va_end( ArgList );
}

BOOL
FindDomainForServer(
    PWSTR Server,
    PWSTR Domain
    )
{
    ULONG NetStatus ;
    WCHAR LocalServerName[ 64 ];
    PDOMAIN_CONTROLLER_INFOW DcInfo ;

    wcsncpy( LocalServerName, Server, 63 );

    if ( AddDollar ) {
        wcscat( LocalServerName, L"$" );
    }


    NetStatus = DsGetDcNameWithAccountW(
                    NULL,
                    LocalServerName,
                    ( AddDollar ? UF_MACHINE_ACCOUNT_MASK : UF_NORMAL_ACCOUNT ),
                    L"",
                    NULL,
                    NULL,
                    DS_DIRECTORY_SERVICE_REQUIRED |
                        DS_RETURN_DNS_NAME,
                    &DcInfo );

    if ( NetStatus == 0 ) {
        wcscpy( Domain, DcInfo->DomainName );
        NetApiBufferFree( DcInfo );

        return TRUE ;
    } else {
        printf("can't find DC for %ws - %u\n", LocalServerName, NetStatus );
    } 

    return FALSE ;
}

DWORD
AddDnsHostNameAttribute(
    HANDLE  hDs,
    PWCHAR  Server,
    PWCHAR  DnsDomain
    )

{
    NET_API_STATUS NetStatus = NO_ERROR;
    ULONG CrackStatus = DS_NAME_NO_ERROR;

    LPWSTR DnsHostNameValues[2];
    LPWSTR SpnArray[3];
    LPWSTR DnsSpn = NULL;
    LPWSTR NetbiosSpn = NULL;

    LDAPModW DnsHostNameAttr;
    LDAPModW SpnAttr;
    LDAPModW *Mods[3] = {NULL};

    LDAP *LdapHandle = NULL;
    LDAPMessage *LdapMessage = NULL;
    PDS_NAME_RESULTW CrackedName = NULL;
    LPWSTR DnOfAccount = NULL;

    LPWSTR NameToCrack;
    DWORD SamNameSize;
    WCHAR SamName[ DNLEN + 1 + CNLEN + 1 + 1];
    WCHAR nameBuffer[ 256 ];

    ULONG LdapStatus;
    LONG LdapOption;

    LDAP_TIMEVAL LdapTimeout;
    ULONG MessageNumber;

    //
    // Ldap modify control needed to indicate that the
    // existing values of the modified attributes should
    // be left intact and the missing ones should be added.
    // Without this control, a modification of an attribute
    // that results in an addition of a value that already
    // exists will fail.
    //

    LDAPControl     ModifyControl = {
        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
        {
            0, NULL
        },
        FALSE
    };

    PLDAPControl    ModifyControlArray[2] =
    {
        &ModifyControl,
        NULL
    };

    //
    // Prepare DnsHostName modification entry
    //

    wcsncpy( nameBuffer, Server, sizeof( nameBuffer ) / sizeof( WCHAR ));
    wcscat( nameBuffer, L"." );
    wcscat( nameBuffer, DnsDomain );

    DnsHostNameValues[0] = nameBuffer;
    DnsHostNameValues[1] = NULL;

    //
    // If we set both DnsHostName and SPN, then DnsHostName is
    // missing, so add it. If we set DnsHostName only, then
    // DnsHostName already exists (but incorrect), so replace it.
    //
    if ( TRUE ) {
        DnsHostNameAttr.mod_op = LDAP_MOD_ADD;
    } else {
        DnsHostNameAttr.mod_op = LDAP_MOD_REPLACE;
    }
    DnsHostNameAttr.mod_type = L"DnsHostName";
    DnsHostNameAttr.mod_values = DnsHostNameValues;

    Mods[0] = &DnsHostNameAttr;
    Mods[1] = NULL;

    //
    // The name of the computer object is
    //  <NetbiosDomainName>\<NetbiosComputerName>$
    //

    wcscpy( SamName, DnsDomain );
    {
        PWCHAR p;

        p = wcschr( SamName, L'.' );
        *p = UNICODE_NULL;
    }

    wcscat( SamName, L"\\" );
    wcscat( SamName, Server );
    wcscat( SamName, L"$" );

    //
    // Crack the sam account name into a DN:
    //

    NameToCrack = SamName;
    NetStatus = DsCrackNamesW(
        hDs,
        0,
        DS_NT4_ACCOUNT_NAME,
        DS_FQDN_1779_NAME,
        1,
        &NameToCrack,
        &CrackedName );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: CrackNames failed on %ws for %ws: %ld\n",
                  DnsDomain,
                  SamName,
                  NetStatus ));
        goto Cleanup ;
    }

    if ( CrackedName->cItems != 1 ) {
        CrackStatus = DS_NAME_ERROR_NOT_UNIQUE;
        NlPrint(( NL_CRITICAL,
                  "SPN: Cracked Name is not unique on %ws for %ws: %ld\n",
                  DnsDomain,
                  SamName,
                  NetStatus ));
        goto Cleanup ;
    }

    if ( CrackedName->rItems[ 0 ].status != DS_NAME_NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: CrackNames failed on %ws for %ws: substatus %ld\n",
                  DnsDomain,
                  SamName,
                  CrackedName->rItems[ 0 ].status ));
        CrackStatus = CrackedName->rItems[ 0 ].status;
        goto Cleanup ;
    }
    DnOfAccount = CrackedName->rItems[0].pName;

    //
    // Open an LDAP connection to the DC and set useful options
    //

    LdapHandle = ldap_init( DnsDomain, LDAP_PORT );

    if ( LdapHandle == NULL ) {
        NetStatus = GetLastError();
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_init failed on %ws for %ws: %ld\n",
                  DnsDomain,
                  SamName,
                  NetStatus ));
        goto Cleanup;
    }

    // 30 second timeout
    LdapOption = 30;
    LdapStatus = ldap_set_optionW( LdapHandle, LDAP_OPT_TIMELIMIT, &LdapOption );
    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_set_option LDAP_OPT_TIMELIMIT failed on %ws for %ws: %ld: %s\n",
                  DnsDomain,
                  SamName,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }

    // Don't chase referals
    LdapOption = PtrToLong(LDAP_OPT_OFF);
    LdapStatus = ldap_set_optionW( LdapHandle, LDAP_OPT_REFERRALS, &LdapOption );
    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_set_option LDAP_OPT_REFERRALS failed on %ws for %ws: %ld: %s\n",
                  DnsDomain,
                  SamName,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }

#if 0
    // Set the option telling LDAP that I passed it an explicit DC name and
    //  that it can avoid the DsGetDcName.
    LdapOption = PtrToLong(LDAP_OPT_ON);
    LdapStatus = ldap_set_optionW( LdapHandle, LDAP_OPT_AREC_EXCLUSIVE, &LdapOption );
    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_set_option LDAP_OPT_AREC_EXCLUSIVE failed on %ws for %ws: %ld: %s\n",
                  DnsDomain,
                  SamName,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }
#endif

    //
    // Bind to the DC
    //

    LdapStatus = ldap_bind_s( LdapHandle,
                              NULL, // No DN of account to authenticate as
                              NULL, // Default credentials
                              LDAP_AUTH_NEGOTIATE );

    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: Cannot ldap_bind to %ws for %ws: %ld: %s\n",
                  DnsDomain,
                  SamName,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }


    //
    // Write the modifications
    //

    LdapStatus = ldap_modify_extW( LdapHandle,
                                   DnOfAccount,
                                   Mods,
                                   (PLDAPControl *) &ModifyControlArray,
                                   NULL,     // No client controls
                                   &MessageNumber );

    if ( LdapStatus != LDAP_SUCCESS ) {
        NlPrint(( NL_CRITICAL,
                  "SPN: Cannot ldap_modify on %ws for %ws: %ld: %s\n",
                  DnsDomain,
                  DnOfAccount,
                  LdapStatus,
                  ldap_err2stringA( LdapStatus )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }

    // Wait for the modify to complete
    LdapTimeout.tv_sec = 30;
    LdapTimeout.tv_usec = 0;
    LdapStatus = ldap_result( LdapHandle,
                              MessageNumber,
                              LDAP_MSG_ALL,
                              &LdapTimeout,
                              &LdapMessage );

    switch ( LdapStatus ) {
    case -1:
        NlPrint(( NL_CRITICAL,
                  "SPN: Cannot ldap_result on %ws for %ws: %ld: %s\n",
                  DnsDomain,
                  SamName,
                  LdapHandle->ld_errno,
                  ldap_err2stringA( LdapHandle->ld_errno )));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;

    case 0:
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_result timeout on %ws for %ws.\n",
                  DnsDomain,
                  SamName ));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;

    case LDAP_RES_MODIFY:
        if ( LdapMessage->lm_returncode != 0 ) {
            NlPrint(( NL_CRITICAL,
                      "SPN: Cannot ldap_result on %ws for %ws: %ld: %s\n",
                      DnsDomain,
                      SamName,
                      LdapMessage->lm_returncode,
                      ldap_err2stringA( LdapMessage->lm_returncode )));
            NetStatus = LdapMapErrorToWin32(LdapMessage->lm_returncode);
            goto Cleanup;
        }

        NlPrint(( NL_MISC,
                  "SPN: Set successfully on DC %ws\n",
                  DnsDomain ));
        break;  // This is what we expect

    default:
        NlPrint(( NL_CRITICAL,
                  "SPN: ldap_result unexpected result on %ws for %ws: %ld\n",
                  DnsDomain,
                  SamName,
                  LdapStatus ));
        NetStatus = LdapMapErrorToWin32(LdapStatus);
        goto Cleanup;
    }


Cleanup:

    //
    // Log the failure in the event log, if requested.
    // Try to output the most specific error.
    //

    if ( CrackedName ) {
        DsFreeNameResultW( CrackedName );
    }

    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
    }

    if ( LdapHandle != NULL ) {
        ldap_unbind_s( LdapHandle );
    }

    if ( DnsSpn ) {
        LocalFree( DnsSpn );
    }

    if ( NetbiosSpn ) {
        LocalFree( NetbiosSpn );
    }

    return NetStatus;
}

BOOL
AddHostSpn(
    PWSTR Server
    )
{
    WCHAR HostSpn[ 64 ];
    WCHAR Domain[ MAX_PATH ];
    WCHAR FlatName[ 64 ];
    HANDLE hDs ;
    ULONG NetStatus ;
    PWSTR Dot ;
    PDS_NAME_RESULTW Result ;
    LPWSTR Flat = FlatName;
    LPWSTR Spn = HostSpn ;

    wcscpy( HostSpn, L"HOST/" );
    wcscat( HostSpn, Server );

#if 1
    if ( !FindDomainForServer( Server, Domain )) {
        printf(" No domain controller for %ws found\n", Server );
        return FALSE ;
    }
#else
    wcscpy( Domain, L"ntdev.microsoft.com" );
#endif

    Dot = wcschr( Domain, L'.' );
    if ( Dot ) {
        *Dot = L'\0';
    }
    
    wcscpy( FlatName, Domain );

    if ( Dot ) {
        *Dot = L'.' ;
    }

    wcscat( FlatName, L"\\" );
    wcscat( FlatName, Server );
    if ( AddDollar ) {
        wcscat( FlatName, L"$" );
    }

    NetStatus = DsBindW( NULL, Domain, &hDs );

    if ( NetStatus != 0 ) {
        printf("Failed to bind to DC of domain %ws, %#x\n", 
               Domain, NetStatus );
        return FALSE ;
    }

    NetStatus = DsCrackNamesW(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0 ) {
        printf("Failed to crack name %ws into the FQDN, %#x\n",
               FlatName, NetStatus );

        DsUnBind( &hDs );

        return FALSE ;
    } else {
        DWORD i;
        BOOL foundFailure = FALSE;

        //
        // check the stat-i inside the struct
        //
        for ( i = 0; i < Result->cItems; ++i ) {
            if ( Result->rItems[i].status == DS_NAME_NO_ERROR ) {
                printf("Found domain\\name '%ws\\%ws' for Flatname '%ws' \n",
                       Result->rItems[i].pDomain,
                       Result->rItems[i].pName,
                       FlatName);
            } else {
                printf("Couldn't crack name for '%ws' - %u\n",
                       FlatName, Result->rItems[i].status);
                foundFailure = TRUE;
            }
        }

        if ( foundFailure ) {
            return FALSE;
        }
    }

    //
    // add DnsHostName attribute to this object
    //
    NetStatus = AddDnsHostNameAttribute( hDs, Server, Domain );
    if ( NetStatus != 0 ) {
        printf( "Failed to add DnsHostName attrib to '%ws.%ws', %#x\n",
                Server, Domain, NetStatus );

        return FALSE;
    }

    //
    // write the netbios based SPN
    //
    NetStatus = DsServerRegisterSpnW(
                    DS_SPN_ADD_SPN_OP,
                    L"HOST",
                    Result->rItems[0].pName);

    if ( NetStatus != 0 ) {
        printf("DsServerRegisterSpn Failed to assign SPN to '%ws', %#x\n",
               Result->rItems[0].pName, NetStatus );
    }

    NetStatus = DsWriteAccountSpnW(
                    hDs,
                    DS_SPN_ADD_SPN_OP,
                    Result->rItems[0].pName,
                    1,
                    &Spn );


    if ( NetStatus != 0 ) {
        printf("Failed to assign SPN '%ws' to account '%ws', %#x\n",
               HostSpn, Result->rItems[0].pName, NetStatus );
    }
    else {
        DWORD i;
        BOOL foundFailure = FALSE;

        //
        // check the stat-i inside the struct
        //
        for ( i = 0; i < Result->cItems; ++i ) {
            if ( Result->rItems[i].status == DS_NAME_NO_ERROR ) {
                printf("Assigned SPN '%ws' to account '%ws' \n",
                       HostSpn, Result->rItems[i].pName );
            } else {
                printf("WriteAccountSpn failed for '%ws' - %u\n",
                       HostSpn, Result->rItems[i].status);
                foundFailure = TRUE;
            }
        }

        if ( foundFailure ) {
            return FALSE;
        }
    }

    //
    // do it again with the DNS domain as well
    //
    wcscat( HostSpn, L"." );
    wcscat( HostSpn, Domain );

    NetStatus = DsWriteAccountSpnW(hDs,
                                   DS_SPN_ADD_SPN_OP,
                                   Result->rItems[0].pName,
                                   1,
                                   &Spn );


    if ( NetStatus != 0 ) {
        printf("Failed to assign SPN '%ws' to account '%ws', %#x\n",
               HostSpn, Result->rItems[0].pName, NetStatus );
    }
    else {
        DWORD i;
        BOOL foundFailure = FALSE;

        //
        // check the stat-i inside the struct
        //
        for ( i = 0; i < Result->cItems; ++i ) {
            if ( Result->rItems[i].status == DS_NAME_NO_ERROR ) {
                printf("Assigned SPN '%ws' to account '%ws' \n",
                       HostSpn, Result->rItems[i].pName );
            } else {
                printf("WriteAccountSpn failed for '%ws' - %u\n",
                       HostSpn, Result->rItems[i].status);
                foundFailure = TRUE;
            }
        }

        if ( foundFailure ) {
            return FALSE;
        }
    }

    DsFreeNameResultW( Result );

    DsUnBind( &hDs );


    return NetStatus == 0 ;

}

void __cdecl wmain (int argc, wchar_t *argv[])
{

    PWCHAR machineName;

    if ( argc < 2 ) {
        printf("usage:  %s [-$] machinename\n", argv[0] );
        exit(0);
    }

    if ( argv[1][0] == '-') {
        switch (argv[1][1]) {
            case '$':
                AddDollar = FALSE ;
                break;
            default:
                printf(" unrecognized option, '%s'\n", argv[1] );
                exit(0);

        }

        machineName = argv[2];

    }
    else {
        machineName = argv[1];
    }


    if ( AddHostSpn( machineName ) ) {
        printf("Updated object\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\cluster.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.cpp
//
//  Description:
//      Implementation of CCluster class
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Cluster.h"

//****************************************************************************
//
//  CCluster
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::CCluster(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCluster::CCluster(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CCluster::CCluster()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CCluster::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CCluster::S_CreateThis( 
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CCluster( pwszNameIn, pNamespaceIn );

} //*** CCluster::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  const SPropMapEntryArray *
//  CCluster::GetPropMap( void )
//
//  Description:
//      Retrieve the property maping table of the cluster.
//
//  Arguments:
//      None.
//
//  Return Values:
//      reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CCluster::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            PVD_PROP_CLUSTER_SECURITYDESCRIPTOR,
            CLUSREG_NAME_CLUS_SD,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_GROUPADMIN,
            CLUS_CLUS_GROUPADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_NETWORKADMIN,
            CLUS_CLUS_NETWORKADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_NETINTFACEADMIN,
            CLUS_CLUS_NETINTERFACEADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_NODEADMIN,
            CLUS_CLUS_NODEADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_RESADMIN,
            CLUS_CLUS_RESADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_RESTYPEADMIN,
            CLUS_CLUS_RESTYPEADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea (
                sizeof( s_rgpm ) / sizeof( SPropMapEntry ),
                s_rgpm
                );

    return &s_pmea;

} //*** CCluster::GetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CCluster::EnumInstance(
//      long                lFlagsIn,
//      IWbemCOntext *      pCtxIn,
//      IWbemObjectSing *   pHandlerIn
//      )
//
//  Description:
//      Enum cluster instance.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CCluster::EnumInstance(  
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    ) 
{
    SAFECLUSTER     shCluster;

    shCluster = OpenCluster( NULL );

    ClusterToWMI( shCluster, pHandlerIn );

    return WBEM_S_NO_ERROR;

} //*** CCluster::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CCluster::ClusterToWMI(
//      HCLUSTER            hClusterIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Translate a cluster objects to WMI object.
//
//  Arguments:
//      hClusterIn  -- Handle to cluster 
//      pHandlerIn  -- Pointer to WMI sink 
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CCluster::ClusterToWMI(
    HCLUSTER            hClusterIn,
    IWbemObjectSink *   pHandlerIn
    )
{   
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES,     FALSE },
        { CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES,        FALSE },
        { CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES,    TRUE },
        { CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES,       TRUE }
    };
    static UINT         s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    DWORD               dwError = ERROR_SUCCESS;
    CError              er;
    UINT                idx;
    CWbemClassObject    wco;

    m_pClass->SpawnInstance( 0, &wco );
    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList pl;
        er = pl.ScGetClusterProperties(
                hClusterIn,
                s_rgControl[ idx ].dwControl,
                NULL,
                0
                );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );

    } // for: each common property type

    //
    // cluster name
    //
    {
        DWORD       cchClusterName = MAX_PATH;
        CWstrBuf    wsbClusterName;

        wsbClusterName.SetSize( cchClusterName );
        dwError = GetClusterInformation(
            hClusterIn,
            wsbClusterName,
            &cchClusterName,
            NULL
            );
        if ( dwError == ERROR_MORE_DATA )
        {
            wsbClusterName.SetSize( ++cchClusterName );
            er = GetClusterInformation(
                hClusterIn,
                wsbClusterName,
                &cchClusterName,
                NULL
                );
        } // if: buffer was too small

        wco.SetProperty( wsbClusterName, PVD_PROP_CLUSTER_NAME );

    }

    //
    // network priority
    //
    {
        LPCWSTR     pwszNetworks;
        BSTR        pbstrNetworks[ MAX_PATH ];
        UINT        idx = 0;
        UINT        cSize;

        CClusterEnum cluEnum( hClusterIn, CLUSTER_ENUM_INTERNAL_NETWORK );

        // bugbug   can you always clean up
        while ( ( pwszNetworks =  cluEnum.GetNext() ) != NULL )
        {
            pbstrNetworks[ idx ]  = SysAllocString( pwszNetworks );
            idx++;
        }
        wco.SetProperty(
            idx,
            pbstrNetworks,
            PVD_PROP_CLUSTER_NETWORK
            );
        cSize = idx;
        for ( idx = 0 ; idx < cSize ; idx++ )
        {
            SysFreeString( pbstrNetworks[ idx ] );
        }
    }

    //
    // quorum resource
    //
    {
        CWstrBuf    wsbName;
        DWORD       cchName = MAX_PATH ;
        CWstrBuf    wsbDeviceName;
        DWORD       cchDeviceName = MAX_PATH;
        DWORD       dwLogSize;

        wsbName.SetSize( cchName );
        wsbDeviceName.SetSize( cchDeviceName );

        dwError = GetClusterQuorumResource(
                        hClusterIn,
                        wsbName,
                        &cchName,
                        wsbDeviceName,
                        &cchDeviceName,
                        &dwLogSize
                        );
        if ( dwError == ERROR_MORE_DATA )
        {
             wsbName.SetSize( ++cchName );
             wsbDeviceName.SetSize( ++cchDeviceName );
             er = GetClusterQuorumResource(
                        hClusterIn,
                        wsbName,
                        &cchName,
                        wsbDeviceName,
                        &cchDeviceName,
                        &dwLogSize
                        );
        }

        wco.SetProperty( wsbDeviceName, PVD_PROP_CLUSTER_FILE );
        wco.SetProperty( dwLogSize,     PVD_PROP_CLUSTER_LOGSIZE );
    }

    pHandlerIn->Indicate( 1, &wco );
    return;

} //*** CCluster::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CCluster::GetObject(
//      CObjPath &          rObjPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      retrieve cluster object based given object path
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CCluster::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    
    shCluster = OpenCluster( 
        rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
        );

    ClusterToWMI( shCluster, pHandlerIn );

    return WBEM_S_NO_ERROR;

} //*** CCluster::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CCluster::ExecuteMethod(
//      CObjPath &           rObjPathIn,
//      WCHAR *              pwszMethodNameIn,
//      long                 lFlagIn,
//      IWbemClassObject *   pParamsIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      execute methods defined in the mof for cluster 
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CCluster::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    CWbemClassObject    InArgs( pParamsIn );
    CError              er;
    
    shCluster = OpenCluster( NULL );

    if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_CLUSTER_RENAME ) == 0 )
    {
        _bstr_t bstrName;
        DWORD   dwReturn;
        InArgs.GetProperty( bstrName, PVD_MTH_CLUSTER_PARM_NEWNAME );
        dwReturn = SetClusterName( shCluster, bstrName );
        if ( dwReturn != ERROR_RESOURCE_PROPERTIES_STORED )
        {
            er = dwReturn;
        }
    } // if: create new group
    else if( _wcsicmp( pwszMethodNameIn, PVD_MTH_CLUSTER_SETQUORUM ) == 0 )
    {
        _bstr_t         bstrName;
        SAFERESOURCE    hResource;
        CObjPath        opPath;

        InArgs.GetProperty( bstrName, PVD_MTH_CLUSTER_PARM_RESOURCE );
        opPath.Init( bstrName );
        bstrName = opPath.GetStringValueForProperty( PVD_PROP_RES_NAME );
        hResource = OpenClusterResource( shCluster, bstrName );
        er = SetClusterQuorumResource(
            hResource,
            NULL,
            64000
            );
    } // else if: set quorum resource

    return WBEM_S_NO_ERROR;

} //*** CCluster::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CCluster::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      save this instance
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CCluster::PutInstance( 
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static  SGetSetControl  s_rgControl[] =
    {
        {
            CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES,
            CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES,
            CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static  DWORD   s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    CError          er;
    DWORD           dwError;
    SAFECLUSTER     shCluster;
    UINT    idx;

    shCluster = OpenCluster( NULL );
    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;

        er = plOld.ScGetClusterProperties(
                shCluster,
                s_rgControl[ idx ].dwGetControl,
                NULL,
                NULL,
                0
                );

        CClusterApi::SetObjectProperties(
            RgGetPropMap(),
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterControl(
                    shCluster,
                    NULL,
                    s_rgControl[ idx ].dwSetControl,
                    plNew.PbPropList(),
                    plNew.CbPropList(),
                    NULL,
                    0,
                    NULL
                    );
        }
    } // for: each control code

    //
    // network
    //
    {
        CClusPropList   plNetwork;
        DWORD           cNetworks = 0;
        _bstr_t *       pbstrNetworks = NULL;
        UINT            idx = 0;
        HNETWORK *      phNetworks = NULL;

        rInstToPutIn.GetProperty(
            &cNetworks,
            &pbstrNetworks,
            PVD_PROP_CLUSTER_NETWORK
            );
        try
        {
            phNetworks = new HNETWORK[ cNetworks ];

            for( idx = 0 ; idx < cNetworks ; idx++ )
            {
                *(phNetworks + idx) = NULL;
            }

            for ( idx = 0 ; idx < cNetworks ; idx++)
            {
                *( phNetworks + idx ) = OpenClusterNetwork(
                    shCluster,
                    *( pbstrNetworks + idx ) );
                if ( phNetworks == NULL )
                {
                    throw CProvException( GetLastError() );
                }
            }

            er = SetClusterNetworkPriorityOrder(
                shCluster,
                cNetworks,
                phNetworks
                );
        } // try
        catch ( ... )
        {
            for ( idx = 0 ; idx < cNetworks ; idx++)
            {
                if ( *( phNetworks + idx ) )
                {
                    CloseClusterNetwork( *( phNetworks + idx) );
                }
            }
            delete [] phNetworks;
            delete [] pbstrNetworks;
            throw;
        } // catch: ...

        //
        // clean up
        //
        for ( idx = 0 ; idx < cNetworks ; idx++)
        {
            if ( *( phNetworks + idx ) )
            {
                CloseClusterNetwork( *( phNetworks + idx) );
            }
        }
        delete [] phNetworks;
        delete [] pbstrNetworks;

    }

    //
    // quorum resource
    //
    {
        CWstrBuf        wsbName;
        DWORD           cchName = MAX_PATH;
        CWstrBuf        wsbDeviceName;
        DWORD           cchDeviceName = MAX_PATH;
        DWORD           dwLogSize;
        _bstr_t         bstrNewDeviceName;
        DWORD           dwNewLogSize;
        SAFERESOURCE    shResource;

        wsbName.SetSize( cchName );
        wsbDeviceName.SetSize( cchDeviceName );
        dwError = GetClusterQuorumResource(
                        shCluster,
                        wsbName,
                        &cchName,
                        wsbDeviceName,
                        &cchDeviceName,
                        &dwLogSize
                        );
        if ( dwError == ERROR_MORE_DATA )
        {
            wsbName.SetSize( ++cchName );
            wsbDeviceName.SetSize( ++cchDeviceName );
            er = GetClusterQuorumResource(
                        shCluster,
                        wsbName,
                        &cchName,
                        wsbDeviceName,
                        &cchDeviceName,
                        &dwLogSize
                        );
        } // if: buffer is too small

        rInstToPutIn.GetProperty( bstrNewDeviceName, PVD_PROP_CLUSTER_FILE );
        rInstToPutIn.GetProperty( &dwNewLogSize,    PVD_PROP_CLUSTER_LOGSIZE );
        if ( _wcsicmp( wsbDeviceName, bstrNewDeviceName )
          || dwLogSize != dwNewLogSize )
        {
            shResource = OpenClusterResource( shCluster, wsbName );

            er = SetClusterQuorumResource(
                    shResource,
                    bstrNewDeviceName,
                    dwNewLogSize
                    );
        } // if:

    }

    return WBEM_S_NO_ERROR;

} //*** CCluster::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CCluster::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      save this instance
//
//  Arguments:
//      rObjPathIn  -- ObjPath for the instance to be deleted
//      lFlagIn     -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////

SCODE
CCluster::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CCluster::DeleteInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\cluster.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.h
//
//  Implementation File:
//      Cluster.cpp
//
//  Description:
//      Definition of the CCluster class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CCluster;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCluster
//
//  Description:
//      Provider Implement for cluster
//
//--
//////////////////////////////////////////////////////////////////////////////
class CCluster : public CProvBase
{
public:

    CCluster::CCluster(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HCLUSTER            hClusterIn,
        IWbemObjectSink *   pHandlerIn
      );

}; //*** class CCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterapi.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterApi.h
//
//  Implementation File:
//      ClusterApi.cpp
//
//  Description:
//      Definition of the CClusterApi class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterApi;

//////////////////////////////////////////////////////////////////////////////
//  External Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusPropList;
class CWbemClassObject;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterApi
//
//  Description:
//      Wrap class for cluster Api
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterApi
{
public:

    static void GetObjectProperties(
        const SPropMapEntryArray *  pArrayIn,
        CClusPropList &             rPropListIn,
        CWbemClassObject &          rInstOut,
        BOOL                        fPrivateIn
        );

    static void SetObjectProperties(
        const SPropMapEntryArray *  rArrayIn,
        CClusPropList &             rPropListInout,
        CClusPropList &             rOldPropListIn,
        CWbemClassObject &          rInstIn,
        BOOL                        fPrivateIn
        );

/*  static void EnumClusterObject(
        DWORD               dwEnumTypeIn,
        IWbemClassObject *  pClassIn,
        IWbemObjectSink *   pHandlerIn,
        IWbemServices *     pServicesIn, 
        FPFILLWMI           pfnClusterToWmiIn
        );
*/

}; //*** class CClusterApi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterenum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterEnum.cpp
//
//  Description:
//      Implementation of CClusterEnum class
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterEnum.h"

//****************************************************************************
//
//  CClusterEnum
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterEnum::CClusterEnum(
//      HCLUSTER    hCluster,
//      DWORD       dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      hClusterIn      -- Cluster handle.
//      dwEnumTypeIn    -- Type of enumeration.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterEnum::CClusterEnum(
    HCLUSTER    hCluster,
    DWORD       dwEnumTypeIn
    )
    : m_pwszName( NULL )
    , m_hEnum( NULL )
    , m_Idx( 0 )
{
    m_hEnum = ClusterOpenEnum( hCluster, dwEnumTypeIn );

    m_cchName = 1024;
    m_pwszName = new WCHAR[ (m_cchName + 1) * sizeof( WCHAR ) ];

} //*** CClusterEnum::CClusterEnum()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterEnum::~CClusterEnum( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterEnum::~CClusterEnum( void )
{
    if ( m_pwszName )
    {
        delete [] m_pwszName;
    }
    if ( m_hEnum )
    {
        ClusterCloseEnum( m_hEnum );
    }

} //*** CClusterEnum::~CClusterEnum()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  const LPCWSTR
//  CClusterEnum::GetNext( void )
//
//  Description:
//      Get the next item from the enumeration.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to the next item name.
//
//--
//////////////////////////////////////////////////////////////////////////////
const LPCWSTR
CClusterEnum::GetNext( void )
{
    DWORD cchName = m_cchName;
    DWORD dwType;
    DWORD dwError;

    dwError = ClusterEnum(
                    m_hEnum,
                    m_Idx,
                    &dwType,
                    m_pwszName,
                    &cchName
                    );

    if ( dwError == ERROR_MORE_DATA )
    {
        delete [] m_pwszName;
        m_cchName = ++cchName;
        m_pwszName =  new WCHAR[ m_cchName * sizeof( WCHAR ) ];

        if ( m_pwszName != NULL )
        {
            dwError = ClusterEnum(
                            m_hEnum,
                            m_Idx,
                            &dwType,
                            m_pwszName,
                            &cchName
                            );
        } // if:
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        } // else:
    } // if: buffer is too small

    if ( dwError == ERROR_SUCCESS )
    {
        m_Idx++;
        return m_pwszName;
    }

    return NULL;

} //*** CClusterEnum::GetNext()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterapi.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterApi.cpp
//
//  Description:
//      Implementation of CClusterApi class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterApi.h"

#include "ClusterApi.tmh"

//****************************************************************************
//
//  CClusterApi
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterApi::GetObjectProperties(
//      const SPropMapEntryArray *   pArrayIn,
//      CClusPropList &             rPropListIn,
//      CWbemClassObject &          rInstOut,
//      BOOL                        fPrivateIn
//      )
//
//  Description:
//      Get object property from Property list, and save to WMI instance
//
//  Arguments:
//      pArrayIn        -- Array of property names whose value will be retrieve
//      rPropListIn     -- Reference to cluster object's proplist
//      rInstOut        -- Reference to WMI instance
//      fPrivateIn      -- TRUE = properties are private
//
//  Return Values:
//      none
//
//--
//////////////////////////////////////////////////////////////////////////////
void CClusterApi::GetObjectProperties(
    const SPropMapEntryArray *  pArrayIn,
    CClusPropList &             rPropListIn,
    CWbemClassObject &          rInstOut,
    BOOL                        fPrivateIn
    )
{
    DWORD   dwError;
    LPCWSTR pwszPropName;
    LPCWSTR pwszMofName;
    WCHAR   wsz[ MAX_PATH ];

    dwError = rPropListIn.ScMoveToFirstProperty();
    while ( dwError == ERROR_SUCCESS )
    {
        pwszPropName = NULL;
        pwszMofName = NULL;

        pwszPropName = rPropListIn.PszCurrentPropertyName();
        pwszMofName = pwszPropName;
        if ( pArrayIn )
        {
            pwszMofName = pArrayIn->PwszLookup( pwszPropName );
        }
        else if( fPrivateIn )
        {
            //
            // handle dynamic generate private property
            //
            pwszMofName = PwszSpaceReplace( wsz, pwszMofName, L'_' );
        }

        if ( pwszMofName != NULL )
        {
            try
            {
                switch ( rPropListIn.CpfCurrentValueFormat() )
                {
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                    {
                        rInstOut.SetProperty(
                            rPropListIn.CbhCurrentValue().pDwordValue->dw,
                            pwszMofName
                            );
                        break;
                    } // case: FORMAT_DWORD && FORMAT_LONG
                
                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                    case CLUSPROP_FORMAT_EXPANDED_SZ:
                    {
                        rInstOut.SetProperty(
                            rPropListIn.CbhCurrentValue().pStringValue->sz,
                            pwszMofName
                            );
                        break;
                    } // case: FORMAT_SZ && FORMAT_EXPAND_SZ && FORMAT_EXPANDED_SZ

                    case CLUSPROP_FORMAT_BINARY:
                    {
                        rInstOut.SetProperty(
                            rPropListIn.CbhCurrentValue().pBinaryValue->cbLength,
                            rPropListIn.CbhCurrentValue().pBinaryValue->rgb,
                            pwszMofName
                            );
                        break;
                    } // case: FORMAT_BINARY

                    case CLUSPROP_FORMAT_MULTI_SZ:
                    {
                        rInstOut.SetProperty(
                            rPropListIn.CbhCurrentValue().pMultiSzValue->cbLength,
                            rPropListIn.CbhCurrentValue().pMultiSzValue->sz,
                            pwszMofName
                            );
                        break;
                    } // case: FORMAT_MULTI_SZ

                    default:
                    {   
                        throw CProvException(
                            static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER ) );
                    }

                } // switch : property type
            } // try
            catch ( ... )
            {
            }
        } // if: MOF name found
        dwError = rPropListIn.ScMoveToNextProperty();
    } // while: proplist not empty
    
} //*** CClusterApi::GetObjectProperties()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterApi::SetObjectProperties(
//      const SPropMapEntryArray *  pArrayIn,
//      CClusPropList &             rPropListInout,
//      CClusPropList &             rOldPropListIn,
//      CWbemClassObject &          rInstIn,
//      BOOL                        fPrivateIn
//      )
//
//  Description:
//      set object property from Property list, and save to WMI instance
//
//  Arguments:
//      pArrayIn        -- Array of property names those value will be retrieve
//      rPropListInout  -- Reference to cluster object's proplist
//      rOldPropListIn  -- Reference to proplist with original value
//      rInstIn         -- Reference to WMI instance
//      fPrivateIn      -- TRUE = properties are private
//
//  Return Values:
//      none
//
//--
//////////////////////////////////////////////////////////////////////////////
void CClusterApi::SetObjectProperties(
    const SPropMapEntryArray *  pArrayIn,
    CClusPropList &             rPropListInout,
    CClusPropList &             rOldPropListIn,
    CWbemClassObject &          rInstIn,
    BOOL                        fPrivateIn
    )
{
    DWORD   dwError = 0;
    LPCWSTR pwszPropName = NULL;
    LPCWSTR pwszMofName = NULL;
    WCHAR   wsz[ MAX_PATH ];

    dwError = rOldPropListIn.ScMoveToFirstProperty();
    while ( ERROR_SUCCESS == dwError )
    {
        pwszPropName = NULL;
        pwszMofName = NULL;

        pwszPropName = rOldPropListIn.PszCurrentPropertyName();
        pwszMofName = pwszPropName;

        if ( pArrayIn )
        {
            pwszMofName = pArrayIn->PwszLookup( pwszPropName );
        }
        else if ( fPrivateIn )
        {
            //
            // handle dynamic generate private property
            //
            pwszMofName = PwszSpaceReplace( wsz, pwszMofName, L'_' );
        }

        if ( pwszMofName != NULL )
        {
            try {
                switch ( rOldPropListIn.CpfCurrentValueFormat() )
                {
                    case CLUSPROP_FORMAT_DWORD:
                    {
                        {
                            DWORD dwNewValue = 0;
                            DWORD dwOldValue = 0;
                            // bugbug, need to handle NULL value for property
                            rInstIn.GetProperty( &dwNewValue, pwszMofName );

                            rPropListInout.ScAddProp(
                                pwszPropName,
                                dwNewValue,
                                rOldPropListIn.CbhCurrentValue().pDwordValue->dw
                                );
                        }
                        break;
                    } // case: FORMAT_DWORD

                    case CLUSPROP_FORMAT_LONG:
                    {
                        {
                            LONG lNewValue = 0;
                            LONG lOldValue = 0;
                            // bugbug, need to handle NULL value for property
                            rInstIn.GetProperty( (DWORD *) &lNewValue, pwszMofName );

                            rPropListInout.ScAddProp(
                                pwszPropName,
                                lNewValue,
                                rOldPropListIn.CbhCurrentValue().pLongValue->l
                                );
                        }
                        break;
                    } // case: FORMAT_DWORD

                    case CLUSPROP_FORMAT_SZ:
                    {
                        {
                            _bstr_t bstrNewValue;
                            rInstIn.GetProperty( bstrNewValue, pwszMofName );
                            rPropListInout.ScAddProp( pwszPropName, bstrNewValue );
                        } 
                        break;
                    } // case: FORMAT_SZ

                    case CLUSPROP_FORMAT_EXPAND_SZ:
                    {
                        {
                            _bstr_t bstrNewValue;
                            rInstIn.GetProperty( bstrNewValue, pwszMofName );
                            rPropListInout.ScAddExpandSzProp( pwszPropName, bstrNewValue );
                        } 
                        break;
                    } // case: FORMAT_SZ

                    case CLUSPROP_FORMAT_MULTI_SZ:
                    {
                        
                        {
                            LPWSTR      pwsz = NULL;
                            DWORD       dwSize;

                            rInstIn.GetPropertyMultiSz(
                                &dwSize,
                                &pwsz,
                                pwszMofName
                                );
                            rPropListInout.ScAddMultiSzProp(
                                pwszPropName,
                                pwsz,
                                rOldPropListIn.CbhCurrentValue().pMultiSzValue->sz
                                );
                            delete [] pwsz;
                        }
                        break;
                    } // case: FORMAT_MULTI_SZ

                    case CLUSPROP_FORMAT_BINARY:
                    {
                        {
                            DWORD dwSize;
                            PBYTE pByte = NULL;

                            rInstIn.GetProperty(
                                &dwSize,
                                &pByte,
                                pwszMofName
                                );
                            rPropListInout.ScAddProp(
                                pwszPropName,
                                pByte,
                                dwSize,
                                rOldPropListIn.CbhCurrentValue().pBinaryValue->rgb,
                                rOldPropListIn.CbhCurrentValue().pBinaryValue->cbLength
                                );
                            delete [] pByte;
                        }
                        break;
                    } // case: FORMAT_BINARY

                    default:
                    {
                        TracePrint(("SetCommonProperties: unknown prop type %d", rOldPropListIn.CpfCurrentValueFormat() ));
                        throw CProvException( 
                            static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER ) );
                    }

                } // switch: on property type
            } catch (CProvException& eh) {
                if (eh.hrGetError() == WBEM_E_NOT_FOUND) {
                    TracePrint(("SetCommonProperties: Property %ws not found. Benign error. Continuing", pwszPropName));
                } else {
                    TracePrint(("SetCommonProperties: exception %x. PropName = %ws, MofName = %ws", 
                        eh.hrGetError(), pwszPropName, pwszMofName));
                    throw;
                }
            }
        }           
        dwError = rOldPropListIn.ScMoveToNextProperty();
    } // while: no error occurred

    return;

} //*** CClusterApi::SetObjectProperties()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterenum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.h
//
//  Implementation File:
//      Cluster.cpp
//
//  Description:
//      Definition of the CClusterEnum class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterEnum;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterEnum
//
//  Description:
//      Enumerate cluster objects.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterEnum
{
public:
    CClusterEnum(
        HCLUSTER    hClusterIn,
        DWORD       dwEnumTypeIn
        );
    virtual ~CClusterEnum( void);
    const LPCWSTR GetNext( void );

protected:
    LPWSTR      m_pwszName;
    HCLUSENUM   m_hEnum;
    UINT        m_Idx;
    DWORD       m_cchName;
    DWORD       m_dwType;

}; //*** class CClusterEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clustergroup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterGroup.h
//
//  Implementation File:
//      ClusterGroup.cpp
//
//  Description:
//      Definition of the CClusterGroup class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterGroup;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterGroup
//
//  Description:
//      Provider Implement for cluster Group
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterGroup : public CProvBase
{

//
// constructor
//
public:
    CClusterGroup::CClusterGroup(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumType = 0
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HGROUP              hGroupIn,
        IWbemObjectSink *   pHandlerIn
        );

}; //*** class CClusterGroup

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterGroupRes
//
//  Description:
//      Provider Implement for cluster group resources
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterGroupRes : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterGroupRes::CClusterGroupRes(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterGroupRes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternetinterface.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name: CClusterNetInterface.cpp
//
//  Description:    
//      Implementation of CClusterNetInterface class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNetInterface.h"

#include "ClusterNetInterface.tmh"
//****************************************************************************
//
//  CClusterNetInterface
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetInterface::CClusterNetInterface(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNetInterface::CClusterNetInterface(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{
    
} //*** CClusterNetInterface::CClusterNetInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterNetInterface::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           // dwEnumTypeIn
//    )
//
//  Description:
//      Create a cluster network interface object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNetInterface::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterNetInterface( pwszNameIn, pNamespaceIn );

} // CClusterNetInterface::S_CreateThis


//////////////////////////////////////////////////////////////////////////////
//++
//
//  const SPropMapEntryArray *
//  CClusterNetInterface::RgGetPropMap( void )
//
//  Description:
//      Retrieve the property maping table of the cluster node.
//
//  Arguments:
//      None.
//
//  Return Values:
//      reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterNetInterface::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            PVD_PROP_NETINTERFACE_DEVICEID,
            CLUSREG_NAME_NETIFACE_NAME,
            SZ_TYPE,
            READONLY
        },
        {
            PVD_PROP_NETINTERFACE_SYSTEMNAME,
            CLUSREG_NAME_NETIFACE_NODE,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NETIFACE_ADAPTER_ID,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NETIFACE_ENDPOINT,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof( s_rgpm ) /sizeof( SPropMapEntry ),
                s_rgpm
                );

    return &s_pmea;

} //*** CClusterNetInterface::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetInterface::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enum cluster instance
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFENETINTERFACE    shNetInterface;
    LPCWSTR             pwszName;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum(
        shCluster,
        CLUSTER_ENUM_NETINTERFACE );


    while ( pwszName = cluEnum.GetNext() )
    {
        shNetInterface = OpenClusterNetInterface( shCluster, pwszName );

        ClusterToWMI( shNetInterface, pHandlerIn );
    }

    return WBEM_S_NO_ERROR;

} //*** CClusterNetInterface::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterResource::ClusterToWMI(
//      HNETINTERFACE       hNetInterfaceIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Translate a cluster network interface object to WMI object.
//
//  Arguments:
//      hNetInterfaceIn     -- handle to network interface
//      pHandlerIn          -- Pointer to WMI sink
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterNetInterface::ClusterToWMI(
    HNETINTERFACE       hNetInterfaceIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] = 
    {
        { CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES,    FALSE },
        { CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES,       FALSE },
        { CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES,   TRUE },
        { CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES,      TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    CError              er;
    UINT                idx;

    m_pClass->SpawnInstance( 0, & wco);
    for( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList pl;
        er = pl.ScGetNetInterfaceProperties(
            hNetInterfaceIn,
            s_rgControl[ idx ].dwControl,
            NULL,
            0 );
   
        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );
    } // for: each control code
    
    wco.SetProperty(
        GetClusterNetInterfaceState( hNetInterfaceIn),
        PVD_PROP_NETINTERFACE_STATE
        );

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;
        er = ClusterNetInterfaceControl( 
                    hNetInterfaceIn,
                    NULL,
                    CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS,  // this control code
                    NULL,                                      // input buffer (not used)
                    0,                                         // input buffer size (not used)
                    & dwOut,
                    sizeof( DWORD ),
                    & cbReturned
                    );
        wco.SetProperty(
            dwOut,
            PVD_PROP_CHARACTERISTIC
            );
    }

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetInterface::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve cluster network interface object based given object path.
//
//  Arguments:
//      rObjPathIn      -- Object path to cluster object
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFENETINTERFACE    shNetInterface;
    
    shCluster = OpenCluster( NULL ) ;
    shNetInterface = OpenClusterNetInterface(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
        );

    ClusterToWMI( shNetInterface, pHandlerIn );
    return WBEM_S_NO_ERROR;

} //*** CClusterNetInterface::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetInterface::ExecuteMethod(
//
//  Description:
//      Execute methods defined in the mof for cluster network interface.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    ) 
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNetInterface::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetInterface::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES,
            CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD            s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t            bstrName;
    SAFECLUSTER      shCluster;
    SAFENETINTERFACE shNetwork;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, L"DeviceID" );

    shCluster = OpenCluster( NULL );
    shNetwork = OpenClusterNetInterface( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;

        er = plOld.ScGetNetInterfaceProperties(
            shNetwork,
            s_rgControl[ idx ].dwGetControl,
            NULL,
            NULL,
            0
            );

        CClusterApi::SetObjectProperties(
            RgGetPropMap(),
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterNetInterfaceControl( 
                    shNetwork,
                    NULL,
                    s_rgControl[ idx ].dwSetControl,
                    plNew.PbPropList(),
                    plNew.CbPropList(),
                    NULL,
                    0,
                    NULL
                    );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterNetInterface::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetInterface::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn  -- ObjPath for the instance to be deleted
//      lFlagIn     -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNetInterface::DeleteInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clustergroup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterGroup.cpp
//
//  Description:    
//      Implementation of CClusterGroup class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterGroup.h"
#include "ClusterGroup.tmh"

//****************************************************************************
//
//  CClusterGroup
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::CClusterGroup(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterGroup::CClusterGroup(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{
} //*** CClusterGroup::CClusterGroup()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterGroup::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           // dwEnumTypeIn
//      )
//
//  Description:
//      Create a CClusterGroup object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterGroup::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    TracePrint(("CClusterGroup::S_CreatThis for Name = %ws, EnumType %u\n", pwszNameIn, dwEnumTypeIn )); 
    return new CClusterGroup( pwszNameIn, pNamespaceIn );

} //*** CClusterGroup::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  const SPropMapEntryArray *
//  CClusterGroup::GetPropMap( void )
//
//  Description:
//      Retrieve the property maping table of the cluster group.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Reference to the array of property maping table.
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterGroup::RgGetPropMap( void )
{

    static SPropMapEntry s_rgpm[] =
    {
        {
            NULL,
            CLUSREG_NAME_GRP_LOADBAL_STATE,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pamea(
                sizeof( s_rgpm ) / sizeof( SPropMapEntry ),
                s_rgpm
                );

    return &s_pamea;

} //*** CClusterGroup::GetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterGroup::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enum cluster instance.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFEGROUP       shGroup;
    LPCWSTR         pwszGroup;

    TracePrint(( "CClusterGroup::EnumInstance, pHandlerIn = %p\n", pHandlerIn ));
    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_GROUP );

    while ( ( pwszGroup = cluEnum.GetNext() ) != NULL )
    {
        shGroup = OpenClusterGroup( shCluster, pwszGroup );

        ClusterToWMI( shGroup, pHandlerIn );

    } // while: more groups

    return WBEM_S_NO_ERROR;

} //*** CClusterGroup::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterGroup::ClusterToWMI(
//      HGROUP              hGroupIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Translate a cluster group object to WMI object.
//
//  Arguments:
//      hGroupIn    -- Handle to group
//      pHandlerIn  -- Handler
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterGroup::ClusterToWMI(
    HGROUP              hGroupIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES,   FALSE },
        { CLUSCTL_GROUP_GET_COMMON_PROPERTIES,      FALSE },
        { CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES,  TRUE },
        { CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES,     TRUE }
    };
    static UINT         s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CError              er;
    UINT                idx;
    CWbemClassObject    wco;

    m_pClass->SpawnInstance( 0, &wco );
    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList pl;
        er = pl.ScGetGroupProperties(
                    hGroupIn,
                    s_rgControl[ idx ].dwControl,
                    NULL,
                    0
                    );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );

    } // for: each common property type

    // 
    // set prefered nodelist
    //
    {
        SAFEGROUPENUM   shGroupEnum;
        DWORD           dwIndex = 0;
        DWORD           dwType;
        DWORD           cchName = MAX_PATH ;
        CWstrBuf        wsbName;
        DWORD           dwError;
        BSTR            rgbstrNode[MAX_PATH];
        DWORD           cbstrNode = 0;

        wsbName.SetSize( cchName );
        shGroupEnum = ClusterGroupOpenEnum(
                        hGroupIn,
                        CLUSTER_GROUP_ENUM_NODES
                        );
        for( ; ; )
        {
            DWORD cch = cchName;
            dwError = ClusterGroupEnum(
                        shGroupEnum,
                        dwIndex,
                        &dwType,
                        wsbName,
                        &cch
                        );
            if ( dwError == ERROR_MORE_DATA )
            {
                cchName = ++cch;
                wsbName.SetSize( cch );
                dwError = ClusterGroupEnum(
                                shGroupEnum,
                                dwIndex,
                                &dwType,
                                wsbName,
                                &cch
                                );
            } // if: more data

            if ( dwError == ERROR_SUCCESS )
            {
                rgbstrNode[ dwIndex ] = SysAllocString ( wsbName );
                if ( rgbstrNode[ dwIndex ] == NULL )
                {
                    for( dwIndex = 0 ; dwIndex < cbstrNode ; dwIndex++ )
                    {
                        SysFreeString( rgbstrNode[ dwIndex ] );
                    }
                    CProvException( static_cast< HRESULT >( WBEM_E_OUT_OF_MEMORY ) );
                }
                dwIndex++;
                cbstrNode = dwIndex;
            } // if: success
            else
            {
                break;
            } // else

        } // for: cluster group

        if( cbstrNode > 0 )
            {
            wco.SetProperty(
                cbstrNode,
                rgbstrNode,
                PVD_PROP_NODELIST
                );
            // bugbug, how to clean up when exception occured
            for ( dwIndex = 0 ; dwIndex < cbstrNode ; dwIndex++ )
            {
                SysFreeString( rgbstrNode[ dwIndex ]  );
            }

        } // if: has valid group
    }
    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;
        er = ClusterGroupControl( 
            hGroupIn,
            NULL,
            CLUSCTL_GROUP_GET_CHARACTERISTICS,
            NULL,
            0,
            &dwOut,
            sizeof( DWORD ),
            &cbReturned
            );
        wco.SetProperty(
            dwOut,
            PVD_PROP_CHARACTERISTIC
            );
    }

    pHandlerIn->Indicate( 1, &wco );
    return;

} //*** CClusterGroup::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterGroup::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve cluster group object based given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFEGROUP       shGroup;
    
    shCluster = OpenCluster( NULL );
    shGroup = OpenClusterGroup(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
        );

    ClusterToWMI( shGroup, pHandlerIn );

    return WBEM_S_NO_ERROR;
        
} //*** CClusterGroup::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterGroup::ExecuteMethod(
//      CObjPath &           rObjPathIn,
//      WCHAR *              pwszMethodNameIn,
//      long                 lFlagIn,
//      IWbemClassObject *   pParamsIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Execute methods defined in the mof for cluster node.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    CWbemClassObject    InArgs( pParamsIn );
    CError              er;
    
    shCluster = OpenCluster( NULL );
    //
    // static method
    //
    if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_GROUP_CREATEGROUP ) == 0 )
    {
        
        _bstr_t bstrNewGroup;
        InArgs.GetProperty( bstrNewGroup, PVD_MTH_GROUP_PARM_GROUPNAME );
        shGroup = CreateClusterGroup( shCluster, bstrNewGroup );

        er = OnlineClusterGroup( shGroup, NULL );
    } // if: CREATEGROUP
    else
    {
        shGroup = OpenClusterGroup(
            shCluster,
            rObjPathIn.GetStringValueForProperty( PVD_PROP_GROUP_NAME )
            );
    
        if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_GROUP_TAKEOFFLINE ) == 0 )
        {
            er = OfflineClusterGroup( shGroup );
        } // if: TAKEOFFLINE
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_GROUP_BRINGONLINE ) == 0 )
        {
            er = OnlineClusterGroup( shGroup, NULL );
        } // else if: BRINGONLINE
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_GROUP_MOVETONEWNODE ) == 0 )
        {
            _bstr_t     bstrNewNode;
            SAFENODE    shNode;
            InArgs.GetProperty( bstrNewNode, PVD_MTH_GROUP_PARM_NODENAME );
            shNode = OpenClusterNode( shCluster, bstrNewNode );
            er = MoveClusterGroup( shGroup, shNode );
        } // else if: MOVETONEWNODE
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_GROUP_RENAME ) == 0 )
        {
            _bstr_t     bstrNewName;
            InArgs.GetProperty( bstrNewName, PVD_MTH_GROUP_PARM_NEWNAME );
            er = SetClusterGroupName( shGroup, bstrNewName );
        } // else if: RENAME
        else
        {
            er = static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
        }
    } // else: not create new group

    
    return WBEM_S_NO_ERROR;

} //*** CClusterGroup::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterGroup::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        { 
            CLUSCTL_GROUP_GET_COMMON_PROPERTIES,
            CLUSCTL_GROUP_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES,
            CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD    s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFEGROUP       shGroup;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );
    shGroup = OpenClusterGroup( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;
        
        er = plOld.ScGetGroupProperties(
                shGroup,
                s_rgControl[ idx ].dwGetControl,
                NULL,
                NULL,
                0
                );

        CClusterApi::SetObjectProperties(
            NULL,
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterGroupControl( 
                shGroup,
                NULL,
                s_rgControl[ idx ].dwSetControl,
                plNew.PbPropList(),
                plNew.CbPropList(),
                NULL,
                0,
                NULL
                );
        }

    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterGroup::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterGroup::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFEGROUP       shGroup;
    CError          er;

    shCluster = OpenCluster( NULL );
    shGroup = OpenClusterGroup(
                    shCluster,
                    rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
                    );

    er = DeleteClusterGroup( shGroup );

    return WBEM_S_NO_ERROR;

} //*** CClusterGroup::DeleteInstance()

//****************************************************************************
//
//  CClusterGroupRes
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroupRes::CClusterGroupRes(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterGroupRes::CClusterGroupRes(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterGroupRes::CClusterGroupRes()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterGroupRes::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterGroupRes::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterGroupRes(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterGroupRes::S_CreateThis()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterGroupRes::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve the property maping table of the cluster node active resource.
//
//  Arguments:
//      lFlagsIn        -- 
//      pCtxIn          -- 
//      pHandlerIn      -- 
//
//  Return Values:
//      SCODE
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroupRes::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    SAFERESOURCE        shResource;
    LPCWSTR             pwszName = NULL;
    DWORD               cchGroupName = MAX_PATH;
    CWstrBuf            wsbGroupName;
    DWORD               cch;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
 
    wsbGroupName.SetSize( cchGroupName );
    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );


    m_wcoGroup.SpawnInstance( 0, &wcoGroup );
    m_wcoPart.SpawnInstance( 0, &wcoPart );


    while ( ( pwszName = clusEnum.GetNext() ) != NULL )
    {
        CWbemClassObject    wco;
        DWORD               dwState;

        cch = cchGroupName;
        wcoPart.SetProperty( pwszName, PVD_PROP_RES_NAME );
        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        shResource = OpenClusterResource( shCluster, pwszName );

        dwState = GetClusterResourceState(
                        shResource,
                        NULL,
                        0,
                        wsbGroupName,
                        &cch
                        );
        if ( dwState == ClusterResourceStateUnknown )
        {
            dwError = GetLastError();
            if ( dwError == ERROR_MORE_DATA )
            {
                cchGroupName = ++cch;
                wsbGroupName.SetSize( cch );
                dwState = GetClusterResourceState(
                                shResource,
                                NULL,
                                0,
                                wsbGroupName,
                                &cch
                                );
            } // if:  more data
            else
            {
                er = dwError;
            }
        } // if: state unknown

        wcoGroup.SetProperty( wsbGroupName, CLUSREG_NAME_GRP_NAME );
        wcoGroup.GetProperty( bstrGroup,    PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, &wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR) bstrPart,  PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, &wco );

    } // while: more resources

    return WBEM_S_NO_ERROR;

} //*** CClusterGroupRes::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternetinterface.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusterNetInterface.h
//
//  Implementation File:
//      CClusterNetInterface.cpp
//
//  Description:
//      Definition of the CClusterNetInterface class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNetInterface;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNetInterface
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNetInterface : public CProvBase
{
//
// constructor
//
public:
    CClusterNetInterface::CClusterNetInterface(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           // dwEnumTypeIn
        );

protected:
    
    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HNETINTERFACE       hNetInterfaceIn,
        IWbemObjectSink *   pHandlerIn
        );

}; //*** class CClusterNetInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternetworks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusterNetwork.h
//
//  Implementation File:
//      CClusterNetwork.cpp
//
//  Description:
//      Definition of the CCClusterNetwork class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNetwork;
class CClusterNetNetInterface;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNetwork
//
//  Description:
//      Provider Implement for cluster Node
//
//  Inheritance:
//      CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNetwork : public CProvBase  
{
//
// constructor
//
public:
    CClusterNetwork::CClusterNetwork(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:
    
    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HNETWORK            hNetworkIn,
        IWbemObjectSink *   pHandlerIn
      );

}; //*** class CClusterNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNetNetInterface
//
//  Description:
//      Implement cluster network and netinterface association
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNetNetInterface : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterNetNetInterface::CClusterNetNetInterface(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterNetNetInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternetworks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusterNetwork.cpp
//
//  Description:
//      Implementation of CClusterNetwork class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNetworks.h"

//****************************************************************************
//
//  CClusterNetwork
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetwork::CClusterNetwork(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNetwork::CClusterNetwork(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    :CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterNetwork::CClusterNetwork()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterNetwork::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           // dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNetwork::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterNetwork( pwszNameIn, pNamespaceIn );

} //*** CClusterNetwork::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  const SPropMapEntryArray *
//  CClusterNetwork::RgGetPropMap( void )
//
//  Description:
//      Retrieve the property maping table of the cluster network.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Reference to the array of property maping table.
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterNetwork::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            NULL,
            CLUSREG_NAME_NET_PRIORITY,
            SZ_TYPE,
            READONLY
        }
        ,
        {
            NULL,
            CLUSREG_NAME_NET_TRANSPORT,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof( s_rgpm ) /sizeof( SPropMapEntry ),
                s_rgpm
                );

    return & s_pmea;

} //*** CClusterNetwork::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetwork::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      enum cluster instance
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetwork::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENETWORK     shNetwork;
    LPCWSTR         pwszName;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_NETWORK );

    while ( pwszName = cluEnum.GetNext() )
    {
        shNetwork = OpenClusterNetwork( shCluster, pwszName );

        ClusterToWMI( shNetwork, pHandlerIn );

    } // while: more networks

    return WBEM_S_NO_ERROR;

} //*** CClusterNetwork::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterResource::ClusterToWMI(
//      HNETWORK            hNetworkIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Translate a cluster resource objects to WMI object.
//
//  Arguments:
//      hResourceIn     -- handle to resource 
//      pHandlerIn      -- Pointer to WMI sink 
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterNetwork::ClusterToWMI(
    HNETWORK            hNetworkIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] = 
    {
        { CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES,     FALSE },
        { CLUSCTL_NETWORK_GET_COMMON_PROPERTIES,        FALSE },
        { CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES,    TRUE },
        { CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES,       TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    CError              er;
    UINT                idx;

    m_pClass->SpawnInstance( 0, & wco );
    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList pl;
        er = pl.ScGetNetworkProperties(
                hNetworkIn,
                s_rgControl[ idx ].dwControl,
                NULL,
                0
                );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );
    } // for: each control code
    
    {
        DWORD dwState = GetClusterNetworkState( hNetworkIn );

        wco.SetProperty( dwState, PVD_PROP_NETWORK_STATE );
    }

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;
        er = ClusterNetworkControl( 
                hNetworkIn,
                NULL,
                CLUSCTL_NETWORK_GET_CHARACTERISTICS,    // this control code
                NULL,                                   // input buffer (not used)
                0,                                      // input buffer size (not used)
                & dwOut,
                sizeof( DWORD ),
                & cbReturned
                );
        wco.SetProperty(
                dwOut,
                PVD_PROP_CHARACTERISTIC
                );
    }

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetwork::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve cluster node object based given object path.
//
//  Arguments:
//      rObjPathIn      -- Object path to cluster object
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetwork::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENETWORK     shNetwork;
    
    shCluster = OpenCluster( NULL );
    shNetwork = OpenClusterNetwork(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
        );

    ClusterToWMI( shNetwork, pHandlerIn );
    return WBEM_S_NO_ERROR;

} //*** CClusterNetwork::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetwork::ExecuteMethod(
//      CObjPath &           rObjPathIn,
//      WCHAR *              pwszMethodNameIn,
//      long                 lFlagIn,
//      IWbemClassObject *   pParamsIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Execute methods defined in the mof for cluster network.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetwork::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    CWbemClassObject    wcoInArgs( pParamsIn );
    CError              er;
    
    shCluster = OpenCluster( NULL );

    if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_NETWORK_RENAME ) == 0 )
    {
        
        _bstr_t     bstrName;
        SAFENETWORK shNetwork;
        
        wcoInArgs.GetProperty( bstrName, PVD_MTH_NETWORK_PARM_NEWNAME );
        shNetwork = OpenClusterNetwork(
            shCluster,
            rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
            );
        er = SetClusterNetworkName( shNetwork, bstrName );
        
    } // if: RENAME
    else
    {
       er = static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    }

    return WBEM_S_NO_ERROR;

} //*** CClusterNetwork::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetwork::PutInstance
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetwork::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_NETWORK_GET_COMMON_PROPERTIES,
            CLUSCTL_NETWORK_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES,
            CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD            s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFENETWORK     shNetwork;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );
    shNetwork = OpenClusterNetwork( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;
        er = plOld.ScGetNetworkProperties(
            shNetwork,
            s_rgControl[ idx ].dwGetControl,
            NULL,
            NULL,
            0
            );

        CClusterApi::SetObjectProperties(
            RgGetPropMap(),
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterNetworkControl( 
                    shNetwork,
                    NULL,
                    s_rgControl[ idx ].dwSetControl,
                    plNew.PbPropList(),
                    plNew.CbPropList(),
                    NULL,
                    0,
                    NULL
                    );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterNetwork::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNetwork::DeleteInstance(
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CClusterNetwork::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNetwork::DeleteInstance()

//****************************************************************************
//
//  CClusterNetNetInterface
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ClusterNetNetInterface::CClusterNetNetInterface(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNetNetInterface::CClusterNetNetInterface(
    const WCHAR *   pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** ClusterNetNetInterface::ClusterNetNetInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  ClusterNetNetInterface::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNetNetInterface::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterNetNetInterface(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** ClusterNetNetInterface::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  ClusterNetNetInterface::GetPropMap(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve the property maping table of the cluster network net interface.
//
//  Arguments:
//      lFlagsIn    -- 
//      pCtxIn      -- 
//      pHandlerIn  -- 
//
//  Return Values:
//      Reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetNetInterface::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    LPCWSTR             pwszName = NULL;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wcoGroup;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
    DWORD               cbNetworkName = MAX_PATH;
    CWstrBuf            wsbNetworkName;
    HRESULT             hr;

    CComPtr< IEnumWbemClassObject > pEnum;

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );

    //
    // network interface objects
    //

    er = m_pNamespace->CreateInstanceEnum(
            _bstr_t( PVD_CLASS_NETWORKSINTERFACE ),
            0,
            NULL,
            & pEnum
            );

    wsbNetworkName.SetSize( cbNetworkName );
    for ( ; ; )
    {
        CWbemClassObject    wcoNetInterface;
        DWORD               cWco;

        hr = pEnum->Next(
                5000,
                1,
                & wcoNetInterface,
                & cWco
                );
        if ( hr == WBEM_S_NO_ERROR )
        {
            SAFENETINTERFACE    shNetInterface;
            DWORD               cbReturn;
            CWbemClassObject    wco;

            wcoNetInterface.GetProperty( bstrPart, PVD_WBEM_PROP_DEVICEID );
            shNetInterface = OpenClusterNetInterface( shCluster, bstrPart );

            dwError = ClusterNetInterfaceControl(
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NETWORK,
                            NULL,
                            0,
                            wsbNetworkName,
                            cbNetworkName,
                            & cbReturn
                            );
            if ( dwError == ERROR_MORE_DATA )
            {
                cbNetworkName = cbReturn;
                wsbNetworkName.SetSize( cbNetworkName );
                er = ClusterNetInterfaceControl(
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NETWORK,
                            NULL,
                            0,
                            wsbNetworkName,
                            cbNetworkName,
                            & cbReturn
                            );
            } // if: buffer is too small
            wcoGroup.SetProperty( wsbNetworkName, CLUSREG_NAME_NET_NAME );
            wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

            wcoNetInterface.GetProperty( bstrPart, PVD_WBEM_RELPATH );
            m_pClass->SpawnInstance( 0, & wco );
            wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
            wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
            pHandlerIn->Indicate( 1, & wco );

        } // if: no error
        else
        {
            break;
        } // else S_FALSE, or error

    } // forever

    if ( FAILED ( hr ) )
    {
        er = hr;
    }

    return WBEM_S_NO_ERROR;

} //*** ClusterNetNetInterface::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternode.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name: CClusterNode.cpp
//
//  Description:    
//      Implementation of CClusterNode class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNode.h"

//****************************************************************************
//
//  CClusterNode
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::CClusterNode(
//
//  Description:
//      Constructor
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNode::CClusterNode( 
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterNode::CClusterNode()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterNode::S_CreateThis(
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNode::S_CreateThis( 
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterNode( pwszNameIn, pNamespaceIn );

} //*** CClusterNode::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  const SPropMapEntryArray *
//  CClusterNode::RgGetPropMap( void )
//
//  Description:
//      Retrieve the property mapping table of the cluster node.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterNode::RgGetPropMap( void )
{

    static SPropMapEntry s_rgpm[] =
    {
        {
            PVD_PROP_NAME,
            CLUSREG_NAME_NODE_NAME,
            SZ_TYPE,
            READONLY
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof( s_rgpm ) / sizeof( SPropMapEntry ),
                s_rgpm
                );

    return & s_pmea;

} //*** CClusterNode::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNode::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      enum cluster instance
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    LPCWSTR         pwszNode;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum(
        shCluster,
        CLUSTER_ENUM_NODE );


    while ( pwszNode = cluEnum.GetNext() )
    {
        shNode = OpenClusterNode( shCluster, pwszNode );

        ClusterToWMI( shNode, pHandlerIn );

    } // while: more nodes

    return WBEM_S_NO_ERROR;

} //*** CClusterNode::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterResource::ClusterToWMI(
//      HNODE               hNodeIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Translate a cluster resource objects to WMI object.
//
//  Arguments:
//      hNodeIn         -- Handle to node
//      pHandlerIn      -- Pointer to WMI sink
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterNode::ClusterToWMI(
    HNODE               hNodeIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES,    FALSE },
        { CLUSCTL_NODE_GET_COMMON_PROPERTIES,       FALSE },
        { CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES,   TRUE },
        { CLUSCTL_NODE_GET_PRIVATE_PROPERTIES,      TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    CError              er;
    UINT                idx;

    m_pClass->SpawnInstance( 0, & wco );
    for ( idx = 0 ; idx < s_cControl; idx ++ )
    {
        CClusPropList pl;
        er = pl.ScGetNodeProperties(
                    hNodeIn,
                    s_rgControl[ idx ].dwControl,
                    NULL,
                    0
                    );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );

    } // for: each control code

    {
        DWORD dwState = GetClusterNodeState( hNodeIn );

        wco.SetProperty( dwState, PVD_PROP_STATE );
    }

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;

        er = ClusterNodeControl( 
                hNodeIn,
                NULL,
                CLUSCTL_NODE_GET_CHARACTERISTICS,
                NULL,
                0,
                & dwOut,
                sizeof( DWORD ),
                & cbReturned
                );
        wco.SetProperty( dwOut, PVD_PROP_CHARACTERISTIC );

        er = ClusterNodeControl(
                hNodeIn,
                NULL,
                CLUSCTL_NODE_GET_FLAGS,
                NULL,
                0,
                & dwOut,
                sizeof( DWORD ),
                & cbReturned
                );
        wco.SetProperty( dwOut, PVD_PROP_FLAGS );
    }

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNode::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      retrieve cluster node object based given object path
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    
    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode(
                shCluster,
                rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
                );

    ClusterToWMI( shNode, pHandlerIn );
    return WBEM_S_NO_ERROR;

} //*** CClusterNode::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNode::ExecuteMethod(
//      CObjPath &           rObjPathIn,
//      WCHAR *              pwszMethodNameIn,
//      long                 lFlagIn,
//      IWbemClassObject *   pParamsIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      execute methods defined in the mof for cluster node
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNode::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNode::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      save this instance
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_NODE_GET_COMMON_PROPERTIES,
            CLUSCTL_NODE_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_NODE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_NODE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD    s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;

        er = plOld.ScGetNodeProperties(
                shNode,
                s_rgControl[ idx ].dwGetControl,
                NULL,
                NULL,
                0
                );
        
        CClusterApi::SetObjectProperties(
            RgGetPropMap(),
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterNodeControl( 
                    shNode,
                    NULL,
                    s_rgControl[ idx ].dwSetControl,
                    plNew.PbPropList(),
                    plNew.CbPropList(),
                    NULL,
                    0,
                    NULL
                    );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterNode::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNode::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn  -- ObjPath for the instance to be deleted
//      lFlagIn     -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNode::DeleteInstance()

//****************************************************************************
//
//  CClusterNodeNetInterface
//
//****************************************************************************

CClusterNodeNetInterface::CClusterNodeNetInterface(
    const WCHAR *   pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** ClusterNodeNetInterface::ClusterNodeNetInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  ClusterNodeNetInterface::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster Node Network Interface object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Str type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNodeNetInterface::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterNodeNetInterface(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** ClusterNodeNetInterface::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  ClusterNodeNetInterface::EnumInstance
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate net interfaces for the node.
//
//  Arguments:
//      lFlagsIn        -- 
//      pCtxIn          -- 
//      pHandlerIn      -- 
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeNetInterface::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER                     shCluster;
    CError                          er;
    DWORD                           dwError;
    CWbemClassObject                wcoGroup;
    _bstr_t                         bstrGroup;
    _bstr_t                         bstrPart;
    DWORD                           cbName = MAX_PATH;
    CWstrBuf                        wsbName;
    CComPtr< IEnumWbemClassObject > pEnum;
    HRESULT                         hr = WBEM_S_NO_ERROR;

    shCluster = OpenCluster( NULL );

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );

    //
    // network interface objects
    //

    er = m_pNamespace->CreateInstanceEnum(
            _bstr_t( PVD_CLASS_NETWORKSINTERFACE ),
            0,
            NULL,
            & pEnum
            );

    wsbName.SetSize( cbName );

    for( ; ; )
    {
        CWbemClassObject    wcoNetInterface;
        DWORD               cWco;

        hr = pEnum->Next(
                5000,
                1,
                & wcoNetInterface,
                & cWco
                );
        if ( hr == WBEM_S_NO_ERROR )
        {
            SAFENETINTERFACE    shNetInterface;
            DWORD               cbReturn;
            CWbemClassObject    wco;

            wcoNetInterface.GetProperty( bstrPart, PVD_WBEM_PROP_DEVICEID );
            shNetInterface = OpenClusterNetInterface( shCluster, bstrPart );
            dwError = ClusterNetInterfaceControl( 
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NODE,
                            NULL,
                            0,
                            wsbName,
                            cbName,
                            & cbReturn
                            );
            if ( dwError == ERROR_MORE_DATA )
            {
                cbName = cbReturn;
                wsbName.SetSize( cbName );
                er = ClusterNetInterfaceControl( 
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NODE,
                            NULL,
                            0,
                            wsbName,
                            cbName,
                            & cbReturn
                            );
            } // if: more data

            wcoGroup.SetProperty( wsbName, PVD_PROP_NAME );
            wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

           wcoNetInterface.GetProperty( bstrPart, PVD_WBEM_RELPATH );
            m_pClass->SpawnInstance( 0, & wco );
            wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
            wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
            er = pHandlerIn->Indicate( 1, & wco );

        } // if: success
        else 
        {
            break;
        } // else: E_XXX, or S_FALSE

    } // forever

    if ( FAILED ( hr ) )
    {
       throw CProvException( hr );
    }

    return WBEM_S_NO_ERROR;

} //*** ClusterNodeNetInterface::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternodegroup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterNodeGroup.cpp
//
//  Description:
//      Implementation of CClusterNodeGroup class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNodeGroup.h"

//****************************************************************************
//
//  CClusterNodeGroup
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNodeGroup::CClusterNodeGroup(
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNodeGroup::CClusterNodeGroup(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterNodeGroup::CClusterNodeGroup()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterNodeGroup::S_CreateThis(
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNodeGroup::S_CreateThis(
    const WCHAR *    pwszNameIn,
    CWbemServices *  pNamespaceIn,
    DWORD            dwEnumTypeIn
    )
{
    return new CClusterNodeGroup(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterNodeGroup::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeGroup::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate instances
//
//  Arguments:
//      lFlagsIn    -- 
//      pCtxIn      -- 
//      pHandlerIn  -- 
//
//  Return Values:
//      SCODE
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeGroup::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    LPCWSTR             pwszName = NULL;
    DWORD               cchNodeName = MAX_PATH;
    CWstrBuf            wsbNodeName;
    DWORD               cch;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
 
    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );
    m_wcoGroup.SpawnInstance( 0, & wcoGroup );
    m_wcoPart.SpawnInstance( 0, & wcoPart );
    wsbNodeName.SetSize( cchNodeName );

    while ( pwszName = clusEnum.GetNext() )
    {
        DWORD   dwState;
        cch = cchNodeName;
        wcoPart.SetProperty( pwszName, PVD_PROP_GROUP_NAME );
        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        shGroup = OpenClusterGroup( shCluster, pwszName );

        dwState = GetClusterGroupState( shGroup, wsbNodeName, & cch );
        if ( dwState == ClusterGroupStateUnknown )
        {
            dwError = GetLastError();
            if ( dwError == ERROR_MORE_DATA )
            {
                cchNodeName = ++ cch;
                wsbNodeName.SetSize( cch );
                GetClusterGroupState( shGroup, wsbNodeName, & cch );
            } // if: more data
            else
            {
                er = dwError;
            } // else 
        } // if: StateUnknown
        
        wcoGroup.SetProperty( wsbNodeName, CLUSREG_NAME_GRP_NAME );
        wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, & wco );
        
    } // while: more items to enumerate

    return WBEM_S_NO_ERROR;

} //*** CClusterNodeGroup::EnumInstance(()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternodegroup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterNodeGroup.h
//
//  Implementation File:
//      ClusterNodeGroup.cpp
//
//  Description:
//      Definition of the CClusterNodeGroup class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNodeGroup;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNodeGroup
//
//  Description:
//      Provider Implement for cluster Node Group
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNodeGroup : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterNodeGroup::CClusterNodeGroup(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterNodeGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternoderes.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name: CClusterNodeRes.cpp
//
//  Description:    
//      Implementation of CClusterNodeRes class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNodeRes.h"

//****************************************************************************
//
//  CClusterNodeRes
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNodeRes::CClusterNodeRes(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNodeRes::CClusterNodeRes(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBaseAssociation( pwszNameIn, pNamespaceIn )
{

} //*** CClusterNodeRes::CClusterNodeRes()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterNodeRes::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           // dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node resource object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNodeRes::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterNodeRes( pwszNameIn, pNamespaceIn );

} //*** CClusterNodeRes::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enum cluster Node resource instance
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shResource;
    LPCWSTR         pwszResName = NULL;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_RESOURCE );

    while ( pwszResName = cluEnum.GetNext() )
    {
        shResource = OpenClusterResource( shCluster, pwszResName );

        ClusterToWMI( shResource, pHandlerIn );
    } // for: each resource

    return WBEM_S_NO_ERROR;

} //*** CClusterNodeRes::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterNodeRes::ClusterToWMI(
//      HRESOURCE            hResourceIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Translate a cluster node resource objects to WMI object.
//
//  Arguments:
//      hResourceIn     -- Handle to cluster
//      pHandlerIn      -- WMI sink
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterNodeRes::ClusterToWMI(
    HRESOURCE            hResourceIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    CWbemClassObject    wco;
    CClusPropList       theProp;
    CError              er;
    CWstrBuf            wsbNodeName;
    CWstrBuf            wsbResName;
    DWORD               cbNodeName = MAX_PATH;
    DWORD               cbResName = MAX_PATH;
    DWORD               cbBytesReturned;
    DWORD               dwState;
    DWORD               dwError;
    
    wsbNodeName.SetSize( cbNodeName  );
    wsbResName.SetSize( cbResName );
    m_pClass->SpawnInstance( 0, & wco );

    dwError = ClusterResourceControl(
                    hResourceIn,
                    NULL,
                    CLUSCTL_RESOURCE_GET_NAME,                  // this control code
                    NULL,
                    0,
                    wsbResName,
                    cbResName,
                    & cbBytesReturned
                    );

    if ( dwError == ERROR_MORE_DATA )
    {
        cbResName = cbBytesReturned;
        wsbResName.SetSize( cbResName );
        er = ClusterResourceControl(
                    hResourceIn,
                    NULL,
                    CLUSCTL_RESOURCE_GET_NAME,
                    NULL,
                    0,
                    wsbResName,
                    cbResName,
                    & cbBytesReturned
                    );
    } // if: buffer was too small
    wco.SetProperty( wsbResName, PVD_PROP_PARTCOMPONENT );

    dwState = GetClusterResourceState(
                    hResourceIn,
                    wsbNodeName,
                    & cbNodeName,
                    NULL,
                    NULL
                    );
    if ( dwState == ClusterResourceStateUnknown )
    {
        er = GetLastError();
    }

    wco.SetProperty( wsbNodeName, PVD_PROP_GROUPCOMPONENT );
    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterNodeRes::ClusterToWMI()
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::GetObject(
//
//  Description:
//      Retrieve cluster node active resource object based given object path.
//
//  Arguments:
//      rObjPathIn      -- Object path to cluster object
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn 
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNodeRes::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::ExecuteMethod(
//
//  Description:
//      Execute methods defined in the mof for cluster node resource.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    ) 
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNodeRes::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNodeRes::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNodeRes::DeleteInstance()
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternode.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterNode.h
//
//  Implementation File:
//      ClusterNode.cpp
//
//  Description:
//      Definition of the CClusterNode class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNode;
class CClusterNodeNetInterface;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNode
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNode : public CProvBase
{
//
// constructor
//
public:
    CClusterNode::CClusterNode(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HNODE               hNodeIn,
        IWbemObjectSink *   pHandlerIn
      );

}; // class CClusterNode

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNodeNetInterface
//
//  Description:
//      Implement cluster Node and netinterface association
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNodeNetInterface : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterNodeNetInterface::CClusterNodeNetInterface(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterNodeNetInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusternoderes.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterNodeRes.h
//
//  Implementation File:
//      ClusterNodeRes.cpp
//
//  Description:
//      Definition of the CClusterNodeRes class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNodeRes;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNodeRes
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNodeRes : public CProvBaseAssociation
{
//
// constructor
//
public:
    CClusterNodeRes::CClusterNodeRes(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    void ClusterToWMI(
        HRESOURCE            hResourceIn,
        IWbemObjectSink *    pHandlerIn
      );

}; //*** class CClusterNodeRes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterobjassoc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterObjAssoc.cpp
//
//  Description:    
//      Implementation of CClusterObjAssoc class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterObjAssoc.h"

//****************************************************************************
//
//  CClusterObjAssoc
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObjAssoc::CClusterObjAssoc(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////////////
CClusterObjAssoc::CClusterObjAssoc(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CProvBaseAssociation( pwszNameIn, pNamespaceIn )
    , m_dwEnumType ( dwEnumTypeIn )
{
    _bstr_t bstrClassName;

    GetTypeName( bstrClassName, PVD_PROP_PARTCOMPONENT );
    pNamespaceIn->GetObject(
        bstrClassName,
        0,
        NULL,
        & m_wcoPart,
        NULL
        );

    GetTypeName( bstrClassName, PVD_PROP_GROUPCOMPONENT );

    pNamespaceIn->GetObject(
        bstrClassName,
        0,
        NULL,
        & m_wcoGroup,
        NULL
        );

} //*** CClusterObjAssoc::CClusterObjAssoc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterObjAssoc::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create an object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterObjAssoc::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterObjAssoc(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterObjAssoc::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterObjAssoc::EnumInstance
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate instances.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      Status code.
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterObjAssoc::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    LPCWSTR             pwszName = NULL;
    DWORD               cchClusterName = MAX_PATH;
    CWstrBuf            wsbClusterName;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CObjPath            opGroup;
    CWbemClassObject    wcoGroup;
    _bstr_t             bstrGroup;

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );
    wsbClusterName.SetSize( cchClusterName );
    dwError = GetClusterInformation(
                    shCluster,
                    wsbClusterName,
                    & cchClusterName,
                    NULL
                    );
    if ( dwError == ERROR_MORE_DATA )
    {
        wsbClusterName.SetSize( ++ cchClusterName );
        er = GetClusterInformation(
                shCluster,
                wsbClusterName,
                & cchClusterName,
                NULL
                );
    } // if: buffer is too small

    m_wcoGroup.SpawnInstance( 0, &wcoGroup );
    wcoGroup.SetProperty( wsbClusterName, PVD_PROP_NAME );
    wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

    while ( pwszName = clusEnum.GetNext() )
    {
        CWbemClassObject    wcoPart;
        CWbemClassObject    wco;
        _bstr_t             bstrPart;

        m_wcoPart.SpawnInstance( 0, & wcoPart );
        
        if ( m_dwEnumType == CLUSTER_ENUM_NETINTERFACE )
        {
            SAFENETINTERFACE    shNetInterface;
            CWstrBuf            wsbNode;
            DWORD               cbNode = MAX_PATH;
            DWORD               cbReturn;

            wsbNode.SetSize( cbNode );
            shNetInterface = OpenClusterNetInterface( shCluster, pwszName );

            dwError = ClusterNetInterfaceControl(
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NODE,
                            NULL,
                            0,
                            wsbNode,
                            cbNode,
                            & cbReturn
                            );

            if ( dwError == ERROR_MORE_DATA )
            {
                wsbNode.SetSize( cbReturn );
                er = ClusterNetInterfaceControl( 
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NODE,
                            NULL,
                            0,
                            wsbNode,
                            cbNode,
                            & cbReturn
                            );
            } // if: buffer too small

            wcoPart.SetProperty( pwszName, PVD_PROP_NETINTERFACE_DEVICEID );
            wcoPart.SetProperty( wsbNode,  PVD_PROP_NETINTERFACE_SYSTEMNAME );
        } // if: found net interface
        else
        {
            wcoPart.SetProperty( pwszName, PVD_PROP_NAME );
        }

        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, & wco );
        
    } // while: more net interfaces

    return WBEM_S_NO_ERROR;

} //*** CClusterObjAssoc::EnumInstance()

//****************************************************************************
//
//  CClusterObjDep
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObjDep::CClusterObjDep
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////
CClusterObjDep::CClusterObjDep(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CProvBaseAssociation( pwszNameIn, pNamespaceIn )
    , m_dwEnumType ( dwEnumTypeIn )
{
    _bstr_t bstrClassName;

    GetTypeName( bstrClassName, PVD_WBEM_PROP_ANTECEDENT );
    pNamespaceIn->GetObject(
        bstrClassName,
        0,
        NULL,
        & m_wcoDependent,
        NULL
        );

    GetTypeName( bstrClassName, PVD_WBEM_PROP_DEPENDENT );

    pNamespaceIn->GetObject(
        bstrClassName,
        0,
        NULL,
        & m_wcoAntecedent,
        NULL
        );

} //*** CClusterObjDep::CClusterObjDep()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterobjassoc.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterObjAssoc.h
//
//  Implementation File:
//      ClusterObjAssoc.cpp
//
//  Description:
//      Definition of the CClusterObjAssoc class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ObjectPath.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterObjAssoc;
class CClusterObjDep;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterObjAssoc
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterObjAssoc : public CProvBaseAssociation
{
//
// constructor
//
public:
    CClusterObjAssoc::CClusterObjAssoc(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:
    
    DWORD               m_dwEnumType;
    _bstr_t             m_bstrPartComp;
    _bstr_t             m_bstrGroupComp;
    CWbemClassObject    m_wcoPart;
    CWbemClassObject    m_wcoGroup;

}; //*** class CClusterObjAssoc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterObjDep
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterObjDep : public CProvBaseAssociation
{
//
// constructor
//
public:
    CClusterObjDep::CClusterObjDep(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) = 0;

protected:
    DWORD               m_dwEnumType;
    CWbemClassObject    m_wcoAntecedent;
    CWbemClassObject    m_wcoDependent;

}; //*** class CClusterObjDep
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterresdepres.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResDepRes.cpp
//
//  Description:    
//      Implementation of CClusterResDepRes class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResDepRes.h"

//****************************************************************************
//
//  CClusterResDepRes
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResDepRes::CClusterResDepRes(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResDepRes::CClusterResDepRes(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjDep( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterResDepRes::CClusterResDepRes()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterResDepRes::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResDepRes::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterResDepRes(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterResDepRes::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResDepRes::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//    )
//
//  Description:
//      Enumerate dependencies of a resource.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResDepRes::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    LPCWSTR             pwszName = NULL;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CWbemClassObject    wcoAntecedent;
    CWbemClassObject    wcoDependent;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
    DWORD               cchDepResName = MAX_PATH;
    CWstrBuf            wsbDepResName;


    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );

    m_wcoAntecedent.SpawnInstance( 0, & wcoAntecedent );
    m_wcoDependent.SpawnInstance( 0, & wcoDependent );

    wsbDepResName.SetSize( cchDepResName );
    while ( pwszName = clusEnum.GetNext() )
    {
        DWORD           dwIndex = 0;
        DWORD           dwType;
        SAFERESOURCE    shResource;
        SAFERESENUM     shResEnum;

        shResource = OpenClusterResource( shCluster, pwszName );
        shResEnum = ClusterResourceOpenEnum( shResource, CLUSTER_RESOURCE_ENUM_DEPENDS );

        for ( ; ; )
        {
            DWORD cch = cchDepResName;

            dwError = ClusterResourceEnum(
                            shResEnum,
                            dwIndex++,
                            & dwType,
                            wsbDepResName,
                            & cch
                            );
            if ( dwError == ERROR_MORE_DATA )
            {
                cchDepResName = ++ cch ;
                wsbDepResName.SetSize( cch );
                dwError = ClusterResourceEnum(
                                shResEnum,
                                dwIndex++,
                                & dwType,
                                wsbDepResName,
                                & cch
                                );
            } // if: buffer was too small
            
            if ( dwError == ERROR_SUCCESS )
            {
                wcoAntecedent.SetProperty( pwszName, CLUSREG_NAME_RESTYPE_NAME );
                wcoAntecedent.GetProperty( bstrGroup, PVD_WBEM_RELPATH );
                
                wcoDependent.SetProperty( wsbDepResName, CLUSREG_NAME_RESTYPE_NAME );
                wcoDependent.GetProperty( bstrPart, PVD_WBEM_RELPATH );

                m_pClass->SpawnInstance( 0, & wco );
                wco.SetProperty( (LPWSTR) bstrGroup, PVD_WBEM_PROP_ANTECEDENT );
                wco.SetProperty( (LPWSTR) bstrPart,  PVD_WBEM_PROP_DEPENDENT );
                pHandlerIn->Indicate( 1, & wco );
            }
            else if ( dwError == ERROR_NO_MORE_ITEMS )
            {
                break;
            }
            else
            {
                er = dwError;
            }
        } // forever
    } // while: more dependencies

    return WBEM_S_NO_ERROR;

} //*** CClusterResDepRes::EnumInstance()

//****************************************************************************
//
//  CClusterToNode
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterToNode::CClusterToNode(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterToNode::CClusterToNode(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjDep( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterToNode::CClusterToNode()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterToNode::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterToNode::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterToNode(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterToNode::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterToNode::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterToNode::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    LPCWSTR             pwszName = NULL;
    DWORD               cchClusterName = MAX_PATH;
    CWstrBuf            wsbClusterName;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wcoAntecedent;
    CWbemClassObject    wcoDependent;
    _bstr_t             bstrAntecedent;
    _bstr_t             bstrDependent;

    wsbClusterName.SetSize( cchClusterName );

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );
    dwError = GetClusterInformation(
                    shCluster,
                    wsbClusterName,
                    & cchClusterName,
                    NULL
                    );

    if ( dwError == ERROR_MORE_DATA )
    {
        wsbClusterName.SetSize( ++ cchClusterName );
        er = GetClusterInformation(
                    shCluster,
                    wsbClusterName,
                    & cchClusterName,
                    NULL
                    );
    }
    m_wcoAntecedent.SpawnInstance( 0, & wcoAntecedent );
    m_wcoDependent.SpawnInstance( 0, & wcoDependent );

    wcoAntecedent.SetProperty( wsbClusterName, PVD_PROP_NAME );
    wcoAntecedent.GetProperty( bstrAntecedent, PVD_WBEM_RELPATH );

    while ( pwszName = clusEnum.GetNext() )
    {
        CWbemClassObject    wco;

        wcoDependent.SetProperty( pwszName, PVD_PROP_NAME );

        wcoDependent.GetProperty( bstrDependent, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrAntecedent, PVD_WBEM_PROP_ANTECEDENT );
        wco.SetProperty( (LPWSTR) bstrDependent,  PVD_WBEM_PROP_DEPENDENT );
        pHandlerIn->Indicate( 1, & wco );
    } // while: more properties

    return WBEM_S_NO_ERROR;

} //*** CClusterToNode::EnumInstance()

//****************************************************************************
//
//  CClusterHostedService
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterHostedService::CClusterHostedService(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumType
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterHostedService::CClusterHostedService(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjDep( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterHostedService::CClusterHostedService()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterHostedService::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a hostedservice.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterHostedService::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterHostedService(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterHostedService::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterHostedService::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enum instance of hostedservice
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterHostedService::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
//    SAFECLUSTER         shCluster;
    CError              er;
    CWbemClassObject    wcoAntecedent;
    _bstr_t             bstrAntecedent;
    _bstr_t             bstrDependent;
    CComPtr< IEnumWbemClassObject > pEnum;

//    shCluster = OpenCluster( NULL ); // DAVIDP: Why is this needed? 19-Jul-2000

    m_wcoAntecedent.SpawnInstance( 0, &wcoAntecedent );

    //
    // network interface objects
    //

    er = m_pNamespace->CreateInstanceEnum(
                _bstr_t( PVD_CLASS_SERVICES ),
                0,
                NULL,
                &pEnum
                );

    for( ; ; )
    {
        CWbemClassObject    wcoService;
        DWORD               cWco;
        HRESULT             hr;

        hr = pEnum->Next(
                5000,
                1,
                &wcoService,
                &cWco
                );
        if ( hr == WBEM_S_NO_ERROR )
        {
            CWbemClassObject    wco;

            wcoService.GetProperty( bstrAntecedent, PVD_PROP_SERVICE_SYSTEMNAME );

            wcoAntecedent.SetProperty( ( LPWSTR ) bstrAntecedent, PVD_PROP_NODE_NAME );
            wcoAntecedent.GetProperty( bstrAntecedent, PVD_WBEM_RELPATH );

            wcoService.GetProperty( bstrDependent, PVD_WBEM_RELPATH );
            m_pClass->SpawnInstance( 0, &wco );
            wco.SetProperty( ( LPWSTR ) bstrAntecedent, PVD_WBEM_PROP_ANTECEDENT );
            wco.SetProperty( ( LPWSTR ) bstrDependent, PVD_WBEM_PROP_DEPENDENT );
            pHandlerIn->Indicate( 1, &wco );
        }
        else
        {
            break;
        }

    } // forever

    return WBEM_S_NO_ERROR;

} //*** CClusterHostedService::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterresource.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResource.cpp
//
//  Description:    
//      Implementation of CClusterResource class
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResource.h"
#include "ClusterResource.tmh"
#include <vector>

//****************************************************************************
//
//  CClusterResource
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::CClusterResource(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResource::CClusterResource(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterResource::CClusterResource()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterResource::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a resource object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResource::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterResource( pwszNameIn, pNamespaceIn );

} //*** CClusterResource::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResource::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate cluster resource instances.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CClusterResource::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shResource;
    LPCWSTR         pwszResName = NULL;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_RESOURCE );

    while ( ( pwszResName = cluEnum.GetNext() ) != NULL )
    {
        shResource = OpenClusterResource( shCluster, pwszResName );
        ClusterToWMI( shResource, pHandlerIn );

    } // while: more resources

    return WBEM_S_NO_ERROR;

} //*** CClusterResource::EnumInstance()

// smart_bstr class to make LoadRegistryCheckpoints func exception safe
struct smart_bstr {
    BSTR data;
    smart_bstr():data(0){}
    ~smart_bstr() { SysFreeString(data); }
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  LoadRegistryCheckpoints(
//      IN HRESOURCE          hResourceIn,
//      IN DWORD dwControlCode,
//      IN const WCHAR* propName,
//      IN OUT CWbemClassObject    wco,
//      )
//
//  Description:
//      Translate a cluster resource objects to WMI object.
//
//  Arguments:
//      hResourceIn     -- Handle to resource
//      dwControlCode   -- show be one of the following
//          CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS
//          CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS
//      propName       -- property name to load checkpoints to
//      wco            -- property container
//
//  Return Values:
//      none
//--
//////////////////////////////////////////////////////////////////////////////

void
LoadRegistryCheckpoints(
    IN HRESOURCE          hResourceIn,
    IN DWORD dwControlCode,
    IN const WCHAR* propName,
    IN OUT CWbemClassObject &wco
    )
{
    DWORD cbReturned = 0;
    DWORD dwStatus;
    CError er;

    dwStatus = ClusterResourceControl(
                hResourceIn,
                NULL,
                dwControlCode,
                NULL,
                0,
                NULL,
                0,
                &cbReturned
                );
    if (dwStatus != ERROR_MORE_DATA) {
        er = dwStatus;
    }
    if (cbReturned == 0) {
        return; // no checkpoints
    }

    std::vector<WCHAR> checkpoints(cbReturned/sizeof(WCHAR)); 
    er = ClusterResourceControl(
                hResourceIn,
                NULL,
                dwControlCode,
                NULL,
                0,
                &checkpoints[0],
                checkpoints.size() * sizeof(WCHAR),
                &cbReturned
                );

    int nKeys = 0; // count how many keys are in the string
    for(int i = 0; i < checkpoints.size(); ++i) {
        if (checkpoints[i] == 0) {
            ++nKeys;
            if (i > 0 && checkpoints[i-1] == 0) {
                break; // double null
            }
        }
    }

    std::vector<smart_bstr> bstrs(nKeys);
    WCHAR* p = &checkpoints[0]; 
    for(int i = 0; i < nKeys; ++i) {
        bstrs[i].data = SysAllocString( p );
        p += wcslen(p) + 1;
    }

    wco.SetProperty(nKeys, &bstrs[0].data, propName);
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterResource::ClusterToWMI(
//      HRESOURCE            hResourceIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Translate a cluster resource objects to WMI object.
//
//  Arguments:
//      hResourceIn     -- Handle to resource
//      pHandlerIn      -- Pointer to WMI sink
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterResource::ClusterToWMI(
    HRESOURCE            hResourceIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES,    FALSE },
        { CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES,       FALSE },
        { CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES,   TRUE },
        { CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,      TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    CWbemClassObject    wcoPrivate;
    CWbemClassObject    wcoClass;
    CError              er;
    DWORD               dwStatus;
    UINT                idx;
    CWstrBuf            wsbTypeName ;
    DWORD               cbTypeName = MAX_PATH;
    DWORD               cbTypeNameReturned = 0;

    //
    // get type name and corresponding property class
    //
    wsbTypeName.SetSize( cbTypeName );
    dwStatus = ClusterResourceControl(
                        hResourceIn,
                        NULL,
                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                        NULL,
                        0,
                        wsbTypeName,
                        cbTypeName,
                        &cbTypeNameReturned
                        );
    if ( dwStatus == ERROR_MORE_DATA )
    {
        cbTypeName = cbTypeNameReturned;
        wsbTypeName.SetSize( cbTypeName );
        er = ClusterResourceControl( 
                    hResourceIn,
                    NULL,
                    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                    NULL,
                    0,
                    wsbTypeName,
                    cbTypeName,
                    &cbTypeNameReturned
                    );
    }
    er = dwStatus;
    er = m_pNamespace->GetObject(
                            g_TypeNameToClass[ static_cast<LPWSTR> ( wsbTypeName ) ],
                            0,
                            0,
                            &wcoClass,
                            NULL
                            );
    er = wcoClass.data()->SpawnInstance( 0, & wcoPrivate );
    m_pClass->SpawnInstance( 0, & wco );

    //
    // get properties from property list
    //
    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList       pl;
        CWbemClassObject    wcoTemp;
        er = pl.ScGetResourceProperties(
                    hResourceIn,
                    s_rgControl[ idx ].dwControl,
                    NULL,
                    0
                    );
        if ( s_rgControl[ idx ].fPrivate )
        {
            wcoTemp = wcoPrivate;
        }
        else
        {
            wcoTemp = wco;
        }

        CClusterApi::GetObjectProperties(
            NULL,
            pl,
            wcoTemp,
            s_rgControl[ idx ].fPrivate
            );
    
    } // for: each control code

    wco.SetProperty(
        wcoPrivate.data(),
        PVD_PROP_RES_PRIVATE );

    {
        DWORD dwState = GetClusterResourceState(
                            hResourceIn,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            );
        wco.SetProperty( dwState, PVD_PROP_RES_STATE );
    }

    LoadRegistryCheckpoints(hResourceIn, 
        CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS, PVD_PROP_RES_CHECKPOINTS, wco);
    LoadRegistryCheckpoints(hResourceIn, 
        CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS, PVD_PROP_RES_CRYPTO_CHECKPOINTS, wco); 

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;
        er = ClusterResourceControl(
                    hResourceIn,
                    NULL,
                    CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                    NULL,
                    0,
                    &dwOut,
                    sizeof( DWORD ),
                    &cbReturned
                    );
        wco.SetProperty( dwOut, PVD_PROP_CHARACTERISTIC );

        wco.SetProperty( dwOut & CLUS_CHAR_QUORUM, PVD_PROP_RESTYPE_QUORUM_CAPABLE );
        wco.SetProperty( dwOut & CLUS_CHAR_DELETE_REQUIRES_ALL_NODES, PVD_PROP_RESTYPE_DELETE_REQUIRES_ALL_NODES );
        wco.SetProperty( dwOut & CLUS_CHAR_LOCAL_QUORUM, PVD_PROP_RESTYPE_LOCALQUORUM_CAPABLE );

        er = ClusterResourceControl(
                    hResourceIn,
                    NULL,
                    CLUSCTL_RESOURCE_GET_FLAGS,
                    NULL,
                    0,
                    &dwOut,
                    sizeof( DWORD ),
                    &cbReturned
                    );
        wco.SetProperty( dwOut, PVD_PROP_FLAGS );

        wco.SetProperty( dwOut & CLUS_FLAG_CORE, PVD_PROP_RES_CORE_RESOURCE );
    }

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResource::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve cluster resourcee object based on given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResource::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shRes;

    shCluster = OpenCluster( NULL );
    shRes = OpenClusterResource(
                shCluster,
                rObjPathIn.GetStringValueForProperty( CLUSREG_NAME_RES_NAME )
                );

    ClusterToWMI( shRes, pHandlerIn );
    return WBEM_S_NO_ERROR;

} //*** CClusterResource::GetObject()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  AddRemoveCheckpoint(
//      IN HRESOURCE          hResourceIn,
//      IN DWORD dwControlCode,
//      IN CWbemClassObject    wcoInputParam,
//      )
//
//  Description:
//      Adds/Removes regular/crypto checkpoint.
//
//  Arguments:
//      hResourceIn     -- Handle to resource
//      dwControlCode   -- clusapi control code
//      wcoInputParam   -- property container
//
//  Return Values:
//      none
//--
//////////////////////////////////////////////////////////////////////////////
void AddRemoveCheckpoint(
    IN HRESOURCE          hResourceIn,
    IN CWbemClassObject& wcoInputParam, 
    IN DWORD dwControlCode
    )
{
    CError er;
    _bstr_t keyName;

    wcoInputParam.GetProperty( keyName, PVD_MTH_PARM_RES_CHECKPOINT_NAME );
    er = ClusterResourceControl(
                hResourceIn,
                NULL,
                dwControlCode,
                (wchar_t*)keyName,
                SysStringByteLen(keyName) + sizeof(WCHAR),
                NULL,
                0,
                NULL
                );

}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResource::ExecuteMethod(
//      CObjPath &           rObjPathIn,
//      WCHAR *              pwszMethodNameIn,
//      long                 lFlagIn,
//      IWbemClassObject *   pParamsIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Execute methods defined in the mof for cluster resource.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResource::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    ) 
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shRes;
    CWbemClassObject    wcoInputParm( pParamsIn );

    shCluster = OpenCluster( NULL );

    //
    // static method
    //
    if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_CREATE_RESOURCE ) == 0 )
    {
        _bstr_t         bstrTargetGroup;
        _bstr_t         bstrResource;
        BOOL            bSeperateMonitor;
        _bstr_t         bstrResourceType;
        SAFERESOURCE    shNewResource;
        SAFEGROUP       shGroup;
        CObjPath        opGroup;

        wcoInputParm.GetProperty( bstrTargetGroup, PVD_MTH_PARM_GROUP );
        opGroup.Init( bstrTargetGroup );
        bstrTargetGroup = opGroup.GetStringValueForProperty( PVD_PROP_GROUP_NAME );

        wcoInputParm.GetProperty( bstrResource, PVD_MTH_PARM_RES_NAME );
        wcoInputParm.GetProperty( bstrResourceType, PVD_MTH_PARM_RES_TYPE );
        wcoInputParm.GetProperty( &bSeperateMonitor, PVD_MTH_PARM_SEP_MONITOR );

        shGroup = OpenClusterGroup( shCluster, bstrTargetGroup );
        shNewResource = CreateClusterResource(
                            shGroup,
                            bstrResource,
                            bstrResourceType,
                            bSeperateMonitor
                            );
    } // if: CREATE_RESOURCE
    else
    {
        shRes = OpenClusterResource(
                    shCluster,
                    rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
                    );

        if( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_OFFLINE ) == 0 )
        {
            return OfflineClusterResource( shRes );
        } // if: OFFLINE
        else if( _wcsicmp(  pwszMethodNameIn, PVD_MTH_RES_ONLINE ) == 0 )
        {
            return OnlineClusterResource( shRes );
        } // else if: ONLINE
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_CHANGE_GROUP ) == 0 )
        {
            _bstr_t     bstrGroupObjpath;
            SAFEGROUP   shGroup;
            CObjPath    opGroup;
            CError      er;

            wcoInputParm.GetProperty( bstrGroupObjpath, PVD_MTH_PARM_GROUP );
            opGroup.Init( bstrGroupObjpath );
            bstrGroupObjpath = opGroup.GetStringValueForProperty(PVD_PROP_GROUP_NAME);

            shGroup = OpenClusterGroup( shCluster, bstrGroupObjpath );
            er = ChangeClusterResourceGroup( shRes, shGroup );
        } // else if: CHANGE_GROUP
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_ADD_DEPENDENCY ) == 0 )
        {
            _bstr_t         bstrDepResource;
            SAFERESOURCE    shDepResource;
            CError          er;
            CObjPath        opResource;

            wcoInputParm.GetProperty( bstrDepResource, PVD_MTH_PARM_RESOURCE );
            opResource.Init( bstrDepResource );
            bstrDepResource = opResource.GetStringValueForProperty(PVD_PROP_RES_NAME);
            shDepResource = OpenClusterResource( shCluster, bstrDepResource );
            er = AddClusterResourceDependency( shRes, shDepResource );
        } // else if: ADD_DEPENDENCY
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_REMOVE_DEPENDENCY ) == 0 )
        {
            _bstr_t         bstrDepResource;
            SAFERESOURCE    shDepResource;
            CError          er;
            CObjPath        opResource;

            wcoInputParm.GetProperty( bstrDepResource, PVD_MTH_PARM_RESOURCE );
            opResource.Init( bstrDepResource );
            bstrDepResource = opResource.GetStringValueForProperty( PVD_PROP_RES_NAME );
            shDepResource = OpenClusterResource( shCluster, bstrDepResource );
            er = RemoveClusterResourceDependency( shRes, shDepResource );
        } // else if: REMOVE_DEPENDENCY
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_ADD_REG_CHECKPOINT ) == 0 )
        {
            AddRemoveCheckpoint(shRes, wcoInputParm, CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT);
        }
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_DEL_REG_CHECKPOINT ) == 0 )
        {
            AddRemoveCheckpoint(shRes, wcoInputParm, CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT);
        }
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_ADD_CRYPTO_CHECKPOINT ) == 0 )
        {
            AddRemoveCheckpoint(shRes, wcoInputParm, CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT);
        }
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_DEL_CRYPTO_CHECKPOINT ) == 0 )
        {
            AddRemoveCheckpoint(shRes, wcoInputParm, CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT);
        }
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_FAIL_RESOURCE ) == 0 )
        {
           CError   er;
           er = FailClusterResource( shRes );
        } // if: FAIL_RESOURCE
        else if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_RES_RENAME ) == 0 )
        {
            _bstr_t         bstrName;
            CError          er;
            CObjPath        opResource;

            wcoInputParm.GetProperty( bstrName, PVD_MTH_PARM_NEWNAME );
            er = SetClusterResourceName( shRes, bstrName );
        } // if: RENAME
        else 
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    } // else: not CREATE_RESOURCE

    return WBEM_S_NO_ERROR;

} //*** CClusterResource::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResource::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResource::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn 
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES,
            CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD    s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shResource;
    CError          er;
    UINT            idx;

    TracePrint(( "CClusterResource::PutInstance entry\n" ));

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );
    shResource = OpenClusterResource( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList       plOld;
        CClusPropList       plNew;
        CWbemClassObject    wco;

        if ( s_rgControl[ idx ].fPrivate )
        {
            rInstToPutIn.GetProperty( wco, PVD_PROP_RES_PRIVATE );
        }
        else
        {
            wco = rInstToPutIn;
        }
        er = plOld.ScGetResourceProperties(
                    shResource,
                    s_rgControl[ idx ].dwGetControl,
                    NULL,
                    NULL,
                    0
                    );

        CClusterApi::SetObjectProperties(
                    NULL,
                    plNew,
                    plOld,
                    wco,
                    s_rgControl[ idx ].fPrivate
                    );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterResourceControl(
                        shResource,
                        NULL,
                        s_rgControl[ idx ].dwSetControl,
                        plNew.PbPropList(),
                        plNew.CbPropList(),
                        NULL,
                        0,
                        NULL
                        );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterResource::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResource::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Delete the object specified in rObjPathIn
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResource::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shRes;
    CError          er;

    shCluster = OpenCluster( NULL );
    shRes = OpenClusterResource(
                shCluster,
                rObjPathIn.GetStringValueForProperty( CLUSREG_NAME_RES_NAME )
                );
    er = OfflineClusterResource( shRes );
    er = DeleteClusterResource( shRes );

    return WBEM_S_NO_ERROR;

} //*** CClusterResource::DeleteInstance()


//****************************************************************************
//
//  CClusterClusterQuorum
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterClusterQuorum::CClusterClusterQuorum(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumType
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterClusterQuorum::CClusterClusterQuorum(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterClusterQuorum::CClusterClusterQuorum()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterClusterQuorum::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterClusterQuorum::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterClusterQuorum(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterClusterQuorum::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterClusterQuorum::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate instances of cluster quorum
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterClusterQuorum::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    DWORD               cchResName = MAX_PATH;
    CWstrBuf            wsbResName;
    DWORD               cchDeviceName = MAX_PATH;
    CWstrBuf            wsbDeviceName;
    DWORD               cchClusterName = MAX_PATH;
    CWstrBuf            wsbClusterName;
    DWORD               dwLogsize;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
 
    wsbResName.SetSize( cchResName );
    wsbDeviceName.SetSize( cchDeviceName );
    wsbClusterName.SetSize( cchClusterName );

    shCluster = OpenCluster( NULL );

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );
    m_wcoPart.SpawnInstance( 0, & wcoPart );


    dwError = GetClusterQuorumResource(
                    shCluster,
                    wsbResName,
                    &cchResName,
                    wsbDeviceName,
                    &cchDeviceName,
                    &dwLogsize
                    );
    if ( dwError == ERROR_MORE_DATA )
    {
        wsbResName.SetSize( ++cchResName );
        wsbDeviceName.SetSize( ++cchDeviceName );
        
        er = GetClusterQuorumResource(
                    shCluster,
                    wsbResName,
                    &cchResName,
                    wsbDeviceName,
                    &cchDeviceName,
                    &dwLogsize
                    );
    } // if: buffer was too small

   dwError = GetClusterInformation(
                    shCluster,
                    wsbClusterName,
                    &cchClusterName,
                    NULL
                    );
    if ( dwError == ERROR_MORE_DATA )
    {
        wsbClusterName.SetSize( ++cchClusterName );
        er = GetClusterInformation(
                shCluster,
                wsbClusterName,
                &cchClusterName,
                NULL
                );
    } // if: buffer was too small

    wcoPart.SetProperty( wsbResName, PVD_PROP_NAME );
    wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

    wcoGroup.SetProperty( wsbClusterName, PVD_PROP_NAME );
    wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

    m_pClass->SpawnInstance( 0, &wco );
    wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
    wco.SetProperty( (LPWSTR) bstrPart,  PVD_PROP_PARTCOMPONENT );
    pHandlerIn->Indicate( 1, &wco );
        
    return WBEM_S_NO_ERROR;

} //*** ClusterClusterQuorum::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterresdepres.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResDepRes.h
//
//  Implementation File:
//      ClusterResDepRes.cpp
//
//  Description:
//      Definition of the CClusterResDepRes class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterResDepRes;
class CClusterToNode;
class CClusterHostedService;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResDepRes
//
//  Description:
//      Provider for cluster resource dependency
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResDepRes : public CClusterObjDep
{
//
// constructor
//
public:
    CClusterResDepRes::CClusterResDepRes(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterResDepRes

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterToNode
//
//  Description:
//      Provider for cluster resource dependency
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterToNode : public CClusterObjDep
{
//
// constructor
//
public:
    CClusterToNode::CClusterToNode(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterToNode

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterHostedService
//
//  Description:
//      Provider for cluster resource dependency
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterHostedService : public CClusterObjDep
{
//
// constructor
//
public:
    CClusterHostedService::CClusterHostedService(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterHostedService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterresourcetype.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResourceType.cpp
//
//  Description:
//      Implementation of ClusterResourceType class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResourceType.h"
#include "ClusterResourceType.tmh"

//****************************************************************************
//
//  CClusterResourceType
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::CClusterResourceType(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResourceType::CClusterResourceType(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterResourceType::CClusterResourceType()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterResourceType::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a CClusterResourceType object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResourceType::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterResourceType( pwszNameIn, pNamespaceIn );

} //*** CClusterResourceType::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  const SPropMapEntryArray *
//  CClusterResourceType::RgGetPropMap( void )
//
//  Description:
//      Retrieve the property maping table of the cluster resource type.
//
//  Arguments:
//      none
//
//  Return Values:
//      Reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterResourceType::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            NULL,
            CLUSREG_NAME_RESTYPE_DEBUG_PREFIX,
            SZ_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof ( s_rgpm ) / sizeof ( SPropMapEntry ),
                s_rgpm
                );

    return & s_pmea;

} //*** CClusterResourceType::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResourceType::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enum resource types
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    LPCWSTR         pwszResType;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_RESTYPE );


    while ( ( pwszResType = cluEnum.GetNext() ) != NULL )
    {
        ClusterToWMI( shCluster, pwszResType, pHandlerIn );
    } // while: more resource types

    return WBEM_S_NO_ERROR;

} //*** CClusterResourceType::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterResourceType::ClusterToWMI(
//      HCLUSTER             hClusterIn,
//      LPCWSTR              pwszNameIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      translate a resource type object to WMI object
//
//  Arguments:
//      hClusterIn      -- Handle to cluster
//      pwszNameIn      -- Name of the cluster object
//      pHandlerIn      -- WMI sink
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterResourceType::ClusterToWMI(
    HCLUSTER             hClusterIn,
    LPCWSTR              pwszNameIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES,   FALSE },
        { CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES,      FALSE },
        { CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES,  TRUE },
        { CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES,     TRUE },
    };
    static UINT         s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    DWORD               nStatus;
    CError              er;
    UINT                idx;
    CWbemClassObject    wco;

    TracePrint(( "ClusterToWMI entry for %ws\n", pwszNameIn ));

    m_pClass->SpawnInstance( 0, &wco );
    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList pl;
        nStatus = pl.ScGetResourceTypeProperties(
                    hClusterIn,
                    pwszNameIn,
                    s_rgControl[ idx ].dwControl,
                    NULL,
                    0
                    );

        if ( nStatus == ERROR_SUCCESS )
        {
            CClusterApi::GetObjectProperties(
                RgGetPropMap(),
                pl,
                wco,
                s_rgControl[ idx ].fPrivate
                );
        }
        else
        {
            TracePrint(( "ScGetResourceTypeProps failed - throw exception, status = %u\n", nStatus ));
            CProvException prove( nStatus );
            wco.SetProperty( prove.PwszErrorMessage(), PVD_WBEM_STATUS );
        }

    } // for: each control code

    //
    // flags and characteristics
    //
    if ( nStatus == ERROR_SUCCESS )
    {
        DWORD   cbReturned;
        DWORD   dwOut;

        er = ClusterResourceTypeControl( 
                    hClusterIn,
                    pwszNameIn,
                    NULL,
                    CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS,
                    NULL,
                    0,
                    &dwOut,
                    sizeof( DWORD ),
                    &cbReturned
                    );
        wco.SetProperty( dwOut, PVD_PROP_CHARACTERISTIC );

        wco.SetProperty( dwOut & CLUS_CHAR_QUORUM, PVD_PROP_RESTYPE_QUORUM_CAPABLE );
        wco.SetProperty( dwOut & CLUS_CHAR_DELETE_REQUIRES_ALL_NODES, PVD_PROP_RESTYPE_DELETE_REQUIRES_ALL_NODES );
        wco.SetProperty( dwOut & CLUS_CHAR_LOCAL_QUORUM, PVD_PROP_RESTYPE_LOCALQUORUM_CAPABLE );

        er = ClusterResourceTypeControl( 
                    hClusterIn,
                    pwszNameIn,
                    NULL,
                    CLUSCTL_RESOURCE_TYPE_GET_FLAGS,
                    NULL,
                    0,
                    &dwOut,
                    sizeof( DWORD ),
                    &cbReturned
                    );
        wco.SetProperty( dwOut, PVD_PROP_FLAGS );
    } // for: each control code


    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResourceType::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResourceType::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve cluster group object based given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;

    shCluster = OpenCluster( NULL );
        
    ClusterToWMI(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME ),
        pHandlerIn
        );

    return WBEM_S_NO_ERROR;
        
} //*** CClusterResourceType::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResourceType::ExecuteMethod(
//      CObjPath &           rObjPathIn,
//      WCHAR *              pwszMethodNameIn,
//      long                 lFlagIn,
//      IWbemClassObject *   pParamsIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Execute methods defined in the mof for cluster resource type.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_S_NO_ERROR;

} //*** CClusterResourceType::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResourceType::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        { 
            CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES,
            CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES,
            FALSE
        },
        { 
            CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static  DWORD   s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );

    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;
        er = plOld.ScGetResourceTypeProperties(
                shCluster,
                bstrName,
                s_rgControl[ idx ].dwGetControl,
                NULL,
                NULL
                );

        CClusterApi::SetObjectProperties(
                RgGetPropMap(),
                plNew,
                plOld,
                rInstToPutIn,
                s_rgControl[ idx ].fPrivate
                );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterResourceTypeControl( 
                        shCluster,
                        bstrName,
                        NULL,
                        s_rgControl[ idx ].dwSetControl,
                        plNew.PbPropList(),
                        plNew.CbPropList(),
                        NULL,
                        0,
                        NULL
                        );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterResourceType::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResourceType::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterResourceType::DeleteInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResource.h
//
//  Implementation File:
//      ClusterResource.cpp
//
//  Description:
//      Definition of the CClusterResource class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterResource;
class CClusterClusterQuorum;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResource
//
//  Description:
//      Provider Implement for cluster resource
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResource : public CProvBase
{
//
// constructor
//
public:
    CClusterResource::CClusterResource(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:
//    static const PropMapEntryArray & RgGetPropMap( void );

    void ClusterToWMI(
        HRESOURCE            hResourceIn,
        IWbemObjectSink *    pHandlerIn
        );

}; //*** class CClusterResource

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterClusterQuorum
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterClusterQuorum : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterClusterQuorum::CClusterClusterQuorum(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterClusterQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterresrestype.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResResType.cpp
//
//  Description:
//      Implementation of CClusterResResType class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResResType.h"

//****************************************************************************
//
//  CClusterResResType
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResResType::CClusterResResType(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResResType::CClusterResResType(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterResResType::CClusterResResType()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterResResType::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResResType::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterResResType(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterResResType::S_CreateThis()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResResType::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate resources of a particular type.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResResType::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    LPCWSTR             pwszName = NULL;
    DWORD               cbTypeName = MAX_PATH;
    CWstrBuf            wsbTypeName;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;

    wsbTypeName.SetSize( cbTypeName ); 

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );
    m_wcoPart.SpawnInstance( 0, & wcoPart );

    while ( pwszName = clusEnum.GetNext() )
    {
        DWORD cbTypeNameReturned = 0;
        shResource = OpenClusterResource( shCluster, pwszName );
        //
        // get resource type name
        //
        dwError = ClusterResourceControl(
                        shResource,
                        NULL,
                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                        NULL,
                        0,
                        wsbTypeName,
                        cbTypeName,
                        & cbTypeNameReturned
                        );
        if ( dwError == ERROR_MORE_DATA )
        {
            cbTypeName = cbTypeNameReturned;
            wsbTypeName.SetSize( cbTypeNameReturned );
            er = ClusterResourceControl(
                        shResource,
                        NULL,
                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                        NULL,
                        0,
                        wsbTypeName,
                        cbTypeName,
                        & cbTypeNameReturned
                        );
        } // if: buffer was too small

        wcoPart.SetProperty( wsbTypeName, PVD_PROP_RESTYPE_NAME );
        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        
        wcoGroup.SetProperty( pwszName, CLUSREG_NAME_RES_NAME );
        wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR) bstrPart,  PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, & wco );
        
    } // while: more resource types (??

    return WBEM_S_NO_ERROR;

} //*** CClusterResResType::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterservice.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterService.cpp
//
//  Description:    
//      Implementation of CClusterService class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterService.h"

//****************************************************************************
//
//  CClusterService
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::CClusterService(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterService::CClusterService(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterService::CClusterService()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterService::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterService::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterService( pwszNameIn, pNamespaceIn );

} //*** CClusterService::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  const SPropMapEntryArray
//  CClusterService::RgGetPropMap( void )
//
//  Description:
//      Retrieve the property mapping table of the cluster node.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Reference to the array of property maping table.
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterService::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            PVD_PROP_SERVICE_SYSTEMNAME,
            CLUSREG_NAME_NODE_NAME, 
            SZ_TYPE,
            READONLY
        },
        {
            NULL,
            CLUSREG_NAME_NODE_DESC,
            SZ_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NODE_MAJOR_VERSION,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NODE_MINOR_VERSION,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL, 
            CLUSREG_NAME_NODE_BUILD_NUMBER,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NODE_CSDVERSION,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof( s_rgpm ) / sizeof( SPropMapEntry ),
                s_rgpm
                );

    return &s_pmea;

} //*** CClusterService::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterService::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate cluster instance.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    LPCWSTR         pwszNode;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_NODE );

    while ( pwszNode = cluEnum.GetNext() )
    {
        shNode = OpenClusterNode( shCluster, pwszNode );

        ClusterToWMI( shNode, pHandlerIn );

    } // while: more nodes

    return WBEM_S_NO_ERROR;

} //*** CClusterService::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterService::ClusterToWMI(
//      HNODE               hNodeIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Translate a cluster node object to WMI object.
//
//  Arguments:
//      hNodeIn         -- Handle to node.
//      pHandlerIn      -- WMI sink 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterService::ClusterToWMI(
    HNODE               hNodeIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES,    FALSE },
        { CLUSCTL_NODE_GET_COMMON_PROPERTIES,       FALSE },
        { CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES,   TRUE },
        { CLUSCTL_NODE_GET_PRIVATE_PROPERTIES,      TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    UINT                idx;
    CError              er;

    m_pClass->SpawnInstance( 0, & wco );
    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList pl;
        er = pl.ScGetNodeProperties(
                hNodeIn,
                s_rgControl[ idx ].dwControl,
                NULL,
                0
                );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );
        
    } // for: each control code
    
    wco.SetProperty( L"ClusterService", PVD_PROP_SERVICE_NAME );

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterService::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve cluster node object based given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn 
    )
{
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;

    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode(
                shCluster,
                rObjPathIn.GetStringValueForProperty( PVD_PROP_SERVICE_SYSTEMNAME )
                );

    ClusterToWMI( shNode, pHandlerIn );

    return WBEM_S_NO_ERROR;

} //*** CClusterService::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterService::ExecuteMethod(
//      CObjPath &           rObjPathIn,
//      WCHAR *              pwszMethodNameIn,
//      long                 lFlagIn,
//      IWbemClassObject *   pParamsIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Execute methods defined in the mof for cluster node.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFENODE            shNode;
    CError              er;
    
    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_SERVICE_SYSTEMNAME )
        );

    if ( _wcsicmp( pwszMethodNameIn, PVD_MTH_SERVICE_PAUSE ) == 0 )
    {
        er = PauseClusterNode( shNode );
    } // if: PAUSE
    else if( _wcsicmp( pwszMethodNameIn, PVD_MTH_SERVICE_RESUME ) == 0 ) 
    {
        er = ResumeClusterNode( shNode );
    } // else if: RESUME
    else
    {
        er = static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    }

    return WBEM_S_NO_ERROR;

} //*** CClusterService::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterService::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_NODE_GET_COMMON_PROPERTIES,
            CLUSCTL_NODE_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_NODE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_NODE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD    s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    CError          er;
    UINT            idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_SERVICE_SYSTEMNAME );

    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;
        er = plOld.ScGetNodeProperties(
                    shNode,
                    s_rgControl[ idx ].dwGetControl,
                    NULL,
                    NULL,
                    0
                    );

        CClusterApi::SetObjectProperties(
                        RgGetPropMap(),
                        plNew,
                        plOld,
                        rInstToPutIn,
                        s_rgControl[ idx ].fPrivate
                        );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterNodeControl(
                        shNode,
                        NULL,
                        s_rgControl[ idx ].dwSetControl,
                        plNew.PbPropList(),
                        plNew.CbPropList(),
                        NULL,
                        0,
                        NULL
                        );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterService::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterService::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterService::DeleteInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterresrestype.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResResType.h
//
//  Implementation File:
//      ClusterResResType.cpp
//
//  Description:
//      Definition of the CClusterResResType class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterResResType;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResResType
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResResType : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterResResType::CClusterResResType(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterResResType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterresourcetype.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResourceType.h
//
//  Implementation File:
//      ClusterResourceType.cpp
//
//  Description:
//      Definition of the CClusterResourceType class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterResourceType;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResourceType
//
//  Description:
//      Provider Implement for cluster resource type
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResourceType : public CProvBase
{
//
// constructor
//
public:
    CClusterResourceType::CClusterResourceType(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HCLUSTER             hClusterIn,
        LPCWSTR              pwszNameIn,
        IWbemObjectSink *    pHandlerIn
      );

}; //*** class CClusterResourceType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterwmiprovider.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterWMIProvider.cpp
//
//  Description:
//      Implementation of the provider registration and entry point.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <initguid.h>
#include "ProvFactory.h"
#include "InstanceProv.h"
#include "EventProv.h"
#include "ClusterWMIProvider.tmh"

//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////


// {598065EA-EDC9-4b2c-913B-5104D04D098A}
DEFINE_GUID( CLSID_CLUSTER_WMI_PROVIDER,
0x598065ea, 0xedc9, 0x4b2c, 0x91, 0x3b, 0x51, 0x4, 0xd0, 0x4d, 0x9, 0x8a );

// {6A52C339-DCB0-4682-8B1B-02DE2C436A6D}
DEFINE_GUID( CLSID_CLUSTER_WMI_CLASS_PROVIDER,
0x6a52c339, 0xdcb0, 0x4682, 0x8b, 0x1b, 0x2, 0xde, 0x2c, 0x43, 0x6a, 0x6d );

// {92863246-4EDE-4eff-B606-79C1971DB230}
DEFINE_GUID( CLSID_CLUSTER_WMI_EVENT_PROVIDER,
0x92863246, 0x4ede, 0x4eff, 0xb6, 0x6, 0x79, 0xc1, 0x97, 0x1d, 0xb2, 0x30 );

// Count number of objects and number of locks.

long        g_cObj = 0;
long        g_cLock = 0;
HMODULE     g_hModule;

FactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_CLUSTER_WMI_PROVIDER,
        CInstanceProv::S_HrCreateThis,
        L"Cluster service WMI instance provider"
    },
    {
        &CLSID_CLUSTER_WMI_CLASS_PROVIDER,
        CClassProv::S_HrCreateThis,
        L"Cluster service WMI class provider"
    },
    {
        &CLSID_CLUSTER_WMI_EVENT_PROVIDER,
        CEventProv::S_HrCreateThis,
        L"Cluster service WMI event provider"
    },
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  WINAPI
//  DllMain(
//      HANDLE  hModule,
//      DWORD   ul_reason_for_call,
//      LPVOID  lpReserved
//      )
//
//  Description:
//      Main DLL entry point.
//
//  Arguments:
//      hModule             -- DLL module handle.
//      ul_reason_for_call  -- 
//      lpReserved          -- 
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
    HANDLE  hModule,
    DWORD   ul_reason_for_call,
    LPVOID  lpReserved
    )
{


// begin_wpp config
// CUSTOM_TYPE(dllreason, ItemListLong(DLL_PROCESS_DETACH, DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, DLL_THREAD_DETACH) );
//
// CUSTOM_TYPE(EventIdx, ItemSetLong(NODE_STATE, NODE_DELETED, NODE_ADDED, NODE_PROPERTY, REGISTRY_NAME,REGISTRY_ATTRIBUTES, REGISTRY_VALUE, REGISTRY_SUBTREE, RESOURCE_STATE, RESOURCE_DELETED, RESOURCE_ADDED, RESOURCE_PROPERTY, GROUP_STATE, GROUP_DELETED, GROUP_ADDED, GROUP_PROPERTY, RESOURCE_TYPE_DELETED, RESOURCE_TYPE_ADDED, RESOURCE_TYPE_PROPERTY, CLUSTER_RECONNECT, NETWORK_STATE, NETWORK_DELETED, NETWORK_ADDED, NETWORK_PROPERTY, NETINTERFACE_STATE, NETINTERFACE_DELETED, NETINTERFACE_ADDED, NETINTERFACE_PROPERTY, QUORUM_STATE, CLUSTER_STATE, CLUSTER_PROPERTY, HANDLE_CLOSE));
//
// CUSTOM_TYPE(GroupState, ItemListLong(Online, Offline, Failed, PartialOnline, Pending) );
// CUSTOM_TYPE(ResourceState, ItemListLong(Initing, Initializing, Online, Offline, Failed) );
// end_wpp
//
// Cluster event filter flags.
//
/*
    NODE_STATE               = 0x00000001,
    NODE_DELETED             = 0x00000002,
    NODE_ADDED               = 0x00000004,
    NODE_PROPERTY            = 0x00000008,

    REGISTRY_NAME            = 0x00000010,
    REGISTRY_ATTRIBUTES      = 0x00000020,
    REGISTRY_VALUE           = 0x00000040,
    REGISTRY_SUBTREE         = 0x00000080,

    RESOURCE_STATE           = 0x00000100,
    RESOURCE_DELETED         = 0x00000200,
    RESOURCE_ADDED           = 0x00000400,
    RESOURCE_PROPERTY        = 0x00000800,

    GROUP_STATE              = 0x00001000,
    GROUP_DELETED            = 0x00002000,
    GROUP_ADDED              = 0x00004000,
    GROUP_PROPERTY           = 0x00008000,

    RESOURCE_TYPE_DELETED    = 0x00010000,
    RESOURCE_TYPE_ADDED      = 0x00020000,
    RESOURCE_TYPE_PROPERTY   = 0x00040000,

    CLUSTER_RECONNECT        = 0x00080000,

    NETWORK_STATE            = 0x00100000,
    NETWORK_DELETED          = 0x00200000,
    NETWORK_ADDED            = 0x00400000,
    NETWORK_PROPERTY         = 0x00800000,

    NETINTERFACE_STATE       = 0x01000000,
    NETINTERFACE_DELETED     = 0x02000000,
    NETINTERFACE_ADDED       = 0x04000000,
    NETINTERFACE_PROPERTY    = 0x08000000,

    QUORUM_STATE             = 0x10000000,
    CLUSTER_STATE            = 0x20000000,
    CLUSTER_PROPERTY         = 0x40000000,

    
    HANDLE_CLOSE             = 0x80000000,
*/


//#ifdef _DEBUG
//    _CrtSetBreakAlloc( 228 );
//#endif

    TracePrint(("ClusWMI: DllMain entry, reason = %!dllreason!", ul_reason_for_call));
    g_hModule = static_cast< HMODULE >( hModule );

    switch ( ul_reason_for_call ) {

    case DLL_PROCESS_ATTACH:

    WPP_INIT_TRACING( NULL );
    break;

    case DLL_PROCESS_DETACH:

    WPP_CLEANUP();
    break;

    default:
    break;

    }

    return TRUE;

} //*** DllMain()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllCanUnloadNow( void )
//
//  Description:
//      Called periodically by Ole in order to determine if the
//      DLL can be freed.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = ( (0L == g_cObj) && (0L == g_cLock) ) ? S_OK : S_FALSE;
    TracePrint(("ClusWMI: DllCanUnloadNow is returning %d", sc));
    return sc;

} //*** DllCanUnloadNow()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllRegisterServer( void )
//
//  Description:
//      Called during setup or by regsvr32.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      SELFREG_E_CLASS
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{   
    WCHAR               wszID[ 128 ];
    WCHAR               wszCLSID[ 128 ];
    WCHAR               wszModule[ MAX_PATH ];
    INT                 idx;
    WCHAR *             pwszModel       = L"Both";
    HKEY                hKey1;
    HKEY                hKey2;
    DWORD               dwRt            =  ERROR_SUCCESS;
    INT                 cArray          = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    TracePrint(("ClusWMI: DllRegisterServer entry"));

    // Create the path.
    try
    {
        do
        {
            DWORD                           cbModuleNameSize    = 0;

            if ( GetModuleFileName( g_hModule, wszModule, MAX_PATH ) == 0 )
            {
                dwRt = GetLastError();
                break;
            }

            cbModuleNameSize = ( lstrlenW( wszModule ) + 1 ) * sizeof( wszModule[ 0 ] );

            for ( idx = 0 ; idx < cArray && dwRt == ERROR_SUCCESS ; idx++ )
            {
                LPCWSTR pwszName = g_FactoryDataArray[ idx ].m_pwszRegistryName;

                StringFromGUID2(
                    *g_FactoryDataArray[ idx ].m_pCLSID,
                    wszID,
                    128
                    );

                lstrcpyW( wszCLSID, L"Software\\Classes\\CLSID\\" );
                lstrcatW( wszCLSID, wszID );

                // Create entries under CLSID

                dwRt = RegCreateKeyW(
                            HKEY_LOCAL_MACHINE,
                            wszCLSID,
                            &hKey1
                            );
                if ( dwRt != ERROR_SUCCESS )
                {
                    break;
                }

                dwRt = RegSetValueEx(
                            hKey1,
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *) pwszName,
                            sizeof( WCHAR ) * ( lstrlenW( pwszName ) + 1 )
                            );
                if ( dwRt != ERROR_SUCCESS )
                {
                    break;
                }

                dwRt = RegCreateKeyW(
                            hKey1,
                            L"InprocServer32",
                            & hKey2
                            );

                if ( dwRt != ERROR_SUCCESS )
                {
                    break;
                }

                dwRt = RegSetValueEx(
                            hKey2,
                            NULL,
                            0,
                            REG_SZ,
                            (BYTE *) wszModule,
                            cbModuleNameSize
                            );

                if ( dwRt != ERROR_SUCCESS )
                {
                    break;
                }

                dwRt = RegSetValueExW(
                            hKey2,
                            L"ThreadingModel",
                            0,
                            REG_SZ,
                            (BYTE *) pwszModel,
                            sizeof( WCHAR ) * ( lstrlen( pwszModel ) + 1 )
                            );
                if ( dwRt != ERROR_SUCCESS )
                {
                    break;
                }
 
                RegCloseKey( hKey1 );
                RegCloseKey( hKey2 );
            } // for: each entry in factory entry array 

            if ( dwRt  != ERROR_SUCCESS )
            {
                break;
            }
        }
        while( false ); // dummy do-while loop to avoid gotos

    }
    catch ( ... )
    {
          RegCloseKey( hKey1 );
          RegCloseKey( hKey2 );
          dwRt = SELFREG_E_CLASS;
    }

    TracePrint(("ClusWMI: RegisterServer returned %d", dwRt));

    return dwRt;

} //*** DllRegisterServer()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllUnregisterServer( void )
//
//  Description:
//      Called when it is time to remove the registry entries.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      SELFREG_E_CLASS
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void )
{
    WCHAR   wszID[ 128 ];
    WCHAR   wszCLSID[ 128 ];
    HKEY    hKey;
    INT     idx;
    DWORD   dwRet   = ERROR_SUCCESS;
    INT     cArray  = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    for ( idx = 0 ; idx < 2 && dwRet == ERROR_SUCCESS ; idx++ )
    {
       StringFromGUID2(
            *g_FactoryDataArray[ idx ].m_pCLSID,
            wszID,
            128
            );

        lstrcpyW( wszCLSID, L"Software\\Classes\\CLSID\\" );
        lstrcatW( wszCLSID, wszID );

        // First delete the InProcServer subkey.

        dwRet = RegOpenKeyW(
                    HKEY_LOCAL_MACHINE,
                    wszCLSID,
                    &hKey
                    );
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
        
        dwRet = RegDeleteKeyW( hKey, L"InProcServer32" );
        RegCloseKey( hKey );

        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }

        dwRet = RegOpenKeyW(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Classes\\CLSID",
                    &hKey
                    );
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
        
        dwRet = RegDeleteKeyW( hKey,wszID );
        RegCloseKey( hKey );
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
    } // for: each object
    
    if ( dwRet != ERROR_SUCCESS )
    {
        dwRet = SELFREG_E_CLASS;
    }

    return dwRet;

} //*** DllUnregisterServer()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllGetClassObject(
//      REFCLSID    rclsidIn,
//      REFIID      riidIn,
//      PPVOID      ppvOut
//      )
//
//  Description:
//      Called by Ole when some client wants a class factory.  Return
//      one only if it is the sort of class this DLL supports.
//
//  Arguments:
//      rclsidIn    --
//      riidIn      --
//      ppvOut      --
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      E_OUTOFMEMORY
//      E_FAIL
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllGetClassObject(
    REFCLSID    rclsidIn,
    REFIID      riidIn,
    PPVOID      ppvOut
    )
{

    HRESULT         hr;
    CProvFactory *  pObj = NULL;
    UINT            idx;
    UINT            cDataArray = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    for ( idx = 0 ; idx < cDataArray ; idx++ )
    {
        if ( rclsidIn == *g_FactoryDataArray[ idx ].m_pCLSID )
        {
            pObj= new CProvFactory( &g_FactoryDataArray[ idx ] );
            if ( NULL == pObj )
            {
                return E_OUTOFMEMORY;
            }

            hr = pObj->QueryInterface( riidIn, ppvOut );

            if ( FAILED( hr ) )
            {
                delete pObj;
            }

            return hr;
        }
    }
    return E_FAIL;

} //*** DllGetClassObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\clusterservice.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterService.h
//
//  Implementation File:
//      ClusterService.cpp
//
//  Description:
//      Definition of the CClusterService class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterService;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterService
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterService : public CProvBase
{
//
// constructor
//
public:
    CClusterService::CClusterService(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance( 
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ); 

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HNODE               hNodeIn,
        IWbemObjectSink *   pHandlerIn
        );

}; //*** class CClusterService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\eventprov.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      EventProv.h
//
//  Implementation File:
//      EventProv.cpp
//
//  Description:
//      Definition of event provider class
//
//  Author:
//      Henry Wang (HenryWa)    19-JAN-2000
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////
#define EVENT_TABLE_SIZE 32

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CEventProv;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEventProv
//
//  Description:
//      Event provider
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEventProv
    : public IWbemEventProvider
    , public IWbemProviderInit
{
public:
    enum EEventStatus
    {
        esPENDING,
        esRUNNING,
        esPENDING_STOP,
        esSTOPPPED,

        esMX
    };

    enum EClusterNotificationType
    {
        cntCLUSTER_STATE_CHANGE =
            CLUSTER_CHANGE_NODE_STATE               |
            CLUSTER_CHANGE_RESOURCE_STATE           |
            CLUSTER_CHANGE_NETWORK_STATE            |
            CLUSTER_CHANGE_NETINTERFACE_STATE       |
            CLUSTER_CHANGE_QUORUM_STATE             |
            CLUSTER_CHANGE_CLUSTER_STATE,
        cntGROUP_STATE_CHANGE =
            CLUSTER_CHANGE_GROUP_STATE,
        cntRESOURCE_STATE_CHANGE =
            CLUSTER_CHANGE_RESOURCE_STATE,
        cntOBJECT_ADD =
            CLUSTER_CHANGE_NODE_ADDED               |
            CLUSTER_CHANGE_RESOURCE_ADDED           |
            CLUSTER_CHANGE_GROUP_ADDED              |
            CLUSTER_CHANGE_RESOURCE_TYPE_ADDED      |
            CLUSTER_CHANGE_NETWORK_ADDED            |
            CLUSTER_CHANGE_NETINTERFACE_ADDED,
        cntOBJECT_REMOVE =
            CLUSTER_CHANGE_NODE_DELETED             |
            CLUSTER_CHANGE_RESOURCE_DELETED         |
            CLUSTER_CHANGE_GROUP_DELETED            |
            CLUSTER_CHANGE_RESOURCE_TYPE_DELETED    |
            CLUSTER_CHANGE_NETWORK_DELETED          |
            CLUSTER_CHANGE_NETINTERFACE_DELETED,
        cntPROPERTY_CHANGE =
            CLUSTER_CHANGE_NODE_PROPERTY            |
            CLUSTER_CHANGE_RESOURCE_PROPERTY        |
            CLUSTER_CHANGE_GROUP_PROPERTY           |
            CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY   |
            CLUSTER_CHANGE_NETWORK_PROPERTY         |
            CLUSTER_CHANGE_NETINTERFACE_PROPERTY    |
            CLUSTER_CHANGE_CLUSTER_PROPERTY
    };

    enum EEventObjectType
    {
        eotHANDLE = 0,
        eotCLUSTER,
        eotNODE,
        eotGROUP,
        eotRESOURCE,
        eotRESOURCE_TYPE,
        eotNETWORK,
        eotNET_INTERFACE,
        eotREGISTRY,
        eotQUORUM,

        eotMX
    };

    typedef void (*FPSETPROP)(
        CWbemClassObject &  pwcoIn,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    struct SEventTypeTable
    {
        CLUSTER_CHANGE      m_eType;
        EEventObjectType    m_eotObjectType;
        LPCWSTR             m_pwszMof;
        IWbemClassObject *  m_pwco;
        FPSETPROP           m_pfn;
    };

    void InsertTable(
        DWORD               dwIdxIn,
        CLUSTER_CHANGE      eTypeIn,
        EEventObjectType    eotObjectTypeIn,
        LPCWSTR             pwszMofIn,
        IWbemClassObject *  pwcoIn,
        FPSETPROP           pfnIn
        );

    SEventTypeTable  m_EventTypeTable[ 32 ];

    CEventProv( void );
    ~CEventProv( void );

    //
    // IUnknown members
    //
    STDMETHODIMP            QueryInterface( REFIID riid, LPVOID * ppv );
    STDMETHODIMP_( ULONG )  AddRef( void );
    STDMETHODIMP_( ULONG )  Release( void );

    // Inherited from IWbemEventProvider

    HRESULT STDMETHODCALLTYPE ProvideEvents( 
        IWbemObjectSink *   pSinkIn,
        long                lFlagsIn
        );

    // Inherited from IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize( 
        LPWSTR                  pwszUserIn,
        LONG                    lFlagsIn,
        LPWSTR                  pwszNamespaceIn,
        LPWSTR                  pwszLocaleIn,
        IWbemServices *         pNamespaceIn,
        IWbemContext *          pCtxIn,
        IWbemProviderInitSink * pInitSinkIn
        );

    static HRESULT S_HrCreateThis(
        IUnknown *  pUnknownOuterIn,
        VOID **     ppvOut
        );

protected:
    ULONG               m_cRef;
    IWbemServices *     m_pNs;
    IWbemObjectSink *   m_pSink;
    IWbemClassObject *  m_pEventAdd;
    IWbemClassObject *  m_pEventRemove;
    IWbemClassObject *  m_pEventProperty;
    IWbemClassObject *  m_pEventState;
    IWbemClassObject *  m_pEventGroupState;
    IWbemClassObject *  m_pEventResourceState;
    EEventStatus        m_esStatus;
    HANDLE              m_hThread;
    BOOL                m_fStopped;
    HCHANGE             m_hChange;

    static void S_SetEventProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static void S_AddEvent(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static void S_DeleteEvent(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static void S_SetNodeStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );
    
    static void S_SetGroupStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );
    
    static void S_SetResourceStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );
 
    static void S_SetNetworkStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static void S_SetNetInterfaceStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static DWORD WINAPI S_EventThread(
        LPVOID pArgIn
        );

    void InstanceThread( void );

}; //*** class CEventProv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\common.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Common.h
//
//  Description:
//      Definition of common type, constant and header files.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once
#pragma warning( disable : 4786 )

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

using namespace std;

class CProvBase;
class CObjPath;
class CWbemClassObject;

extern long       g_cObj;
extern long       g_cLock;

typedef LPVOID * PPVOID;

typedef CProvBase * ( * FPNEW )(
    IN LPCWSTR          pwszName,
    IN CWbemServices *  pNamespace,
    DWORD               dwEnumType
    );

typedef void ( * FPFILLWMI )(
    IN PVOID                phCluster,
    IN PVOID                phClusterObj,
    IN LPCWSTR              pwszName,
    IN IWbemClassObject *   pClass,
    IN IWbemServices *      pServices, 
    IN IWbemObjectSink *    pHandler
    );

LPWSTR PwszSpaceReplace(
    LPWSTR      pwszTrgInout,
    LPCWSTR     pwszSrcIn,
    WCHAR       wchArgIn
    );

enum PROP_TYPE
{
    DWORD_TYPE,
    SZ_TYPE,
    MULTI_SZ_TYPE
};

enum ACCESS_TYPE
{   
    READONLY,
    READWRITE
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  typedef struct SPropMapEntry
//
//  Description:
//      structure to map property name defined in mof
//      to the property name defined in wolfpack header.
//      PropertyType indicate the type of wolfpack properties.
//      Mof property is always in VARIANT format and it's type 
//      is in vt field
//
//--
//////////////////////////////////////////////////////////////////////////////

struct SPropMapEntry
{
    LPCWSTR     mofName;
    LPCWSTR     clstName;
    PROP_TYPE   PropertyType;
    ACCESS_TYPE Access;

};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  struct SPropMapEntryArray
//
//  Description:
//      Array of SPropMapEntry
//
//--
//////////////////////////////////////////////////////////////////////////////
struct SPropMapEntryArray
{
    SPropMapEntryArray(
        DWORD           dwSizeIn,
        SPropMapEntry * pArrayIn
        )
        : m_dwSize( dwSizeIn )
        , m_pArray( pArrayIn )
    {
    }

    LPCWSTR PwszLookup( LPCWSTR pwszIn ) const;

    DWORD           m_dwSize;
    SPropMapEntry * m_pArray;

};

struct SGetSetControl
{
    DWORD   dwGetControl;
    DWORD   dwSetControl;
    BOOL    fPrivate;
};

struct SGetControl
{
    DWORD   dwControl;
    BOOL    fPrivate;
};

void CreateClass(
    const WCHAR *           pwszClassNameIn,
    CWbemServices *         pNamespaceIn, 
    auto_ptr<CProvBase>&    rNewClassInout
    );

// CLUSTER
extern const WCHAR * const PVD_CLASS_CLUSTER;
extern const WCHAR * const PVD_CLASS_CLUSTERTONETWORKS;
extern const WCHAR * const PVD_CLASS_CLUSTERTONETINTERFACE;
extern const WCHAR * const PVD_CLASS_CLUSTERTONODE;
extern const WCHAR * const PVD_CLASS_CLUSTERTOQUORUMRES;
extern const WCHAR * const PVD_CLASS_CLUSTERTORES;
extern const WCHAR * const PVD_CLASS_CLUSTERTORESTYPE;
extern const WCHAR * const PVD_CLASS_CLUSTERTOGROUP;

extern const WCHAR * const PVD_PROP_CLUSTER_SECURITY;
extern const WCHAR * const PVD_PROP_CLUSTER_SECURITYDESCRIPTOR;
extern const WCHAR * const PVD_PROP_CLUSTER_NAME;
extern const WCHAR * const PVD_PROP_CLUSTER_GROUPADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_NODEADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_RESADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_RESTYPEADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_NETWORKADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_NETINTFACEADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_FILE;
extern const WCHAR * const PVD_PROP_CLUSTER_LOGSIZE;
extern const WCHAR * const PVD_PROP_CLUSTER_NETWORK;

extern const WCHAR * const CLUS_CLUS_GROUPADMIN;
extern const WCHAR * const CLUS_CLUS_NETWORKADMIN;
extern const WCHAR * const CLUS_CLUS_NETINTERFACEADMIN;
extern const WCHAR * const CLUS_CLUS_NODEADMIN;
extern const WCHAR * const CLUS_CLUS_RESADMIN;
extern const WCHAR * const CLUS_CLUS_RESTYPEADMIN;

extern const WCHAR * const PVD_MTH_CLUSTER_RENAME;
extern const WCHAR * const PVD_MTH_CLUSTER_SETQUORUM;
extern const WCHAR * const PVD_MTH_CLUSTER_PARM_NEWNAME;
extern const WCHAR * const PVD_MTH_CLUSTER_PARM_RESOURCE;


// NODE
extern const WCHAR * const PVD_CLASS_NODE;
extern const WCHAR * const PVD_CLASS_NODEACTIVEGROUP;
extern const WCHAR * const PVD_CLASS_NODETONETINTERFACE;
extern const WCHAR * const PVD_CLASS_NODEACTIVERES;

extern const WCHAR * const PVD_PROP_NODE_NAME;

// RESOURCE
extern const WCHAR * const PVD_CLASS_RESOURCE;
extern const WCHAR * const PVD_CLASS_RESDEPRES;
extern const WCHAR * const PVD_CLASS_RESRESOURCETYPE;

extern const WCHAR * const PVD_PROP_RES_NAME;
extern const WCHAR * const PVD_PROP_RES_STATE;
extern const WCHAR * const PVD_PROP_RES_PRIVATE;
extern const WCHAR * const PVD_PROP_RES_CHECKPOINTS;
extern const WCHAR * const PVD_PROP_RES_CRYPTO_CHECKPOINTS;
extern const WCHAR * const PVD_PROP_RES_CORE_RESOURCE;

extern const WCHAR * const PVD_MTH_RES_ONLINE;
extern const WCHAR * const PVD_MTH_RES_OFFLINE;
extern const WCHAR * const PVD_MTH_RES_ADD_DEPENDENCY;
extern const WCHAR * const PVD_MTH_RES_CHANGE_GROUP;
extern const WCHAR * const PVD_MTH_RES_CREATE_RESOURCE;
extern const WCHAR * const PVD_MTH_RES_FAIL_RESOURCE;
extern const WCHAR * const PVD_MTH_RES_REMOVE_DEPENDENCY;
extern const WCHAR * const PVD_MTH_RES_RENAME;
extern const WCHAR * const PVD_MTH_RES_DELETE;
extern const WCHAR * const PVD_MTH_RES_ADD_REG_CHECKPOINT;
extern const WCHAR * const PVD_MTH_RES_DEL_REG_CHECKPOINT;
extern const WCHAR * const PVD_MTH_RES_ADD_CRYPTO_CHECKPOINT;
extern const WCHAR * const PVD_MTH_RES_DEL_CRYPTO_CHECKPOINT;


extern const WCHAR * const PVD_MTH_PARM_RESOURCE;
extern const WCHAR * const PVD_MTH_PARM_GROUP;
extern const WCHAR * const PVD_MTH_PARM_NEWNAME;
extern const WCHAR * const PVD_MTH_PARM_RES_NAME;
extern const WCHAR * const PVD_MTH_PARM_RES_TYPE;
extern const WCHAR * const PVD_MTH_PARM_SEP_MONITOR;
extern const WCHAR * const PVD_MTH_PARM_RES_CHECKPOINT_NAME;


// RESOURCETYPE
extern const WCHAR * const PVD_CLASS_RESOURCETYPE;

extern const WCHAR * const PVD_PROP_RESTYPE_NAME;
extern const WCHAR * const PVD_PROP_RESTYPE_DLLNAME;
extern const WCHAR * const PVD_PROP_RESTYPE_ADMINEXTENSIONS;
extern const WCHAR * const PVD_PROP_RESTYPE_ISALIVE;
extern const WCHAR * const PVD_PROP_RESTYPE_LOOKSALIVE;
extern const WCHAR * const PVD_PROP_RESTYPE_DESCRIPTION;
extern const WCHAR * const PVD_PROP_RESTYPE_QUORUM_CAPABLE;
extern const WCHAR * const PVD_PROP_RESTYPE_LOCALQUORUM_CAPABLE;
extern const WCHAR * const PVD_PROP_RESTYPE_DELETE_REQUIRES_ALL_NODES;

// GROUP
extern const WCHAR * const PVD_CLASS_GROUP;
extern const WCHAR * const PVD_CLASS_GROUPTORES;

extern const WCHAR * const PVD_PROP_GROUP_NAME;
extern const WCHAR* const PVD_PROP_NODELIST;

extern const WCHAR * const PVD_MTH_GROUP_CREATEGROUP;
extern const WCHAR * const PVD_MTH_GROUP_TAKEOFFLINE;
extern const WCHAR * const PVD_MTH_GROUP_BRINGONLINE;
extern const WCHAR * const PVD_MTH_GROUP_MOVETONEWNODE;
extern const WCHAR * const PVD_MTH_GROUP_DELETE;
extern const WCHAR * const PVD_MTH_GROUP_RENAME;
extern const WCHAR * const PVD_MTH_GROUP_PARM_GROUPNAME;
extern const WCHAR * const PVD_MTH_GROUP_PARM_NODENAME;
extern const WCHAR * const PVD_MTH_GROUP_PARM_NEWNAME;


// NetworkInterface
extern const WCHAR * const PVD_CLASS_NETWORKSINTERFACE;

extern const WCHAR * const PVD_PROP_NETINTERFACE_DEVICEID;
extern const WCHAR * const PVD_PROP_NETINTERFACE_SYSTEMNAME;
extern const WCHAR * const PVD_PROP_NETINTERFACE_STATE;

// NetworkName
extern const WCHAR * const PVD_CLASS_NETWORKNAME;

// networks
extern const WCHAR * const PVD_CLASS_NETWORKS;
extern const WCHAR * const PVD_CLASS_NETTONETINTERFACE;

extern const WCHAR * const PVD_PROP_NETWORK_STATE;
extern const WCHAR * const PVD_MTH_NETWORK_RENAME;
extern const WCHAR * const PVD_MTH_NETWORK_PARM_NEWNAME;

// service
extern const WCHAR * const PVD_CLASS_SERVICES;
extern const WCHAR * const PVD_CLASS_HOSTEDSERVICES;

extern const WCHAR * const PVD_PROP_SERVICE_NAME;
extern const WCHAR * const PVD_PROP_SERVICE_SYSTEMNAME;

extern const WCHAR * const PVD_MTH_SERVICE_PAUSE;
extern const WCHAR * const PVD_MTH_SERVICE_RESUME;

// event

extern const WCHAR * const PVD_CLASS_EVENT;
extern const WCHAR * const PVD_PROP_EVENT_NAME;
extern const WCHAR * const PVD_PROP_EVENT_PATH;
extern const WCHAR * const PVD_PROP_EVENT_TYPE;
extern const WCHAR * const PVD_PROP_EVENT_TYPEMAJOR;
extern const WCHAR * const PVD_PROP_EVENT_TYPEMINOR;
extern const WCHAR * const PVD_PROP_EVENT_NEWSTATE;
extern const WCHAR * const PVD_PROP_EVENT_NODE;
extern const WCHAR * const PVD_PROP_EVENT_GROUP;

extern const WCHAR * const PVD_CLASS_EVENT_ADD;
extern const WCHAR * const PVD_CLASS_EVENT_REMOVE;
extern const WCHAR * const PVD_CLASS_EVENT_STATECHANGE;
extern const WCHAR * const PVD_CLASS_EVENT_GROUPSTATECHANGE;
extern const WCHAR * const PVD_CLASS_EVENT_RESOURCESTATECHANGE;
extern const WCHAR * const PVD_CLASS_EVENT_PROP;

extern const WCHAR * const PVD_CLASS_PROPERTY;

extern const WCHAR * const PVD_PROP_NAME;
extern const WCHAR * const PVD_PROP_STATE;
extern const WCHAR * const PVD_PROP_GROUPCOMPONENT;
extern const WCHAR * const PVD_PROP_PARTCOMPONENT;
extern const WCHAR * const PVD_PROP_CHARACTERISTIC;
extern const WCHAR * const PVD_PROP_FLAGS;


extern const WCHAR * const PVD_WBEM_EXTENDEDSTATUS;
extern const WCHAR * const PVD_WBEM_DESCRIPTION;
extern const WCHAR * const PVD_WBEM_STATUSCODE;
extern const WCHAR * const PVD_WBEM_STATUS;
extern const WCHAR * const PVD_WBEM_CLASS;
extern const WCHAR * const PVD_WBEM_RELPATH;
extern const WCHAR * const PVD_WBEM_PROP_ANTECEDENT;
extern const WCHAR * const PVD_WBEM_PROP_DEPENDENT;
extern const WCHAR * const PVD_WBEM_PROP_DEVICEID;
extern const WCHAR * const PVD_WBEM_QUA_DYNAMIC;
extern const WCHAR * const PVD_WBEM_QUA_CIMTYPE;

extern const WCHAR * const PVD_WBEM_QUA_PROV_VALUE;
extern const WCHAR * const PVD_WBEM_QUA_PROV_NAME;


class CClassData
{
public:
    const WCHAR * wszClassName;
    FPNEW pfConstruct;
    const char * szType;

}; // *** class CClassData

class CClassCreator
{
public:
    CClassCreator( void )
        : m_pfnConstructor( NULL )
        , m_pbstrClassName( L"" )
        { };
    CClassCreator(
        FPNEW           pfnIn,
        const WCHAR *   pwszClassNameIn,
        DWORD           dwEnumTypeIn
        )
        : m_pfnConstructor( pfnIn )
        , m_pbstrClassName( pwszClassNameIn )
        , m_dwEnumType( dwEnumTypeIn )
        { };
    FPNEW           m_pfnConstructor;
    _bstr_t         m_pbstrClassName;
    DWORD           m_dwEnumType;

}; //*** class CClassCreator

template< class _Ty >
struct strLessThan : binary_function< _Ty, _Ty, bool >
{
    bool operator()( const _Ty& _X, const _Ty& _Y ) const
    {
        return ( _wcsicmp( _X, _Y ) < 0 );
    }

}; //*** struct strLessThan

typedef map< _bstr_t, CClassCreator, strLessThan< _bstr_t > > ClassMap;
typedef map< _bstr_t, _bstr_t, strLessThan< _bstr_t > > TypeNameToClass;
extern TypeNameToClass  g_TypeNameToClass;
extern ClassMap         g_ClassMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\eventprov.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterService.cpp
//
//  Description:    
//      Implementation of CClusterService class 
//
//  Author:
//      Henry Wang (HenryWa) 19-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "EventProv.h"
#include "EventProv.tmh"
#include "clustergroup.h"

//****************************************************************************
//
//  CEventProv
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEventProv::CEventProv( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEventProv::CEventProv( void )
    : m_pNs( 0 )
    , m_pSink( 0 )
    , m_cRef( 0 )
    , m_pEventAdd( 0 )
    , m_pEventRemove( 0 )
    , m_pEventState( 0 )
    , m_pEventGroupState( 0 )
    , m_pEventResourceState( 0 )
    , m_pEventProperty( 0 )
    , m_hThread( 0 )
    , m_esStatus( esPENDING )
{
    UINT idx;
    for ( idx = 0; idx < EVENT_TABLE_SIZE ; idx++ )
    {
        m_EventTypeTable[ idx ].m_pwco = NULL;
        m_EventTypeTable[ idx ].m_pfn = NULL;
    }
    InterlockedIncrement( &g_cObj );

} //*** CEventProv::CEventProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEventProv::!CEventProv( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEventProv::~CEventProv( void )
{
    InterlockedDecrement( &g_cObj );

    if ( m_hThread != NULL )
    {
        CloseHandle( m_hThread );
    }

    if ( m_pNs != NULL )
    {
        m_pNs->Release();
    }

    if ( m_pSink != NULL )
    {
        m_pSink->Release();
    }

    if ( m_pEventAdd != NULL )
    {
        m_pEventAdd->Release();
    }

    if ( m_pEventRemove != NULL )
    {
        m_pEventRemove->Release();
    }

    if ( m_pEventState != NULL )
    {
        m_pEventState->Release();
    }

    if ( m_pEventGroupState != NULL )
    {
        m_pEventGroupState->Release();
    }

    if ( m_pEventResourceState != NULL )
    {
        m_pEventResourceState->Release();
    }

    if ( m_pEventProperty != NULL )
    {
        m_pEventProperty->Release();
    }

} //*** CEventProv::~CEventProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CEventProv::QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//  Description:
//      Query for interfaces supported by this COM object.
//
//  Arguments:
//      riid    -- Interface being queried for.
//      ppv     -- Pointer in which to return interface pointer.
//
//  Return Values:
//      NOERROR
//      E_NOINTERFACE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEventProv::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    *ppv = 0;

    if ( IID_IUnknown == riid || IID_IWbemEventProvider == riid )
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if ( IID_IWbemProviderInit == riid )
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;

} //*** CEventProv::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEventProv::AddRef( void )
//
//  Description:
//      Add a reference to the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEventProv::AddRef( void )
{
    return InterlockedIncrement( (LONG *) &m_cRef );

} //*** CEventProv::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEventProv::Release( void )
//
//  Description:
//      Release a reference on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEventProv::Release( void )
{
    LONG cRef = InterlockedDecrement( (LONG *) &m_cRef );
    if ( 0L ==  cRef )
    {
        m_esStatus = esPENDING_STOP;
        CancelIo( m_hChange );
        //
        // wait for the thread completely stopped
        //
        while ( ! m_fStopped )
        {
            Sleep( 100 );
        }
        delete this;
    }
    
    return cRef;

} //*** CEventProv::Release()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CEventProv::ProvideEvents(
//      IWbemObjectSink *   pSinkIn,
//      long                lFlagsIn
//      )
//
//  Description:
//      Start the provider to generate event
//      Called by wmi
//
//  Arguments:
//      pSinkIn     -- WMI sink pointer to send event back
//      lFlagsIn    -- WMI flag
//
//  Return Values:
//      WBEM_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEventProv::ProvideEvents(
    IWbemObjectSink *   pSinkIn,
    long                lFlagsIn
    )
{
    // Copy the sink.
    // ==============
    m_pSink = pSinkIn;
    m_pSink->AddRef();

    // Create the event thread.
    // ========================
    
    DWORD dwTID;
    
    m_hThread = CreateThread(
                    0,
                    0,
                    CEventProv::S_EventThread,
                    this,
                    0,
                    &dwTID
                    );


    // Wait for provider to be 'ready'.
    // ================================
    
    while ( m_esStatus != esRUNNING )
    {
        Sleep( 100 );
    }

    return WBEM_NO_ERROR;

} //*** CEventProv::ProvideEvents

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  DWORD
//  WINAPI
//  CEventProv::S_EventThread(
//      LPVOID  pArgIn
//      )
//
//  Description:
//      Event thread proc.
//
//  Arguments:
//      pArgIn  -- 
//
//  Return Values:
//      Any return values from CEventProv::InstanceThread().
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
CEventProv::S_EventThread(
    LPVOID pArgIn
    )
{
    // Make transition to the per-instance method.
    // ===========================================
    
    ((CEventProv *) pArgIn)->InstanceThread();
    return 0;

} //*** CEventProv::S_EventThread()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CEventProv::InstanceThread( void )
//
//  Description:
//      This function is started as seperated thread, waiting for cluster
//      event notification and then send event back to wmi
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::InstanceThread( void )
{
    SAFECLUSTER     shCluster;
    //SAFECHANGE      shChange;
    DWORD           dwError;
    DWORD_PTR       dwpNotifyKey;
    DWORD           cchName = MAX_PATH;
    DWORD           dwFilterType;
    HRESULT         hr = S_OK;
    CWstrBuf        wsbName;
    CError          er;
    DWORD           cchReturnedName;

    try
    {
        m_esStatus = esRUNNING;
        m_fStopped = FALSE;
        shCluster = OpenCluster( NULL );
        m_hChange = CreateClusterNotifyPort(
                        (HCHANGE) INVALID_HANDLE_VALUE,
                        shCluster,
                        ( cntCLUSTER_STATE_CHANGE | cntOBJECT_ADD | cntOBJECT_REMOVE
                        | cntPROPERTY_CHANGE | cntGROUP_STATE_CHANGE
                        | cntRESOURCE_STATE_CHANGE ),
                        1
                        );

        wsbName.SetSize( cchName );

        while ( m_esStatus == esRUNNING )
        {
            cchReturnedName = cchName;
            wsbName.Empty();    // Null out the name field
            //TracePrint(("Call GetClusterNotify to get next notification event\n"));
            dwError = GetClusterNotify(
                            m_hChange,
                            &dwpNotifyKey,
                            &dwFilterType,
                            wsbName,
                            &cchReturnedName,
                            400
                            ); 

            if ( dwError == ERROR_MORE_DATA )
            {
                cchName =  ++cchReturnedName;
                wsbName.SetSize( cchName );
                dwError = GetClusterNotify(
                                m_hChange,
                                &dwpNotifyKey,
                                &dwFilterType,
                                wsbName,
                                &cchReturnedName,
                                400
                                );
            } // if: more data

            if ( dwError == ERROR_SUCCESS )
            {
                CWbemClassObject    wco;
                UINT                idx;
                DWORD               dwType;
                SEventTypeTable *   pTypeEntry = NULL;
            
                //
                // locate table index for the event type
                //
                dwType = dwFilterType;
                for ( idx = 0 ; (idx < EVENT_TABLE_SIZE) && ! ( dwType & 0x01 ) ; idx++ )
                {
                    dwType = dwType >> 1;
                }
                TracePrint(("Received <%ws> event, ChangeEvent = %!EventIdx!", wsbName, dwFilterType));
            
                pTypeEntry = &m_EventTypeTable[ idx ];
                if ( pTypeEntry->m_pwco != NULL )
                {
                    pTypeEntry->m_pwco->SpawnInstance( 0, &wco );

                    try {
                      pTypeEntry->m_pfn(
                        wco,
                        pTypeEntry->m_pwszMof,
                        //pwszName,
                        wsbName,
                        pTypeEntry->m_eotObjectType,
                        dwFilterType
                        );
                    } // try
                        catch ( ... )
                    {
                        TracePrint(("  ****  Exception on last Event call\n"));
                    } // catch
                } // if: 

                er = m_pSink->Indicate( 1, &wco );

            } // if: success

        } // while: running
    } // try
    catch( ... )
    {
        TracePrint(("Exiting event provider loop! %lx\n", m_esStatus));
        // bugbug: when error occured, event provider should be shut down, 
        // the provider should notify wmi and clean up. 
        // wmi doesn't handle this release call correctly.
        m_pSink->Release();
        //
        // set it to null to provent being released again by destructor
        //
        m_pSink = NULL;
    } // catch

    m_fStopped = TRUE;
  
} //*** CEventProv::InstanceThread()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetEventProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set an event property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetEventProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    CObjPath op;

    TracePrint(("Set event property for <%ws>:<%ws>, Event = %!EventIdx!", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
    
    pwcoInout.SetProperty( pwszObjectNameIn, PVD_PROP_EVENT_NAME );
    pwcoInout.SetProperty( static_cast< DWORD >( eotObjectTypeIn ), PVD_PROP_EVENT_TYPE );
    pwcoInout.SetProperty( static_cast< DWORD >( 0 ), PVD_PROP_EVENT_TYPEMAJOR );
    pwcoInout.SetProperty( dwEventMinorIn, PVD_PROP_EVENT_TYPEMINOR );

    //
    // setting object path
    //
    if ( ! op.Init( NULL ) )
    {
        TracePrint(("  ****  Out of memory! Throwing exception.\n"));
        throw WBEM_E_OUT_OF_MEMORY;
    }
    op.SetClass( pwszMofClassNameIn );

    //
    // net interface objectpath is different from all the other objects
    //
    if ( eotObjectTypeIn == eotNET_INTERFACE )
    {
        SAFECLUSTER         shCluster;
        SAFENETINTERFACE    shNetInterface;
        DWORD               cbName = MAX_PATH;
        CWstrBuf            wsbName;
        DWORD               cbReturn;
        CError              er;

        shCluster = OpenCluster( NULL );
        wsbName.SetSize( cbName );
        shNetInterface = OpenClusterNetInterface( shCluster, pwszObjectNameIn );

        //
        // NOTE - I didn't handle error_more_data, since max_path should be 
        // large enough for node name
        //
        er = ClusterNetInterfaceControl(
                    shNetInterface,
                    NULL,
                    CLUSCTL_NETINTERFACE_GET_NODE,
                    NULL,
                    0,
                    wsbName,
                    cbName,
                    &cbReturn
                    );

        op.AddProperty( PVD_PROP_NETINTERFACE_SYSTEMNAME, wsbName );
        op.AddProperty( PVD_PROP_NETINTERFACE_DEVICEID,   pwszObjectNameIn );
    } //if: event is net interface
    else
    {
        op.AddProperty( PVD_PROP_NAME, pwszObjectNameIn );
    }

    pwcoInout.SetProperty(
        static_cast< LPCWSTR >( op.GetObjectPathString() ),
        PVD_PROP_EVENT_PATH
        );

} //*** CEventProv::S_SetEventProperty()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_AddEvent(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set an event property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_AddEvent(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    //CObjPath op;
    //SAFECLUSTER shCluster;

    switch ( eotObjectTypeIn )
    {
        case eotGROUP:
        {
            //SAFEGROUP   shGroup;

            TracePrint(("Add group event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
            break;
        }

        case eotRESOURCE:
        {
            TracePrint(("Add resource event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
            break;
        }


        default:
            TracePrint(("Add object event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
            TracePrint(("  ****  Unknown Object Type!\n"));
            throw WBEM_E_INVALID_PARAMETER;
    }


} //*** CEventProv::S_AddEvent()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_DeleteEvent(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set an event property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_DeleteEvent(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    //CObjPath op;
    //SAFECLUSTER     shCluster;

    switch ( eotObjectTypeIn )
    {
        case eotGROUP:
        {
            //SAFEGROUP   shGroup;

            TracePrint(("Delete group event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
            break;
        }

        case eotRESOURCE:
        {
            TracePrint(("Delete resource event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
            break;
        }

        default:
            TracePrint(("Delete object event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
            TracePrint(("  ****  Unknown Object Type!\n"));
            throw WBEM_E_INVALID_PARAMETER;
    }

} //*** CEventProv::S_DeleteEvent()

#if 0
//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetClusterStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a node state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetClusterStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    DWORD       dwState;
    DWORD       dwError;

    dwError = GetNodeClusterState( NULL, &dwState );

    if ( dwError != ERROR_SUCCESS )
    {
        TracePrint(("  ****  Failed to get the node cluster state. Throwing exception!\n"));
        throw CProvException( dwError );
    }

    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetClusterStateProperty()
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetNodeStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a node state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetNodeStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER shCluster;
    SAFENODE    shNode;
    DWORD       dwState;

    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode( shCluster, pwszObjectNameIn );
    dwState = GetClusterNodeState( shNode );

    if ( dwState == ClusterNodeStateUnknown )
    {
        TracePrint(("  ****  SetNodeStateProperty... node state unknown. Throwing exception!\n"));
        throw CProvException( GetLastError() );
    }

    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetNodeStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetNetworkStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a network state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetNetworkStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER shCluster;
    SAFENETWORK shNetwork;
    DWORD       dwState;

    shCluster = OpenCluster( NULL );
    shNetwork = OpenClusterNetwork( shCluster, pwszObjectNameIn );
    dwState = GetClusterNetworkState( shNetwork );
    if ( dwState == ClusterNetworkStateUnknown )
    {
        TracePrint(("  ****  SetNetworkStateProperty... network state unknown. Throwing exception!\n"));
        throw CProvException( GetLastError() );
    }

    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetNetworkStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetNetInterfaceStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a network interface state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn      -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetNetInterfaceStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER         shCluster;
    SAFENETINTERFACE    shNetInterface;
    DWORD               dwState;

    shCluster = OpenCluster( NULL );
    shNetInterface = OpenClusterNetInterface( shCluster, pwszObjectNameIn );
    dwState = GetClusterNetInterfaceState( shNetInterface );
    if ( dwState == ClusterNetInterfaceStateUnknown )
    {
        TracePrint(("  ****  SetNetInterfaceStateProperty... network interface state unknown. Throwing exception!\n"));
        throw CProvException( GetLastError() );
    }

    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetNetInterfaceStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetGroupStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a group state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetGroupStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    DWORD               dwState;
    DWORD               cchName = MAX_PATH;
    CWstrBuf            wsbNodeName;

    wsbNodeName.SetSize( cchName );
    shCluster = OpenCluster( NULL );
    shGroup  = OpenClusterGroup( shCluster, pwszObjectNameIn );

    dwState = GetClusterGroupState( shGroup, wsbNodeName, &cchName );
    if ( dwState == ClusterGroupStateUnknown )
    {
        //
        // BUGBUG I am not handling error_more_data here, since it's not possible that
        // nodeName exceed MAX_PATH, assuming it use netbios name
        //
        TracePrint(("ClusterGroup State is UNKNOWN. Throwing exception!\n"));
        throw CProvException( GetLastError() );
    } else {
        TracePrint(("Setting group state for group <%ws> to %!GroupState!\n", pwszObjectNameIn, dwState ));
        pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
        pwcoInout.SetProperty( wsbNodeName, PVD_PROP_EVENT_NODE );
    }

    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetGroupStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetResourceStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a resource state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn      -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetResourceStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    DWORD               dwState;
    DWORD               cchNodeName = MAX_PATH;
    CWstrBuf            wsbNodeName;
    DWORD               cchGroupName = MAX_PATH;
    CWstrBuf            wsbGroupName;
    DWORD               dwError;

    shCluster = OpenCluster( NULL );
    wsbNodeName.SetSize( cchNodeName );
    wsbGroupName.SetSize( cchGroupName );
    shResource = OpenClusterResource( shCluster, pwszObjectNameIn );
    if ( !shResource.BIsNULL() ) {
        dwState = GetClusterResourceState(
                        shResource,
                        wsbNodeName,
                        &cchNodeName,
                        wsbGroupName,
                        &cchGroupName
                        );
    } else {
        dwState = ClusterResourceStateUnknown;
    }

    TracePrint(("Setting resource state for resource <%ws> to %!ResourceState!\n", pwszObjectNameIn, dwState ));
    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    pwcoInout.SetProperty( wsbNodeName, PVD_PROP_EVENT_NODE );
    pwcoInout.SetProperty( wsbGroupName, PVD_PROP_EVENT_GROUP );

    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetResourceStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CEventProv::InsertTable(
//      DWORD               dwIdxIn,
//      CLUSTER_CHANGE      eTypeIn,
//      EEventObjectType    eotObjectTypeIn,
//      LPCWSTR             pwszMofIn,
//      IWbemClassObject *  pwcoIn,
//      FPSETPROP           pfnIn
//      )
//
//  Description:
//      Insert values in the event table.
//
//  Arguments:
//      dwIdxIn         -- 
//      eTypeIn         -- 
//      eotObjectTypeIn  -- 
//      pwszMofIn       -- 
//      pwcoIn          -- 
//      pfnIn           -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::InsertTable(
    DWORD               dwIdxIn,
    CLUSTER_CHANGE      eTypeIn,
    EEventObjectType    eotObjectTypeIn,
    LPCWSTR             pwszMofIn,
    IWbemClassObject *  pwcoIn,
    FPSETPROP           pfnIn
    )
{
    m_EventTypeTable[ dwIdxIn ].m_eType = eTypeIn;
    m_EventTypeTable[ dwIdxIn ].m_eotObjectType = eotObjectTypeIn;
    m_EventTypeTable[ dwIdxIn ].m_pwszMof = pwszMofIn;
    m_EventTypeTable[ dwIdxIn ].m_pwco = pwcoIn;
    m_EventTypeTable[ dwIdxIn ].m_pfn= pfnIn;

    return;

} //*** CEventProv::InsertTable()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CEventProv::Initialize(
//      LPWSTR                  pwszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pwszNamespaceIn,
//      LPWSTR                  pwszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initializing the provider by setting up a lookup table.
//      called by wmi only once to create provider object.
//
//  Arguments:
//      pwszUserIn          -- User name 
//      lFlagsIn            -- WMI flag
//      pwszNamespaceIn     -- Name space
//      pwszLocaleIn        -- Locale string
//      pCtxIn              -- WMI context
//      pInitSinkIn         -- WMI sink pointer
//
//  Return Values:
//      WBEM_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEventProv::Initialize(
    LPWSTR                  pwszUserIn,
    LONG                    lFlagsIn,
    LPWSTR                  pwszNamespaceIn,
    LPWSTR                  pwszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{
    HRESULT hr = WBEM_S_INITIALIZED;
    CError  er;

    m_pNs = pNamespaceIn;
    m_pNs->AddRef();

    //
    // Grab the class definition for the event.
    //
    try
    {
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_ADD ),
                0,
                pCtxIn,
                &m_pEventAdd,
                0
                );
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_REMOVE ),
                0,
                pCtxIn,
                &m_pEventRemove,
                0
                );
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_STATECHANGE ),
                0,
                pCtxIn,
                &m_pEventState,
                0
                );
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_GROUPSTATECHANGE ),
                0,
                pCtxIn,
                &m_pEventGroupState,
                0
                );
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_RESOURCESTATECHANGE ),
                0,
                pCtxIn,
                &m_pEventResourceState,
                0
                );
#if 0
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_NODESTATECHANGE ),
                0,
                pCtxIn,
                &m_pEventNodeState,
                0
                );
#endif
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_PROP ),
                0,
                pCtxIn,
                &m_pEventProperty,
                0
                );

        //
        // initialize mapping table
        //

        //
        // node events
        //
        InsertTable(
            0,
            CLUSTER_CHANGE_NODE_STATE,
            eotNODE,
            PVD_CLASS_NODE,
            m_pEventState,
            S_SetNodeStateProperty
            );
        InsertTable(
            1,
            CLUSTER_CHANGE_NODE_DELETED,
            eotNODE,
            PVD_CLASS_NODE,
            m_pEventRemove,
            S_SetEventProperty
            );
       InsertTable(
            2,
            CLUSTER_CHANGE_NODE_ADDED,
            eotNODE,
            PVD_CLASS_NODE,
            m_pEventAdd,
            S_SetEventProperty
            );
       InsertTable(
            3,
            CLUSTER_CHANGE_NODE_PROPERTY,
            eotNODE,
            PVD_CLASS_NODE,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // registry event, don't care
       //

       //
       // Resource
       //
       InsertTable(
            8,
            CLUSTER_CHANGE_RESOURCE_STATE,
            eotRESOURCE,
            PVD_CLASS_RESOURCE,
            m_pEventResourceState,
            S_SetResourceStateProperty
            );
       InsertTable(
            9,
            CLUSTER_CHANGE_RESOURCE_DELETED,
            eotRESOURCE,
            PVD_CLASS_RESOURCE,
            m_pEventRemove,
            S_DeleteEvent
            );
       InsertTable(
            10,
            CLUSTER_CHANGE_RESOURCE_ADDED,
            eotRESOURCE,
            PVD_CLASS_RESOURCE,
            m_pEventAdd,
            S_AddEvent
            );
       InsertTable(
            11,
            CLUSTER_CHANGE_RESOURCE_PROPERTY,
            eotRESOURCE,
            PVD_CLASS_RESOURCE,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // group
       //
       InsertTable(
            12,
            CLUSTER_CHANGE_GROUP_STATE,
            eotGROUP,
            PVD_CLASS_GROUP,
            m_pEventGroupState,
            S_SetGroupStateProperty
            );
       InsertTable(
            13,
            CLUSTER_CHANGE_GROUP_DELETED,
            eotGROUP,
            PVD_CLASS_GROUP,
            m_pEventRemove,
            S_DeleteEvent
            );
       InsertTable(
            14,
            CLUSTER_CHANGE_GROUP_ADDED,
            eotGROUP,
            PVD_CLASS_GROUP,
            m_pEventAdd,
            S_AddEvent
            );
       InsertTable(
            15,
            CLUSTER_CHANGE_GROUP_PROPERTY,
            eotGROUP,
            PVD_CLASS_GROUP,
            m_pEventProperty,
            S_SetEventProperty
            );

       //
       // Resource Type 
       //
       InsertTable(
            16,
            CLUSTER_CHANGE_RESOURCE_TYPE_DELETED,
            eotRESOURCE_TYPE,
            PVD_CLASS_RESOURCETYPE,
            m_pEventRemove,
            S_SetEventProperty
            );
       InsertTable(
            17,
            CLUSTER_CHANGE_RESOURCE_TYPE_ADDED,
            eotRESOURCE_TYPE,
            PVD_CLASS_RESOURCETYPE,
            m_pEventAdd,
            S_SetEventProperty
            );
       InsertTable(
            18,
            CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY,
            eotRESOURCE_TYPE,
            PVD_CLASS_RESOURCETYPE,
            m_pEventProperty,
            S_SetEventProperty
            );

       //
       // skip 19 - CLUSTER_CHANGE_CLUSTER_RECONNECT
       //

       //
       // network
       //
       InsertTable(
            20,
            CLUSTER_CHANGE_NETWORK_STATE,
            eotNETWORK,
            PVD_CLASS_NETWORKS,
            m_pEventState,
            S_SetNetworkStateProperty
            );
       InsertTable(
            21,
            CLUSTER_CHANGE_NETWORK_DELETED,
            eotNETWORK,
            PVD_CLASS_NETWORKS,
            m_pEventRemove,
            S_SetEventProperty
            );
       InsertTable(
            22,
            CLUSTER_CHANGE_NETWORK_ADDED,
            eotNETWORK,
            PVD_CLASS_NETWORKS,
            m_pEventAdd,
            S_SetEventProperty
            );
       InsertTable(
            23,
            CLUSTER_CHANGE_NETWORK_PROPERTY,
            eotNETWORK,
            PVD_CLASS_NETWORKS,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // net interface
       //
       InsertTable(
            24,
            CLUSTER_CHANGE_NETINTERFACE_STATE,
            eotNET_INTERFACE,
            PVD_CLASS_NETWORKSINTERFACE,
            m_pEventState,
            S_SetNetInterfaceStateProperty
            );
       InsertTable(
            25,
            CLUSTER_CHANGE_NETINTERFACE_DELETED,
            eotNET_INTERFACE,
            PVD_CLASS_NETWORKSINTERFACE,
            m_pEventRemove,
            S_SetEventProperty
            );
       InsertTable(
            26,
            CLUSTER_CHANGE_NETINTERFACE_ADDED,
            eotNET_INTERFACE,
            PVD_CLASS_NETWORKSINTERFACE,
            m_pEventAdd,
            S_SetEventProperty
            );
       InsertTable(
            27,
            CLUSTER_CHANGE_NETINTERFACE_PROPERTY,
            eotNET_INTERFACE,
            PVD_CLASS_NETWORKSINTERFACE,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // other
       //
       InsertTable(
            28,
            CLUSTER_CHANGE_QUORUM_STATE,
            eotQUORUM,
            PVD_CLASS_RESOURCE,
            m_pEventState,
            S_SetResourceStateProperty
            );
/*       InsertTable(
            29,
            CLUSTER_CHANGE_CLUSTER_STATE,
            eotCLUSTER,
            PVD_CLASS_CLUSTER,
            m_pEventState,
            S_SetClusterStateProperty );
*/
        InsertTable(
            30,
            CLUSTER_CHANGE_CLUSTER_PROPERTY,
            eotCLUSTER,
            PVD_CLASS_CLUSTER,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // skip 31 - CLUSTER_CHANGE_HANDLE_CLOSE
       //

    } // try
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    } // catch

    // Tell CIMOM that we're up and running.
    // =====================================
    pInitSinkIn->SetStatus( hr, 0 );
    
    return WBEM_NO_ERROR;

} //*** CEventProv::Initialize()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  HRESULT
//  CEventProv::S_HrCreateThis(
//      IUnknown *  pUnknownOuterIn,
//      VOID **     ppvOut
//      )
//
//  Description:
//      Create a CEventProv object.
//
//  Arguments:
//      pUnknownOutIn   -- 
//      ppvOut          -- 
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEventProv::S_HrCreateThis(
    IUnknown *  pUnknownOuterIn,
    VOID **     ppvOut
    )
{
    *ppvOut = new CEventProv();
    return S_OK;

} //*** CEventProv::S_HrCreateThis()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\ntrkcomm.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NtRkComm.cpp
//
//  Description:
//      Implementation of CWbemServices, CImpersonatedProvider, CInstanceMgr
//      class.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "NtRkComm.h"
#include "ObjectPath.h"

//****************************************************************************
//
//  CWbemServices
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemServices::CWbemServices(
//      IWbemServices * pNamespace
//    )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pNamespace  --
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemServices::CWbemServices(
    IWbemServices * pNamespace
    )
    : m_pWbemServices( NULL )
{
    m_pWbemServices = pNamespace;
    if ( m_pWbemServices != NULL )
    {
        m_pWbemServices->AddRef( );
    }

} //*** CWbemServices::CWbemServices()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemServices::~CWbemServices( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemServices::~CWbemServices( void )
{
    if ( m_pWbemServices != NULL )
    {
        m_pWbemServices->Release();
    }

} //*** CWbemServices::~CWbemServices()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::CreateClassEnum(
//      BSTR                    bstrSuperclassIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      Returns an enumerator for all classes satisfying the
//      selection criteria
//
//  Arguments:
//      bstrSuperclassIn
//          Specifies a superclass name
//
//      lFlagsIn
//          accepts WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_
//          RETURN_IMMEDIATELY, WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_
//          BIDIRECTIONAL
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the pointer to the enumerator
//
//  Return Value:
//      WBEM stand error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::CreateClassEnum(
    BSTR                    bstrSuperclassIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->CreateClassEnum(
                bstrSuperclassIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::CreateClassEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::CreateInstanceEnum(
//      BSTR                    bstrClassIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      creates an enumerator that returns the instances of a
//      specified class according to user-specified selection
//      criteria
//
//  Arguments:
//      bstrClassIn
//          Specifies a superclass name
//
//      lFlagsIn
//          accepts WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_
//          RETURN_IMMEDIATELY, WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_
//          BIDIRECTIONAL
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the pointer to the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::CreateInstanceEnum(
    BSTR                    bstrClassIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->CreateInstanceEnum(
                bstrClassIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::CreateInstanceEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::DeleteClass(
//      BSTR                bstrClassIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//    )
//
//  Description:
//      Deletes the specified class from the current namespace.
//
//  Arguments:
//      bstrClassIn
//          The name of the class targeted for deletion.
//
//      lFlagsIn
//          accepts WBEM_FLAG_RETURN_IMMEDIATELY, WBEM_FLAG_
//          OWNER_UPDATE
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          Receives the call result
//
//  Return Value:
//      WBEM stand error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::DeleteClass(
    BSTR                bstrClassIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->DeleteClass(
                bstrClassIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::DeleteClass()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::DeleteInstance(
//      BSTR                bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      deletes an instance of an existing class in the current namespace
//
//  Arguments:
//      bstrObjectPathIn
//          object path to the instance to be deleted.
//
//      lFlagsIn
//          accepts WBEM_FLAG_RETURN_IMMEDIATELY
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          Receives the call result
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::DeleteInstance(
    BSTR                bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->DeleteInstance(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::DeleteInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecMethod(
//      BSTR                bstrObjectPathIn,
//      BSTR                bstrMethodNameIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemClassObject *  pInParamsIn,
//      IWbemClassObject ** ppOurParamsOut,
//      IWbemCallResult **  ppCallResultOut
//      )
//
//  Description:
//      execute methods for the given object
//
//  Arguments:
//      bstrObjectPathIn
//          object path of the object for which the method is executed
//
//      bstrMethodNameIn
//          name of the method to be invoked
//
//      lFlagsIn
//          zero to make this a synchronous call
//
//      pCtxIn
//          Typically NULL
//
//      pInParamsIn
//          Input parameters for the method
//
//      ppOurParamsOut
//          output parameters for the method
//
//      ppCallResultOut
//          To receive call result
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecMethod(
    BSTR                bstrObjectPathIn,
    BSTR                bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemClassObject ** ppOurParamsOut,
    IWbemCallResult **  ppCallResultOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecMethod(
                bstrObjectPathIn,
                bstrMethodNameIn,
                lFlagsIn,
                pCtxIn,
                pInParamsIn,
                ppOurParamsOut,
                ppCallResultOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecMethod()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecNotificationQuery(
//      BSTR                    bstrQueryLanguageIn,
//      BSTR                    bstrQueryIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      Executes a query to receive events.
//
//  Arguments:
//      bstrQueryLanguageIn
//          BSTR containing one of the query languages supported by WMI
//
//      bstrQueryIn
//          text of the event-related query
//
//      lFlagsIn
//          WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecNotificationQuery(
    BSTR                    bstrQueryLanguageIn,
    BSTR                    bstrQueryIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecNotificationQuery(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecNotificationQuery()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecQuery(
//      BSTR                    bstrQueryLanguageIn,
//      BSTR                    bstrQueryIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      executes a query to retrieve objects.
//
//  Arguments:
//      bstrQueryLanguageIn
//          BSTR containing one of the query languages supported by WMI
//
//      bstrQueryIn
//          containing the text of the query
//
//      lFllFlagsIn
//          WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY
//          WBEM_FLAG_BIDIRECTIONAL, WBEM_FLAG_ENSURE_LOCATABLE
//          WBEM_FLAG_PROTOTYPE
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          receives the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecQuery(
    BSTR                    bstrQueryLanguageIn,
    BSTR                    bstrQueryIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecQuery(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecQuery()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::GetObject(
//      BSTR                bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemClassObject ** ppObjectInout,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      retrieves a class or instance
//
//  Arguments:
//      bstrObjectPathIn
//          The object path of the object to retrieve
//
//      lFlagsIn
//          0
//
//      pCtxIn
//          Typically NULL
//
//      ppObjectInout
//          If not NULL, this receives the object
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::GetObject(
    BSTR                bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject ** ppObjectInout,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->GetObject(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                ppObjectInout,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::GetObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::PutClass(
//      IWbemClassObject *  pObjectIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      Creates a new class or updates an existing one
//
//  Arguments:
//      pObjectIn
//          point to a valid class definition
//
//      lFlagsIn
//          WBEM_FLAG_CREATE_OR_UPDATE,WBEM_FLAG_UPDATE_ONLY,
//          WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY,
//          WBEM_FLAG_OWNER_UPDATE, WBEM_FLAG_UPDATE_COMPATIBLE,
//          WBEM_FLAG_UPDATE_SAFE_MODE, WBEM_FLAG_UPDATE_FORCE_MODE
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::PutClass(
    IWbemClassObject *  pObjectIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->PutClass(
                pObjectIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::PutClass()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::PutInstance(
//      IWbemClassObject *  pInstIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      Creates or updates an instance of an existing class.
//
//  Arguments:
//      pInstIn
//          Points to the instance to be written
//
//      lFlagsIn
//          WBEM_FLAG_CREATE_OR_UPDATE,WBEM_FLAG_UPDATE_ONLY,
//          WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY,
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::PutInstance(
    IWbemClassObject *  pInstIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->PutInstance(
                pInstIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::PutInstance()

//****************************************************************************
//
//  CImpersonatedProvider
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonatedProvider::CImpersonatedProvider(
//      BSTR            bstrObjectPathIn    = NULL,
//      BSTR            bstrUserIn          = NULL,
//      BSTR            bstrPasswordIn      = NULL,
//      IWbemContext *  pCtxIn              = NULL
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      bstrObjectPathIn    --
//      bstrUserIn          --
//      bstrPasswordIn      --
//      pCtxIn              --
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CImpersonatedProvider::CImpersonatedProvider(
    BSTR            ,// bstrObjectPathIn.
    BSTR            ,// bstrUserIn,
    BSTR            ,// bstrPasswordIn,
    IWbemContext *  // pCtxIn
    )
    : m_cRef( 0 ), m_pNamespace( NULL )
{

} //*** CImpersonatedProvider::CImpersonatedProvider()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonatedProvider::~CImpersonatedProvider( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CImpersonatedProvider::~CImpersonatedProvider( void )
{
    delete m_pNamespace;

} //*** CImpersonatedProvider::~CImpersonatedProvider()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CImpersonatedProvider::AddRef( void )
//
//  Description:
//      Increment the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CImpersonatedProvider::AddRef( void )
{
    return InterlockedIncrement( ( long * ) & m_cRef );

} //*** CImpersonatedProvider::AddRef()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CImpersonatedProvider::Release( void )
//
//  Description:
//      Release a reference on the COM object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      New reference count.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CImpersonatedProvider::Release( void )
{
    ULONG nNewCount = InterlockedDecrement( ( long * ) & m_cRef  );
    if ( 0L == nNewCount )
        delete this;

    return nNewCount;

} //*** CImpersonatedProvider::Release()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::QueryInterface(
//      REFIID  riid,
//      PPVOID  ppv
//      )
//
//  Description:
//      Initialize the provider.
//
//  Arguments:
//      riidIn      -- Interface ID being queried.
//      ppvOut      -- Pointer in which to return interface pointer.
//
//  Return Value:
//      NOERROR
//      E_NOINTERFACE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CImpersonatedProvider::QueryInterface(
    REFIID  riid,
    PPVOID  ppv
    )
{
    *ppv = NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if ( riid == IID_IWbemServices )
    {
       *ppv = static_cast< IWbemServices * >( this );
    }

    if ( IID_IUnknown == riid || riid == IID_IWbemProviderInit )
    {
        *ppv = static_cast< IWbemProviderInit * >( this );
    }


    if ( NULL != *ppv )
    {
        AddRef();
        return NOERROR;
    }
    else
    {
        return E_NOINTERFACE;
    }

} //*** CImpersonatedProvider::QueryInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::Initialize(
//      LPWSTR                  pszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pszNamespaceIn,
//      LPWSTR                  pszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initialize the provider.
//
//  Arguments:
//      pszUserIn       --
//      lFlagsIn        --
//      pszNamespaeIn   --
//      pszLocaleIn     --
//      pNamespaceIn    --
//      pCtxIn          --
//      pInitSinkIn     --
//
//  Return Value:
//      WBEM_S_NO_ERROR
//      WBEM_E_OUT_OF_MEMORY
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CImpersonatedProvider::Initialize(
    LPWSTR                  ,// pszUserIn,
    LONG                    ,// lFlagsIn,
    LPWSTR                  ,// pszNamespaceIn,
    LPWSTR                  ,// pszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          ,// pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lStatus = WBEM_S_INITIALIZED;

    m_pNamespace = new CWbemServices( pNamespaceIn );
    if ( m_pNamespace == NULL )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        lStatus = WBEM_E_FAILED;
    } // if: error allocating memory

    //Let CIMOM know you are initialized
    //==================================

    pInitSinkIn->SetStatus( lStatus, 0 );
    return hr;

} //*** CImpersonatedProvider::Initialize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::CreateInstanceEnumAsync(
//      const BSTR          bstrClassIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Create an instance asynchronously.
//
//  Arguments:
//      bstrClassIn         --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoCreateInstanceEnumAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::CreateInstanceEnumAsync(
    const BSTR          bstrClassIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoCreateInstanceEnumAsync(
                    bstrClassIn,
                    lFlagsIn,
                    pCtxIn,
                    pResponseHandlerIn
                    );
    } // if:

    return hr;

} //*** CImpersonatedProvider::CreateInstanceEnumAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::DeleteInstanceAsync(
//      const BSTR          bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Delete an instance asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoDeleteInstanceAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::DeleteInstanceAsync(
    const BSTR          bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoDeleteInstanceAsync(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::DeleteInstanceAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::ExecMethodAsync(
//      const BSTR          bstrObjectPathIn,
//      const BSTR          bstrMethodNameIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemClassObject *  pInParamsIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Execute a method asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      bstrMethodNameIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pInParamsIn         --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoExecMethodAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::ExecMethodAsync(
    const BSTR          bstrObjectPathIn,
    const BSTR          bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoExecMethodAsync(
                bstrObjectPathIn,
                bstrMethodNameIn,
                lFlagsIn,
                pCtxIn,
                pInParamsIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::ExecMethodAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::ExecQueryAsync(
//      const BSTR          bstrQueryLanguageIn,
//      const BSTR          bstrQueryIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Execute a query asynchronously.
//
//  Arguments:
//      bstrQueryLanguageIn --
//      bstrQueryIn         --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoExecQueryAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::ExecQueryAsync(
    const BSTR          bstrQueryLanguageIn,
    const BSTR          bstrQueryIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoExecQueryAsync(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::ExecQueryAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::GetObjectAsync(
//      const BSTR          bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Get an instance asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoGetObjectAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::GetObjectAsync(
    const BSTR          bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext  *     pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoGetObjectAsync(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::GetObjectAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::PutInstanceAsync(
//      IWbemClassObject *  pInstIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Save an instance asynchronously.
//
//  Arguments:
//      pInstIn             --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoPutInstanceAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::PutInstanceAsync(
    IWbemClassObject *  pInstIn,
    long                lFlagsIn,
    IWbemContext  *     pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoPutInstanceAsync(
                pInstIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::PutInstanceAsync()

//****************************************************************************
//
//  CWbemInstanceMgr
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::CWbemInstanceMgr(
//      IWbemObjectSink *   pHandlerIn,
//      DWORD               dwSizeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pHandlerIn      -- WMI sink.
//      dwSizeIn        --
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemInstanceMgr::CWbemInstanceMgr(
    IWbemObjectSink *   pHandlerIn,
    DWORD               dwSizeIn    // = 50
    )
    : m_pSink( NULL )
    , m_ppInst( NULL )
    , m_dwIndex( 0 )
{
    DWORD dwIndex = 0;

    m_pSink = pHandlerIn;
    if ( m_pSink == NULL )
    {
        throw static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    } // if: no sink specified

    m_pSink->AddRef( );
    m_dwThreshHold = dwSizeIn;
    m_ppInst = new IWbemClassObject*[ dwSizeIn ];
    for ( dwIndex = 0 ; dwIndex < dwSizeIn ; dwIndex++ )
    {
        m_ppInst[ dwIndex ] = NULL;
    } // for each in m_ppInst

} //*** CWbemInstanceMgr::CWbemInstanceMgr()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::CWbemInstanceMgr( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemInstanceMgr::~CWbemInstanceMgr( void )
{
    if ( m_ppInst != NULL )
    {
        if ( m_dwIndex > 0 )
        {
            m_pSink->Indicate( m_dwIndex, m_ppInst );
        }
        DWORD dwIndex = 0;
        for ( dwIndex = 0; dwIndex < m_dwIndex; dwIndex++ )
        {
            if ( m_ppInst[ dwIndex ] != NULL )
            {
                ( m_ppInst[ dwIndex ] )->Release( );
            }
        }
        delete [] m_ppInst;
    }

    m_pSink->Release( );

} //*** CWbemInstanceMgr::~CWbemInstanceMgr()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CWbemInstanceMgr::Indicate(
//      IN IWbemClassObject *   pInstIn
//    )
//
//  Description:
//      Notify an instance to WMI sink
//
//  Arguments:
//      pInstIn     -- Instance to send to WMI
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWbemInstanceMgr::Indicate(
    IN IWbemClassObject *   pInstIn
    )
{
    if ( pInstIn == NULL )
    {
        throw static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    }

    m_ppInst[ m_dwIndex++ ] = pInstIn;
    pInstIn->AddRef( );
    if ( m_dwIndex == m_dwThreshHold )
    {
        HRESULT sc = WBEM_S_NO_ERROR;
        sc = m_pSink->Indicate( m_dwIndex, m_ppInst );
        if( FAILED( sc ) )
        {
            if ( sc == WBEM_E_CALL_CANCELLED )
            {
                sc = WBEM_S_NO_ERROR;
            }
            throw CProvException( sc );
        }

        // reset state
        DWORD dwIndex = 0;
        for ( dwIndex = 0; dwIndex < m_dwThreshHold; dwIndex++ )
        {
            if ( m_ppInst[ dwIndex ] != NULL )
            {
                ( m_ppInst[ dwIndex ] )->Release( );
            } //*** if m_ppInst[ _dwIndex ] != NULL

            m_ppInst[ dwIndex ] = NULL;

        } //*** for each in m_ppInst

        m_dwIndex = 0;

    } //*** if( m_dwIndex == m_dwThreshHold )
    return;

} //*** CWbemInstanceMgr::Indicate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::SetStatus
//
//  Description:
//      send status to WMI sink
//
//  Arguments:
//      lFlagsIn        -- WMI flag
//      hrIn            -- HResult
//      bstrParamIn     -- Message
//      pObjParamIn     -- WMI extended error object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWbemInstanceMgr::SetStatus(
    LONG                lFlagsIn,
    HRESULT             hrIn,
    BSTR                bstrParamIn,
    IWbemClassObject *  pObjParamIn
    )
{
    m_pSink->SetStatus(
        lFlagsIn,
        hrIn,
        bstrParamIn,
        pObjParamIn
        );

} //*** CWbemInstanceMgr::SetStatus()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\ntrkcomm.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NtRkComm.h
//
//  Implementation File:
//      NtRkComm.cpp
//
//  Description:
//      Definition of the CWbemServices, CImpersonatedProvider and 
//      CInstanceMgr class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <wbemprov.h>
#include <objbase.h>


typedef LPVOID * PPVOID;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemServices
//
//  Description:
//      Wraps for IWbemServices. security impersonation is implemented here
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWbemServices
{
protected:
    IWbemServices * m_pWbemServices;

public:
    CWbemServices( IWbemServices * );
    virtual ~CWbemServices( void );

    HRESULT STDMETHODCALLTYPE GetObject(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject ** ppObjectInout,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE PutClass(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE DeleteClass(
        BSTR                bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE CreateClassEnum(
        BSTR                    bstrSuperclassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE PutInstance(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE DeleteInstance(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
        BSTR                    bstrClassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
        BSTR                    bstrQueryLanguageIn,
        BSTR                    bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
        BSTR                    bstrQueryLanguageIn,
        BSTR                    bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecMethod(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemClassObject ** ppOurParamsOut,
        IWbemCallResult **  ppCallResultOut
        );

}; //*** class CWbemServices

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CImpersonatedProvider
//
//  Description:
//      a middle layer between IWbemservices and actual provider. It takes
//      care of security impersonation
//
//--
//////////////////////////////////////////////////////////////////////////////
class CImpersonatedProvider
    : public IWbemServices
    , public IWbemProviderInit
{
protected:
    ULONG               m_cRef;         //Object reference count
    CWbemServices *     m_pNamespace;

public:
    CImpersonatedProvider(
        BSTR            bstrObjectPathIn    = NULL,
        BSTR            bstrUserIn          = NULL,
        BSTR            bstrPasswordIn      = NULL,
        IWbemContext *  pCtxIn              = NULL
        );
    virtual ~CImpersonatedProvider( void );

    //Non-delegating object IUnknown

    STDMETHODIMP            QueryInterface( REFIID riid, PPVOID ppv );
    STDMETHODIMP_( ULONG )  AddRef( void );
    STDMETHODIMP_( ULONG )  Release( void );

            //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(
         LPWSTR                     pszUserIn,
         LONG                       lFlagsIn,
         LPWSTR                     pszNamespaceIn,
         LPWSTR                     pszLocaleIn,
         IWbemServices *            pNamespaceIn,
         IWbemContext *             pCtxIn,
         IWbemProviderInitSink *    pInitSinkIn
         );

     //IWbemServices  

    HRESULT STDMETHODCALLTYPE OpenNamespace(
        const BSTR          bstrNamespaceIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemServices **    ppWorkingNamespaceInout,
        IWbemCallResult **  ppResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CancelAsyncCall(
        IWbemObjectSink  *  pSinkIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE QueryObjectSink(
        long                lFlagsIn,
        IWbemObjectSink **  ppResponseHandlerOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE GetObject(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject ** ppObjectInout,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE GetObjectAsync(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE PutClass(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutClassAsync(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteClass(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteClassAsync(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateClassEnum(
        const BSTR              bstrSuperclassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
        const BSTR          bstrSuperclassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutInstance(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutInstanceAsync(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE DeleteInstance(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
        const BSTR               bstrClassIn,
        long                     lFlagsIn,
        IWbemContext *           pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
        const BSTR              bstrQueryLanguageIn,
        const BSTR              bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecQueryAsync(
        const BSTR           bstrQueryLanguageIn,
        const BSTR           bstrQueryIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
        const BSTR              bstrQueryLanguageIn,
        const BSTR              bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext*           pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
        const BSTR           bstrQueryLanguageIn,
        const BSTR           bstrQueryIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethod(
        const BSTR          bstrObjectPathIn,
        const BSTR          bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemClassObject ** ppOurParamsOut,
        IWbemCallResult **  ppCallResultOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(
        const BSTR          bstrObjectPathIn,
        const BSTR          bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

protected:
    virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        BSTR                bstrRefStrIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        BSTR                bstrQueryLanguageIn,
        BSTR                bstrQueryIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;
    virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        BSTR                    bstrObjectPathIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IWbemObjectSink FAR *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

}; //*** class CImpersonatedProvider

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemInstanceMgr
//
//  Description:
//      Manage WMI instance, allow block indicate
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWbemInstanceMgr
{
protected:
    IWbemObjectSink *   m_pSink;
    IWbemClassObject ** m_ppInst;
    DWORD               m_dwThreshHold;
    DWORD               m_dwIndex;

public:

    CWbemInstanceMgr(
        IWbemObjectSink *   pHandlerIn,
        DWORD               dwSizeIn = 50
        );
    
    virtual ~CWbemInstanceMgr( void );

    void Indicate(
        IN IWbemClassObject * pInst
        );

    void SetStatus(
        LONG                lFlagsIn,
        HRESULT             hrIn,
        BSTR                bstrParamIn,
        IWbemClassObject *  pObjParamIn
        );

}; //*** class CWbemInstanceMgr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\instanceprov.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InstanceProv.cpp
//
//  Description:
//      Implementation of CInstanceProv class
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InstanceProv.h"
#include "ClusterResource.h"
#include "Cluster.h"
#include "ClusterNode.h"
#include "ClusterGroup.h"
#include "ClusterNodeRes.h"
#include "ClusterResourceType.h"
#include "ClusterEnum.h"
#include "Clusternetworks.h"
#include "ClusterNetInterface.h"
#include "ClusterObjAssoc.h"
#include "ClusterNodeGroup.h"
#include "ClusterResResType.h"
#include "ClusterResDepRes.h"
#include "ClusterService.h"
#include "InstanceProv.tmh"

//////////////////////////////////////////////////////////////////////////////
//  Global Variables
//////////////////////////////////////////////////////////////////////////////

long                g_lNumInst = 0;
ClassMap            g_ClassMap;
TypeNameToClass     g_TypeNameToClass;

//****************************************************************************
//
//  CInstanceProv
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CInstanceProv::CInstanceProv(
//      BSTR            bstrObjectPathIn    = NULL,
//      BSTR            bstrUserIn          = NULL,
//      BSTR            bstrPasswordIn      = NULL,
//      IWbemContext *  pCtxIn              = NULL
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      bstrObjectPathIn    --
//      bstrUserIn          --
//      bstrPasswordIn      --
//      pCtxIn              --
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CInstanceProv::CInstanceProv(
    BSTR            ,// bstrObjectPathIn,
    BSTR            ,// bstrUserIn,
    BSTR            ,// bstrPasswordIn,
    IWbemContext *  // pCtxIn
    )
{
 //   m_pNamespace = NULL;
 //   m_cRef = 0;
    InterlockedIncrement( &g_cObj );
    return;

} //*** CInstanceProv::CInstanceProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CInstanceProv::~CInstanceProv( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CInstanceProv::~CInstanceProv( void )
{
    InterlockedDecrement( &g_cObj );
#ifdef _DEBUG
    _CrtDumpMemoryLeaks();
#endif

    return;

} //*** CInstanceProv::~CInstanceProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoExecQueryAsync(
//      BSTR                bstrQueryLanguageIn,
//      BSTR                bstrQueryIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Enumerate instance for a given class.
//
//  Arguments:
//      bstrQueryLanguageIn
//           A valid BSTR containing one of the query languages
//           supported by Windows Management. This must be WQL.
//
//      bstrQueryIn
//          A valid BSTR containing the text of the query
//
//      lFlagsIn
//          WMI flag
//
//      pCtxIn
//          WMI context
//
//      pHandlerIn
//          WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoExecQueryAsync(
    BSTR                ,// bstrQueryLanguageIn,
    BSTR                ,// bstrQueryIn,
    long                ,// lFlagsIn,
    IWbemContext *      ,// pCtxIn,
    IWbemObjectSink *   // pHandlerIn
    )
{
//  pHandler->SetStatus( WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL );
//  return sc;
//  pHandler->SetStatus( WBEM_E_PROVIDER_NOT_CAPABLE, S_OK, NULL, NULL );
    return WBEM_E_NOT_SUPPORTED;
//  return WBEM_E_PROVIDER_NOT_CAPABLE;
    //WBEM_E_PROVIDER_NOT_CAPABLE;

} //*** CInstanceProv::DoExecQueryAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoCreateInstanceEnumAsync(
//      BSTR                bstrRefStrIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Enumerate instance for a given class.
//
//  Arguments:
//      bstrRefStrIn    -- Name the class to enumerate
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoCreateInstanceEnumAsync(
    BSTR                bstrRefStrIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    SCODE                   sc      = WBEM_S_NO_ERROR;
    IWbemClassObject *      pStatus = NULL;
    CWbemClassObject        Status;
    auto_ptr< CProvBase >   pProvBase;

    // Do a check of arguments and make sure we have pointer to Namespace

    if ( pHandlerIn == NULL || m_pNamespace == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {

        CreateClass(
            bstrRefStrIn,
            m_pNamespace,
            pProvBase
            );
        sc = pProvBase->EnumInstance(
                lFlagsIn,
                pCtxIn,
                pHandlerIn
                );
    } // try
    catch ( CProvException prove )
    {
        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = prove.hrGetError();
            pStatus = Status.data();
        }
    } // catch
    catch( ... )
    {
        sc =  WBEM_E_FAILED;
    }

    sc =  pHandlerIn->SetStatus(
                WBEM_STATUS_COMPLETE,
                sc,
                NULL,
                pStatus
                );

    return WBEM_S_NO_ERROR;

} //*** CInstanceProv::DoCreateInstanceEnumAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoGetObjectAsync(
//      BSTR                bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Creates an instance given a particular path value.
//
//  Arguments:
//      bstrObjectPathIn    -- Object path to an object
//      lFlagsIn            -- WMI flag
//      pCtxIn              -- WMI context
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoGetObjectAsync(
    BSTR                bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    SCODE                   sc;
    CObjPath                ObjPath;
    CProvBase *             pProv = NULL;
    auto_ptr< CProvBase >   pProvBase;

    // Do a check of arguments and make sure we have pointer to Namespace

    if ( bstrObjectPathIn == NULL || pHandlerIn == NULL || m_pNamespace == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // do the get, pass the object on to the notify

    try
    {

        if ( ObjPath.Init( bstrObjectPathIn ) != TRUE )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CreateClass(
            ObjPath.GetClassName(),
            m_pNamespace,
            pProvBase
            );

        sc = pProvBase->GetObject(
                ObjPath,
                lFlagsIn,
                pCtxIn,
                pHandlerIn
                );
    } // try
    catch ( CProvException  prove )
    {
        CWbemClassObject Status;
        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = pHandlerIn->SetStatus(
                    WBEM_STATUS_COMPLETE,
                    WBEM_E_FAILED,
                    NULL,
                    Status.data( )
                    );

            return sc;
        }

    }
    catch( ... )
    {
        sc = WBEM_E_FAILED;
    }

    pHandlerIn->SetStatus(
        WBEM_STATUS_COMPLETE,
        sc,
        NULL,
        NULL
        );

    return sc;

} //*** CInstanceProv::DoGetObjectAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoPutInstanceAsync(
//      IWbemClassObject *  pInstIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      pInstIn         -- WMI object to be saved
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoPutInstanceAsync(
    IWbemClassObject *  pInstIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    SCODE               sc      = WBEM_S_NO_ERROR;
    IWbemClassObject *  pStatus = NULL;
    CWbemClassObject    Status;

    if ( pInstIn == NULL || pHandlerIn == NULL  )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // get class name
        _bstr_t                 bstrClass;
        CWbemClassObject        wcoInst( pInstIn );
        auto_ptr< CProvBase >   pProvBase;

        wcoInst.GetProperty( bstrClass, PVD_WBEM_CLASS );

        CreateClass( bstrClass, m_pNamespace, pProvBase );

        sc = pProvBase->PutInstance(
                wcoInst,
                lFlagsIn,
                pCtxIn,
                pHandlerIn
                );
    }
    catch ( CProvException prove )
    {
        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = prove.hrGetError();
            pStatus = Status.data();
        }
    }
    catch ( ... )
    {
        sc = WBEM_E_FAILED;
    }

    return pHandlerIn->SetStatus(
                WBEM_STATUS_COMPLETE,
                sc,
                NULL,
                pStatus
                );

} //*** CInstanceProv::DoPutInstanceAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoDeleteInstanceAsync(
//       BSTR               bstrObjectPathIn,
//       long               lFlagsIn,
//       IWbemContext *     pCtxIn,
//       IWbemObjectSink *  pHandlerIn
//       )
//
//  Description:
//      Delete this instance.
//
//  Arguments:
//      bstrObjectPathIn    -- ObjPath for the instance to be deleted
//      lFlagsIn            -- WMI flag
//      pCtxIn              -- WMI context
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoDeleteInstanceAsync(
     BSTR               bstrObjectPathIn,
     long               lFlagsIn,
     IWbemContext *     pCtxIn,
     IWbemObjectSink *  pHandlerIn
     )
{
    SCODE                   sc;
    CObjPath                ObjPath;
    CProvBase *             pProv = NULL;
    _bstr_t                 bstrClass;
    auto_ptr< CProvBase >   pProvBase;

    // Do a check of arguments and make sure we have pointer to Namespace

    if ( bstrObjectPathIn == NULL || pHandlerIn == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // do the get, pass the object on to the notify

    try
    {
        if ( ! ObjPath.Init( bstrObjectPathIn ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName();
        CreateClass( bstrClass, m_pNamespace, pProvBase );

        sc = pProvBase->DeleteInstance(
                ObjPath,
                lFlagsIn,
                pCtxIn,
                pHandlerIn
                );
    } // try
    catch ( CProvException prove )
    {
        CWbemClassObject    Status;

        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = pHandlerIn->SetStatus(
                    WBEM_STATUS_COMPLETE,
                    WBEM_E_FAILED,
                    NULL,
                    Status.data()
                    );
            return sc;
        }
    }
    catch ( ... )
    {
        sc = WBEM_E_FAILED;
    }

    pHandlerIn->SetStatus(
        WBEM_STATUS_COMPLETE,
        sc,
        NULL,
        NULL
        );

    return sc;

} //*** CInstanceProv::DoDeleteInstanceAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoExecMethodAsync(
//      BSTR                bstrObjectPathIn,
//      BSTR                bstrMethodNameIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemClassObject *  pInParamsIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Execute methods for the given object.
//
//  Arguments:
//      bstrObjectPathIn    -- Object path to a given object
//      bstrMethodNameIn    -- Name of the method to be invoked
//      lFlagsIn            -- WMI flag
//      pCtxIn              -- WMI context
//      pInParamsIn         -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoExecMethodAsync(
    BSTR                bstrObjectPathIn,
    BSTR                bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    SCODE sc;
    if ( bstrObjectPathIn == NULL || pHandlerIn == NULL || m_pNamespace == NULL
        || bstrMethodNameIn == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        CObjPath                ObjPath;
        _bstr_t                 bstrClass;
        auto_ptr< CProvBase >   pProvBase;

        if ( ! ObjPath.Init( bstrObjectPathIn ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName( );

        CreateClass( bstrClass, m_pNamespace, pProvBase );

        sc = pProvBase->ExecuteMethod(
                ObjPath,
                bstrMethodNameIn,
                lFlagsIn,
                pInParamsIn,
                pHandlerIn
                );
    } // try

    catch ( CProvException prove )
    {
        CWbemClassObject Status;
        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = pHandlerIn->SetStatus(
                    WBEM_STATUS_COMPLETE,
                    WBEM_E_FAILED,
                    NULL,
                    Status.data( )
                    );
            return sc;
        }
    }
    catch ( ... )
    {
        sc = WBEM_E_FAILED;
    }

    pHandlerIn->SetStatus(
        WBEM_STATUS_COMPLETE,
        sc,
        NULL,
        NULL );

    return sc;

} //*** CInstanceProv::DoExecMethodAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::CreateClassEnumAsync(
//      const BSTR          bstrSuperclassIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Create a class enumerator.
//
//  Arguments:
//      bstrSuperclassIn    -- Class to create
//      lFlagsIn            -- WMI flag
//      pCtxIn              -- WMI context
//      pResponseHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::CreateClassEnumAsync(
    const BSTR          bstrSuperclassIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    return WBEM_S_NO_ERROR;

} //*** CInstanceProv::CreateClassEnumAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::SetExtendedStatus(
//      CProvException &    rpeIn,
//      CWbemClassObject &  rwcoInstOut
//      )
//
//  Description:
//      Create and set extended error status.
//
//  Arguments:
//      rpeIn       -- Exception object.
//      rwcoInstOut -- Reference to WMI instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::SetExtendedStatus(
    CProvException &    rpeIn,
    CWbemClassObject &  rwcoInstOut
    )
{
    SCODE               sc = WBEM_S_NO_ERROR;
    IWbemClassObject *  pStatus = NULL;

    sc =  m_pNamespace->GetObject(
                _bstr_t( PVD_WBEM_EXTENDEDSTATUS ),
                0,
                NULL,
                &pStatus,
                NULL
                );
    if ( SUCCEEDED( sc ) )
    {
        sc = pStatus->SpawnInstance( 0, &rwcoInstOut );
        if ( SUCCEEDED( sc ) )
        {
            rwcoInstOut.SetProperty( rpeIn.PwszErrorMessage(), PVD_WBEM_DESCRIPTION );
            rwcoInstOut.SetProperty( rpeIn.DwGetError(),       PVD_WBEM_STATUSCODE );
        }
    }

    return sc;

} //*** CInstanceProv::SetExtendedStatus()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::S_HrCreateThis(
//      IUnknown *  pUnknownOuterIn,
//      VOID **     ppvOut
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      pUnknownOuterIn -- Outer IUnknown pointer.
//      ppvOut          -- Receives the created instance pointer.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::S_HrCreateThis(
    IUnknown *  ,// pUnknownOuterIn,
    VOID **     ppvOut
    )
{
    *ppvOut = new CInstanceProv();
    return S_OK;

} //*** CInstanceProv::S_HrCreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CInstanceProv::Initialize(
//      LPWSTR                  pszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pszNamespaceIn,
//      LPWSTR                  pszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initialize the instance provider.
//
//  Arguments:
//      pszUserIn       --
//      lFlagsIn        -- WMI flag
//      pszNamespaceIn  --
//      pszLocaleIn     --
//      pNamespaceIn    --
//      pCtxIn          -- WMI context
//      pInitSinkIn     -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CInstanceProv::Initialize(
    LPWSTR                  pszUserIn,
    LONG                    lFlagsIn,
    LPWSTR                  pszNamespaceIn,
    LPWSTR                  pszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lStatus = WBEM_S_INITIALIZED;

    g_ClassMap[ PVD_CLASS_CLUSTER ] =
        CClassCreator( (FPNEW) CCluster::S_CreateThis, PVD_CLASS_CLUSTER , 0 );
    g_ClassMap[ PVD_CLASS_NODE ] =
        CClassCreator( (FPNEW) CClusterNode::S_CreateThis, PVD_CLASS_NODE , 0 );
    g_ClassMap[ PVD_CLASS_RESOURCE ] =
        CClassCreator( (FPNEW) CClusterResource::S_CreateThis, PVD_CLASS_RESOURCE , 0 );
    g_ClassMap[ PVD_CLASS_RESOURCETYPE ] =
        CClassCreator( (FPNEW) CClusterResourceType::S_CreateThis, PVD_CLASS_RESOURCETYPE , 0 );
    g_ClassMap[ PVD_CLASS_GROUP ] =
        CClassCreator( (FPNEW) CClusterGroup::S_CreateThis, PVD_CLASS_GROUP , 0 );
    g_ClassMap[ PVD_CLASS_NODEACTIVERES ] =
        CClassCreator( (FPNEW) CClusterNodeRes::S_CreateThis, PVD_CLASS_NODEACTIVERES , 0 );
    g_ClassMap[ PVD_CLASS_NETWORKSINTERFACE ] =
        CClassCreator( (FPNEW) CClusterNetInterface::S_CreateThis, PVD_CLASS_NETWORKSINTERFACE, 0 );
    g_ClassMap[ PVD_CLASS_NETWORKS ] =
        CClassCreator( (FPNEW) CClusterNetwork::S_CreateThis, PVD_CLASS_NETWORKS , 0 );

    g_ClassMap[ PVD_CLASS_CLUSTERTONETWORKS ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTONETWORKS , CLUSTER_ENUM_NETWORK );
    g_ClassMap[ PVD_CLASS_CLUSTERTONETINTERFACE ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTONETINTERFACE , CLUSTER_ENUM_NETINTERFACE );
    g_ClassMap[ PVD_CLASS_CLUSTERTONODE ] =
        CClassCreator( (FPNEW) CClusterToNode::S_CreateThis, PVD_CLASS_CLUSTERTONODE , CLUSTER_ENUM_NODE );
    g_ClassMap[ PVD_CLASS_CLUSTERTORES ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTORES , CLUSTER_ENUM_RESOURCE );
    g_ClassMap[ PVD_CLASS_CLUSTERTORESTYPE ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTORESTYPE , CLUSTER_ENUM_RESTYPE );
    g_ClassMap[ PVD_CLASS_CLUSTERTOGROUP ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTOGROUP , CLUSTER_ENUM_GROUP  );
    g_ClassMap[ PVD_CLASS_NODEACTIVEGROUP ] =
        CClassCreator( (FPNEW) CClusterNodeGroup::S_CreateThis, PVD_CLASS_NODEACTIVEGROUP , CLUSTER_ENUM_GROUP  );
    g_ClassMap[ PVD_CLASS_RESRESOURCETYPE ] =
        CClassCreator( (FPNEW) CClusterResResType::S_CreateThis, PVD_CLASS_RESRESOURCETYPE , CLUSTER_ENUM_RESOURCE );
    g_ClassMap[ PVD_CLASS_RESDEPRES ] =
        CClassCreator( (FPNEW) CClusterResDepRes::S_CreateThis, PVD_CLASS_RESDEPRES , CLUSTER_ENUM_RESOURCE );
    g_ClassMap[ PVD_CLASS_GROUPTORES ] =
        CClassCreator( (FPNEW) CClusterGroupRes::S_CreateThis, PVD_CLASS_GROUPTORES , CLUSTER_ENUM_RESOURCE );
    g_ClassMap[ PVD_CLASS_NETTONETINTERFACE ] =
        CClassCreator( (FPNEW) CClusterNetNetInterface::S_CreateThis, PVD_CLASS_NETTONETINTERFACE , CLUSTER_ENUM_NETINTERFACE );
    g_ClassMap[ PVD_CLASS_NODETONETINTERFACE ] =
        CClassCreator( (FPNEW) CClusterNodeNetInterface::S_CreateThis, PVD_CLASS_NODETONETINTERFACE , CLUSTER_ENUM_NETINTERFACE );
    g_ClassMap[ PVD_CLASS_CLUSTERTOQUORUMRES ] =
        CClassCreator( (FPNEW) CClusterClusterQuorum::S_CreateThis, PVD_CLASS_CLUSTERTOQUORUMRES , 0 );
    g_ClassMap[ PVD_CLASS_SERVICES ] =
        CClassCreator( (FPNEW) CClusterService::S_CreateThis, PVD_CLASS_SERVICES , 0 );
    g_ClassMap[ PVD_CLASS_HOSTEDSERVICES ] =
        CClassCreator( (FPNEW) CClusterHostedService::S_CreateThis, PVD_CLASS_HOSTEDSERVICES , 0 );

    return CImpersonatedProvider::Initialize(
                pszUserIn,
                lFlagsIn,
                pszNamespaceIn,
                pszLocaleIn,
                pNamespaceIn,
                pCtxIn,
                pInitSinkIn
                );

} //*** CInstanceProv::Initialize()

//****************************************************************************
//
//  CClassProv
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClassProv::CClassProv( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClassProv::CClassProv( void )
{
    InterlockedIncrement( &g_cObj );

} //*** CClassProv::CClassProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClassProv::~CClassProv( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClassProv::~CClassProv( void )
{
    InterlockedDecrement( &g_cObj );

} //*** CClassProv::~CClassProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClassProv::Initialize(
//      LPWSTR                  pszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pszNamespaceIn,
//      LPWSTR                  pszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initialize the class provider.
//
//  Arguments:
//      pszUserIn       --
//      lFlagsIn        -- WMI flag
//      pszNamespaceIn  --
//      pszLocaleIn     --
//      pNamespaceIn    --
//      pCtxIn          -- WMI context
//      pInitSinkIn     -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClassProv::Initialize(
    LPWSTR                  ,// pszUserIn,
    LONG                    lFlagsIn,
    LPWSTR                  ,// pszNamespaceIn,
    LPWSTR                  ,// pszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{
    HRESULT                     hr      = WBEM_S_NO_ERROR;
    LONG                        lStatus = WBEM_S_INITIALIZED;
    static map< _bstr_t, bool > mapResourceType;

    TracePrint(( "CClassProv:Initialize entry - do resources first\n" ));

    try
    {
        SAFECLUSTER         shCluster;
        SAFERESOURCE        shResource;
        DWORD               dwReturn            = ERROR_SUCCESS;
        LPCWSTR             pwszResName         = NULL;
        LPCWSTR             pwszResTypeName     = NULL;
        DWORD               cbTypeName          = 1024;
        DWORD               cbTypeNameReturned  = 0;
        CWstrBuf            wsbTypeName;
        CWbemClassObject    wco;
        CWbemClassObject    wcoChild;
        CError              er;

        wsbTypeName.SetSize( cbTypeName );
        er = pNamespaceIn->GetObject(
                const_cast< LPWSTR >( PVD_CLASS_PROPERTY ),
                lFlagsIn,
                pCtxIn,
                &wco,
                NULL
                );

        shCluster = OpenCluster( NULL );

        CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_RESOURCE );

        //
        // First enumerate all of the resources.
        //
        while ( pwszResName = cluEnum.GetNext() )
        {
            TracePrint(( "CClassProv:Initialize found resource = %ws\n", pwszResName ));

            shResource = OpenClusterResource( shCluster, pwszResName );

            //
            // get resource type name
            //
            dwReturn = ClusterResourceControl(
                            shResource,
                            NULL,
                            CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                            NULL,
                            0,
                            wsbTypeName,
                            cbTypeName,
                            &cbTypeNameReturned
                            );

            if ( dwReturn == ERROR_MORE_DATA )
            {
                cbTypeName = cbTypeNameReturned;
                wsbTypeName.SetSize( cbTypeName );
                er = ClusterResourceControl(
                            shResource,
                            NULL,
                            CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                            NULL,
                            0,
                            wsbTypeName,
                            cbTypeName,
                            &cbTypeNameReturned
                            );
            } // if: buffer was too small

            //
            // check if type name already handled
            //
            if ( mapResourceType[ (LPCWSTR) wsbTypeName ] )
            {
                continue;
            }

            mapResourceType[ (LPCWSTR) wsbTypeName ] = true;

            wco.SpawnDerivedClass( 0, &wcoChild );

            CreateMofClassFromResource( shResource, wsbTypeName, wcoChild );
            er = pNamespaceIn->PutClass(
                       wcoChild.data(),
                       WBEM_FLAG_OWNER_UPDATE,
                       pCtxIn,
                       NULL
                       );
        } // while: more resources


        cbTypeNameReturned  = 0;

        TracePrint(( "CClassProv:Initialize - now find resource types\n" ));

        //
        // Now enumerate all of the resource types.
        //
        CClusterEnum cluEnumResType( shCluster, CLUSTER_ENUM_RESTYPE );

        while ( pwszResTypeName = cluEnumResType.GetNext() )
        {
            //
            // check if type name already handled
            //
            if ( mapResourceType[ (LPCWSTR) pwszResTypeName ] )
            {
                TracePrint(( "CClassProv:Initialize found existing restype = %ws\n", pwszResTypeName ));
                continue;
            }

            mapResourceType[ (LPCWSTR) pwszResTypeName ] = true;

            TracePrint(( "CClassProv:Initialize Creating new restype = %ws\n", pwszResTypeName ));

            wco.SpawnDerivedClass( 0, &wcoChild );

            CreateMofClassFromResType( shCluster, pwszResTypeName, wcoChild );
            er = pNamespaceIn->PutClass(
                       wcoChild.data(),
                       WBEM_FLAG_OWNER_UPDATE,
                       pCtxIn,
                       NULL
                       );
            //TracePrint(( "CClassProv:Initialize PutClass for %ws returned %u\n", pwszResTypeName, er ));


        } // while: more resource types
    } // try
    catch ( CProvException & cpe )
    {
        lStatus = cpe.hrGetError();
        TracePrint(( "CClassProv:Initialize Caught CProvException = %u\n", lStatus ));
    }
    catch (...)
    {
        TracePrint(( "CClassProv:Initialize Caught Unknown Exception\n" ));
        lStatus = WBEM_E_FAILED;
    }

    //TracePrint(( "CClassProv:Initialize exit\n" ));

    pInitSinkIn->SetStatus( lStatus,0 );
    return WBEM_S_NO_ERROR;

} //*** CClassProv::Initialize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClassProv::S_HrCreateThis(
//      IUnknown *  pUnknownOuterIn,
//      VOID **     ppvOut
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      pUnknownOuterIn -- Outer IUnknown pointer.
//      ppvOut          -- Receives the created instance pointer.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClassProv::S_HrCreateThis(
    IUnknown *  ,// pUnknownOuterIn,
    VOID **     ppvOut
    )
{
    *ppvOut = new CClassProv();
    return S_OK;

} //*** CClassProv::S_HrCreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClassProv::CreateMofClassFromResource(
//      HRESOURCE           hResourceIn,
//      LPCWSTR             pwszTypeNameIn,
//      CWbemClassObject &  rClassInout
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      hResourceIn     -- Cluster resource handle.
//      pwszTypeNameIn  -- Type name (??).
//      rClassInout     -- WMI class object.
//
//  Return Values:
//      None
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClassProv::CreateMofClassFromResource(
    HRESOURCE           hResourceIn,
    LPCWSTR             pwszTypeNameIn,
    CWbemClassObject &  rClassInout
    )
{
    WCHAR               pwszClass[ MAX_PATH ];
    IWbemQualifierSet * pQualifers = NULL;
    LPWSTR              pwsz;

    TracePrint(( "CreateMofClassFromResource: entry, TypeName = %ws\n", pwszTypeNameIn ));

    //
    // form new class name
    //
    wcscpy( pwszClass, L"MSCluster_Property_" );
    pwsz = wcschr( pwszClass, L'\0' );
    PwszSpaceReplace( pwsz, pwszTypeNameIn, L'_');
    rClassInout.SetProperty( pwszClass, PVD_WBEM_CLASS );
    g_TypeNameToClass[ pwszTypeNameIn ] = pwszClass ;

    //
    // setup class property
    //

    {
        static DWORD s_rgdwControl[] =
        {
            CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES,
            CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
        };
        static DWORD s_cControl = sizeof( s_rgdwControl ) / sizeof( DWORD );

        DWORD   dwRt = ERROR_SUCCESS;
        VARIANT var;
        UINT    idx;

        var.vt =  VT_NULL;

        for ( idx = 0 ; idx < s_cControl ; idx++ )
        {
            CClusPropList pl;

            dwRt = pl.ScGetResourceProperties(
                        hResourceIn,
                        s_rgdwControl[ idx ],
                        NULL,
                        0 );

            dwRt = pl.ScMoveToFirstProperty();
            while ( dwRt == ERROR_SUCCESS )
            {
                LPCWSTR             pwszPropName = NULL;
                WCHAR               pwszPropMof[MAX_PATH];
                CIMTYPE             cimType;

                pwszPropName = pl.PszCurrentPropertyName();
                PwszSpaceReplace( pwszPropMof, pwszPropName, L'_' );

                switch ( pl.CpfCurrentValueFormat() )
                {
                    case CLUSPROP_FORMAT_WORD:
                    {
                        cimType =  CIM_UINT16;
                        break;
                    } // case: CLUSPROP_FORMAT_WORD

                    case CLUSPROP_FORMAT_DWORD:
                    {
                        cimType = CIM_UINT32;
                        break;
                    } // case: CLUSPROP_FORMAT_DWORD:

                    case CLUSPROP_FORMAT_LONG:
                    {
                        cimType = CIM_SINT32;
                        break;
                    } // case: CLUSPROP_FORMAT_LONG:

                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                    case CLUSPROP_FORMAT_EXPANDED_SZ:
                    {
                        cimType = CIM_STRING;
                        break;
                    } // case: CLUSPROP_FORMAT_SZ, etc.

                    case CLUSPROP_FORMAT_BINARY:
                    {
                        cimType = CIM_UINT8 | CIM_FLAG_ARRAY;
                        break;
                    } // case: CLUSPROP_FORMAT_BINARY

                    case CLUSPROP_FORMAT_MULTI_SZ:
                    {
                        cimType = CIM_STRING | CIM_FLAG_ARRAY;
                        break;
                    } // case: CLUSPROP_FORMAT_BINARY

                    case CLUSPROP_FORMAT_LARGE_INTEGER:
                    {
                        cimType = CIM_SINT32 | CIM_FLAG_ARRAY;
                        break;
                    } // case: CLUSPROP_FORMAT_ULARGE_INTEGER

                    case CLUSPROP_FORMAT_ULARGE_INTEGER:
                    {
                        cimType = CIM_UINT32 | CIM_FLAG_ARRAY;
                        break;
                    } // case: CLUSPROP_FORMAT_ULARGE_INTEGER

                    case CLUSPROP_FORMAT_SECURITY_DESCRIPTOR:
                    {
                        cimType = CIM_UINT8 | CIM_FLAG_ARRAY;
                        break;
                    }

                    default:
                    {
                        TracePrint(( "CreateMofClassFromResource: Unknown format value %lx\n",  pl.CpfCurrentValueFormat() ));
                        break;
                    }

                } // switch : property type

                rClassInout.data()->Put(
                    pwszPropMof,
                    0,
                    &var,
                    cimType
                    );

                dwRt = pl.ScMoveToNextProperty();
            } // while: proplist not empty

        } // for: readwrite and readonly property
    } // set properties

} //*** CClassProv::CreateMofClassFromResource()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClassProv::CreateMofClassFromResType(
//      HCLUSTER            hCluster,
//      LPCWSTR             pwszTypeNameIn,
//      CWbemClassObject &  rClassInout
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      pwszTypeNameIn  -- Type name (??).
//      rClassInout     -- WMI class object.
//
//  Return Values:
//      None
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClassProv::CreateMofClassFromResType(
    HCLUSTER            hCluster,
    LPCWSTR             pwszTypeNameIn,
    CWbemClassObject &  rClassInout
    )
{
    WCHAR               pwszClass[ MAX_PATH ];
    IWbemQualifierSet * pQualifers = NULL;
    LPWSTR              pwsz;

    //
    // form new class name
    //
    wcscpy( pwszClass, L"MSCluster_Property_" );
    pwsz = wcschr( pwszClass, L'\0' );
    PwszSpaceReplace( pwsz, pwszTypeNameIn, L'_');
    rClassInout.SetProperty( pwszClass, PVD_WBEM_CLASS );
    g_TypeNameToClass[ pwszTypeNameIn ] = pwszClass ;

    TracePrint(( "CreateMofClassFromResType: entry\n" ));

    //
    // setup class property
    //

    {
        static DWORD s_rgdwControl[] =
        {
            CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS,
        };
        static DWORD s_cControl = sizeof( s_rgdwControl ) / sizeof( DWORD );

        DWORD   dwRt = ERROR_SUCCESS;
        VARIANT var;
        UINT    idx;

        var.vt =  VT_NULL;

        for ( idx = 0 ; idx < s_cControl ; idx++ )
        {
            CClusPropList pl;

            dwRt = pl.ScGetResourceTypeProperties(
                        hCluster,
                        pwszTypeNameIn,
                        s_rgdwControl[ idx ],
                        NULL,
                        NULL,
                        0 );

            if ( dwRt != ERROR_SUCCESS ) {
                TracePrint(( "CreateMofClassFromResType: error = %lx reading restype format types\n", dwRt ));
                continue;
            }

            dwRt = pl.ScMoveToFirstProperty();
            while ( dwRt == ERROR_SUCCESS )
            {
                LPCWSTR             pwszPropName = NULL;
                WCHAR               pwszPropMof[MAX_PATH];
                CIMTYPE             cimType;
                DWORD               formatType;

                pwszPropName = pl.PszCurrentPropertyName();
                formatType = pl.CpfCurrentFormatListSyntax();
                TracePrint(( "CreateMofClassFromResType: Found name = %ws, format type = %lx\n", pwszPropName, formatType ));

                PwszSpaceReplace( pwszPropMof, pwszPropName, L'_' );

                switch ( formatType )
                {
                    case CLUSPROP_FORMAT_WORD:
                    {
                        cimType =  CIM_UINT16;
                        break;
                    } // case: CLUSPROP_FORMAT_WORD

                    case CLUSPROP_FORMAT_DWORD:
                    {
                        cimType = CIM_UINT32;
                        break;
                    } // case: CLUSPROP_FORMAT_DWORD:

                    case CLUSPROP_FORMAT_LONG:
                    {
                        cimType = CIM_SINT32;
                        break;
                    } // case: CLUSPROP_FORMAT_LONG:

                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                    case CLUSPROP_FORMAT_EXPANDED_SZ:
                    {
                        cimType = CIM_STRING;
                        break;
                    } // case: CLUSPROP_FORMAT_SZ, etc.

                    case CLUSPROP_FORMAT_BINARY:
                    {
                        cimType = CIM_UINT8 | CIM_FLAG_ARRAY;
                        break;
                    } // case: CLUSPROP_FORMAT_BINARY

                    case CLUSPROP_FORMAT_MULTI_SZ:
                    {
                        cimType = CIM_STRING | CIM_FLAG_ARRAY;
                        break;
                    } // case: CLUSPROP_FORMAT_BINARY

                    default:
                    {
                        TracePrint(( "CreateMofClassFromResType: Unknown format type = %lx", formatType ));
                        break;
                    }

                } // switch : property type

                //TracePrint(( "CreateMofClassFromResType: MofProp = %ws, CIMType = %lx\n", pwszPropMof, cimType ));
                rClassInout.data()->Put(
                    pwszPropMof,
                    0,
                    &var,
                    cimType
                    );

                dwRt = pl.ScMoveToNextProperty();
            } // while: proplist not empty

        } // for: readwrite and readonly property
    } // set properties

} //*** CClassProv::CreateMofClassFromResType()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\instanceprov.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InstanceProv.h
//
//  Implementation File:
//      InstanceProv.cpp
//
//  Description:
//      Definition of the CInstanceProv class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CInstanceProv;
class CClassProv;

//////////////////////////////////////////////////////////////////////////////
//  External Declarations
//////////////////////////////////////////////////////////////////////////////

class CWbemClassObject;
class CProvException;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CInstanceProv
//
//  Description:
//      Implement the Instance and method provider entry point class. WMI 
//      holds a pointer to this object, and invoking its member functions 
//      based client request
//
//--
//////////////////////////////////////////////////////////////////////////////
class CInstanceProv : public CImpersonatedProvider
{
protected:
    SCODE SetExtendedStatus(
        CProvException &    rpeIn,
        CWbemClassObject &  rwcoInstOut
        );
 
public:
    CInstanceProv(
        BSTR            bstrObjectPathIn    = NULL,
        BSTR            bstrUserIn          = NULL,
        BSTR            bstrPasswordIn      = NULL,
        IWbemContext *  pCtxIn              = NULL
        );
    virtual ~CInstanceProv( void );

    HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        );

    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IWbemClassObject *   pInstIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        BSTR                 bstrObjectPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        BSTR                 bstrRefStrIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        BSTR                 bstrQueryLanguageIn,
        BSTR                 bstrQueryIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pHandlerIn
        );

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
        const BSTR          bstrSuperclassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        ) ;

    STDMETHODIMP Initialize(
         LPWSTR                  pszUserIn,
         LONG                    lFlagsIn,
         LPWSTR                  pszNamespaceIn,
         LPWSTR                  pszLocaleIn,
         IWbemServices *         pNamespaceIn,
         IWbemContext *          pCtxIn,
         IWbemProviderInitSink * pInitSinkIn
         );

    static HRESULT S_HrCreateThis(
        IUnknown *  pUnknownOuterIn,
        VOID **     ppvOut
        );

}; //*** CInstanceProv

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClassProv
//
//  Description:
//      Implement the Class provider entry point class. WMI
//      holds a pointer to this object, and invoking its member functions
//      based client request
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClassProv : public CImpersonatedProvider
{
public:
    CClassProv( void );
    virtual ~CClassProv( void );

    HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        BSTR                bstrObjectPathIN,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        BSTR                bstrRefStrIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        BSTR                bstrQueryLanguageIn,
        BSTR                bstrQueryIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
        const BSTR          bstrSuperclassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHODIMP Initialize(
         LPWSTR                  pszUserIn,
         LONG                    lFlagsIn,
         LPWSTR                  pszNamespaceIn,
         LPWSTR                  pszLocaleIn,
         IWbemServices *         pNamespaceIn,
         IWbemContext *          pCtxIn,
         IWbemProviderInitSink * pInitSinkIn
         );

    static HRESULT S_HrCreateThis(
        IUnknown *  pUnknownOuterIn,
        VOID **     ppvOut
        );

protected:
    void CreateMofClassFromResource(
        HRESOURCE           hResourceIn,
        LPCWSTR             pwszTypeNameIn,
        CWbemClassObject &  pClassInout
        );

    void CreateMofClassFromResType(
        HCLUSTER            hCluster,
        LPCWSTR             pwszTypeNameIn,
        CWbemClassObject &  pClassInout
        );

}; //*** class CClassProv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter (DavidP) 05-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG

//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <crtdbg.h>
#include <wbemprov.h>
#include <objbase.h>
#include "ntrkcomm.h"
#include <memory>
#include <map>
#include <list>
#include <comdef.h>
#include <tchar.h>

#include <atlbase.h>

#include <clusapi.h>
#include <resapi.h>
#include <clusudef.h>

#include "Common.h"
#include "ClusterApi.h"
#include "ClusterEnum.h"
#include "ObjectPath.h"
#include "PropList.h"
#include "ProvBase.h"
#include "SafeHandle.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\proplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		PropList.cpp
//
//	Description:
//		Implementation of the CClusPropList class.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//		Galen Barbee (galenb)	December 18, 1998
//			Added parsing methods.
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "proplist.tmh"

#ifdef _DEBUG
#ifdef __AFX_H__
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // __AFX_H__
#endif

#ifndef __AFX_H__
class CMemoryException
{
public:
	void Delete( void ) { }

}; //*** class CMemoryException
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

const int BUFFER_GROWTH_FACTOR = 256;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CchMultiSz
//
//	Description:
//		Length of all of the substrings of a multisz string minus the final NULL.
//
//		(i.e., includes the nulls of the substrings, excludes the final null)
//		multiszlen( "abcd\0efgh\0\0" => 5 + 5 = 10
//
//	Arguments:
//		psz		[IN] The string to get the length of.
//
//	Return Value:
//		Count of characters in the multisz or 0 if empty.
//
//--
/////////////////////////////////////////////////////////////////////////////
static size_t CchMultiSz(
	IN LPCWSTR psz
	)
{
	ASSERT( psz != NULL );

	size_t	_cchTotal = 0;
	size_t	_cchChars;

	while ( *psz != _T( '\0' ) )
	{
		_cchChars = lstrlenW( psz ) + 1;

		_cchTotal += _cchChars;
		psz += _cchChars;
	} // while: pointer not stopped on EOS

	return _cchTotal;

} //*** CchMultiSz

/////////////////////////////////////////////////////////////////////////////
//++
//
//	NCompareMultiSz
//
//	Description:
//		Compare two MULTI_SZ buffers.
//
//	Arguments:
//		pszSource	[IN] The source string.
//		pszTarget	[IN] The target string.
//
//	Return Value:
//		If the string pointed to by pszSource is less than the string pointed
//		to by pszTarget, the return value is negative. If the string pointed
//		to by pszSource is greater than the string pointed to by pszTarget,
//		the return value is positive. If the strings are equal, the return value
//		is zero.
//
//--
/////////////////////////////////////////////////////////////////////////////
static int NCompareMultiSz(
	IN LPCWSTR pszSource,
	IN LPCWSTR pszTarget
	)
{
	ASSERT( pszSource != NULL );
	ASSERT( pszTarget != NULL );

	while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') )
	{
		//
		// Move to end of strings.
		//
		while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') && ( *pszSource == *pszTarget ) )
		{
			++pszSource;
			++pszTarget;
		} // while: pointer not stopped on EOS

		//
		// If strings are the same, skip past terminating NUL.
		// Otherwise exit the loop.
		if ( ( *pszSource == L'\0' ) && ( *pszTarget == L'\0') )
		{
			++pszSource;
			++pszTarget;
		} // if: both stopped on EOS
		else
		{
			break;
		} // else: stopped because something is not equal -- wr are done.

	} // while: pointer not stopped on EOS

	return *pszSource - *pszTarget;

} //*** NCompareMultiSz()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropValueList class
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CClusPropValueList, CObject );
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScMoveToFirstValue
//
//	Description:
//		Move the cursor to the first value in the value list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS	Position moved to the first value successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToFirstValue( void )
{
	ASSERT( m_cbhValueList.pb != NULL );

	DWORD	_sc;

	m_cbhCurrentValue = m_cbhValueList;
	m_cbDataLeft = m_cbDataSize;
	m_bAtEnd = FALSE;

	if ( m_cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
	{
		_sc = ERROR_NO_MORE_ITEMS;
	} // if: no items in the value list
	else
	{
		_sc = ERROR_SUCCESS;
	} // else: items exist in the value list

	return _sc;

} //*** CClusPropValueList::ScMoveToFirstValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScMoveToNextValue
//
//	Description:
//		Move the cursor to the next value in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the next value successfully.
//		ERROR_NO_MORE_ITEMS	Already at the end of the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToNextValue( void )
{
	ASSERT( m_cbhCurrentValue.pb != NULL );

	DWORD					_sc		= ERROR_NO_MORE_ITEMS;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;

	_cbhCurrentValue = m_cbhCurrentValue;

	do
	{
		//
		// Don't try to move if we're already at the end.
		//
		if ( m_bAtEnd )
		{
			break;
		} // if: already at the end of the list

		//
		// Make sure the buffer is big enough for the value header.
		//
		if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance buffer pointer.
		//
		_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
					+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

		//
		// Make sure the buffer is big enough for the value header,
		// the data itself, and the endmark.
		//
		if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Move past the current value to the next value's syntax.
		//
		_cbhCurrentValue.pb += _cbDataSize;

		//
		// This test will ensure that the value is always valid since we won't
		// advance if the next thing is the endmark.
		//
		if ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
		{
			m_cbhCurrentValue = _cbhCurrentValue;
			m_cbDataLeft -= _cbDataSize;
			_sc = ERROR_SUCCESS;
		} // if: next value's syntax is not the endmark
		else
		{
			m_bAtEnd = TRUE;
		} // else: next value's syntax is the endmark
	} while ( 0 );

	return _sc;

} //*** CClusPropValueList::ScMoveToNextValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScCheckIfAtLastValue
//
//	Description:
//		Indicate whether we are on the last value in the list or not.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Not currently at the last value in the list.
//		ERROR_NO_MORE_ITEMS	Currently at the last value in the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScCheckIfAtLastValue( void )
{
	ASSERT( m_cbhCurrentValue.pb != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;
	DWORD					_cbDataSize;

	_cbhCurrentValue = m_cbhCurrentValue;

	do
	{
		//
		// Don't try to recalculate if we already know
		// we're at the end of the list.
		//
		if ( m_bAtEnd )
		{
			break;
		} // if: already at the end of the list

		//
		// Make sure the buffer is big enough for the value header.
		//
		if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance buffer pointer.
		//
		_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
					+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

		//
		// Make sure the buffer is big enough for the value header,
		// the data itself, and the endmark.
		//
		if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Move past the current value to the next value's syntax.
		//
		_cbhCurrentValue.pb += _cbDataSize;

		//
		// We are on the last value if the next thing after this value
		// is an endmark.
		//
		if ( _cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
		{
			_sc = ERROR_NO_MORE_ITEMS;
		} // if: next value's syntax is the endmark
	} while ( 0 );

	return _sc;

} //*** CClusPropValueList::ScCheckIfAtLastValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScAllocValueList
//
//	Description:
//		Allocate a value list buffer that's big enough to hold the next
//		value.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the value list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by new.  By default, no exceptions are thrown.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScAllocValueList( IN DWORD cbMinimum )
{
	ASSERT( cbMinimum > 0 );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbTotal = 0;

	//
	// Add the size of the item count and final endmark.
	//
	cbMinimum += sizeof( CLUSPROP_VALUE );
	_cbTotal = m_cbDataSize + cbMinimum;

	if ( m_cbBufferSize < _cbTotal )
	{
		PBYTE	_pbNewValuelist = NULL;

		cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
		_cbTotal = m_cbDataSize + cbMinimum;

		//
		// Allocate and zero a new buffer.
		//
		_pbNewValuelist = new BYTE[ _cbTotal ];
		if ( _pbNewValuelist != NULL )
		{
			ZeroMemory( _pbNewValuelist, _cbTotal );

			//
			// If there was a previous buffer, copy it and the delete it.
			//
			if ( m_cbhValueList.pb != NULL )
			{
				if ( m_cbDataSize != 0 )
				{
					CopyMemory( _pbNewValuelist, m_cbhValueList.pb, m_cbDataSize );
				} // if: data already exists in buffer

				delete [] m_cbhValueList.pb;
				m_cbhCurrentValue.pb = _pbNewValuelist + (m_cbhCurrentValue.pb - m_cbhValueList.pb);
			} // if: there was a previous buffer
			else
			{
				m_cbhCurrentValue.pb = _pbNewValuelist + sizeof( DWORD ); // move past prop count
			} // else: no previous buffer

			//
			// Save the new buffer.
			//
			m_cbhValueList.pb = _pbNewValuelist;
			m_cbBufferSize = _cbTotal;
		} // if: allocation succeeded
		else
		{
			_sc = ERROR_NOT_ENOUGH_MEMORY;
		} // else: allocation failed
	} // if: buffer isn't big enough

	return _sc;

} //*** CClusPropValueList::ScAllocValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScGetResourceValueList
//
//	Description:
//		Get value list of a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropValueList::ScAllocValueList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceValueList(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hResource != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cb = 512;

    TracePrint(( "GetResourceValueList entry\n" ));

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get values.
	//
	_sc = ScAllocValueList( _cb );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhValueList.pb,
						m_cbBufferSize,
						&_cb
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocValueList( _cb );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceControl(
								hResource,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhValueList.pb,
								m_cbBufferSize,
								&_cb
								);
			} // if: ScAllocValueList succeeded
		} // if: buffer too small
	} // if: ScAllocValueList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeleteValueList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cb;
		m_cbDataLeft = _cb;
	} // else: no errors

	return _sc;

} //*** CClusPropValueList::ScGetResourceValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropValueList::ScGetResourceTypeValueList
//
//	Description:
//		Get value list of a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropValueList::ScAllocValueList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceTypeValueList(
	IN HCLUSTER	hCluster,
	IN LPCWSTR	pwszResTypeName,
	IN DWORD	dwControlCode,
	IN HNODE	hHostNode,
	IN LPVOID	lpInBuffer,
	IN DWORD	cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( pwszResTypeName != NULL );
	ASSERT( *pwszResTypeName != L'\0' );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cb = 512;

    TracePrint(( "GetResourceTypeValueList entry\n" ));

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get values.
	//
	_sc = ScAllocValueList( _cb );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhValueList.pb,
						m_cbBufferSize,
						&_cb
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocValueList( _cb );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceTypeControl(
								hCluster,
								pwszResTypeName,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhValueList.pb,
								m_cbBufferSize,
								&_cb
								);
			} // if: ScAllocValueList succeeded
		} // if: buffer too small
	} // if: ScAllocValueList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeleteValueList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cb;
		m_cbDataLeft = _cb;
	} // else: no errors

	return _sc;

} //*** CClusPropValueList::ScGetResourceTypeValueList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CClusPropList, CObject );
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScCopy
//
//	Description:
//		Copy a property list.  This function is equivalent to an assignment
//		operator.  Since this operation can fail, no assignment operator is
//		provided.
//
//	Arguments:
//		pcplPropList	[IN] The proplist to copy into this instance.
//		cbListSize		[IN] The total size of the prop list.
//
//	Return Value:
//		Win32 status code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScCopy(
	IN const PCLUSPROP_LIST	pcplPropList,
	IN DWORD				cbListSize
	)
{
	ASSERT( pcplPropList != NULL );

	DWORD	_sc = ERROR_SUCCESS;

	//
	// Clean up any vestiges of a previous prop list.
	//
	if ( m_cbhPropList.pb != NULL )
	{
		DeletePropList();
	} // if: the current list is not empty

	//
	// Allocate the new property list buffer.  If successful,
	// copy the source list.
	//
	m_cbhPropList.pb = new BYTE[ cbListSize ];
	if ( m_cbhPropList.pb != NULL )
	{
		CopyMemory( m_cbhPropList.pList, pcplPropList, cbListSize );
		m_cbBufferSize = cbListSize;
		m_cbDataSize   = cbListSize;
		m_cbDataLeft   = cbListSize;
		_sc = ScMoveToFirstProperty();
	} // if: new succeeded
	else
	{
		_sc = ERROR_NOT_ENOUGH_MEMORY;
	} // else:

	return _sc;

} //*** CClusPropList::ScCopy()

////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToFirstProperty
//
//	Description:
//		Move the cursor to the first property in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the first property successfully.
//		ERROR_NO_MORE_ITEMS	There are no properties in the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToFirstProperty( void )
{
	ASSERT( m_cbhPropList.pb != NULL );
	ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

	DWORD					_sc;
	DWORD					_cbDataLeft;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;

    TracePrint(( "MoveToFirstProperty: entry\n" ));

	do
	{
		//
		// Make sure the buffer is big enough for the list header.
		//
		if ( m_cbDataSize < sizeof( m_cbhPropList.pList->nPropertyCount ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data

		//
		// Set the property counter to the number of properties in the list.
		//
		m_nPropsRemaining = m_cbhPropList.pList->nPropertyCount;

		//
		// Point the name pointer to the first name in the list.
		//
		m_cbhCurrentPropName.pName = &m_cbhPropList.pList->PropertyName;
		m_cbDataLeft = m_cbDataSize - sizeof( m_cbhPropList.pList->nPropertyCount );

		//
		// Check to see if there are any properties in the list.
		//
		if ( m_nPropsRemaining == 0 )
		{
            TracePrint(( "MoveToFirstProperty: no properties found!\n" ));
			_sc = ERROR_NO_MORE_ITEMS;
			break;
		} // if: no properties in the list

		//
		// Make sure the buffer is big enough for the first property name.
		//
		if ( m_cbDataLeft < sizeof( *m_cbhCurrentPropName.pName ) )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Calculate how much to advance the buffer pointer.
		//
		_cbDataSize = sizeof( *m_cbhCurrentPropName.pName )
					+ ALIGN_CLUSPROP( m_cbhCurrentPropName.pName->cbLength );

		//
		// Make sure the buffer is big enough for the name header
		// and the data itself.
		//
		if ( m_cbDataLeft < _cbDataSize )
		{
			_sc = ERROR_INVALID_DATA;
			break;
		} // if: not enough data left

		//
		// Point the value buffer to the first value in the list.
		//
        //TracePrint(( "MoveToFirstProperty: First Property Name = %ws, props remain = %u\n", _cbhCurrentValue.pStringValue->sz, m_nPropsRemaining ));
		_cbhCurrentValue.pb = m_cbhCurrentPropName.pb + _cbDataSize;
		_cbDataLeft = m_cbDataLeft - _cbDataSize;
		m_pvlValues.Init( _cbhCurrentValue, _cbDataLeft );

		//
		// Indicate we are successful.
		//
		_sc = ERROR_SUCCESS;

	} while ( 0 );

	//_cbhCurrentValue = m_pvlValues;
    //TracePrint(( "MoveToFirstProperty: First Property Name = %ws, props remain = %u\n", _cbhCurrentValue.pStringValue->sz, m_nPropsRemaining ));

    TracePrint(( "MoveToFirstProperty: exit\n" ));

	return _sc;

} //*** CClusPropList::ScMoveToFirstProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToNextProperty
//
//	Description:
//		Move the cursor to the next property in the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS		Position moved to the next property successfully.
//		ERROR_NO_MORE_ITEMS	Already at the end of the list.
//		ERROR_INVALID_DATA	Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToNextProperty( void )
{
	ASSERT( m_cbhPropList.pb != NULL );
	ASSERT( m_pvlValues.CbhValueList().pb != NULL );

	DWORD					_sc;
	DWORD					_cbNameSize;
	DWORD					_cbDataLeft;
	DWORD					_cbDataSize;
	CLUSPROP_BUFFER_HELPER	_cbhCurrentValue;
	CLUSPROP_BUFFER_HELPER	_cbhPropName;

	_cbhCurrentValue = m_pvlValues;
	_cbDataLeft = m_pvlValues.CbDataLeft();

    //TracePrint(( "CClusPropList:ScMoveToNextProperty  entry\n" ));

	//
	// If we aren't already at the last property, attempt to move to the next one.
	//
	_sc = ScCheckIfAtLastProperty();
	if ( _sc == ERROR_SUCCESS )
	{
		do
		{
			//
			// Make sure the buffer is big enough for the value header.
			//
			if ( _cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data left

			//
			// Careful!  Add offset only to cbhCurrentValue.pb.  Otherwise
			// pointer arithmetic will give undesirable results.
			//
			while ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
			{
				//
				// Make sure the buffer is big enough for the value
				// and an endmark.
				//
				_cbDataSize = sizeof( *_cbhCurrentValue.pValue )
							+ ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );
				if ( _cbDataLeft < _cbDataSize + sizeof( *_cbhCurrentValue.pSyntax ) )
				{
					_sc = ERROR_INVALID_DATA;
					break;
				} // if: not enough data left

				//
				// Advance past the value.
				//
				_cbhCurrentValue.pb += _cbDataSize;
				_cbDataLeft -= _cbDataSize;
			} // while: not at endmark

			if ( _sc != ERROR_SUCCESS )
			{
				break;
			} // if: error occurred in loop

			//
			// Advanced past the endmark.
			// Size check already performed in above loop.
			//
			_cbDataSize = sizeof( *_cbhCurrentValue.pSyntax );
			_cbhCurrentValue.pb += _cbDataSize;
			_cbDataLeft -= _cbDataSize;

			//
			// Point the name pointer to the next name in the list.
			//
			_cbhPropName = _cbhCurrentValue;
            //TracePrint(( "MoveToNextProperty: name = %ws\n", _cbhPropName.pStringValue->sz ));
			ASSERT( _cbDataLeft == m_cbDataSize - (_cbhPropName.pb - m_cbhPropList.pb) );

			//
			// Calculate the size of the name with header.
			// Make sure the buffer is big enough for the name and an endmark.
			//
			if ( _cbDataLeft < sizeof( *_cbhPropName.pName ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data
			_cbNameSize = sizeof( *_cbhPropName.pName )
						+ ALIGN_CLUSPROP( _cbhPropName.pName->cbLength );
			if ( _cbDataLeft < _cbNameSize + sizeof( CLUSPROP_SYNTAX ) )
			{
				_sc = ERROR_INVALID_DATA;
				break;
			} // if: not enough data

			//
			// Point the value buffer to the first value in the list.
			//
			_cbhCurrentValue.pb = _cbhPropName.pb + _cbNameSize;
			m_cbhCurrentPropName = _cbhPropName;
			m_cbDataLeft = _cbDataLeft - _cbNameSize;
			m_pvlValues.Init( _cbhCurrentValue, m_cbDataLeft );

			//
			// We've successfully advanced to the next property,
			// so there is now one fewer property remaining.
			//
			--m_nPropsRemaining;
			ASSERT( m_nPropsRemaining >= 1 );

			_sc = ERROR_SUCCESS;

		} while ( 0 );
	} // if: not at last property

	return _sc;

} //*** CClusPropList::ScMoveToNextProperty()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScMoveToPropertyByName
//
//	Description:
//		Find the passed in property name in the proplist.  Note that the
//		cursor is reset to the beginning at the beginning of the routine and
//		the current state of the cursor is lost.
//
//	Arguments:
//		pwszPropName	[IN] Name of the property
//
//	Return Value:
//		TRUE if the property was found, FALSE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToPropertyByName( IN LPCWSTR pwszPropName )
{
	ASSERT( m_cbhPropList.pb != NULL );

	DWORD	_sc;

	_sc = ScMoveToFirstProperty();
	if ( _sc == ERROR_SUCCESS )
	{
		do
		{
			//
			// See if this is the specified property.  If so, we're done.
			//
			if ( lstrcmpiW( m_cbhCurrentPropName.pName->sz, pwszPropName ) == 0 )
			{
				break;
			} // if: property found

			//
			// Advance to the next property.
			//
			_sc = ScMoveToNextProperty();

		} while ( _sc == ERROR_SUCCESS );	// do-while: not end of list
	} // if: successfully moved to the first property

	return _sc;

} //*** ClusPropList::ScMoveToPropertyByName( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAllocPropList
//
//	Description:
//		Allocate a property list buffer that's big enough to hold the next
//		property.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by new.  By default, no exceptions are thrown.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAllocPropList( IN DWORD cbMinimum )
{
	ASSERT( cbMinimum > 0 );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbTotal = 0;

	//
	// Add the size of the item count and final endmark.
	//
	cbMinimum += sizeof( CLUSPROP_VALUE );
	_cbTotal = m_cbDataSize + cbMinimum;

	if ( m_cbBufferSize < _cbTotal )
	{
		PBYTE	_pbNewProplist = NULL;

		cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
		_cbTotal = m_cbDataSize + cbMinimum;

		//
		// Allocate and zero a new buffer.
		//
		_pbNewProplist = new BYTE[ _cbTotal ];
		if ( _pbNewProplist != NULL )
		{
			ZeroMemory( _pbNewProplist, _cbTotal );

			//
			// If there was a previous buffer, copy it and the delete it.
			//
			if ( m_cbhPropList.pb != NULL )
			{
				if ( m_cbDataSize != 0 )
				{
					CopyMemory( _pbNewProplist, m_cbhPropList.pb, m_cbDataSize );
				} // if: data already exists in buffer

				delete [] m_cbhPropList.pb;
				m_cbhCurrentProp.pb = _pbNewProplist + (m_cbhCurrentProp.pb - m_cbhPropList.pb);
			} // if: there was a previous buffer
			else
			{
				m_cbhCurrentProp.pb = _pbNewProplist + sizeof( DWORD ); // move past prop count
			} // else: no previous buffer

			//
			// Save the new buffer.
			//
			m_cbhPropList.pb = _pbNewProplist;
			m_cbBufferSize = _cbTotal;
		} // if: allocation succeeded
		else
		{
			_sc = ERROR_NOT_ENOUGH_MEMORY;
		} // else: allocation failed
	} // if: buffer isn't big enough

	return _sc;

} //*** CClusPropList::ScAllocPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR 	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_SZ			_pValue;

	if (( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ))
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pStringValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddMultiSzProp
//
//	Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddMultiSzProp(
	IN LPCWSTR 	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_MULTI_SZ		_pValue;

	if ( ( pwszPrevValue != NULL ) && ( NCompareMultiSz( pwszValue, pwszPrevValue ) == 0 ) )
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (CchMultiSz( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pMultiSzValue;
			CopyMultiSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddMultiSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddExpandSzProp
//
//	Description:
//		Add an EXPAND_SZ string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pwszValue		[IN] Value of the property to set in the list.
//		pwszPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddExpandSzProp(
	IN LPCWSTR	pwszName,
	IN LPCWSTR	pwszValue,
	IN LPCWSTR	pwszPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					_bValuesDifferent = TRUE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_SZ			_pValue;

	if ( ( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ) )
	{
		_bValuesDifferent = FALSE;
	} // if: we have a prev value and the values are the same

	//
	// If we should always add, or if the new value and the previous value
	// are not equal, add the property to the property list.
	//
	if ( m_bAlwaysAddProp || _bValuesDifferent )
	{
		DWORD	_cbNameSize;
		DWORD	_cbDataSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
		_cbValueSize = sizeof( CLUSPROP_SZ )
					+ ALIGN_CLUSPROP( _cbDataSize )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pStringValue;
			CopyExpandSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddExpandSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a DWORD property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		nValue			[IN] Value of the property to set in the list.
//		nPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR	pwszName,
	IN DWORD	nValue,
	IN DWORD	nPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_DWORD			_pValue;

	if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_DWORD )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pDwordValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( DWORD )

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a LONG property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		nValue			[IN] Value of the property to set in the list.
//		nPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR	pwszName,
	IN LONG		nValue,
	IN LONG		nPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_LONG			_pValue;

	if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_LONG )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pLongValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( LONG )

#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Description:
//		Add a binary property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pbValue			[IN] Value of the property to set in the list.
//		cbValue			[IN] Count of bytes in pbValue.
//		pbPrevValue		[IN] Previous value of the property.
//		cbPrevValue		[IN] Count of bytes in pbPrevValue.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR			pwszName,
	IN const PBYTE		pbValue,
	IN DWORD			cbValue,
	IN const PBYTE		pbPrevValue,
	IN DWORD			cbPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	BOOL					bChanged = FALSE;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_BINARY		_pValue;

	//
	// Determine if the buffer has changed.
	//
	if ( m_bAlwaysAddProp || (cbValue != cbPrevValue) )
	{
		bChanged = TRUE;
	} // if: always adding the property or the value size changed
	else if ( ( cbValue != 0 ) && ( cbPrevValue != 0 ) )
	{
		bChanged = memcmp( pbValue, pbPrevValue, cbValue ) != 0;
	} // else if: value length changed

	if ( bChanged )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_BINARY )
					+ ALIGN_CLUSPROP( cbValue )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pBinaryValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScAddProp
//
//	Routine Description:
//		Add a ULONGLONG property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		ullValue		[IN] Value of the property to set in the list.
//		ullPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
	IN LPCWSTR		pwszName,
	IN ULONGLONG	ullValue,
	IN ULONGLONG	ullPrevValue
	)
{
	ASSERT( pwszName != NULL );

	DWORD						_sc = ERROR_SUCCESS;
	PCLUSPROP_PROPERTY_NAME		_pName;
	PCLUSPROP_ULARGE_INTEGER	_pValue;

	if ( m_bAlwaysAddProp || ( ullValue != ullPrevValue ) )
	{
		DWORD	_cbNameSize;
		DWORD	_cbValueSize;

		//
		// Calculate sizes and make sure we have a property list.
		//
		_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
					+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
		_cbValueSize = sizeof( CLUSPROP_ULARGE_INTEGER )
					+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

		_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
		if ( _sc == ERROR_SUCCESS )
		{
			//
			// Set the property name.
			//
			_pName = m_cbhCurrentProp.pName;
			CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
			m_cbhCurrentProp.pb += _cbNameSize;

			//
			// Set the property value.
			//
			_pValue = m_cbhCurrentProp.pULargeIntegerValue;
			CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, ullValue );
			m_cbhCurrentProp.pb += _cbValueSize;

			//
			// Increment the property count and buffer size.
			//
			m_cbhPropList.pList->nPropertyCount++;
			m_cbDataSize += _cbNameSize + _cbValueSize;
		} // if: ScAllocPropList successfully grew the proplist

	} // if: the value has changed

	return _sc;

} //*** CClusPropList::ScAddProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScSetPropToDefault
//
//	Description:
//		Add a property to the property list so that it will revert to its
//		default value.
//
//	Arguments:
//		pwszName	[IN] Name of the property.
//		cpfPropFmt	[IN] Format of property
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScSetPropToDefault(
	IN LPCWSTR					pwszName,
	IN CLUSTER_PROPERTY_FORMAT	cpfPropFmt
	)
{
	ASSERT( pwszName != NULL );

	DWORD					_sc = ERROR_SUCCESS;
	DWORD					_cbNameSize;
	DWORD					_cbValueSize;
	PCLUSPROP_PROPERTY_NAME	_pName;
	PCLUSPROP_VALUE			_pValue;

	// Calculate sizes and make sure we have a property list.
	_cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
				+ ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
	_cbValueSize = sizeof( CLUSPROP_BINARY )
				+ sizeof( CLUSPROP_SYNTAX ); // value list endmark

	_sc = ScAllocPropList( _cbNameSize + _cbValueSize );
	if ( _sc == ERROR_SUCCESS )
	{
		//
		// Set the property name.
		//
		_pName = m_cbhCurrentProp.pName;
		CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
		m_cbhCurrentProp.pb += _cbNameSize;

		//
		// Set the property value.
		//
		_pValue = m_cbhCurrentProp.pValue;
		CopyEmptyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, cpfPropFmt );
		m_cbhCurrentProp.pb += _cbValueSize;

		//
		// Increment the property count and buffer size.
		//
		m_cbhPropList.pList->nPropertyCount++;
		m_cbDataSize += _cbNameSize + _cbValueSize;
	} // if:

	return _sc;

} //*** CClusPropList::ScSetPropToDefault()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in pwsz string.  If specified as 0,
//						the the length will be determined by a call to strlen.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz		// = 0
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
	} // if: zero size specified
	ASSERT( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	lstrcpyW( pprop->sz, psz );

	//
	// Set an endmark.
	//
	_cbhProps.pStringValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyMultiSzProp
//
//	Description:
//		Copy a MULTI_SZ string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in psz string.  If specified as 0,
//						the the length will be determined by calls to strlen.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyMultiSzProp(
	OUT PCLUSPROP_MULTI_SZ		pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_MULTI_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (CchMultiSz( psz ) + 1) * sizeof( WCHAR );
	} // if: zero size specified
	ASSERT( cbsz == (CchMultiSz( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	CopyMemory( pprop->sz, psz, cbsz );

	//
	// Set an endmark.
	//
	_cbhProps.pMultiSzValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pMultiSzValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyMultiSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyExpandSzProp
//
//	Description:
//		Copy an EXPAND_SZ string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		psz			[IN] String to copy.
//		cbsz		[IN] Count of bytes in psz string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyExpandSzProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LPCWSTR					psz,
	IN size_t					cbsz
	)
{
	ASSERT( pprop != NULL );
	ASSERT( psz != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	if ( cbsz == 0 )
	{
		cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
	} // if: cbsz == 0
	ASSERT( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
	pprop->cbLength = cbsz;
	lstrcpyW( pprop->sz, psz );

	//
	// Set an endmark.
	//
	_cbhProps.pStringValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyExpandSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a DWORD property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of DWORD.
//		nValue		[IN] Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_DWORD			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN DWORD					nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = sizeof( DWORD );
	pprop->dw = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pDwordValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pDwordValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( DWORD )

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a LONG property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of LONG.
//		nValue		[IN] Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_LONG			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN LONG						nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_LONG;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = sizeof( DWORD );
	pprop->l = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pLongValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pLongValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( LONG )

#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a ULONGLONG property to a property structure.
//
//	Arguments:
//		pprop		[OUT]	Property structure to fill.
//		proptype	[IN]	Type of LONG.
//		nValue		[IN]	Property value to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT	PCLUSPROP_ULARGE_INTEGER	pprop,
	IN	CLUSTER_PROPERTY_TYPE		proptype,
	IN	ULONGLONG					nValue
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
	pprop->Syntax.wType = static_cast< WORD >( proptype );
	pprop->cbLength = sizeof( ULONGLONG );
	pprop->li.QuadPart = nValue;

	//
	// Set an endmark.
	//
	_cbhProps.pULargeIntegerValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pULargeIntegerValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Description:
//		Copy a binary property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of string.
//		pb			[IN] Block to copy.
//		cbsz		[IN] Count of bytes in pb buffer.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_BINARY		pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN const PBYTE				pb,
	IN size_t					cb
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
	pprop->Syntax.wType = static_cast< WORD >( cptPropType );
	pprop->cbLength = cb;
	if ( cb > 0 )
	{
		CopyMemory( pprop->rgb, pb, cb );
	} // if: non-zero data length

	//
	// Set an endmark.
	//
	_cbhProps.pBinaryValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cb );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyEmptyProp
//
//	Description:
//		Copy an empty property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		cptPropType	[IN] Type of property.
//		cpfPropFmt	[IN] Format of property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyEmptyProp(
	OUT PCLUSPROP_VALUE			pprop,
	IN CLUSTER_PROPERTY_TYPE	cptPropType,
	IN CLUSTER_PROPERTY_FORMAT	cptPropFmt
	)
{
	ASSERT( pprop != NULL );

	CLUSPROP_BUFFER_HELPER	_cbhProps;

    pprop->Syntax.wFormat = static_cast< WORD >( cptPropFmt );
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = 0;

	//
	// Set an endmark.
	//
	_cbhProps.pValue = pprop;
	_cbhProps.pb += sizeof( *_cbhProps.pValue );
	_cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyEmptyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNodeProperties
//
//	Description:
//		Get properties on a node.
//
//	Arguments:
//		hNode			[IN] Handle for the node to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNodeProperties(
	IN HNODE		hNode,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hNode != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNodeControl(
								hNode,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
							);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetGroupProperties
//
//	Description:
//		Get properties on a group.
//
//	Arguments:
//		hGroup			[IN] Handle for the group to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetGroupProperties(
	IN HGROUP		hGroup,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hGroup != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterGroupControl(
								hGroup,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetResourceProperties
//
//	Description:
//		Get properties on a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceProperties(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hResource != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceControl(
								hResource,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetResourceTypeProperties
//
//	Description:
//		Get properties on a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceTypeProperties(
	IN HCLUSTER		hCluster,
	IN LPCWSTR		pwszResTypeName,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( pwszResTypeName != NULL );
	ASSERT( *pwszResTypeName != L'\0' );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterResourceTypeControl(
								hCluster,
								pwszResTypeName,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNetworkProperties
//
//	Description:
//		Get properties on a network.
//
//	Arguments:
//		hNetwork		[IN] Handle for the network to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetworkProperties(
	IN HNETWORK		hNetwork,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	ASSERT( hNetwork != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc = ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNetworkControl(
								hNetwork,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetNetInterfaceProperties
//
//	Description:
//		Get properties on a network interface.
//
//	Arguments:
//		hNetInterface	[IN] Handle for the network interface to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetInterfaceProperties(
	IN HNETINTERFACE	hNetInterface,
	IN DWORD			dwControlCode,
	IN HNODE			hHostNode,
	IN LPVOID			lpInBuffer,
	IN DWORD			cbInBufferSize
	)
{
	ASSERT( hNetInterface != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc= ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterNetInterfaceControl(
								hNetInterface,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetNetInterfaceProperties()

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::ScGetClusterProperties
//
//	Description:
//		Get properties on a cluster.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetClusterProperties(
	IN HCLUSTER	hCluster,
	IN DWORD	dwControlCode,
	IN HNODE	hHostNode,
	IN LPVOID	lpInBuffer,
	IN DWORD	cbInBufferSize
	)
{
	ASSERT( hCluster != NULL );
	ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_CLUSTER << CLUSCTL_OBJECT_SHIFT) );

	DWORD	_sc= ERROR_SUCCESS;
	DWORD	_cbProps = 256;

	//
	// Overwrite anything that may be in the buffer.
	// Allows this class instance to be reused.
	//
	m_cbDataSize = 0;

	//
	// Get properties.
	//
	_sc = ScAllocPropList( _cbProps );
	if ( _sc == ERROR_SUCCESS )
	{
		_sc = ClusterControl(
						hCluster,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_cbhPropList.pb,
						m_cbBufferSize,
						&_cbProps
						);
		if ( _sc == ERROR_MORE_DATA )
		{
			_sc = ScAllocPropList( _cbProps );
			if ( _sc == ERROR_SUCCESS )
			{
				_sc = ClusterControl(
								hCluster,
								hHostNode,
								dwControlCode,
								lpInBuffer,
								cbInBufferSize,
								m_cbhPropList.pb,
								m_cbBufferSize,
								&_cbProps
								);
			} // if: ScAllocPropList succeeded
		} // if: buffer too small
	} // if: ScAllocPropList succeeded

	if ( _sc != ERROR_SUCCESS )
	{
		DeletePropList();
	} // if: error getting private properties.
	else
	{
		m_cbDataSize = _cbProps;
		m_cbDataLeft = _cbProps;
	} // else: no errors

	return _sc;

} //*** CClusPropList::ScGetClusterProperties()


#endif // CLUSAPI_VERSION >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\objectpath.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ObjectPath.h
//
//  Implementation File:
//      ObjectPath.cpp
//
//  Description:
//      Definition of the CObjpath class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "genlex.h"     //wbem sdk header
#include "objpath.h"    //wbem sdk header

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CObjPath;
class CProvException;
class CWbemClassObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CObjPath
//
//  Description:
//      CObjpath class make it easier to work with Object path string
//
//--
/////////////////////////////////////////////////////////////////////////////
class CObjPath
{
//
// constructor and desctructor
//
public:

    CObjPath( void );
    virtual ~CObjPath( void );

public:
    _bstr_t GetObjectPathString( void );

    BOOL AddProperty(
        LPCWSTR     pwszNameIn,
        LPCWSTR     pwszValueIn
        );
    
    BOOL AddProperty(
        LPCWSTR     pwszNameIn,
        VARIANT *   pvValueIn
        );
    
    BOOL SetClass(
        IN LPCWSTR pwszValue
        );
    
    _bstr_t GetStringValueForProperty(
        LPCWSTR pwszIn
        );

    _bstr_t GetClassName( void );
    
    BOOL Init(
        LPCWSTR     pwszPathIn
        );
    
protected:
    ParsedObjectPath *  m_parsedObj;

}; //*** class CObjPath

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvException
//
//  Description:
//      Base exception class, declares common interface and member data
//      for all exception subclass
//  
//--
/////////////////////////////////////////////////////////////////////////////
class CProvException
{
public:
    CProvException(
        HRESULT hrIn
        )
        : m_hr( hrIn )
    {
    }

    CProvException(
        DWORD   nWin32ErrorIn
        )
        : m_hr( 0 )
    {
        m_hr = HRESULT_FROM_WIN32( nWin32ErrorIn );
    }

    virtual ~CProvException( void )
    {
    }

    CProvException(
        const CProvException & rhsIn
        )
        : m_hr( 0 )
    {
        m_bstrError = rhsIn.m_bstrError;
        m_hr = rhsIn.m_hr;
    }

    CProvException & operator=(
        const CProvException & rhsIn
        )
    {
        m_bstrError = rhsIn.m_bstrError;
        m_hr = rhsIn.m_hr;
        return *this;
    }

    LPCWSTR PwszErrorMessage( void ) const;

    BOOL BIsWmiError( void ) const
    {
        return HRESULT_FACILITY( m_hr ) == 4;
    }

    DWORD DwGetError( void ) const throw()
    {
        return HRESULT_CODE( m_hr );
    }

    HRESULT hrGetError( void ) const throw()
    {
        return m_hr;
    }

protected:
    mutable _bstr_t m_bstrError;
    HRESULT         m_hr;

}; //*** class CProvException

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemClassObject
//
//  Description:
//      Wrap for IWbemClassObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWbemClassObject
{
protected:
    IWbemClassObject *  m_pClassObject;
    VARIANT             m_v;

public:
    CWbemClassObject( void );
    CWbemClassObject( IWbemClassObject * pInstIn );
    virtual ~CWbemClassObject( void );

    IWbemClassObject ** operator&( void )
    {
        return &m_pClassObject;
    }

    CWbemClassObject & operator=( IWbemClassObject * pInstIn )
    {
        if( pInstIn != NULL )
        {
            pInstIn->AddRef();
            if ( m_pClassObject != NULL )
            {
                m_pClassObject->Release();
            }
            m_pClassObject = pInstIn;
        }
        return *this;
    }

    CWbemClassObject & operator=( CWbemClassObject & rInstIn )
    {
        
        if ( m_pClassObject != NULL )
        {
            m_pClassObject->Release();
        }
        
        m_pClassObject = rInstIn.m_pClassObject;
        if ( m_pClassObject != NULL )
        {
            m_pClassObject->AddRef();
        }
        
        return *this;
    }

    SCODE SetProperty(
        LPCSTR      pszValueIn,
        LPCWSTR     pwszPropNameIn
        );

    SCODE SetProperty(
        DWORD       dwValueIn,
        LPCWSTR     pwszPropNameIn
        );

    SCODE SetProperty(
        LPCWSTR     pwszValueIn,
        LPCWSTR     pwszPropNameIn
        );
    SCODE SetProperty(
        IWbemClassObject * pWbemClassObjectIn,
        LPCWSTR     pwszPropNameIn
        );
    SCODE SetProperty(
        DWORD       dwSizeIn,
        PBYTE       pByteIn,
        LPCWSTR     pwszPropNameIn
        );
    SCODE SetProperty(
        DWORD       dwSizeIn,
        LPCWSTR     pwszMultiSzIn,
        LPCWSTR     pwszPropNameIn
        );

    SCODE SetProperty(
        DWORD       dwSizeIn,
        BSTR *      pbstrIn,
        LPCWSTR     pwszPropNameIn
        );

    SCODE GetProperty(
        DWORD *     pdwValueOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetProperty(
        DWORD *     pdwSizeOut,
        PBYTE *     ppByteOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetProperty(
        DWORD *     pdwSizeOut,
        _bstr_t **  ppbstrOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetPropertyMultiSz(
        DWORD *     pdwSizeOut,
        LPWSTR *    ppwszMultiSzOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetProperty(
        _bstr_t &   rBstrOut,
        LPCWSTR     pwszPropNameIn
    );

    SCODE GetProperty(
        BOOL *      pfValueOut,
        LPCWSTR     pwszPropNameIn
        );

    SCODE GetProperty(
        VARIANT *   pVariantOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetProperty(
        CWbemClassObject & rWcoInout,
        LPCWSTR     pwszPropNameIn
        );

    SCODE GetMethod(
        BSTR                bstrMethodNameIn,
        LONG                lFlagIn,
        IWbemClassObject ** ppINOut,
        IWbemClassObject ** ppOUTOut
        );
    SCODE SpawnInstance(
        LONG                lFlagIn,
        IWbemClassObject ** ppNewOut
        );
    SCODE SpawnDerivedClass(
        LONG                lFlagIn,
        IWbemClassObject ** ppNewOut
        );

    IWbemClassObject * data( void )
    {
        return m_pClassObject;
    }

}; //*** class CWbemClassObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\objectpath.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ObjectPath.cpp
//
//  Description:    
//      Implementation of class CObjpath, CProvException, CProvExceptionHr,
//      and CProvExceptionWin32.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ObjectPath.h"

//****************************************************************************
//
//  CObjPath
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CObjPath::CObjPath( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CObjPath::CObjPath( void )
    : m_parsedObj( NULL )
{

} //*** CObjPath::CObjPath()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CObjPath::~CObjPath( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CObjPath::~CObjPath( void )
{
    delete m_parsedObj;

} //*** CObjPath::~CObjPath()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetStringValueForProperty(
//      LPCWSTR     pwszIn
//      )
//
//  Description:
//      Retrieve the string value for the given property.
//
//  Arguments:
//      pwszIn      -- Name of the property
//
//  Return Values:
//      The property's value.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetStringValueForProperty(
    LPCWSTR     pwszIn
    )
{
    int         idx;
    KeyRef *    pKey;

    for( idx = 0 ; idx < m_parsedObj->m_dwNumKeys ; idx++ )
    {
        pKey = m_parsedObj->m_paKeys[ idx ];
        if( _wcsicmp( pKey->m_pName, pwszIn ) == 0 )
        {
            if( pKey->m_vValue.vt == VT_BSTR )
            {
                return pKey->m_vValue.bstrVal;
            }
        }
    }

    return L"";

} //*** CObjPath::GetStringValueForProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetClassName( void )

//
//  Description:
//      Get the class name.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Class name string.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetClassName( void )
{
    return m_parsedObj->m_pClass;

} //*** CObjPath::GetClassName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::Init(
//      LPCWSTR     pwszPathIn
//      )
//
//  Description:
//      Initialize the object.
//
//  Arguments:
//      pwszPathIn  -- Object path string
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::Init(
    LPCWSTR     pwszPathIn
    )
{
    if ( pwszPathIn == NULL )
    {
        m_parsedObj = new ParsedObjectPath;
    }
    else
    {
        CObjectPathParser objParser( e_ParserAcceptRelativeNamespace );
        objParser.Parse(
            const_cast< WCHAR * >( pwszPathIn ),
            &m_parsedObj
            );
    }

    if ( m_parsedObj == NULL )
    {
        return FALSE;
    } // if:

    return TRUE;

} //*** CObjPath::Init()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::SetClass(
//      LPCWSTR     pwszValueIn
//      )
//
//  Description:
//      Set the name of the class for the object path.
//
//  Arguments:
//      pwszValueIn     -- Class name string.
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::SetClass(
    LPCWSTR     pwszValueIn
    )
{
    return m_parsedObj->SetClassName( pwszValueIn );

} //*** CObjPath::SetClass()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::AddProperty(
//      IN LPCWSTR pwszNameIn,
//      IN LPCWSTR pwszValueIn
//      )
//
//  Description:
//      Add property to object path.
//
//  Arguments:
//      pwszNameIn      -- Name of the property.
//      pwszValueIn     -- Value of the property in WCHAR* format.
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::AddProperty(
    IN LPCWSTR pwszNameIn,
    IN LPCWSTR pwszValueIn
    )
{
    VARIANT v;
    BOOL    bRt = FALSE;

    VariantInit( & v );
    v.vt = VT_BSTR;
    v.bstrVal = _bstr_t( pwszValueIn ).copy(  );
    bRt = m_parsedObj->AddKeyRef(
                pwszNameIn,
                & v
                );
    VariantClear( & v );
    return bRt;
    
} //*** CObjPath::AddProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetObjectPathString( void )
//
//  Description:
//      Retrieve object path string.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Object path string in _bstr_t.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetObjectPathString( void )
{
    LPWSTR  pwszPath = NULL;
    _bstr_t bstrResult;

    try
    {
        CObjectPathParser::Unparse( m_parsedObj, & pwszPath );
        bstrResult = pwszPath;
    }
    catch( ... )   //catch _com_error
    {
        delete [] pwszPath;
        throw;
    }

    delete [] pwszPath;
    return bstrResult;

} //*** CObjPath::GetObjectPathString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::AddProperty(
//      LPCWSTR     pwszNameIn,
//      VARIANT *   pvValueIn
//      )
//
//  Description:
//      Add a property to this instance.
//
//  Arguments:
//      pwszNameIn      -- Name of the property.
//      pvValueIn       -- Value of the property in VARIANT format
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::AddProperty(
    LPCWSTR     pwszNameIn,
    VARIANT *   pvValueIn
    )
{
    return m_parsedObj->AddKeyRef( pwszNameIn, pvValueIn );

} //*** CObjPath::AddProperty

//****************************************************************************
//
//  CProvException
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  CProvException::PwszErrorMessage( void ) const
//
//  Description:
//      retrieve Error message 
//
//  Arguments:
//      None.
//
//  Return Values:
//      Null-terminated Unicode error message from the exception.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
CProvException::PwszErrorMessage( void ) const
{
    if ( m_bstrError.length( ) == 0 )
    {
        LPWSTR pError = NULL;
        DWORD rt = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        HRESULT_CODE( m_hr ),
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPWSTR) &pError,
                        0,
                        NULL
                        );
        m_bstrError = pError;
        LocalFree( pError );
    } // if: string is empty
    return m_bstrError;

} //*** CProvException::PwszErrorMessage()

//****************************************************************************
//
//  CWbemClassObject
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::CWbemClassObject( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::CWbemClassObject( void )
    : m_pClassObject( NULL )
{
    VariantInit( &m_v );

} //*** CWbemClassObject::CWbemClassObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::CWbemClassObject(
//      IWbemClassObject *  pInstIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pInstIn     -- WMI class object interface.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::CWbemClassObject(
    IWbemClassObject *  pInstIn
    )
    : m_pClassObject( NULL )
{
    m_pClassObject = pInstIn;
    if ( m_pClassObject )
    {
        m_pClassObject->AddRef();
    }
    VariantInit( &m_v );

} //*** CWbemClassObject::CWbemClassObject( pInstIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::~CWbemClassObject( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::~CWbemClassObject( void )
{
    if ( m_pClassObject )
    {
        m_pClassObject->Release();
    }
    VariantClear( &m_v );

} //*** CWbemClassObject::~CWbemClassObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      DWORD       dwValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set dword value of a property.
//
//  Arguments:
//      dwValueIn       -- Property dword value
//      pwszPropNameIn  -- Property Name
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    DWORD       dwValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE sc;

    VariantClear( &m_v );
    m_v.vt = VT_I4;
    m_v.lVal = dwValueIn;
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0, 
                &m_v,
                0
                );

    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( dwValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      LPCWSTR     pwszValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set wstring value of a property.
//
//  Arguments:
//      pwszValueIn     -- Property string value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CWbemClassObject::SetProperty(
    LPCWSTR     pwszValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE sc;
    if ( pwszValueIn == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    VariantClear( &m_v );
//  _bstr_t bstrValue( pwszValueIn );
    m_v.vt = VT_BSTR;
    m_v.bstrVal = _bstr_t( pwszValueIn ).copy();
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                0
                );
    VariantClear( &m_v );


    if( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;
 
} //*** CWbemClassObject::SetProperty( pwszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      DWORD       dwSizeIn,
//      PBYTE       pByteIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set binary value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pByteIn.
//      pByteIn         -- Pointer to byte.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    PBYTE       pByteIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LONG            idx;
    LONG            ix;

    rgsabound[ 0 ].lLbound = 0;
    rgsabound[ 0 ].cElements = dwSizeIn;

    if( pByteIn == NULL )
    {
        return sc;
    }
    
    VariantClear( &m_v );

    psa = SafeArrayCreate( VT_UI1, 1, rgsabound );
    if(psa == NULL)
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    for( idx = 0 ; idx < dwSizeIn ; idx++ )
    {
        ix = idx;
        sc = SafeArrayPutElement(
                psa,
                &ix,
                static_cast< void * >( pByteIn+idx )
                );

        if ( sc != S_OK )
        {
            throw CProvException( sc );
        }
    }

    m_v.vt = ( VT_ARRAY | VT_UI1 );

    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            0
            );

    if ( sc != S_OK )
    {
        throw CProvException( sc );
    }

    return sc;


} //*** CWbemClassObject::SetProperty( pByteIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      DWORD       dwSizeIn,
//      BSTR *      pbstrIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set wstring array value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pByteIn.
//      pbstrIn         -- Pointer to BSTR array.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    BSTR *      pbstrIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LONG            idx;
    LONG            ix;

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwSizeIn;

    if ( pbstrIn == NULL )
    {
        return sc;
    }

    VariantClear( &m_v );

    psa = SafeArrayCreate( VT_BSTR, 1, rgsabound );
    if ( psa == NULL )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    for( idx = 0 ; idx < dwSizeIn ; idx++)
    {
        ix = idx;
        sc = SafeArrayPutElement(
                psa,
                &ix,
                pbstrIn[ idx ]
                );

        if ( sc != S_OK)
        {
            throw CProvException( sc );
        }
    }

    m_v.vt = (VT_ARRAY | VT_BSTR );

    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            0
            );
    
    if ( sc != S_OK)
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pbstrIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//
//  Description:
//      Set MultiSz value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pwszMultiSzIn.
//      pwszMultiSzIn   -- Pointer to MultiSz.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    LPCWSTR     pwszMultiSzIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LPCWSTR         pwsz = NULL;
    LONG            idx;
    LONG            ix;

    if( pwszMultiSzIn == NULL )
    {
        return sc;
    }
    VariantClear( &m_v );

    //
    // find out the number of string
    //
    DWORD cMultiSz = 1;
    for ( pwsz = pwszMultiSzIn; *pwsz || *pwsz ++ ; pwsz ++ )
    {
        if ( ! ( *pwsz ) )
        {
            cMultiSz ++ ;
        }
    }
    rgsabound[ 0 ].lLbound = 0;
    rgsabound[ 0 ].cElements = cMultiSz;

    psa = SafeArrayCreate( VT_BSTR, 1, rgsabound);
    if ( psa == NULL )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    pwsz = pwszMultiSzIn;
    for( idx = 0 ; idx < cMultiSz ; idx++ )
    {
        ix = idx;
        sc = SafeArrayPutElement(
                    psa,
                    &ix,
                    (BSTR) _bstr_t( pwsz )
                    );

        if ( sc != S_OK )
        {
            throw CProvException( sc );
        }
        pwsz = wcschr( pwsz, L'\0' );
        pwsz ++;
    }

    m_v.vt = (VT_ARRAY | VT_BSTR );
    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0, 
            &m_v,
            0
            );

    if ( sc != S_OK )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pwszMultiSzIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      LPCSTR      pszValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set ansi string value of a property.
//
//  Arguments:
//      pszValueIn      -- Property string value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    LPCSTR      pszValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    if ( pszValueIn == NULL )
    {
        return S_OK;
    }
    return SetProperty(
                static_cast< WCHAR * >( _bstr_t( pszValueIn ) ),
                pwszPropNameIn
                );

} //*** CWbemClassObject::SetProperty( pszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      IWbemClassObject *  pWbemClassObject,
//      LPCWSTR             pwszPropNameIn
//      )
//
//  Description:
//      Set wbem class object of a property.
//
//  Arguments:
//      pWbemClassObject    -- Property wbem class object 
//      pwszPropNameIn      -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    IWbemClassObject *  pWbemClassObjectIn,
    LPCWSTR             pwszPropNameIn
    )
{
    SCODE   sc = S_OK;
    if ( pWbemClassObjectIn == NULL )
    {
        return sc;
    }
    VariantClear( & m_v );
    
    m_v.vt = VT_UNKNOWN  ;
    m_v.punkVal = pWbemClassObjectIn;
    pWbemClassObjectIn->AddRef();
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                0
                );
    VariantClear( &m_v );


    if( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SpawnInstance(
//      LONG                lFlagIn,
//      IWbemClassObject ** ppNewOut
//      )
//
//  Description:
//      Spawn a instance of IWbemClassObject.
//
//  Arguments:
//      lFlagIn     -- WMI flag, reserved, must be 0.
//      ppNewOut    -- Created new instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SpawnInstance(
    LONG                lFlagIn,
    IWbemClassObject ** ppNewOut
    )
{
    return m_pClassObject->SpawnInstance( lFlagIn, ppNewOut );

} //*** CWbemClassObject::SpawnInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SpawnDerivedClass(
//      LONG                lFlagIn,
//      IWbemClassObject ** ppNewOut
//      )
//
//  Description:
//      Spawn a derived class.
//
//  Arguments:
//      lFlagIn     -- WMI flag, reserved, must be 0.
//      ppNewOut    -- Created new instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SpawnDerivedClass(
    LONG                lFlagIn,
    IWbemClassObject ** ppNewOut
    )
{
    return m_pClassObject->SpawnDerivedClass( lFlagIn, ppNewOut );

} //*** CWbemClassObject::SpawnInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetMethod(
//      BSTR                bstrMethodNameIn,
//      LONG                lFlagIn,
//      IWbemClassObject ** ppINOut,
//      IWbemClassObject ** ppOUTOut
//      )
//
//  Description:
//      Retrieve the method for an WMI object.
//
//  Arguments:
//      bstrMethodNameIn
//          Method Name.
//
//      lFlagIn
//          WMI flag, Reserved. It must be zero.
//
//      ppINOut
//          IWbemClassObject pointer which describes the in-parameters 
//          to the method.
//
//      ppOUTOut
//          an IWbemClassObject pointer which describes the 
//          out-parameters to the method
//
//  Return Values:
//      WBEM stand error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetMethod(
    BSTR                bstrMethodNameIn,
    LONG                lFlagIn,
    IWbemClassObject ** ppINOut,
    IWbemClassObject ** ppOUTOut
    )
{
    return m_pClassObject->GetMethod(
                bstrMethodNameIn,
                lFlagIn,
                ppINOut,
                ppOUTOut
                );

} //*** CWbemClassObject::GetMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwValueOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the DWORD property for this WMI object.
//
//  Arguments:
//      pdwValueOut     -- DWORD variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CWbemClassObject::GetProperty(
    DWORD *     pdwValueOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE   sc;

    VariantClear( &m_v );
    sc = m_pClassObject->Get(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            NULL,
            NULL
            );

    if ( SUCCEEDED( sc ) )
    {
        if( m_v.vt == VT_I4 )
        {
            *pdwValueOut = m_v.lVal;
            return sc;
        }
        else if ( m_v.vt == VT_BOOL)
        {
            if ( m_v.boolVal == VARIANT_TRUE )
            {
                *pdwValueOut = 1;
            }
            else
            {
                *pdwValueOut = 0;
            }
            return sc;
        }
        else if ( m_v.vt == VT_UI1 )
        {
            *pdwValueOut = ( DWORD ) m_v.bVal;
        }
        else if ( m_v.vt == VT_NULL )
        {
            return WBEM_E_FAILED;
        }
    }

    // raise exception if sc is not S_OK or vt is not expected
    CProvException e( sc );
    throw e;
    
    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetProperty( pdwValueOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      _bstr_t &   rBstrOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BSTR property for this WMI object.
//
//  Arguments:
//      rBstrOut        -- bstr_t variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetProperty(
    _bstr_t &   rBstrOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE   sc;

    VariantClear( &m_v );
    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );
    if ( SUCCEEDED( sc ) )
    {
        if( m_v.vt == VT_BSTR )
        {
            rBstrOut = m_v.bstrVal;
            return sc;
        }
        else if( m_v.vt == VT_NULL )
        {
            return WBEM_E_FAILED;
        }
    }

    CProvException e( sc );
    throw e;
    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetProperty( rBstrOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      BOOL *      pfValueOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BOOL property for this WMI object.
//
//  Arguments:
//      pfValueOut      -- BOOL variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CWbemClassObject::GetProperty(
    BOOL *      pfValueOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE   sc;

    VariantClear( &m_v );
    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );

    if ( m_v.vt == VT_BOOL )
    {
        *pfValueOut = m_v.boolVal;
        return sc;
    }

    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetProperty

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      PBYTE *     ppByteOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the binary property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppByteOut       -- Output buffer.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CWbemClassObject::GetProperty(
    DWORD *     pdwSizeOut,
    PBYTE *     ppByteOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE sc;
    VariantClear(&m_v);
    *pdwSizeOut = 0;

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                & m_v,
                NULL,
                NULL
                );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_UI1 ) )
        {
            PBYTE   pByte;

            * pdwSizeOut = m_v.parray->rgsabound[ 0 ].cElements;
            * ppByteOut = new BYTE[ *pdwSizeOut ];
            sc = SafeArrayAccessData( m_v.parray, ( void ** ) &pByte );
            if ( SUCCEEDED ( sc ) )
            {    
                UINT idx;
                for ( idx = 0; idx < *pdwSizeOut; idx ++ )
                {
                    *( (* ppByteOut ) + idx ) = *( pByte + idx );
                }
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException( static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER) );
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppByteOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      _bstr_t **  ppbstrOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BSTR array property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppbstrOut       -- BSTR variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetProperty(
    DWORD *     pdwSizeOut,
    _bstr_t **  ppbstrOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE sc;
    VariantClear( &m_v );
    *pdwSizeOut = 0;

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                & m_v,
                NULL, 
                NULL
                );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_BSTR ) )
        {
            BSTR * pBstr;

            *pdwSizeOut = m_v.parray->rgsabound[0].cElements;
            *ppbstrOut = new _bstr_t[ *pdwSizeOut ];
            sc = SafeArrayAccessData( m_v.parray, (void **) & pBstr );
            if ( SUCCEEDED ( sc ) )
            {
                UINT idx;
                for( idx = 0; idx < *pdwSizeOut; idx ++)
                {
                    *( (*ppbstrOut) + idx ) = *( pBstr + idx );
                }
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException( static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER) );
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppbstrOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      LPWSTR *    ppwszMultiSzOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the MultiSz property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppwszMultiSzOut -- MultiSz output buffer.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetPropertyMultiSz(
    DWORD *     pdwSizeOut,
    LPWSTR *    ppwszMultiSzOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE       sc;
    DWORD       cElements;
    DWORD       cMultiSz = 0;

    VariantClear(&m_v);
    *pdwSizeOut = 0;
//    *ppOut = NULL;
    sc = m_pClassObject->Get(
            _bstr_t( pwszPropNameIn ),
            0,
            & m_v,
            NULL,
            NULL
            );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_BSTR ) )
        {
            LPWSTR * ppwsz = NULL;

            cElements = m_v.parray->rgsabound[ 0 ].cElements;
            sc = SafeArrayAccessData( m_v.parray, ( void ** ) & ppwsz );
            if ( SUCCEEDED ( sc ) )
            {    
                UINT idx;
                for( idx = 0; idx < cElements; idx ++)
                {
                   cMultiSz = cMultiSz + wcslen( *(ppwsz + idx) ) + sizeof (WCHAR); 
                }
                cMultiSz += sizeof( WCHAR ) * 2;
                *ppwszMultiSzOut = new WCHAR[ cMultiSz ];

                if ( *ppwszMultiSzOut == NULL )
                {
                    throw CProvException( static_cast< HRESULT > ( WBEM_E_OUT_OF_MEMORY) );
                }
                LPWSTR pwszDst = *ppwszMultiSzOut;
                LPWSTR pwszSrc;
                for ( idx = 0; idx < cElements ; idx ++)
                {
                    for( pwszSrc = *( ppwsz + idx); *pwszSrc ; pwszDst++, pwszSrc ++ )
                    {
                        *pwszDst = *pwszSrc;
                    }
                    *(pwszDst++) = L'\0';
                }
                *pwszDst = L'\0';
                *pdwSizeOut = cMultiSz;
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException( static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER) );
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppwszMultiSzOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      VARIANT *   pVariantOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the variant property for this WMI object.
//
//  Arguments:
//      pVariantOut     -- Variant variable to receive property value
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetProperty(
    VARIANT *   pVariantOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE   sc;

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                pVariantOut,
                NULL,
                NULL
                );
    if ( FAILED( sc ) )
    {
        CProvException e( sc );
        throw e;
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( pVariantOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//  CWbemClassObject & rWcoInout,
//  LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the embeded object property for this WMI object.
//
//  Arguments:
//      rWcoInout       -- class object variable to receive property value
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetProperty(
    CWbemClassObject & rWcoInout,
    LPCWSTR     pwszPropNameIn
    )
{
    
    CError  er;
    VariantClear( &m_v );
    er = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );
    if ( m_v.vt != VT_UNKNOWN )
    {
        er = static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER );
        
    }
    IWbemClassObject * pwco = NULL;
    er = m_v.punkVal->QueryInterface( & pwco );
    rWcoInout = pwco;
    VariantClear( & m_v );
    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( rWcoInout )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\provbase.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvBase.h
//
//  Implementation File:
//      ProvBase.cpp
//
//  Description:
//      Definition of the CProvBase class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CProvBase;
class CProvBaseAssociation;

//////////////////////////////////////////////////////////////////////////////
//  External Declarations
//////////////////////////////////////////////////////////////////////////////

/* main interface class, this class defines all operations can be performed
   on this provider
*/
//class CSqlEval;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvBase
//
//  Description:
//  interface class defines all operations can be performed
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProvBase
{
public:
    virtual SCODE EnumInstance(
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual SCODE GetObject(
        CObjPath &          rObjPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn 
        ) = 0;

    virtual SCODE ExecuteMethod(
        CObjPath &          rObjPathIn,
        WCHAR *             pwszMethodNameIn,
        long                lFlagIn,
        IWbemClassObject *  pParamsIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual SCODE PutInstance( 
        CWbemClassObject &  rInstToPutIn,
        long                lFlagIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual SCODE DeleteInstance(
        CObjPath &          rObjPathIn,
        long                lFlagIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    CProvBase(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    virtual  ~CProvBase( void );

protected:
    CWbemServices *     m_pNamespace;
    IWbemClassObject *  m_pClass;
    _bstr_t             m_bstrClassName;

}; //*** class CProvBase

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvBaseAssociation
//
//  Description:
//  interface class defines all operations can be performed
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProvBaseAssociation
    : public CProvBase
{
public:
    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) = 0;

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    CProvBaseAssociation(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        )
        : CProvBase( pwszNameIn, pNamespaceIn )
    {
    }

    virtual  ~CProvBaseAssociation( void )
    {
    }

protected:
    void GetTypeName(
        _bstr_t &   bstrClassNameOut,
        _bstr_t     bstrProperty 
        );

}; //*** class CProvBaseAssociation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		PropList.h
//
//	Implementation File:
//		PropList.cpp
//
//	Description:
//		Definition of the CClusPropList class.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//		12/18/1998	GalenB	Added MoveFirst, MoveNext, and other parsing
//							methods.
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _PROPLIST_H_
#define _PROPLIST_H_

#pragma once

#include <clusapi.h>
#include <resapi.h>

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CObjectProperty;
class CClusPropValueList;
class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#if !defined( ASSERT )
#include <crtdbg.h>
#define ASSERT _ASSERTE
#endif // !defined( ASSERT )

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjectProperty
//
//	Description:
//		Describes a property in a cluster property list.
//
//	Inheritance:
//		CObjectProperty
//
//--
/////////////////////////////////////////////////////////////////////////////

#if defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )


class CObjectProperty
{
public:
	LPCWSTR					m_pwszName;
	CLUSTER_PROPERTY_FORMAT	m_propFormat;

	union CValue
	{
		CString *	pstr;
		LONG *		pl;
		DWORD *		pdw;
		BOOL *		pb;
		struct
		{
			PBYTE *	ppb;
			DWORD *	pcb;
		};
	};
	CValue					m_value;
	CValue					m_valuePrev;
	CValue					m_valueEx;		// expand_sz value (if any)

	DWORD					m_fFlags;

	enum ObjPropFlags
	{
		opfNew = 1
	};

	CObjectProperty::CObjectProperty( void )
	{
		m_value.pstr = NULL;
		m_value.pcb = NULL;
		m_valuePrev.pstr = NULL;
		m_valuePrev.pcb = NULL;
		m_valueEx.pstr = NULL;
		m_valueEx.pcb = NULL;
	};

	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_valuePrev.pstr = &rstrPrevValue;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	void	SetExpandSz(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
		m_value.pstr = &rstrValue;
		m_valuePrev.pstr = &rstrPrevValue;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	// Set() to get extra EXPANDED_SZ value
	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN CString & rstrValueEx,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valueEx.pstr = &rstrValueEx;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	// Set() to get extra EXPANDED_SZ value
	void	SetExpandSz(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue,
				IN CString & rstrValueEx,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
		m_value.pstr = &rstrValue;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valueEx.pstr = &rstrValueEx;
		m_fFlags = fFlags;

	} //*** Set( CString & )

	void	Set(
				IN LPCWSTR pwszName,
				IN LONG & rnValue,
				IN LONG & rnPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_LONG;
		m_value.pl = &rnValue;
		m_valuePrev.pl = &rnPrevValue;
		m_fFlags = fFlags;

	} //*** Set( LONG & )

	void	Set(
				IN LPCWSTR pwszName,
				IN DWORD & rdwValue,
				IN DWORD & rdwPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pdw = &rdwValue;
		m_valuePrev.pdw = &rdwPrevValue;
		m_fFlags = fFlags;

	} //*** Set( DWORD & )

	void	Set(
				IN LPCWSTR pwszName,
				IN BOOL & rbValue,
				IN BOOL & rbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pb = &rbValue;
		m_valuePrev.pb = &rbPrevValue;
		m_fFlags = fFlags;

	} //*** Set( BOOL & )

	void	Set(
				IN LPCWSTR pwszName,
				IN PBYTE & rpbValue,
				IN DWORD & rcbValue,
				IN PBYTE & rpbPrevValue,
				IN DWORD & rcbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_BINARY;
		m_value.ppb = &rpbValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = &rpbPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
		m_fFlags = fFlags;

	} //*** Set( PBYTE & )

	void	Set(
				IN LPCWSTR pwszName,
				IN LPWSTR & rpwszValue,
				IN DWORD & rcbValue,
				IN LPWSTR & rpwszPrevValue,
				IN DWORD & rcbPrevValue,
				IN DWORD fFlags = 0
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
		m_value.ppb = reinterpret_cast< PBYTE * >( &rpwszValue );
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = reinterpret_cast< PBYTE * >( &rpwszPrevValue );
		m_valuePrev.pcb = &rcbPrevValue;
		m_fFlags = fFlags;

	} //*** Set( LPWSTR & )

}; //*** class CObjectProperty

#endif	// defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )


class CClusPropValueList
#ifdef __AFX_H__
	: public CObject
#endif // __AFX_H__
{
#ifdef __AFX_H__
	DECLARE_DYNAMIC( CClusPropValueList );
#endif // __AFX_H__

public:
	//
	// Construction.
	//

	// Default constructor
	CClusPropValueList( void )
		: m_cbDataSize( 0 )
		, m_cbDataLeft( 0 )
		, m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		m_cbhValueList.pb = NULL;
		m_cbhCurrentValue.pb = NULL;

	} //*** CClusPropValueList()

	// Copy constructor.
	CClusPropValueList( IN const CClusPropValueList & rcpvl )
		: m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		Init( rcpvl );

	} //*** CClusPropValueList()

	// Buffer helper constructor.
	CClusPropValueList( IN CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
		: m_cbBufferSize( 0 )
		, m_bAtEnd( FALSE )
	{
		Init( cbhValueList, cbDataSize );

	} //*** CClusPropValueList()

	// Destructor
	~CClusPropValueList( void )
	{
		DeleteValueList();

	} //*** ~CClusPropValueList()

	// Initialize the value list
	void Init( IN const CClusPropValueList & rcpvl )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= rcpvl.m_cbhValueList;
		m_cbhCurrentValue	= rcpvl.m_cbhCurrentValue;
		m_cbDataSize		= rcpvl.m_cbDataSize;
		m_cbDataLeft		= rcpvl.m_cbDataLeft;
		m_bAtEnd			= rcpvl.m_bAtEnd;

	} //*** Init()

	// Initialize the value list from a buffer helper
	void Init( IN const CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= cbhValueList;
		m_cbhCurrentValue	= cbhValueList;
		m_cbDataSize		= cbDataSize;
		m_cbDataLeft		= cbDataSize;
		m_bAtEnd			= FALSE;

	} //*** Init()

	// Assignment operator
	void operator=( IN const CClusPropValueList & rcpvl )
	{
		ASSERT( m_cbBufferSize == 0 );

		m_cbhValueList		= rcpvl.m_cbhValueList;
		m_cbhCurrentValue	= rcpvl.m_cbhCurrentValue;
		m_cbDataSize		= rcpvl.m_cbDataSize;
		m_cbDataLeft		= rcpvl.m_cbDataLeft;
		m_bAtEnd			= rcpvl.m_bAtEnd;

	} //*** operator=()

public:
	//
	// Accessor methods.
	//

	// Buffer helper cast operator to access the current value
	operator const CLUSPROP_BUFFER_HELPER( void ) const
	{
		return m_cbhCurrentValue;

	} //*** operator CLUSPROP_BUFFER_HELPER()

	// Access the value list
	CLUSPROP_BUFFER_HELPER CbhValueList( void ) const
	{
		return m_cbhValueList;

	} //*** CbhValueList()

	// Access the current value
	CLUSPROP_BUFFER_HELPER CbhCurrentValue( void ) const
	{
		return m_cbhCurrentValue;

	} //*** CbhCurrentValue()

	// Access the format of the current value
	CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pValue->Syntax.wFormat );

	} //*** CpfCurrentValueFormat()

	// Access the format of the current format list syntax entry
	CLUSTER_PROPERTY_FORMAT CpfCurrentFormatListSyntax( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pWordValue->w );

	} //*** CpfCurrentFormatListSyntax()

	// Access the type of the current value
	CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_TYPE >( m_cbhCurrentValue.pValue->Syntax.wType );

	} //*** CptCurrentValueType()

	// Access the syntax of the current value
	CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
	{
		return static_cast< CLUSTER_PROPERTY_SYNTAX >( m_cbhCurrentValue.pValue->Syntax.dw );

	} //*** CpsCurrentValueSyntax()

	// Access the length of the data of the current value
	DWORD CbCurrentValueLength( void ) const
	{
		DWORD cbLength;

		if ( m_cbhCurrentValue.pb == NULL )
		{
			cbLength = 0;
		} // if: no value list allocated yet
		else
		{
			cbLength = m_cbhCurrentValue.pValue->cbLength;
		} // else: value list allocated

		return cbLength;

	} //*** CbCurrentValueLength()

	// Access size of the data in the buffer.
	DWORD CbDataSize( void ) const
	{
		return m_cbDataSize;

	} //*** CbDataSize()

	// Access amount of data left in buffer after current value
	DWORD CbDataLeft( void ) const
	{
		return m_cbDataLeft;

	} //*** CbDataLeft()

public:
	//
	// Parsing methods.
	//

	// Move to the first value in the list
	DWORD ScMoveToFirstValue( void );

	// Move the value after the current one in the list
	DWORD ScMoveToNextValue( void );

	// Query whether we are at the last value in the list or not
	DWORD ScCheckIfAtLastValue( void );

public:
	//
	// Methods for building a value list.
	//

	// Allocate a value list
	DWORD ScAllocValueList( IN DWORD cbMinimum );

	// Delete the value list buffer and cleanup support variables
	void DeleteValueList( void )
	{
		//
		// If m_cbBufferSize is greater then 0 then we allocated the value list.
		// If it's zero then the value list is a part of the property list in
		// CClusPropList.
		//
		if ( m_cbBufferSize > 0 )
		{
			delete [] m_cbhValueList.pb;
			m_cbhValueList.pb = NULL;
			m_cbhCurrentValue.pb = NULL;
			m_cbBufferSize = 0;
			m_cbDataSize = 0;
			m_cbDataLeft = 0;
			m_bAtEnd = FALSE;
		} // if: we allocated anything

	} //*** DeletePropList()

	// Get a value list from a resource
	DWORD ScGetResourceValueList(
						IN HRESOURCE	hResource,
						IN DWORD		dwControlCode,
						IN HNODE		hHostNode		= NULL,
						IN LPVOID		lpInBuffer		= NULL,
						IN DWORD		cbInBufferSize	= 0
						);

	// Get a value list from a resource type
	DWORD ScGetResourceTypeValueList(
						IN HCLUSTER	hCluster,
						IN LPCWSTR	pwszResTypeName,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

private:
	CLUSPROP_BUFFER_HELPER	m_cbhValueList;		// Pointer to the value list for parsing.
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentValue;	// Pointer to the current value for parsing.
	DWORD					m_cbDataSize;		// Amount of data in the buffer.
	DWORD					m_cbDataLeft;		// Amount of data left in buffer after current value.
	DWORD					m_cbBufferSize;		// Size of the buffer if we allocated it.
	BOOL					m_bAtEnd;			// Indicates whether at last value in list.

}; //*** class CClusPropValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPropList
//
//	Description:
//		Describes a cluster property list.
//
//	Inheritance:
//		CClusPropList
//		CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusPropList
#ifdef __AFX_H__
	: public CObject
#endif // __AFX_H__
{
#ifdef __AFX_H__
	DECLARE_DYNAMIC( CClusPropList );
#endif // __AFX_H__

public:
	//
	// Construction.
	//

	// Default constructor
	CClusPropList( IN BOOL bAlwaysAddProp = FALSE )
		: m_bAlwaysAddProp( bAlwaysAddProp )
		, m_cbBufferSize( 0 )
		, m_cbDataSize( 0 )
		, m_cbDataLeft( 0 )
		, m_nPropsRemaining( 0 )
	{
		m_cbhPropList.pList		= NULL;
		m_cbhCurrentProp.pb		= NULL;
		m_cbhCurrentPropName.pb	= NULL;

	} //*** CClusPropList()

	// Destructor
	~CClusPropList( void )
	{
		DeletePropList();

	} //*** ~CClusPropList()

	// Copy list into this list (like assignment operator)
	DWORD ScCopy( IN const PCLUSPROP_LIST pcplPropList, IN DWORD cbListSize );

	// Delete the property list buffer and cleanup support variables
	void DeletePropList( void )
	{
		delete [] m_cbhPropList.pb;
		m_cbhPropList.pb = NULL;
		m_cbhCurrentProp.pb = NULL;
		m_cbhCurrentPropName.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
		m_cbDataLeft = 0;

	} //*** DeletePropList()

protected:
	//
	// Attributes.
	//

	BOOL					m_bAlwaysAddProp;		// Indicate if properties should be added even if not different.
	CLUSPROP_BUFFER_HELPER	m_cbhPropList;			// Pointer to the beginning of the list.
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentProp;		// Pointer to the current property.
	DWORD					m_cbBufferSize;			// Allocated size of the buffer.
	DWORD					m_cbDataSize;			// Amount of data in the buffer.
	DWORD					m_cbDataLeft;			// Amount of data left in buffer after current value.

private:
	CLUSPROP_BUFFER_HELPER	m_cbhCurrentPropName;	// Pointer to the current name for parsing
	DWORD					m_nPropsRemaining;		// Used by BMoveToNextProperty() to track end of list.
	CClusPropValueList		m_pvlValues;			// Helper class for value list of current property.

public:
	//
	// Accessor methods.
	//

	// Access the values of the current property
	const CClusPropValueList & RPvlPropertyValue( void )
	{
		return m_pvlValues;

	} //*** RPvlPropertyValue()

	// Access the property list
	operator PCLUSPROP_LIST( void ) const
	{
		return m_cbhPropList.pList;

	} //*** operator PCLUSPROP_LIST()

	// Access allocated size of the buffer
	DWORD CbBufferSize( void ) const
	{
		return m_cbBufferSize;

	} //*** CbBufferSize()

	// Access the name of the current property
	LPCWSTR PszCurrentPropertyName( void ) const
	{
		return m_cbhCurrentPropName.pName->sz;

	} //*** PszCurrentPropertyName()

	// Access the current property name as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentPropertyName( void )
	{
		return m_cbhCurrentPropName;

	} //*** CbhCurrentPropertyName()

	// Access value list of the current property as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentValueList( void )
	{
		return m_pvlValues.CbhValueList();

	} //*** CbhCurrentValueList()

	// Access current value of the current property as a buffer helper
	const CLUSPROP_BUFFER_HELPER CbhCurrentValue( void )
	{
		return m_pvlValues.CbhCurrentValue();

	} //*** CbhCurrentValue()

	// Access the format of the current value of the current property
	CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
	{
		return m_pvlValues.CpfCurrentValueFormat();

	} //*** CpfCurrentValueFormat()

	// Access the format of the current format list syntax entry
	CLUSTER_PROPERTY_FORMAT CpfCurrentFormatListSyntax( void ) const
	{
		return m_pvlValues.CpfCurrentFormatListSyntax();

	} //*** CpfCurrentFormatListSyntax()

	// Access the type of the current value of the current property
	CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
	{
		return m_pvlValues.CptCurrentValueType();

	} //*** CptCurrentValueType()

	// Access the syntax of the current value of the current property
	CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
	{
		return m_pvlValues.CpsCurrentValueSyntax();

	} //*** CpsCurrentValueSyntax()

	// Access the length of the current value of the current property
	DWORD CbCurrentValueLength( void ) const
	{
		return m_pvlValues.CbCurrentValueLength();

	} //*** CbCurrentValueLength()

	PCLUSPROP_LIST Plist( void )
	{
		return m_cbhPropList.pList;

	} //*** Plist()

	const CLUSPROP_BUFFER_HELPER CbhPropList( void ) const
	{
		return m_cbhPropList;

	} //*** CbhPropList()

	PBYTE PbPropList( void ) const
	{
		return m_cbhPropList.pb;

	} //*** PbPropList()

	DWORD CbPropList( void ) const
	{
		return m_cbDataSize + sizeof( CLUSPROP_SYNTAX ); /*endmark*/

	} //*** CbPropList()

	// Access amount of data left in buffer after current value
	DWORD CbDataLeft( void ) const
	{
		return m_cbDataLeft;

	} //*** CbDataLeft()

	DWORD Cprops( void ) const
	{
		if ( m_cbhPropList.pb == NULL )
		{
			return 0;
		} // if:  no buffer yet

		return m_cbhPropList.pList->nPropertyCount;

	} //*** Cprops()

public:
	//
	// Parsing methods.
	//

	// Initialize the size after getting properties from an external source
	void InitSize( IN DWORD cbSize )
	{
		ASSERT( m_cbhPropList.pb != NULL );
		ASSERT( m_cbBufferSize > 0 );

		m_cbDataSize = cbSize;
		m_cbDataLeft = cbSize;

	} //*** InitSize()

	// Move to the first property in the list
	DWORD ScMoveToFirstProperty( void );

	// Move the property after the current one in the list
	DWORD ScMoveToNextProperty( void );

	// Move to a property by specifying its name
	DWORD ScMoveToPropertyByName( IN LPCWSTR pwszPropName );

	// Move to the first value in the current property
	DWORD ScMoveToFirstPropertyValue( void )
	{
		return m_pvlValues.ScMoveToFirstValue();

	} //*** ScMoveToFirstPropertyValue()

	// Move the the value after the current on in the current property
	DWORD ScMoveToNextPropertyValue( void )
	{
		return m_pvlValues.ScMoveToNextValue();

	} //*** ScMoveToNextPropertyValue()

	// Query whether we are at the last property in the list or not
	DWORD ScCheckIfAtLastProperty( void ) const
	{
		DWORD _sc;

		if ( m_nPropsRemaining <= 1 )
		{
			_sc = ERROR_NO_MORE_ITEMS;
		} // if:  at the last property
		else
		{
			_sc = ERROR_SUCCESS;
		} // else:  not at the last property

		return _sc;

	} //*** ScCheckIfAtLastProperty()

	// Query whether the list is empty or not
	BOOL BIsListEmpty( void ) const
	{
		ASSERT( m_cbhPropList.pb != NULL );
		ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

		return m_cbhPropList.pList->nPropertyCount == 0;

	} //*** BIsListEmpty()

public:
	//
	// Methods for building a property list.
	//

	// Allocate a property list
	DWORD ScAllocPropList( IN DWORD cbMinimum );

	void ClearPropList( void )
	{
		m_cbDataSize = 0;
		m_cbDataLeft = 0;

		if ( m_cbBufferSize != 0 )
		{
			ZeroMemory( m_cbhPropList.pb, m_cbBufferSize );
			m_cbhCurrentProp.pb = m_cbhPropList.pb + sizeof( m_cbhPropList.pList->nPropertyCount );
			m_cbhCurrentPropName = m_cbhCurrentProp;
		} // if:  buffer already allocated

	} //*** ClearPropList()

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddMultiSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

	DWORD ScAddProp( IN LPCWSTR pwszName, IN DWORD nValue, IN DWORD nPrevValue );

#if CLUSAPI_VERSION >= 0x0500

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LONG nValue, IN LONG nPrevValue );

#endif // CLUSAPI_VERSION >= 0x0500

	DWORD ScAddProp( IN LPCWSTR pwszName, IN ULONGLONG ullValue, IN ULONGLONG ullPrevValue );

	DWORD ScSetPropToDefault( IN LPCWSTR pwszName, IN CLUSTER_PROPERTY_FORMAT propfmt );

	DWORD ScAddProp(
			IN LPCWSTR		pwszName,
			IN const PBYTE	pbValue,
			IN DWORD		cbValue,
			IN const PBYTE	pbPrevValue,
			IN DWORD		cbPrevValue
			);

	DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
	{
		return ScAddProp( pwszName, pwszValue, NULL );

	} //*** ScAddProp()

	DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
	{
		return ScAddExpandSzProp( pwszName, pwszValue, NULL );

	} //*** ScAddExpandSzProp()

public:
	//
	// Get Property methods.
	//

	DWORD ScGetNodeProperties(
						IN HNODE	hNode,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetGroupProperties(
						IN HGROUP	hGroup,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetResourceProperties(
						IN HRESOURCE	hResource,
						IN DWORD		dwControlCode,
						IN HNODE		hHostNode		= NULL,
						IN LPVOID		lpInBuffer		= NULL,
						IN DWORD		cbInBufferSize	= 0
						);

	DWORD ScGetResourceTypeProperties(
						IN HCLUSTER	hCluster,
						IN LPCWSTR	pwszResTypeName,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetNetworkProperties(
						IN HNETWORK	hNetwork,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

	DWORD ScGetNetInterfaceProperties(
						IN HNETINTERFACE	hNetInterface,
						IN DWORD			dwControlCode,
						IN HNODE			hHostNode		= NULL,
						IN LPVOID			lpInBuffer		= NULL,
						IN DWORD			cbInBufferSize	= 0
						);

#ifdef CLUSAPI_VERSION 

	DWORD ScGetClusterProperties(
						IN HCLUSTER	hCluster,
						IN DWORD	dwControlCode,
						IN HNODE	hHostNode		= NULL,
						IN LPVOID	lpInBuffer		= NULL,
						IN DWORD	cbInBufferSize	= 0
						);

#endif // CLUSAPI_VERSION >= 0x0500

// Implementation
protected:
	void CopyProp(
			IN PCLUSPROP_SZ				pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyExpandSzProp(
			IN PCLUSPROP_SZ				pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyMultiSzProp(
			IN PCLUSPROP_MULTI_SZ		pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LPCWSTR					psz,
			IN size_t					cbsz = 0
			);

	void CopyProp(
			IN PCLUSPROP_DWORD			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN DWORD					nValue
			);

#if CLUSAPI_VERSION >= 0x0500

	void CopyProp(
			IN PCLUSPROP_LONG			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN LONG						nValue
			);

#endif // CLUSAPI_VERSION >= 0x0500

	void CopyProp(
			OUT	PCLUSPROP_ULARGE_INTEGER	pprop,
			IN	CLUSTER_PROPERTY_TYPE		proptype,
			IN	ULONGLONG					nValue
			);

	void CopyProp(
			IN PCLUSPROP_BINARY			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN const PBYTE				pb,
			IN size_t					cb
			);

	void CopyEmptyProp(
			IN PCLUSPROP_VALUE			pprop,
			IN CLUSTER_PROPERTY_TYPE	proptype,
			IN CLUSTER_PROPERTY_FORMAT	propfmt
			);

}; //*** class CClusPropList


/////////////////////////////////////////////////////////////////////////////

#pragma warning( default : 4201 )

/////////////////////////////////////////////////////////////////////////////

#endif // _PROPLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\provfactory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvFactory.cpp
//
//  Description:
//      Implementation of CProvFactory class.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ProvFactory.h"

//****************************************************************************
//
//  CProvFactory
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::QueryInterface(
//      REFIID  riidIn,
//      PPVOID  ppvOut
//      )
//
//  Description:
//      Query for an interface supported by this COM object.
//
//  Arguments:
//      riidIn      -- Interface ID.
//      ppvOut      -- Receives the interface pointer.
//
//  Return Values:
//      NOERROR
//      E_NOINTERFACE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::QueryInterface(
    REFIID  riidIn,
    PPVOID  ppvOut
    )
{
    *ppvOut = NULL;

    if ( IID_IUnknown == riidIn || IID_IClassFactory == riidIn )
    {
        *ppvOut = this;
    }

    if ( NULL != *ppvOut )
    {
        ( (LPUNKNOWN) *ppvOut )->AddRef( );
        return NOERROR;
    }

    return E_NOINTERFACE;

} //*** CProvFactory::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProvFactory::AddRef ( void )
//
//  Description:
//      Increment the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New count of references.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProvFactory::AddRef ( void )
{
    //return ++m_cRef;
    return InterlockedIncrement( (long *) &m_cRef );

} //*** CProvFactory::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProvFactory::Release( void )
//
//  Description:
//      Decrement the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New count of references.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProvFactory::Release( void )
{
    ULONG nNewCount = InterlockedDecrement( (long *) & m_cRef );
    if ( 0L == nNewCount )
    {
        delete this;
    } // if: 0L == nNewCount
    
    return nNewCount;

} //*** CProvFactory::Release()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::CreateInstance(
//      LPUNKNOWN   pUnkOuterIn,
//      REFIID      riidIn,
//      PPVOID      ppvObjOut
//      )
//
//  Description:
//      Instantiates a Locator object returning an interface pointer.
//
//  Arguments:
//      pUnkOuterIn
//          LPUNKNOWN to the controlling IUnknown if we are being used in
//          an aggregation.
//
//      riidIn
//          REFIID identifying the interface the caller desires to have
//          for the new object.
//
//      ppvObjOut
//          PPVOID in which to store the desired interface pointer for the
//          new object.
//
//  Return Values:
//      NOERROR
//      E_OUTOFMEMORY
//      E_NOINTERFACE
//      CLASS_E_NOAGGREGATION
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::CreateInstance(
    LPUNKNOWN   pUnkOuterIn,
    REFIID      riidIn,
    PPVOID      ppvObjOut
    )
{
    IUnknown *  pObj = NULL;
    HRESULT     hr;

    *ppvObjOut = NULL;

    // This object doesnt support aggregation.

    if ( NULL != pUnkOuterIn )
    {
        return CLASS_E_NOAGGREGATION;
    } /// if: not pUnkOuter

    
    hr = m_pFactoryData->pFnCreateInstance(
                NULL,
                reinterpret_cast< VOID ** >( &pObj )
                );

    if ( NULL == pObj )
    {
        return E_OUTOFMEMORY;
    } // if: pObj is NULL

    hr = pObj->QueryInterface( riidIn, ppvObjOut );

    //Kill the object if initial creation or Init failed.

    if ( FAILED( hr ) )
    {
        delete pObj;
    } // if: failed

    return hr;

} //*** CProvFactory::CreateInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::LockServer(
//      BOOL    fLockIn
//      )
//
//  Description:
//      Increments or decrements the lock count of the DLL.  If the lock
//      count goes to zero and there are no objects, the DLL is allowed to
//      unload.  See DllCanUnloadNow.
//
//  Arguments:
//      fLockIn
//          BOOL specifying whether to increment or decrement the lock count.
//
//  Return Values:
//      NOERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::LockServer(
    BOOL    fLockIn
    )
{
    if ( fLockIn )
    {
        InterlockedIncrement( & g_cLock );
    } /// if: lock
    else
    {
        InterlockedDecrement( & g_cLock );
    } /// else:

    return NOERROR;

} //*** CProvFactory::LockServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\provbase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CProvBase.cpp
//
//  Description:    
//      Implementation of CProvBase class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ProvBase.h"

//****************************************************************************
//
//  CProvBase
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProvBase::CProvBase(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase::CProvBase(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : m_pNamespace( NULL )
    , m_pClass( NULL )
{
    SCODE   sc;

    m_pNamespace = pNamespaceIn;
    m_bstrClassName = pwszNameIn;

    sc = m_pNamespace->GetObject(
            m_bstrClassName,
            0,
            0,
            &m_pClass,
            NULL
            );

    // failed to construct object,
    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

} //*** CProvBase::CProvBase()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProvBase::~CProvBase( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase::~CProvBase( void )
{
    if ( m_pClass != NULL )
    {
        m_pClass->Release();
    }

} //*** CProvBase::~CProvBase()

//****************************************************************************
//
//  CProvBaseAssociation
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CProvBaseAssociation::GetTypeName(
//      _bstr_t &   rbstrClassNameOut,
//      _bstr_t     bstrPropertyIn
//      )
//
//  Description:
//      Get the type of a property.
//
//  Arguments:
//      rbstrClassNameOut   -- Receives type name string.
//      bstrPropertyIn      -- Property name.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CProvBaseAssociation::GetTypeName(
    _bstr_t &   rbstrClassNameOut,
    _bstr_t     bstrPropertyIn
    )
{
    CError              er;
    IWbemQualifierSet * pQualifier;
    _variant_t          var;
    _bstr_t             bstrTemp;
    LPCWSTR             pwsz, pwsz1;

    er = m_pClass->GetPropertyQualifierSet(
        bstrPropertyIn,
        &pQualifier
        );
    
	if ( er != WBEM_S_NO_ERROR ) {
        return;
    }

    er = pQualifier->Get(
        PVD_WBEM_QUA_CIMTYPE,
        0,
        &var,
        NULL
        );

    if ( er != WBEM_S_NO_ERROR ) {
        goto ERROR_EXIT;
    }


    bstrTemp = var;
	pwsz1 = bstrTemp;
	if (pwsz1==NULL)
		goto ERROR_EXIT;
    pwsz = wcschr( bstrTemp, L':' );
    if ( pwsz != NULL)
    {
        pwsz++;
        rbstrClassNameOut = pwsz;
    }
ERROR_EXIT:
    pQualifier->Release();
    return;

} //*** CProvBaseAssociation::GetTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wml\inc\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    union {
        struct {
            ULONG EnableFlags;
            ULONG EnableLevel;
        };
        UINT64 EnableFlags64;
    };
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Length, Address
    );

#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\provfactory.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvFactory.h
//
//  Implementation File:
//      ProvFactory.cpp
//
//  Description:
//      Definition of the CProvFactory class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "InstanceProv.h"

typedef HRESULT ( * PFNCREATEINSTANCE )(
    IUnknown *,
    VOID **
    );

struct FactoryData
{
    const CLSID *       m_pCLSID;
    PFNCREATEINSTANCE   pFnCreateInstance;
    LPCWSTR             m_pwszRegistryName;

}; //*** struct FactoryData

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvFactory
//
//  Description:
//      Handle class creation
//
//--
/////////////////////////////////////////////////////////////////////////////
class CProvFactory
    : public IClassFactory
{
protected:
    ULONG           m_cRef;
    FactoryData *   m_pFactoryData;

public:
    CProvFactory( FactoryData *   pFactoryDataIn )
        : m_pFactoryData( pFactoryDataIn )
        , m_cRef( 0 )
    {
    }

    virtual ~CProvFactory( void )
    {
    }

    STDMETHODIMP            QueryInterface( REFIID riidIn, PPVOID ppvOut );
    STDMETHODIMP_( ULONG )  AddRef( void );
    STDMETHODIMP_( ULONG )  Release( void );

    //IClassFactory members
    STDMETHODIMP CreateInstance(
        LPUNKNOWN   pUnknownOuterIn,
        REFIID      riidIn,
        PPVOID      ppvObjOut
        );
    STDMETHODIMP LockServer( BOOL fLockIn );

}; //*** class CProvFactory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wml\inc\wmltypes.inc ===
//#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType)

#define WMILIB_SIMPLE_TYPE(_TypeName, _EquivType, _FmtStr, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, FormatSimple, _MofStr, WMILIB_ALIGNEDCOPY)
   
#define WMILIB_COMPLX_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ALIGNEDCOPY)

#define WMILIB_STRING_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ASIS)

WMILIB_SIMPLE_TYPE(UBYTE, char, "u",          ItemByte)
WMILIB_SIMPLE_TYPE(SBYTE, char, "d",          ItemSByte)
WMILIB_SIMPLE_TYPE(XBYTE, char, "X",          ItemXByte)
WMILIB_SIMPLE_TYPE(OBYTE, char, "02o",        ItemOByte)
WMILIB_COMPLX_TYPE(BBYTE, char, FormatBinary, ItemXByte)

WMILIB_SIMPLE_TYPE(USHORT, short, "u",          ItemUShort)
WMILIB_SIMPLE_TYPE(SSHORT, short, "d",          ItemShort)
WMILIB_SIMPLE_TYPE(XSHORT, short, "X",          ItemXShort)
WMILIB_SIMPLE_TYPE(OSHORT, short, "o",          ItemOShort)
WMILIB_COMPLX_TYPE(BSHORT, short, FormatBinary, ItemXShort)

WMILIB_SIMPLE_TYPE(UINT, int, "u",          ItemULong)
WMILIB_SIMPLE_TYPE(SINT, int, "s",          ItemLong)
WMILIB_SIMPLE_TYPE(XINT, int, "X",          ItemULongX)
WMILIB_SIMPLE_TYPE(OINT, int, "o",          ItemULong)
WMILIB_COMPLX_TYPE(BINT, int, FormatBinary, ItemULong)

WMILIB_SIMPLE_TYPE(HANDLE, HANDLE, "x",     ItemULong)

WMILIB_SIMPLE_TYPE(ULONGLONG, _int64, "u", ItemULongLong)
WMILIB_SIMPLE_TYPE(SLONGLONG, _int64, "s", ItemLongLong)
WMILIB_SIMPLE_TYPE(XLONGLONG, _int64, "X", ItemULongLongX)
WMILIB_SIMPLE_TYPE(OLONGLONG, _int64, "o", ItemULongLong)

WMILIB_SIMPLE_TYPE(PTR,        void*, "x", ItemXPointer)

WMILIB_SIMPLE_TYPE(BOOLEAN, char, "u", ItemListByte (FALSE,TRUE) )

WMILIB_SIMPLE_TYPE(UCHAR, CHAR,  "c", ItemUChar)
WMILIB_SIMPLE_TYPE(ACHAR, CHAR,  "c", ItemChar)
WMILIB_SIMPLE_TYPE(WCHAR, WCHAR, "c", ItemShortSign)

WMILIB_STRING_TYPE(ASTR, WMILIBTYPE_STRING, FormatMisc, ItemString)
WMILIB_STRING_TYPE(WSTR, WMILIBTYPE_STRING, FormatMisc, ItemWString)
WMILIB_STRING_TYPE(USTR, WMILIBTYPE_STRING, FormatMisc, ItemPString)

WMILIB_COMPLX_TYPE(DATE,     LARGE_INTEGER, FormatMisc, ItemDate)
WMILIB_COMPLX_TYPE(TIMENT,   LARGE_INTEGER, FormatMisc, ItemTime)
WMILIB_COMPLX_TYPE(DATETIME, LARGE_INTEGER, FormatMisc, ItemDateTime)
WMILIB_COMPLX_TYPE(MILLISEC, LARGE_INTEGER, FormatMisc, ItemMillisec)
WMILIB_COMPLX_TYPE(ALETTER,  CHAR,          FormatMisc, ItemLetter)
WMILIB_COMPLX_TYPE(WLETTER,  WCHAR,         FormatMisc, ItemWLetter)
WMILIB_COMPLX_TYPE(GUID,     GUID,          FormatMisc, ItemGuid)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wml\inc\wmlmacro.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlmacro.h

Abstract:

    This file defines macro for an easy wmi tracing.

Author:

    gorn

Revision History:

--*/
#ifndef WMLMACRO_H
#define WMLMACRO_H 1

typedef struct {char x[418957];} WMILIBTYPE_STRING;

#undef  WMILIB_TYPEDEF
#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType) \
    typedef _EquivType WMILIBTYPE_ ## _TypeName ;
#include "wmltypes.inc"

typedef union _WMLLOCALSTRUCT {
    UCHAR    uchar;
    USHORT   ushort;
    ULONG    uint;
    WCHAR    wchar;
    LONGLONG longlong;
} WMLLOCALSTRUCT;

#define WMLLOCAL WMLLOCALSTRUCT _wmllocal


#define WMILIB_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WMILIB_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WMILIB_CHECKED_ZERO( _Value, _Type) )

#define WMILIB_LOGPAIR(_a, _b) (_a),(_b),

#define WMILIB_LOGARGVALTYPE(_value, _type) \
            WMILIB_LOGPAIR(WMILIB_CHECKED_SIZEOF(_value, _type), &(_value) )

#define LOG(_TypeName, _Value)                         \
    WMILIB_LOGARGVALTYPE( _Value, WMILIBTYPE_ ## _TypeName)

#define LOGASTR(_value) \
    WMILIB_LOGPAIR( strlen(_value) + WMILIB_CHECKED_SIZEOF((_value)[0],CHAR), _value )

#define LOGWSTR(_value) \
    WMILIB_LOGPAIR( wcslen(_value) * sizeof(WCHAR) + WMILIB_CHECKED_SIZEOF((_value)[0],WCHAR), _value)

#define LOGCSTR(_x) \
    WMILIB_LOGPAIR( sizeof((_x).Length) + WMILIB_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGUSTR(_x)                                                            \
    WMILIB_LOGPAIR( sizeof((_x).Length)                                        \
                    + WMILIB_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )          \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(CHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], CHAR), _x ) 

#define LOGWCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )           \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(WCHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], WCHAR), _x ) 

#define LOGTIME(_Value)    LOG(TIMENT,  _Value)
#define LOGPTR(_Value)     LOG(PTR,     _Value)
#define LOGHANDLE(_Value)  LOG(HANDLE,  _Value)
#define LOGSTATUS(_Value)  LOG(XINT,    _Value)
#define LOGBYTE(_Value)    LOG(UBYTE,   _Value)
#define LOGULONG(_Value)   LOG(UINT,    _Value)
#define LOGULONGLONG(_Value)   LOG(ULONGLONG,    _Value)
#define LOGXLONG(_Value)   LOG(XINT,    _Value)
#define LOGXSHORT(_Value)  LOG(XSHORT,  _Value)
#define LOGUSHORT(_Value)  LOG(USHORT,  _Value)
#define LOGUCHAR(_Value)   LOG(UCHAR,   _Value)
#define LOGUBYTE(_Value)   LOG(UCHAR,   _Value)
#define LOGIRQL(_Value)    LOG(UCHAR,   _Value)
#define LOGBOOL(_Value)    LOG(BOOL,    _Value)
#define LOGBOOLEAN(_Value) LOG(BOOLEAN, _Value)
#define LOGARSTR(_Value)   LOGASTR(_Value)
#define LOGPNPMN(_Value)   LOG(UCHAR,   _Value)
#define LOGIOCTL(_Value)   LOG(ULONG,   _Value)
#define LOGGUID(_Val)      LOG(GUID, _Val)
#define LOGSLONG(_Val)     LOG(SINT, _Val)

// These better be defined elsewhere
//#define WML_FLAGS(_Val)  ( (ULONG) (_Val) )
//#define WML_STREAM(_Val) ( (ULONG) ((_Val) >> 32) )

#define WML_CONTROL(_prefix, _flags) \
            ( _prefix ## ControlGuids[ WML_STREAM(_flags) ] )
            
#define WML_TRACEGUID(_prefix, _id) \
            ( _prefix ## TraceGuids[ WML_GUID(_id) ] )
            
#define WML_ENABLED(_prefix, _flags) \
            ( WML_CONTROL(_prefix, _flags).EnableFlags & WML_FLAGS(_flags) )
            
#define WML_LOG(_prefix, _flags, _id, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _flags) ) { \
            WmlTrace( WML_ID(_id), \
                     &WML_TRACEGUID(_prefix, _id) , \
                      WML_CONTROL(_prefix, _flags).LoggerHandle, _arg); \
        } \
    } while (0)            


#endif // WMLMACRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\safehandle.h ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      SafeHandle.h
//
//  Description:
//      Implementation of safe handle and pointer classes.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ObjectPath.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CError;
template< class T > class SafePtr;
class CWstrBuf;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterApi
//
//  Description:
//      Wrap class for cluster Api
//
//--
//////////////////////////////////////////////////////////////////////////////
class CError
{
public:
    CError( void )
        : m_hr( 0 )
    {
    }

    inline CError & operator=( DWORD dw )
    {
        if ( dw != ERROR_SUCCESS ) 
        {
            throw CProvException ( dw );
        }
        m_hr = HRESULT_FROM_WIN32( dw );
        return *this;
    }

    inline CError & operator=( HRESULT hr )
    {
        if ( FAILED ( hr ) )
        {
            throw CProvException ( hr );
        }
        m_hr = hr;
        return *this;
    }

    operator DWORD( void )
    {
        return HRESULT_CODE( m_hr );
    }

protected:
    HRESULT m_hr;

}; //*** CError

//////////////////////////////////////////////////////////////////////////////
//++
//
//  template< class T >
//  class SafePtr
//
//  Description:
//      Safe handle/pointer class.
//
//  Template Arguments:
//      T       -- Type of handle or pointer.
//
//--
//////////////////////////////////////////////////////////////////////////////
template< class T >
class SafePtr
{
public:
    SafePtr( void )
        : m_handle( NULL )
    {
    }

    SafePtr( T h )
        : m_handle( h )
    {
        h = NULL;
    }
    
    virtual ~SafePtr( void )
    {
        deleteHandle( m_handle );
    }

    T operator&( void )
    {
        return m_handle;
    }
    
    BOOL BIsNULL( void )
    {
        return m_handle == NULL;
    }

    operator T( void )
    {
        return m_handle;
    }
    
    operator void * ( void )
    { 
        return static_cast< void * >( m_handle );
    }

    SafePtr< T > & operator=( T tRhs )
    {
        if ( tRhs == NULL )
        {
            throw CProvException ( GetLastError() );
        }
         
        if ( m_handle != NULL )
        {
            deleteHandle( m_handle );
        }
        m_handle = tRhs;
        tRhs = NULL;
        return *this;
    }

protected:

    T m_handle;

    void deleteHandle( HCLUSTER hCluster )
    {
        if ( hCluster && ( CloseCluster( hCluster ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HNODE hNode ) 
    {
        if ( hNode && ( CloseClusterNode( hNode ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HCLUSENUM hEnum ) 
    {
        if ( hEnum && ( ClusterCloseEnum( hEnum ) != ERROR_SUCCESS ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HRESOURCE hRes )
    {
        if ( hRes && ( CloseClusterResource( hRes ) == FALSE ))
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HGROUP hGroup )
    {
        if ( hGroup && ( CloseClusterGroup( hGroup ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HNETWORK hNetwork )
    {
        if ( hNetwork && ( CloseClusterNetwork( hNetwork ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HNETINTERFACE hNetInterface )
    {
        if ( hNetInterface && ( CloseClusterNetInterface( hNetInterface ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HRESENUM hResEnum )
    {
        DWORD   dwReturn;
        if ( hResEnum  )
        {
            dwReturn = ClusterResourceCloseEnum( hResEnum ) ;
            if ( dwReturn != ERROR_SUCCESS )
            {
                throw CProvException( dwReturn );
            }
        }
    }

    void deleteHandle( HGROUPENUM hGroupEnum )
    {   
        DWORD   dwReturn;
        if ( hGroupEnum )
        {
            dwReturn = ClusterGroupCloseEnum( hGroupEnum );
            if ( dwReturn != ERROR_SUCCESS )
            {
                throw CProvException( dwReturn );
            }
        }
    }

    void deleteHandle( HCHANGE hChange )
    {
        BOOL fReturn;
        if ( hChange )
        {
            fReturn = CloseClusterNotifyPort( hChange );
            if ( ! fReturn )
            {
                throw CProvException( GetLastError() );
            }
        }
    }

private:
    SafePtr( SafePtr< T > & cT )
    {
    }

}; //*** class SafePtr

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWstrBuf
//
//  Description:
//      Wrap class for Unicode strings.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWstrBuf
{
public:
     
    CWstrBuf( void )
        : m_pwsz( NULL )
    {
    }

    ~CWstrBuf( void )
    {
        delete [] m_pwsz;
    };

    void SetSize( DWORD dwSize )
    {
        delete [] m_pwsz;
        m_pwsz = new WCHAR[ sizeof( WCHAR ) * dwSize ];
        if ( m_pwsz == NULL )
        {
            throw WBEM_E_OUT_OF_MEMORY;
        } else {
            m_pwsz[0] = UNICODE_NULL;
        }
    }

    operator WCHAR*( void )
    {
        return m_pwsz;
    }

    void Empty( VOID )
    {
        m_pwsz[0] = UNICODE_NULL;
    }

protected:

    LPWSTR  m_pwsz;

}; //*** class CWstrBuf

typedef SafePtr< HRESOURCE >    SAFERESOURCE;
typedef SafePtr< HGROUP >       SAFEGROUP;
typedef SafePtr< HCLUSENUM >    SAFECLUSENUM;
typedef SafePtr< HNODE >        SAFENODE;
typedef SafePtr< HCLUSTER >     SAFECLUSTER;
typedef SafePtr< HNETWORK >     SAFENETWORK;
typedef SafePtr< HNETINTERFACE> SAFENETINTERFACE;
typedef SafePtr< HRESENUM >     SAFERESENUM;
typedef SafePtr< HGROUPENUM >   SAFEGROUPENUM;
typedef SafePtr< HCHANGE >      SAFECHANGE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wml\inc\wmlum.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlum.h

Abstract:

    User mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved


--*/
#ifndef WMLUM_H
#define WMLUM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WMILIB_REG_STRUCT
{
    TRACEHANDLE LoggerHandle;
    ULONG EnableFlags; 
    ULONG EnableLevel;

    struct _WMILIB_REG_STRUCT* Next;
    TRACEHANDLE RegistrationHandle;
} WMILIB_REG_STRUCT, *PWMILIB_REG_STRUCT;

typedef PWMILIB_REG_STRUCT WMILIB_REG_HANDLE;

typedef void (*WMILIBPRINTFUNC)(UINT Level, PCHAR String);

ULONG
WmlInitialize(
    IN LPWSTR ProductName, 
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WMILIB_REG_STRUCT 
    );
    
VOID
WmlUninitialize(
    IN WMILIB_REG_HANDLE
    );

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

typedef 
ULONG
(*PWML_INITIALIZE)(
    IN LPWSTR ProductName, 
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*, 
    ...
    );

typedef 
VOID 
(*PWML_UNINITIALIZE)(
    IN WMILIB_REG_HANDLE);

typedef 
ULONG
(*PWML_TRACE)(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... 
    );

typedef 
struct _WML_DATA {

    PWML_TRACE        Trace;
    PWML_INITIALIZE   Initialize;
    PWML_UNINITIALIZE Uninitialize;
    
    WMILIB_REG_HANDLE WmiRegHandle;
    HINSTANCE         WmlDllInstance;
    
} WML_DATA;


#define LOADWML(status, wml) \
    do \
    { \
        HINSTANCE hInst = LoadLibraryW(L"wmlum.dll"); \
        (wml).WmlDllInstance = hInst; \
        if (!hInst) { \
            status = GetLastError(); \
        } else { \
            (wml).Trace        =        (PWML_TRACE) GetProcAddress(hInst, "WmlTrace"); \
            (wml).Initialize   =   (PWML_INITIALIZE) GetProcAddress(hInst, "WmlInitialize"); \
            (wml).Uninitialize = (PWML_UNINITIALIZE) GetProcAddress(hInst, "WmlUninitialize"); \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
        } \
    } \
    while(0)

#define UNLOADWML(wml) \
    do \
    { \
        if ( (wml).Uninitialize ) { \
            (wml).Uninitialize( (wml).WmiRegHandle ); \
        } \
        if ( (wml).WmlDllInstance ) { \
            FreeLibrary( (wml).WmlDllInstance ); \
        } \
        RtlZeroMemory( &(wml) , sizeof(WML_DATA) ); \
    } \
    while(0)  

#ifdef __cplusplus
};
#endif

#endif // WMLUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wmiprovider\util.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Util.cpp
//
//  Description:
//      Implementation of utility class and functions
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Cluster.h"
#include "ClusterResource.h"
#include "ClusterNode.h"
#include "ClusterGroup.h"
#include "ClusterNodeRes.h"
#include "ClusterResourceType.h"

//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////

// CLUSTER
const WCHAR * const PVD_CLASS_CLUSTER               = L"MSCluster_Cluster";
const WCHAR * const PVD_CLASS_CLUSTERTONETWORKS     = L"MSCluster_ClusterToNetworks";
const WCHAR * const PVD_CLASS_CLUSTERTONETINTERFACE = L"MSCluster_ClusterToNetworkInterface";
const WCHAR * const PVD_CLASS_CLUSTERTONODE         = L"MSCluster_ClusterToNode";
const WCHAR * const PVD_CLASS_CLUSTERTOQUORUMRES    = L"MSCluster_ClusterToQuorumResource";
const WCHAR * const PVD_CLASS_CLUSTERTORES          = L"MSCluster_ClusterToResource";
const WCHAR * const PVD_CLASS_CLUSTERTORESTYPE      = L"MSCluster_ClusterToResourceType";
const WCHAR * const PVD_CLASS_CLUSTERTOGROUP        = L"MSCluster_ClusterToGroup";

const WCHAR * const PVD_PROP_CLUSTER_NAME               = L"Name";
const WCHAR * const PVD_PROP_CLUSTER_SECURITY           = L"Security";
const WCHAR * const PVD_PROP_CLUSTER_SECURITYDESCRIPTOR = L"Security_Descriptor";
const WCHAR * const PVD_PROP_CLUSTER_GROUPADMIN         = L"GroupAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_NODEADMIN          = L"NodeAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_RESADMIN           = L"ResourceAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_RESTYPEADMIN       = L"ResourceTypeAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_NETWORKADMIN       = L"NetworkAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_NETINTFACEADMIN    = L"NetworkInterfaceAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_FILE               = L"MaintenanceFile";
const WCHAR * const PVD_PROP_CLUSTER_LOGSIZE            = L"QuorumLogFileSize";
const WCHAR * const PVD_PROP_CLUSTER_NETWORK            = L"NetworkPriorities";

const WCHAR * const CLUS_CLUS_GROUPADMIN        = L"Groups\\AdminExtensions";
const WCHAR * const CLUS_CLUS_NETWORKADMIN      = L"Networks\\AdminExtensions";
const WCHAR * const CLUS_CLUS_NETINTERFACEADMIN = L"NetworkInterfaces\\AdminExtensions";
const WCHAR * const CLUS_CLUS_NODEADMIN         = L"Nodes\\AdminExtensions";
const WCHAR * const CLUS_CLUS_RESADMIN          = L"Resources\\AdminExtensions";
const WCHAR * const CLUS_CLUS_RESTYPEADMIN      = L"ResourceTypes\\AdminExtensions";

const WCHAR * const PVD_MTH_CLUSTER_RENAME          = L"Rename";
const WCHAR * const PVD_MTH_CLUSTER_SETQUORUM       = L"SetQuorumResource";
const WCHAR * const PVD_MTH_CLUSTER_PARM_NEWNAME    = L"NewName";
const WCHAR * const PVD_MTH_CLUSTER_PARM_RESOURCE   = L"Resource";

// NODE
const WCHAR * const PVD_CLASS_NODE                  = L"MSCluster_Node";
const WCHAR * const PVD_CLASS_NODEACTIVEGROUP       = L"MSCluster_NodeActiveGroup";
const WCHAR * const PVD_CLASS_NODETONETINTERFACE    = L"MSCluster_NodeToNetworkInterface";
const WCHAR * const PVD_CLASS_NODEACTIVERES         = L"MSCluster_NodeActiveResource";

const WCHAR * const PVD_PROP_NODE_NAME = L"Name";

// RESOURCE
const WCHAR * const PVD_CLASS_RESOURCE          = L"MSCluster_Resource";
const WCHAR * const PVD_CLASS_RESDEPRES         = L"MSCluster_ResourceDepResource";
const WCHAR * const PVD_CLASS_RESRESOURCETYPE   = L"MSCluster_ResourceResourceType";

const WCHAR * const PVD_PROP_RES_NAME		= L"Name";
const WCHAR * const PVD_PROP_RES_STATE		= L"State";
const WCHAR * const PVD_PROP_RES_PRIVATE	= L"PrivateProperties";
const WCHAR * const PVD_PROP_RES_CHECKPOINTS = L"RegistryCheckpoints";
const WCHAR * const PVD_PROP_RES_CRYPTO_CHECKPOINTS = L"CryptoCheckpoints";
const WCHAR * const PVD_PROP_RES_CORE_RESOURCE = L"CoreResource";

const WCHAR * const PVD_MTH_RES_ONLINE              = L"BringOnline";
const WCHAR * const PVD_MTH_RES_OFFLINE             = L"TakeOffline";
const WCHAR * const PVD_MTH_RES_ADD_DEPENDENCY      = L"AddDependency";
const WCHAR * const PVD_MTH_RES_CHANGE_GROUP        = L"MoveToNewGroup";
const WCHAR * const PVD_MTH_RES_CREATE_RESOURCE     = L"CreateResource";
const WCHAR * const PVD_MTH_RES_FAIL_RESOURCE       = L"FailResource";
const WCHAR * const PVD_MTH_RES_REMOVE_DEPENDENCY   = L"RemoveDependency";
const WCHAR * const PVD_MTH_RES_RENAME              = L"Rename";
const WCHAR * const PVD_MTH_RES_DELETE              = L"Delete";
const WCHAR * const PVD_MTH_RES_ADD_REG_CHECKPOINT = L"AddRegistryCheckpoint";
const WCHAR * const PVD_MTH_RES_DEL_REG_CHECKPOINT = L"RemoveRegistryCheckpoint";
const WCHAR * const PVD_MTH_RES_ADD_CRYPTO_CHECKPOINT = L"AddCryptoCheckpoint";
const WCHAR * const PVD_MTH_RES_DEL_CRYPTO_CHECKPOINT = L"RemoveCryptoCheckpoint";
const WCHAR * const PVD_MTH_PARM_RESOURCE           = L"Resource";
const WCHAR * const PVD_MTH_PARM_GROUP              = L"Group";
const WCHAR * const PVD_MTH_PARM_NEWNAME            = L"NewName";
const WCHAR * const PVD_MTH_PARM_RES_NAME           = L"ResourceName";
const WCHAR * const PVD_MTH_PARM_RES_TYPE           = L"ResourceType";
const WCHAR * const PVD_MTH_PARM_SEP_MONITOR        = L"SeparateMonitor";
const WCHAR * const PVD_MTH_PARM_RES_CHECKPOINT_NAME = L"CheckpointName";

// Resource Type
const WCHAR * const PVD_CLASS_RESOURCETYPE  = L"MSCluster_ResourceType";
const WCHAR * const PVD_PROP_RESTYPE_NAME   = L"Name";
const WCHAR * const PVD_PROP_RESTYPE_QUORUM_CAPABLE = L"QuorumCapable";
const WCHAR * const PVD_PROP_RESTYPE_LOCALQUORUM_CAPABLE = L"LocalQuorumCapable";
const WCHAR * const PVD_PROP_RESTYPE_DELETE_REQUIRES_ALL_NODES = L"DeleteRequiresAllNodes";


// GROUP
const WCHAR * const PVD_CLASS_GROUP         = L"MSCluster_ResourceGroup";
const WCHAR * const PVD_CLASS_GROUPTORES    = L"MSCluster_ResourceGroupToResource";

const WCHAR * const PVD_PROP_GROUP_NAME = L"Name";
const WCHAR * const PVD_PROP_NODELIST   = L"PreferredNodeList";

const WCHAR * const PVD_MTH_GROUP_CREATEGROUP       = L"CreateGroup";
const WCHAR * const PVD_MTH_GROUP_TAKEOFFLINE       = L"TakeOffLine";
const WCHAR * const PVD_MTH_GROUP_BRINGONLINE       = L"BringOnLine";
const WCHAR * const PVD_MTH_GROUP_MOVETONEWNODE     = L"MoveToNewNode";
const WCHAR * const PVD_MTH_GROUP_DELETE            = L"Delete";
const WCHAR * const PVD_MTH_GROUP_RENAME            = L"Rename";
const WCHAR * const PVD_MTH_GROUP_PARM_GROUPNAME    = L"GroupName";
const WCHAR * const PVD_MTH_GROUP_PARM_NODENAME     = L"NodeName";
const WCHAR * const PVD_MTH_GROUP_PARM_NEWNAME      = L"NewName";


// NetworkInterface
const WCHAR * const PVD_CLASS_NETWORKSINTERFACE = L"MSCluster_NetworkInterface";

const WCHAR * const PVD_PROP_NETINTERFACE_DEVICEID      = L"DeviceId";
const WCHAR * const PVD_PROP_NETINTERFACE_SYSTEMNAME    = L"SystemName";
const WCHAR * const PVD_PROP_NETINTERFACE_STATE         = L"State";


// networks
const WCHAR * const PVD_CLASS_NETWORKS          = L"MSCluster_Networks";
const WCHAR * const PVD_CLASS_NETTONETINTERFACE = L"MSCluster_NetworkToNetworksInterface";

const WCHAR * const PVD_PROP_NETWORK_STATE = L"State";

const WCHAR * const PVD_MTH_NETWORK_RENAME          = L"Rename";
const WCHAR * const PVD_MTH_NETWORK_PARM_NEWNAME    = L"NewName";

// service
const WCHAR * const PVD_CLASS_SERVICES          = L"MSCluster_Service";
const WCHAR * const PVD_CLASS_HOSTEDSERVICES    = L"MSCluster_HostedService";

const WCHAR * const PVD_PROP_SERVICE_NAME       = L"Name";
const WCHAR * const PVD_PROP_SERVICE_SYSTEMNAME = L"SystemName";

const WCHAR * const PVD_MTH_SERVICE_PAUSE   = L"Pause";
const WCHAR * const PVD_MTH_SERVICE_RESUME  = L"Resume";

// event

const WCHAR * const PVD_CLASS_EVENT             = L"MSCluster_Event";
const WCHAR * const PVD_PROP_EVENT_NAME         = L"EventObjectName";
const WCHAR * const PVD_PROP_EVENT_PATH         = L"EventObjectPath";
const WCHAR * const PVD_PROP_EVENT_TYPE         = L"EventObjectType";
const WCHAR * const PVD_PROP_EVENT_TYPEMAJOR    = L"EventTypeMajor";
const WCHAR * const PVD_PROP_EVENT_TYPEMINOR    = L"EventTypeMinor";
const WCHAR * const PVD_PROP_EVENT_NEWSTATE     = L"EventNewState";
const WCHAR * const PVD_PROP_EVENT_NODE         = L"EventNode";
const WCHAR * const PVD_PROP_EVENT_GROUP        = L"EventGroup";


const WCHAR * const PVD_CLASS_EVENT_ADD                 = L"MSCluster_EventObjectAdd";
const WCHAR * const PVD_CLASS_EVENT_REMOVE              = L"MSCluster_EventObjectRemove";
const WCHAR * const PVD_CLASS_EVENT_STATECHANGE         = L"MSCluster_EventStateChange";
const WCHAR * const PVD_CLASS_EVENT_GROUPSTATECHANGE    = L"MSCluster_EventGroupStateChange";
const WCHAR * const PVD_CLASS_EVENT_RESOURCESTATECHANGE = L"MSCluster_EventResourceStateChange";
const WCHAR * const PVD_CLASS_EVENT_PROP                = L"MSCluster_EventPropertyChange";

const WCHAR * const PVD_CLASS_PROPERTY      = L"MSCluster_Property";

const WCHAR * const PVD_PROP_NAME           = L"Name";
const WCHAR * const PVD_PROP_STATE          = L"State";
const WCHAR * const PVD_PROP_GROUPCOMPONENT = L"GroupComponent";
const WCHAR * const PVD_PROP_PARTCOMPONENT  = L"PartComponent";
const WCHAR * const PVD_PROP_CHARACTERISTIC = L"characteristics";
const WCHAR * const PVD_PROP_FLAGS          = L"Flags";

//
// wbem
//
const WCHAR * const PVD_WBEM_EXTENDEDSTATUS     = L"__ExtendedStatus";
const WCHAR * const PVD_WBEM_DESCRIPTION        = L"Description";
const WCHAR * const PVD_WBEM_STATUSCODE         = L"StatusCode";
const WCHAR * const PVD_WBEM_STATUS             = L"Status";
const WCHAR * const PVD_WBEM_CLASS              = L"__CLASS";
const WCHAR * const PVD_WBEM_RELPATH            = L"__Relpath";
const WCHAR * const PVD_WBEM_PROP_ANTECEDENT    = L"Antecedent";
const WCHAR * const PVD_WBEM_PROP_DEPENDENT     = L"Dependent";
const WCHAR * const PVD_WBEM_PROP_DEVICEID      = L"DeviceId";
const WCHAR * const PVD_WBEM_QUA_DYNAMIC        = L"Dynamic";
const WCHAR * const PVD_WBEM_QUA_CIMTYPE        = L"CIMTYPE";

const WCHAR * const PVD_WBEM_QUA_PROV_VALUE = L"MS_CLUSTER_PROVIDER";
const WCHAR * const PVD_WBEM_QUA_PROV_NAME  = L"Provider";

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CreateClass(
//      const WCHAR *           pwszClassNameIn,
//      CWbemServices *         pNamespaceIn,
//      auto_ptr< CProvBase > & rNewClassInout
//      )
//
//  Description:
//      Create the specified class
//
//  Arguments:
//      pwszClassNameIn     -- Name of the class to create.
//      pNamespaceIn        -- WMI namespace
//      rNewClassInout      -- Receives the new class.
//
//  Return Values:
//      reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CreateClass(
    const WCHAR *           pwszClassNameIn,
    CWbemServices *         pNamespaceIn,
    auto_ptr< CProvBase > & rNewClassInout
    )
{
    CClassCreator & rcc = g_ClassMap[ pwszClassNameIn ];
    if ( rcc.m_pfnConstructor != NULL )
    {
        auto_ptr< CProvBase > pBase(
            rcc.m_pfnConstructor(
                rcc.m_pbstrClassName,
                pNamespaceIn,
                rcc.m_dwEnumType
                )
            );
            rNewClassInout = pBase;
    }
    else
    {
        throw CProvException( static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER ) );
    }

    return;

} //*** void CreateClass()

//****************************************************************************
//
//  PropMapEntryArray
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  SPropMapEntryArray::PwszLookup(
//      LPCWSTR     pwszIn
//      ) const
//
//  Description:
//      Lookup an entry in the array.
//
//  Arguments:
//      pwszIn      -- Name of entry to lookup.
//
//  Return Values:
//      Pointer to string entry in the array.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
SPropMapEntryArray::PwszLookup(
    LPCWSTR     pwszIn
    ) const
{
    UINT idx;

    for ( idx = 0; idx < m_dwSize; idx ++ )
    {
        if ( _wcsicmp( pwszIn, m_pArray[ idx ].clstName ) == 0 )
        {
            //
            // mofName is NULL for clstname not supported
            //
            return m_pArray[ idx ].mofName;
        }
    }

    //
    // mofname is the same as clstname if not found in the table
    //
    return pwszIn;

} //*** SPropMapEntry::PwszLookup()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  PwszSpaceReplace(
//      LPWSTR      pwszTrgInout,
//      LPCWSTR     pwszSrcIn,
//      WCHAR       wchArgIn
//      )
//
//  Description:
//      Replace spaces in a string with another character.
//      Ignores leading spaces.
//
//  Arguments:
//      pwszTrgInout    -- Target string.
//      pwszSrcIn       -- Source string.
//      wchArgIn        -- Character to replace spaces with.
//
//  Return Values:
//      Pointer to the target string.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPWSTR
PwszSpaceReplace(
    LPWSTR      pwszTrgInout,
    LPCWSTR     pwszSrcIn,
    WCHAR       wchArgIn
    )
{
    LPCWSTR pwsz = NULL;
    LPWSTR  pwszTrg = NULL;

    if ( ( pwszTrgInout == NULL ) || ( pwszSrcIn == NULL ) )
    {
        return NULL;
    }

    //
    // ignore leading space
    //
    for ( pwsz = pwszSrcIn ; *pwsz == L' '; pwsz++ )
    {
        // empty loop
    }
    pwszTrg = pwszTrgInout;
    for ( ; *pwsz != L'\0' ; pwsz++ )
    {
        if ( *pwsz == L' ' )
        {
            *pwszTrg++  = wchArgIn;
            for ( ; *pwsz == L' '; pwsz++ )
            {
                // empty loop
            }
            pwsz--;
        }
        else
        {
            *pwszTrg++  = *pwsz;
        }
    } // for: each character in the source string

    *pwszTrg = L'\0';
    return pwszTrgInout;

} //*** PwszSpaceReplace()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wml\km\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

	This code is a quick hack to enable WMI tracing in cluster drivers.
	It should eventually go away.

	WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

	WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <wmistr.h>
#include <evntrace.h>

#include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PWML_CONTROL_GUID_REG GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        ((minorFunction != IRP_MN_REGINFO) &&
         (WmiLibInfo->GuidCount == 0) || (WmiLibInfo->ControlGuids == NULL) ))
    {
        //
        // IRP is not for us so forward if there is a lower device object
        if (WmiLibInfo->LowerDeviceObject != NULL)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return(IoCallDriver(WmiLibInfo->LowerDeviceObject, Irp));
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if (minorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (WmlpFindGuid(WmiLibInfo->ControlGuids,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex) )
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PWML_CONTROL_GUID_REG guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG bufferNeeded;
            ULONG i;
            UNICODE_STRING nullRegistryPath;

            regPath = WmiLibInfo->DriverRegPath;
            guidList = WmiLibInfo->ControlGuids;
            guidCount = WmiLibInfo->GuidCount;

            if (regPath == NULL)
            {
                // No registry path specified. This is a bad thing for 
                // the device to do, but is not fatal
                nullRegistryPath.Buffer = NULL;
                nullRegistryPath.Length = 0;
                nullRegistryPath.MaximumLength = 0;
                regPath = &nullRegistryPath;
            }                
            
            registryPathOffset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                                  guidCount * sizeof(WMIREGGUIDW);

            bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

            if (bufferNeeded <= bufferSize)
            {
                retSize = bufferNeeded;
                RtlZeroMemory(buffer, bufferNeeded);

                wmiRegInfo = (PWMIREGINFO)buffer;
                wmiRegInfo->BufferSize = bufferNeeded;
                // wmiRegInfo->NextWmiRegInfo = 0;
                // wmiRegInfo->MofResourceName = 0;
                wmiRegInfo->RegistryPath = registryPathOffset;
                wmiRegInfo->GuidCount = guidCount;

                for (i = 0; i < guidCount; i++)
                {
                    wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                    wmiRegGuid->Guid = guidList[i].Guid;
                    wmiRegGuid->Flags = WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID;
                    // wmiRegGuid->InstanceInfo = 0;
                    // wmiRegGuid->InstanceCount = 0;
                }

                stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                *stringPtr++ = regPath->Length;
                RtlCopyMemory(stringPtr,
                          regPath->Buffer,
                          regPath->Length);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
                *((PULONG)buffer) = bufferNeeded;
                retSize = sizeof(ULONG);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_ENABLE_EVENTS:
        case IRP_MN_DISABLE_EVENTS:
        {
            PWNODE_HEADER   Wnode = irpStack->Parameters.WMI.Buffer;
            PWML_CONTROL_GUID_REG Ctx = WmiLibInfo->ControlGuids + guidIndex;
            if (irpStack->Parameters.WMI.BufferSize >= sizeof(WNODE_HEADER)) {
                status = STATUS_SUCCESS;

                if (minorFunction == IRP_MN_DISABLE_EVENTS) {
                    Ctx->EnableFlags64 = 0;
                } else {
                    Ctx->LoggerHandle = (TRACEHANDLE)( Wnode->HistoricalContext );
                    
                    Ctx->EnableLevel = WmiGetLoggerEnableLevel(Ctx->LoggerHandle);
                    Ctx->EnableFlags = WmiGetLoggerEnableFlags(Ctx->LoggerHandle);
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        {
            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_EXECUTE_METHOD:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return(status);
}

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Length, Address
    )
{
    TRACE_BUFFER TraceBuffer;

    ((PULONG)&TraceBuffer)[1] = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cchcp.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cchcp.c

Abstract:

    Not-immplemented messages for changing code page

--*/

#include "cmd.h"


int Chcp( command_line )
TCHAR *command_line;
{
	DBG_UNREFERENCED_PARAMETER( command_line );
    PutStdOut(MSG_NOT_IMPLEMENTED, NOARGS);

    return( SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wml\um\test\wmltest.c ===
#include <stdio.h>

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wmlum.h"
#include "wmlmacro.h"

WMILIB_REG_STRUCT   ClRtlWmiReg;
GUID ClRtlTraceGuid = { /* a14414bc-22d9-11d3-ba8a-00c04f8eed00 */
    0xa14414bc,0x22d9,0x11d3,{0xba,0x8a,0x00,0xc0,0x4f,0x8e,0xed,0x00}};

void print(int level, PCHAR str) {
    printf(str);
}

WML_DATA wml;

char a[] = "Gorik&Anzhela";

int __cdecl main(int argc, char** argv) {

    DWORD status;
    ULONG ProcessId = 123;
    WMLLOCAL;
    STRING as;

    as.Buffer = a+6;
    as.Length = 7;
    

    LOADWML(status, wml);
    printf("LOADWML status, %d\n", status);
    if (status != ERROR_SUCCESS) {
        return -1;
    }

    
    wml.Initialize(L"Clustering Service", print, &wml.WmiRegHandle, 
                   L"ClusRtl", &ClRtlWmiReg,
                    0);

#if 0
    wml.Trace( 10, &ClRtlTraceGuid, ClRtlWmiReg.LoggerHandle,
                   LOG(UINT, ProcessId )
                   LOGCHARARR(5, a) 0);

    Sleep(1000);
    
    wml.Trace( 10, &ClRtlTraceGuid, ClRtlWmiReg.LoggerHandle,
                   LOG(UINT, ProcessId )
                   LOGCHARARR(5, a) 0);

    Sleep(1000);
#endif    
    wml.Trace( 10, &ClRtlTraceGuid, ClRtlWmiReg.LoggerHandle,
                   LOG(UINT, ProcessId )
                   LOGCSTR(as) 0);

    Sleep(1000);

    UNLOADWML(wml);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\wml\um\wmlum.cpp ===
#define _UNICODE
#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>
#include <guiddef.h>

#define REG_TRACE_REGKEY            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing")

#define REG_TRACE_ENABLED           TEXT("EnableTracing")

#define REG_TRACE_LOG_FILE_NAME     TEXT("LogFileName")
#define REG_TRACE_LOG_SESSION_NAME  TEXT("LogSessionName")
#define REG_TRACE_LOG_BUFFER_SIZE   TEXT("BufferSize")
#define REG_TRACE_LOG_MIN_BUFFERS   TEXT("MinBuffers")
#define REG_TRACE_LOG_MAX_BUFFERS   TEXT("MaxBuffers")
#define REG_TRACE_LOG_MAX_FILESIZE  TEXT("MaxFileSize")
#define REG_TRACE_LOG_MAX_HISTORY   TEXT("MaxHistorySize")
#define REG_TRACE_LOG_MAX_BACKUPS   TEXT("MaxBackups")

#define REG_TRACE_ACTIVE            TEXT("Active")
#define REG_TRACE_CONTROL           TEXT("ControlFlags")
#define REG_TRACE_LEVEL             TEXT("Level")
#define REG_TRACE_GUID              TEXT("Guid")

#include "wmlum.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

VOID RegisterIfNecessary(LPWSTR KeyName, LPCGUID Guid);

WMILIBPRINTFUNC WmiLibPrint = 0;

#define NT_LOGGER L"NT Kernel Logger"

VOID
MyDbgPrint(
    UINT Level,
    PCHAR FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:
     None.

--*/
{
    CHAR Buffer[256];
    DWORD Bytes;
    va_list ArgList;

    if (WmiLibPrint == NULL) {
        return;
    }

    va_start(ArgList, FormatString);

    Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING,
                           FormatString,
                           0,
                           0,
                           Buffer,
                           sizeof(Buffer) / sizeof(CHAR),
                           &ArgList);


    va_end(ArgList);
    if (Bytes != 0) {
        (*WmiLibPrint)(Level, Buffer);
    }
}

UINT HexVal(int ch) { return isdigit(ch) ? ch - '0' : ch - 'a' + 10; }
UINT Hex(LPWSTR s, int n)
{
    UINT res = 0;
    while(n--) { res = res * 16 + HexVal(*s++); }
    return res;
}

VOID
GuidFromStr(
    IN LPWSTR str, 
    OUT LPGUID guid)
{
    guid->Data1 =            Hex(str +  0, 8);
    guid->Data2 =    (USHORT)Hex(str +  9, 4);
    guid->Data3 =    (USHORT)Hex(str + 14, 4);
    guid->Data4[0] = (UCHAR) Hex(str + 19, 2);
    guid->Data4[1] = (UCHAR) Hex(str + 21, 2);
    guid->Data4[2] = (UCHAR) Hex(str + 24, 2);
    guid->Data4[3] = (UCHAR) Hex(str + 26, 2);
    guid->Data4[4] = (UCHAR) Hex(str + 28, 2);
    guid->Data4[5] = (UCHAR) Hex(str + 30, 2);
    guid->Data4[6] = (UCHAR) Hex(str + 32, 2);
    guid->Data4[7] = (UCHAR) Hex(str + 34, 2);
}

typedef struct _INHERITED_DATA {
    BOOL Active;
    ULONG ControlFlags;
    ULONG LogLevel;
    ULONG Reserved;
    TRACEHANDLE Logger;
    GUID  Guid;
    BOOL  GuidDefined;
} INHERITED_DATA, *PINHERITED_DATA;

VOID
ReadCommonData(
    IN HKEY hk, 
    IN OUT PINHERITED_DATA data
    )
{
    ULONG ulTemp;
    ULONG dwSize;
    WCHAR szGuid[16 * 3 + 1];

    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_ACTIVE, 
                             NULL, NULL, (BYTE *) &ulTemp, &dwSize))
    {
        data->Active = ulTemp;
    }

    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_CONTROL, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwSize)) 
    {
        data->ControlFlags = ulTemp;
    }


    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LEVEL, 
                                         NULL, NULL,
                                         (BYTE *) &ulTemp, 
                                         &dwSize)) 
    {
        data->LogLevel = ulTemp;
    }

    dwSize = sizeof(szGuid);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_GUID, 
                                         NULL, NULL,
                                         (BYTE *) &szGuid, 
                                         &dwSize)) 
    {
        GuidFromStr(szGuid, &data->Guid);
        data->GuidDefined = TRUE;
    }

    return;
}

typedef struct _FULL_LOGGER_INFO {
    EVENT_TRACE_PROPERTIES LoggerInfo;
    WCHAR logFileName[MAX_PATH + 512];
    WCHAR logSessionName[MAX_PATH + 512];
    ULONG MaxHistorySize;
    ULONG MaxBackups;
} FULL_LOGGER_INFO, *PFULL_LOGGER_INFO;

GUID MySystemTraceControlGuid = { /* 9e814aad-3204-11d2-9a82-006008a86939 */
    0x9e814aad,
    0x3204,
    0x11d2,
    {0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39}
  };


VOID 
ReadLoggerInfo(
    IN HKEY hk, 
    OUT PTRACEHANDLE Logger) 
{
    FULL_LOGGER_INFO x;
    WCHAR tmpName[MAX_PATH + 512];
    WCHAR tmpName2[MAX_PATH + 512];
    ULONG ulTemp;
    ULONG dwReadSize = sizeof(ulTemp);    
    ULONG status;
    SYSTEMTIME localTime;
    BOOL success;
    
    RtlZeroMemory(&x.LoggerInfo, sizeof(x));
    x.LoggerInfo.Wnode.BufferSize = sizeof(x);
    x.LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    x.LoggerInfo.LogFileNameOffset = (ULONG)((ULONG_PTR)x.logFileName - (ULONG_PTR)&x);
    x.LoggerInfo.LoggerNameOffset  = (ULONG)((ULONG_PTR)x.logSessionName - (ULONG_PTR)&x);
    x.LoggerInfo.LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;

    //
    // If the key describes a logger,
    // it should have at least LOG_SESSION_NAME value
    //
    dwReadSize = sizeof(x.logSessionName);
    status = RegQueryValueEx(hk, REG_TRACE_LOG_SESSION_NAME, 
                             NULL, NULL, 
                             (BYTE *) &x.logSessionName, &dwReadSize);
    if (status != ERROR_SUCCESS) {
        return;
    }

    if ( wcscmp(x.logSessionName, NT_LOGGER) == 0) {
        MyDbgPrint(3,"[WMILIB] Enabling system tracing\n", 
                   x.logSessionName,
                   x.LoggerInfo.Wnode.HistoricalContext);

        x.LoggerInfo.Wnode.Guid = MySystemTraceControlGuid;
        x.LoggerInfo.EnableFlags |= 
            EVENT_TRACE_FLAG_PROCESS |
            EVENT_TRACE_FLAG_THREAD |
            EVENT_TRACE_FLAG_DISK_IO |
            EVENT_TRACE_FLAG_NETWORK_TCPIP |
            EVENT_TRACE_FLAG_REGISTRY;
    }

    // Let's query, whether there is a logger with this name
    status = QueryTrace(0, x.logSessionName, &x.LoggerInfo);
    if (ERROR_SUCCESS == status) {
        MyDbgPrint(1,"[WMILIB] Query successful Logger %1!ws! %2!08X!:%3!08X!\n", 
                   x.logSessionName,
                   x.LoggerInfo.Wnode.HistoricalContext);
        *Logger = x.LoggerInfo.Wnode.HistoricalContext;
        return;
    }

    if (ERROR_WMI_INSTANCE_NOT_FOUND != status) {
        MyDbgPrint(1,"[WMILIB] Query of %1!ws! failed %2!d!\n", 
                   x.logSessionName, status);
    }

    // There is no logger runing

    // First, We will query logFileName value into tmpName variable
    // and then expand it into logFileName
    dwReadSize = sizeof(tmpName);
    status = RegQueryValueEx(hk, REG_TRACE_LOG_FILE_NAME, 
                             NULL, NULL, 
                             (BYTE *) &tmpName, &dwReadSize);
    if (status != ERROR_SUCCESS) {
        // If there is no logFileName, then this node doesn't describe
        // a logger. Bail out.
        MyDbgPrint(1,"[WMILIB] Cannot read log file name, status %1!d!\n", status);
        return;
    }
    dwReadSize = ExpandEnvironmentStrings(tmpName, x.logFileName, ARRAYSIZE(x.logFileName) );
    if (dwReadSize == 0 || dwReadSize > ARRAYSIZE(x.logFileName)) {
        MyDbgPrint(1,"[WMILIB] Expansion of %1!ws! failed, return value %2!d!\n", tmpName, dwReadSize);
        CopyMemory(x.logFileName, tmpName, sizeof(x.logFileName));
    }
    
    MyDbgPrint(3,"[WMILIB] FileName %1!S!\n", x.logFileName);
    MyDbgPrint(3,"[WMILIB] Session %1!S!\n", x.logSessionName);

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_BUFFER_SIZE, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.LoggerInfo.BufferSize = ulTemp;

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MIN_BUFFERS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.LoggerInfo.MinimumBuffers = ulTemp;

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_BUFFERS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.LoggerInfo.MaximumBuffers = ulTemp;

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_FILESIZE, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.LoggerInfo.MaximumFileSize = ulTemp;

	x.MaxHistorySize = 4 * x.LoggerInfo.MaximumFileSize;
    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_HISTORY, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.MaxHistorySize = ulTemp;

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_BACKUPS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize))
        x.MaxBackups = ulTemp;


	if (x.MaxBackups == 0) {
	 	// We need to check whether the file already exist and rename it //

	 	GetLocalTime(&localTime);
		_snwprintf(tmpName, ARRAYSIZE(tmpName), 
				   L"%1ws.%04d%02d%02d%02d%02d%02d",
				   x.logFileName,
				   localTime.wYear,localTime.wMonth,localTime.wDay,
				   localTime.wHour,localTime.wMinute,localTime.wSecond);

		success = MoveFile(x.logFileName, tmpName);
		if (!success) {
	    	status = GetLastError();
		} else {
			status = ERROR_SUCCESS;
		}
	    MyDbgPrint(3,"[WMILIB] Rename %1!ws! => %2!ws!, status %3!d!\n", 
	    			x.logFileName, tmpName, status);
	} else {
		int i;
		for (i = x.MaxBackups; i >= 1; --i) {
			_snwprintf(tmpName2, ARRAYSIZE(tmpName), 
					   L"%1ws.%03d",
					   x.logFileName, i);
			if (i == 1) {
				wcscpy(tmpName, x.logFileName);
			} else {
				_snwprintf(tmpName, ARRAYSIZE(tmpName), 
						   L"%1ws.%03d",
						   x.logFileName, i-1);
			}
			success = MoveFileEx(tmpName, tmpName2, MOVEFILE_REPLACE_EXISTING);
			if (!success) {
		    	status = GetLastError();
			} else {
				status = ERROR_SUCCESS;
			}
		    MyDbgPrint(3,"[WMILIB] Rename %1!ws! => %2!ws!, status %3!d!\n", 
		    			tmpName, tmpName2, status);
		}
	}

    status = StartTrace(Logger, x.logSessionName, &x.LoggerInfo);
    *Logger = x.LoggerInfo.Wnode.HistoricalContext;
    MyDbgPrint(1,"[WMILIB] Logger %1!ws! started %3!08X!:%4!08X! %2!d!\n", 
               x.logSessionName, status, *Logger);
}

WCHAR szModuleName[MAX_PATH+500];

ULONG
InitWmiInternal(
    IN HKEY Dir OPTIONAL, // if 0, then current ...
    IN LPWSTR ProductName, 
    IN PINHERITED_DATA InheritedData OPTIONAL
    )
{
    ULONG status;
    INHERITED_DATA data;
    HKEY CloseMe = 0;
    HKEY hk      = 0;
    //ULONG ulTemp;
    //ULONG dwReadSize = sizeof(ulTemp);
    DWORD dwSizeOfModuleName;
    DWORD dwIndex;

    MyDbgPrint(2, "[WMILIB] Init %1!ws!\n", ProductName);

    if (InheritedData) {
        data = *InheritedData;
    } else {
        ZeroMemory(&data, sizeof(data));
    }
    data.GuidDefined = FALSE;

    if (!Dir) {
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                              REG_TRACE_REGKEY, 
                              0, 
                              KEY_READ, 
                              &CloseMe);
        if (status != ERROR_SUCCESS) {
            MyDbgPrint(1,"[WMILIB] Failed to open Trace Key, %1!d!\n", status);
            goto exit_gracefully;
        }
        Dir = CloseMe;
    }

    status = RegOpenKeyEx(Dir, 
                          ProductName, 
                          0, 
                          KEY_READ, 
                          &hk);
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WMILIB] Failed to open %1!ws! subkey, %2!d!\n", ProductName, status);
        goto exit_gracefully;
    }


    ReadLoggerInfo(hk, &data.Logger);
    ReadCommonData(hk, &data);

    if (!data.Active) {
        MyDbgPrint(1,"[WMILIB] Tracing is not active for %1!ws!\n", ProductName);
    	goto exit_gracefully;
    }

    if (data.GuidDefined) {
        // First, try to find its in the map.            //
        // If it is there, we need to register this Guid //
        RegisterIfNecessary(ProductName, &data.Guid);

        // We can try to start tracing //
        if (data.Logger) {
            status = EnableTrace(data.Active, 
                                 data.ControlFlags, 
                                 data.LogLevel,
                                 &data.Guid,
                                 data.Logger);
            MyDbgPrint(1,"[WMILIB] Enable=%1!d! %2!ws!, status %3!d!\n", data.
                       Active, ProductName, status);
        }
    }

    dwSizeOfModuleName = sizeof(szModuleName);
    dwIndex = 0;
    while (ERROR_SUCCESS == (status = RegEnumKeyEx(hk, dwIndex, 
                                                   szModuleName, 
                                                   &dwSizeOfModuleName,
                                                   NULL, NULL, NULL, NULL)))
    {
        InitWmiInternal(hk, szModuleName, &data);

        dwSizeOfModuleName = sizeof(szModuleName);
        ++dwIndex;
    }

    if (ERROR_NO_MORE_ITEMS == status) {
        status = ERROR_SUCCESS;
    }

exit_gracefully:
    if (CloseMe) {
        RegCloseKey(CloseMe);
    }
    if (hk) {
        RegCloseKey(hk);
    }
    return status;
}

ULONG
InitWmi(
    IN LPWSTR ProductName
    )
{
    MyDbgPrint(1, "[WMILIB] Initialize %1!ws!\n", ProductName);
    return InitWmiInternal(0, ProductName, 0);
}

#pragma warning(disable: 4512) // error C4512: 'blah-blah-blah' : assignment operator could not be generated
#pragma warning(disable: 4100) // '_P' : unreferenced formal parameter
#include <xmemory>
#pragma warning(default: 4100)
#include <map>
//#include <xstring>

struct wless {
    bool operator() (LPCWSTR a, LPCWSTR b) const { return lstrcmpW(a,b) < 0; }
};

typedef std::map<LPCWSTR, PWMILIB_REG_STRUCT, wless > WIDE_STRING_MAP;

WIDE_STRING_MAP* map;
PWMILIB_REG_STRUCT head;

ULONG
WmilibControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    PWMILIB_REG_STRUCT Ctx = (PWMILIB_REG_STRUCT)Context;
    ULONG Status = ERROR_SUCCESS;

   	switch (RequestCode)
   	{
   	case WMI_ENABLE_EVENTS:
   	    {
   	    Ctx->LoggerHandle = GetTraceLoggerHandle( Buffer );
   	    Ctx->EnableLevel = GetTraceEnableLevel(Ctx->LoggerHandle);
   	    Ctx->EnableFlags = GetTraceEnableFlags(Ctx->LoggerHandle);
        MyDbgPrint(3, "[WMILIB] WMI_ENABLE_EVENTS Ctx 0x%1!08X! Flags %2!X! Lev %3!d! Logger %4!08X!:%5!08X!\n", 
                   Ctx, Ctx->EnableFlags, Ctx->EnableLevel, Ctx->LoggerHandle);
    
        break;
   	    }

   	case WMI_DISABLE_EVENTS:
   	    {
        Ctx->LoggerHandle = 0;
        Ctx->EnableFlags = 0;
        Ctx->EnableLevel = 0;
        MyDbgPrint(3, "[WMILIB] WMI_DISABLE_EVENTS Ctx 0x%1!08X!\n", Ctx);
   	    break;
    	}

   	default:
   	   {
   	       Status = ERROR_INVALID_PARAMETER;
   	       break;
   	   }
   	}
   	*InOutBufferSize = 0;
   	return(Status);
}



VOID RegisterIfNecessary(
    LPWSTR KeyName, 
    LPCGUID Guid)
{
    WIDE_STRING_MAP::iterator i = map->find(KeyName);
    if ( i == map->end() ) {
        MyDbgPrint(2, "[WMILIB] map: %1!ws!, not found\n", KeyName);
        return; // Not found //
    }
    MyDbgPrint(3, "[WMILIB] map[%1!ws!]=0x%2!08X!\n", i->first, i->second);

    TRACE_GUID_REGISTRATION Reg;

    Reg.Guid = Guid;
    Reg.RegHandle = 0;

    ULONG status = RegisterTraceGuids(
        WmilibControlCallback,
        i->second, // Context for the callback
        Guid,      // Control Guid
        1,         // # of dummies
        &Reg,      // dummy trace guid
        0, //ImagePath,
        0, //ResourceName,
        &i->second->RegistrationHandle
        );

    if (status == ERROR_SUCCESS) {
        i->second->Next = head;
        head = i->second;
    } else {
        MyDbgPrint(1, "[WMILIB] Failed to register %1!ws!, status %2!d!\n", KeyName, status);
    }
}

ULONG
WmlInitialize(
    IN LPWSTR              ProductName, 
    IN WMILIBPRINTFUNC     PrintFunc,
    OUT WMILIB_REG_HANDLE* Head, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WMILIB_REG_STRUCT 
    )
{
    WIDE_STRING_MAP map;
    LPWSTR str;
    va_list ap;

    WmiLibPrint = PrintFunc;

    *Head = 0;

    ::head = 0;
    ::map = &map;

    va_start(ap, Head);
    while(0 != (str = va_arg(ap, LPWSTR)) ) {
         map[ str ] = va_arg(ap, PWMILIB_REG_STRUCT);
    }
    va_end(ap);
    ULONG status = InitWmiInternal(0, ProductName, 0);
    *Head = ::head;
    return status;
}

VOID
WmlUninitialize(
    IN PWMILIB_REG_STRUCT head
    )
{
    while (head) {
        MyDbgPrint(3,"[WMILIB] Unregister 0x%1!08X!\n", head);
        UnregisterTraceGuids(head->RegistrationHandle);
        head = head->Next;
    }
}

#define WMILIB_USER_MODE

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    TRACE_BUFFER TraceBuffer;

    ((PULONG)&TraceBuffer)[1] = Type;
    
#ifndef WMILIB_USER_MODE
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle;
#endif

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
#ifdef WMILIB_USER_MODE
    ULONG status = TraceEvent( LoggerHandle, &TraceBuffer.Trace);
    if (status != ERROR_SUCCESS) {
    	// Need to count failures and report them during unintialize or ...//
    }
#else
    IoWMIWriteEvent(&TraceBuffer);
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cclock.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cclock.c

Abstract:

    time/date functions

--*/

#include "cmd.h"

#define MMDDYY 0
#define DDMMYY 1
#define YYMMDD 2

extern TCHAR Fmt04[], Fmt05[], Fmt06[], Fmt10[], Fmt11[];
extern TCHAR Fmt17[], Fmt15[];
extern unsigned DosErr;
extern unsigned LastRetCode;
// for keeping current console output codepage.
extern  UINT CurrentCP;

BOOL TimeAmPm=TRUE;
TCHAR TimeSeparator[8];
TCHAR DateSeparator[8];
TCHAR DecimalPlace[8];
int DateFormat;
TCHAR *DateFormatString;
TCHAR ThousandSeparator[8];
TCHAR ShortMondayName[16];
TCHAR ShortTuesdayName[16];
TCHAR ShortWednesdayName[16];
TCHAR ShortThursdayName[16];
TCHAR ShortFridayName[16];
TCHAR ShortSaturdayName[16];
TCHAR ShortSundayName[16];
TCHAR AMIndicator[8];
TCHAR PMIndicator[8];
ULONG YearWidth;

//
//  We snapshot the current LCID at startup and modify it based on the current known
//  set of scripts that Console supports.
//


LCID CmdGetUserDefaultLCID(
    void
    )
{
    LCID CmdLcid = GetUserDefaultLCID();
#ifdef LANGPACK
    if (
       (PRIMARYLANGID(CmdLcid) == LANG_ARABIC) ||
       (PRIMARYLANGID(CmdLcid) == LANG_HEBREW) ||
       (PRIMARYLANGID(CmdLcid) == LANG_THAI)   ||
       (PRIMARYLANGID(CmdLcid) == LANG_HINDI)  ||
       (PRIMARYLANGID(CmdLcid) == LANG_TAMIL)  ||
       (PRIMARYLANGID(CmdLcid) == LANG_FARSI)
       ) {
        CmdLcid = MAKELCID (MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), SORT_DEFAULT); // 0x409;
    }
#endif
    return CmdLcid;
}


VOID
InitLocale( VOID )
{
    TCHAR Buffer[128];

    LCID CmdLcid = CmdGetUserDefaultLCID( );
    
    // get the time separator
    if (GetLocaleInfo(CmdLcid, LOCALE_STIME, Buffer, sizeof(TimeSeparator)))
        _tcscpy(TimeSeparator, Buffer);
    else
        _tcscpy(TimeSeparator, TEXT(":"));

    // determine if we're 0-12 or 0-24
    if (GetLocaleInfo(CmdLcid, LOCALE_ITIME, Buffer, 128)) {
        TimeAmPm = _tcscmp(Buffer,TEXT("1"));
    }

    _tcscpy(AMIndicator, TEXT("a"));
    _tcscpy(PMIndicator, TEXT("p"));

    //
    //  get the date ordering
    //
    DateFormat = MMDDYY;
    if (GetLocaleInfo(CmdLcid, LOCALE_IDATE, Buffer, 128)) {
        switch (Buffer[0]) {
        case TEXT('0'):
            DateFormat = MMDDYY;
            DateFormatString = TEXT( "MM/dd/yy" );
            break;
        case TEXT('1'):
            DateFormat = DDMMYY;
            DateFormatString = TEXT( "dd/MM/yy" );
            break;
        case TEXT('2'):
            DateFormat = YYMMDD;
            DateFormatString = TEXT( "yy/MM/dd" );
            break;
        default:
            break;
        }
    }

    //
    //  Get the date width
    //

    YearWidth = 2;
    if (GetLocaleInfo( CmdLcid, LOCALE_ICENTURY, Buffer, 128 )) {
        if (Buffer[0] == TEXT( '1' )) {
            YearWidth = 4;
        }
    }

    // get the date separator
    if (GetLocaleInfo(CmdLcid, LOCALE_SDATE, Buffer, sizeof(DateSeparator)))
        _tcscpy(DateSeparator, Buffer);
    else
        _tcscpy(DateSeparator, TEXT("/"));

    // get the short day names
    if (GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME1, Buffer, sizeof(ShortMondayName)))
        _tcscpy(ShortMondayName, Buffer);
    else
        _tcscpy(ShortMondayName, TEXT("Mon"));
    if (GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME2, Buffer, sizeof(ShortTuesdayName)))
        _tcscpy(ShortTuesdayName, Buffer);
    else
        _tcscpy(ShortTuesdayName, TEXT("Tue"));
    if (GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME3, Buffer, sizeof(ShortWednesdayName)))
        _tcscpy(ShortWednesdayName, Buffer);
    else
        _tcscpy(ShortWednesdayName, TEXT("Wed"));
    if (GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME4, Buffer, sizeof(ShortThursdayName)))
        _tcscpy(ShortThursdayName, Buffer);
    else
        _tcscpy(ShortThursdayName, TEXT("Thu"));
    if (GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME5, Buffer, sizeof(ShortFridayName)))
        _tcscpy(ShortFridayName, Buffer);
    else
        _tcscpy(ShortFridayName, TEXT("Fri"));
    if (GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME6, Buffer, sizeof(ShortSaturdayName)))
        _tcscpy(ShortSaturdayName, Buffer);
    else
        _tcscpy(ShortSaturdayName, TEXT("Sat"));
    if (GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME7, Buffer, sizeof(ShortSundayName)))
        _tcscpy(ShortSundayName, Buffer);
    else
        _tcscpy(ShortSundayName, TEXT("Sun"));

    // get decimal and thousand separator strings
    if (GetLocaleInfo(CmdLcid, LOCALE_SDECIMAL, Buffer, sizeof(DecimalPlace)))
        _tcscpy(DecimalPlace, Buffer);
    else
        _tcscpy(DecimalPlace, TEXT("."));
    if (GetLocaleInfo(CmdLcid, LOCALE_STHOUSAND, Buffer, sizeof(ThousandSeparator)))
        _tcscpy(ThousandSeparator, Buffer);
    else
        _tcscpy(ThousandSeparator, TEXT(","));

    //
    //  Set locale so that we can correctly process extended characters
    //  Note:  The string passed in is expected to be ASCII, not unicode
    //

    setlocale( LC_ALL, ".OCP" ) ;
}


BOOLEAN
SetDateTime(
           IN  LPSYSTEMTIME OsDateAndTime
           )
{
    //
    //  We have to do this twice in order to get the leap year set correctly.
    //

    SetLocalTime( OsDateAndTime );
    return(SetLocalTime( OsDateAndTime ) != 0);
}

/***    eDate - begin the execution of the Date command
 *
 *  Purpose:
 *      To display and/or set the system date.
 *
 *  Args:
 *      n - the parse tree node containing the date command
 *
 *  int eDate(struct cmdnode *n)
 *
 *  Returns:
 *      SUCCESS always.
 *
 */

int eDate(n)
struct cmdnode *n ;
{
    BOOL bTerse = FALSE;
    PTCHAR pArgs = n->argptr;
    DEBUG((CLGRP, DALVL, "eDATE: argptr = `%s'", n->argptr)) ;

    //
    // If extensions are enabled, allow a /T switch
    // to disable inputing a new DATE, just display the
    // current date.
    //
    if (fEnableExtensions)
        while ( (pArgs = mystrchr( pArgs, TEXT('/') )) != NULL ) {
            TCHAR c = (TCHAR) _totlower(*(pArgs+1));
            if ( c == TEXT('t') )
                bTerse = TRUE;
            pArgs += 2; // just skip it
        }

    if ( bTerse ) {
        PrintDate(NULL, PD_PTDATE, (TCHAR *)NULL, 0) ;
        cmd_printf(CrLf);
        return(LastRetCode = SUCCESS);
    }

    if ((n->argptr == NULL) ||
        (*(n->argptr = EatWS(n->argptr, NULL)) == NULLC)) {
        PutStdOut(MSG_CURRENT_DATE, NOARGS) ;
        PrintDate(NULL, PD_PTDATE, (TCHAR *)NULL, 0) ;
        cmd_printf(CrLf);
    };

    return(LastRetCode = GetVerSetDateTime(n->argptr, EDATE)) ;
}




/***    eTime - begin the execution of the Time command
 *
 *  Purpose:
 *      To display and/or set the system date.
 *
 *  int eTime(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the time command
 *
 *  Returns:
 *      SUCCESS always.
 *
 */

int eTime(n)
struct cmdnode *n ;
{
    BOOL bTerse = FALSE;
    PTCHAR pArgs = n->argptr;
    DEBUG((CLGRP, TILVL, "eTIME: argptr = `%s'", n->argptr)) ;

    //
    // If extensions are enabled, allow a /T switch
    // to disable inputing a new TIME, just display the
    // current time.
    //
    if (fEnableExtensions)
        while ( (pArgs = mystrchr( pArgs, TEXT('/') )) != NULL ) {
            TCHAR c = (TCHAR) _totlower(*(pArgs+1));
            if ( c == TEXT('t') )
                bTerse = TRUE;
            pArgs += 2; // just skip it
        }

    if ( bTerse ) {
        PrintTime(NULL, PD_PTDATE, (TCHAR *)NULL, 0) ;
        cmd_printf(CrLf);
        return(LastRetCode = SUCCESS);
    }

    if ((n->argptr == NULL) ||
        (*(n->argptr = EatWS(n->argptr, NULL)) == NULLC)) {
        PutStdOut(MSG_CURRENT_TIME, NOARGS) ;
        PrintTime(NULL, PT_TIME, (TCHAR *)NULL, 0) ;
        cmd_printf(CrLf);
    };

    return(LastRetCode = GetVerSetDateTime(n->argptr, ETIME)) ;
}




/***    PrintDate - print the date
 *
 *  Purpose:
 *      To print the date either in the format used by the Date command or
 *      the format used by the Dir command.  The structure Cinfo is checked
 *      for the country date format.
 *
 *  PrintDate(int flag, TCHAR *buffer)
 *
 *  Args:
 *      flag - indicates which format to print
 *      *buffer - indicates whether or not to print date message
 *
 *  Notes:
 */

int PrintDate(crt_time,flag,buffer,cch)
struct tm *crt_time ;
int flag ;
TCHAR *buffer;
int cch;
{
    TCHAR DayOfWeek[10];
    TCHAR datebuf [32] ;
    unsigned i, j, k, m;
    int ptr = 0;
    struct tm xcrt_time ;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    FILETIME LocalFileTime;
    int cchUsed;
    BOOL NeedDayOfWeek = TRUE;

    DEBUG((CLGRP, DALVL, "PRINTDATE: flag = %d", flag)) ;

    //
    //  PrintDate is never called with PD_DATE and buffer == NULL
    //  PrintDate is never called with PD_DIR and buffer == NULL
    //  PrintDate is never called with PD_PTDATE and buffer != NULL
    //
    //  Another way of saying this is:
    //      PD_DATE => output to buffer
    //      PD_DIR => output to buffer
    //      PD_DIR2000 => output to buffer
    //      PD_PTDATE => print out
    //
    //  PD_DIR      MM/DD/YY
    //  PD_DIR2000  MM/DD/YYYY
    //  PD_DATE     Japan: MM/DD/YYYY DayOfWeek     Rest: DayOfWeek MM/DD/YYYY
    //  PD_PTDATE   Japan: MM/DD/YYYY DayOfWeek     Rest: DayOfWeek MM/DD/YYYY
    //

    //
    //  If no time was input, then use the current system time.  Convert from the
    //  various formats to something standard.
    //

    if (!crt_time) {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime,&FileTime);
    } else {
        xcrt_time = *crt_time;
        ConverttmToFILETIME(&xcrt_time,&FileTime);
    }
    FileTimeToLocalFileTime(&FileTime,&LocalFileTime);
    FileTimeToSystemTime( &LocalFileTime, &SystemTime );

    //
    // SystemTime now contains the correct local time
    // FileTime now contains the correct local time
    //

    //
    //  If extensions are enabled, we format things in the culturally
    //  correct format (from international control panel).  if not, then
    //  we display it as best we can from NT 4.
    //

    if (fEnableExtensions) {

        TCHAR LocaleDateFormat[128];
        PTCHAR p;
        BOOL InQuotes = FALSE;

        //
        //  Map the locale to one that is acceptable to the console subsystem
        //

        if (!GetLocaleInfo( CmdGetUserDefaultLCID( ), 
                            LOCALE_SSHORTDATE, 
                            LocaleDateFormat, 
                            sizeof( LocaleDateFormat ) / sizeof( LocaleDateFormat[0] ))) {
            //
            //  Not enough room for this format, cheat and use the one we
            //  assumed from the DateFormat
            //

            _tcscpy( LocaleDateFormat, DateFormatString );
        }

        //
        //  The format string may be expanded with widely varying widths.  We
        //  adjust this string to try to make sure that they are all fixed widths.
        //
        //  The picture formats only have varying widths for:
        //      d   (no leading zero date)
        //      dddd(full date name)
        //      M   (no leading zero month)
        //      MMMM(full month name)
        //
        //      So, if we see d or M, we change it to dd or MM (leading zero)
        //      If we see dddd or MMMM we change it to ddd or MMM (three char abbrev)
        //

        p = LocaleDateFormat;
        while (*p != TEXT( '\0' )) {
            TCHAR c = *p;

            //
            //  Text inside single quotes is left alone
            //

            if (c == TEXT( '\'' )) {
                InQuotes = !InQuotes;
                p++;
            } else if (InQuotes) {
                p++;
            } else if (c == TEXT( 'd' ) || c == TEXT( 'M' )) {

                //
                //  Count the number of identical chars
                //

                int Count = 0;

                while (*p == c) {
                    Count++;
                    p++;
                }


                //
                //  Reset p and shuffle string around based on the repetition count
                //

                p -= Count;

                if (Count == 1) {
                    //
                    //  Move string right by one and copy the first char
                    //
                    memmove( (PUCHAR) &p[1], (PUCHAR) &p[0], sizeof( TCHAR ) * (_tcslen( &p[0] ) + 1));

                    //
                    //  Skip over the format string
                    //

                    p += 2;

                } else {
                    //
                    //  If the format string is specifying a day of week (d), then we do not
                    //  need to add on the DayOfWeek, below
                    //

                    if (c == TEXT( 'd' )) {
                        NeedDayOfWeek = FALSE;
                    }

                    if (Count > 3) {
                        //
                        //  Move string left from the first different char to just after the 3rd 
                        //  repetition
                        //
                        memmove( (PUCHAR) &p[3], (PUCHAR) &p[Count], sizeof( TCHAR ) * (_tcslen( &p[Count] ) + 1));

                        //
                        //  Skip over the format string
                        //

                        p += 3;

                    } else {

                        //
                        //  Skip over the 2 or 3 count
                        //

                        p += Count;
                    }
                }
            } else {
                p++;
            }
        }

        GetDateFormat( CmdGetUserDefaultLCID( ), 
                       0, 
                       &SystemTime, 
                       LocaleDateFormat, 
                       datebuf, 
                       sizeof( datebuf ) / sizeof( datebuf[0] ));
    } else {

        i = SystemTime.wMonth;
        j = SystemTime.wDay;
        k = SystemTime.wYear;

        //
        //  only print last two digits for DIR listings
        //

        if (flag == PD_DIR) {
            k = k % 100;
        }

        if (DateFormat == YYMMDD ) {
            m = k ;                         /* Swap all values         */
            k = j ;
            j = i ;
            i = m ;
        } else if (DateFormat == DDMMYY) {
            m = i ;                         /* Swap mon/day for Europe */
            i = j ;
            j = m ;
        }

        DEBUG((CLGRP, DALVL, "PRINTDATE: i = %d  j = %d  k = %d", i, j, k)) ;

        //
        //  Format the current date and current day of week
        //

        _sntprintf(datebuf, 32, Fmt10, i, DateSeparator, j, DateSeparator, k);
    }

    _tcscpy( DayOfWeek, dayptr( SystemTime.wDayOfWeek )) ;

    //
    //  If there is no input buffer, we display the day-of-week and date
    //  according to language preference.  Only in DBCS codepages (aka Japan)
    //  does the day of week FOLLOW the date
    //

    if (buffer == NULL) {
        //
        //  This can only be PD_PTDATE
        //

        //
        //  No day of week means we simply display the date
        //

        if (!NeedDayOfWeek) {
            cchUsed = cmd_printf( Fmt11, datebuf );
        } else if (IsDBCSCodePage()) {
            cchUsed = cmd_printf( Fmt15, datebuf, DayOfWeek );         //  "%s %s "
        } else {
            cchUsed = cmd_printf( Fmt15, DayOfWeek, datebuf );         //  "%s %s "
        }

    } else {
        //
        //  for PD_DATE, we need to output the date in the correct spot
        //

        if (NeedDayOfWeek && flag == PD_DATE) {

            if (IsDBCSCodePage()) {
                _tcscpy( buffer, datebuf );
                _tcscat( buffer, TEXT( " " ));
                _tcscat( buffer, DayOfWeek );
            } else {
                _tcscpy( buffer, DayOfWeek );
                _tcscat( buffer, TEXT( " " ));
                _tcscat( buffer, datebuf );
            }
        } else {
            // 
            //  PD_DIR and PD_DIR2000 only get the date
            //

            _tcscpy( buffer, datebuf );
        }
        cchUsed = _tcslen( buffer );
    }

    return cchUsed;
}




/***    PrintTime - print the time
 *
 *  Purpose:
 *      To print the time either in the format used by the Time command or
 *      the format used by the Dir command.  The structure Cinfo is checked
 *      for the country time format.
 *
 *  PrintTime(int flag)
 *
 *  Args:
 *      flag - indicates which format to print
 *
 */

int PrintTime(crt_time, flag, buffer, cch)
struct tm *crt_time ;
int flag ;
TCHAR *buffer;
int cch;
{
    TCHAR *ampm ;
    unsigned hr ;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    FILETIME LocalFileTime;
    int cchUsed;

    if (!crt_time) {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime,&FileTime);
    } else {
        ConverttmToFILETIME(crt_time,&FileTime);
    }

    FileTimeToLocalFileTime(&FileTime,&LocalFileTime);
    FileTimeToSystemTime( &LocalFileTime, &SystemTime );


    //
    //  PT_TIME implies Time Command format.  This is nothing more
    //  than 24 hour clock with tenths
    //

    if (flag == PT_TIME) {      /* Print time in Time command format    */
        if (!buffer) {
            cchUsed = cmd_printf(Fmt06,
                                 SystemTime.wHour, TimeSeparator,
                                 SystemTime.wMinute, TimeSeparator,
                                 SystemTime.wSecond, DecimalPlace,
                                 SystemTime.wMilliseconds/10
                                ) ;
        } else {
            cchUsed = _sntprintf(buffer, cch, Fmt06,
                                 SystemTime.wHour, TimeSeparator,
                                 SystemTime.wMinute, TimeSeparator,
                                 SystemTime.wSecond, DecimalPlace,
                                 SystemTime.wMilliseconds/10
                                ) ;
        }

    } else {

        TCHAR TimeBuffer[32];

        //
        //  Print time in Dir command format.  If extensions are enabled
        //  then we have the culturally correct time, otherwise we use
        //  the NT 4 format.
        //

        if (fEnableExtensions) {
            TCHAR LocaleTimeFormat[128];
            PTCHAR p;
            BOOL InQuotes = FALSE;


            if (!GetLocaleInfo( CmdGetUserDefaultLCID( ), 
                                LOCALE_STIMEFORMAT, 
                                LocaleTimeFormat, 
                                sizeof( LocaleTimeFormat ) / sizeof( LocaleTimeFormat[0] ))) {
                //
                //  Not enough room for this format, cheat and use the one we
                //  assumed from the DateFormat
                //

                _tcscpy( LocaleTimeFormat, TEXT( "HH:mm:ss t" ));
            }

            //
            //  Scan the string looking for "h", "H", or "m" and make sure there are two of them.
            //  If there is a single one, replicate it.  We do this to ensure leading zeros
            //  which we need to make this a fixed-width string
            //

            p = LocaleTimeFormat;
            while (*p != TEXT( '\0' )) {
                TCHAR c = *p;

                //
                //  Text inside single quotes is left alone
                //

                if (c == TEXT( '\'' )) {
                    InQuotes = !InQuotes;
                    p++;
                } else if (InQuotes) {
                    p++;
                } else if (c == TEXT( 'h' ) || c == TEXT( 'H' ) || c == TEXT( 'm' )) {

                    //
                    //  Count the number of identical chars
                    //

                    int Count = 0;

                    while (*p == c) {
                        Count++;
                        p++;
                    }


                    //
                    //  Reset p and shuffle string around based on the repetition count
                    //

                    p -= Count;

                    if (Count == 1) {
                        memmove( (PUCHAR) &p[1], (PUCHAR) &p[0], sizeof( TCHAR ) * (_tcslen( &p[0] ) + 1));
                        *p = c;
                    }

                    p++;

                }

                p++;
            }

            cchUsed = GetTimeFormat( CmdGetUserDefaultLCID( ),
                                     TIME_NOSECONDS,
                                     &SystemTime,
                                     LocaleTimeFormat,
                                     TimeBuffer,
                                     sizeof( TimeBuffer ) / sizeof( TimeBuffer[0] ));

            if (cchUsed == 0) {
                TimeBuffer[0] = TEXT( '\0' );
            }

        } else {
            ampm = AMIndicator ;
            hr = SystemTime.wHour;
            if ( TimeAmPm ) {  /* 12 hour am/pm format */
                if ( hr >= 12) {
                    if (hr > 12) {
                        hr -= 12 ;
                    }
                    ampm = PMIndicator ;
                } else if (hr == 0) {
                    hr = 12 ;
                }
            } else {  /* 24 hour format */
                ampm = TEXT( " " );
            }

            _sntprintf( TimeBuffer, 
                        sizeof( TimeBuffer ) / sizeof( TimeBuffer[0] ),
                        Fmt04,
                        hr,
                        TimeSeparator,
                        SystemTime.wMinute,
                        ampm );
        }

        if (!buffer) {
            cchUsed = CmdPutString( TimeBuffer );
        } else {
            _tcsncpy( buffer, TimeBuffer, cch );
            buffer[cch] = TEXT( '\0' );
            cchUsed = _tcslen( buffer );
        }

    }

    return cchUsed;
}


/***    GetVerSetDateTime - controls the changing of the date/time
 *
 *  Purpose:
 *      To prompt the user for a date or time, verify it, and set it.
 *      On entry, if *dtstr is not '\0', it already points to a date or time
 *      string.
 *
 *      If null input is given to one of the prompts, the command execution
 *      ends; neither the date or the time is changed.
 *
 *      Once valid input has been received the date/time is updated.
 *
 *  int GetVerSetDateTime(TCHAR *dtstr, int call)
 *
 *  Args:
 *      dtstr - ptr to command line date/time string and is used to hold a ptr
 *          to the tokenized date/time string
 *      call - indicates whether to prompt for date or time
 *
 */

int GetVerSetDateTime(dtstr, call)
TCHAR *dtstr ;
int call ;
{
    TCHAR dtseps[16] ;    /* Date/Time separators passed to TokStr() */
    TCHAR *scan;
    TCHAR separators[16];
    TCHAR LocalBuf[MAX_PATH];

    unsigned int dformat ;
    SYSTEMTIME OsDateAndTime;
    LONG cbRead;
    int ret;

    if (call == EDATE) {         /* Initialize date/time separator list */
        dtseps[0] = TEXT('/') ;
        dtseps[1] = TEXT('-') ;
        dtseps[2] = TEXT('.') ;
        _tcscpy(&dtseps[3], DateSeparator) ;
    } else {
        dtseps[0] = TEXT(':');
        dtseps[1] = TEXT('.');
        dtseps[2] = TimeSeparator[0] ;
        _tcscpy(&dtseps[3], DecimalPlace) ;     /* decimal separator should */
                                                /* always be last */
    }

    DEBUG((CLGRP, DALVL|TILVL, "GVSDT: dtseps = `%s'", dtseps)) ;

    for ( ; ; ) {                   /* Date/time get-verify-set loop    */
        if ((dtstr) && (*dtstr != NULLC)) {         /* If a date/time was passed copy it into input buffer */
            _tcscpy(LocalBuf, dtstr) ;
            *dtstr = NULLC ;
        } else {                    /* Otherwise, prompt for new date/time  */
            switch (DateFormat) {           /* M012    */
            /*  case USA:  */
            case MMDDYY: /* @@ */
                dformat = MSG_ENTER_NEW_DATE ;
                break ;

                /*   case JAPAN:
                     case CHINA:
                     case SWEDEN:
                     case FCANADA:    @@ */
            case YYMMDD:
                dformat = MSG_ENTER_JAPAN_DATE ;
                break ;

            default:
                dformat = MSG_ENTER_DEF_DATE ;
            } ;

            if ( call == EDATE )
                PutStdOut(dformat, ONEARG, DateSeparator );
            else
                PutStdOut(MSG_ENTER_NEW_TIME, NOARGS);

            scan = LocalBuf;
            ret = ReadBufFromInput(CRTTONT(STDIN),LocalBuf,MAX_PATH,&cbRead);
            if (ret && cbRead != 0) {

                *(scan + cbRead) = NULLC ;

            } else {

                //
                // attempt to read past eof or error in pipe
                // etc.
                //
                return( FAILURE );

            }
            for (scan = LocalBuf; *scan; scan++)
                if ( (*scan == '\n') || (*scan == '\r' )) {
                    *scan = '\0';
                    break;
                }
            if (!FileIsDevice(STDIN))
                cmd_printf(Fmt17, LocalBuf) ;
            DEBUG((CLGRP, DALVL|TILVL, "GVSDT: LocalBuf = `%s'", LocalBuf)) ;
        }

        _tcscpy( separators, dtseps);
        _tcscat( separators, TEXT(";") );
        if (*(dtstr = TokStr(LocalBuf,separators, TS_SDTOKENS )) == NULLC)
            return( SUCCESS ) ;    /* If empty input, return   */

/*  - Fill date/time buffer with correct date time and overlay that
 *        of the user
 */
        GetLocalTime( &OsDateAndTime );


        if (((call == EDATE) ? VerifyDateString(&OsDateAndTime,dtstr,dtseps) :
             VerifyTimeString(&OsDateAndTime,dtstr,dtseps))) {

            if (SetDateTime( &OsDateAndTime )) {
                return( SUCCESS ) ;
            } else {
                if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD) {
                    PutStdErr(GetLastError(),NOARGS);
                    return( FAILURE );
                }
            }
        }

        DEBUG((CLGRP, DALVL|TILVL, "GVSDT: Bad date/time entered.")) ;

        PutStdOut(((call == EDATE) ? MSG_INVALID_DATE : MSG_REN_INVALID_TIME), NOARGS);
        *dtstr = NULLC ;
    }
    return( SUCCESS );
}


/***    VerifyDateString - verifies a date string
 *
 *  Purpose:
 *      To verify a date string and load it into OsDateAndTime.
 *
 *  VerifyDateString(TCHAR *dtoks, TCHAR *dseps)
 *
 *  Args:
 *      OsDateAndTime - where to store output numbers.
 *      dtoks - tokenized date string
 *      dseps - valid date separator characters
 *
 *  Returns:
 *      TRUE if the date string is valid.
 *      FALSE if the date string is invalid.
 *
 */

VerifyDateString(OsDateAndTime, dtoks, dseps)
LPSYSTEMTIME OsDateAndTime ;
TCHAR *dtoks ;
TCHAR *dseps ;
{
    int indexes[3] ;                /* Storage for date elements       */
    int i ;                         /* Work variable                   */
    int y, d, m ;                   /* Array indexes                   */

    switch (DateFormat) {   /* Set array according to date format   */
    case MMDDYY:
        m = 0 ;
        d = 1 ;
        y = 2 ;
        break ;

    case YYMMDD:
        y = 0 ;
        m = 1 ;
        d = 2 ;
        break ;

    default:
        d = 0 ;
        m = 1 ;
        y = 2 ;
    }

    DEBUG((CLGRP, DALVL, "VDATES: m = %d, d = %d, y = %d", m, d, y)) ;

/*  Loop through the tokens in dtoks, and load them into the array.  Note
 *  that the separators are also tokens in the string requiring the token
 *  pointer to be advanced twice for each element.
 */
    for (i = 0 ; i < 3 ; i++, dtoks += _tcslen(dtoks)+1) {
        TCHAR *j;
        int Length;

        DEBUG((CLGRP, DALVL, "VDATES: i = %d  dtoks = `%ws'", i, dtoks)) ;


        //
        //  The atoi() return code will not suffice to reject date field strings with
        //  non-digit characters.  It is zero, both for error and for the valid integer
        //  zero.  Also, a string like "8$" will return 8.  For that reason, each
        //  character must be tested.
        //

        j = dtoks;
        while (*j != TEXT( '\0' )) {
            if (!_istdigit( *j )) {
                return FALSE;
            }
            j++;
        }

        //
        //  Verify lengths:
        //      years can be 2 or 4 chars in length
        //      Days can be 1 or 2 chars in length
        //      Months can be 1 or 2 chars in length
        //

        indexes[i] = _tcstol(dtoks, NULL, 10) ;

        Length = (int)(j - dtoks);
        if (i == y) {
            if (Length != 2 && Length != 4) {
                return FALSE;
            } else if (Length == 4 && indexes[i] < 1600) {
                return FALSE;
            }
        } else
            if (Length != 1 && Length != 2) {
            return FALSE;
        }


        dtoks = j + 1;
        DEBUG((CLGRP, DALVL, "VDATES: *dtoks = %02x", *dtoks)) ;

        if (i < 2 && (!*dtoks || !_tcschr(dseps, *dtoks)))
            return(FALSE) ;
    }

    //
    // FIX,FIX - need to calculate OsDateAndTime->wDayOfWeek
    //

    OsDateAndTime->wDay = (WORD)indexes[d] ;
    OsDateAndTime->wMonth = (WORD)indexes[m] ;

    //
    //  Take two-digit years and convert them appropriately:
    //      80...99 => 1980...1999
    //      00...79 => 2000...2079
    //
    //  Four-digit years are taken at face value
    //

    if (indexes[y] < 0) {
        return FALSE;
    } else if (00 <= indexes[y] && indexes[y] <= 79) {
        indexes[y] += 2000;
    } else if (80 <= indexes[y] && indexes[y] <= 99) {
        indexes[y] += 1900;
    } else if (100 <= indexes[y] && indexes[y] <= 1979) {
        return FALSE;
    }

    OsDateAndTime->wYear = (WORD)indexes[y] ;
    return(TRUE) ;
}




/***    VerifyTimeString - verifies a time string
 *
 *  Purpose:
 *      To verify a date string and load it into OsDateAndTime.
 *
 *  VerifyTimeString(TCHAR *ttoks)
 *
 *  Args:             /
 *      OsDateAndTime - where to store output numbers.
 *      ttoks - Tokenized time string.  NOTE: Each time field and each
 *              separator field is an individual token in the time string.
 *              Thus the token advancing formula "str += mystrlen(str)+1",
 *              must be used twice to go from one time field to the next.
 *
 *  Returns:
 *      TRUE if the time string is valid.
 *      FALSE if the time string is invalid.
 *
 */

VerifyTimeString(OsDateAndTime, ttoks, tseps)
LPSYSTEMTIME OsDateAndTime ;
TCHAR *ttoks ;
TCHAR *tseps ;
{
    int i ;     /* Work variables    */
    int j ;
    TCHAR *p1, *p2;
    WORD *pp;
    TCHAR tsuffixes[] = TEXT("aApP");

    p2 = &tseps[ 1 ];

    pp = &OsDateAndTime->wHour;

    for (i = 0 ; i < 4 ; i++, ttoks += mystrlen(ttoks)+1) {

        DEBUG((CLGRP,TILVL, "VTIMES: ttoks = `%ws'  i = %d", ttoks, i)) ;

/* First insure that field is <= 2 bytes and they are digits.  Note this
 * also verifies that field is present.
 */

        if ((j = mystrlen(ttoks)) > 2 ||
            !_istdigit(*ttoks) ||
            (*(ttoks+1) && !_istdigit(*(ttoks+1))))
            break;

        *pp++ = (TCHAR)_tcstol(ttoks, NULL, 10) ;     /* Field OK, store int     */
        ttoks += j+1 ;                  /* Adv to separator tok    */

        DEBUG((CLGRP, TILVL, "VTIMES: separator = `%ws'", ttoks)) ;

        if (!*ttoks)                    /* No separator field?     */
            break ;                     /* If so, exit loop        */

/*  handle AM or PM
 */
        if (mystrchr(tsuffixes, *ttoks)) {
            goto HandleAMPM;
        }
/*  M000 - Fixed ability to use '.' as separator for time strings
 */
        if ( i < 2 ) {
            if ( ! (p1 = mystrchr(tseps, *ttoks) ) )
                return(FALSE) ;

        } else {
            if (*ttoks != *p2)              /* Is decimal seperator */
                return(FALSE) ;     /* valid.               */
        }
    } ;

    //
    // see if there's an a or p specified.  if there's a P, adjust
    // for PM time
    //

    if (*ttoks) {
        BOOL pm;
        if (!mystrchr(tsuffixes, *ttoks)) {
            return FALSE;
        }
        HandleAMPM:
        pm = (*ttoks == TEXT('p') ||  *ttoks == TEXT('P'));

        // if we're here, we've encountered an 'a' or 'p'.  make
        // sure that it's the last character or that the only
        // character left is an 'm'.  remember that since
        // 'a' and 'p' are separators, they get separated from the 'm'.

        ttoks += 2; // go past 'a' or 'p' plus null.
        if (*ttoks != NULLC &&
            *ttoks != TEXT('m') &&
            *ttoks != TEXT('M')) {
            return FALSE;
        }
        if (pm) {
            if (OsDateAndTime->wHour != 12) {
                OsDateAndTime->wHour += 12;
            }
        } else {
            if (OsDateAndTime->wHour == 12) {
                OsDateAndTime->wHour -= 12;
            }
        }
    }


/*  M002 - If we got at least one field, fill the rest with 00's
 */
    while (++i < 4)
        *pp++ = 0 ;

    return(TRUE) ;
}

VOID
ConverttmToFILETIME (
                    struct tm *Time,
                    LPFILETIME FileTime
                    )

/*++

Routine Description:

    This routine converts an NtTime value to its corresponding Fat time
    value.

Arguments:

    Time - Supplies the C Runtime Time value to convert from

    FileTime - Receives the equivalent File date and time

Return Value:

    BOOLEAN - TRUE if the Nt time value is within the range of Fat's
        time range, and FALSE otherwise

--*/

{
    SYSTEMTIME SystemTime;

    if (!Time) {
        GetSystemTime(&SystemTime);
    } else {

        //
        //  Pack the input time/date into a system time record
        //

        SystemTime.wYear      = (WORD)Time->tm_year;
        SystemTime.wMonth         = (WORD)(Time->tm_mon+1);     // C is [0..11]
        // NT is [1..12]
        SystemTime.wDay       = (WORD)Time->tm_mday;
        SystemTime.wHour      = (WORD)Time->tm_hour;
        SystemTime.wMinute    = (WORD)Time->tm_min;
        SystemTime.wSecond    = (WORD)Time->tm_sec;
        SystemTime.wDayOfWeek = (WORD)Time->tm_wday;
        SystemTime.wMilliseconds = 0;
    }
    SystemTimeToFileTime( &SystemTime, FileTime );

}

VOID
ConvertFILETIMETotm (
                    LPFILETIME FileTime,
                    struct tm *Time
                    )

/*++

Routine Description:

    This routine converts a file time to its corresponding C Runtime time
    value.

Arguments:

    FileTime - Supplies the File date and time to convert from

    Time - Receives the equivalent C Runtime Time value

Return Value:

--*/

{
    SYSTEMTIME SystemTime;

    // why skip printing the date if it's invalid?
    //if (FileTime->dwLowDateTime == 0 && FileTime->dwHighDateTime == 0) {
    //    return( FALSE );
    //    }

    FileTimeToSystemTime( FileTime, &SystemTime );


    //
    //  Pack the input time/date into a time field record
    //

    Time->tm_year         = SystemTime.wYear;
    Time->tm_mon          = SystemTime.wMonth-1;    // NT is [1..12]
                                                    // C is [0..11]
    Time->tm_mday         = SystemTime.wDay;
    Time->tm_hour         = SystemTime.wHour;
    Time->tm_min          = SystemTime.wMinute;
    Time->tm_sec          = SystemTime.wSecond;
    Time->tm_wday         = SystemTime.wDayOfWeek;
    Time->tm_yday         = 0;
    Time->tm_isdst        = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cdebug.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cdebug.c

Abstract:

    Internal debugging support

--*/

#include "cmd.h"

#if CMD_DEBUG_ENABLE
/***	MSDOS Ver 4.0 Command Interpreter    Part 20 of 22  CDEBUG.C
 *
 *  This file contains all of the C routines in Command's debugging
 *  package.
 *
 *  The printing of debugging messages can be sectionally enabled at
 *  runtime through the first 2 arguments passed to this program.  The
 *  first one controls the groups to enable and the second one controls
 *  the level of detail in the groups to enable. (Numbers are in hex.)
 *
 *  Group   Level   Meaning
 *  ===========================================================
 *   0001	Main Command Loop Code (Main & Dispatch)
 *	 0001	    Main function
 *	 0002	    Dispatch function
 *   0002	Command Initialization
 *	 0001	    Argument checking
 *	 0002	    Environment initialization
 *	 0004	    Rest of initialization
 *   0004	Parser
 *	 0001	    Parsing
 *	 0002	    Lexing
 *	 0004	    Input routine
 *	 0008	    Dump parse tree to stdin
 *	 0010	    Byte input routine
 *   0008	Operators
 *	 0001	    Pipe level
 *	 0002	    Detach level
 *	 0004	    Other operators level
 *   0010	Path Commands
 *	 0001	    Mkdir level
 *	 0002	    Chdir level
 *	 0004	    Rmdir level
 *   0020	File Commands
 *	 0001	    Copy level
 *	 0002	    Delete level
 *	 0004	    Rename level
 *   0040	Informational Commands
 *	 0001	    Directory level
 *	 0002	    Type level
 *	 0004	    Version level
 *	 0008	    Volume level
 *	 0016	    Priv level
 *	 0032	    Console Level
 *	 0064	    Dislplay Level
 *   0080	Environment Commands
 *	 0001	    Path level
 *	 0002	    Prompt level
 *	 0004	    Set level
 *	 0008	    Other envirnment functions
 *       0010	    Environment scanning for external commands
 *   0100	Batch Processor
 *	 0001	    Batch processor
 *	 0002	    FOR processor
 *	 0004	    IF processor
 *	 0008	    Other batch commands
 *   0200	External Command Execution
 *	 0001	    External commands level
 *   0400	Other Commands
 *	 0001	    Break command
 *	 0002	    Cls command
 *	 0004	    Ctty command
 *	 0008	    Exit command
 *	 0010	    Verify command
 *   0800	Signal Handler
 *	 0001	    Main Signal handler level
 *	 0002	    Init Signal handler level
 *   1000	Memory Manager
 *	 0001	    Memory allocators
 *	 0002	    List managers
 *	 0004	    Segment manipulators
 *   2000	Common command tools
 *	 1000	    ScanFSpec level
 *	 2000	    SetFSSetAndSaveDir() level
 *       4000       TokStr() level
 *       8000       FullPath level
 *   4000	Clock manipulators
 *	 0001	    Date command level
 *	 0002	    Time command level
 *
 *
 *  None of the debugging code is included in the program if the
 *  value DBG is defined.
 *
 *
 *  Eric K. Evans, Microsoft
 */

/***	Modification History
 *
 */

extern unsigned DebGroup ;
extern unsigned DebLevel ;



/***	Deb - conditionally print debugging messages
 *
 *  Deb(MsgGroup, MsgLevel, msg, arg0, arg1, arg2, arg3, arg4)
 *
 *  Args:
 *	MsgGroup - The group of the message that wants to be printed.
 *	MsgLevel - The level of the message that wants to be printed.
 *	msg  - A printf style message string.
 *	arg0-4	 - The other args to be printed.
 *
 */
void
Deb(ULONG MsgGroup, ULONG MsgLevel, CHAR *msg, ...)
{
        CHAR  Buffer[ 512 ];
	va_list     args;
	CHAR	*pch = Buffer;
	int	cb;


	va_start( args, msg );
	cb = _vsnprintf( Buffer, 512, msg, args );
	va_end( args );
	if (cb > 512)
            fprintf(stderr, "Debug output buffer length exceeded - crash imminent\n");
        Buffer[511] = '\0'; // null-terminate the buffer in case the _vsnprintf filled the buffer

	while (*pch) {
		if (*pch == '\n' || *pch == '\r')
			*pch = '#';
		pch++;
	}

	if ((MsgGroup & DebGroup) && (MsgLevel & DebLevel)) {
		OutputDebugStringA(Buffer);
		OutputDebugStringA("\n");
	}
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cbatch.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cbatch.c

Abstract:

    Batch file processing

--*/

#include "cmd.h"


struct batdata *CurrentBatchFile = NULL;

int EchoFlag = E_ON;           /* E_ON = commands are to be echoed        */
int EchoSave;                  /* M016 - Save echo status here            */

extern int Necho;

BOOLEAN GotoFlag = FALSE;      /* TRUE = eGoto() found a label            */

TCHAR *Fvars = NULL;
TCHAR **Fsubs = NULL;
TCHAR *save_Fvars = NULL; /* @@ */
TCHAR **save_Fsubs = NULL; /* @@ */
int  FvarsSaved = FALSE; /* @@ */

extern UINT CurrentCP;
extern ULONG DCount;                   /* M031 */
extern unsigned DosErr;                /* M033 */
extern unsigned flgwd;                 /* M040 */

/*  M011 - Removed RemStr, BatSpecStr, NewBatName and OldBatName from
 *         external declarations below.
 */

extern TCHAR CurDrvDir[];

extern TCHAR Fmt02[], Fmt11[], Fmt12[], Fmt13[], Fmt15[], Fmt17[], Fmt18[]; /* M024 */
extern TCHAR Fmt20[];                  /* M017/M024                       */
extern TCHAR Fmt00[]; /* @@4 */

extern TCHAR TmpBuf[];                 /* M030 - Used for GOTO search     */
extern CHAR  AnsiBuf[];
extern TCHAR GotoStr[];
extern TCHAR GotoEofStr[];
extern TCHAR ForStr[];
extern TCHAR ForLoopStr[];
extern TCHAR ForDirTooStr[];
extern TCHAR ForParseStr[];
extern TCHAR ForRecurseStr[];

extern int LastRetCode;
extern TCHAR chCompletionCtrl;
extern TCHAR chPathCompletionCtrl;
extern unsigned global_dfvalue; /* @@4 */
extern TCHAR LexBuffer[];       /* @@4 */

extern TCHAR SwitChar;         /* M020 - Reference global switch byte     */

extern BOOL CtrlCSeen;
void    CheckCtrlC();

extern jmp_buf MainEnv;

#define BIG_BAT_NEST             200
#define MAX_STACK_USE_PERCENT     90

BOOLEAN flChkStack;
int     CntBatNest;
PVOID   FixedPtrOnStack;

typedef struct {
    PVOID   Base;
    PVOID   GuardPage;
    PVOID   Bottom;
    PVOID   ApprxSP;
} STACK_USE;

STACK_USE   GlStackUsage;


#define DEFAULT_DELIMS  TEXT( " \t" )

// to handle OS/2 vs DOS errorlevel setting rules in a script files.

int  glBatType = NO_TYPE;

/***    ChkStack - check the stack usage
 *
 *  Args:
 *      pFixed    - fixed pointer on stack
 *      pStackUse - struct stack info to return to caller
 *
 *  Returns:
 *      FAILURE   - if stack info is not good
 *      SUCCESS   - otherwise
 *
 *  Notes:
 *      See the comments below about Stack Pointer
 *
 *
 */

int ChkStack (PVOID pFixed, STACK_USE *pStackUse )

{
    MEMORY_BASIC_INFORMATION    Mbi;
    PVOID                       BasePtr;
    PCHAR                       WalkPtr;
    int                         cnt;
    PVOID                       ThreadStackBase,
    ThreadStackLimit;
    CHAR                        VarOnStack;            // keep this automatic var. here !


    // 950119 the best (right) way to find the Current Stack Pointer is
    // to write assembly code for all platforms.
    // I implemented the most portable code. It should work OK with current NT
    // memory models. If NT memory models change then a lot of code will have to
    // be re-written anyway. Several NT projects rely on same assumption.
    // I also have consistency test for all pointers.

    pStackUse->ApprxSP = (VOID *) &VarOnStack;    // address of automatic variable
                                                  // should be close to current SP


    // suggested by MarkL 950119

    ThreadStackBase =  (PVOID) (NtCurrentTeb()->NtTib.StackBase );
    ThreadStackLimit = (PVOID) (NtCurrentTeb()->NtTib.StackLimit );

    if ( (pStackUse->ApprxSP >= ThreadStackBase) ||
         (pStackUse->ApprxSP <= ThreadStackLimit ) )

        return(FAILURE);


    if ( (pFixed >= ThreadStackBase) ||
         (pFixed <= ThreadStackLimit ) )

        return(FAILURE);



    // 1. Pass fixed on-the-stack pointer to find out the base address.

    if ( (VirtualQuery (pFixed, &Mbi, sizeof(Mbi) ) ) != sizeof (Mbi) )
        return(FAILURE);


    BasePtr = Mbi.AllocationBase;



    // 2. walk all the Virtual Memory Regions with same Allocation Base Address.

    cnt = 0;

    for (WalkPtr = (CHAR *)BasePtr;  Mbi.AllocationBase == BasePtr;  WalkPtr += Mbi.RegionSize) {

        if ( (VirtualQuery ( (PVOID) WalkPtr, &Mbi, sizeof(Mbi) ) ) != sizeof (Mbi) )
            return(FAILURE);

        if (cnt == 0) {
            if (Mbi.BaseAddress != Mbi.AllocationBase)
                return(FAILURE);
        }



        if (Mbi.Protect & PAGE_GUARD)
            pStackUse->GuardPage = Mbi.BaseAddress;

        if (Mbi.AllocationBase == BasePtr)
            pStackUse->Bottom =  (PVOID) ( ( (CHAR *) Mbi.BaseAddress) + Mbi.RegionSize);


        cnt++;

        if (cnt >= 1000)               // normally there are 3 regions : committed, guard, reserved.
            return(FAILURE);

    }


    pStackUse->Base = BasePtr;


    if ( pStackUse->Bottom != ThreadStackBase)
        return(FAILURE);


    if ( ( pStackUse->Base   != GlStackUsage.Base) ||
         ( pStackUse->Bottom != GlStackUsage.Bottom ) ||
         ( pStackUse->Bottom <= pStackUse->Base ) )

        return(FAILURE);



    return(SUCCESS);

}


/***    BatAbort - terminate the batch processing unconditionally.
 *
 *  Notes:
 *      Similar to CtrlCAbort()
 *
 *
 */

void BatAbort ()

{

    struct batdata *bdat;


    //
    //  End local environments ( Otherwise we can end up with garbage
    //  in the main environment if any batch file used the setlocal
    //  command ).
    //

    if (CurrentBatchFile) {

        bdat = CurrentBatchFile;
        while ( bdat ) {
            EndAllLocals( bdat );
            bdat = bdat->backptr;
        }
    }

    SigCleanUp();

    CntBatNest = 0;

    longjmp(MainEnv, 1);

}



//
// Used to set and reset ctlcseen flag
//
VOID    SetCtrlC();
VOID    ResetCtrlC( );


/***    BatProc - does the set up before and the cleanup after batch processing
 *
 *  Purpose:
 *      Set up for the execution of a batch job.  If this job is being
 *      chained, (will come here only if part of compound statement),
 *      use the existing batch data structure thereby ending execution
 *      of the existing batch job (though still keeping its stack and data
 *      usage).  If this is the first job or this job is being called,
 *      allocate a new batch data structure.  In either case, use SetBat
 *      to fill the structure and prepare the job, then call BatLoop to
 *      at least begin the execution.  When this returns at completion,
 *      check the env and dircpy fields of the data structure to see if
 *      the current directory and environment need to be reset.  Finally,
 *      turn on the echoflag if no more batch jobs are on the stack.
 *
 *      There are 3 ways to execute a batch job.  They are:
 *              1.  Exactly as DOS 3.x.  This is the default method and
 *                  occurs whenever a batch file is simply executed at the
 *                  command line or chained by another batch file.  In the
 *                  former case, it is the first job and will go through
 *                  BatProc, else it will be detected in BatLoop and will
 *                  will simply replace its parent.
 *              2.  Nested via the CALL statement.  This is new functionality
 *                  and provides the means of executing the child batch
 *                  file and returning to the parent.
 *              3.  Invocation of an external batch processor via ExtCom()
 *                  which then executes the batch file.  This is accomplished
 *                  by the first line of the batch file being of the form:
 *
 *                      ExtProc <batch processor name> [add'l args]
 *
 *  int BatProc(struct cmdnode *n, TCHAR *fname, int typflag)
 *
 *  Args:
 *      n - parse tree node containing the batch job command
 *      fname - the name of the batch file (MUST BE MAX_PATH LONG!)
 *      typflg - 0 = Normal batch file execution
 *               1 = Result of CALL statement
 *
 *  Returns:
 *      FAILURE if the batch processor cannot execute the batch job.
 *      Otherwise, the retcode of the last command in which was executed.
 *
 */

int BatProc(n, fname, typflg)
struct cmdnode *n;
TCHAR *fname;
int typflg;                            /* M011 - "how called" flag        */
{
    struct batdata *bdat;          /* Ptr to new batch data struct    */
    int batretcode;                 /* Retcode - last batch command    */
    int istoplevel;
    struct envdata *CopyEnv();
    SIZE_T         StackUsedPerCent;
    STACK_USE      StackUsage;

#ifdef USE_STACKAVAIL                     // unfortunately not available
    if ( stackavail() < MINSTACKNEED ) { /*  If not enough stack @@4 */
        /*  space, stop processing  */
        PutStdErr(MSG_TRAPC,ONEARG,Fmt00); /* @@4 */
        return(FAILURE);
    }
#endif

    DEBUG((BPGRP,BPLVL,"BP: fname = %ws  argptr = %ws", fname, n->argptr));




/*  M016 - If this is the first batch file executed, the interactive echo
 *         status is saved for later restoration.
 */

    if (!CurrentBatchFile) {
        EchoSave = EchoFlag;
        istoplevel = 1;
        CntBatNest = 0;
    } else
        istoplevel = 0;


    // to check stack only if we are looping too much,
    // to avoid unnecessary overhead

    if (flChkStack && ( CntBatNest > BIG_BAT_NEST ) ) {
        if ( ChkStack (FixedPtrOnStack, &StackUsage) == FAILURE ) {
            flChkStack = 0;
        } else {
            GlStackUsage.GuardPage = StackUsage.GuardPage;
            GlStackUsage.ApprxSP   = StackUsage.ApprxSP;

            StackUsedPerCent = ( ( (UINT_PTR)StackUsage.Bottom - (UINT_PTR)StackUsage.ApprxSP) * 100 ) /
                               ( (UINT_PTR)StackUsage.Bottom - (UINT_PTR)StackUsage.Base );

            if ( StackUsedPerCent >= MAX_STACK_USE_PERCENT ) {
                PutStdErr(MSG_ERROR_BATCH_RECURSION,
                          TWOARGS,
                          CntBatNest,
                          StackUsedPerCent );

                // if ^C was reported by "^C thread" then handle it here, before calling BatAbort().

                CheckCtrlC();

                BatAbort();
            }
        }
    }


    if (typflg)
        CntBatNest++;


/*  M011 - Altered to conditionally build a new data structure based on the
 *         values of typflg and CurrentBatchFile.  Provided the first structure has
 *         been built, chained files no longer cause a new structure, while
 *         CALLed files do.  Also, backpointer and CurrentBatchFile are set here
 *         rather than in BatLoop() as before.  Finally, note that the
 *         file position indicator bdat->filepos must be reset to zero now
 *         when a new file is exec'd. Otherwise a chained file using the old
 *         structure would start off where the last one ended.
 */
    if (typflg || !CurrentBatchFile) {

        DEBUG((BPGRP,BPLVL,"BP: Making new structure"));

        bdat = (struct batdata *) mkstr(sizeof(struct batdata));
        if ( ! bdat )
            return( FAILURE );
        bdat->backptr = CurrentBatchFile;

    } else {

        DEBUG((BPGRP,BPLVL,"BP: Using old structure"));
        bdat = CurrentBatchFile;
    }

    CurrentBatchFile = bdat;         /* Takes care of both cases                */

/*  M011 ends   */
    bdat->stackmin = DCount;               /* M031 - Fix datacount    */
    mystrcpy(TmpBuf,fname);                        /* Put where expected      */


    if (SetBat(n, fname))                   /* M031 - All work done    */
        return(FAILURE);               /* ...in SetBat now        */

#ifndef WIN95_CMD
    // Following two CmdBatNotification calls are being made to
    // let NTVDM know that the binary is coming from a .bat/.cmd
    // file. Without this all those DOS .bat programs are broken which
    // first run a TSR and then run a real DOS app. There are a lot
    // of such cases, Ventura Publisher, Civilization and many more
    // games which first run a TSR. If .bat/.cmd does'nt have any
    // DOS binary these calls dont have any effect.

    if (istoplevel) {

        // to determine the type of the script file: CMD or BAT
        // to decide how to handle the errorlevel

        glBatType = BAT_TYPE;           // default


        if (fname && (mystrlen(fname) >= 5) ) {
            PTCHAR         tmp;

            tmp = fname + mystrlen(fname) - 1;

            if ( ( (*tmp     == TEXT ('D')) || (*tmp     == TEXT ('d')) ) &&
                 ( (*(tmp-1) == TEXT ('M')) || (*(tmp-1) == TEXT ('m')) ) &&
                 ( (*(tmp-2) == TEXT ('C')) || (*(tmp-2) == TEXT ('c')) ) &&
                 ( *(tmp-3) == DOT ) ) {

                glBatType = CMD_TYPE;
            }
        }

        CmdBatNotification (CMD_BAT_OPERATION_STARTING);
    }
#endif // WIN95_CMD

    batretcode = BatLoop(bdat,n);                          /* M039    */

    if (istoplevel) {
#ifndef WIN95_CMD
        CmdBatNotification (CMD_BAT_OPERATION_TERMINATING);
#endif // WIN95_CMD
        CntBatNest = 0;
        glBatType  = NO_TYPE;
    }


    DEBUG((BPGRP, BPLVL, "BP: Returned from BatLoop"));
    DEBUG((BPGRP, BPLVL, "BP: bdat = %lx CurrentBatchFile = %lx",bdat,CurrentBatchFile));

/*  M011 - Now that setlocal and endlocal control the saving and restoring
 *         of environments and current directories, it is necessary to
 *         check each batch data structure before popping it off the stack
 *         to see if its file issued a SETLOCAL command.  EndAllLocals() tests
 *         the env and dircpy fields, doing nothing if no localization
 *         needs to be reset.  No tests need be done before calling it.
 */
    if (CurrentBatchFile == bdat) {
        DEBUG((BPGRP, BPLVL, "BP: bdat=CurrentBatchFile, calling EndAllLocals"));
        EndAllLocals(bdat);
        CurrentBatchFile = bdat->backptr;
        if (CntBatNest > 0)
            CntBatNest--;
    }

    if (CurrentBatchFile == NULL) {
        EchoFlag = EchoSave;   /* M016 - Restore echo status      */
        CntBatNest = 0;
    }

    DEBUG((BPGRP, BPLVL, "BP: Exiting, CurrentBatchFile = %lx", CurrentBatchFile));

    return(batretcode);
}




/***    BatLoop - controls the execution of batch files
 *
 *  Purpose:
 *      Loop through the statements in a batch file.  Do the substitution.
 *      If this is the first statement and it is a REM command, call eRem()
 *      directly to check for possible external batch processor invocation.
 *      Otherwise, call Dispatch() to execute it and continue.
 *
 *  BatLoop(struct batdata *bdat, struct cmdnode *c) (M031)
 *
 *  Args:
 *      bdat - Contains info needed to execute the current batch job
 *      c    - The node for this batch file (M031)
 *
 *  Returns:
 *      The retcode of the last command in the batch file.
 *
 *  Notes:
 *      Execution should end if the target label of a Goto command is not
 *      found, a signal is received or an unrecoverable error occurs.  It
 *      will be indicated by the current batch data structure being
 *      popped off the batch jobs stack and is detected by comparing
 *      CurrentBatchFile and bdat.  If they aren't equal, something happened so
 *      return.
 *
 *      GotoFlag is reset everytime through the loop to make sure that
 *      execution resumes after a goto statement is executed.
 *
 */

BatLoop(bdat,c)
struct batdata *bdat;
struct cmdnode *c;
{
    struct node *n;                /* Ptr to next statement           */
    BOOL fSilentNext;

    int firstline = TRUE;           /* TRUE = first valid line         */
    CRTHANDLE       fh;            /* Batch job file handle           */
    int batretcode = SUCCESS;      /* Last Retcode (M008 init)        */
    fSilentNext = FALSE;

    for (; CurrentBatchFile == bdat; ) {

        CheckCtrlC();
        GotoFlag = FALSE;

        //
        // If extensions are enabled, this is the first line in the
        // file and it begins with a COLON, then we got here via
        // CALL :label, so turn this into a GOTO :label command
        // as BatProc/SetBat have already done the work of pushing
        // our state and parsing the arguments.
        //
        if (fEnableExtensions && firstline && *c->cmdline == COLON) {
            struct cmdnode *c1;
            c1 = (struct cmdnode *)mknode();
            if (c1 == NULL) {
                PutStdErr(MSG_NO_MEMORY, NOARGS );
                return( FAILURE );
            }

            c1->type = CMDTYP;

            c1->cmdline = mkstr((mystrlen(GotoStr)+1)*sizeof(TCHAR));
            if (c1->cmdline == NULL) {
                PutStdErr(MSG_NO_MEMORY, NOARGS );
                return FAILURE;
            }

            mystrcpy(c1->cmdline, GotoStr);

            c1->argptr = mkstr((mystrlen(c->cmdline)+1)*sizeof(TCHAR));
            if (c1->argptr == NULL) {
                PutStdErr(MSG_NO_MEMORY, NOARGS );
                return FAILURE;
            }

            mystrcpy(c1->argptr, c->cmdline);

            *(c1->argptr) = SPACE;

            //
            // Set a flag so eGoTo does not try to abort a FOR loop
            // because of one of these new CALL forms.
            //
            c1->flag = CMDNODE_FLAG_GOTO;

            //
            // Then again, maybe not.  I have to think about this some
            // more.
            //
            c1->flag = 0;
            n = (struct node *)c1;
            //
            // Since we generated this GOTO statement, dont let the user
            // know
            //
            fSilentNext = TRUE;
        } else {
            //
            // Open and position the batch file to where next statement
            //
            if ((fh = OpenPosBat(bdat)) == BADHANDLE)
                return( FAILURE);              /* Ret if error    */


            DEBUG((BPGRP, BPLVL, "BLOOP: fh = %d", (ULONG)fh));


            n = Parser(READFILE, (INT_PTR)fh, bdat->stacksize); /* Parse   */
            bdat->filepos = _tell(fh); // next statement
            Cclose(fh);

            if ((n == NULL) || (n == (struct node *) EOS)) {
                continue;
            }

            DEBUG((BPGRP, BPLVL, "BLOOP: node = %x", n));
            DEBUG((BPGRP, BPLVL, "BLOOP: fpos = %lx", bdat->filepos));

/*  If syntax error, it is impossible to continue so abort.  Note that
 *  the Abort() function doesn't return.
 */
            if ( ( n == (struct node *)PARSERROR) ||   /* If error...*/
/* @@4 */               ( global_dfvalue == MSG_SYNERR_GENL ) )
            /* @@4 */
            {
                PSError();

                if ((EchoFlag == E_ON) && !Necho) {

                    DEBUG((BPGRP, BPLVL, "BLOOP: Displaying Statement."));

                    PrintPrompt();
                    PutStdOut(MSG_LITERAL_TEXT,ONEARG,&LexBuffer[1]);
                }
                Abort();                       /* ...quit         */
            }

            if (n == (struct node *) EOF)           /* If EOF...       */
                return(batretcode);            /* ...return also  */
        }

        DEBUG((BPGRP, BPLVL, "BLOOP: type = %d", n->type));

/*  M008 - By the addition of the second conditional term (&& n), any
 *         leading NULL lines in the batch file will be skipped without
 *         penalty.
 */
        if (firstline && n)             /* Kill firstline...       */
            firstline = FALSE;     /* ...when passed          */

/*  M008 - Don't prompt, display or dispatch if statement is label for Goto
 *  M009 - Altered second conditional below to test for REMTYP.  Was a test
 *         for CMDTYP and a strcmpi with the RemStr string.
 */
        if (n->type == CMDTYP &&
            *(((struct cmdnode *) n)->cmdline) == COLON)
            continue;

/*  M019 - Added extra conditional to test for leading SILent node
 */

        if (fSilentNext)
            fSilentNext = FALSE;
        else
            if (EchoFlag == E_ON && n->type != SILTYP && !Necho) {

            DEBUG((BPGRP, BPLVL, "BLOOP: Displaying Statement."));

            PrintPrompt();
            DisplayStatement(n, DSP_SIL);          /* M019    */
            cmd_printf(CrLf);                      /* M026    */
        }

        if ( n->type == SILTYP ) {       /*  @@ take care of */
            n = n->lhs;                 /*  @@ recursive batch files */
        } /* endif */

/* M031 - Chained batch files no longer go through dispatch.  They become
 *        simply an extention of the current one by adding their redirection
 *        and replacing the current batch data information with their own.
 */
        if ( n == NULL ) {
            batretcode = SUCCESS;
        } else if (n->type == CMDTYP &&
                   FindCmd(CMDHIGH, ((struct cmdnode *)n)->cmdline, TmpBuf) == -1 &&
/* M035 */          !mystrchr(((struct cmdnode *)n)->cmdline, STAR) &&
/* M035 */          !mystrchr(((struct cmdnode *)n)->cmdline, QMARK) &&
                   SearchForExecutable((struct cmdnode *)n, TmpBuf) == SFE_ISBAT) {

            DEBUG((BPGRP, BPLVL, "BLOOP: Chaining to %ws", bdat->filespec));
            if ((n->rio && AddRedir(c,(struct cmdnode *)n)) ||
                SetBat((struct cmdnode *)n, bdat->filespec)) {
                return(FAILURE);
            }
            firstline = TRUE;
            batretcode = SUCCESS;
        } else {

            DEBUG((BPGRP, BPLVL, "BLOOP: Calling Dispatch()..."));
            DEBUG((BPGRP, BPLVL, "BLOOP: ...node type = %d",n->type));

            batretcode = Dispatch(RIO_BATLOOP, n);
            {
                extern CPINFO CurrentCPInfo;

                ResetConsoleMode();
                //
                // Get current CodePage Info.  We need this to decide whether
                // or not to use half-width characters.
                //
                GetCPInfo((CurrentCP=GetConsoleOutputCP()), &CurrentCPInfo);
                //
                // Maybe console output code page was changed by CHCP or MODE,
                // so need to reset LanguageID to correspond to code page.
                //
#if !defined( WIN95_CMD )
                CmdSetThreadUILanguage(0);
#endif
        
            }

        }
    }

    DEBUG((BPGRP, BPLVL, "BLOOP: At end, returning %d", batretcode));
    DEBUG((BPGRP, BPLVL, "BLOOP: At end, CurrentBatchFile = %lx", CurrentBatchFile));
    DEBUG((BPGRP, BPLVL, "BLOOP: At end, bdat = %lx", bdat));

    return(batretcode);
}




/***    SetBat - Replaces current batch data with new. (M031)
 *
 *  Purpose:
 *      Causes a chained batch file's information to replace its parent's
 *      in the current batch data structure.
 *
 *  SetBat(struct cmdnode *n, TCHAR *fp)
 *
 *  Args:
 *      n  - pointer to the node for the chained batch file target.
 *      fp - pointer to filename found for batch file.
 *      NOTE: In addition, the batch filename will be in TmpBuf at entry.
 *
 *  Returns:
 *      FAILURE if memory could not be allocated
 *      SUCCESS otherwise
 *
 *  Notes:
 *    - WARNING - No allocation of memory must occur above the call to
 *      FreeStack().  When this call occurs, all allocated heap space
 *      is freed back to the empty batch data structure and its filespec
 *      string.  Any allocated memory would also be freed.
 *    - The string used for "->filespec" is that malloc'd by ECWork or
 *      eCall during the search for the batch file.  In the case of
 *      calls from BatLoop, the existing "->filespec" string is used
 *      by copying the new batch file name into it.  THIS STRING MUST
 *      NOT BE RESIZED!
 *
 */

int
SetBat(struct cmdnode *n, PTCHAR fp)
{
    int i;                 // Index counters
    int j;
    TCHAR *s;                      // Temp pointer

    SAFER_CODE_PROPERTIES CodeProps = {sizeof(SAFER_CODE_PROPERTIES), SAFER_CRITERIA_IMAGEPATH, 0};
    SAFER_LEVEL_HANDLE Level = NULL;

    DEBUG((BPGRP,BPLVL,"SETBAT: Entered"));
    CurrentBatchFile->filepos = 0;   // Zero position pointer
    CurrentBatchFile->filespec = fp; // Insure correct str
    CurrentBatchFile->hRestrictedToken = NULL; // Restricted token for batchfile

    //
    // If extensions are enabled and the command line begins with
    // a COLON then we got here via CALL :label, so update our
    // CurrentBatchFile file spec with our parents file spec, since we are
    // in the same file.
    //
    if (fEnableExtensions && *n->cmdline == COLON) {
        struct batdata *bdat;

        bdat = CurrentBatchFile->backptr;
        mystrcpy(CurrentBatchFile->filespec, bdat->filespec);
        CurrentBatchFile->filepos = bdat->filepos;
    } else {
        //
        // Otherwise old behavior is going to a new file.  Get its full name
        //
        if (FullPath(CurrentBatchFile->filespec, TmpBuf,MAX_PATH)) /* If bad name,   */
            return(FAILURE);               /* ...return failure       */
    }


    mystrcpy(TmpBuf, n->cmdline);          /* Preserve cmdline and    */
    *(s = TmpBuf+mystrlen(TmpBuf)+1) = NULLC; /* ...argstr in case this  */
    if (n->argptr)
        mystrcpy(s, n->argptr);            /* ...is a chain and node  */

    FreeStack(CurrentBatchFile->stackmin);           /* ...gets lost here       */

    DEBUG((BPGRP,BPLVL,"SETBAT: fspec = `%ws'",CurrentBatchFile->filespec));
    DEBUG((BPGRP,BPLVL,"SETBAT: orgargs = `%ws'",s));
    DEBUG((BPGRP,BPLVL,"SETBAT: Making arg0 string"));

    CurrentBatchFile->alens[0] = mystrlen(TmpBuf);
    CurrentBatchFile->aptrs[0] = mkstr( (CurrentBatchFile->alens[0]+1) * sizeof( TCHAR ) );
    if (CurrentBatchFile->aptrs[0] == NULL) {
        PutStdErr(MSG_NO_MEMORY, NOARGS );
        return(FAILURE);
    }
    mystrcpy(CurrentBatchFile->aptrs[0], TmpBuf);
    CurrentBatchFile->orgaptr0 = CurrentBatchFile->aptrs[0];

    DEBUG((BPGRP, BPLVL, "SETBAT: arg 0 = %ws", CurrentBatchFile->aptrs[0]));
    DEBUG((BPGRP, BPLVL, "SETBAT: len 0 = %d", CurrentBatchFile->alens[0]));
    DEBUG((BPGRP, BPLVL, "SETBAT: Zeroing remaining arg elements"));

    for (i = 1; i < 10; i++) {            /* Zero any previous       */
        CurrentBatchFile->aptrs[i] = 0;          /* ...arg pointers and     */
        CurrentBatchFile->alens[i] = 0;          /* ...length values        */
    }

    if (*s) {

        DEBUG((BPGRP,BPLVL,"SETBAT: Making orgargs string"));

        CurrentBatchFile->orgargs = mkstr( (mystrlen( s ) + 1) * sizeof( TCHAR ) );
        if (CurrentBatchFile->orgargs == NULL) {
            PutStdErr(MSG_NO_MEMORY, NOARGS );
            return(FAILURE);
        }

        //
        //  Strip leading spaces from orgargs
        //

        s += _tcsspn( s, TEXT( " \t" ));

        mystrcpy( CurrentBatchFile->orgargs, s );

        //
        //  Strip trailing spaces from orgargs
        //

        s = CurrentBatchFile->orgargs + mystrlen( CurrentBatchFile->orgargs );
        while (s != CurrentBatchFile->orgargs) {
            if (s[-1] != TEXT( ' ' ) && s[-1] != TEXT( '\t' )) {
                break;
            }
            s--;
        }

        *s = TEXT( '\0' );

        if (!fEnableExtensions) {
            //
            // /Q on batch script invocation only supported when extensions disabled
            //
            s = CurrentBatchFile->orgargs;
            while (s = mystrchr(s, SwitChar)) {
                if (_totupper(*(++s)) == QUIETCH) {
                    EchoFlag = E_OFF;
                    mystrcpy(s-1,s+1);
                    DEBUG((BPGRP,BPLVL,"SETBAT: Found Q switch, orgargs now = %ws",CurrentBatchFile->orgargs));
                    break;
                }
            }
        }

        DEBUG((BPGRP,BPLVL,"SETBAT: Tokenizing orgargs string"));

        s = TokStr(CurrentBatchFile->orgargs, NULL, TS_NOFLAGS);

        for (i = 1; *s && i < 10; s += j+1, i++) {
            CurrentBatchFile->aptrs[i] = s;
            CurrentBatchFile->alens[i] = j = mystrlen(s);
            DEBUG((BPGRP, BPLVL, "SETBAT: arg %d = %ws", i, CurrentBatchFile->aptrs[i]));
            DEBUG((BPGRP, BPLVL, "SETBAT: len %d = %d", i, CurrentBatchFile->alens[i]));
        }

        CurrentBatchFile->args = s;
    } else {

        DEBUG((BPGRP, BPLVL, "SETBAT: No args found, ptrs = 0"));

        CurrentBatchFile->orgargs = CurrentBatchFile->args = NULL;
    }

    CurrentBatchFile->stacksize = DCount;            /* Protect from parser     */

    //
    //  We delay load these routines in order to allow CMD to work on downlevel versions
    //

    ReportDelayLoadErrors = FALSE;
    
    try {

        //
        // Now get the restricted token to be used for this batch file.
        //

        CodeProps.ImagePath = (WCHAR *) CurrentBatchFile->filespec;

        //
        // Identify the level at which the code should be run.
        //

        if (SaferIdentifyLevel(1, &CodeProps, &Level, NULL)) {

            //
            // Compute the token from the level.
            //

            if (SaferComputeTokenFromLevel(Level, NULL, &CurrentBatchFile->hRestrictedToken, SAFER_TOKEN_NULL_IF_EQUAL, NULL)) {

                //
                // All is well. We have successfuly computed a restricted token for
                // the batch file. Close the handle to authorization level.
                //

                SaferCloseLevel(Level);

                //
                // Impersonate if a restricted token was returned by authorization.
                // The revert happens in EndAllLocals.
                //

                if (CurrentBatchFile->hRestrictedToken != NULL) {
                    if (!ImpersonateLoggedOnUser(CurrentBatchFile->hRestrictedToken)) {

                        // 
                        // We failed to impersonate. Close the token handle and 
                        // return failure.
                        //

                        CloseHandle(CurrentBatchFile->hRestrictedToken);
                        CurrentBatchFile->hRestrictedToken = NULL;
                        return(FAILURE);
                    }
                }


            } else {

                DWORD dwLastError = GetLastError();
                
                if (dwLastError == ERROR_ACCESS_DISABLED_BY_POLICY) {
                    SaferRecordEventLogEntry(
                        Level, 
                        (WCHAR *) CurrentBatchFile->filespec, 
                        NULL);
                                            
                        PutStdErr(MSG_EXEC_FAILURE, NOARGS );

                }

                //
                // We failed to compute the restricted token from the authorization level.
                // We will not run the batchfile.
                //

                CurrentBatchFile->hRestrictedToken = NULL;
                SaferCloseLevel(Level);
                return(FAILURE);

            }

        } else {

            //
            // In case of errors, return failure.
            //

            return(FAILURE);

        }
    } except (LastRetCode = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER) {
         if (LastRetCode != VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND)) {
             ReportDelayLoadErrors = TRUE;
             return FAILURE;
         }
    }

    ReportDelayLoadErrors = TRUE;

    DEBUG((BPGRP, BPLVL, "SETBAT: Stack set: Min = %d, size = %d",CurrentBatchFile->stackmin,CurrentBatchFile->stacksize));

    return(SUCCESS);
}




/***    DisplayStatement - controls the displaying of batch file statements
 *
 *  Purpose:
 *      Walk a parse tree to display the statement contained in it.
 *      If n is null, the node contains a label, or the node is SILTYP
 *      and flg is DSP_SIL, do nothing.
 *
 *  void DisplayStatement(struct node *n, int flg)
 *
 *  Args:
 *      n   - pointer to root of the parse tree
 *      flg - flag indicates "silent" or "verbose" mode
 *
 */

void DisplayStatement(n, flg)
struct node *n;
int flg;               /* M019 - New flag argument                */
{
    TCHAR *eqstr = TEXT("");

    void DisplayOperator(),
    DisplayRedirection();     /* M008 - Made void                */

/*  M019 - Added extra conditionals to determine whether or not to display
 *         any part of the tree that following a SILent node.  This is done
 *         based on a new flag argument which indicates SILENT or VERBOSE
 *         mode (DSP_SIL or DSP_VER).
 *         NOTE: When this routine is combined with pipes to xfer statements
 *         to a child Command.com via STDOUT, it will have to be changed in
 *         order to discriminate between the two purposes for which it is
 *         called.  Flag definitions already exist in CMD.H for this purpose
 *         (DSP_SCN & DSP_PIP).
 */
    if (!n ||
        (n->type == SILTYP && flg == DSP_SIL) ||
        ((((struct cmdnode *) n)->cmdline) &&
         *(((struct cmdnode *) n)->cmdline) == COLON))
        return;

    switch (n->type) {
    case LFTYP:
        DisplayOperator(n, CrLf);
        break;

    case CSTYP:
        DisplayOperator(n, CSSTR);
        break;

    case ORTYP:
        DisplayOperator(n, ORSTR);
        break;

    case ANDTYP:
        DisplayOperator(n, ANDSTR);
        break;

    case PIPTYP:
        DisplayOperator(n, PIPSTR);
        break;

    case SILTYP:
        CmdPutString( SILSTR );
        DisplayStatement(n->lhs, DSP_VER);
        DisplayRedirection(n);
        break;

    case PARTYP:

        DEBUG((BPGRP, BPLVL, "DST: Doing parens"));

        CmdPutString( LEFTPSTR );
        if (n->lhs->type == LFTYP)
            cmd_printf( CrLf );
        DisplayStatement(n->lhs, DSP_SIL);     /* M019    */
        if (n->lhs->type == LFTYP)
            cmd_printf( CrLf );
        cmd_printf(Fmt11, RPSTR);              /* M013 */
        DisplayRedirection(n);
        break;

    case FORTYP:

        DEBUG((BPGRP, BPLVL, "DST: Displaying FOR."));

        //
        // If extensions are enabled, handle displaying the new
        // optional switches on the FOR statement.
        //
        if (fEnableExtensions) {
            cmd_printf(TEXT("%.3s"), ((struct fornode *) n)->cmdline);
            if (((struct fornode *)n)->flag & FOR_LOOP)
                cmd_printf(TEXT(" %s"), ForLoopStr);
            else
                if (((struct fornode *)n)->flag & FOR_MATCH_DIRONLY)
                cmd_printf(TEXT(" %S"), ForDirTooStr);
            else
                if (((struct fornode *)n)->flag & FOR_MATCH_PARSE) {
                cmd_printf(TEXT(" %s"), ForParseStr);
                if (((struct fornode *)n)->parseOpts)
                    cmd_printf(TEXT(" %s"), ((struct fornode *)n)->parseOpts);
            } else
                if (((struct fornode *)n)->flag & FOR_MATCH_RECURSE) {
                cmd_printf(TEXT(" %s"), ForRecurseStr);
                if (((struct fornode *)n)->recurseDir)
                    cmd_printf(TEXT(" %s"), ((struct fornode *)n)->recurseDir );
            }
            cmd_printf(TEXT(" %s "), ((struct fornode *) n)->cmdline+_tcslen(ForStr)+1);
        } else
            cmd_printf(Fmt11, ((struct fornode *) n)->cmdline);

        cmd_printf(Fmt13, ((struct fornode *) n)->arglist, ((struct fornode *) n)->cmdline+DOPOS);              
/* M019 */DisplayStatement(((struct fornode *) n)->body, DSP_VER);
        break;

    case IFTYP:

        DEBUG((BPGRP, BPLVL, "DST: Displaying IF."));

        cmd_printf(Fmt11, ((struct ifnode *) n)->cmdline); /* M013 */
        //
        // If extensions are enabled, handle displaying the new
        // optional /I switch on the IF statement.
        //
        if (fEnableExtensions) {
            if (((struct ifnode *)n)->cond->type != NOTTYP) {
                if (((struct ifnode *)n)->cond->flag == CMDNODE_FLAG_IF_IGNCASE)
                    cmd_printf(TEXT("/I "));
            } else
                if (((struct cmdnode *)(((struct ifnode *)n)->cond->argptr))->flag == CMDNODE_FLAG_IF_IGNCASE)
                cmd_printf(TEXT("/I "));
        }

/* M019 */DisplayStatement((struct node *)(((struct ifnode *) n)->cond), DSP_SIL);              
/* M019 */DisplayStatement(((struct ifnode *) n)->ifbody, DSP_SIL);
        if (((struct ifnode *) n)->elsebody) {
            cmd_printf(Fmt02, ((struct ifnode *) n)->elseline);                      /* M013 */
/* M019 */DisplayStatement(((struct ifnode *) n)->elsebody, DSP_SIL);
        }
        break;

    case NOTTYP:

        DEBUG((BPGRP, BPLVL, "DST: Displaying NOT."));

/*  M002 - Removed '\n' from printf statement below.
 */
        cmd_printf(Fmt11, ((struct cmdnode *) n)->cmdline);              /* M013 */
/*  M002 ends   */
/* M019 */DisplayStatement((struct node *)(((struct cmdnode *) n)->argptr), DSP_SIL);
        break;

    case STRTYP:
    case CMPTYP:
        eqstr = TEXT("== ");
        //
        // If extensions are enabled, handle displaying the
        // new forms of comparison operators.
        //
        if (fEnableExtensions) {
            if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_EQU)
                eqstr = TEXT("EQU ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_NEQ)
                eqstr = TEXT("NEQ ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_LSS)
                eqstr = TEXT("LSS ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_LEQ)
                eqstr = TEXT("LEQ ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_GTR)
                eqstr = TEXT("GTR ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_GEQ)
                eqstr = TEXT("GEQ ");
        }
        cmd_printf(Fmt12, ((struct cmdnode *) n)->cmdline, eqstr, ((struct cmdnode *) n)->argptr); /* M013 */
        break;

    case ERRTYP:
    case EXSTYP:
    case CMDVERTYP:
    case DEFTYP:
        cmd_printf(Fmt15, ((struct cmdnode *) n)->cmdline, ((struct cmdnode *) n)->argptr); /* M013 */
        break;

    case REMTYP:            /* M009 - Rem now seperate type    */
    case CMDTYP:

        DEBUG((BPGRP, BPLVL, "DST: Displaying command."));
        CmdPutString( ((struct cmdnode *) n)->cmdline );
        if (((struct cmdnode *) n)->argptr)
            cmd_printf(Fmt11, ((struct cmdnode *) n)->argptr); /* M013 */
        DisplayRedirection(n);
    }
}




/***    DisplayOperator - controls displaying statments containing operators
 *
 *  Purpose:
 *      Diplay an operator and recurse on its left and right hand sides.
 *
 *  void DisplayOperator(struct node *n, TCHAR *opstr)
 *
 *  Args:
 *      n - node of operator to be displayed
 *      opstr - the operator to print
 *
 */

void DisplayOperator(n, opstr)
struct node *n;
TCHAR *opstr;
{

    void DisplayStatement();       /* M008 - made void                */

    DEBUG((BPGRP, BPLVL, "DOP"));

    DisplayStatement(n->lhs, DSP_SIL);                     /* M019    */

    if (n->rhs) {
        cmd_printf(Fmt02, opstr);
        DisplayStatement(n->rhs, DSP_SIL);             /* M019    */
    }
}




/***    DisplayRedirection - displays statements' I/O redirection
 *
 *  Purpose:
 *      Display the type and file names of any redirection associated with
 *      this node.
 *
 *  void DisplayRedirection(struct node *n)
 *
 *  Args:
 *      n - the node to check for redirection
 *
 *  Notes:
 *      M017 - This function has been extensively modified to conform
 *      to new data structures for redirection.
 *      M018 - Modified for redirection of handles other than 0 for input.
 */

void DisplayRedirection(n)
struct node *n;
{
    struct relem *tmp;

    DEBUG((BPGRP, BPLVL, "DRD"));

    tmp = n->rio;

    while (tmp) {

        cmd_printf(Fmt18, TEXT('0')+tmp->rdhndl, tmp->rdop);

        if (tmp->flag)
            cmd_printf(Fmt20);

        cmd_printf(Fmt11, tmp->fname);
        tmp = tmp->nxt;
    }
}




/***    OpenPosBat - open a batch file and position its file pointer
 *
 *  Purpose:
 *      Open a batch file and position the file pointer to the location at
 *      which the next statement is to be read.
 *
 *  int OpenPosBat(struct batdata *bdat)
 *
 *  Args:
 *      bdat - pointer to current batch job structure
 *
 *  Returns:
 *      The handle of the file if everything is successful.  Otherwise,
 *      FAILURE.
 *
 *  Notes:
 *      M033 - Now reports sharing violation errors if appropriate.
 *
 */

CRTHANDLE OpenPosBat(bdat)
struct batdata *bdat;
{
    CRTHANDLE fh;          /* Batch file handle               */
    int DriveIsFixed();

    DEBUG((BPGRP, BPLVL, "OPB: fspec = %ws", bdat->filespec));

    while ((fh = Copen(bdat->filespec, O_RDONLY|O_BINARY)) == BADHANDLE) {

        if (DosErr != ERROR_FILE_NOT_FOUND) {           /* M037    */
            PrtErr(ERROR_OPEN_FAILED);     /* M037    */
            return(fh);
        } else if ( DriveIsFixed( bdat->filespec ) ) {   /* @@4 */
            PutStdErr( MSG_CMD_BATCH_FILE_MISSING, NOARGS); /* @@4 */
            return(fh);                            /* @@4 */
        } else {
            PutStdErr(MSG_INSRT_DISK_BAT, NOARGS);
            if (0x3 == _getch()) {
                SetCtrlC();
                return(fh);
            }
        }
    }

    SetFilePointer(CRTTONT(fh), bdat->filepos, NULL, FILE_BEGIN);
    return(fh);
}




/***    eEcho - execute an Echo command
 *
 *  Purpose:
 *      To either print a message, change the echo status, or display the
 *      echo status.
 *
 *  int eEcho(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the echo command
 *
 *  Returns:
 *      SUCCESS always.
 *
 */

int eEcho(
         struct cmdnode *n
         )
{
    int oocret;
    int rc;

    DEBUG((BPGRP, OTLVL, "eECHO: Entered."));

    switch (oocret = OnOffCheck(n->argptr, OOC_NOERROR)) {
    case OOC_EMPTY:

        rc = PutStdOut(((EchoFlag == E_ON) ? MSG_ECHO_ON : MSG_ECHO_OFF), NOARGS);
        if (rc != 0) {
            if (FileIsPipe(STDOUT)) {
                PutStdErr( MSG_CMD_INVAL_PIPE, NOARGS );
            } else if ( !FileIsDevice( STDOUT ) ) {
                PutStdErr( rc, NOARGS );
            } else if (!(flgwd & 2)) {
                PutStdErr( ERROR_WRITE_FAULT, NOARGS );
            }
        }
        break;

    case OOC_OTHER:
        cmd_printf(Fmt17, n->argptr+1);
        break;
    default:
        EchoFlag = oocret;
    }

    return(SUCCESS);
}




/***    eFor - controls the execution of a For loop
 *
 *  Purpose:
 *      Loop through the elements in a FOR loop arg list.  Expand those that
 *      contain wildcards.
 *
 *  int eFor(struct fornode *n)
 *
 *  Args:
 *      n - the FOR loop parse tree node
 *
 *  Returns:
 *      The retcode of the last command executed in the FOR body.
 *
 *  Notes:
 *      *** IMPORTANT ***
 *      Each iteration through the FOR loop being executed causes more memory
 *      to be allocated.  This can cause Command to run out of memory.  To
 *      keep this from happening, we use DCount to locate the end of the data
 *      stack after the first iteration through the FOR loop.  At the end of
 *      each successive iteration through the loop, memory is freed that was
 *      allocated during that iteration of the loop.  The first iterations'
 *      memory is NOT freed because there is data allocated there that must
 *      be kept for successive iterations; namely, the save structure in the
 *      for loop node.
 *
 */

void FvarRestore()
{
    if ( FvarsSaved ) {       /* @@ */
        FvarsSaved = FALSE;   /* @@ */
        Fvars = save_Fvars;  /* @@ */
        Fsubs = save_Fsubs;  /* @@ */
    }                     /* @@ */
}

FRecurseWork(
            TCHAR *path,
            TCHAR *filepart,
            struct fornode *pForNode,
            PCPYINFO fsinfo,
            int i,
            TCHAR *argtoks
            );

FParseWork(
          struct fornode *pForNode,
          int i,
          BOOL bFirstLoop
          );

FLoopWork(
         struct fornode *pForNode,
         PCPYINFO fsinfo,
         int i,
         TCHAR *argtoks,
         BOOL bFirstLoop
         );

int eFor(struct fornode *pForNode)
{
    TCHAR *argtoks;        /* Tokenized argument list         */
    int i = 0;                     /* Temp                            */
    int datacount;                 /* Elts on data stack not to free  */
    int forretcode; /* Return code from FWork()        */
/*509*/int argtoklen;
    BOOL bFirstLoop;
    PCPYINFO fsinfo;        /* Used for expanded fspec */

    FvarsSaved = FALSE; /* @@ */
    bFirstLoop = TRUE;

    fsinfo = (PCPYINFO) mkstr(sizeof(CPYINFO));

    if (!fsinfo) {
        PutStdErr(MSG_NO_MEMORY, NOARGS );
        return(FAILURE);
    }

    if (Fvars) {
        Fvars = (TCHAR*)resize(Fvars,((i = mystrlen(Fvars))+2)*sizeof(TCHAR));
        Fsubs = (TCHAR **)resize(Fsubs,(i+1)*(sizeof(TCHAR *)) );
    } else {
        Fvars = (TCHAR*)mkstr(2*sizeof(TCHAR));                /* If no str, make one     */
        Fsubs = (TCHAR **)mkstr(sizeof(TCHAR *));      /* ...also a table         */
    }

    if (Fvars == NULL || Fsubs == NULL) {
        PutStdErr(MSG_NO_MEMORY, NOARGS );
        return FAILURE;
    }

    Fvars[i] = (TCHAR)(pForNode->forvar);            /* Add new var to str  */
    Fvars[i+1] = NULLC;

    //
    // Check for the new forms of the FOR loop.  None of these flags
    // will be set if extensions are not enabled
    //
    if (pForNode->flag & FOR_LOOP) {
        TCHAR ForLoopBuffer[32];
        int ForLoopValue, ForLoopStep, ForLoopLimit;

        //
        // Handle the loop for of the FOR statement, where the set
        // is described by a starting number and step value (+ or -)
        // and an end number
        //
        // FOR /L %i in (start,step,end) do
        //
        argtoks = TokStr(pForNode->arglist, NULL, TS_NOFLAGS);
        ForLoopValue = _tcstol( argtoks, NULL, 0 );
        argtoklen = mystrlen( argtoks );
        argtoks += argtoklen+1;
        ForLoopStep = _tcstol( argtoks, NULL, 0 );
        argtoklen = mystrlen( argtoks );
        argtoks += argtoklen+1;
        ForLoopLimit = _tcstol( argtoks, NULL, 0 );

        //
        // We have the three numbers, now run the body of the FOR
        // loop with each value described
        //
        datacount = 0;
        while (TRUE) {
            //
            // If step is negative, go until loop value is less
            // than limit.  Otherwise go until it is greater than
            // limit.
            //
            if (ForLoopStep < 0) {
                if (ForLoopValue < ForLoopLimit)
                    break;
            } else {
                if (ForLoopValue > ForLoopLimit)
                    break;
            }

            FvarRestore();
            DEBUG((BPGRP, FOLVL, "FOR: element %d = `%ws'",i ,argtoks));
            CheckCtrlC();

            //
            // Convert the loop value to text and set the value of the loop
            // variable
            //
            _sntprintf(ForLoopBuffer, 32, TEXT("%d"), ForLoopValue);
            Fsubs[i] = ForLoopBuffer;

            //
            // Run the body of the FOR Loop
            //
            forretcode = FWork(pForNode->body,bFirstLoop);
            datacount = ForFree(datacount);
            bFirstLoop = FALSE;

            //
            // Step to next value
            //
            ForLoopValue += ForLoopStep;
        }
    } else
        if (pForNode->flag & FOR_MATCH_PARSE) {
        //
        // Handle the new parse form of the FOR loop
        //
        //  FOR /F "parameters" %i in (filelist) do ...
        //  FOR /F "parameters" %i in (`command to execute`) do ...
        //  FOR /F "parameters" %i in ('literal string') do ...
        //

        forretcode = FParseWork(pForNode,
                                i,
                                TRUE
                               );
    } else
        if (pForNode->flag & FOR_MATCH_RECURSE) {
        TCHAR pathbuf[MAX_PATH];
        TCHAR *filepart;
        TCHAR *p;
        DWORD Length;

        //
        // Handle the new recurse form of the FOR loop
        //
        //  FOR /R directory %i in (filespecs) do ...
        //
        // Where directory is an optional directory path of where to start
        // walking the directory tree.  Default is the current directory.
        // filespecs is one or more file name specifications, wildcards
        // allowed.
        //

        //
        // Get the full path of the directory to start walking, defaulting
        // to the current directory.
        //

        p = StripQuotes( pForNode->recurseDir ? pForNode->recurseDir : TEXT(".\\"));

        Length = GetFullPathName( p, MAX_PATH, pathbuf, &filepart );
        if (Length == 0 || Length >= MAX_PATH ) {
            PutStdErr( MSG_FULL_PATH_TOO_LONG, ONEARG, p );
            forretcode = FAILURE;
        } else {

            if (filepart == NULL) {
                filepart = lastc(pathbuf);
                if (*filepart != BSLASH) {
                    *++filepart = BSLASH;
                }
                *++filepart = NULLC;
            } else {
                //
                //  A directory is present.  Append a path sep
                //

                mystrcat( pathbuf, TEXT( "\\" ));
                filepart = lastc( pathbuf ) + 1;
            }

            //
            // Tokenize the list of file specifications
            //
            argtoks = TokStr(pForNode->arglist, NULL, TS_NOFLAGS);

            //
            // Do the work
            //
            forretcode = FRecurseWork(pathbuf, filepart, pForNode, fsinfo, i, argtoks);
        }
    } else {
        //
        // If none of the new flags specified, then old style FOR statement
        // Tokenize the elements of the set and loop over them
        //
        argtoks = TokStr(pForNode->arglist, NULL, TS_NOFLAGS);
        DEBUG((BPGRP, FOLVL, "FOR: initial argtok = `%ws'", argtoks));
        forretcode = FLoopWork(pForNode, fsinfo, i, argtoks, TRUE);
        DEBUG((BPGRP, FOLVL, "FOR: Exiting."));
    }

    //
    // All done, deallocate the FOR variable
    //
    if (i) {
        if (Fvars || (*Fvars)) {
            *(Fvars+mystrlen(Fvars)-1) = NULLC;
        }
        Fsubs[i] = NULL;
    } else {
        Fvars = NULL;
        Fsubs = NULL;
    }
    return(forretcode);
}


/***    FRecurseWork - controls the execution of a For loop with the /R option
 *
 *  Purpose:
 *      Execute a FOR loop statement for recursive walk of a directory tree
 *
 *  FRecurseWork(TCHAR *path, TCHAR *filepart,
 *               struct fornode *pForNode, PCPYINFOfsinfo,
 *               int i, TCHAR *argtoks)
 *
 *  Args:
 *      path - full path of directory to start recursing down
 *      filepart - tail portion of full path where file name portion is
 *      pForNode - pointer to the FOR parse tree node
 *      fsinfo - work buffer for expanding file specification wildcards
 *      i - FOR variable index in Fvars and Fsubs arrays
 *      argtoks - the tokenized data set to loop over.  This set is presumed
 *                to be file names with possible wild cards.  This set is
 *                evaluated for each directory seen by the recusive walk of the
 *                the directory tree.  So FOR /R "." %i in (*.c *.h) do echo %i
 *                would echo all the .c and .h files in a directory tree
 *
 *  Returns:
 *      The retcode of the last statement executed in the for body or FORERROR.
 *
 */

FRecurseWork(
            TCHAR *path,
            TCHAR *filepart,
            struct fornode *pForNode,
            PCPYINFO fsinfo,
            int i,
            TCHAR *argtoks
            )
{
    WIN32_FIND_DATA buf;           /* Buffer for find first/next    */
    HANDLE hnFirst;                        /* handle from ffirst()            */
    int forretcode = FORERROR;
    int npfxlen, ntoks;
    TCHAR *s1;
    TCHAR *s2;
    TCHAR *tmpargtoks;

    //
    // Calculate the length of the path and find the end of the
    // tokenized data set and the number of tokens in the set.
    //
    npfxlen = _tcslen(path);
    ntoks = 0;
    s1 = argtoks;
    while (*s1) {
        ntoks += 1;
        while (*s1++) {
            NOTHING;
        }
    }

    //
    // Now allocate space for a copy of the tokenized data set with room to prefix
    // each element of the set with the path string.  Construct the copy of the set
    //
    tmpargtoks = mkstr( ntoks * ((npfxlen + ((int)(s1 - argtoks) + 1)) * sizeof(TCHAR)) );
    if (tmpargtoks == NULL) {
        PutStdErr(MSG_NO_MEMORY, NOARGS );
        return FAILURE;
    }
    s1 = argtoks;
    s2 = tmpargtoks;
    while (*s1) {
        _tcsncpy(s2, path, npfxlen);
        _tcscpy(s2+npfxlen, s1);
        s2 += npfxlen;
        while (*s1++)
            s2 += 1;
        s2 += 1;
    }
    *s2++ = NULLC;

    //
    // Now run the body of the FOR loop with the new data set, then free it.
    //
    forretcode = FLoopWork(pForNode, fsinfo, i, tmpargtoks, TRUE);

    //
    // Now find any subdirectories in path and recurse on them
    //
    filepart[0] = STAR;
    filepart[1] = NULLC;
    hnFirst = FindFirstFile( path, &buf );
    filepart[0] = NULLC;
    if (hnFirst != INVALID_HANDLE_VALUE) {
        do {
            _tcscpy(filepart, buf.cFileName);
            if (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
                _tcscmp(buf.cFileName, TEXT(".")) &&
                _tcscmp(buf.cFileName, TEXT(".."))) {

                s1 = lastc(filepart);
                *++s1 = BSLASH;
                *++s1 = NULLC;
                forretcode = FRecurseWork(path, s1, pForNode, fsinfo, i, argtoks);
            }

        } while (FindNextFile( hnFirst, &buf ));
        FindClose(hnFirst);
    }

    return(forretcode);
}

/***    FParseWork - controls the execution of a For loop with the /F option
 *
 *  Purpose:
 *      Execute a FOR loop statement for parsing the contents of a file
 *
 *  FParseWork(struct fornode *pForNode, PCPYINFOfsinfo,
 *             int i, TCHAR *argtoks, BOOL bFirstLoop)
 *
 *  Args:
 *      pForNode - pointer to the FOR parse tree node
 *      i - FOR variable index in Fvars and Fsubs arrays
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      The retcode of the last statement executed in the for body or FORERROR.
 *
 */

FParseWork(
          struct fornode *pForNode,
          int i,
          BOOL bFirstLoop
          )
{
    HANDLE hFile;                  /* handle from ffirst()            */
    DWORD dwFileSize, dwBytesRead;
    int datacount;                 /* Elts on data stack not to free  */
    int argtoklen;
    int forretcode = FORERROR;
    TCHAR *argtoks;
    TCHAR *s1;
    TCHAR *s2;
    TCHAR *sToken;
    TCHAR *sEnd;
    TCHAR *tmpargtoks = NULL;
    TCHAR eol=TEXT(';');
    TCHAR quoteChar;
    TCHAR *delims;
    TCHAR chCmdLine, chLiteralString;
    int nVars;
    int nSkip;
    int nSkipSave;
    int nTok, nTokEnd, nTokBits, nTokStar;
    DWORD nTokenMask;
    BOOL bNewSemantics;

    //
    // First see if we have any parse options present.  Possible parse options are:
    //
    //  eol=c               // c is the end of line comment character
    //  delims=cccc         // cccc specifies one or more delimeter characters
    //  skip=n              // n specifies how many lines at the begin of each file
    //                      // to skip (defaults to zero).
    //  tokens=m,n-o        // m is a token number to pass to the body of the FOR loop
    //                      // n-o is a range of token numbers to pass. (defaults
    //                      // to tokens=1
    //  usebackq            // If present, allows new back quotes for command line,
    //                      // single quote for literal strings, which frees up double
    //                      // quotes for quoting file names
    //
    //

    delims = (TCHAR *) gmkstr( sizeof( DEFAULT_DELIMS ) + sizeof( TCHAR ) );
    mystrcpy( delims, DEFAULT_DELIMS );

    nSkip = 0;
    nVars = 1;
    nTokenMask = 1;
    nTokStar = 0;
    bNewSemantics = FALSE;
    if (pForNode->parseOpts) {
        s1 = pForNode->parseOpts;
        if (*s1 == QUOTE || *s1 == TEXT('\'')) {
            quoteChar = *s1++;
        } else {
            quoteChar = NULLC;
        }
        nTokBits = 1;
        while (s1 && *s1) {
            while (*s1 && *s1 <= SPACE)
                s1 += 1;

            if (*s1 == quoteChar)
                break;

            if (!_tcsnicmp(s1, TEXT("usebackq"), 8)) {
                bNewSemantics = TRUE;
                s1 += 8;
            } else
                if (!_tcsnicmp(s1, TEXT("useback"), 7)) {
                bNewSemantics = TRUE;
                s1 += 7;
            } else
                if (!_tcsnicmp(s1, TEXT("eol="), 4)) {
                eol=s1[4];
                s1 += 5;
            } else
                if (!_tcsnicmp(s1, TEXT("delims="), 7)) {
                s1 += 7;
                s2 = s1;

                //
                //  Advance to the next space or end of string
                //

                while (*s1 && *s1 != quoteChar) {
                    if (*s1 == SPACE && s1[1] != quoteChar)
                        break;
                    else
                        s1 += 1;
                }

                //
                //  New delimiter characters
                //

                FreeStr( delims );
                delims = (TCHAR *) gmkstr( ((int)(s1 - s2) + 1) * sizeof( TCHAR ));

                _tcsncpy(delims, s2, (UINT)(s1-s2));
                delims[s1-s2] = NULLC;

                if (*s1)
                    s1 += 1;
            } else
                if (!_tcsnicmp(s1, TEXT("skip="), 5)) {
                s1 += 5;
                nSkip = _tcstol(s1, &s1, 0);
                if (nSkip <= 0)
                    goto badtokens;
            } else
                if (!_tcsnicmp(s1, TEXT("tokens="), 7)) {
                s1 += 7;
                nTokenMask = 0;
                nTokBits = 0;
                while (*s1 && *s1 != quoteChar) {
                    if (*s1 == STAR) {
                        s1 += 1;
                        nTokBits += 1;
                        nTokStar = nTokBits;
                        break;
                    }

                    nTok = _tcstol(s1, &s1, 0);
                    if (nTok <= 0)
                        goto badtokens;

                    if (*s1 == MINUS) {
                        nTokEnd = _tcstol(s1+1, &s1, 0);
                        if (nTokEnd <= 0)
                            goto badtokens;
                    } else
                        nTokEnd = nTok;

                    if (nTok > 0 && nTokEnd < 32)
                        while (nTok <= nTokEnd) {
                            nTokBits += 1;
                            nTokenMask |= 1 << (nTok - 1);
                            nTok += 1;
                        }

                    if (*s1 == COMMA)
                        s1 += 1;
                    else
                        if (*s1 != STAR)
                        break;
                }

                if (nTokBits > nVars)
                    nVars = nTokBits;
            } else {
                badtokens:
                PutStdErr(MSG_SYNERR_GENL,ONEARG,s1);
                return(FAILURE);
            }
        }

        //
        // If user specified more than one token then we need to allocate
        // additional FOR variable names to pass them to the body of the
        // FOR loop.  The variables names are the next nVars-1 letters after
        // the one the user specified in the FOR statement.  So if they specified
        // %i as the variable name and requested 3 tokens, then %j and %k would
        // be allocated here.
        //
        if (nVars > 1) {
            Fvars = (TCHAR*)resize(Fvars,(i+nVars)*sizeof(TCHAR) );
            Fsubs = (TCHAR **)resize(Fsubs,(i+nVars)*sizeof(TCHAR *) );

            if (Fvars == NULL || Fsubs == NULL) {
                PutStdErr(MSG_NO_MEMORY, NOARGS );
                Abort( );
            }

            for (nTok=1; nTok<nVars; nTok++) {
                Fvars[i+nTok] = (TCHAR)(pForNode->forvar+nTok);
                Fsubs[i+nTok] = NULL;
            }
            Fvars[i+nTok] = NULLC;
        }
    }

    //
    // Parse string between parenthesis.  Only parse it if present and
    // not either the Command Line or Literal String mode
    //
    argtoks = pForNode->arglist;
    if (bNewSemantics) {
        chCmdLine = TEXT('`');
        chLiteralString = TEXT('\'');
    } else {
        chCmdLine = TEXT('\'');
        chLiteralString = QUOTE;
    }

    if (!argtoks || (*argtoks != chCmdLine && *argtoks != chLiteralString))
        //
        // If not the command line form, then tokenize the set of file names
        //
        argtoks = TokStr(argtoks, NULL, TS_NOFLAGS);


    // Now loop over the set of files, opening and parsing each one.
    //
    nSkipSave = nSkip;
    for (datacount = 0; *argtoks && !GotoFlag; argtoks += argtoklen+1) {
        FvarRestore();
        CheckCtrlC();
        s1 = sEnd = NULL;
        tmpargtoks = NULL;
        nSkip = nSkipSave;
        argtoklen = mystrlen( argtoks );
        if (*argtoks == chCmdLine && argtoklen > 1 && argtoks[argtoklen-1] == chCmdLine) {
            FILE *pChildOutput;
            char *spBegin;
            size_t cbUsed, cbTotal;

            //
            // If the file name is a quoted string, with single quotes, then it is a command
            // line to execute.  So strip off the quotes.
            //
            argtoks += 1;
            argtoklen -= 2;
            argtoks[argtoklen] = NULLC;

            //
            // Execute the command line, getting a handle to its standard output
            // stream.
            //

            pChildOutput = _tpopen( argtoks, TEXT( "rb" ));
            if (pChildOutput == NULL) {
                PutStdErr(MSG_DIR_BAD_COMMAND_OR_FILE, ONEARG, argtoks);
                return(GetLastError());
            }

            //
            // Now read the standard output stream, collecting it into allocated
            // memory so we can parse it when the command finishes.  Read until
            // we hit EOF or an error on the child output handle.
            //
            cbUsed = cbTotal = 0;
            spBegin = NULL;
            while (!feof(pChildOutput) && !ferror(pChildOutput)) {
                if ((cbTotal-cbUsed) < 512) {
                    cbTotal += 256;
                    if (spBegin)
                        spBegin = resize(spBegin, cbTotal);
                    else
                        spBegin = mkstr(cbTotal);
                    if (spBegin == NULL) {
                        PutStdErr(MSG_NO_MEMORY, ONEARG, argtoks);
                        _pclose(pChildOutput);
                        return(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                spBegin[cbUsed] = TEXT( '\0' );
                if (!fgets(spBegin+cbUsed, (int)(cbTotal-cbUsed), pChildOutput))
                    break;

                cbUsed = strlen(spBegin);
            }
            //
            // All done.  Close the child output handle, which will actually wait
            // for the child process to terminate.
            //
            _pclose(pChildOutput);

            //
            // Reallocate memory to what we actually need for the UNICODE representation
            //
            spBegin = resize(spBegin, (cbUsed+2) * sizeof(TCHAR));
            if (Fvars == NULL || Fsubs == NULL) {
                PutStdErr(MSG_NO_MEMORY, ONEARG, argtoks);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            //
            // Move the ANSI data to the second half of the buffer so we can convert it
            // to UNICODE
            //
            memmove(spBegin+cbUsed, spBegin, cbUsed);
            tmpargtoks = (TCHAR *)spBegin;
            dwFileSize = dwBytesRead = cbUsed;

            //
            // No go treat the in memory buffer we have created as if it were a
            // file read in from disk.
            //
            goto gotfileinmemory;
        } else
            if (*argtoks == chLiteralString &&
                argtoklen > 1 &&
                argtoks[argtoklen-1] == chLiteralString
               ) {
            //
            // If the file name is a literal string then it is an immediate
            // string to be parsed.  Fake things up for the parsing logic
            // and fall through to it.
            //
            argtoks[argtoklen-1] = NLN;
            s1 = argtoks += 1;
            sEnd = s1 + argtoklen - 1;
        } else {
            if (*argtoks == QUOTE) {
                argtoks += 1;
                s1 = lastc(argtoks);
                if (*s1 == QUOTE) {
                    do {
                        *s1-- = NULLC;
                    }
                    while (s1 >= argtoks && *s1 == SPACE);
                }
            }

            //
            // We have an actual file name to try to open and read.  So do it
            //
            hFile = CreateFile( argtoks,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_DELETE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL
                              );
            if (hFile == INVALID_HANDLE_VALUE) {
                PutStdErr(MSG_CMD_FILE_NOT_FOUND, ONEARG, argtoks);
                return GetLastError();
            } else {
                dwFileSize = SetFilePointer(hFile, 0, NULL, FILE_END);
                SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
                tmpargtoks = mkstr((dwFileSize+2) * sizeof( TCHAR ));
                if (tmpargtoks == NULL) {
                    PutStdErr(MSG_NO_MEMORY, ONEARG, argtoks);
                    CloseHandle( hFile );
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                dwBytesRead = 0xFFFFFFFF;
                ReadFile( hFile,
#ifdef UNICODE
                          (LPSTR)tmpargtoks+dwFileSize,
#else
                          tmpargtoks,
#endif
                          dwFileSize,
                          &dwBytesRead,
                          NULL
                        );
                CloseHandle(hFile);
                gotfileinmemory:
                if (dwBytesRead == dwFileSize) {
                    //
                    // Successfully opened and read the data.  Convert it to UNICODE
                    // and setup the variables for the parsing loop
                    //
#ifdef UNICODE
#ifdef FE_SB
                    dwFileSize =
#endif
                    MultiByteToWideChar(CurrentCP,
                                        MB_PRECOMPOSED,
                                        (LPSTR)tmpargtoks+dwFileSize,
                                        dwFileSize,
                                        tmpargtoks,
                                        dwFileSize);
#endif
                    s1 = tmpargtoks;
                    sEnd = s1 + dwFileSize;
                    if (sEnd == s1 || sEnd[-1] != NLN)
                        *sEnd++ = NLN;
                    *sEnd = NULLC;
                }
            }
        }

        //
        // This is the parsing loop
        //
        //  s1 points to next character.
        //  sEnd points just after the last valid character to parse
        //
        // Loop isolates next line in input buffer, parse that line,
        // Passes any tokens from the line to body of the FOR loop and
        // then loops.
        //
        while (s1 < sEnd && !GotoFlag) {
            CheckCtrlC();

            //
            // Not past the end of the buffer.  Find the next
            // newline
            //
            s1 = _tcschr(s2=s1, NLN);

            //
            // If no newline, then done parsing
            //
            if (s1 == NULL)
                break;

            //
            // If CRLF, nuke the CR and the LF
            //
            if (s1 > s2 && s1[-1] == CR)
                s1[-1] = NULLC;
            *s1++ = NULLC;

            //
            // Done skipping input lines?
            //
            if (!nSkip) {
                //
                // Yes, parse this line
                //
                for (nTok=1; nTok<nVars; nTok++) {
                    Fsubs[i+nTok] = NULL;
                }
                nTok = 0;
                nTokBits = 0;

                //
                // Null is the end of line marker now
                //
                while (*s2) {
                    //
                    // Skip any leading delimeters
                    //

                    while (*s2 && _tcschr(delims, *s2) != NULL)
                        s2++;

                    //
                    // If first character is eol comment character than
                    // skip this line
                    //
                    if (nTok == 0 && *s2==eol)
                        break;

                    //
                    // Remember start of token
                    //
                    sToken = s2;

                    if (nTokStar != 0 && (nTokBits+1) == nTokStar) {
                        Fsubs[i+nTokBits] = sToken;
                        nTokBits += 1;
                        break;
                    }

                    //
                    // Find the end of the token
                    //
                    while (*s2 && !_tcschr(delims, *s2))
                        s2 += 1;
                    
                    //
                    // If we got a token, and it is not more than we can
                    // handle, then see if they want this token.  If so,
                    // set the value of the appropriate FOR variable
                    //
                    
                    if (sToken != s2 && nTok < 32) {
                        if ((nTokenMask & (1 << nTok++)) != 0) {
                            Fsubs[i+nTokBits] = sToken;
                            nTokBits += 1;
                        }
                    }
                    
                    //
                    //  If we're not at the end of the string, terminate this
                    //  token and advance
                    //
                    
                    if (*s2 != NULLC) {
                        *s2++ = NULLC;
                    }

                }
                
                //
                // If we set any FOR variables, then run the body of the FOR loop
                //
                
               if (nTokBits) {
                    forretcode = FWork(pForNode->body,bFirstLoop);
                    datacount = ForFree(datacount);
                    bFirstLoop = FALSE;
                }
            } else
                nSkip -= 1;
        }

        //
        // If we allocated memory for the output of the command line, free it up
        //
        if (tmpargtoks != NULL) {
            FreeStr( tmpargtoks );
            tmpargtoks = NULL;
        }
    }

    //
    // If we used any additonal FOR variables, clear them here as we are done with them,
    //
    if (nVars > 1 && Fvars && (*Fvars)) {
        Fvars[i+1] = NULLC;
        Fsubs[i+1] = NULL;
    }
    return(forretcode);
}

/***    FLoopWork - controls the execution of a For loop
 *
 *  Purpose:
 *      Execute a FOR loop statement for a given set
 *
 *  FLoopWork(struct fornode *pForNode, PCPYINFOfsinfo, int i, TCHAR *argtoks, BOOL bFirstLoop
 *
 *  Args:
 *      pForNode - pointer to the FOR parse tree node
 *      fsinfo - work buffer for expanding file specification wildcards
 *      i - FOR variable index in Fvars and Fsubs arrays
 *      argtoks - the tokenized data set to loop over
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      The retcode of the last statement executed in the for body or FORERROR.
 *
 */

FLoopWork(
         struct fornode *pForNode,
         PCPYINFO fsinfo,
         int i,
         TCHAR *argtoks,
         BOOL bFirstLoop
         )
{
    TCHAR *forexpname;             /* Used to hold expanded fspec     */
    WIN32_FIND_DATA buf;           /* Buffer for find first/next    */
    HANDLE hnFirst;                        /* handle from ffirst()            */
    int datacount;                 /* Elts on data stack not to free  */
    int forretcode;                /* Return code from FWork()        */
    int catspot;                   /* Add fnames to forexpname here   */
    int argtoklen;
    DWORD forexpnamelen;
    DWORD dwMatchAttributes;

    //
    // Loop, processing each string in the argtoks set
    //
    for (datacount = 0; *argtoks && !GotoFlag; argtoks += argtoklen+1) {
        FvarRestore();
        DEBUG((BPGRP, FOLVL, "FOR: element %d = `%ws'",i ,argtoks));
        CheckCtrlC();

        //
        // Save the length of next string in set so we can skip over it
        //
        argtoklen = mystrlen( argtoks );
        if (!(mystrchr(argtoks, STAR) || mystrchr(argtoks, QMARK))) {
            //
            // String contains no wildcard characters, so set the value of
            // the FOR variable to the string and evaluate the body of the
            // FOR loop
            //
            Fsubs[i] = argtoks;
            forretcode = FWork(pForNode->body,bFirstLoop);
            datacount = ForFree(datacount);
            bFirstLoop = FALSE;
        } else {                /* Else, expand wildcards          */
            forexpnamelen = 0;
            forexpname = NULL;
            //
            // String contains file specification wildcard characters.
            // Expand the reference into one or more file or directory names,
            // processing each name as a string
            //
            dwMatchAttributes = (pForNode->flag & FOR_MATCH_DIRONLY) ? A_AEVH : A_AEDVH;
            mystrcpy( argtoks, StripQuotes( argtoks ) );
            if (ffirst(argtoks, dwMatchAttributes, &buf, &hnFirst)) {
                //
                // Found at least one file.  Parse it as a file name.
                //
                fsinfo->fspec = argtoks;
                ScanFSpec(fsinfo);
                //
                // Remember where the file name portion is so we can append each
                // matching file name to create a full path.
                //
                catspot = (fsinfo->pathend) ? (int)(fsinfo->pathend-fsinfo->fspec+1) : 0;
                if (forexpnamelen < mystrlen(fsinfo->fspec)) {
                    forexpnamelen = mystrlen(fsinfo->fspec)+1;
                    if (forexpname == NULL)
                        forexpname = mkstr(forexpnamelen*sizeof(TCHAR));
                    else
                        forexpname = resize(forexpname, forexpnamelen*sizeof(TCHAR));
                }
                if (forexpname == NULL) {
                    PutStdErr( MSG_NO_MEMORY, NOARGS );
                    Abort( );
                }

                mystrcpy(forexpname, fsinfo->fspec);
                do {
                    FvarRestore();         /* @@ */

                    //
                    // Copy current file name into full path buffer
                    //
                    if (forexpnamelen < (forexpnamelen+mystrlen(buf.cFileName))) {
                        forexpnamelen += mystrlen(buf.cFileName);
                        if (forexpname == NULL)
                            forexpname = mkstr(forexpnamelen*sizeof(TCHAR));
                        else
                            forexpname = resize(forexpname, forexpnamelen*sizeof(TCHAR));

                        if (forexpname == NULL) {
                            PutStdErr( MSG_NO_MEMORY, NOARGS );
                            Abort( );
                        }
                    }
                    mystrcpy(&forexpname[catspot], buf.cFileName);

                    //
                    // See if user wants files or directories and what we have
                    // and evaluate the body of the FOR loop if we have what the
                    // user wants.  Ignore the bogus . and .. directory names
                    // returned by file systems.
                    //
                    if (!(pForNode->flag & FOR_MATCH_DIRONLY) ||
                        (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
                         _tcscmp(buf.cFileName, TEXT(".")) &&
                         _tcscmp(buf.cFileName, TEXT("..")))) {

                        DEBUG((BPGRP, FOLVL, "FOR: forexpname = `%ws'", forexpname));
                        //
                        // User wants this file or directory name, so set
                        // the value of the FOR variable and evaluate the
                        // body of the FOR loop.
                        //
                        Fsubs[i] = forexpname;
                        forretcode = FWork(pForNode->body,bFirstLoop);
                        bFirstLoop = FALSE;
                    }

                    //
                    // Check for CtrlC and then get next matching file name
                    //
                    CheckCtrlC();
                } while (fnext(&buf, dwMatchAttributes, hnFirst) && !GotoFlag);

                datacount = ForFree(datacount);
                //
                // No more matching files, close the find handle and mark end of
                // first loop iteration
                //
                findclose(hnFirst);    /* @@4-@@M1 */
                bFirstLoop = FALSE;
            }
        }
    }

    return(forretcode);
}

/***    FWork - controls the execution of 1 iteration of a For loop
 *
 *  Purpose:
 *      Execute a FOR loop statement.
 *
 *  FWork(struct node *n, TCHAR var, TCHAR *varval)
 *
 *  Args:
 *      n - pointer to the body of the FOR loop
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      The retcode of the last statement executed in the for body or FORERROR.
 *
 */

FWork(n,bFirstLoop)
struct node *n;
BOOL bFirstLoop;
{
    int forretcode;                /* Dispatch Retcode or FORERROR    */
    void DisplayStatement();       /* M008 - made void                */

    DEBUG((BPGRP, FOLVL, "FW: Entered; Substituting variable"));

    if (SubFor(n,bFirstLoop)) {
        return(FORERROR);
    } else {

        DEBUG((BPGRP, FOLVL, "FW: EchoFlag = %d", EchoFlag));

        if (EchoFlag == E_ON && n->type != SILTYP && !Necho) {
            PrintPrompt();
            DisplayStatement(n, DSP_SIL);          /* M019    */
            cmd_printf(CrLf);                      /* M026    */
        }
        forretcode = Dispatch(RIO_OTHER,n);    /* M000            */
    }

    DEBUG((BPGRP, FOLVL, "FW: Returning %d", forretcode));

    return(forretcode);
}




/***    SubFor - controls FOR variable substitutions
 *
 *  Purpose:
 *      To walk a parse tree and make FOR variable substitutions on
 *      individual nodes.  SFWork() is called to do individual string
 *      substitutions.
 *
 *  int SubFor(struct node *n)
 *
 *  Args:
 *      n - pointer to the statement subtree in which the substitutions are
 *          to be made
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      SUCCESS if all goes well.
 *      FAILURE if an oversized command is found.
 *
 *  Note:
 *      The variables to be substituted for are contained in Fvars and
 *      Fsubs is an array of string pointers to corresponding replacement
 *      strings.  For I/O redirection, the list contained in the node
 *      must also be walked and its filespec strings examined.
 *
 */

int SubFor(n,bFirstLoop)
struct node *n;
BOOL bFirstLoop;
{
    int j; /* Temps used to make substitutions...     */
    struct relem *io;      /* M017 - Pointer to redir list            */

    DEBUG((BPGRP, FOLVL, "SUBFOR: Entered."));

    if (!n) {

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found NULL node."));

        return(0);
    }

    switch (n->type) {
    case LFTYP:
    case CSTYP:
    case ORTYP:
    case ANDTYP:
    case PIPTYP:
    case PARTYP:
    case SILTYP:                    /* M019 - New type         */

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found operator."));

        if (SubFor(n->lhs,bFirstLoop) ||
            SubFor(n->rhs,bFirstLoop))
            return(FAILURE);

        for (j=0, io=n->rio; j < 10 && io; j++, io=io->nxt) {

            // can't pass freed io->fname
            DEBUG((BPGRP, FOLVL, "SUBFOR: s = %lx", &io->fname));
            if (SFWork(n, &io->fname, j,bFirstLoop))
                return(FAILURE);

            DEBUG((BPGRP, FOLVL, "SUBFOR: *s = `%ws'  &*s = %lx", io->fname, &io->fname));

        }
        return(SUCCESS);
/*  M017 ends   */

    case FORTYP:

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found FOR."));

        if (SFWork(n, &((struct fornode *) n)->arglist, 0,bFirstLoop))
            return(FAILURE);

        return(SubFor(((struct fornode *)n)->body,bFirstLoop));

    case IFTYP:

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found IF."));

        if (SubFor((struct node *)((struct ifnode *) n)->cond,bFirstLoop) ||
            SubFor((struct node *)((struct ifnode *) n)->ifbody,bFirstLoop))
            return(FAILURE);

        return(SubFor(((struct ifnode *)n)->elsebody,bFirstLoop));

    case NOTTYP:

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found NOT."));

        return(SubFor((struct node *)((struct cmdnode *)n)->argptr,bFirstLoop));

    case REMTYP:            /* M009 - Rem now separate type    */
    case CMDTYP:
    case CMDVERTYP:
    case ERRTYP:
    case DEFTYP:
    case EXSTYP:
    case STRTYP:
    case CMPTYP:

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found command."));

        if (SFWork(n, &((struct cmdnode *)n)->cmdline, 0,bFirstLoop) ||
            SFWork(n, &((struct cmdnode *)n)->argptr, 1,bFirstLoop))
            return(FAILURE);

        for (j=2, io=n->rio; j < 12 && io; j++, io=io->nxt) {

            // can't pass freed io->fname
            DEBUG((BPGRP, FOLVL, "SUBFOR: s = %lx ", &io->fname) );
            if (SFWork(n, &io->fname, j,bFirstLoop))
                return(FAILURE);

            DEBUG((BPGRP, FOLVL, "SUBFOR: *s = `%ws'  &*s = %lx", io->fname, &io->fname));

        }
/*  M017 ends   */
        return(SUCCESS);
    }

    // If we get here we have an invalid node type.  All case entries should
    // return themselfs.
    DEBUG((BPGRP, FOLVL, "SUBFOR: Invalid Node type"));
    return(0);
}




/***    SFWork - does batch file variable substitutions
 *
 *  Purpose:
 *      Make FOR variable substitutions in a single string.  If a FOR loop
 *      substitution is being made, a pointer to the original string is
 *      saved so that it can be used for subsequent iterations.
 *
 *  SFWork(struct node *n, TCHAR **src, int index)
 *
 *  Args:
 *      n     - parse tree node containing the string being substituted
 *      src   - the string being examined
 *      index - index in save structure
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      SUCCESS if substitutions could be made.
 *      FAILURE if the new string is too long.
 *
 *  Notes:
 *
 */

SFWork(n, src, index, bFirstLoop)
struct node *n;
TCHAR **src;
int index;
BOOL bFirstLoop;
{
    TCHAR *dest;   /* Destination string pointer              */
    TCHAR *srcstr,          /* Source string pointer                   */
    *srcpy,            /* Copy of srcstr                          */
    *t,                /* Temp pointer                            */
    c;                /* Current character being copied          */
    int dlen;      /* Length of dest string                   */
    int sslen,              /* Length of substr                        */
    i;                 /* Work variable                           */

    DEBUG((BPGRP, FOLVL, "SFW: Entered."));

    if (*src == NULL) {

        DEBUG((BPGRP, FOLVL, "SFW: Passed null ptr, returning now."));

        return(SUCCESS);
    }

/*  If this string has been previously substituted, get the original string.
 *  Else, "*src" is the original.
 */
    if (n->save.saveptrs[index]) {
        srcpy = n->save.saveptrs[index];
        DEBUG((BPGRP, FOLVL, "SFW: Src is saved string `%ws'",srcpy));
    } else {
        if (!bFirstLoop) {
            // arg got created.  get rid of it.
            *src = NULL;
            return(SUCCESS);
        }

        srcpy = *src;
        DEBUG((BPGRP, FOLVL, "SFW: Src is passed string `%ws'",srcpy));
    }

    srcstr = srcpy;

    if (!(dest = mkstr((MAXTOKLEN+1)*sizeof(TCHAR))))
        return(FAILURE);

    DEBUG((BPGRP, FOLVL, "SFW: dest = %lx", dest));

    for (dlen = 0; (c = *srcstr++) && dlen <= MAXTOKLEN; ) {
        //
        // See if we have a percent character indicating a variable
        // reference.  If not, continue scanning.
        //
        if ( (c != PERCENT) || ( !(*srcstr)) || *srcstr == PERCENT) { /* @@4 */

            DEBUG((BPGRP, FOLVL, "  SFW: No PERCENT adding `%c'", c));

            *dest++ = c;
            dlen++;

            continue;
        }

        //
        // Found a percent character which might represent a for loop
        // variable reference.
        //
        // If extensions are enabled then use the new substitution routine
        // that supports path manipulation, etc.  If it succeeds, accept
        // its substitution.
        //
        if (fEnableExtensions && (t = MSCmdVar(NULL, srcstr, &sslen, Fvars, Fsubs))) {
            srcstr += sslen;
            sslen = mystrlen(t);    /* Calc length     */

            if (dlen+sslen > MAXTOKLEN)     /* Too long?       */
                return(FAILURE);       /* ...yes, quit    */

            mystrcpy(dest, t);
            dlen += sslen;
            dest += sslen;
            continue;
        }

        //
        // Either extensions are disabled or new code could not
        // resolve the variable references, so let the old code
        // do it.
        //
        c = *srcstr++;

        DEBUG((BPGRP, FOLVL, "  SFW: Got PERCENT next is `%c'", c));
        DEBUG((BPGRP, FOLVL, "  SFW: Fvars are `%ws' @ %lx", Fvars, Fvars));

        if (t = mystrrchr(Fvars,c)) {   /* @@4 */  /* If c is var     */
            i = (int)(t - Fvars);          /* ...make index   */

            DEBUG((BPGRP, FOLVL, "  SFW: Found @ %lx", t));
            DEBUG((BPGRP, FOLVL, "  SFW: Index is %d", i));
            DEBUG((BPGRP, FOLVL, "  SFW: Substitute is `%ws'", Fsubs[i]));
            sslen = mystrlen(Fsubs[i]);    /* Calc length     */

            if (dlen+sslen > MAXTOKLEN)     /* Too long?       */
                return(FAILURE);       /* ...yes, quit    */

            DEBUG((BPGRP, FOLVL, "  SFW: Copying to dest."));

            mystrcpy(dest, Fsubs[i]);
            dlen += sslen;
            dest += sslen;

            DEBUG((BPGRP, FOLVL, "SFW: Forsub, dest = `%ws'", dest-dlen));

        } else {

            DEBUG((BPGRP, FOLVL, "  SFW: Not a var adding PERCENT and `%c'",c));

            *dest++ = PERCENT;
            *dest++ = c;
            dlen += 2;
        }
    }

    DEBUG((BPGRP, FOLVL, "SFW: Done, dlen = %d  dest = `%ws'", dlen, dest-dlen));

    if (dlen > MAXTOKLEN) {

        DEBUG((BPGRP, FOLVL, "SFW: Error, too long."));

        return(FAILURE);
    }

    DEBUG((BPGRP, FOLVL, "SFW: Saving FOR string."));
    if (bFirstLoop) {
        n->save.saveptrs[index] = srcpy;
    }

    if (!(*src = (TCHAR*)resize(dest-dlen, (dlen+1)*sizeof(TCHAR*))))       /* Free unused spc   */
        return(FAILURE);

    DEBUG((BPGRP, FOLVL, "SFW: After resize *src = `%ws'", *src));

    return(SUCCESS);
}




/***    ForFree - controls memory freeing during For loop execution
 *
 *  Purpose:
 *      To free up space used during the execution of a for loop body as
 *      explained in the note in the comments for eFor().  If datacount
 *      is 0, this is the first time ForFree() has been called so DCount
 *      is used to get the number of elements on the data stack that must
 *      stay there for the corect execution of the loop.  If datacount is
 *      not 0, it is the number discussed above.  In this case, this number
 *      is passed to FreeStack().
 *
 *  int ForFree(int datacount)
 *
 *  Args:
 *      datacount - see above
 *
 *  Returns:
 *      Datacount
 *
 */

int ForFree(datacount)
int datacount;
{
    if (datacount)
        FreeStack(datacount);
    else
        datacount = DCount;

    return(datacount);
}




/***    eGoto - executes a Goto statement
 *
 *  Purpose:
 *      Find the label associated with the goto command and set the file
 *      position field in the current batch job structure to the position
 *      right after the label.  After the label is found, set the GotoFlag.
 *      This tells function eFor() to stop executing a for loop and it
 *      tells Dispatch() that no more commands are to be executed until
 *      the flag is reset.  This way, if the goto command is buried inside
 *      of any kind of compound statement, Command will be able to work its
 *      way out of the statement and reset I/O redirection before continuing
 *      with the statement after the label which was found.
 *
 *      If the label isn't found, an error message is printed and the
 *      current batch job is terminated by popping its structure of the
 *      stack.
 *
 *      If no batch job is in progress, this command is a nop.
 *
 *  int eGoto(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the goto command
 *
 *  Returns:
 *      SUCCESS if the label is found.
 *      FAILURE otherwise.
 *
 *  Notes:
 *      M030 - This function has been completely rewritten for speed-up
 *      of GOTO label searches.  Now uses complete 257 byte temporary
 *      buffer.
 *      M031 - Function altered to speed up GOTO's.  Optimized for
 *      forward searches and buffer increased to 512 bytes.
 *
 */

//
//  BUFFERLENGTH is the amount we read from the batch file each
//  time we fill the internal buffer
//

#define BUFFERLENGTH    512

int eGoto(n)
struct cmdnode *n;
{
    struct batdata *bdat;
    unsigned cnt;                  /* Count of bytes read from file   */
    TCHAR s[128],                    /* Ptr to search label             */
    t[128],                    /* Ptr to found label              */
    *p1,                       /* Place keeper ptr 1              */
    *p2,                       /* Place keeper ptr 2              */
    *p3;                       /* Place keeper ptr 3              */
    CRTHANDLE fh;                   /* Batch file handle               */
    int frstpass = TRUE,            /* First time through indicator    */
    gotoretcode = SUCCESS;      /* Just what it says               */
    long Backup,                    /* Rewind count for seek           */
    savepos;                  /* Save location for file pos      */
    DWORD filesize;


    DEBUG((BPGRP, OTLVL, "GOTO: CurrentBatchFile = %lx", CurrentBatchFile));

    if (!(bdat = CurrentBatchFile))
        return(FAILURE);

    //
    // If no target of goto is present, then treat it like a label-not-found
    //

    if ( n->argptr == NULL) {
        EndAllLocals(bdat);
        CurrentBatchFile = bdat->backptr;
        PutStdErr(MSG_NO_BAT_LABEL, NOARGS);

        DEBUG((BPGRP, OTLVL, "GOTO: No label to goto, returning FAILURE, CurrentBatchFile = %lx", CurrentBatchFile));
        return FAILURE;
    }

    ParseLabel( n->argptr, s, sizeof( s ), TRUE );  /* TRUE indicates source label     */

    savepos = bdat->filepos;
    if ((fh = OpenPosBat( bdat )) == BADHANDLE)
        return(FAILURE);               /* Err if can't open       */

    DEBUG((BPGRP, OTLVL, "GOTO: label = %ws", s));
    DEBUG((BPGRP, OTLVL, "GOTO: fh = %d", fh));
    filesize = GetFileSize(CRTTONT(fh), NULL);

    //
    // If extensions are enabled, see if they are using the command script
    // equivalent of return, which is GOTO :EOF.  If so, set the current
    // position to the end of file and fall through to the normal end of
    // command script logic.
    //
    p2 = EatWS(n->argptr,NULL);
    if (fEnableExtensions &&
        !_tcsnicmp( p2, GotoEofStr, 4 ) &&
        (!p2[4] || _istspace( p2[4] ))
       ) {
        bdat->filepos = filesize;
        GotoFlag = TRUE;
    } else
        for (;;) {
            CheckCtrlC();
            if (
               //
               //  If we've read beyond where we started in the file and it's the second pass
               //

               ((bdat->filepos = SetFilePointer( CRTTONT( fh ), 0, NULL, FILE_CURRENT )) >= savepos
                && !frstpass)

               //
               //  or if we couldn't read from the batch file
               //

               || ReadBufFromInput( CRTTONT( fh ), TmpBuf, BUFFERLENGTH, (LPDWORD)&cnt ) == 0

               //
               //  or if there was nothing to read in the batch file (i.e., EOF)
               //

               || cnt == 0

               //
               //  or we detected EOF some other way
               //

               || cnt == EOF

               //
               //  or if we read a NULL line ???
               //

               || TmpBuf[0] == NULLC

               //
               //  or if the label to go to is empty
               //

               || s[0] == NULLC) {

                //
                //  If we are at EOF for the first time, then seek back to the beginning of the
                //  CMD file and continue  scanning
                //

                if (cnt == 0 && frstpass) {
                    SetFilePointer( CRTTONT( fh ), 0L, NULL, FILE_BEGIN );
                    frstpass = FALSE;
                    continue;
                }

                //
                //  Terminate this batch file
                //

                EndAllLocals(bdat);
                CurrentBatchFile = bdat->backptr;
                PutStdErr(MSG_MISSING_BAT_LABEL, ONEARG, s);

                DEBUG((BPGRP, OTLVL, "GOTO: Returning FAILURE, CurrentBatchFile = %lx", CurrentBatchFile));
                gotoretcode = FAILURE;
                break;
            }

            //
            //  Make sure input line is NUL terminated
            //

            TmpBuf[cnt] = NULLC;

            DEBUG((BPGRP, OTLVL, "GOTO: Got %d bytes @ %lx", cnt, TmpBuf));

            //
            //  If there's no :, then we just skip off to the next block of input
            //

            if (!(p1 = mystrchr( TmpBuf, COLON )))
                continue;

            DEBUG((BPGRP, OTLVL, "GOTO: Seeking through the buffer"));

            //
            //  Walk through the input buffer looking for end-of-lines and
            //  testing to see if there's a label next
            //

            do {

                DEBUG((BPGRP, OTLVL, "GOTO: Found COLON @ %lx.",p1));
                DEBUG((BPGRP, OTLVL, "GOTO: Backing up to NLN."));

                //
                //  Back up to the position of the previous EOL or beginning
                //  of the buffer
                //

                p2 = p1++;
                while (*p2 != NLN && p2 != &TmpBuf[0]) {
                    --p2;
                }

                DEBUG((BPGRP, OTLVL, "GOTO: Found NLN @ %lx.",p1));
                DEBUG((BPGRP, OTLVL, "GOTO: Trashing white space."));

                if (*p2 != COLON)
                    ++p2;
                p3 = EatWS(p2,NULL);   /* Fwd to 1st non-whtspc   */

                DEBUG((BPGRP,OTLVL,"GOTO: Found '%c' @ %lx.",*p2,p2));

                if (*p3 == COLON) {

                    DEBUG((BPGRP, OTLVL, "GOTO: Possible label."));

                    //
                    //  Scan forward for the end of the current line
                    //

                    p1 = mystrchr( p2, NLN );

                    //
                    //  If we don't have a newline and we haven't read up to EOF, then we need to
                    //  back up to the beginning of the line in the file and attempt to read it in
                    //  in one entire block.  Of course, there's a problem if the line is longer
                    //  than the buffer.  In this case, we simply treat the longer chars as being
                    //  in the next line.  Tough.
                    //

                    if (p1 == NULL
                        && SetFilePointer( CRTTONT( fh ), 0, NULL, FILE_CURRENT ) != filesize
                        && cnt != BUFFERLENGTH ) {

                        DEBUG((BPGRP, OTLVL, "GOTO: No NLN!"));

                        Backup = (long)(cnt - (p2 - &TmpBuf[0]));
#if defined(FE_SB) && defined(UNICODE) // eGoto()
                        if (IsDBCSCodePage()) {
                            // We should decrement file pointer in MBCS byte count.
                            // Because the file is described by MBCS string.
                            Backup = WideCharToMultiByte( CurrentCP, 0, TmpBuf, Backup, NULL, 0, NULL, NULL);
                        }
#endif // defined(FE_SB) && defined(UNICODE)
                        SetFilePointer(CRTTONT(fh), -Backup, NULL, FILE_CURRENT);

                        DEBUG((BPGRP, OTLVL, "GOTO: Rewound %ld", Backup));
                        break;         /* Read more       */
                    }

                    ParseLabel( p3, t, sizeof( t ), FALSE ); /* FALSE = target  */

                    DEBUG((BPGRP,OTLVL,"GOTO: Found label %ws at %lx.",t,p1));
                    if (_tcsicmp(s, t) == 0) {

                        DEBUG((BPGRP,OTLVL,"GOTO: A match!"));

                        GotoFlag = (n->flag & CMDNODE_FLAG_GOTO) != 0;

                        DEBUG((BPGRP,OTLVL,"GOTO: NLN at %lx",p1));
                        DEBUG((BPGRP,OTLVL,"GOTO: File pos is %04lx",bdat->filepos));
                        DEBUG((BPGRP,OTLVL,"GOTO: Adding %lx - %lx = %lx bytes",p1+1,&TmpBuf[0],(p1+1)-&TmpBuf[0]));

#if defined(FE_SB) // eGoto()
                        // We should increment file pointer in MBCS byte count.
                        // Because the file is described by MBCS string.
                        if ( !p1 ) {
#ifdef UNICODE
                            if (IsDBCSCodePage()) {
                                long cbMbcs;
                                cbMbcs = WideCharToMultiByte( CurrentCP, 0, TmpBuf, cnt,
                                                              NULL, 0, NULL, NULL);
                                bdat->filepos += cbMbcs;
                            } else
                                bdat->filepos += (long)cnt; /* @@4 */
#else
                            bdat->filepos += (long)cnt; /* @@4 */
#endif
                        } else {
#ifdef UNICODE
                            if (IsDBCSCodePage()) {
                                long cbMbcs;
                                cbMbcs = WideCharToMultiByte(CurrentCP,0,TmpBuf,(int)(++p1 - &TmpBuf[0]),
                                                             NULL,0,NULL,NULL);
                                bdat->filepos += cbMbcs;
                            } else
                                bdat->filepos += (long)(++p1 - &TmpBuf[0]);
#else
                            bdat->filepos += (long)(++p1 - &TmpBuf[0]);
#endif
                        }
#else
                        if ( !p1 ) { /* @@4 */
                            bdat->filepos += (long)cnt; /* @@4 */
                        } else {  /* @@4 */
                            bdat->filepos += (long)(++p1 - &TmpBuf[0]);
                        }
#endif // defined(FE_SB)
                        DEBUG((BPGRP,OTLVL,"GOTO: File pos changed to %04lx",bdat->filepos));
                        break;
                    }
                }

                DEBUG((BPGRP,OTLVL,"GOTO: Next do loop iteration."));

            } while (p1 = mystrchr(p1,COLON));

            DEBUG((BPGRP,OTLVL,"GOTO: Out of do loop GotoFlag = %d.",GotoFlag));

            if (GotoFlag == TRUE)
                break;

            DEBUG((BPGRP,OTLVL,"GOTO: Next for loop iteration."));

        }

    DEBUG((BPGRP,OTLVL,"GOTO: Out of for loop retcode = %d.",gotoretcode));

    Cclose(fh);                    /* M023 */
    return(gotoretcode);
}




/***    eIf - controls the execution of an If statement
 *
 *  Purpose:
 *      Execute the IF conditional.  If the conditional function returns a
 *      nonzero value, execute the body of the if statement.  Otherwise,
 *      execute the body of the else.
 *
 *  int eIf(struct ifnode *n)
 *
 *  Args:
 *      n - the node containing the if statement
 *
 *  Returns:
 *      The retcode from which ever body (ifbody or elsebody) is executed.
 *
 */

int eIf(struct ifnode *pIfNode)
{

    int     i;
    struct cmdnode *n;
    BOOLEAN bNot;

    DEBUG((BPGRP, IFLVL, "IF: cond type = %d", pIfNode->cond->type));

    /*  The following checks the syntax of an errorlevel arg
        to ensure that only numeric digits are specified.
    */
    n = pIfNode->cond;
    if (n->type == NOTTYP) {
        bNot = TRUE;
        n = (struct cmdnode *)n->argptr;
    } else {
        bNot = FALSE;
    }

    if (n->type == ERRTYP || n->type == CMDVERTYP) {
        for (i = 0; n->argptr[i] != 0; i++) {
            if (i == 0 && n->type == ERRTYP && n->argptr[i] == MINUS) {
                continue;
            }

            if (!_istdigit(n->argptr[i])) {
                PutStdErr(MSG_SYNERR_GENL, ONEARG, n->argptr);
                return(FAILURE);
            }
        }
    }

    if (bNot ^ (BOOLEAN)((*GetFuncPtr(n->type))(n) != 0)) {

        DEBUG((BPGRP, IFLVL, "IF: Executing IF body."));

        return(Dispatch(RIO_OTHER,pIfNode->ifbody)); /* M000      */

    } else {

        DEBUG((BPGRP, IFLVL, "IF: Executing ELSE body."));

        return(Dispatch(RIO_OTHER,pIfNode->elsebody)); /* M000    */
    }

    return(SUCCESS);
}




/***    eErrorLevel - executes an errrorlevel If conditional
 *
 *  Purpose:
 *      If LastRetCode >= the errorlevel in the node, return 1.  If not,
 *      return 0.
 *
 *  int eErrorLevel(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the errorlevel command
 *
 *  Returns:
 *      See above.
 *
 */

int eErrorLevel(n)
struct cmdnode *n;
{
    DEBUG((BPGRP, IFLVL, "ERRORLEVEL: argptr = `%ws'  LRC = %d", n->argptr, LastRetCode));

    return(_tcstol(n->argptr, NULL, 10) <= LastRetCode);
}



/***    eCmdExtVer - executes an CMDEXTVERSION If conditional
 *
 *  Purpose:
 *      If CMDEXTVERSION >= the value in the node, return 1.  If not,
 *      return 0.  This routine is never called unless command extensions
 *      are enabled.
 *
 *  int eCmdExtVer(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the CMDEXTVERSION command
 *
 *  Returns:
 *      See above.
 *
 */

int eCmdExtVer(n)
struct cmdnode *n;
{
    DEBUG((BPGRP, IFLVL, "CMDEXTVERSION: argptr = `%ws'  VER = %d", n->argptr, CMDEXTVERSION));

    return(_tcstol(n->argptr, NULL, 10) <= CMDEXTVERSION);
}



/***    eDefined - execute the DEFINED conditional of an if statement
 *
 *  Purpose:
 *      Return 1 if the environment variable in node n exists.  Otherwise return 0.
 *      This routine is never called unless command extensions are enabled.
 *
 *  int eDefined(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the exist command
 *
 *  Returns:
 *      See above.
 *
 */

int eDefined(n)
struct cmdnode *n;
{
    return(GetEnvVar(n->argptr)!= NULL);
}



/***    eExist - execute the exist conditional of an if statement
 *
 *  Purpose:
 *      Return 1 if the file in node n exists.  Otherwise return 0.
 *
 *  int eExist(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the exist command
 *
 *  Returns:
 *      See above.
 *
 */

int eExist(n)
struct cmdnode *n;
{
    return(exists(n->argptr));
}




/***    eNot - execute the not condition of an if statement
 *
 *  Purpose:
 *      Return the negated result of the if conditional pointed to by
 *      n->argptr.
 *
 *  int eNot(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the not command
 *
 *  Returns:
 *      See above.
 *
 */

int eNot(n)
struct cmdnode *n;
{
    UNREFERENCED_PARAMETER( n );
#if DBG
    cmd_printf( TEXT("CMD: should never get here\n") );
    DebugBreak();
#endif
    return 0;
}




/***    eStrCmp - execute an if statement string comparison
 *
 *  Purpose:
 *      Return a nonzero value if the 2 strings in the node are equal.
 *      Otherwise return 0.
 *
 *  int eStrCmp(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the string comparison command
 *
 *  Returns:
 *      See above.
 *
 */

int eStrCmp(n)
struct cmdnode *n;
{
    DEBUG((BPGRP, IFLVL, "STRCMP: returning %d", !_tcscmp(n->cmdline, n->argptr)));

    //
    // If the parse node says to ignore case, do a case insensitive compare
    // otherwise case sensitive.  The ignore case will never be set unless
    // command extensions are enabled.
    //
    if (n->flag & CMDNODE_FLAG_IF_IGNCASE)
        return(!lstrcmpi(n->cmdline, n->argptr));
    else
        return(!lstrcmp(n->cmdline, n->argptr));
}



/***    eGenCmp - execute an if statement comparison - general case
 *
 *  Purpose:
 *      Return a nonzero value if comparison condition is met.
 *      Otherwise return 0.  This routine is never called unless
 *      command extensions are enabled.
 *
 *  int eStrCmp(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the string comparison command
 *
 *  Returns:
 *      See above.
 *
 */

int eGenCmp(n)
struct cmdnode *n;
{
    TCHAR *s1, *s2;
    LONG n1, n2, iCompare;

    n1 = _tcstol(n->cmdline, &s1, 0);
    n2 = _tcstol(n->argptr, &s2, 0);
    if (*s1 == NULLC && *s2 == NULLC)
        iCompare = n1 - n2;
    else
        if (n->flag & CMDNODE_FLAG_IF_IGNCASE)
        iCompare = lstrcmpi(n->cmdline, n->argptr);
    else
        iCompare = lstrcmp(n->cmdline, n->argptr);

    switch (n->cmdarg) {
    case CMDNODE_ARG_IF_EQU:
        return iCompare == 0;

    case CMDNODE_ARG_IF_NEQ:
        return iCompare != 0;

    case CMDNODE_ARG_IF_LSS:
        return iCompare < 0;

    case CMDNODE_ARG_IF_LEQ:
        return iCompare <= 0;

    case CMDNODE_ARG_IF_GTR:
        return iCompare > 0;

    case CMDNODE_ARG_IF_GEQ:
        return iCompare >= 0;
    }

    return 0;
}




/***    ePause - execute the Pause command
 *
 *  Purpose:
 *      Print a message and pause until a character is typed.
 *
 *  int ePause(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the pause command
 *
 *  Returns:
 *      SUCCESS always.
 *
 *  Notes:
 *      M025 - Altered to use DOSREAD for pause response and to use
 *      new function SetKMode to insure that if STDIN is KBD, it will
 *      will be in raw mode when DOSREAD accesses it.
 *      M041 - Changed to use single byte var for input buffer.
 *           - Changed to do direct KB read if STDIN == KBD.
 *
 */

int ePause(n)
struct cmdnode *n;
{
    ULONG cnt;      // Count of response bytes
    TCHAR c;               // Retrieval buffer


    UNREFERENCED_PARAMETER( n );
    DEBUG((BPGRP, OTLVL, "PAUSE"));

    PutStdOut(MSG_STRIKE_ANY_KEY, NOARGS);

    if (FileIsDevice(STDIN) && (flgwd & 1)) {
        FlushConsoleInputBuffer( GetStdHandle(STD_INPUT_HANDLE) );
        c = (TCHAR)_getch();
        if (c == 0x3) {
            SetCtrlC();
        }
    } else {
        ReadBufFromInput(
                        GetStdHandle(STD_INPUT_HANDLE),
                        (TCHAR*)&c, 1, (LPDWORD)&cnt);
    }

    cmd_printf(CrLf);
    return(SUCCESS);
}




/***    eShift - execute the Shift command
 *
 *  Purpose:
 *      If a batch job is being executed, shift the batch job's vars one to the
 *      left.  The value for %0 is never shifted.  The value for %1 is lost.
 *      If there are args that have not been assigned to a variable, the next
 *      one is assigned to %9.  Otherwise, %9's value is NULLed.
 *
 *      If no batch job is in progress, just return.
 *
 *  int eShift(struct cmdnode *n)
 *
 *  Returns:
 *      SUCCESS always.
 *
 *  Notes:
 *      As of Modification number M004, the value of %0 is now included in
 *      in the shift command.
 */

int eShift(n)
struct cmdnode *n;
{
    struct batdata *bdat;
    TCHAR *s;
    int iStart;
    int i;

    DEBUG((BPGRP, OTLVL, "SHIFT: CurrentBatchFile = %lx", CurrentBatchFile));

    if (CurrentBatchFile) {
        bdat = CurrentBatchFile;

        //
        // If extensions are enabled, look for /n switch that specifies
        // the starting index of the shift.  Zero is the default starting
        // index.
        //
        iStart = 0;
        if (fEnableExtensions && n->argptr) {
            s = EatWS( n->argptr, NULL );
            if (*s++ == SWITCHAR && (*s >= L'0' && *s < L'9')) {
                iStart = *s - L'0';
            } else if (_tcslen(s)) {
                PutStdErr(MSG_SHIFT_BAD_ARG, NOARGS);
                LastRetCode = FAILURE;
                return FAILURE;
            }
        }
        for (i = iStart; i < 9; i++) {
            bdat->aptrs[i] = bdat->aptrs[i+1];
            bdat->alens[i] = bdat->alens[i+1];

            DEBUG((BPGRP, OTLVL, "SHIFT: #%d  addr = %lx  len = %d", i, bdat->aptrs[i], bdat->alens[i]));
        }

        if ((bdat->args) && (*bdat->args)) {
            bdat->aptrs[9] = bdat->args;
            bdat->alens[9] = i = mystrlen(bdat->args);
            bdat->args += i+1;

            DEBUG((BPGRP, OTLVL, "SHIFT: #9  %lx  len = %d  args = %ws", bdat->aptrs[9], bdat->alens[9], bdat->args));

        } else {
            bdat->aptrs[9] = NULL;
            bdat->alens[9] = 0;

            DEBUG((BPGRP, OTLVL, "SHIFT: #9  was NULLed."));
        }
    }

    return(SUCCESS);
}




/***    eSetlocal - Begin Local treatment of environment commands
 *
 *  Purpose:
 *      To prevent the export of environment alterations to COMMAND's
 *      current environment by saving copies of the current directory
 *      and environment in use at the time.
 *
 *  int eSetlocal(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the SETLOCAL command
 *
 *  Returns:
 *      Always returns SUCCESS.
 *
 *  Notes:
 *    - All directory and environment alterations occuring after the
 *      execution of this command will affect only the copies made and
 *      hence will be local to this batch file (and child processes
 *      invoked by this batch file) until a subsequent ENDLOCAL command
 *      is executed.
 *    - The data stack level, referenced by CurrentBatchFile->stacksize, does not
 *      include the memory malloc'd for saving the directory & environment.
 *      As a result, the next call to Parser() would free up these items.
 *      To prevent this, the data stack pointer in the current batch data
 *      structure, is set to a level beyond these two items; including also
 *      some memory malloc'd in functions between the last call to Parser()
 *      and the current execution of eSetlocal().  This memory will only be
 *      freed when Parser() is called following termination of the current
 *      batch file.  To attempt to save the current stack level and restore
 *      it in eEndlocal() works only if both commands occur in the same
 *      file.  If eEndlocal() comes in a nested file, the resulting freeing
 *      of memory by Parser() would also eliminate even the batch data
 *      structures occuring between the two.
 *
 */

int eSetlocal(n)
struct cmdnode *n;
{
    struct envdata *CopyEnv();
    struct batsaveddata *p;
    TCHAR *tas;            /* Tokenized argument list         */

    if (CurrentBatchFile) {
        if (CurrentBatchFile->SavedEnvironmentCount < CMD_MAX_SAVED_ENV) {      // Check also CurrentBatchFile

            DEBUG((BPGRP, OTLVL, "SLOC: Performing localizing"));

            p = HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( *p ));
            if (!p)
                return FAILURE;

            p->dircpy = HeapAlloc( GetProcessHeap( ),
                                   HEAP_ZERO_MEMORY,
                                   mystrlen( CurDrvDir )*sizeof( TCHAR )+sizeof( TCHAR ));
            if (!p->dircpy)
                return FAILURE;
            else
                mystrcpy(p->dircpy, CurDrvDir);

            p->envcpy = CopyEnv();
            if (!p->envcpy)
                return FAILURE;

            //
            // Save this in case it is modified, so it can be
            // restored when the matching ENDLOCAL is executed.
            //

            p->fEnableExtensions = fEnableExtensions;
            p->fDelayedExpansion = fDelayedExpansion;

            CurrentBatchFile->saveddata[CurrentBatchFile->SavedEnvironmentCount] = p;
            CurrentBatchFile->SavedEnvironmentCount += 1;

            if (CurrentBatchFile->stacksize < (CurrentBatchFile->stackmin = DCount)) {
                CurrentBatchFile->stacksize = DCount;
            }

            //
            //  If there is addional text on the command line, see
            //  if it matches various keywords that enable or disable
            //  features inside scripts.
            //
            //  We do this regardless
            //  of where extensions are currently enabled, so we can
            //  use this mechanism to temporarily turn on/off extensions
            //  from inside of a command script as needed.  The original
            //  CMD.EXE ignored any extra text on the SETLOCAL command
            //  line, did not declare an error and did not set ERRORLEVEL
            //  Now it looks for the extra text and declares and error
            //  if it does not match one of the acceptable keywords and
            //  sets ERRORLEVEL to 1 if it does not.
            //
            //  Very minor incompatibility with old command scripts that
            //  that should not effect anybody.
            //

            tas = TokStr(n->argptr, NULL, TS_NOFLAGS);
            LastRetCode = SUCCESS;

            while (*tas != NULLC) {
                if (!_tcsicmp( tas, TEXT("ENABLEEXTENSIONS"))) {
                    fEnableExtensions = TRUE;
                } else if (!_tcsicmp( tas, TEXT("DISABLEEXTENSIONS"))) {
                    fEnableExtensions = FALSE;
                } else if (!_tcsicmp( tas, TEXT( "ENABLEDELAYEDEXPANSION" ))) {
                    fDelayedExpansion = TRUE;
                } else if (!_tcsicmp( tas, TEXT( "DISABLEDELAYEDEXPANSION" ))) {
                    fDelayedExpansion = FALSE;
                } else if (*tas != NULLC) {
                    PutStdErr(MSG_SETLOCAL_BAD_ARG, NOARGS);
                    LastRetCode = FAILURE;
                    return FAILURE;
                }

                tas += mystrlen( tas ) + 1;
            }

        } else {
            PutStdErr(MSG_MAX_SETLOCAL,NOARGS);
            return FAILURE;
        }
    }

    DEBUG((BPGRP, OTLVL, "SLOC: Exiting"));

    return(SUCCESS);
}




/***    eEndlocal - End Local treatment of environment commands
 *
 *  Purpose:
 *      To reestablish the export of environment alterations to COMMAND's
 *      current environment.  Once this command is encountered, the current
 *      directory and the current environment in use at the time of the
 *      initial SETLOCAL command will be restored from their copies.
 *
 *  int eEndlocal(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the ENDLOCAL command
 *
 *  Returns:
 *      Always returns SUCCESS.
 *
 *  Notes:
 *      Issuance of an ENDLOCAL command without a previous SETLOCAL command
 *      is bad programming practice but not considered an error.
 *
 */

int eEndlocal(n)
struct cmdnode *n;
{
    struct batdata *bdat = CurrentBatchFile;

    UNREFERENCED_PARAMETER( n );

    ElclWork( bdat );

    return(SUCCESS);
}

void EndAllLocals( struct batdata *bdat )
{
    //
    // If a restricted token was created to run this batch file then close it.
    // Also, revert to the process token. The matching impersonate was done in
    // SetBat.
    //

    if (bdat->hRestrictedToken != NULL) {
        RevertToSelf();
        CloseHandle(bdat->hRestrictedToken);
        bdat->hRestrictedToken = NULL;
    }

    while (bdat->SavedEnvironmentCount != 0) {
        ElclWork( bdat );
    }
}

/***    ElclWork - Restore copied directory and environment
 *
 *  Purpose:
 *      If the current batch data structure contains valid pointers to
 *      copies of the current directory and environment, restore them.
 *
 *  int ElclWork(struct batdata *bdat)
 *
 *  Args:
 *      bdat - the batch data structure containing copied dir/env pointers
 *
 *  Returns:
 *      Always returns SUCCESS.
 *
 *  Notes:
 *      The level of stacked data, ie. CurrentBatchFile->stacksize, cannot be restored
 *      to its pre-SETLOCAL level in case this command is occuring in a
 *      later nested batch file.  To do so would free the memory containing
 *      its own batch data structure.  Only when the current batch file
 *      terminates and is popped off the stack, will Parser() free up the
 *      memory containing the copies.  Issuance of an ENDLOCAL command
 *      without a previous SETLOCAL command is bad programming practice
 *      but not considered an error.
 *
 */

void ElclWork( struct batdata *bdat )
{
    TCHAR c;
    struct batsaveddata *p;

    if (bdat == NULL) {
        return;
    }

    if (bdat->SavedEnvironmentCount == 0) {
        return;
    }

    bdat->SavedEnvironmentCount--;
    p = bdat->saveddata[bdat->SavedEnvironmentCount];

    bdat->saveddata[bdat->SavedEnvironmentCount] = NULL;

    if (p == NULL) {
        return;
    }

    c = _toupper( *p->dircpy );
    if (CurDrvDir[0] != c) {
        ChangeDrive( c - 0x20 );
    }
    ChangeDir( p->dircpy);

    ResetEnv( p->envcpy );

    fEnableExtensions = p->fEnableExtensions;
    fDelayedExpansion = p->fDelayedExpansion;

    HeapFree( GetProcessHeap( ), 0, p->dircpy );
    HeapFree( GetProcessHeap( ), 0, p );
}

/***    eCall - begin the execution of the Call command
 *
 *  Purpose:
 *      This is Command's interface to the Call function.  It just calls
 *      CallWork with its command node, and sets LastRetCode.
 *
 *  int eCall(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the copy command
 *
 *  Returns:
 *      Whatever CallWork() returns.
 *
 */


int eCall(n)
struct cmdnode *n;
{
    int CallWork();

    return(LastRetCode = CallWork(n->argptr)); /* @@ */
}


/***    CallWork - Execute another batch file as a subroutine (M009 - New)
 *
 *  Purpose:
 *      Parse the argument portion of the current node.  If it is a batch
 *      file invocation, call BatProc() with the newly parsed node.
 *
 *  int CallWork(TCHAR *fname)
 *
 *  Args:
 *      fname - pointer to the batch file to be CALLed
 *
 *  Returns:
 *      The process return code of the child batch file or
 *      SUCCESS if null node or
 *      FAILURE if PARSERROR or unable to exec as batch file.
 *
 *  Notes:
 *      The CALLing of batch files is much the same as the proposed
 *      "new-style" batch file concept, except with regard to localizing
 *      environment and directory alterations.
 *
 */

int ColonIsToken;

int CallWork(fname)
TCHAR *fname;
{
    struct node *c;        /* New node for CALL statement     */
    TCHAR *flptr;          /* Ptr to file location            */
    int i;                         /* Work variable                   */
    TCHAR *t1, *t2,                 /* M041 - Temp pointer             */
    *aptr;                    /* M041 - New arg pointer          */
    TCHAR *temp_parm;              /* @@4a */
    unsigned rc;

    DEBUG((BPGRP,OTLVL,"CALL: entered"));

    if (fname == NULL) {

        return( FAILURE );

    }
    if (!(flptr = mkstr(MAX_PATH*sizeof(TCHAR))))   /* Filespec to run   */
        return(FAILURE);

/*  Note that in reparsing the argument portion of the current statement
 *  we do not have to concern ourselves with redirection.  It was already
 *  set up when the CALL statement was dispatch()'ed.
 *  M041 - We do, however, have to "re-escape" any escape characters
 *  before reparsing or they will disappear.
 */
    aptr = fname;                      /* Initialize it           */
    if (t1 = mystrchr(fname, ESCHAR)) {
        if (!(aptr = mkstr(((mystrlen(fname) * 2) + 1) * sizeof(TCHAR))))
            return(FAILURE);
        t2 = aptr;
        t1 = fname;
        while (*t1)
            if ((*t2++ = *t1++) == ESCHAR)
                *t2++ = ESCHAR;
        *t2 = NULLC;
        if (!(aptr = resize(aptr, (mystrlen(aptr) + 1)*sizeof(TCHAR))))
            return(FAILURE);
    }

    i = DCount;                    /* Valid data ptr for parser       */

    DEBUG((BPGRP,OTLVL,"CALL: Parsing %ws",fname));

    ColonIsToken = 1;
    c=Parser(READSTRING, (INT_PTR)aptr, i);
    ColonIsToken = 0;

    if (c == (struct node *) PARSERROR) {

        DEBUG((BPGRP,OTLVL,"CALL: Parse error, returning failure"));     

        /*@@5c */

if (!(temp_parm = mkstr(((mystrlen(aptr) * 2) + 1) * sizeof(TCHAR))))
            return(FAILURE);
        /*@@5a */mystrcpy(temp_parm, aptr);
        _tcsupr(temp_parm);     
        /*@@5a */
        /*@@5a */if ( (!_tcscmp(temp_parm, TEXT(" IF" ))) ||
                      /*@@5a */         (!_tcscmp(temp_parm, TEXT(" FOR" ))) )
        /*@@5a */
        {         
            /*@@5a */
            PutStdErr( MSG_SYNERR_GENL, ONEARG, aptr );  /* @@4 */
            /*@@5a */
        }

        return(FAILURE);
    }

    if (c == (struct node *) EOF) {

        DEBUG((BPGRP,OTLVL,"CALL: Found EOF, returning success"));

        return(SUCCESS);
    }

    DEBUG((BPGRP,OTLVL,"CALL: Parsed OK, looking for batch file"));

    //
    // If extensions are enable, check for the new form of the CALL
    // statement:
    //
    //      CALL :label args...
    //
    // which is basically a form of subroutine call within command scripts.
    // If the target of the CALL begins with a COLON then do nothing
    // here and let BatProc take care of it when it is called below.
    //
    // Otherwise, execute the old code, which will search for a command
    // script file or executable.
    //
    if (fEnableExtensions && *((struct cmdnode *)c)->cmdline == COLON) {
        //
        // The new form is only valid inside of a command script, so
        // declare an error if the user entered it from the command line
        //
        if (CurrentBatchFile == NULL) {
            PutStdErr( MSG_CALL_LABEL_INVALID, NOARGS );
            return(FAILURE);
        }
    } else
        if ((mystrchr(((struct cmdnode *)c)->cmdline, STAR) ||   /* M035    */
             mystrchr(((struct cmdnode *)c)->cmdline, QMARK) ||
             (i = SearchForExecutable((struct cmdnode *)c, flptr)) != SFE_ISBAT)) {

        rc = FindFixAndRun( (struct cmdnode *)c );
        return(rc); /*@@5*/

    }

    DEBUG((BPGRP,OTLVL,"CALL: Found batch file"));

    rc = BatProc((struct cmdnode *)c, flptr, BT_CALL);

    /* @@6a If rc is zero, return LastRetCode because it might != 0 */
    return(rc ? rc : LastRetCode);
}


/***    eBreak - begin the execution of the BREAK command
 *
 *  Purpose:
 *      Does nothing as it is only here for compatibility.  If extensions are
 *      enabled and running on Windows NT, then enters a hard coded breakpoint
 *      if this process is being debugged by a debugger.
 *
 *  int eExtproc(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the copy command
 *
 *  Returns:
 *      SUCCESS;
 *
 */

int eBreak(struct cmdnode *n)
{
    UNREFERENCED_PARAMETER( n );
#if !defined( WIN95_CMD ) && DBG
    if (fEnableExtensions &&
        lpIsDebuggerPresent != NULL &&          // Only true on NT
        (*lpIsDebuggerPresent)()) {
        DebugBreak();
    }
#endif
    return(SUCCESS);
}


BOOL
ReadBufFromFile(
               HANDLE      h,
               TCHAR       *pBuf,
               int         cch,
               int         *pcch)
{
    int         cb;
    UCHAR       *pch = AnsiBuf;
    int         cchNew;
    DWORD       fPos;

    fPos = SetFilePointer(h, 0, NULL, FILE_CURRENT);
    if (ReadFile(h, AnsiBuf, cch, pcch, NULL) == 0)
        return 0;
    if (*pcch == 0)
        return 0;

    /* check for lead character at end of line */
    cb = cchNew = *pcch;
    while (cb > 0) {
        if ( (cb >=3 ) &&
             ( (*pch == '\n' && *(pch+1) == '\r') ||
               (*pch == '\r' && *(pch+1) == '\n') )  ) {
            *(pch+2) = '\000';
            cchNew = (int)(pch - AnsiBuf) + 2;
            SetFilePointer(h, fPos+cchNew, NULL, FILE_BEGIN);
            break;
        } else if (is_dbcsleadchar(*pch)) {
            if (cb == 1) {
                if (ReadFile(h, pch+1, 1, &cb, NULL) == 0 || cb == 0) {
                    *pcch = 0;
                    return 0;
                }
                cchNew++;
                break;
            }
            cb -= 2;
            pch += 2;
        } else {
            cb--;
            pch++;
        }
    }
#ifdef UNICODE
    cch = MultiByteToWideChar(CurrentCP, MB_PRECOMPOSED, AnsiBuf, cchNew, pBuf, cch);
#else
    memmove(pBuf, AnsiBuf, cchNew);
    cch = cchNew;
#endif
    *pcch = cch;
    return cch;
}

BOOL
ReadBufFromConsole(
                  HANDLE      h,
                  TCHAR*      pBuf,
                  int         cch,
                  int         *pcch)
{
    CONSOLE_READCONSOLE_CONTROL InputControl;
    BOOL ReadConsoleResult, bTouched, bPathCompletion, bHaveHScrollBar, bHaveVScrollBar;
    PTCHAR PrevBuf;
    DWORD cchPrevBuf;
    DWORD cchRead;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD InitialCursorPosition;
    HANDLE hOut;
    DWORD cchBuf;
    ULONG i, iCompletionCh, iCR;
    DWORD nLines, nCols;

    //
    // Original code just called ReadConsole with the passed parameters.
    // Now, we attempt to call the new improved ReadConsole with an extra
    // parameter to enable intermediate wakeups from the read to process
    // a file completion control character.  This new feature is only
    // enabled if all of the following are true:
    //  Command extensions are enabled
    //  User has defined a command completion control character
    //  Standard Output Handle is a console output handle
    //
    // If any of the above are not true, do it the old way.
    //

    hOut = GetStdHandle( STD_OUTPUT_HANDLE );
    if (hOut == INVALID_HANDLE_VALUE)
        hOut = CRTTONT( STDOUT );
    if (!fEnableExtensions ||
        chCompletionCtrl >= SPACE ||
        chPathCompletionCtrl >= SPACE ||
        !GetConsoleScreenBufferInfo( hOut, &csbi )
       )
        return ReadConsole(h, pBuf, cch, pcch, NULL);

    InitialCursorPosition = csbi.dwCursorPosition;
    nLines = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
    nCols = csbi.srWindow.Right - csbi.srWindow.Left + 1;
    bHaveHScrollBar = ((SHORT)nCols != csbi.dwSize.X);
    bHaveVScrollBar = ((SHORT)nLines != csbi.dwSize.Y);

    //
    // All conditions are met, so set up the extra parameter to
    // ReadConsole to tell it what control character(s) are to
    // cause the read to return with intermediate results.
    //

    InputControl.nLength = sizeof(CONSOLE_READCONSOLE_CONTROL);
    InputControl.nInitialChars = 0;
    InputControl.dwCtrlWakeupMask = (1 << chCompletionCtrl);
    InputControl.dwCtrlWakeupMask |= (1 << chPathCompletionCtrl);
    InputControl.dwControlKeyState = 0;

    //
    // We will now loop until the user type enter, processing any
    // intermediate wakeups as file completion requests.
    //
    DoCompleteInitialize();
    PrevBuf = NULL;
    cchPrevBuf = 0;
    while (TRUE) {
        //
        // Read a line of input from the console.
        //

        ReadConsoleResult = ReadConsole(h, pBuf, cch, pcch, &InputControl);
        cchRead = *pcch;

        if (CtrlCSeen) {
            ResetCtrlC( );
            if (PrevBuf)
                HeapFree(GetProcessHeap(), 0, PrevBuf);
            PrevBuf = NULL;
        }

        //
        // If the read failed for any reason, we are done.
        //
        if (!ReadConsoleResult)
            break;

        //
        // Make sure the result buffer is null terminated.  If the buffer
        // contains a carriage return, then the use must have hit enter, so
        // break out of the loop to return the command line to the caller.
        //
        bPathCompletion = FALSE;
        iCR = iCompletionCh = 0xFFFFFFFF;
        for (i=0; i<(ULONG)*pcch; i++) {
            if (pBuf[i] == CR) {
                iCR = i;
                break;
            } else
                if (pBuf[i] == chCompletionCtrl) {
                iCompletionCh = i;
                break;
            } else
                if (pBuf[i] == chPathCompletionCtrl) {
                iCompletionCh = i;
                bPathCompletion = TRUE;
                break;
            }
        }
        if (iCR != 0xFFFFFFFF) {
            break;
        }

        //
        // Use did not hit enter, so they must have hit the file completion
        // control character.  Find where they did this and terminate the
        // result buffer at that point.  If not found, then assume they hit
        // enter and break out of the loop to return what we have.
        //
        if (iCompletionCh == 0xFFFFFFFF) {
            break;
        }

        //
        // Found the file completion control character.  Dont count it as read.
        // Null terminate the buffer and see if the buffer contents before
        // the completion character is the same as what we displayed last.
        //
        *pcch = iCompletionCh;
        pBuf[iCompletionCh] = NULLC;
        if (PrevBuf == NULL || _tcscmp(pBuf, PrevBuf))
            bTouched = TRUE;
        else
            bTouched = FALSE;

        //
        // If we know we are processing a command that only takes directory
        // names are arguments, force completion code to only match directory
        // names.
        //
        if (!bPathCompletion && iCompletionCh > 2) {
            if (!_tcsnicmp(pBuf, TEXT("cd "), 3) 
                || !_tcsnicmp(pBuf, TEXT("rd "), 3) 
                || !_tcsnicmp(pBuf, TEXT("md "), 3) 
                || !_tcsnicmp(pBuf, TEXT("chdir "), 6) 
                || !_tcsnicmp(pBuf, TEXT("rmdir "), 6) 
                || !_tcsnicmp(pBuf, TEXT("mkdir "), 6) 
                || !_tcsnicmp(pBuf, TEXT("pushd "), 6)

               ) {
                bPathCompletion = TRUE;
            }
        }

        //
        // Call the file completion code with the input buffer, current length,
        // whether the user had the shift key down or not (SHIFT means backwards)
        // and whether or not the user modified the input buffer since the last
        // time it was displayed.  If the user did not modify what was last displayed
        // then that tells the file completion code to display the next matching
        // file name from the list as opposed to recalculating the list of matching
        // files.
        //
        if ( DoComplete( pBuf,
                         iCompletionCh,
                         cch,
                         !(InputControl.dwControlKeyState & SHIFT_PRESSED),
                         bPathCompletion,
                         bTouched
                       )
           ) {
            //
            //  Recompute the position of the start of the command line, since
            //  it might have scrolled around since when we first wrote it out.
            //

            if (GetConsoleScreenBufferInfo( hOut, &csbi )) {
                //
                //  Walk backwards from the current cursor position to determine the 
                //  proper initial position for screen blanking and for the next 
                //  ReadConsole
                //
                //  The row (Y) of the next input is based on the number of lines 
                //  consumed by the prompt plus the length of what the user has input. 
                //  There is no need to round at all since any remainder is simply 
                //  how far on the screen we are.
                //

                InitialCursorPosition.Y =
                (SHORT) (csbi.dwCursorPosition.Y 
                         - (InitialCursorPosition.X + iCompletionCh) / csbi.dwSize.X);
            }

            //
            // Completion found a new file name and put it in the buffer.
            // Update the length of valid characters in the buffer, redisplay
            // the buffer at the cursor position we started, so the user can
            // see the file name found
            //
            cchBuf = _tcslen(pBuf);
            SetConsoleCursorPosition( hOut, InitialCursorPosition );

            FillConsoleOutputCharacter( hOut, 
                                        TEXT( ' ' ), 
                                        cchRead, 
                                        InitialCursorPosition, 
                                        &cchRead );

            WriteConsole(hOut, pBuf, cchBuf, &cchBuf, NULL);

            InputControl.nInitialChars = cchBuf;
        } else {
            //
            // File completion had nothing to had, so just beep and redo the read.
            //
            MessageBeep( 0xFFFFFFFF );
            InputControl.nInitialChars = _tcslen(pBuf);
        }

        //
        // Done with file completion.  Free any previous buffer copy and
        // allocate a copy of the current input buffer so we will know if the
        // user has changed it or not.
        //
        if (PrevBuf)
            HeapFree(GetProcessHeap(), 0, PrevBuf);
        cchPrevBuf = _tcslen(pBuf);
        PrevBuf = HeapAlloc(GetProcessHeap(), 0, (cchPrevBuf+1) * sizeof(TCHAR));
        _tcscpy(PrevBuf, pBuf);
    }

    //
    // All done.  Free any buffer copy and return the result of the read
    // to the caller
    //
    if (PrevBuf)
        HeapFree(GetProcessHeap(), 0, PrevBuf);

    return ReadConsoleResult;
}

BOOL
ReadBufFromInput(
                HANDLE      h,
                TCHAR       *pBuf,
                int         cch,
                int         *pcch)
{
    unsigned htype;

    htype = GetFileType(h);
    htype &= ~FILE_TYPE_REMOTE;

    if (htype == FILE_TYPE_CHAR)
        return ReadBufFromConsole(h, pBuf, cch, pcch);
    else
        return ReadBufFromFile(h, pBuf, cch, pcch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cdata.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cdata.c

Abstract:

    Global data

--*/

#include "cmd.h"

TCHAR CrLf[]     = TEXT("\r\n");                        // M022
TCHAR DBkSpc[] = TEXT("\b \b");         // M022
#if defined(FE_SB)
TCHAR DDBkSpc[] = TEXT("\b\b  \b\b");
#endif // defined(FE_SB)

//
// M010 - std_(e)printf format strings
//

TCHAR Fmt00[] = TEXT("   ");
TCHAR Fmt01[] = TEXT("  ");
TCHAR Fmt02[] = TEXT(" %s ");
TCHAR Fmt03[] = TEXT("%-9s%-4s");
TCHAR Fmt04[] = TEXT("%02d%s%02d%s");                //  DD/DD?
TCHAR Fmt05[] = TEXT("%2d%s%02d%s%02d");            //  DD/DD/DD
TCHAR Fmt06[] = TEXT("%2d%s%02d%s%02d%s%02d");      //  DD:DD:DD.DD
TCHAR Fmt08[] = TEXT("%10lu  ");
TCHAR Fmt09[] = TEXT("[%s]");
TCHAR Fmt10[] = TEXT("%02d%s%02d%s%02d");           //  OO/DD/DD
TCHAR Fmt11[] = TEXT("%s ");
TCHAR Fmt12[] = TEXT("%s %s%s ");
TCHAR Fmt13[] = TEXT("(%s) %s ");
TCHAR Fmt15[] = TEXT("%s %s ");
TCHAR Fmt16[] = TEXT("%s=%s\r\n");
TCHAR Fmt17[] = TEXT("%s\r\n");
TCHAR Fmt18[] = TEXT("%c%c");                       // M016 - I/O redirection echo
TCHAR Fmt19[] = TEXT("%c");
TCHAR Fmt20[] = TEXT(">");                          // M016 - Additional append symbol
TCHAR Fmt21[] = TEXT("  %03d");
TCHAR Fmt22[] = TEXT("%s%s  %03d");
TCHAR Fmt26[] = TEXT("%04X-%04X");                  // for volume serial number
TCHAR Fmt27[] = TEXT("%s>");                        // default prompt string


//
// M010 - command name strings
//


TCHAR AppendStr[]   = TEXT("DPATH");        // @@ - Added APPEND command
TCHAR CallStr[]     = TEXT("CALL");         // M005 - Added CALL command
TCHAR CdStr[]       = TEXT("CD");
TCHAR ColorStr[]    = TEXT("COLOR");
TCHAR TitleStr[]    = TEXT("TITLE");
TCHAR ChdirStr[]    = TEXT("CHDIR");
TCHAR ClsStr[]      = TEXT("CLS");
TCHAR CmdExtVerStr[]= TEXT("CMDEXTVERSION");
TCHAR DefinedStr[]  = TEXT("DEFINED");
TCHAR CopyStr[]     = TEXT("COPY");
TCHAR CPathStr[]    = TEXT("PATH");
TCHAR CPromptStr[]  = TEXT("PROMPT");

TCHAR PushDirStr[]  = TEXT("PUSHD");
TCHAR PopDirStr[]   = TEXT("POPD");
TCHAR AssocStr[]    = TEXT("ASSOC");
TCHAR FTypeStr[]    = TEXT("FTYPE");

TCHAR DatStr[]      = TEXT("DATE");
TCHAR DelStr[]      = TEXT("DEL");
TCHAR DirStr[]      = TEXT("DIR");
TCHAR DoStr[]       = TEXT("DO");

TCHAR EchoStr[]     = TEXT("ECHO");
TCHAR ElseStr[]     = TEXT("ELSE");
TCHAR EndlocalStr[] = TEXT("ENDLOCAL");     // M004 - For Endlocal command
TCHAR EraStr[]      = TEXT("ERASE");
TCHAR ErrStr[]      = TEXT("ERRORLEVEL");
TCHAR ExitStr[]     = TEXT("EXIT");
TCHAR ExsStr[]      = TEXT("EXIST");
TCHAR BreakStr[]    = TEXT("BREAK");
#if 0
TCHAR ExtprocStr[]  = TEXT("EXTPROC");      // M007 - For EXTPROC command
#endif

TCHAR ForStr[]      = TEXT("FOR");
TCHAR ForHelpStr[]  = TEXT("FOR/?");
TCHAR ForLoopStr[]  = TEXT("/L");
TCHAR ForDirTooStr[]= TEXT("/D");
TCHAR ForParseStr[] = TEXT("/F");
TCHAR ForRecurseStr[]=TEXT("/R");

TCHAR GotoStr[]     = TEXT("GOTO");
TCHAR GotoEofStr[]  = TEXT(":EOF");

TCHAR IfStr[]       = TEXT("IF");
TCHAR IfHelpStr[]   = TEXT("IF/?");
TCHAR InStr[]       = TEXT("IN");
CHAR  InternalError[] = "\nCMD Internal Error %s\n";      // M028  10,...,10

TCHAR KeysStr[]     = TEXT("KEYS");         // @@5 - Keys internal command

TCHAR MkdirStr[]    = TEXT("MKDIR");
TCHAR MdStr[]       = TEXT("MD");

TCHAR NotStr[]      = TEXT("NOT");

TCHAR PausStr[]     = TEXT("PAUSE");

TCHAR RdStr[]       = TEXT("RD");
TCHAR RemStr[]      = TEXT("REM");
TCHAR RemHelpStr[]  = TEXT("REM/?");
TCHAR MovStr[]      = TEXT("MOVE");
TCHAR RenamStr[]    = TEXT("RENAME");
TCHAR RenStr[]      = TEXT("REN");
TCHAR RmdirStr[]    = TEXT("RMDIR");

TCHAR SetStr[]      = TEXT("SET");
TCHAR SetArithStr[] = TEXT("/A");
TCHAR SetPromptStr[]= TEXT("/P");
TCHAR SetlocalStr[] = TEXT("SETLOCAL");     // M004 - For Setlocal command
TCHAR ShiftStr[]    = TEXT("SHIFT");
TCHAR StartStr[]    = TEXT("START");        // @@ - Start Command

TCHAR TimStr[]      = TEXT("TIME");
TCHAR TypStr[]      = TEXT("TYPE");

TCHAR VeriStr[]     = TEXT("VERIFY");
TCHAR VerStr[]      = TEXT("VER");
TCHAR VolStr[]      = TEXT("VOL");


//
// Strings for string compares
//

TCHAR BatExt[]      = TEXT(".BAT");         // @@ old bat file extionsion
TCHAR CmdExt[]      = TEXT(".CMD");         // @@ new bat file extionsion

TCHAR ComSpec[]     = TEXT("\\CMD.EXE");          // M017
TCHAR ComSpecStr[]  = TEXT("COMSPEC");
TCHAR ComExt[]      = TEXT(".COM");

TCHAR Delimiters[]  = TEXT("=,;");
TCHAR Delim2[]      = TEXT(":.+/[]\\ \t\"");    // 20H,09H,22H;
TCHAR Delim3[]      = TEXT("=,");               // Delimiters - no semicolon
TCHAR Delim4[]      = TEXT("=,;+/[] \t\"");     // Command delimeters - no path characters
TCHAR Delim5[]      = TEXT(":.\\");             // Possible command delimeters - path characters
TCHAR DevNul[]      = TEXT("\\DEV\\NUL");

TCHAR ExeExt[]      = TEXT(".EXE");

TCHAR PathStr[]     = TEXT("PATH");
TCHAR PathExtStr[]  = TEXT("PATHEXT");
TCHAR PathExtDefaultStr[] = TEXT(".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS");

TCHAR PromptStr[]   = TEXT("PROMPT");

TCHAR VolSrch[]     = TEXT(" :\\*");             // Vol ID search (ctools1.c)   LNS

//
// Character Definitions
//

TCHAR BSlash    = BSLASH;         // M017 - Restored this char
TCHAR DPSwitch  = TEXT('P');
TCHAR DWSwitch  = TEXT('W');
TCHAR EqualSign = EQ;
TCHAR PathChar  = BSLASH;         // M000
TCHAR PCSwitch  = TEXT('p');
TCHAR BCSwitch  = TEXT('k');              // @@ - add /K switch to cmd.exe
TCHAR SCSwitch  = TEXT('c');
TCHAR QCSwitch  = TEXT('q');              // @@dv - add /Q switch to cmd.exe
TCHAR DCSwitch  = TEXT('b');              // add /B switch to cmd.exe
TCHAR UCSwitch  = TEXT('u');              // add /U switch to cmd.exe
TCHAR ACSwitch  = TEXT('a');              // add /A switch to cmd.exe
TCHAR XCSwitch  = TEXT('x');              // add /X switch to cmd.exe
TCHAR YCSwitch  = TEXT('y');              // add /Y switch to cmd.exe
TCHAR SwitChar  = SWITCHAR;               // M000


//
//   TmpBuf is a TMPBUFLEN byte temporary buffer which can be used by any function
//   so long as the function's use does not confict with any of the other uses
//   of the buffer.  It is HIGHLY reccommended that this buffer be used in place
//   of mallocing data or declaring new global variables whenever possible.
//
//   Once you have determined that your new use of the buffer does not conflict
//   with current uses of the buffer, add an entry in the table below.
//
//
//    TCHAR RANGE
//    USED       WHERE USED     REFERENCED BY         HOW LONG NEEDED
//   -----------+-------------+---------------------+--------------------------
//      0 - 1024| cparse.c    | All of the parser   | During parsing and lexing
//              |             | via TokBuf          |
//      0 - 128 | cinit.c     | SetUpEnvironment()  | During init
//              |             | Init()              |
//      0 - 513 | cbatch.c    | BatLoop(), SetBat() | During batch processing
//              |             | eGoTo()             | During label search
//      0 - 141 | cfile.c     | DelWork()           | Tmp buffer for path
//      0 - 141 |             | RenWork()           | Tmp buffer for path
//
//
//   *** NOTE: In some circumstances it may be beneficial to break up allocation
//   of this buffer and intermix other labels in it. In this way, you can
//   address a particular portion of the buffer without having to declare
//   another variable in your code to do so.
//
//   *** WARNING ***  If this buffer is used incorrectly bad things may happen
//   Bugs which are EXTREMELY difficult to track down could be introduce
//   if we are not VERY careful using this buffer.
//
//   *** WARNING *** When referencing TmpBuf in C files, make sure that TmpBuf
//   is declared as an array; NOT as a pointer.
//
//


TCHAR   TmpBuf[TMPBUFLEN];
CHAR    AnsiBuf[LBUFLEN];

HMODULE hKernel32 = INVALID_HANDLE_VALUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cmd\cext.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cext.c

Abstract:

    External command support

--*/

#include "cmd.h"

#define DBENV   0x0080
#define DBENVSCAN       0x0010

HANDLE hChildProcess;

unsigned start_type ;                                          /* D64 */

extern UINT CurrentCP;
extern TCHAR Fmt16[] ; /* @@5h */

extern unsigned DosErr ;
extern BOOL CtrlCSeen;

extern TCHAR CurDrvDir[] ;

extern TCHAR CmdExt[], BatExt[], PathStr[] ;
extern TCHAR PathExtStr[], PathExtDefaultStr[];
extern TCHAR ComSpec[] ;        /* M033 - Use ComSpec for SM memory        */
extern TCHAR ComSpecStr[] ;     /* M033 - Use ComSpec for SM memory        */
extern void tokshrink(TCHAR*);

extern TCHAR PathChar ;
extern TCHAR SwitChar ;

extern PTCHAR    pszTitleCur;
extern BOOLEAN  fTitleChanged;

extern int LastRetCode ;
extern HANDLE PipePid ;       /* M024 - Store PID from piped cmd   */

extern struct envdata CmdEnv ;    // Holds info to manipulate Cmd's environment

extern int  glBatType;     // to distinguish OS/2 vs DOS errorlevel behavior depending on a script file name

TCHAR  szNameEqExitCodeEnvVar[]       = TEXT ("=ExitCode");
TCHAR  szNameEqExitCodeAsciiEnvVar[]  = TEXT ("=ExitCodeAscii");


WORD
GetProcessSubsystemType(
    HANDLE hProcess
    );


/***    ExtCom - controls the execution of external programs
 *
 *  Purpose:
 *      Synchronously execute an external command.  Call ECWork with the
 *      appropriate values to have this done.
 *
 *  ExtCom(struct cmdnode *n)
 *
 *  Args:
 *      Parse tree node containing the command to be executed.
 *
 *  Returns:
 *      Whatever ECWork returns.
 *
 *  Notes:
 *      During batch processing, labels are ignored.  Empty commands are
 *      also ignored.
 *
 */

int ExtCom(n)
struct cmdnode *n ;
{
        if (CurrentBatchFile && *n->cmdline == COLON)
                return(SUCCESS) ;

        if (n && n->cmdline && mystrlen(n->cmdline)) {
                return(ECWork(n, AI_SYNC, CW_W_YES)) ;          /* M024    */
        } ;

        return(SUCCESS) ;
}





/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: ECWork                                             */
/*                                                                     */
/* DESCRIPTIVE NAME: Execute External Commands Worker                  */
/*                                                                     */
/* FUNCTION: Execute External Commands                                 */
/*           This routine calls SearchForExecutable routine to search  */
/*           for the executable command.  If the command ( .EXE, .COM, */
/*           or .CMD file ) is found, the command is executed.         */
/*                                                                     */
/* ENTRY POINT: ECWork                                                 */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT: n - the parse tree node containing the command to be executed*/
/*                                                                     */
/*        ai - the asynchronous indicator                              */
/*           - 0 = Exec synchronous with parent                        */
/*           - 1 = Exec asynchronous and discard child return code     */
/*           - 2 = Exec asynchronous and save child return code        */
/*                                                                     */
/*        wf - the wait flag                                           */
/*           - 0 = Wait for process completion                         */
/*           - 1 = Return immediately (Pipes)                          */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         If synchronous execution, the return code of the command is */
/*         returned.                                                   */
/*                                                                     */
/*         If asynchronous execution, the return code of the exec call */
/*         is returned.                                                */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/
/***    ECWork - begins the execution of external commands
 *
 *  Purpose:
 *      To search for and execute an external command.  Update LastRetCode
 *      if an external program was executed.
 *
 *  int ECWork(struct cmdnode *n, unsigned ai, unsigned wf)
 *
 *  Args:
 *      n - the parse tree node containing the command to be executed
 *      ai - the asynchronous indicator
 *         - 0 = Exec synchronous with parent
 *         - 1 = Exec asynchronous and discard child return code
 *         - 2 = Exec asynchronous and save child ret