IncreasingTimestampsDefault);

#endif // defined(DVR_UNOFFICIAL_BUILD)

        if (dwIncreasingTimeStamps)
        {
            SetFlags(EnforceIncreasingTimeStamps);
        }

        // Ensure that the open succeeded. No point deferring this to the first
	// WriteSample

        LIST_ENTRY* pCurrent = NEXT_LIST_NODE(&m_leWritersList);
        DVR_ASSERT(pCurrent != &m_leWritersList, "");

        PASF_WRITER_NODE pWriterNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

        DWORD nRet = ::WaitForSingleObject(pWriterNode->hReadyToWriteTo, INFINITE);
        if (nRet == WAIT_FAILED)
        {
            DVR_ASSERT(0, "Writer node's WFSO(hReadyToWriteTo) failed");

            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x", 
                            pWriterNode->hReadyToWriteTo, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
           __leave; 
        }

        if (pWriterNode->pWMWriter == NULL)
        {
            DVR_ASSERT(pWriterNode->pWMWriter != NULL, "");
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Writer node's pWMWriter is NULL?!");
            hrRet = E_FAIL;
            __leave;
        }

        // Verify there was no error in opening the file, i.e., BeginWriting 
        // succeeded
        if (FAILED(pWriterNode->hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Writer node's hrRet indicates failure, hrRet = 0x%x",
                            pWriterNode->hrRet);
            hrRet = pWriterNode->hrRet;
            __leave;
        }

    }
    __finally
    {
        if (phr)
        {
            *phr = hrRet;
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    return;

} // CDVRRingBufferWriter::CDVRRingBufferWriter

CDVRRingBufferWriter::~CDVRRingBufferWriter()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::~CDVRRingBufferWriter"

    DVRIO_TRACE_ENTER();

    // Since each recorder holds a ref count on this object, this 
    // will be called only when all recorders have been destroyed.

    if (!IsFlagSet(WriterClosed))
    {
        HRESULT hr;

        hr = Close();
        
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                        "Object had not been closed; Close() returned hr = 0x%x",
                        hr);
    }

    // Delete writer nodes corresponding to recordings that
    // were never started. See the comment in Close().
    LIST_ENTRY* pCurrent;  

    pCurrent = NEXT_LIST_NODE(&m_leFreeList);
    while (pCurrent != &m_leFreeList)
    {
        PASF_WRITER_NODE pFreeNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);
        
        DVR_ASSERT(pFreeNode->hFileClosed, "");
        
        // Ignore the returned status
        ::WaitForSingleObject(pFreeNode->hFileClosed, INFINITE);
        DVR_ASSERT(pFreeNode->pRecorderNode == NULL, "");
        RemoveEntryList(pCurrent);
        delete pFreeNode;
        pCurrent = NEXT_LIST_NODE(&m_leFreeList);
    }

    delete [] m_pwszDVRDirectory;

    DVR_ASSERT(m_hRegistryRootKey, "");

    DWORD dwRegRet = ::RegCloseKey(m_hRegistryRootKey);
    if (dwRegRet != ERROR_SUCCESS)
    {
        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                   "Closing registry key m_hRegistryRootKey failed.");
    }

    DVR_ASSERT(m_hDvrIoKey, "");

    dwRegRet = ::RegCloseKey(m_hDvrIoKey);
    if (dwRegRet != ERROR_SUCCESS)
    {
        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                   "Closing registry key m_hDvrIoKey failed.");
    }


    // Close should have cleaned up all this:
    DVR_ASSERT(m_pProfile == NULL, "");

    // Note: Close should not release the file collection 
    // if we support post-recording. We should do that 
    // here.
    DVR_ASSERT(m_pDVRFileCollection == NULL, "");
    DVR_ASSERT(m_pcnsCurrentStreamTime == NULL, "");
    DVR_ASSERT(m_pnWriterHasBeenClosed == NULL, "");
    DVR_ASSERT(IsListEmpty(&m_leRecordersList), "");
    DVR_ASSERT(IsListEmpty(&m_leWritersList), "");
    DVR_ASSERT(IsListEmpty(&m_leFreeList), "");

    ::DeleteCriticalSection(&m_csLock);

    DVRIO_TRACE_LEAVE0();

} // CDVRRingBufferWriter::~CDVRRingBufferWriter()


// ====== Helper methods

// static
DWORD WINAPI CDVRRingBufferWriter::ProcessOpenRequest(LPVOID p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::ProcessOpenRequest"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // We don't need to hold any locks in this function. We are guaranteed that
    // pNode won't be removed from m_leWritersList till hReadyToWriteTo is set
    // and Close() will not delete the node without removing it from the 
    // writer's list (and waiting for the file to be closed)

    PASF_WRITER_NODE pWriterNode = (PASF_WRITER_NODE) p;

    DVR_ASSERT(pWriterNode, "");
    DVR_ASSERT(pWriterNode->pWMWriter, "");
    DVR_ASSERT(pWriterNode->hReadyToWriteTo, "");
    DVR_ASSERT(::WaitForSingleObject(pWriterNode->hReadyToWriteTo, 0) == WAIT_TIMEOUT, "");

    IWMWriterFileSink*  pWMWriterFileSink = NULL;
    
    __try
    {
        hrRet = pWriterNode->pDVRFileSink->QueryInterface(IID_IWMWriterFileSink, (LPVOID*) &pWMWriterFileSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pWriterNode->pDVRFileSink->QueryInterface for IID_IWMWriterFileSink failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }

        LPCWSTR pwszFileName = pWriterNode->pwszFileName;

        if (pwszFileName == NULL)
        {
            DVR_ASSERT(pWriterNode->pRecorderNode, "");
            pwszFileName = pWriterNode->pRecorderNode->pwszFileName;
        }

        DVR_ASSERT(pwszFileName, "");
    
        hrRet = pWMWriterFileSink->Open(pwszFileName);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pWriterNode->pDVRFileSink->Open failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }

#if defined(DVR_UNOFFICIAL_BUILD)

        DVR_ASSERT(pWriterNode->cnsLastStreamTime == 0, "");

        DVR_ASSERT(pWriterNode->hVal == NULL, "");

        DWORD dwCreateValidationFiles = ::GetRegDWORD(pWriterNode->hDvrIoKey,
                                                      kwszRegCreateValidationFilesValue, 
                                                      kdwRegCreateValidationFilesDefault);

        if (dwCreateValidationFiles)
        {
            __try
            {
                WCHAR* pwszBuf = (WCHAR*) _alloca(wcslen(pWriterNode->pwszFileName + 4) * sizeof(WCHAR));
                if (pwszBuf == NULL)
                {
                    DVR_ASSERT(pwszBuf != NULL, "Alloca failed");
                    __leave;
                }
                wcscpy(pwszBuf, pWriterNode->pwszFileName);
                
                wcscat(pwszBuf, L".val");

                pWriterNode->hVal = ::CreateFileW(pwszBuf, 
                                                  GENERIC_WRITE, FILE_SHARE_READ, 
                                                  NULL, CREATE_ALWAYS, 
                                                  FILE_ATTRIBUTE_NORMAL, 
                                                  NULL);
                if (pWriterNode->hVal == INVALID_HANDLE_VALUE)
                {
                    DWORD dwLastError = ::GetLastError();   // for debugging only

                    DVR_ASSERT(0, "CreateFile of the validation file failed");
                    
                    pWriterNode->hVal = NULL;
                    __leave;
                }
            }
            __finally
            {
            }
        }

#endif // if defined(DVR_UNOFFICIAL_BUILD)

        hrRet = pWriterNode->pWMWriter->BeginWriting();
        if (FAILED(hrRet))
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "BeginWriting failed; hr = 0x%x for file id %u", 
                            hrRet, pWriterNode->nFileId);
            __leave;
        }

        DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE, 
                        "BeginWriting hr = 0x%x for file %u", 
                        hrRet, pWriterNode->nFileId);
    }
    __finally
    {
        // Do NOT change pWriterNode->hrRet after this till ProcessCloseRequest.
        // ProcessCloseRequest relies on seeing the value returned by BeginWriting
        pWriterNode->hrRet = hrRet;
        if (pWriterNode->pRecorderNode)
        {
            // Set the status on the associated recorder node
            pWriterNode->pRecorderNode->hrRet = hrRet;
        }
        
        delete [] pWriterNode->pwszFileName;
        pWriterNode->pwszFileName = NULL;

        if (pWMWriterFileSink)
        {
            pWMWriterFileSink->Release();
        }

        ::SetEvent(pWriterNode->hReadyToWriteTo);
    }

    // It's unsafe to reference pWriterNode after this as we do not hold any locks

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return 1;
    
    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRRingBufferWriter::ProcessOpenRequest

HRESULT CDVRRingBufferWriter::PrepareAFreeWriterNode(
    IN LPCWSTR                              pwszFileName,
    IN QWORD                                cnsStartTime,
    IN QWORD                                cnsEndTime,    
    IN QWORD*                               pcnsFirstSampleTimeOffsetFromStartOfFile,
    IN CDVRFileCollection::DVRIOP_FILE_ID   nFileId,
    IN PASF_RECORDER_NODE                   pRecorderNode,
    OUT LIST_ENTRY*&                        rpFreeNode)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::PrepareAFreeWriterNode"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    LIST_ENTRY*         pCurrent = &m_leFreeList;  
    BOOL                bRestore = 0;
    BOOL                bRemoveSink = 0;
    PASF_WRITER_NODE    pFreeNode;
    IWMWriterSink*      pWMWriterSink = NULL;

    __try
    {
        pCurrent = NEXT_LIST_NODE(pCurrent);
        while (pCurrent != &m_leFreeList)
        {
            pFreeNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);
            DVR_ASSERT(pFreeNode->hFileClosed, "");
            if (::WaitForSingleObject(pFreeNode->hFileClosed, 0) == WAIT_OBJECT_0)
            {
                if (pFreeNode->pRecorderNode != NULL)
                {
                    // This should not happen. Ignore this node and go on
                    DVR_ASSERT(pFreeNode->pRecorderNode == NULL, "");
                }
                else
                {
                    // Verify that the hReadyToWriteTo event is reset
                    DWORD nRet = ::WaitForSingleObject(pFreeNode->hReadyToWriteTo, 0);
                    if (nRet == WAIT_TIMEOUT)
                    {
                        break;
                    }

                    DVR_ASSERT(nRet != WAIT_OBJECT_0, "Free list node's hReadyToWriteTo is set?");
                    if (nRet == WAIT_OBJECT_0)
                    {
                        // This shouldn't happen; ignore the node and go on.
                        // Debug version will assert each time it hits this 
                        // node!
                    }
                    else
                    {
                        // This shouldn't happen either. Ignore this node and 
                        // move on.
                        DWORD dwLastError = ::GetLastError();
                        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                        "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x", 
                                        pFreeNode->hReadyToWriteTo, dwLastError);
                    }
                }
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }
        if (pCurrent == &m_leFreeList)
        {
            // Create a new node

            pFreeNode = new ASF_WRITER_NODE(&hrRet);
            
            if (pFreeNode == NULL)
            {
                hrRet = E_OUTOFMEMORY;
                DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "alloc via new failed - ASF_WRITER_NODE");
                pCurrent = NULL;
                __leave;
            }
            else if (FAILED(hrRet))
            {
                delete pFreeNode;
                pFreeNode = NULL;
                pCurrent = NULL;
                __leave;
            }
            DVR_ASSERT(::WaitForSingleObject(pFreeNode->hFileClosed, 0) == WAIT_OBJECT_0, "");
            DVR_ASSERT(::WaitForSingleObject(pFreeNode->hReadyToWriteTo, 0) == WAIT_TIMEOUT, "");

            InsertHeadList(&m_leFreeList, &pFreeNode->leListEntry);
            pCurrent = NEXT_LIST_NODE(&m_leFreeList);
            DVR_ASSERT(pCurrent == &pFreeNode->leListEntry, "");

#if defined(DVR_UNOFFICIAL_BUILD)
            pFreeNode->hDvrIoKey = m_hDvrIoKey;
#endif // if defined(DVR_UNOFFICIAL_BUILD)

        }
        DVR_ASSERT(pFreeNode->pRecorderNode == NULL, "");

        DVR_ASSERT(pCurrent != &m_leFreeList, "");

        // Create an ASF writer object if needed
        if (!pFreeNode->pWMWriter)
        {
            IWMWriter* pWMWriter;
            
            hrRet = ::WMCreateWriter(NULL, &pWMWriter);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "WMCreateWriter failed; hr = 0x%x", 
                                hrRet);
                __leave;
            }
            pFreeNode->pWMWriter = pWMWriter; // Released only in Close()
        }

        if (!pFreeNode->pWMWriterAdvanced)
        {
            IWMWriterAdvanced3*  pWMWriterAdvanced;

            hrRet = pFreeNode->pWMWriter->QueryInterface(IID_IWMWriterAdvanced3, (LPVOID*) &pWMWriterAdvanced);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "pFreeNode->pWMWriter->QueryInterface for IID_IWMWriterAdvanced failed; hr = 0x%x", 
                                hrRet);
                __leave;
            }
            pFreeNode->pWMWriterAdvanced = pWMWriterAdvanced; // Released only in Close()

            // Enough to do this once even if the writer object is reused
            // (at least as currently implemented in the SDK). There is no
            // way to undo this.
            //
            // Ignore errors (currently does not fail)
            pFreeNode->pWMWriterAdvanced->SetNonBlocking();
        }

        // Create and initialize the DVR file sink

        DVR_ASSERT(pFreeNode->pDVRFileSink == NULL, "");

        hrRet = DVRCreateDVRFileSink(m_hRegistryRootKey, m_hDvrIoKey, &pFreeNode->pDVRFileSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "DVRCreateDVRFileSink failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }

        DWORD dwDeleteTemporaryFiles = ::GetRegDWORD(m_hDvrIoKey,
                                                     kwszRegDeleteRingBufferFilesValue, 
                                                     kdwRegDeleteRingBufferFilesDefault);

        if (!pRecorderNode && dwDeleteTemporaryFiles == 0)
        {
            DWORD dwLastError;
            DWORD dwAttr = ::GetFileAttributesW(pwszFileName);

            if (dwAttr == (DWORD) -1)
            {
                dwLastError = ::GetLastError();

                if (dwLastError == ERROR_FILE_NOT_FOUND)
                {
                    // Go on; the file will be created
                }
                else
                {
                    DVR_ASSERT(0, "GetFileAttributes failed; temp file will be deleted when it is closed");

                    // Change dwDeleteTemporaryFiles back to 1 and go on.
                    // If it is not changed to 1, opening the file will fail

                    dwDeleteTemporaryFiles = 1;
                }
            }
            else
            {
                dwAttr &= ~(FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);

                DWORD dwRet = ::SetFileAttributesW(pwszFileName, dwAttr);
                if (dwRet == 0)
                {
                    dwLastError = ::GetLastError(); // for debugging only

                    DVR_ASSERT(0, "SetFileAttributes failed; temp file will be deleted when it is closed");

                    // Change dwDeleteTemporaryFiles back to 1 and go on.
                    // If it is not changed to 1, opening the file will fail

                    dwDeleteTemporaryFiles = 1;
                }

            }
        }

        hrRet = pFreeNode->pDVRFileSink->MarkFileTemporary(pRecorderNode || !dwDeleteTemporaryFiles? 0 : 1);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pFreeNode->pDVRFileSink->MarkFileTemporary failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }

        if (m_dwIndexStreamId != MAXDWORD)
        {
            hrRet = pFreeNode->pDVRFileSink->SetIndexStreamId(m_dwIndexStreamId);
            if (FAILED(hrRet))
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "pFreeNode->pDVRFileSink->SetIndexStreamId failed; hr = 0x%x", 
                                hrRet);
                __leave;
            }
        }

        // Add the DVR file sink to the WM writer

        hrRet = pFreeNode->pDVRFileSink->QueryInterface(IID_IWMWriterSink, (LPVOID*) &pWMWriterSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pFreeNode->pDVRFileSink->QueryInterface for IID_IWMWriterSink failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }

        DVR_ASSERT(pFreeNode->pWMWriterAdvanced, "");

        hrRet = pFreeNode->pWMWriterAdvanced->AddSink(pWMWriterSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pFreeNode->pWMWriterAdvanced->AddSink failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }
        bRemoveSink = 1;

        // Set the profile on the writer. This destroys the 
        // existing ASF mux and creates a new one.
        //
        // On failure, this action does not have to be undone.
        // Clean up will be done when SetProfile is next called
        // or when EndWriting is called.
        //
        // Sending NULL in the argument to undo this action 
        // immediately is rejected with an E_POINTER return
        hrRet = pFreeNode->pWMWriter->SetProfile(m_pProfile);

        if (FAILED(hrRet))
        {
            DVR_ASSERT(SUCCEEDED(hrRet), "SetProfile failed");
            __leave;
        }

        // Tell the writer that we are providing compressed streams.
        // It's enough to set the input props to NULL for this.
        DWORD dwNumInputs;

        hrRet = pFreeNode->pWMWriter->GetInputCount(&dwNumInputs);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(SUCCEEDED(hrRet), "GetInputCount failed");
            __leave;
        }

        for (; dwNumInputs > 0;)
        {
            dwNumInputs--;
            hrRet = pFreeNode->pWMWriter->SetInputProps(dwNumInputs, NULL);
            if (FAILED(hrRet))
            {
                DVR_ASSERT(SUCCEEDED(hrRet), "SetInputProps failed");
                __leave;
            }
        }

        DWORD dwSyncTolerance = ::GetRegDWORD(m_hRegistryRootKey,
                                              kwszRegSyncToleranceValue, 
                                              kdwRegSyncToleranceDefault);

        hrRet = pFreeNode->pWMWriterAdvanced->SetSyncTolerance(dwSyncTolerance);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pFreeNode->pWMWriterAdvanced->SetSyncTolerance failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }

        pFreeNode->cnsStartTime = cnsStartTime;
        pFreeNode->cnsEndTime = cnsEndTime;
        pFreeNode->pcnsFirstSampleTimeOffsetFromStartOfFile = pcnsFirstSampleTimeOffsetFromStartOfFile,
        pFreeNode->nFileId = nFileId;
        pFreeNode->nDupdHandles = ASF_WRITER_NODE::ASF_WRITER_NODE_HANDLES_NOT_DUPD;
        pFreeNode->hrRet = S_OK;

        DVR_ASSERT(pFreeNode->pwszFileName == NULL, "");

        if (pRecorderNode == NULL)
        {
            pFreeNode->pwszFileName = pwszFileName;
        }
        else
        {
            // pRecorderNode->pwszFileName is used
        }

        pFreeNode->SetRecorderNode(pRecorderNode);
        ::ResetEvent(pFreeNode->hFileClosed);
        bRestore = 1;

        // Issue the call to BeginWriting
        if (::QueueUserWorkItem(ProcessOpenRequest, pFreeNode, WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "QueueUserWorkItem failed; last error = 0x%x", 
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        // Note: If any step can fail after this, we have to be sure
        // to put this node back into the free list
        RemoveEntryList(pCurrent);
        NULL_NODE_POINTERS(pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            rpFreeNode = NULL;
            if (bRestore)
            {
                pFreeNode->cnsStartTime = 0;
                pFreeNode->cnsEndTime = 0;
                pFreeNode->pcnsFirstSampleTimeOffsetFromStartOfFile = NULL,
                pFreeNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
                pFreeNode->SetRecorderNode(NULL);
                delete [] pFreeNode->pwszFileName;
                pFreeNode->pwszFileName = NULL;
                ::SetEvent(pFreeNode->hFileClosed);
            }

            if (bRemoveSink)
            {
                HRESULT hr;

                DVR_ASSERT(pFreeNode->pWMWriterAdvanced, "");
                DVR_ASSERT(pWMWriterSink, "");
                hr = pFreeNode->pWMWriterAdvanced->RemoveSink(pWMWriterSink);
                DVR_ASSERT(SUCCEEDED(hr), "pFreeNode->pWMWriterAdvanced->RemoveSink failed");
            }
            if (pFreeNode->pDVRFileSink)
            {
                pFreeNode->pDVRFileSink->Release();
                pFreeNode->pDVRFileSink = NULL;
            }

            // SetProfile cannot be undone; see comment above.
        }
        else
        {
            rpFreeNode = pCurrent;
        }
        if (pWMWriterSink)
        {
            pWMWriterSink->Release();
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::PrepareAFreeWriterNode


HRESULT CDVRRingBufferWriter::AddToWritersList(IN LIST_ENTRY*   pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::AddToWritersList"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    __try
    {
        // Insert into m_leWritersList

        BOOL                bFound = 0;
        LIST_ENTRY*         pTmp = &m_leWritersList;
        PASF_WRITER_NODE    pWriterNode;
        QWORD               cnsStartTime;
        QWORD               cnsEndTime;

        pWriterNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

        cnsStartTime = pWriterNode->cnsStartTime;
        cnsEndTime = pWriterNode->cnsEndTime;

        while (NEXT_LIST_NODE(pTmp) != &m_leWritersList)
        {
            pTmp = NEXT_LIST_NODE(pTmp);
            pWriterNode = CONTAINING_RECORD(pTmp, ASF_WRITER_NODE, leListEntry);
            if (cnsEndTime <= pWriterNode->cnsStartTime)
            {
                // All ok; we should insert before pTmp
                bFound = 1;
                break;
            }
            if (cnsStartTime >= pWriterNode->cnsEndTime)
            {
                // Keep going on
                continue;
            }
            // Trouble
            DVR_ASSERT(cnsStartTime < pWriterNode->cnsEndTime && cnsEndTime > pWriterNode->cnsStartTime,
                       "Overlapped insert assertion failure?!");
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Overlapped insert! Input params: start time: %I64u, end time: %I64u\n"
                            "overlap node values: start time: %I64u, end time: %I64u",
                            cnsStartTime, cnsEndTime, pWriterNode->cnsStartTime, pWriterNode->cnsEndTime);
            hrRet = E_FAIL;
            __leave;
        }

        if (!bFound)
        {
            // We insert at tail
            pTmp = NEXT_LIST_NODE(pTmp);;
            DVR_ASSERT(pTmp == &m_leWritersList, "");
        }
        InsertTailList(pTmp, pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up necessary
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::AddToWritersList

HRESULT CDVRRingBufferWriter::AddATemporaryFile(IN QWORD   cnsStartTime,
                                                IN QWORD   cnsEndTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::AddATemporaryFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    BOOL                bRemoveRingBufferFile = 0;
    BOOL                bCloseFile = 0;
    LIST_ENTRY*         pCurrent;  
    CDVRFileCollection::DVRIOP_FILE_ID nFileId;
    BOOL                bAdded = 0;
    QWORD*              pcnsFirstSampleTimeOffsetFromStartOfFile = NULL;

    __try
    {
        HRESULT hr;
        
        // Call the ring buffer to add a file
        LPWSTR  pwszFile = NULL;

        if (!IsFlagSet(FirstTempFileCreated))
        {
            DWORD       dwSize = 0;

            hr = GetRegString(m_hDvrIoKey, kwszRegTempRingBufferFileNameValue, NULL, &dwSize);

            SetFlags(FirstTempFileCreated);

            if (SUCCEEDED(hr) && dwSize > sizeof(WCHAR))
            {
                // + 1 just in case dwSize is not a multiple of sizeof(WCHAR)
                pwszFile = new WCHAR[dwSize/sizeof(WCHAR) + 1];

                if (!pwszFile)
                {
                    hrRet = E_OUTOFMEMORY;
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", dwSize/sizeof(WCHAR)+1);
                    __leave;
                }

                hr = GetRegString(m_hDvrIoKey, kwszRegTempRingBufferFileNameValue, pwszFile, &dwSize);
                if (FAILED(hr))
                {
                    DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "GetRegString failed to get value of kwszTempRingBufferFileNameValue (second call).");
                    // Ignore the registry key
                    delete [] pwszFile;
                    pwszFile = NULL;
                }
            }
        }
        
        DVR_ASSERT(m_pDVRFileCollection, "");

        hr = m_pDVRFileCollection->AddFile(&pwszFile, 
                                           cnsStartTime, 
                                           cnsEndTime, 
                                           FALSE,                // bPermanentFile, 
                                           &pcnsFirstSampleTimeOffsetFromStartOfFile,
                                           &nFileId);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(hr != S_FALSE, "Temp file added is not in ring buffer extent?!");
        DVR_ASSERT(pcnsFirstSampleTimeOffsetFromStartOfFile != NULL, "");
        DVR_ASSERT(nFileId != CDVRFileCollection::DVRIOP_INVALID_FILE_ID, "");

        bRemoveRingBufferFile = 1;

        hr = PrepareAFreeWriterNode(pwszFile, cnsStartTime, cnsEndTime, pcnsFirstSampleTimeOffsetFromStartOfFile, nFileId, NULL, pCurrent);
            
        // We don't need this any more. AddFile allocated it. It has been saved away in pCurrent
        // which will delete it. If PrepareAFreeWriterNode() failed, this may already have been 
        // deleted.
        pwszFile = NULL;

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(pCurrent != NULL, "");

        // If any step after this fails, we have to call CloseWriterFile
        bCloseFile = 1;

        // Insert into m_leWritersList

        hr = AddToWritersList(pCurrent);        

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        
        bAdded = 1;
		hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            if (bAdded)
            {
                RemoveEntryList(pCurrent);
                NULL_NODE_POINTERS(pCurrent);
            }
            if (bCloseFile)
            {
                HRESULT hr;
                
                hr = CloseWriterFile(pCurrent);

                if (FAILED(hr))
                {
                    // Ignore the error and go on. Node has been
                    // deleted.
                }
            }

            if (bRemoveRingBufferFile)
            {
                // Set the end time to the start time to invalidate the file 
                // in the file collection
                CDVRFileCollection::DVRIOP_FILE_TIME ft = {nFileId, cnsStartTime, cnsStartTime}; 
                HRESULT hr;

                DVR_ASSERT(pcnsFirstSampleTimeOffsetFromStartOfFile && *pcnsFirstSampleTimeOffsetFromStartOfFile == MAXQWORD, "");

                hr = m_pDVRFileCollection->SetFileTimes(1, &ft);

                // A returned value of S_FALSE is ok. If this fails, 
                // just ignore the error
                DVR_ASSERT(SUCCEEDED(hr), "");
            }
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::AddATemporaryFile

// static
DWORD WINAPI CDVRRingBufferWriter::ProcessCloseRequest(LPVOID p)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::ProcessCloseRequest"

    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR ""
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE
    #endif

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    // We don't need to hold any locks in this function. We are guaranteed that
    // pNode won't be deleted till Close() is called and Close() waits for 
    // hFileClosed to be set.

    PASF_WRITER_NODE pWriterNode = (PASF_WRITER_NODE) p;

    DVR_ASSERT(pWriterNode, "");
    DVR_ASSERT(pWriterNode->pWMWriter, "");
    DVR_ASSERT(pWriterNode->hReadyToWriteTo, "");
    DVR_ASSERT(::WaitForSingleObject(pWriterNode->hFileClosed, 0) == WAIT_TIMEOUT, "");

    if (FAILED(pWriterNode->hrRet))
    {
        // BeginWriting failed, don't close the file
        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                        "BeginWriting() failed on file id %u, hr = 0x%x; not closing it, "
                        "but moving it to free list",
                        pWriterNode->nFileId, pWriterNode->hrRet);
        hrRet = pWriterNode->hrRet;
    }
    else
    {
        hrRet = pWriterNode->hrRet = pWriterNode->pWMWriter->EndWriting();
        if (FAILED(hrRet))
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "EndWriting failed; hr = 0x%x for file id %u", 
                            hrRet, pWriterNode->nFileId);
        }

        DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE, 
                        "EndWriting hr = 0x%x for file %u", 
                        hrRet, pWriterNode->nFileId);
    }

    // The sink's Open call does not have to be explicitly undone. Calling
    // EndWriting as well as the last call to the sink's Release close the 
    // sink.

    // Remove the DVR file sink and release it

    DVR_ASSERT(pWriterNode->pDVRFileSink, "");

    IWMWriterSink*      pWMWriterSink = NULL;

    __try
    {
        hrRet = pWriterNode->pDVRFileSink->QueryInterface(IID_IWMWriterSink, (LPVOID*) &pWMWriterSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pWriterNode->pDVRFileSink->QueryInterface for IID_IWMWriterSink failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }

        hrRet = pWriterNode->pWMWriterAdvanced->RemoveSink(pWMWriterSink);
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pWriterNode->pWMWriterAdvanced->RemoveSink failed; hr = 0x%x", 
                            hrRet);
            __leave;
        }

#if defined(DVR_UNOFFICIAL_BUILD)

        if (pWriterNode->hVal)
        {
            ::CloseHandle(pWriterNode->hVal);
            pWriterNode->hVal = NULL;
        }
        pWriterNode->cnsLastStreamTime = 0;

#endif // if defined(DVR_UNOFFICIAL_BUILD)


    }
    __finally
    {
        if (pWMWriterSink)
        {
            pWMWriterSink->Release();
        }

        // The next release should destroy the DVR file sink
        pWriterNode->pDVRFileSink->Release();
        pWriterNode->pDVRFileSink = NULL;

        if (FAILED(hrRet))
        {
            // Don't reuse the pWMWriter
            pWriterNode->pWMWriter->Release();
            pWriterNode->pWMWriter = NULL;
            pWriterNode->pWMWriterAdvanced->Release();
            pWriterNode->pWMWriterAdvanced = NULL;
        }
    }

    DVR_ASSERT(pWriterNode->pwszFileName == NULL, "");
    pWriterNode->cnsStartTime = 0;
    pWriterNode->cnsEndTime = 0;
    pWriterNode->pcnsFirstSampleTimeOffsetFromStartOfFile = NULL,
    pWriterNode->nFileId = CDVRFileCollection::DVRIOP_INVALID_FILE_ID;
    pWriterNode->nDupdHandles = ASF_WRITER_NODE::ASF_WRITER_NODE_HANDLES_NOT_DUPD;

    if (pWriterNode->pRecorderNode)
    {
        // This writer node is no longer associated with the recorder node.
        PASF_RECORDER_NODE pRecorderNode = pWriterNode->pRecorderNode;

        // Set the status on the asasociated recorder node; this could be the 
        // BeginWriting status if BeginWriting failed
        pRecorderNode->hrRet = hrRet;

        pRecorderNode->SetWriterNode(NULL);
        pWriterNode->SetRecorderNode(NULL);

        pRecorderNode->SetFlags(ASF_RECORDER_NODE::DeleteRecorderNode);
        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::RecorderNodeDeleted))
        {
            delete pRecorderNode;
        }
    }

    ::SetEvent(pWriterNode->hFileClosed);

    // It's unsafe to reference pWriterNode after this as we do not hold any locks

    DVRIO_TRACE_LEAVE1_HR(hrRet);

    return 1;
    
    #if defined(DEBUG)
    #undef DVRIO_DUMP_THIS_FORMAT_STR
    #define DVRIO_DUMP_THIS_FORMAT_STR "this=0x%p, this->id=%u, "
    #undef DVRIO_DUMP_THIS_VALUE
    #define DVRIO_DUMP_THIS_VALUE , this, this->m_dwClassInstanceId
    #endif

} // CDVRRingBufferWriter::ProcessCloseRequest

HRESULT CDVRRingBufferWriter::CloseWriterFile(LIST_ENTRY* pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CloseWriterFile"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_WRITER_NODE    pWriterNode;
    BOOL                bLeak = 0;   // Leak the writer node memory if we fail
    BOOL                bDelete = 0; // Delete the writer node if we fail
    BOOL                bWaitForClose = 0; // Wait for hFileClsoed before deleting

    pWriterNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

    __try
    {
        DWORD nRet;

        // We have to close the file; ensure the open has completed
        DVR_ASSERT(pWriterNode->hReadyToWriteTo, "");
        if (::WaitForSingleObject(pWriterNode->hReadyToWriteTo, INFINITE) == WAIT_FAILED)
        {
            DVR_ASSERT(0, "Writer node's WFSO(hReadyToWriteTo) failed");

            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x", 
                            pWriterNode->hReadyToWriteTo, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);

            // We don't know if the queued user work item has executed or not
            // Better to leak this memory than to potentially av.
            bLeak = 1;
           __leave; 
        }
        bDelete = 1;

        // Verify that hFileClosed is reset
        DVR_ASSERT(pWriterNode->hFileClosed, "");
        nRet = ::WaitForSingleObject(pWriterNode->hFileClosed, 0);
        if (nRet != WAIT_TIMEOUT)
        {
            DVR_ASSERT(nRet != WAIT_OBJECT_0, "Writer node's hFileClosed is set?");
            if (nRet == WAIT_OBJECT_0)
            {
                // hope for the best! Consider treating this an error @@@@
                ::ResetEvent(pWriterNode->hFileClosed);
            }
            else
            {
                DWORD dwLastError = ::GetLastError();
                DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "WFSO(hFileClosed) failed; hFileClosed = 0x%p, last error = 0x%x", 
                                pWriterNode->hFileClosed, dwLastError);
                hrRet = HRESULT_FROM_WIN32(dwLastError);
                __leave;
            }
        }

        if (pWriterNode->pRecorderNode)
        {
            PASF_RECORDER_NODE pRecorderNode = pWriterNode->pRecorderNode;
         
            // Recording completed and file is being closed. Pull node out
            // of m_leRecordersList. This must be done while holding 
            // m_csLock (and all call to this fn hold the lock)
            if (!LIST_NODE_POINTERS_NULL(&pRecorderNode->leListEntry))
            {
                RemoveEntryList(&pRecorderNode->leListEntry);
                NULL_NODE_POINTERS(&pRecorderNode->leListEntry);
            }
        }

        // Issue the call to EndWriting
        if (::QueueUserWorkItem(ProcessCloseRequest, pWriterNode, WT_EXECUTEDEFAULT) == 0)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "QueueUserWorkItem failed; last error = 0x%x", 
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }
        bWaitForClose = 1; // We wait only if subsequent operations fail

        // We could do this after the WFSO(hReadyToWriteTo) succeeds
        // We delay it because we may change this function to not
        // not delete the node on failure and retry this function.
        // So it's better to leave the event set until we are 
        // sure of success.
        ::ResetEvent(pWriterNode->hReadyToWriteTo);

        // Insert into m_leFreeList
        LIST_ENTRY*         pTmp = &m_leFreeList;
        PASF_WRITER_NODE    pFreeNode;

        while (PREVIOUS_LIST_NODE(pTmp) != &m_leFreeList)
        {
            pTmp = PREVIOUS_LIST_NODE(pTmp);
            pFreeNode = CONTAINING_RECORD(pTmp, ASF_WRITER_NODE, leListEntry);
            if (pFreeNode->pWMWriter != NULL)
            {
                InsertHeadList(pTmp, pCurrent);
                bDelete = 0;
                break;
            }
        }
        if (pTmp == &m_leFreeList)
        {
            // Not inserted into free list yet - all nodes in the 
            // free list have pWMWriter == NULL
            InsertHeadList(&m_leFreeList, pCurrent);
            bDelete = 0;
        }
        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // We either leak or delete the node on failure, but not both

            DVR_ASSERT(bLeak == 0 || bLeak == 1, "");
            DVR_ASSERT(bDelete == 0 || bDelete == 1, "");
            DVR_ASSERT(bLeak ^ bDelete, "");

            if (bWaitForClose)
            {
                // Currently won't happen since we have no failures 
                // after queueing the work item. However, this is to
                // protect us from code changes

                DWORD nRet;

                nRet = ::WaitForSingleObject(pWriterNode->hFileClosed, INFINITE);
                if (nRet == WAIT_FAILED)
                {
                    DVR_ASSERT(nRet == WAIT_OBJECT_0, "Writer node WFSO(hFileClosed) failed");

                    DWORD dwLastError = ::GetLastError();
                    DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "WFSO(hFileClosed) failed, deleting node anyway; hFileClosed = 0x%p, last error = 0x%x", 
                                    pWriterNode->hFileClosed, dwLastError);

                    // Ignore this error
                    // hrRet = HRESULT_FROM_WIN32(dwLastError);
                }
            }
            else
            {
                // If SUCCEEDED(hrRet) || bWaitForClose == 1, this has already
                // been done in ProcessCloseRequest
                if (pWriterNode->pRecorderNode)
                {
                    // This writer node is no longer associated with the recorder node.
                    PASF_RECORDER_NODE pRecorderNode = pWriterNode->pRecorderNode;

                    // Set the status on the asasociated recorder node; this will be the 
                    // BeginWriting status if BeginWriting failed
                    if (SUCCEEDED(pRecorderNode->hrRet))
                    {
                        // We haven't called EndWriting
                        pRecorderNode->hrRet = E_FAIL;
                    }
                    pRecorderNode->SetWriterNode(NULL);
                    pWriterNode->SetRecorderNode(NULL);
                    // Recording completed and file has been closed. Pull node out
                    // of m_leRecordersList
                    if (!LIST_NODE_POINTERS_NULL(&pRecorderNode->leListEntry))
                    {
                        RemoveEntryList(&pRecorderNode->leListEntry);
                        NULL_NODE_POINTERS(&pRecorderNode->leListEntry);
                    }
                    pRecorderNode->SetFlags(ASF_RECORDER_NODE::DeleteRecorderNode);
                    if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::RecorderNodeDeleted))
                    {
                        delete pRecorderNode;
                    }
                }
            }
            if (bDelete)
            {
                delete pWriterNode;
            }
        }
        else
        {
            DVR_ASSERT(bLeak == 0 && bDelete == 0, "");
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::CloseWriterFile


HRESULT CDVRRingBufferWriter::CloseAllWriterFilesBefore(QWORD cnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CloseAllWriterFilesBefore"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    PASF_WRITER_NODE    pWriterNode;
    LIST_ENTRY*         pCurrent = &m_leWritersList;  

    __try
    {
        HRESULT hr;

        while (NEXT_LIST_NODE(pCurrent) != &m_leWritersList)
        {
            pCurrent = NEXT_LIST_NODE(pCurrent);
            pWriterNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);
            if (pWriterNode->cnsEndTime > cnsStreamTime)
            {
                // All done
                hrRet = S_OK;
                break;
            }

            RemoveEntryList(pCurrent);
            NULL_NODE_POINTERS(pCurrent);

            hr = CloseWriterFile(pCurrent);
            if (FAILED(hr))
            {
                // We ignore this and go on, the node has been deleted
            }

            // Reset pCurrent to the start of the Writer list
            pCurrent = &m_leWritersList;
        }
        hrRet = S_OK; // even if there was a failure
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::CloseAllWriterFilesBefore


HRESULT CDVRRingBufferWriter::AddToRecordersList(IN LIST_ENTRY*   pCurrent)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::AddToRecordersList"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    __try
    {
        // Insert into m_leRecordersList

        BOOL                bFound = 0;
        LIST_ENTRY*         pTmp = &m_leRecordersList;
        PASF_RECORDER_NODE  pRecorderNode;
        QWORD               cnsStartTime;
        QWORD               cnsEndTime;

        pRecorderNode = CONTAINING_RECORD(pCurrent, ASF_RECORDER_NODE, leListEntry);

        cnsStartTime = pRecorderNode->cnsStartTime;
        cnsEndTime = pRecorderNode->cnsEndTime;

        while (NEXT_LIST_NODE(pTmp) != &m_leRecordersList)
        {
            pTmp = NEXT_LIST_NODE(pTmp);
            pRecorderNode = CONTAINING_RECORD(pTmp, ASF_RECORDER_NODE, leListEntry);
            if (cnsEndTime <= pRecorderNode->cnsStartTime)
            {
                // All ok; we should insert before pTmp
                bFound = 1;
                break;
            }
            if (cnsStartTime >= pRecorderNode->cnsEndTime)
            {
                // Keep going on
                continue;
            }
            // Trouble
            DVR_ASSERT(cnsStartTime < pRecorderNode->cnsEndTime && cnsEndTime > pRecorderNode->cnsStartTime,
                       "Overlapped insert assertion failure?!");
            DvrIopDebugOut4(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Overlapped insert! Input params: start time: %I64u, end time: %I64u\n"
                            "overlap node values: start time: %I64u, end time: %I64u",
                            cnsStartTime, cnsEndTime, pRecorderNode->cnsStartTime, pRecorderNode->cnsEndTime);
            hrRet = E_FAIL;
            __leave;
        }

        if (!bFound)
        {
            // We insert at tail
            pTmp = NEXT_LIST_NODE(pTmp);;
            DVR_ASSERT(pTmp == &m_leRecordersList, "");
        }
        InsertTailList(pTmp, pCurrent);

        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            // No clean up necessary
        }
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::AddToRecordersList

// ====== Public methods to support the recorder

HRESULT CDVRRingBufferWriter::StartRecording(IN LPVOID pRecorderId,
                                             IN QWORD cnsStartTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::StartRecording"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    if (cnsStartTime == MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                        "Start time of MAXQWORD is invalid.");
        hrRet = E_INVALIDARG;
        DVRIO_TRACE_LEAVE1_HR(hrRet);
        return hrRet;
    }

    LIST_ENTRY* pInsert = NULL;
    BOOL        bIrrecoverableError = 0;
    LIST_ENTRY  leCloseFilesList;

    InitializeListHead(&leCloseFilesList);

    ::EnterCriticalSection(&m_csLock);
    __try
    {
        if (IsFlagSet(WriterClosed))
        {
            // The recorders list will not be empty if a recording had been
            // created but had not been started before the writer was closed.
            // We should not allow the recording to be started now.
            hrRet = E_UNEXPECTED;
            __leave;
        }
        if (IsFlagSet(SampleWritten) && cnsStartTime <= *m_pcnsCurrentStreamTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Start time (%I64u) is <= current stream time (%I64u)", 
                            cnsStartTime, *m_pcnsCurrentStreamTime);
            hrRet = E_INVALIDARG;
            __leave;
        }
        if (!IsFlagSet(SampleWritten) && cnsStartTime < m_cnsFirstSampleTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Start time (%I64u) is < first sample time (%I64u)", 
                            cnsStartTime, m_cnsFirstSampleTime);
            hrRet = E_INVALIDARG;
            __leave;
        }
        
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }

        HRESULT     hr;
        LIST_ENTRY* pCurrent;  
        LIST_ENTRY* pStart = (LIST_ENTRY*) pRecorderId;

        // Remove the node from the recorder's list. 

        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            if (pCurrent == pStart)
            {
                RemoveEntryList(pCurrent);
                NULL_NODE_POINTERS(pCurrent);
                break;
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        if (pCurrent == &m_leFreeList)
        {
            // Didn't find the node

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Did not find recorder node id 0x%x in the recorders list", 
                            pStart);
            hrRet = E_FAIL;
            __leave;
        }

        pInsert = pStart;

        PASF_RECORDER_NODE  pRecorderNode;
        PASF_WRITER_NODE    pWriterNode;

        pRecorderNode = CONTAINING_RECORD(pStart, ASF_RECORDER_NODE, leListEntry);
        pWriterNode = pRecorderNode->pWriterNode;

        if (pRecorderNode->cnsStartTime != MAXQWORD)
        {
            // Recording already started?!
            DVR_ASSERT(pRecorderNode->cnsStartTime == MAXQWORD, "Recording already started");
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Recording already started on the recorder node id=0x%x at time %I64u", 
                            pStart, pRecorderNode->cnsStartTime);
            hrRet = E_FAIL;
            __leave;
        }
        if (pRecorderNode->cnsEndTime != MAXQWORD)
        {
            // Recording already stopped without having been started?!
            DVR_ASSERT(pRecorderNode->cnsEndTime == MAXQWORD, 
                       "Recording already stopped, but wasn't started?!");
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Recording already stopped on the recorder node id=0x%x at time %I64u, start time is MAXQWORD", 
                            pStart, pRecorderNode->cnsEndTime);
            hrRet = E_FAIL;
            __leave;
        }
        if (!pWriterNode)
        {
            DVR_ASSERT(pRecorderNode->pWriterNode, "");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pWriterNode of the recorder node id=0x%x is NULL", 
                            pStart);
            hrRet = E_FAIL;
            __leave;
        }

        // Verify that cnsStartTime follows the start time of all 
        // other recordings.
        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            PASF_RECORDER_NODE pTmpNode;
            
            pTmpNode = CONTAINING_RECORD(pCurrent, ASF_RECORDER_NODE, leListEntry);
            if (pTmpNode->cnsStartTime != MAXQWORD)
            {
                // If pTmpNode->cnsEndTime == MAXQWORD, StopRecording
                // has not been called on pTmpNode; we cannot allow
                // StartRecording to be called on this node.
                if (pTmpNode->cnsEndTime > cnsStartTime)
                {
                    DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                    "Recorder node id=0x%x end time (%I64u) >= cnsStartTime (%I64u)", 
                                    pCurrent, pTmpNode->cnsEndTime, cnsStartTime);
                    hrRet = E_INVALIDARG;
                    __leave;
                }
                // All ok
                break;
            }
            else
            {
                DVR_ASSERT(pTmpNode->cnsEndTime == MAXQWORD, "");
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        // Determine where in the writer's list to add this node and
        // whether to change the file times of other writer nodes

        DWORD dwNumNodesToUpdate = 0;
        pCurrent = NEXT_LIST_NODE(&m_leWritersList);
        while (pCurrent != &m_leWritersList)
        {
            PASF_WRITER_NODE pTmpNode;
            
            pTmpNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

            if (pTmpNode->cnsStartTime == MAXQWORD)
            {
                break;
            }
            if (// Redundant: pTmpNode->cnsStartTime >= cnsStartTime ||
                pTmpNode->cnsEndTime > cnsStartTime)
            {
                // We have verified that the end times of all recorders is
                // < cnsStartTime. So this is a temporary node
                DVR_ASSERT(pTmpNode->pRecorderNode == NULL,
                           "Node must be a temporary node");

                dwNumNodesToUpdate++;
            }
            else if (pTmpNode->cnsEndTime == cnsStartTime)
            {
                // Nothing to do. Note that start time of this 
                // node may be equal to the end time because
                // we made a previous call to SetFileTimes and
                // did not close the writer node (this should
                // not happen the way the code is currently structured).
                // This is ok, when calling SetFileTimes, we skip
                // over such nodes
                DVR_ASSERT(pTmpNode->cnsStartTime < cnsStartTime,
                           "Node should have been removed from the writers list.");
            }
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }

        if (dwNumNodesToUpdate > 0)
        {
            CDVRFileCollection::PDVRIOP_FILE_TIME   pFileTimes;
            
            pFileTimes = (CDVRFileCollection::PDVRIOP_FILE_TIME) _alloca(dwNumNodesToUpdate*sizeof(CDVRFileCollection::DVRIOP_FILE_TIME));
            if (pFileTimes == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "alloca failed - %u bytes", 
                                dwNumNodesToUpdate*sizeof(CDVRFileCollection::DVRIOP_FILE_TIME));

                hrRet = E_OUTOFMEMORY; // out of stack space
                __leave;
            }

            DWORD i = 0;
            LIST_ENTRY* pRemove = NULL;

            pCurrent = NEXT_LIST_NODE(&m_leWritersList);
            while (pCurrent != &m_leWritersList)
            {
                PASF_WRITER_NODE pTmpNode;
            
                pTmpNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);

                if (pTmpNode->cnsStartTime == MAXQWORD)
                {
                    break;
                }
                if (// Redundant: pTmpNode->cnsStartTime >= cnsStartTime ||
                    pTmpNode->cnsEndTime > cnsStartTime)
                {
                    // We have asserted in the previous loop that 
                    // these nodes are all temporary nodes

                    pFileTimes[i].nFileId = pTmpNode->nFileId;
                    if (pTmpNode->cnsStartTime < cnsStartTime)
                    {
                        // New start time is the same as the old one
                        // End time changed to recorder's start time
                        pFileTimes[i].cnsStartTime = pTmpNode->cnsStartTime;
                        pTmpNode->cnsEndTime = pFileTimes[i].cnsEndTime  = cnsStartTime;
                    }
                    else if (pTmpNode->cnsStartTime == cnsStartTime)
                    {
                        // we are going to tell the file collection object
                        // to delete this temporary node by setting its 
                        // start time = end time
                        pTmpNode->cnsStartTime = pFileTimes[i].cnsStartTime = cnsStartTime;
                        pTmpNode->cnsEndTime = pFileTimes[i].cnsEndTime  = cnsStartTime;
                        DVR_ASSERT(pRemove == NULL, 
                                   "a) There are 2 nodes in the writers list with the same start time AND with end time > start time OR b) the writers list is not sorted by start,end time");
                        pRemove = pCurrent;
                    }
                    else
                    {
                        // we are going to tell the file collection object
                        // to delete this temporary node by setting its 
                        // start time = end time. Note that the recording
                        // file is going to have a stop time of MAXQWORD

                        // NOTE: Because of this there CAN NEVER BE temporary 
                        // nodes following a permanent node in m_leWritersList
                        // and in the file collection object UNLESS the 
                        // recording node is being written to.

                        if (!pRemove)
                        {
                            pRemove = pCurrent;
                        }
                        pFileTimes[i].cnsStartTime = pTmpNode->cnsStartTime;
                        pTmpNode->cnsEndTime = pFileTimes[i].cnsEndTime  = pTmpNode->cnsStartTime;
                    }
                    i++;
                }
                else if (pTmpNode->cnsEndTime == cnsStartTime)
                {
                    // Nothing to do. Note that start time of this 
                    // node may be equal to the end time because
                    // we made a previous call to SetFileTimes and
                    // did not close the writer node (this should
                    // not happen the way the code is currently structured).
                    // This is ok, when calling SetFileTimes, we skip
                    // over such nodes
                }
                pCurrent = NEXT_LIST_NODE(pCurrent);
            }
            DVR_ASSERT(i == dwNumNodesToUpdate, "");

            // We can be smart and restore state of the writers list
            // (restore the start, end times on writer nodes, insert pRemove)
            // but this is not worth it. We should not have any errors
            // after this - any error ought to be a bug and should be
            // fixed.
            bIrrecoverableError = 1;

            if (pRemove)
            {
                // Remove all nodes after this one in m_leWritersList
                // (including pRemove)
                // Note that all these nodes are temporary files; this has been
                // asserted in the while loop above.

                BOOL bStop = 0;
                
                pCurrent = PREVIOUS_LIST_NODE(&m_leWritersList);
                while (!bStop)
                {
                    bStop = (pCurrent == pRemove);

#if defined(DEBUG)
                    PASF_WRITER_NODE pTmpNode;
            
                    pTmpNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);
                    
                    DVR_ASSERT(pTmpNode->pRecorderNode == NULL, "Node should be a temp one.");
#endif
                    
                    RemoveEntryList(pCurrent);

                    // As explained in StopRecording and SetFirstSampleTime, we close these files
                    // after setting the file times on the file collection object and priming a
                    // writer file. This delays sending the EOF notification to the reader until the
                    // file collection object has been cleaned up. Note that, as in StopRecording,
                    // we need to do this only if
                    // !IsFlagSet(SampleWritten) && cnsStartTime == *m_pcnsCurrentStreamTime. 
                    // However, we just do it always. An alternative to delaying the closing of these
                    // files is to grab the file collection lock and unlock it only after we have
                    // completed updating the file collection - we use that approach in SetFirstSampleTime.
                    //
                    // WAS:
                    // NULL_NODE_POINTERS(pCurrent);
                    // Ignore failed return status - the writer node has been deleted.
                    // hr = CloseWriterFile(pCurrent);
                    InsertHeadList(&leCloseFilesList, pCurrent);
                    
                    pCurrent = PREVIOUS_LIST_NODE(&m_leWritersList);
                }
            }
            hr = m_pDVRFileCollection->SetFileTimes(dwNumNodesToUpdate, pFileTimes);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else
            {
                // S_FALSE is ok; the list could have got empty if cnsStartTime = 0
                // and we have not yet written a sample
            }
        }

        // Add the file to the file collection object
        DVR_ASSERT(m_pDVRFileCollection, "");

        hr = m_pDVRFileCollection->AddFile((LPWSTR*) &pRecorderNode->pwszFileName, 
                                           cnsStartTime, 
                                           pRecorderNode->cnsEndTime, 
                                           TRUE,                // bPermanentFile, 
                                           &pWriterNode->pcnsFirstSampleTimeOffsetFromStartOfFile,
                                           &pWriterNode->nFileId);
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        // Add the writer node to the writer's list
        bIrrecoverableError = 1;
        pRecorderNode->cnsStartTime = pWriterNode->cnsStartTime = cnsStartTime;
        pRecorderNode->cnsEndTime = pWriterNode->cnsEndTime = MAXQWORD;
        hr = AddToWritersList(&pWriterNode->leListEntry);
        if (FAILED(hr))
        {
            // ??!! This should never happen
            DVR_ASSERT(0, "Insertion of recorder into writers list failed");
            hrRet = hr;
            __leave;
        }

        pInsert = NULL;

        // Re-insert the recorder node in the recorder's list
        hr = AddToRecordersList(pStart);
        if (FAILED(hr))
        {
            // ??!! This should never happen
            DVR_ASSERT(0, "Insertion of recorder into writers list failed");
            hrRet = hr;
            __leave;
        }

        // We let DeleteRecorder delete the node right away if we exit
        // with failure. This is not an issue - if bIrrecoverableError 
        // is non-zero, we disallow operations such as WriteSample, 
        // StartRecording and StopRecording. If bIrrecoverableError is 0,
        // pRecorderNode->cnsStartTime  is still MAXQWORD and the
        // client will either have to call StartRecording on this node
        // once again or delete it.

        pRecorderNode->ClearFlags(ASF_RECORDER_NODE::DeleteRecorderNode);
        hrRet = S_OK;
    }
    __finally
    {
        HRESULT hr;
        
        if (pInsert)
        {
            // Ignore the returned status; AddToRecordersList 
            // has already logged  the error
            hr = AddToRecordersList(pInsert);
        }

        LIST_ENTRY* pCurrent;  
        
        pCurrent = PREVIOUS_LIST_NODE(&leCloseFilesList);
        while (pCurrent != &leCloseFilesList)
        {
            RemoveEntryList(pCurrent);

            NULL_NODE_POINTERS(pCurrent);
            
            // Ignore failed return status - the writer node has been deleted.
            hr = CloseWriterFile(pCurrent);
            
            pCurrent = PREVIOUS_LIST_NODE(&leCloseFilesList);
        }

        if (FAILED(hrRet) && bIrrecoverableError)
        {
            m_nNotOkToWrite = MINLONG;
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::StartRecording


HRESULT CDVRRingBufferWriter::StopRecording(IN LPVOID pRecorderId,
                                            IN QWORD cnsStopTime,
                                            IN BOOL bNow)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::StopRecording"

    DVRIO_TRACE_ENTER();

    HRESULT     hrRet;

    if (cnsStopTime == MAXQWORD)
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                        "Stop time of MAXQWORD is invalid.");
        hrRet = E_INVALIDARG;
        DVRIO_TRACE_LEAVE1_HR(hrRet);
        return hrRet;
    }

    BOOL        bIrrecoverableError = 0;
    LIST_ENTRY* pWriterNodeToBeClosed = NULL;


    ::EnterCriticalSection(&m_csLock);
    __try
    {
        if (IsFlagSet(WriterClosed))
        {
            // The recorders list will not be empty if a recording had been
            // created but had not been started before the writer was closed.
            // We should not allow the recording to be started now.

            // This operation will fail below anyway because we'll discover
            // that the recording had not been started. However, we have 
            // already released the file collection and cannot access
            // *m_pcnsCurrentStreamTime (if bNow is non-zero).

            hrRet = E_UNEXPECTED;
            __leave;
        }
        if (bNow)
        {
            cnsStopTime = *m_pcnsCurrentStreamTime+1;
        }
    
        if (IsFlagSet(SampleWritten) && cnsStopTime <= *m_pcnsCurrentStreamTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Stop time (%I64u) is <= current stream time (%I64u); WriteSample has been called", 
                            cnsStopTime, *m_pcnsCurrentStreamTime);
            hrRet = E_INVALIDARG;
            __leave;
        }

        // Note: Even if the first sample has not been written, the first recording's
        // start time can not be < *m_pcnsCurrentStreamTime; StartRecording and
        // SetFirstSampleTime enforce that. Setting cnsStopTime == *m_pcnsCurrentStreamTime
        // allows client to cancel the recording.
        if (!IsFlagSet(SampleWritten) && cnsStopTime < *m_pcnsCurrentStreamTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Stop time (%I64u) is < current stream time (%I64u); WriteSample has NOT been called", 
                            cnsStopTime, *m_pcnsCurrentStreamTime);
            hrRet = E_INVALIDARG;
            __leave;
        }
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }

        HRESULT     hr;
        LIST_ENTRY* pCurrent;  
        LIST_ENTRY* pStop = (LIST_ENTRY*) pRecorderId;

        // Verify the node is in the recorder's list. 

        pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            if (pCurrent == pStop)
            {
                // Since cnsEndTime is MAXQWORD on this recorder
                // node, it's position in m_leRecordersList will not 
                // change, i.e., setting the stop time will leave the
                // list sorted.
                // RemoveEntryList(pCurrent);
                break;
            }
            pCurrent = PREVIOUS_LIST_NODE(pCurrent);
        }

        if (pCurrent == &m_leFreeList)
        {
            // Didn't find the node

            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Did not find recorder node id 0x%x in the recorders list", 
                            pStop);
            hrRet = E_FAIL;
            __leave;
        }

        PASF_RECORDER_NODE  pRecorderNode;

        pRecorderNode = CONTAINING_RECORD(pStop, ASF_RECORDER_NODE, leListEntry);

        if (pRecorderNode->cnsEndTime != MAXQWORD &&
            pRecorderNode->cnsStartTime != cnsStopTime // Recording is not being cancelled
           )
        {
            // Recording already stopped and caller is not cancelling the recording
            DVR_ASSERT(pRecorderNode->cnsEndTime == MAXQWORD, "Recording already stopped");
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Recording already stopped on the recorder node id=0x%x at time %I64u", 
                            pStop, pRecorderNode->cnsEndTime);
            hrRet = E_FAIL;
            __leave;
        }
        if (pRecorderNode->cnsStartTime == MAXQWORD)
        {
            // Recording not started
            DVR_ASSERT(pRecorderNode->cnsStartTime != MAXQWORD, 
                       "Recording not yet started?!");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Recording not started on the recorder node id=0x%x, start time is MAXQWORD", 
                            pStop);
            hrRet = E_FAIL;
            __leave;
        }
        if (cnsStopTime < pRecorderNode->cnsStartTime)
        {
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Recorder node id=0x%x, start time (%I64u) > stopTime (%I64u)", 
                            pStop, pRecorderNode->cnsStartTime, cnsStopTime);
            hrRet = E_INVALIDARG;
            __leave;
        }
        if (pRecorderNode->cnsStartTime == cnsStopTime &&
            IsFlagSet(SampleWritten) &&
            *m_pcnsCurrentStreamTime >= pRecorderNode->cnsStartTime)
        {
            DvrIopDebugOut3(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Recorder node id=0x%x, start time (%I64u) < current stream time (%I64u)", 
                            pStop, pRecorderNode->cnsStartTime, *m_pcnsCurrentStreamTime);
            hrRet = E_INVALIDARG;
            __leave;
        }


        PASF_WRITER_NODE    pWriterNode;
        pWriterNode = pRecorderNode->pWriterNode;
        if (!pWriterNode)
        {
            DVR_ASSERT(pRecorderNode->pWriterNode, "");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pWriterNode of the recorder node id=0x%x is NULL", 
                            pStop);
            hrRet = E_FAIL;
            __leave;
        }

        DVR_ASSERT(pRecorderNode->cnsStartTime == pWriterNode->cnsStartTime, "");

        // Set the times

        // Note that we set the time on the recorder node so the client cannot
        // stop recording again or cancel it if this function fails after this.
        // We also set bIrrecoverableError, so StartRecording, StopRecording
        // and WriteSample will fail anyway.
        pRecorderNode->cnsEndTime = pWriterNode->cnsEndTime = cnsStopTime;
        bIrrecoverableError = 1;

        if (cnsStopTime > pRecorderNode->cnsStartTime)
        {
            // Stop time is being set

            // There are 2 cases to consider here. 
            // (a) We have started writing to the recorder file. In this case,
            //     the previous file's time (in m_leWritersList) cannot be changed
            //     and there can be a temporary node after this one
            // (b) We have not written to the recorder file yet. In this case,
            //     there CANNOT be a temp node after this one (or a permanent
            //     one for that matter since we are setting the stop time).
            //     A note in StartRecording explains why there cannot be a temp
            //     file after this node.
            // In either case, we have to adjust the times of at most 2 files, the
            // previous file in the writers list is not affected by setting the
            // stop recording time (since the recording is not being cancelled).

            DWORD               dwNumNodesToUpdate = 0;
            CDVRFileCollection::DVRIOP_FILE_TIME    ft[2];
            LIST_ENTRY*         pWriter = &(pWriterNode->leListEntry);
            LIST_ENTRY*         pNext = NEXT_LIST_NODE(pWriter);
            PASF_WRITER_NODE    pNextWriter = (pNext == &m_leWritersList)? NULL : CONTAINING_RECORD(pNext, ASF_WRITER_NODE, leListEntry);

            // Both cases
            ft[dwNumNodesToUpdate].nFileId = pWriterNode->nFileId;
            ft[dwNumNodesToUpdate].cnsStartTime = pRecorderNode->cnsStartTime;
            ft[dwNumNodesToUpdate].cnsEndTime = cnsStopTime;
            dwNumNodesToUpdate++;

            if (IsFlagSet(SampleWritten) && 
                pRecorderNode->cnsStartTime <= *m_pcnsCurrentStreamTime)
            {
                // Case a
                if (!pNextWriter)
                {
                    // Next temp node has not been primed yet. Leave it as is
                }
                else
                {
                    // Assert it is a temporary node
                    DVR_ASSERT(pNextWriter->pRecorderNode == NULL, 
                               "Setting end time on recorder node, next node in writers list is a recorder node?!");
                    DVR_ASSERT(pNextWriter->cnsStartTime == MAXQWORD, "");
                    DVR_ASSERT(pNextWriter->cnsEndTime == MAXQWORD, "");
                    ft[dwNumNodesToUpdate].nFileId = pNextWriter->nFileId;
                    ft[dwNumNodesToUpdate].cnsStartTime = pNextWriter->cnsStartTime = cnsStopTime;
                    ::SafeAdd(ft[dwNumNodesToUpdate].cnsEndTime, cnsStopTime, m_cnsTimeExtentOfEachFile);
                    pNextWriter->cnsEndTime = ft[dwNumNodesToUpdate].cnsEndTime;
                    dwNumNodesToUpdate++;

                    DVR_ASSERT(NEXT_LIST_NODE(pNext) == &m_leWritersList,
                               "More than 1 node following recorder node in writer list - we are setting its stop time?!");
                }
            }
            else
            {
                // Case b
                DVR_ASSERT(pNextWriter == NULL, 
                           "Not written to this recorder node and it has a node following it in m_leWritersList"); 
            }

            hr = m_pDVRFileCollection->SetFileTimes(dwNumNodesToUpdate, &ft[0]);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else if (hr != S_OK)
            {
                // S_FALSE is NOT ok; we have a recorder node in the list, file collection
                // cannot have got empty.
                // We have at least one node in the list.
                DVR_ASSERT(hr == S_OK, "hr = S_FALSE unexpected");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "SetFileTimes returns hr = 0x%x - unexpected.",
                                hr); 
                hrRet = E_FAIL;
                __leave;
            }
        }
        else
        {
            // cnsStopTime == pRecorderNode->cnsStartTime, i.e., recording
            // is being cancelled. Stop time may or may not have been set earlier.

            // Note: There are no temporary nodes following this recording node.
            // See the note in start recording which explains why this is so -
            // note that no samples have been written to the recorder file as yet
            // (which is why we allow cancelling the recording). However if the
            // node before this is a temporary one, we may have to adjust its 
            // end time.
            
            // We have to remove the node from the writers list, close the
            // writers file and remove the file from the file collection.
            // Then we have to determine whether to prime a new node (a
            // temporary file) to replace the one we removed.

            LIST_ENTRY*         pWriter = &(pWriterNode->leListEntry);
            LIST_ENTRY*         pPrev = PREVIOUS_LIST_NODE(pWriter);
            LIST_ENTRY*         pNext = NEXT_LIST_NODE(pWriter);
            PASF_WRITER_NODE    pPrevWriter = (pPrev == &m_leWritersList)? NULL : CONTAINING_RECORD(pPrev, ASF_WRITER_NODE, leListEntry);
            PASF_WRITER_NODE    pNextWriter = (pNext == &m_leWritersList)? NULL : CONTAINING_RECORD(pNext, ASF_WRITER_NODE, leListEntry);
            CDVRFileCollection::DVRIOP_FILE_TIME    ft[2];
            DWORD               dwNumNodesToUpdate = 0;
            
            if (pNextWriter)
            {
                DVR_ASSERT(pNextWriter->pRecorderNode == NULL,
                           "Node following recorder in writers list is a temp node.");
            }
            if (pPrevWriter && pPrevWriter->pRecorderNode == NULL)
            {
                QWORD   cnsTemp;
                
                ::SafeAdd(cnsTemp, pPrevWriter->cnsStartTime, m_cnsTimeExtentOfEachFile);

                DVR_ASSERT(pPrevWriter->cnsEndTime <= cnsTemp, 
                           "A temporary node in the writers list has extent > m_cnsTimeExtentOfEachFile");
                
                if (pPrevWriter->cnsEndTime < cnsTemp)
                {
                    // We have asserted that the next writer is a permanent node above
                    if (pNextWriter && cnsTemp > pNextWriter->cnsStartTime)
                    {
                        cnsTemp = pNextWriter->cnsStartTime;
                    }
                    if (pPrevWriter->cnsEndTime != cnsTemp) // this test is redundant, will always succeed
                    {
                        // Adjust it
                        ft[dwNumNodesToUpdate].nFileId = pPrevWriter->nFileId;
                        ft[dwNumNodesToUpdate].cnsStartTime = pPrevWriter->cnsStartTime;
                        pPrevWriter->cnsEndTime = ft[dwNumNodesToUpdate].cnsEndTime = cnsTemp;
                        dwNumNodesToUpdate++;
                    }
                }
            }
            // Set start time = end time for the recorder's writer node.
            // Note that these may be less than cnsTemp. SetFileTimes should be 
            // able to handle this since start time == end time
            ft[dwNumNodesToUpdate].nFileId = pWriterNode->nFileId;
            ft[dwNumNodesToUpdate].cnsStartTime = ft[dwNumNodesToUpdate].cnsEndTime = cnsStopTime;
            dwNumNodesToUpdate++;

            RemoveEntryList(pWriter);
            NULL_NODE_POINTERS(pWriter);

            // We defer closing the file till after the next node has been primed.
            // We do not want to leave the writer in a state in which all files have
            // been closed as that could confuse a reader of the ring buffer to believe
            // that it has hit EOF. (It is necessary to do this only if the reader could
            // be reading this file, which is possible only if
            // !IsFlagSet(SampleWritten) && cnsStopTime == *m_pcnsCurrentStreamTime. 
            // However, it doesn't hurt to always do this.)
            //
            // WAS:
            // Ignore the returned status; the node is deleted if there was an error
            // hr = CloseWriterFile(pWriter);
            pWriterNodeToBeClosed = pWriter;

            hr = m_pDVRFileCollection->SetFileTimes(dwNumNodesToUpdate, &ft[0]);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else
            {
                // S_FALSE is ok; the list could have got empty if cnsStopTime = m_cnsFirstSampleTime
                // and we have not yet written a sample; i.e., a recording was set
                // up starting at time t= m_cnsFirstSampleTime and is now being cancelled.
            }

            // Determine if we have to prime the writer's list
            BOOL bPrime = 0;
            // The start, end times passed to AddATemporaryFile
            QWORD               cnsTempStartTimeAddFile;
            QWORD               cnsTempEndTimeAddFile;

            if (pPrevWriter)
            {
                if (IsFlagSet(SampleWritten) && 
                    *m_pcnsCurrentStreamTime >= pPrevWriter->cnsStartTime && 
                    *m_pcnsCurrentStreamTime <= pPrevWriter->cnsEndTime &&
                    (!pNextWriter || pPrevWriter->cnsEndTime < pNextWriter->cnsStartTime)
                   )
                {
                    // Current writes are going to the previous node and the
                    // time extent of the previous node and the node we deleted
                    // are contiguous. The node that we deleted can be considered 
                    // to have been the priming node.
                    //
                    // There is no need to prime here since WriteSample does that
                    // but we may as well

                    // If no sample has been written, we have a previous writer node
                    // which should cover the first write (by code design)

                    bPrime = 1;
                    cnsTempStartTimeAddFile = pPrevWriter->cnsEndTime;
                }
            }
            else
            {
                // If IsFlagSet(SampleWritten):
                // We know that cnsStopTime > *m_pcnsCurrentStreamTime. The node
                // corresponding to *m_pcnsCurrentStreamTime must be in the writers list
                // and it cannot have been closed by calling CloseAllWriterFilesBefore in
                // WriteSample (even in the case that m_cnsMaxStreamDelta = 0) because 
                // WriteSamples closes files only if the file's end time is <=
                // *m_pcnsCurrentStreamTime - m_cnsMaxStreamDelta, i.e., all samples
                // in the file have times < (not <=) *m_pcnsCurrentStreamTime - 
                // m_cnsMaxStreamDelta. So pPrevWriter cannot be NULL.

                // Conclusion: WriteSample has not been called at all, 
                // i.e., !IsFlagSet(SampleWritten). Note that
                // SetFirstSampleTime may have been called and that 
                // m_cnsFirstSampleTime may not be 0.

                if (IsFlagSet(SampleWritten))
                {
                    DVR_ASSERT(!IsFlagSet(SampleWritten), "");
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "No previous node in m_leWritersList for writer node corresponding to the stopped recorder node id=0x%x althugh a sample has been written", 
                                    pStop);
                    hrRet = E_FAIL;
                    __leave;
                }
                bPrime = 1;
                cnsTempStartTimeAddFile = m_cnsFirstSampleTime;
            }
            if (bPrime)
            {
                ::SafeAdd(cnsTempEndTimeAddFile, cnsTempStartTimeAddFile, m_cnsTimeExtentOfEachFile);
                if (pNextWriter && cnsTempEndTimeAddFile > pNextWriter->cnsStartTime)
                {
                    cnsTempEndTimeAddFile = pNextWriter->cnsStartTime;
                }
                hr = AddATemporaryFile(cnsTempStartTimeAddFile, cnsTempEndTimeAddFile);
                if (FAILED(hr))
                {
                    DVR_ASSERT(0, "AddATemporaryFile for priming failed.");
                    hrRet = hr;
                    DvrIopDebugOut7(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "Failed to prime a writer node after stopping recording for recorder id = 0x%x, SampleWritten = %d "
                                    "Previous writer exists: %hs, "
                                    "Start time supplied to AddATemporaryFile: %I64u, "
                                    "End time supplied to AddATemporaryFile: %I64u, "
                                    "Current stream time: %I64u, "
                                    "m_cnsFirstSampleTime: %I64u.",
                                    pStop,
                                    IsFlagSet(SampleWritten)? 1 : 0,
                                    pPrevWriter? "Yes" : "No",
                                    cnsTempStartTimeAddFile,
                                    cnsTempEndTimeAddFile,
                                    *m_pcnsCurrentStreamTime,
                                    m_cnsFirstSampleTime
                                    );
                }
            }
        } // if (cnsStopTime == pRecorderNode->cnsStartTime)
        hrRet = S_OK;
    }
    __finally
    {
        if (pWriterNodeToBeClosed)
        {
            // Ignore the returned status; the node is deleted if there was an error
            CloseWriterFile(pWriterNodeToBeClosed);
        }
        if (FAILED(hrRet) && bIrrecoverableError)
        {
            m_nNotOkToWrite = MINLONG;
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::StopRecording

HRESULT CDVRRingBufferWriter::DeleteRecorder(IN LPVOID pRecorderId)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::DeleteRecorder"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        LIST_ENTRY*         pCurrent;  
        PASF_RECORDER_NODE  pRecorderNode;
        LIST_ENTRY*         pDelete = (LIST_ENTRY*) pRecorderId;

        pRecorderNode = CONTAINING_RECORD(pDelete, ASF_RECORDER_NODE, leListEntry);

        pRecorderNode->SetFlags(ASF_RECORDER_NODE::RecorderNodeDeleted);

        // The DeleteRecorderNode is set by CloseWriterFile/ProcessCloseRequest
        // after the recorder's file has been closed. It is also set in
        // the ASF_RECORDER_NODE constructor and cleared only when 
        // the start recording time is set. Note that recorder nodes that
        // have not been started (StartRecording not called) cannot be 
        // cancelled (StopRecording won't take MAXQWORD as an argument)
        // but they can be deleted.
        if (pRecorderNode->IsFlagSet(ASF_RECORDER_NODE::DeleteRecorderNode))
        {
            // If pWriterNode is not NULL, CreateRecorder failed or the
            // client deleted the recorder before starting it
            if (pRecorderNode->pWriterNode)
            {
                // Ignore the returned status; if this fails, the 
                // writer node is just deleted

                if (!LIST_NODE_POINTERS_NULL(&pRecorderNode->pWriterNode->leListEntry))
                {
                    RemoveEntryList(&pRecorderNode->pWriterNode->leListEntry);
                    NULL_NODE_POINTERS(&pRecorderNode->pWriterNode->leListEntry);
                }

                HRESULT hr;

                hr = CloseWriterFile(&pRecorderNode->pWriterNode->leListEntry);

                // We don't have to wait for the file to be closed.
                // CloseWriterFile/ProcessCloseRequest will delete 
                // pRecorderNode asynchronously.
                // Do NOT access pRecorderNode after this
                pRecorderNode = NULL;
            }
            else if (!LIST_NODE_POINTERS_NULL(pDelete))
            {
                RemoveEntryList(pDelete);
                NULL_NODE_POINTERS(pDelete);
                delete pRecorderNode;
                pRecorderNode = NULL;
            }
            else
            {
                delete pRecorderNode;
                pRecorderNode = NULL;
            }
        }
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::DeleteRecorder

HRESULT CDVRRingBufferWriter::GetRecordingStatus(IN  LPVOID pRecorderId,
                                                 OUT HRESULT* phResult OPTIONAL,
                                                 OUT BOOL*  pbStarted OPTIONAL,
                                                 OUT BOOL*  pbStopped OPTIONAL,
                                                 OUT BOOL*  pbSet) 
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetRecordingStatus"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    if (!pbSet || DvrIopIsBadWritePtr(pbSet, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");        
        return E_POINTER;
    }
    *pbSet = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        LIST_ENTRY*         pCurrent;  
        PASF_RECORDER_NODE  pRecorderNode;
        LIST_ENTRY*         pRecorder = (LIST_ENTRY*) pRecorderId;

        pRecorderNode = CONTAINING_RECORD(pRecorder, ASF_RECORDER_NODE, leListEntry);

        if (phResult)
        {
            *phResult = pRecorderNode->hrRet;
        }

        if (pbStarted == NULL && pbStopped == NULL)
        {
            __leave;
        }

        if (!IsFlagSet(WriterClosed))
        {
            QWORD cnsStreamTime = *m_pcnsCurrentStreamTime;
            if (pbStarted)
            {
                *pbStarted = cnsStreamTime >= pRecorderNode->cnsStartTime;
            }
            if (pbStopped)
            {
                *pbStopped = cnsStreamTime >= pRecorderNode->cnsEndTime;
            }
            *pbSet = 1;
        }
        else
        {
            // The recorder object should fill pbStart and pbStop
        }

    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::GetRecordingStatus

HRESULT CDVRRingBufferWriter::HasRecordingFileBeenClosed(IN LPVOID pRecorderId)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::HasRecordingFileBeenClosed"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        LIST_ENTRY*         pCurrent;  
        PASF_RECORDER_NODE  pRecorderNode;
        LIST_ENTRY*         pRecorder = (LIST_ENTRY*) pRecorderId;

        pRecorderNode = CONTAINING_RECORD(pRecorder, ASF_RECORDER_NODE, leListEntry);

        hrRet = pRecorderNode->pWriterNode == NULL? S_OK : S_FALSE;
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::HasRecordingFileBeenClosed

// ====== IUnknown

STDMETHODIMP CDVRRingBufferWriter::QueryInterface(IN  REFIID riid, 
                                                  OUT void   **ppv)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::QueryInterface"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet;

    if (!ppv || DvrIopIsBadWritePtr(ppv, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");        
        hrRet = E_POINTER;
    }
    else if (riid == IID_IUnknown)
    {        
        *ppv = (IUnknown*) this;
        hrRet = S_OK;
    }
    else if (riid == IID_IDVRRingBufferWriter)
    {        
        *ppv = (IDVRRingBufferWriter*) this;
        hrRet = S_OK;
    }
    else
    {
        *ppv = NULL;
        hrRet = E_NOINTERFACE;
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "no such interface");        
    }

    if (SUCCEEDED(hrRet))
    {
        ((IUnknown *) (*ppv))->AddRef();
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    
    return hrRet;

} // CDVRRingBufferWriter::QueryInterface


STDMETHODIMP_(ULONG) CDVRRingBufferWriter::AddRef()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::AddRef"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedIncrement(&m_nRefCount);

    DVR_ASSERT(nNewRef > 0, 
               "m_nRefCount <= 0 after InterlockedIncrement");

    DVRIO_TRACE_LEAVE1(nNewRef);
    
    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRRingBufferWriter::AddRef


STDMETHODIMP_(ULONG) CDVRRingBufferWriter::Release()
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::Release"

    DVRIO_TRACE_ENTER();

    LONG nNewRef = InterlockedDecrement(&m_nRefCount);

    DVR_ASSERT(nNewRef >= 0, 
              "m_nRefCount < 0 after InterlockedDecrement");

    if (nNewRef == 0) 
    {
        // Must call DebugOut before the delete because the 
        // DebugOut references this->m_dwClassInstanceId
        DvrIopDebugOut1(DVRIO_DBG_LEVEL_TRACE, 
                        "Leaving, object *destroyed*, returning %u",
                        nNewRef);
        delete this;
    }
    else
    {
        DVRIO_TRACE_LEAVE1(nNewRef);
    }
 
    return nNewRef <= 0? 0 : (ULONG) nNewRef;

} // CDVRRingBufferWriter::Release


// ====== IDVRRingBufferWriter


STDMETHODIMP CDVRRingBufferWriter::SetFirstSampleTime(IN QWORD cnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::SetFirstSampleTime"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;
    BOOL    bLocked = 0;    // We have locked m_pDVRFileCollection
    BOOL    bRecoverableError = 0;


    ::EnterCriticalSection(&m_csLock);

    __try
    {
        if (IsFlagSet(StartingStreamTimeKnown))
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "StartingStreamTimeKnown flag is set (expect it is not "
                            "set when this function is called).");

            hrRet = E_UNEXPECTED;
            bRecoverableError = 1;
            __leave;
        }
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }
        if (m_cnsFirstSampleTime != 0)
        {
            DVR_ASSERT(m_cnsFirstSampleTime == 0, "");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "m_cnsFirstSampleTime = %I64u, should be 0",
                            m_cnsFirstSampleTime);
            bRecoverableError = 1;
            hrRet = E_FAIL;
            __leave;
        }

        // This should have been set in our constructor.
        DVR_ASSERT(m_pcnsCurrentStreamTime, "");

        if (cnsStreamTime == m_cnsFirstSampleTime)
        {
            // Skip out of this routine
            hrRet = S_OK;
            __leave;
        }

        // We have to update the times of nodes in m_leWritersList

        LIST_ENTRY*         pWriter;
        PASF_WRITER_NODE    pWriterNode;
        DWORD               dwNumNodesToUpdate;
        HRESULT             hr;

        // There should be at least one node in the list; there could be more
        // if StartRecording has been called. 

        if (IsListEmpty(&m_leWritersList))
        {
            DVR_ASSERT(!IsListEmpty(&m_leWritersList), 
                       "Writers list is empty - should have been primed in the constructor "
                       "and in StopRecording.");
            hrRet = E_FAIL;
          __leave;
        }

        pWriter = NEXT_LIST_NODE(&m_leWritersList);
        pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

        // The first node should have a start time of 0 regardless of 
        // whether it is a temporary node or a recorder node.
        if (pWriterNode->cnsStartTime != 0)
        {
            DVR_ASSERT(pWriterNode->cnsStartTime == 0, 
                       "Temporary writer's node start time != 0 ");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Temporary writer's node start time != 0; it is %I64u",
                            pWriterNode->cnsStartTime);
            hrRet = E_FAIL;
            __leave;
        }

        // We consider two cases: cnsStreamTime is (a) before and (b) after the first 
        // recording's start time 

        QWORD cnsFirstRecordingTime = MAXQWORD;

        if (!IsListEmpty(&m_leRecordersList))
        {
            PASF_RECORDER_NODE  pRecorderNode;

            pRecorderNode = CONTAINING_RECORD(NEXT_LIST_NODE(&m_leRecordersList), ASF_RECORDER_NODE, leListEntry);
            
            // If StartRecording has not been called on the first recorder node
            // its start time would be MAXQWORD, which works for us here.
            cnsFirstRecordingTime = pRecorderNode->cnsStartTime;
        }

        if (cnsStreamTime < cnsFirstRecordingTime)
        {
            CDVRFileCollection::DVRIOP_FILE_TIME    ft;

            ft.nFileId = pWriterNode->nFileId;
            ft.cnsStartTime = cnsStreamTime;
            ::SafeAdd(ft.cnsEndTime, cnsStreamTime, m_cnsTimeExtentOfEachFile);
            if (ft.cnsEndTime > cnsFirstRecordingTime)
            {
                ft.cnsEndTime = cnsFirstRecordingTime;
            }
            dwNumNodesToUpdate = 1;

            // No need to call CloseAllWriterFilesBefore here.

            hr = m_pDVRFileCollection->Lock();
            if (FAILED(hr))
            {
                hrRet = hr;
                bRecoverableError = 1;
                __leave;
            }
            bLocked = 1;

            // Update the times on the writer node
            pWriterNode->cnsStartTime = cnsStreamTime;
            pWriterNode->cnsEndTime = ft.cnsEndTime;


            hr = m_pDVRFileCollection->SetFileTimes(dwNumNodesToUpdate, &ft);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else if (hr == S_FALSE)
            {
                // We have at least one node in the list.
                DVR_ASSERT(hr == S_OK, "hr = S_FALSE unexpected");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "SetFileTimes returns hr = 0x%x - unexpected.",
                                hr); 
                hrRet = E_FAIL;
                __leave;
            }
        }
        else
        {
            // Find out which node cnsStreamTime corresponds to. Note that
            // there may not be any node because cnsStreamTime falls between
            // two recordings or after the last recording. Note that we do
            // NOT create a temporary node after every recording node just
            // so that this case would be covered. If we did, we'd have
            // the file collection object could have more than m_dwNumberOfFiles
            // temporary files in it even before we got the first sample and
            // we'd have to change its algorithm for computing the time extent
            // of the ring buffer (and possibly maintain writer ref counts).
            // Instead, we pay the penalty here - we wait till a file is 
            // primed. Two notes: 1. we cannot re-use the temporary file node
            // as is because its order relative to the other files would change
            // (SetFileTimes would fail) and 2. This case will not happen
            // unless the client called StopRecording before writing started.

            LIST_ENTRY*         pWriterForThisSample = NULL;
            
            // The start, end time of the last node passed to SetFileTimes
            QWORD               cnsTempStartTime; 
            QWORD               cnsTempEndTime; 
#if defined(DEBUG)
            BOOL                bFirstIteration = 1;
#endif
            // The start, end times passed to AddATemporaryFile
            QWORD               cnsTempStartTimeAddFile; // always cnsStreamTime
            QWORD               cnsTempEndTimeAddFile;

            // If a file's end time is before this, it should be closed by 
            // calling CloseAllWriterFilesBefore
            QWORD cnsCloseTime;

            dwNumNodesToUpdate = 0;
            pWriter = NEXT_LIST_NODE(&m_leWritersList);
            while (pWriter != &m_leWritersList)
            {
                pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

#if defined(DEBUG)
                if (!bFirstIteration)
                {
                    // Note that this mayu also be true for the first node in
                    // the writer's list, but it doesn't have to be.
                    DVR_ASSERT(pWriterNode->pRecorderNode != NULL, "");
                }
#endif
                if (pWriterNode->cnsStartTime > cnsStreamTime)
                {
                   // If this assertion fails, we never set cnsTempStartTime and cnsTempEndTime,
                    // but use them.
                    DVR_ASSERT(!bFirstIteration, 
                              "cnsStreamTime should be < the first recording time; we should not be here!");                        
                
                    // We will have to call AddATemporaryFile to create a temporary file
                    // cnsStreamTime falls between two recordings
                    cnsTempStartTimeAddFile = cnsStreamTime;
                    ::SafeAdd(cnsTempEndTimeAddFile, cnsStreamTime, m_cnsTimeExtentOfEachFile);
                    if (cnsTempEndTimeAddFile > pWriterNode->cnsStartTime)
                    {
                        cnsTempEndTimeAddFile = pWriterNode->cnsStartTime;
                    }
                    break;
                }

                dwNumNodesToUpdate++;
                if (pWriterNode->cnsEndTime > cnsStreamTime)
                {
                    // cnsStreamTime falls within this recording

                    // Assert this writer node has an associated recorder
                    DVR_ASSERT(pWriterNode->pRecorderNode != NULL, "");

                    pWriterForThisSample = pWriter;
                    cnsTempEndTime = pWriterNode->cnsEndTime;
                    cnsTempStartTime = cnsStreamTime;
                    break;
                }
                cnsTempStartTime = cnsTempEndTime = pWriterNode->cnsStartTime;
                pWriter = NEXT_LIST_NODE(pWriter);
#if defined(DEBUG)
                bFirstIteration = 0;
#endif
            }
            if (pWriter == &m_leWritersList)
            {
                cnsTempStartTimeAddFile = cnsStreamTime;
                // We will have to call AddATemporaryFile to create a temporary file
                // cnsStreamTime is after the last recording
                ::SafeAdd(cnsTempEndTimeAddFile, cnsStreamTime, m_cnsTimeExtentOfEachFile);
            }

            CDVRFileCollection::PDVRIOP_FILE_TIME   pFileTimes;
            pFileTimes = (CDVRFileCollection::PDVRIOP_FILE_TIME) _alloca(dwNumNodesToUpdate*sizeof(CDVRFileCollection::DVRIOP_FILE_TIME));
            if (pFileTimes == NULL)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "alloca failed - %u bytes", 
                                dwNumNodesToUpdate*sizeof(CDVRFileCollection::DVRIOP_FILE_TIME));

                hrRet = E_OUTOFMEMORY; // out of stack space
                bRecoverableError = 1;
                __leave;
            }

            pWriter = &m_leWritersList;
            for (DWORD i = 0; i < dwNumNodesToUpdate; i++)
            {
                pWriter = NEXT_LIST_NODE(pWriter);
                pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);
                pFileTimes[i].nFileId = pWriterNode->nFileId;
                pFileTimes[i].cnsStartTime = pFileTimes[i].cnsEndTime = pWriterNode->cnsStartTime;
            }
            // Change start and end times for the last node passed to SetFileTimes
            // Also update this info on the writer node itself.
            pFileTimes[i].cnsStartTime = cnsTempStartTime; 
            pFileTimes[i].cnsEndTime = cnsTempEndTime;

            // Update the times on the writer node. Note that this is safe even
            // if cnsStreamTime falls between two recordings or after the last
            // recording; in these cases cnsTempStartTime and cnsTempEndTime
            // were set from the start, end times of the same writer node.
            DVR_ASSERT(pWriterForThisSample || 
                       (pWriterNode->cnsStartTime == cnsTempStartTime &&
                        pWriterNode->cnsEndTime == cnsTempEndTime),
                       "");
            pWriterNode->cnsStartTime = cnsTempStartTime;
            pWriterNode->cnsEndTime = cnsTempEndTime;

            // We call close writer files here to delete nodes before cnsStreamTime
            // from m_leWritersList and close the ASF files. If we do this before calling
            // SetFileTimes, the chances of deleting temporary disk files in the 
            // SetFileTimes call are greater. Other than that; there is no need
            // to make this call before SetFileTimes().
            //
            // Note that m_leWritersList is changed after the call
            //

            // NOTE: We do NOT update the start and end times on ASF_RECORDER_NODE
            // nodes. This is deliberate. CloseWriterFile/ProcessCloseRequest which
            // are called by CloseAllWriterFilesBefore pulls the recorder nodes out
            // of m_leRecordersList and leaves them "hanging" till the client
            // calls DeleteRecorder. At that time the nodes are deleted. Since the
            // nodes are not in the recorders list, the start/end times on the 
            // nodes do not matter any more.
            //
            // The exception to this is the recorder node corresponding to 
            // pWriterForThisSample. The first sample time falls within the
            // extent of this writer node, so the writer will not be closed.
            if (pWriterForThisSample)
            {
                PASF_WRITER_NODE pTmpNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);
                
                // This has already been asserted in the while loop above
                DVR_ASSERT(pTmpNode->pRecorderNode != NULL, "");

                DVR_ASSERT(pTmpNode->pRecorderNode->cnsStartTime != MAXQWORD &&
                           pTmpNode->pRecorderNode->cnsEndTime != MAXQWORD &&
                           pTmpNode->pRecorderNode->cnsEndTime == cnsTempEndTime, "");

                pTmpNode->pRecorderNode->cnsStartTime = cnsTempStartTime;
            }

            // We lock the file collection before closign the writer files.
            // A reader that has one of the closed writer files open will get
            // an EOF when the file is closed. The reader would next try to
            // get info about the closed file from the file collection object.
            // We keep the object locked till all updates are done; this 
            // will make the reader wait after it gets the EOF notification
            // till the file collection object is consistent with the writer's
            // call to SetFirstSampleTime. (Our reader will detect that the 
            // file that it got the EOF notification for has fallen out of the
            // ring buffer and bail out of GetNextSample.)
            //
            // Note also that we want at least 1 file int he ring buffer to be open
            // until the writer calls Close. By grabbing this lock before closing
            // the file, we can afford to relax that constraint - we can add the 
            // priming file after closing the file - because the reader can't 
            // get any info out of the file collection till it gets the lock anyway.

            hr = m_pDVRFileCollection->Lock();
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            bLocked = 1;

            hr = CloseAllWriterFilesBefore(cnsStreamTime);

            // Errors after this are not recoverable since the writers list has changed
            // as a result of calling CloseAllWriterFilesBefore()

            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }


            hr = m_pDVRFileCollection->SetFileTimes(dwNumNodesToUpdate, pFileTimes);
            if (FAILED(hr))
            {
                hrRet = hr;
                __leave;
            }
            else
            {
                // S_FALSE is ok; the list could have got empty if cnsStreamTime
                // is after the last recording
            }

            if (!pWriterForThisSample)
            {
                // Verify that:
                DVR_ASSERT(cnsTempStartTimeAddFile == cnsStreamTime, "");

                // Add a temporary file.
                
                hr = AddATemporaryFile(cnsTempStartTimeAddFile, cnsTempEndTimeAddFile);
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }
            }
        }

        hrRet = S_OK;

    }
    __finally
    {
        HRESULT hr;

        if (SUCCEEDED(hrRet))
        {
            SetFlags(StartingStreamTimeKnown);

            m_cnsFirstSampleTime = cnsStreamTime;

            if (!bLocked)
            {
                // Just in case the reader is accessing this concurrently ...

                hr = m_pDVRFileCollection->Lock();
                if (FAILED(hr))
                {
                    // Just go on
                }
                else
                {
                    bLocked = 1;
                }
            }
            
            // We update this even though we have not yet written the first sample.
            // This is ok, because a Seek (by the reader) to this time will succeed.
            // The ring buffer's time extent would be returned as (cnsStreamTime, cnsStreamTime).
            // Usually if the ring buffers time extent is returned as (T1, T2), there is
            // a sample time stamped T2, but this is an exception.
            //
            // If we don't set this here, GetTimeExtent on the reader (ring buffer)
            // would return a start time > end time (end time would be *m_pcnsCurrentStreamTime
            // which is 0.
            *m_pcnsCurrentStreamTime = cnsStreamTime;
            
            m_nNotOkToWrite++;
        }
        else if (!bRecoverableError)
        {
            m_nNotOkToWrite = MINLONG;
        }

        if (bLocked)
        {
            hr = m_pDVRFileCollection->Unlock();
            DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->Unlock failed");
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::SetFirstSampleTime

STDMETHODIMP CDVRRingBufferWriter::WriteSample(IN WORD  wStreamNum,
                                               IN QWORD cnsStreamTimeInput,
                                               IN DWORD dwFlags,
                                               IN INSSBuffer *pSample)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::WriteSample"

    DVRIO_TRACE_ENTER();

    DvrIopDebugOut2(DVRIO_DBG_LEVEL_TRACE,
                    "wStreamNum is %u, cnsStreamTimeInput is %I64u",
                    (DWORD) wStreamNum, cnsStreamTimeInput);


    HRESULT hrRet = E_FAIL;
    BOOL    bLocked = 0;    // We have locked m_pDVRFileCollection
    BOOL    bRecoverableError = 0;
    PASF_WRITER_NODE    pWriterNode = NULL;
    QWORD   cnsStreamTime;  // The actual time we supply to the SDK; different
                            // from cnsStreamTimeInput by at most a few msec.

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        // Not really necessary since _finally section does not use
        // cnsStreamTime if we leave with failure. We have to do this
        // if the EnforceIncreasingTimeStamps flag is not set
        cnsStreamTime = cnsStreamTimeInput;

        if (m_nNotOkToWrite)
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "m_nNotOkToWrite is %d (should be 0 to allow the write).",
                            m_nNotOkToWrite);

            // This clause will cover the case when we hit a recoverable error 
            // earlier. It doesn't hurt to set bRecoverableError to 1 in that case.
            bRecoverableError  = 1;
            hrRet = E_UNEXPECTED;
            __leave;
        }

        // m_nNotOkToWrite == 0 implies:
        DVR_ASSERT(IsFlagSet(StartingStreamTimeKnown) && IsFlagSet(MaxStreamDeltaSet) && 
                   !IsFlagSet(WriterClosed), "m_nNotOkToWrite is 0?!");

        // Redundant: We have tested this in SetFirstSampleTime and 
        // we have checked (via the m_nNotOkToWrite test) that that function
        // has been called
        // DVR_ASSERT(m_pcnsCurrentStreamTime, "");

        if (cnsStreamTimeInput < m_cnsFirstSampleTime)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "cnsStreamTimeInput (%I64u) <= m_cnsFirstSampleTime (%I64u)",
                            cnsStreamTimeInput, m_cnsFirstSampleTime);
            bRecoverableError  = 1;
            hrRet = E_INVALIDARG;
            __leave;
        }

        // Workaround an SDK bug. First, the precision that the SDK provides for
        // timestamps is 1 msec precision although its input is a cns - cns are
        // truncated down to msec and scaled back up in the mux. Secondly. the 
        // mux reorders samples and fragments of samples that have the same time
        // stamp. This is not an issue for  samples in different streams. However,
        // if 2 samples in the same stream have the same timestamp and some of
        // these samples are fragmented across ASF packets, the sample fragments 
        // can be interleaved. For example, sample 2 fragment 1 can be followed
        // by sample 1 (unfragmented), which is followed by sample 2 fragment 2.
        // Even if the reader can put this back together (currently there is a 
        // bug in the reader that causes it to discard sample 2 altogether in
        // the case that samples 1 and 2 both have a timestamp of 0), this could 
        // cause issues for seeking. The safe thing is to work around all this
        // and provide timestamps  that increase by at least 1 msec to the SDK.
        //
        if (IsFlagSet(EnforceIncreasingTimeStamps))
        {
            // Note that *m_pcnsCurrentStreamTime will usually be a multiple of
            // k_dwMilliSecondsToCNS. The exception is the value it is set to in 
            // SetFirstSampleTime

            QWORD       msStreamTime     = cnsStreamTimeInput/k_dwMilliSecondsToCNS;
            QWORD       msLastStreamTime = *m_pcnsCurrentStreamTime/k_dwMilliSecondsToCNS;
        
            if (msStreamTime <= msLastStreamTime)
            {
                msStreamTime = msLastStreamTime + 1;
            }
            cnsStreamTime = msStreamTime * k_dwMilliSecondsToCNS;
        }

        // We have closed files through *m_pcnsCurrentStreamTime - m_cnsMaxStreamDelta
        // [that is files whose end time is *m_pcnsCurrentStreamTime - m_cnsMaxStreamDelta,
        // i.e., whose samples have times < (not <=) *m_pcnsCurrentStreamTime - 
        // m_cnsMaxStreamDelta, i.e., 2 successive calls can supply a stream time
        // of *m_pcnsCurrentStreamTime - m_cnsMaxStreamDelta without error].
        //
        // If we get a sample earlier than that, fail the call.
        // Note that for the first sample that's written, we have actually closed
        // files through *m_pcnsCurrentStreamTime, which is equal to m_cnsFirstSampleTime,
        // but this test is harmless in that case.

        if (*m_pcnsCurrentStreamTime > m_cnsMaxStreamDelta &&
            cnsStreamTime < *m_pcnsCurrentStreamTime - m_cnsMaxStreamDelta)
        {
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "cnsStreamTime (%I64u) <= *m_pcnsCurrentStreamTime - m_cnsMaxStreamDelta (%I64u)",
                            cnsStreamTime, *m_pcnsCurrentStreamTime - m_cnsMaxStreamDelta);
            bRecoverableError  = 1;
            hrRet = E_INVALIDARG;
            __leave;
        }

        if (cnsStreamTime == MAXQWORD)
        {
            // Note that a file with end time = T means the file has samples
            // whose times are < T (not <= T)

            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "cnsStreamTime == QWORD_INIFITE is invalid.");
            bRecoverableError  = 1;
            hrRet = E_INVALIDARG;
            __leave;
        }

        // Find the node corresponding to cnsStreamTime

        LIST_ENTRY*         pWriter = NEXT_LIST_NODE(&m_leWritersList);
        BOOL                bFoundWriterForThisSample = 0;

        pWriter = NEXT_LIST_NODE(&m_leWritersList);
        while (pWriter != &m_leWritersList)
        {
            pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

            if (pWriterNode->cnsStartTime > cnsStreamTime)
            {            
                // We will have to call AddATemporaryFile to create a file
                // Clearly, there is a time hole here.
                break;
            }

            if (pWriterNode->cnsEndTime > cnsStreamTime)
            {
                // cnsStreamTime corresponds to this node
                bFoundWriterForThisSample = 1;
                break;
            }
            pWriter = NEXT_LIST_NODE(pWriter);
        }

        if (!bFoundWriterForThisSample)
        {
            // We either have a time hole or we've hit the end ofthe list and
            // not found a primed file (or both - if the list was empty).

            // Verify that we are in sync w/ the file collection, i.e., that
            // the file colection also does not have a file for this time.

            hr = m_pDVRFileCollection->GetFileAtTime(cnsStreamTime, 
                                                     NULL,          // ppwszFileName OPTIONAL,
                                                     NULL,          // pcnsFirstSampleTimeOffsetFromStartOfFile
                                                     NULL,          // pnFileId OPTIONAL,
                                                     0              // bFileWillBeOpened
                                                    );
            if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                DVR_ASSERT(0, 
                           "Writers list not in sync w/ file collection");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "Writer's list not in sync w/ file collection for the stream time %I64u",
                                cnsStreamTime);
                hrRet = E_FAIL;
                __leave;
            }

            // The start, end times passed to AddATemporaryFile if we do not find a node
            QWORD               cnsTempStartTimeAddFile;
            QWORD               cnsTempEndTimeAddFile;

            hr = m_pDVRFileCollection->GetLastValidTimeBefore(cnsStreamTime,
                                                              &cnsTempStartTimeAddFile);
            if (FAILED(hr))
            {
                // The call should not fail. We have ensured that 
                // (a) cnsStreamTime >= m_cnsFirstSampleTime. i.e., we are not writing before 
                // the first sample time and
                // (b) cnsStreamTime > *m_pcnsCurrentStreamTime - m_cnsMaxStreamDelta. 
                // 
                // If the call fails, there are no temporary (or permanent) files before cnsStreamTime.
                // But we added 1 temporary file before writing started and the file collection and
                // the file collection always maintains m_dwNumberOfFiles temporary files in its
                // extent. It cannot be the case that all temporary files are after cnsStreamTime 
                // because of (b) and the relation between m_cnsMaxStreamDelta and m_dwNumberOfFiles. 
                // So there must have been some bad calls to SetFileTimes that zapped all temporary 
                // (and permanent) files before cnsStreamTime.
             
                DVR_ASSERT(0, 
                           "GetLastValidTimeBefore failed");
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "GetLastValidTimeBefore for the stream time %I64u",
                                cnsStreamTime);
                hrRet = E_FAIL;
                __leave;
            }
            // Advance the start time to the first usable time after the last 
            // valid one. So now, cnsTempStartTimeAddFile <= cnsStreamTime
            cnsTempStartTimeAddFile += 1;

            hr = m_pDVRFileCollection->GetFirstValidTimeAfter(cnsStreamTime,
                                                              &cnsTempEndTimeAddFile);
            if (FAILED(hr))
            {
                cnsTempEndTimeAddFile = MAXQWORD;
            }

            QWORD               cnsTempLast;
            QWORD               cnsTemp;
            
            if (cnsStreamTime - cnsTempStartTimeAddFile > 20 * m_cnsTimeExtentOfEachFile)
            {
                if (cnsTempEndTimeAddFile - cnsStreamTime < 10 * m_cnsTimeExtentOfEachFile)
                {
                    cnsTempLast = cnsTempEndTimeAddFile;

                    while (cnsTempLast > cnsStreamTime)
                    {
                        cnsTempLast -= m_cnsTimeExtentOfEachFile;
                    } 
                }
                else
                {
                    // An eight of the extent before the current sample time is 
                    // arbitrary.
                    cnsTempLast = cnsStreamTime - m_cnsTimeExtentOfEachFile/8;
                }
                ::SafeAdd(cnsTemp, cnsTempLast, m_cnsTimeExtentOfEachFile);
            }
            else
            {
                cnsTemp = cnsTempStartTimeAddFile;

                DVR_ASSERT(cnsTemp <= cnsStreamTime, "");

                while (cnsTemp <= cnsStreamTime)
                {
                    // We maintain cnsTempLast rather than subtract m_cnsTimeExtentOfEachFile
                    // from cnsTemp after the loop because SafeAdd may return MAXQWORD
                    cnsTempLast = cnsTemp;
             
                    ::SafeAdd(cnsTemp, cnsTemp, m_cnsTimeExtentOfEachFile);
                } 
            }

            cnsTempStartTimeAddFile = cnsTempLast;

            // End time is the min of:
            // - cnsTempStartTimeAddFile + m_cnsTimeExtentOfEachFile
            // - MAXQWORD
            // - the start time of the next node in the writer's list
            if (cnsTemp < cnsTempEndTimeAddFile)
            {
                cnsTempEndTimeAddFile = cnsTemp;
            }

            hr = AddATemporaryFile(cnsTempStartTimeAddFile, cnsTempEndTimeAddFile);
            if (FAILED(hr))
            {
                DVR_ASSERT(0, "AddATemporaryFile failed.");
                hrRet = hr;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "Failed to add a node for the stream time %I64u",
                                cnsStreamTime);
                __leave;
            }

            // Find the node we just added
            pWriter = NEXT_LIST_NODE(&m_leWritersList);
            while (pWriter != &m_leWritersList)
            {
                pWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

                if (pWriterNode->cnsStartTime > cnsStreamTime)
                {            
                    // bad, bad, bad
                    break;
                }

                if (pWriterNode->cnsEndTime > cnsStreamTime)
                {
                    // cnsStreamTime corresponds to this node
                    bFoundWriterForThisSample = 1;
                    break;
                }
                pWriter = NEXT_LIST_NODE(pWriter);
            }
        }

        // We MUST already have a node in the writer's list corresponding to 
        // cnsStreamTime.

        if (!bFoundWriterForThisSample)
        {
            DVR_ASSERT(0, 
                       "Writers list does not have a node for the given stream time");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Writer's list does not have a ndoe for the stream time %I64u",
                            cnsStreamTime);
            pWriterNode = NULL;
            hrRet = E_FAIL;
            __leave;
        }

        // Wait for the file to be opened

        DWORD nRet = ::WaitForSingleObject(pWriterNode->hReadyToWriteTo, INFINITE);
        if (nRet == WAIT_FAILED)
        {
            DVR_ASSERT(0, "Writer node's WFSO(hReadyToWriteTo) failed");

            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x", 
                            pWriterNode->hReadyToWriteTo, dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
           __leave; 
        }

        if (pWriterNode->pWMWriter == NULL)
        {
            DVR_ASSERT(pWriterNode->pWMWriter != NULL, "");
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Writer node's pWMWriter is NULL?!");
            hrRet = E_FAIL;
            __leave;
        }

        // Verify there was no error in opening the file, i.e., BeginWriting 
        // succeeded
        if (FAILED(pWriterNode->hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "Writer node's hrRet indicates failure, hrRet = 0x%x",
                            pWriterNode->hrRet);
            hrRet = pWriterNode->hrRet;
            __leave;
        }

        // We are ready to write.
        hr = pWriterNode->pWMWriterAdvanced->WriteStreamSample(
                                                 wStreamNum,
                                                 cnsStreamTime - pWriterNode->cnsStartTime, // sample time
                                                 0, // send time by SDK
                                                 0, // duration - unused by SDK
                                                 dwFlags,
                                                 pSample);

        if (FAILED(hr))
        {
            if (hr == NS_E_INVALID_REQUEST)
            {
                // Internal error
                DVR_ASSERT(SUCCEEDED(hr), "pWMWriter->WriteSample failed");
                hrRet = E_FAIL;
            }
            else
            {
                hrRet = hr;
                bRecoverableError = 1;
            }
            DvrIopDebugOut1(bRecoverableError?
                            DVRIO_DBG_LEVEL_CLIENT_ERROR :
                            DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pWMWriter->WriterSample failed, hr = 0x%x",
                            hr);
            __leave;
        }
        
        DVR_ASSERT(m_pDVRFileCollection, "");
        
        hr = m_pDVRFileCollection->Lock();
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
        if (*pWriterNode->pcnsFirstSampleTimeOffsetFromStartOfFile > cnsStreamTime - pWriterNode->cnsStartTime)
        {
            *pWriterNode->pcnsFirstSampleTimeOffsetFromStartOfFile = cnsStreamTime - pWriterNode->cnsStartTime;
            
            if (pWriterNode->nDupdHandles == ASF_WRITER_NODE::ASF_WRITER_NODE_HANDLES_NOT_DUPD)
            {
                HANDLE hDataFile;
                HANDLE hMemoryMappedFile;
                HANDLE hFileMapping;
                HANDLE hTempIndexFile;
                LPVOID hMappedView;

                DVR_ASSERT(pWriterNode->pDVRFileSink, "");

                hr = pWriterNode->pDVRFileSink->GetMappingHandles(&hDataFile,
                                                                  &hMemoryMappedFile,
                                                                  &hFileMapping,
                                                                  &hMappedView,
                                                                  &hTempIndexFile);
                if (FAILED(hr))
                {
                    DVR_ASSERT(SUCCEEDED(hr), "pWriterNode->pDVRFileSink->GetMappingHandles failed");
                    DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                    "pWriterNode->pDVRFileSink->GetMappingHandles failed, hr = 0x%x, will not try again",
                                    hr);
                }
                else
                {
                    hr = m_pDVRFileCollection->SetMappingHandles(pWriterNode->nFileId,
                                                                 hDataFile, 
                                                                 hMemoryMappedFile,
                                                                 hFileMapping,
                                                                 hMappedView,
                                                                 hTempIndexFile);    
                }
                pWriterNode->nDupdHandles = SUCCEEDED(hr)? 
                                                    ASF_WRITER_NODE::ASF_WRITER_NODE_HANDLES_DUPD : 
                                                    ASF_WRITER_NODE::ASF_WRITER_NODE_HANDLES_DUP_FAILED;
            }
        }
        DVR_ASSERT(pWriterNode->nDupdHandles != ASF_WRITER_NODE::ASF_WRITER_NODE_HANDLES_NOT_DUPD, "");

        if (*m_pcnsCurrentStreamTime < cnsStreamTime) 
        {
            *m_pcnsCurrentStreamTime = cnsStreamTime;
        }
        
        hr = m_pDVRFileCollection->Unlock();
        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }

        if (NEXT_LIST_NODE(&m_leWritersList) != pWriter &&
            cnsStreamTime > m_cnsMaxStreamDelta)
        {
            // Close writer files if we can

            // Note that this is done after we write the sample so that
            // we ensure that the ring buffer always has at least 1 open 
            // file. If we don't do this, it is possible that a reader
            // could detect EOF prematurely (all files have been closed by
            // the writer and there is no file after the one it last read 
            // from in the ring buffer).

            // Note that if we forced m_cnsMaxStreamDelta > 0 (instead of
            // letting it be >= 0), we could close open files at the start
            // of this function rather than here.

            // Note that CloseAllWriterFilesBefore will not close pWriter,
            // the file we just wrote to since cnsEndTime for the file we just
            // wrote to would be > cnsStreamTime.

            QWORD cnsCloseTime;

            cnsCloseTime = cnsStreamTime - m_cnsMaxStreamDelta;

            LIST_ENTRY*         pWriter = NEXT_LIST_NODE(&m_leWritersList);
            PASF_WRITER_NODE    pTmpWriterNode = CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry);

            if (pTmpWriterNode->cnsEndTime <= cnsCloseTime)
            {
                hr = CloseAllWriterFilesBefore(cnsCloseTime);
                if (FAILED(hr))
                {
                    hrRet = hr;
                    __leave;
                }
            }
        }

        // Prime the next file if need be

        BOOL                bPrime = 0;

        // The start, end times passed to AddATemporaryFile if we do not find a node
        QWORD               cnsTempStartTimeAddFile;
        QWORD               cnsTempEndTimeAddFile;
        
        if (NEXT_LIST_NODE(pWriter) == &m_leWritersList)
        {
            // Note that if pWriterNode->cnsEndTime == MAXQWORD, 
            // go ahead and prime. Typically, we'll need to because we
            // this node corresponds to a recorder. If the sample's write 
            // time has got to the neighbourhood of MAXQWORD, 
            // that's ok - we'll prime the file but never write to it.

            bPrime = 1;
            cnsTempStartTimeAddFile = pWriterNode->cnsEndTime;
            ::SafeAdd(cnsTempEndTimeAddFile, cnsTempStartTimeAddFile, m_cnsTimeExtentOfEachFile);
        }
        else
        {
            PASF_WRITER_NODE pNextWriterNode = CONTAINING_RECORD(NEXT_LIST_NODE(pWriter), ASF_WRITER_NODE, leListEntry);
            // Note that there is no need to special case MAXQWORD
            if (pNextWriterNode->cnsStartTime != pWriterNode->cnsEndTime)
            {
                bPrime = 1;
                cnsTempStartTimeAddFile = pWriterNode->cnsEndTime;
                ::SafeAdd(cnsTempEndTimeAddFile, cnsTempStartTimeAddFile, m_cnsTimeExtentOfEachFile);

                if (cnsTempEndTimeAddFile > pNextWriterNode->cnsStartTime)
                {
                    cnsTempEndTimeAddFile = pNextWriterNode->cnsStartTime;
                }
            }
            else
            {
                // Already primed
            }
        }

        if (bPrime)
        {
            hr = AddATemporaryFile(cnsTempStartTimeAddFile, cnsTempEndTimeAddFile);
            if (FAILED(hr))
            {
                DVR_ASSERT(0, "AddATemporaryFile for priming failed.");
                // We ignore this error - we can do this again later.
                // hrRet = hr;
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                                "Failed to prime a writer node for start stream time %I64u",
                                cnsTempStartTimeAddFile);
            }
        }

        hrRet = S_OK;
    }
    __finally
    {
        HRESULT hr;

        if (bLocked)
        {
            hr = m_pDVRFileCollection->Unlock();
            DVR_ASSERT(SUCCEEDED(hr), "m_pDVRFileCollection->Unlock failed");
        }

        if (SUCCEEDED(hrRet))
        {
            SetFlags(SampleWritten);

#if defined(DVR_UNOFFICIAL_BUILD)

            if (pWriterNode->hVal)
            {
                DWORD dwRet = 0;
                DWORD dwWritten;
                DWORD dwLastError;

                __try
                {
                    if (cnsStreamTime <= pWriterNode->cnsLastStreamTime && cnsStreamTime > 0)
                    {
                        // Our validate utility expects times to be monotonically increasing
                        // May as well close the validation file
                        DVR_ASSERT(0, "Stream time smaller than last write; validation file will be closed.");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal, 
                                        (LPVOID) &wStreamNum, sizeof(wStreamNum),
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != sizeof(wStreamNum))
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (wStreamNum)");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal, 
                                        (LPVOID) &cnsStreamTime, sizeof(cnsStreamTime),
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != sizeof(cnsStreamTime))
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (cnsStreamTime)");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal, 
                                        (LPVOID) &dwFlags, sizeof(dwFlags),
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != sizeof(dwFlags))
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (dwFlags)");
                        dwRet = 0;
                        __leave;
                    }

                    BYTE* pBuffer;
                    DWORD dwLength;

                    if (FAILED(pSample->GetBufferAndLength(&pBuffer, &dwLength)))
                    {
                        DVR_ASSERT(0, "GetBufferAndLength validation file failed");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal, 
                                        (LPVOID) &dwLength, sizeof(dwLength),
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != sizeof(dwLength))
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (dwLength)");
                        dwRet = 0;
                        __leave;
                    }

                    dwRet = ::WriteFile(pWriterNode->hVal, 
                                        (LPVOID) pBuffer, dwLength,
                                        &dwWritten, NULL);
                    if (dwRet == 0 || dwWritten != dwLength)
                    {
                        dwLastError = ::GetLastError();     // for debugging only
                        DVR_ASSERT(0, "Write to validation file failed (pSample->pBuffer)");
                        dwRet = 0;
                        __leave;
                    }

                }
                __finally
                {
                    if (dwRet == 0)
                    {
                        ::CloseHandle(pWriterNode->hVal);
                        pWriterNode->hVal = NULL;
                    }
                }

            }

#endif // if defined(DVR_UNOFFICIAL_BUILD)
        }
        else if (!bRecoverableError)
        {
            m_nNotOkToWrite = MINLONG;
            SetFlags(SampleWritten);
            if (pWriterNode && pWriterNode->pRecorderNode)
            {
                // Inform the recorder of the failure
                pWriterNode->pRecorderNode->hrRet = hrRet;
            }
        }
		else
		{
			// Dummy stmt so we can set a break here
			hr = hrRet;
		}

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }

    
    return hrRet;

} // CDVRRingBufferWriter::WriteSample

STDMETHODIMP CDVRRingBufferWriter::SetMaxStreamDelta(IN QWORD cnsMaxStreamDelta)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::SetMaxStreamDelta"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }

        if (!IsFlagSet(MaxStreamDeltaSet))
        {
            SetFlags(MaxStreamDeltaSet);
            m_nNotOkToWrite++;
        }

        m_cnsMaxStreamDelta = cnsMaxStreamDelta;

        hrRet = S_OK;
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::SetMaxStreamDelta

STDMETHODIMP CDVRRingBufferWriter::Close(void)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::Close"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;

        if (IsFlagSet(WriterClosed))
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_TRACE, 
                            "Writer already closed");

            hrRet = S_FALSE;
            __leave;
        }

        // Shut down any active recorder. Note that there
        // is at most one.
        // This step is not really necesssary, but it's
        // the clean way to do it.

        LIST_ENTRY* pCurrent;  

        if (m_nNotOkToWrite != MINLONG)
        {
            pCurrent = PREVIOUS_LIST_NODE(&m_leRecordersList);
            while (pCurrent != &m_leRecordersList)
            {
                PASF_RECORDER_NODE pRecorderNode = CONTAINING_RECORD(pCurrent, ASF_RECORDER_NODE, leListEntry);

                if (pRecorderNode->cnsEndTime == MAXQWORD &&
                    pRecorderNode->cnsStartTime < MAXQWORD)
                {
                    hr = StopRecording(pCurrent, 0, 1 /* = bNow */);
                    if (FAILED(hr))
                    {
                        // If this recording has not started yet, we
                        // expect StopRecording to fail.

                        // Note that the file collection object will think that
                        // this file extend to QWORD_INFINITE, that's ok.

                        DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                        "StopRecording on recorder id 0x%p failed",
                                        pCurrent);
                        // Go on
                        // hrRet = hr;
                        // break;
                    }
                    break;
                }
                pCurrent = PREVIOUS_LIST_NODE(pCurrent);
            }
        }

        // Don't allow any more writes. start/stop recording calls
        // regardless of whether this operation is successful
        m_nNotOkToWrite = MINLONG;

        // Note that some files following a recording may 
        // have start = end time = MAXQWORD, so that's
        // the only argument that we can send in here.
        //
        // The recorders list should be emptied by this call
        // once ProcessCloseRequest has completed for all the 
        // recorder files.
        //
        // hr on return will always be S_OK since failures are
        // skipped over.
        hr = CloseAllWriterFilesBefore(MAXQWORD);
        hrRet = hr;

        // @@@@ Should we return from this function at this point
        // if FAILED(hrRet)????

        // These lists should be empty by now.
        // Note: recording list empty does NOT mean that 
        // recorder nodes have been freed. Recorders that
        // have not called DeleteRecording have references
        // to these nodes and the nodes will be deleted
        // in DeleteRecording

        // Recording list may not be empty: if a recording was
        // created and never started, the recorder remains in 
        // the list. Note that the corresponding CDVRRecorder object
        // holds a ref count in the writer.
        // DVR_ASSERT(IsListEmpty(&m_leRecordersList), "");

        DVR_ASSERT(IsListEmpty(&m_leWritersList), "");

        // Delete all the writer nodes. However, this will not 
        // delete writer nodes corresponding to recorders that 
        // were not started - since those recordings have not
        // been closed. Those writer nodes are deleted in the
        // destructor.
        pCurrent = NEXT_LIST_NODE(&m_leFreeList);
        while (pCurrent != &m_leFreeList)
        {
            PASF_WRITER_NODE pFreeNode = CONTAINING_RECORD(pCurrent, ASF_WRITER_NODE, leListEntry);
            
            DVR_ASSERT(pFreeNode->hFileClosed, "");
            
            // Ignore the returned status
            ::WaitForSingleObject(pFreeNode->hFileClosed, INFINITE);
            DVR_ASSERT(pFreeNode->pRecorderNode == NULL, "");
            RemoveEntryList(pCurrent);
            delete pFreeNode;
            pCurrent = NEXT_LIST_NODE(&m_leFreeList);
        }
        
        // Note that we cannot delete the file collection object
        // here if we allow post recordings. Recorders may want
        // to Start/StopRecordings after Close and we have to have
        // the file collection object around to know if the 

        // Since these point to members of the file collection 
        // object and we are going to release that object here
        m_pcnsCurrentStreamTime = NULL;
        if (m_pnWriterHasBeenClosed)
        {
            ::InterlockedExchange(m_pnWriterHasBeenClosed, 1);
            m_pnWriterHasBeenClosed = NULL;
        }
        
        if (m_pDVRFileCollection)
        {
            m_pDVRFileCollection->Release();
            m_pDVRFileCollection = NULL;

            // Note that files (recordings or temp files) could have been added
            // to the file collection object beyond *m_pcnsCurrentStreamTime. 
            // They have all been closed and so are 0 length. This is a good
            // thing for recordings (permanent files). The reader will not be
            // able to seek to these files (since *m_pcnsCurrentStreamTime 
            // < the file's start time) 

        }

        if (m_pProfile)
        {
            m_pProfile->Release();
            m_pProfile = NULL;
        }

        SetFlags(WriterClosed);
        hrRet = S_OK;
    }
    __finally
    {
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::Close

STDMETHODIMP CDVRRingBufferWriter::CreateRecorder(
    IN  LPCWSTR        pwszDVRFileName, 
    IN  DWORD          dwReserved,
    OUT IDVRRecorder** ppDVRRecorder)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CreateRecorder"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = S_OK;
    WCHAR*  pwszFileName = NULL;

    if (!pwszDVRFileName || DvrIopIsBadStringPtr(pwszDVRFileName) ||
        !ppDVRRecorder || DvrIopIsBadWritePtr(ppDVRRecorder, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);
        
        if (ppDVRRecorder && !DvrIopIsBadWritePtr(ppDVRRecorder, 0))
        {
            *ppDVRRecorder = NULL;
        }

        return E_INVALIDARG;
    }

    *ppDVRRecorder = NULL;
    
    // Get fully qualified file name and verify that the file does not
    // exist

    DWORD dwLastError = 0;
    BOOL bRet = 0;

    __try
    {
        // Get fully qualified name of file.
        WCHAR wTempChar;
        DWORD nLen;

        nLen = ::GetFullPathNameW(pwszDVRFileName, 0, &wTempChar, NULL);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "First GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            __leave;
        }

        pwszFileName = new WCHAR[nLen+1];

        if (!pwszFileName)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, "alloc via new failed - WCHAR[%u]", nLen+1);
            __leave;
        }

        nLen = ::GetFullPathNameW(pwszDVRFileName, nLen+1, pwszFileName, NULL);
        if (nLen == 0)
        {
            dwLastError = ::GetLastError();
            DvrIopDebugOut2(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "Second GetFullPathNameW failed, nLen = %u, last error = 0x%x",
                            nLen, dwLastError);
            __leave;
        }

        // Verify that the file does not exist

        WIN32_FIND_DATA FindFileData;
        HANDLE hFind;

        hFind = ::FindFirstFileW(pwszFileName, &FindFileData);

        if (hFind != INVALID_HANDLE_VALUE) 
        {
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "File already exists");
            ::FindClose(hFind);
            dwLastError = ERROR_ALREADY_EXISTS;
            __leave;
        } 
        else 
        {
            dwLastError = ::GetLastError();
            if (dwLastError != ERROR_FILE_NOT_FOUND)
            {
                DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                                "FindFirstFile failed, last error = 0x%x",
                                dwLastError);
                __leave;
            }
            // File is not found; this is what we want
            dwLastError = 0;
        }
    }
    __finally
    {
        if (hrRet != S_OK || dwLastError != 0)
        {
            if (dwLastError != 0)
            {
                hrRet = HRESULT_FROM_WIN32(dwLastError);
            }
            DVRIO_TRACE_LEAVE1_HR(hrRet);
            delete [] pwszFileName;
            bRet = 1;
        }
    }
    if (bRet)
    {
        return hrRet;
    }

    DVR_ASSERT(hrRet == S_OK, "Should have returned on failure?!");

    PASF_RECORDER_NODE pRecorderNode = NULL;
    CDVRRecorder*      pRecorderInstance = NULL;
    LIST_ENTRY*        pWriter;

    hrRet = E_FAIL;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        HRESULT hr;
        
        if (m_nNotOkToWrite == MINLONG)
        {
            // We hit an irrecoverable error earlier
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "m_nNotOkToWrite is MINLONG.");

            hrRet = E_FAIL;
            __leave;
        }
    
        // Construct the class objects we need

        pRecorderNode = new ASF_RECORDER_NODE(pwszFileName, &hr);

        if (!pRecorderNode)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via new failed - ASF_RECORDER_NODE");
            __leave;
        }

        pwszFileName = NULL; // pRecorderNode's destuctor will delete it.

        if (FAILED(hr))
        {
            hrRet = hr;
            __leave;
        }
            
        pRecorderInstance = new CDVRRecorder(this, &pRecorderNode->leListEntry, &hr);
        if (!pRecorderInstance)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via new failed - CDVRRecorder");
            __leave;
        }

        // This is not addref'd; otherwise it would create a circular refcount
        pRecorderNode->SetRecorderInstance(pRecorderInstance);

        if (FAILED(hr))
        {
            // don't want this deleted since deleting pRecorderInstance
            // will call DeleteRecorder which will do this.
            pRecorderNode = NULL;
            hrRet = hr;
            __leave;
        }

        hr = PrepareAFreeWriterNode(pRecorderNode->pwszFileName, 
                                    pRecorderNode->cnsStartTime, // for consistency with info in pRecorderNode
                                    pRecorderNode->cnsEndTime,   // for consistency with info in pRecorderNode
                                    NULL,                        // pcnsFirstSampleTimeOffsetFromStartOfFile     
                                    CDVRFileCollection::DVRIOP_INVALID_FILE_ID, 
                                    pRecorderNode,
                                    pWriter);

        if (FAILED(hr))
        {
            // don't want this deleted since deleting pRecorderInstance
            // will call DeleteRecorder which will do this.
            pRecorderNode = NULL;
            hrRet = hr;
            __leave;
        }

        DVR_ASSERT(pWriter != NULL, "");

        pRecorderNode->SetWriterNode(CONTAINING_RECORD(pWriter, ASF_WRITER_NODE, leListEntry));

        // Insert into recorders list
        hr = AddToRecordersList(&pRecorderNode->leListEntry);

        if (FAILED(hr))
        {
            // This cannot happen since start = end time = MAXQWORD
            DVR_ASSERT(pRecorderNode->cnsStartTime == MAXQWORD, "");
            DVR_ASSERT(pRecorderNode->cnsEndTime == MAXQWORD, "");
            DVR_ASSERT(SUCCEEDED(hr), "AddToRecordersList failed?!");
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "AddToRecordersList failed");
            hrRet = hr;

            // don't want this deleted since deleting pRecorderInstance
            // will call DeleteRecorder which will do this.
            pRecorderNode = NULL;
            __leave;
        }

        // Wait for BeginWriting to finish - do this after releasing m_csLock
        // Note that if the client cannot delete this recorder since it does 
        // not yet have an IDVRRecorder for this recorder. Also CDVRRecorder has
        // a refcount on the ring buffer writer, so the ring buffer writer cannot
        // be destroyed. Calling Close will not change the recorders list.


        hrRet = S_OK;
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            delete [] pwszFileName;
            delete pRecorderNode;
            delete pRecorderInstance;
            DVRIO_TRACE_LEAVE1_HR(hrRet);
            bRet = 1;
        }

        ::LeaveCriticalSection(&m_csLock);
    }
    if (bRet)
    {
        return hrRet;
    }

    DVR_ASSERT(hrRet == S_OK, "");

    // Wait for BeginWriting to finish after releasing m_csLock
    DVR_ASSERT(pRecorderNode, "");
    DVR_ASSERT(pRecorderNode->pWriterNode, "");
    DVR_ASSERT(pRecorderNode->pWriterNode->hReadyToWriteTo, "");
    if (::WaitForSingleObject(pRecorderNode->pWriterNode->hReadyToWriteTo, INFINITE) == WAIT_FAILED)
    {
        DVR_ASSERT(0, "Writer node's WFSO(hReadyToWriteTo) failed");

        DWORD dwLastError = ::GetLastError();
        DvrIopDebugOut2(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                        "WFSO(hReadyToWriteTo) failed; hReadyToWriteTo = 0x%p, last error = 0x%x", 
                        pRecorderNode->pWriterNode->hReadyToWriteTo, dwLastError);
        hrRet = HRESULT_FROM_WIN32(dwLastError);
    }

    if (SUCCEEDED(hrRet))
    {
        // This value has been put there by ProcessOpenRequest

        hrRet = pRecorderNode->hrRet;
        if (FAILED(hrRet))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "ProcessOpenRequest/BeginWriting failed, hr = 0x%x", 
                            hrRet);
        }
    }

    if (SUCCEEDED(hrRet))
    {
        DVR_ASSERT(pRecorderInstance, "");
        hrRet = pRecorderInstance->QueryInterface(IID_IDVRRecorder, (void**) ppDVRRecorder);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(0, "QI for IID_IDVRRecorder failed");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "pRecorderInstance->QueryInterface failed, hr = 0x%x", 
                            hrRet);
        }
    }

    if (FAILED(hrRet))
    {
        // This will delete pRecorder as well
        
        pRecorderNode = NULL;
        delete pRecorderInstance;
        pRecorderInstance = NULL;
    }
    else if (dwReserved & DVRIO_PERSISTENT_RECORDING)
    {
        // Do this as the last step when we know we are going to return success
        pRecorderInstance->AddRef();
        pRecorderNode->SetFlags(ASF_RECORDER_NODE::PersistentRecording);
    }

    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // CDVRRingBufferWriter::CreateRecorder

STDMETHODIMP CDVRRingBufferWriter::CreateReader(OUT IDVRReader** ppDVRReader)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::CreateReader"

    DVRIO_TRACE_ENTER();

    if (!ppDVRReader || DvrIopIsBadWritePtr(ppDVRReader, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");
        DVRIO_TRACE_LEAVE1_HR(E_INVALIDARG);        
        return E_INVALIDARG;
    }

    // No need to lock. 

    // Note; If caller has this pointer, we should not be being destroyed
    // while this function runs. If we are, that's an error on the caller's
    // part (the pointer it has to this should be properly Addref'd). So the 
    // lock is not held just to guarantee we won't be destroyed during the 
    // call and the destructor does not grab the lock either.

    HRESULT                 hrRet;
    CDVRReader*             p;
    HKEY                    hDvrIoKey = NULL;
    HKEY                    hRegistryRootKey = NULL;
    BOOL                    bCloseKeys = 1; // Close all keys that we opened (only if this fn fails)


    *ppDVRReader = NULL;

    __try
    {
        DWORD dwRegRet;

        // Give the reader it's own handles so that they can be closed independently

        if (0 == ::DuplicateHandle(::GetCurrentProcess(), m_hRegistryRootKey,
                                   ::GetCurrentProcess(), (LPHANDLE) &hRegistryRootKey,
                                   0,       // desired access - ignored
                                   FALSE,   // bInherit
                                   DUPLICATE_SAME_ACCESS))
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "DuplicateHandle failed for DVR IO key, last error = 0x%x",
                            dwLastError);
            hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        dwRegRet = ::RegCreateKeyExW(
                        hRegistryRootKey,
                        kwszRegDvrIoReaderKey, // subkey
                        0,                   // reserved
                        NULL,                // class string
                        REG_OPTION_NON_VOLATILE, // special options
                        KEY_ALL_ACCESS,      // desired security access
                        NULL,                // security attr
                        &hDvrIoKey,          // key handle 
                        NULL                 // disposition value buffer
                       );
        if (dwRegRet != ERROR_SUCCESS)
        {
            DWORD dwLastError = ::GetLastError();
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_CLIENT_ERROR, 
                            "RegCreateKeyExW for DVR IO key failed, last error = 0x%x",
                            dwLastError);
           hrRet = HRESULT_FROM_WIN32(dwLastError);
            __leave;
        }

        p = new CDVRReader(m_pDVRFileCollection, 
                           m_pcnsCurrentStreamTime, 
                           m_pnWriterHasBeenClosed, 
                           hRegistryRootKey, 
                           hDvrIoKey,
                           &hrRet);

        if (p == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            DvrIopDebugOut0(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via new failed - CDVRReader");
            __leave;
        }

        bCloseKeys = 0; // ~CDVRReader will close the keys
        
        if (FAILED(hrRet))
        {
            __leave;
        }


        hrRet = p->QueryInterface(IID_IDVRReader, (void**) ppDVRReader);
        if (FAILED(hrRet))
        {
            DVR_ASSERT(0, "QI for IID_IDVRReader failed");
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "CDVRReader::QueryInterface failed, hr = 0x%x", 
                            hrRet);
            __leave;
        }
    }
    __finally
    {
        if (FAILED(hrRet))
        {
            delete p;

            if (bCloseKeys)
            {
                DWORD dwRegRet;

                if (hDvrIoKey)
                {
                    dwRegRet = ::RegCloseKey(hDvrIoKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hDvrIoKey failed.");
                    }
                }
                if (hRegistryRootKey)
                {
                    DVR_ASSERT(hRegistryRootKey, "");
                    dwRegRet = ::RegCloseKey(hRegistryRootKey);
                    if (dwRegRet != ERROR_SUCCESS)
                    {
                        DVR_ASSERT(dwRegRet == ERROR_SUCCESS,
                                   "Closing registry key hRegistryRootKey failed.");
                    }
                }
            }
        }
        else
        {
            DVR_ASSERT(bCloseKeys == 0, "");
        }
    }
    
    DVRIO_TRACE_LEAVE1_HR(hrRet);
    return hrRet;

} // CDVRRingBufferWriter::CreateReader

STDMETHODIMP CDVRRingBufferWriter::GetDVRDirectory(OUT LPWSTR* ppwszDirectoryName)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetDVRDirectory"

    DVRIO_TRACE_ENTER();

    HRESULT hrRet = E_FAIL;

    // We don;t need the critical section for this function since
    // m_pwszDVRDirectory is set in the constructor and not changed
    // after that. The caller should have an addref'd interface pointer
    // when calling this fn.

    __try
    {
        if (!ppwszDirectoryName)
        {
            hrRet = E_POINTER;
            __leave;
        }

        if (!m_pwszDVRDirectory)
        {
            DVR_ASSERT(m_pwszDVRDirectory, "");

            hrRet = E_FAIL;
            __leave;
        }
    
        DWORD nLen = (wcslen(m_pwszDVRDirectory) + 1) * sizeof(WCHAR);

        *ppwszDirectoryName = (LPWSTR) ::CoTaskMemAlloc(nLen);
        if (!(*ppwszDirectoryName))
        {
            DvrIopDebugOut1(DVRIO_DBG_LEVEL_INTERNAL_ERROR, 
                            "alloc via CoTaskMemAlloc failed - %d bytes", nLen);
            hrRet = E_OUTOFMEMORY;
            __leave;
        }
        wcscpy(*ppwszDirectoryName, m_pwszDVRDirectory);
    
        hrRet = S_OK;
    }
    __finally
    {
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::GetDVRDirectory

STDMETHODIMP CDVRRingBufferWriter::GetRecordings(OUT DWORD*   pdwCount,
                                                 OUT IDVRRecorder*** pppIDVRRecorder OPTIONAL,
                                                 OUT LPWSTR** pppwszFileName OPTIONAL,
                                                 OUT QWORD**  ppcnsStartTime OPTIONAL,
                                                 OUT QWORD**  ppcnsStopTime OPTIONAL,
                                                 OUT BOOL**   ppbStarted OPTIONAL)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetRecordings"

    DVRIO_TRACE_ENTER();

    if (!pdwCount || DvrIopIsBadWritePtr(pdwCount, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");        
        return E_POINTER;
    }
    if ((pppIDVRRecorder && DvrIopIsBadWritePtr(pppIDVRRecorder, 0)) ||
        (pppwszFileName && DvrIopIsBadWritePtr(pppwszFileName, 0)) ||
        (ppcnsStartTime && DvrIopIsBadWritePtr(ppcnsStartTime, 0)) ||
        (ppcnsStopTime && DvrIopIsBadWritePtr(ppcnsStopTime, 0)) ||
        (ppbStarted && DvrIopIsBadWritePtr(ppbStarted, 0)) 
       )
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");        
        return E_POINTER;
    }

    HRESULT hrRet = S_OK;

    IDVRRecorder** ppIDVRRecorder = NULL;
    LPWSTR*        ppwszFileName  = NULL;
    QWORD*         pcnsStartTime  = NULL;
    QWORD*         pcnsStopTime   = NULL;
    BOOL*          pbStarted      = NULL;
    DWORD          dwCount        = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        BOOL        bDone = 1;
        LIST_ENTRY* pCurrent;  

        // Determine number of recorders and the max file name len

        pCurrent = NEXT_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            dwCount++;
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }

        if (dwCount == 0)
        {
            __leave;
        }

        // Allocate memory

        if (pppIDVRRecorder)
        {
            ppIDVRRecorder = (IDVRRecorder**) ::CoTaskMemAlloc(dwCount * 
                                                               sizeof(IDVRRecorder *));
            if (!ppIDVRRecorder)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            ::ZeroMemory(ppIDVRRecorder, dwCount * sizeof(IDVRRecorder *));
            bDone = 0;
        }

        if (pppwszFileName)
        {
            ppwszFileName = (LPWSTR*) ::CoTaskMemAlloc(dwCount * sizeof(LPWSTR));
            if (!ppwszFileName)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            ::ZeroMemory(ppwszFileName, dwCount * sizeof(LPWSTR));
            bDone = 0;
        }

        if (ppcnsStartTime)
        {
            pcnsStartTime = (QWORD*) ::CoTaskMemAlloc(dwCount * sizeof(QWORD));
            if (!pcnsStartTime)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            bDone = 0;
        }

        if (ppcnsStopTime)
        {
            pcnsStopTime = (QWORD*) ::CoTaskMemAlloc(dwCount * sizeof(QWORD));
            if (!pcnsStopTime)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            bDone = 0;
        }

        if (ppbStarted)
        {
            pbStarted = (BOOL*) ::CoTaskMemAlloc(dwCount * sizeof(BOOL));
            if (!pbStarted)
            {
                hrRet = E_OUTOFMEMORY;
                __leave;
            }
            bDone = 0;
        }

        if (bDone)
        {
            __leave;
        }

        // Get the current stream time

        QWORD cnsStreamTime = MAXQWORD;

        if (pbStarted && !IsFlagSet(WriterClosed))
        {
            cnsStreamTime = *m_pcnsCurrentStreamTime;
        }

        // Copy over the info

        DWORD i = 0;

        pCurrent = NEXT_LIST_NODE(&m_leRecordersList);
        while (pCurrent != &m_leRecordersList)
        {
            PASF_RECORDER_NODE pRecorderNode = CONTAINING_RECORD(pCurrent, ASF_RECORDER_NODE, leListEntry);

            if (ppIDVRRecorder)
            {
                if (pRecorderNode->pRecorderInstance)
                {
                    HRESULT hr;
                    hr = pRecorderNode->pRecorderInstance->QueryInterface(IID_IDVRRecorder, 
                                                                          (void**) &ppIDVRRecorder[i]);
                    if (FAILED(hr))
                    {
                        hrRet = hr;
                        __leave;
                    }
                }
                else
                {
                    DVR_ASSERT(0, "");
                    hrRet = E_FAIL;
                    __leave;
                }
            }
            if (ppwszFileName)
            {
                DWORD nLen = pRecorderNode->pwszFileName? 1 + wcslen(pRecorderNode->pwszFileName) : 1;

                ppwszFileName[i] = (LPWSTR) ::CoTaskMemAlloc(nLen * sizeof(WCHAR));
                if (!ppwszFileName[i])
                {
                    hrRet = E_OUTOFMEMORY;
                    __leave;
                }

                if (pRecorderNode->pwszFileName)
                {
                    wcscpy(ppwszFileName[i], pRecorderNode->pwszFileName);
                }
                else
                {
                    // Should not happen
                    ppwszFileName[i][0] = L'\0';
                }
            }
            if (pcnsStartTime)
            {
                HRESULT hr;
                pcnsStartTime[i] = pRecorderNode->cnsStartTime;
            }
            if (pcnsStopTime)
            {
                HRESULT hr;
                pcnsStopTime[i] = pRecorderNode->cnsEndTime;
            }
            if (pbStarted)
            {
                if (IsFlagSet(WriterClosed) || pRecorderNode->cnsStartTime == MAXQWORD)
                {
                    // If the writer has been closed, the only nodes left in
                    // m_leRecordersList are the ones that have not been 
                    // started (including those whose start times were never set).
                    // Any node that had been started would have been closed when
                    // the writer was closed.

                    // This will change if we support ASX files

                    pbStarted[i] = 0;
                }
                else
                {
                    pbStarted[i] = cnsStreamTime >= pRecorderNode->cnsStartTime;
                }
            }
            i++;
            pCurrent = NEXT_LIST_NODE(pCurrent);
        }

        DVR_ASSERT(i == dwCount, "");

        hrRet = S_OK;

    }
    __finally
    {
        if (FAILED(hrRet))
        {
            for (DWORD i = 0; i < dwCount; i++)
            {
                if (ppIDVRRecorder && ppIDVRRecorder[i])
                {
                    ppIDVRRecorder[i]->Release();
                }
                if (ppwszFileName && ppwszFileName[i])
                {
                    ::CoTaskMemFree(ppwszFileName[i]);
                }
            }
            if (ppIDVRRecorder)
            {
                ::CoTaskMemFree(ppIDVRRecorder);
                ppIDVRRecorder = NULL;
            }
            if (ppwszFileName)
            {
                ::CoTaskMemFree(ppwszFileName);
                ppwszFileName = NULL;
            }
            if (pcnsStartTime)
            {
                ::CoTaskMemFree(pcnsStartTime);
                pcnsStartTime = NULL;
            }
            if (pcnsStopTime)
            {
                ::CoTaskMemFree(pcnsStopTime);
                pcnsStopTime = NULL;
            }
            if (pbStarted)
            {
                ::CoTaskMemFree(pbStarted);
                pbStarted = NULL;
            }
            dwCount = 0;
        }

        *pdwCount = dwCount;
        if (pppIDVRRecorder)
        {
            *pppIDVRRecorder = ppIDVRRecorder;
        }
        if (pppwszFileName)
        {
            *pppwszFileName = ppwszFileName;
        }
        if (ppcnsStartTime)
        {
            *ppcnsStartTime = pcnsStartTime;
        }
        if (ppcnsStopTime)
        {
            *ppcnsStopTime = pcnsStopTime;
        }
        if (ppbStarted)
        {
            *ppbStarted = pbStarted;
        }

        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::GetRecordings

STDMETHODIMP CDVRRingBufferWriter::GetStreamTime(OUT QWORD* pcnsStreamTime)
{
    #if defined(DVRIO_THIS_FN)
    #undef DVRIO_THIS_FN
    #endif // DVRIO_THIS_FN
    #define DVRIO_THIS_FN "CDVRRingBufferWriter::GetStreamTime"

    DVRIO_TRACE_ENTER();

    if (!pcnsStreamTime || DvrIopIsBadWritePtr(pcnsStreamTime, 0))
    {
        DvrIopDebugOut0(DVRIO_DBG_LEVEL_CLIENT_ERROR, "bad input argument");        
        return E_POINTER;
    }

    HRESULT hrRet = S_OK;
    QWORD cnsStreamTime = 0;

    ::EnterCriticalSection(&m_csLock);

    __try
    {
        // Get the current stream time


        if (!IsFlagSet(WriterClosed))
        {
            cnsStreamTime = *m_pcnsCurrentStreamTime;
        }
        else
        {
            hrRet = E_UNEXPECTED;
        }
    }
    __finally
    {
        if (SUCCEEDED(hrRet))
        {
            *pcnsStreamTime = cnsStreamTime;
        }
        ::LeaveCriticalSection(&m_csLock);
        DVRIO_TRACE_LEAVE1_HR(hrRet);
    }
    
    return hrRet;

} // CDVRRingBufferWriter::GetStreamTime
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrplay\dvrplayprop.cpp ===
#include "dvrall.h"

#include "DVRPlayres.h"       //  resource ids
#include "DVRPlayprop.h"

CDVRPlayProp::CDVRPlayProp (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage       (
            pClassName,
            pIUnknown,
            IDD_DVR_PLAY,
            IDS_DVR_PLAY_TITLE
            )
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRPlayProp")) ;
}

HRESULT
CDVRPlayProp::OnActivate (
    )
{
    return CBasePropertyPage::OnActivate () ;
}

HRESULT
CDVRPlayProp::OnApplyChanges (
    )
{
    return CBasePropertyPage::OnApplyChanges () ;
}

HRESULT
CDVRPlayProp::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    return CBasePropertyPage::OnConnect (pIUnknown) ;
}

HRESULT
CDVRPlayProp::OnDeactivate (
    )
{
    return CBasePropertyPage::OnDeactivate () ;
}

HRESULT
CDVRPlayProp::OnDisconnect (
    )
{
    return CBasePropertyPage::OnDisconnect () ;
}

INT_PTR
CDVRPlayProp::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    return CBasePropertyPage::OnReceiveMessage (hwnd, uMsg, wParam, lParam) ;
}

CUnknown *
WINAPI
CDVRPlayProp::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CDVRPlayProp *  pProp ;

    pProp = new CDVRPlayProp (
                        NAME ("CDVRPlayProp"),
                        pIUnknown,
                        CLSID_DVRPlayProp,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrplay\dvrplayprop.h ===
#ifndef __dvrplayprop_h
#define __dvrplayprop_h

class CDVRPlayProp :
    public CBasePropertyPage
{
    public :

        CDVRPlayProp (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        ~CDVRPlayProp (
            )
        {
            TRACE_DESTRUCTOR (TEXT ("CDVRPlayProp")) ;
        }

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        INT_PTR
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

#endif  //  __dvrplayprop_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dll\dvrprop.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrprop.cpp

    Abstract:

        This module contains dvr property pages DLL declarations

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        18-Mar-01       created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <tchar.h>
#include <limits.h>

//  dshow
#include <streams.h>
#include <dvdmedia.h>       //  MPEG2VIDEOINFO

//  WMSDK
#include <wmsdk.h>

#include "dvrdef.h"
#include "dvrfor.h"
#include "dvrtrace.h"
#include "dvrmacros.h"
#include "dvrioidl.h"

//  link in CLSIDs
#include <initguid.h>
#include "dvrds.h"
#include "dvrdspriv.h"
#include "dvranalysis.h"
#include "dvrioidl.h"
#include "MultiGraphHost.h"


//  DVRStreamSink prop
#include "commctrl.h"
#include "uictrl.h"
#include "DVRSinkProp.h"

//  DVRStreamSource prop
#include "DVRSourceProp.h"

//  DVRPlay prop
#include "DVRPlayProp.h"

//  registration templates
CFactoryTemplate
g_Templates[] = {
    //  ========================================================================
    //  DVRSource filter property pages
    //  code in ..\dvrsource
    {   L"DVRSource Prop",                          //  display name
        & CLSID_DVRStreamSourceProp,                //  CLSID
        CDVRSourceProp::CreateInstance,             //  CF CreateInstance method
        NULL,                                       //
        NULL                                        //  not dshow related
    },

    //  ========================================================================
    //  DVRSink filter property pages
    //  code in ..\dvrsink
    {   L"DVRSink Prop",                            //  display name
        & CLSID_DVRStreamSinkProp,                  //  CLSID
        CDVRSinkProp::CreateInstance,               //  CF CreateInstance method
        NULL,                                       //
        NULL                                        //  not dshow related
    },

    //  ========================================================================
    //  DVRPlay filter property pages
    //  code in ..\dvrplay
    {   L"DVRPlay Prop",                            //  display name
        & CLSID_DVRPlayProp,                        //  CLSID
        CDVRPlayProp::CreateInstance,               //  CF CreateInstance method
        NULL,                                       //
        NULL                                        //  not dshow related
    },
} ;

int g_cTemplates = NUMELMS(g_Templates);

//
// DllRegisterSever
//
// Handle the registration of this filter
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2 (TRUE);
}

//
// DllUnregsiterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2 (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrplay\dvrplayres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dvrsource.rc
//
#define IDS_DVR_PLAY_TITLE              1201
#define IDD_DVR_PLAY                    1202

#define IDC_DVR_PLAY_FILENAME           1203
#define IDC_DVR_PLAY_OPEN_FILE          1204

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1205
#define _APS_NEXT_COMMAND_VALUE         12061
#define _APS_NEXT_CONTROL_VALUE         1207
#define _APS_NEXT_SYMED_VALUE           1208
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrsink\dvrsinkprop.cpp ===
#include "dvrall.h"

#include "MultiGraphHost.h"
#include "dvrsinkres.h"       //  resource ids
#include "commctrl.h"
#include "uictrl.h"
#include "dvrsinkprop.h"


const LPCWSTR kszMsgBoxTitle = TEXT("DVR Stream Sink");
const LPCWSTR kszLockFailedMsg = TEXT("Failed to lock the stream sink filter");


typedef
struct {
    WCHAR * szTitle ;
    DWORD   dwWidth ;
} COL_DETAIL ;

#define LV_COL(title, width)  { L#title, (width) }

//  ============================================================================
//  ============================================================================

static enum {
    RECORDING_FILENAME,
    RECORDING_START,
    RECORDING_STOP,
    RECORDING_STATE,

    RECORDING_COL_COUNT     //  always last
} ;

static COL_DETAIL
g_DVRRecordingsLV [] = {
    LV_COL  (Filename,  92),
    LV_COL  (Start,     40),
    LV_COL  (Stop,      40),
    LV_COL  (State,     45)
} ;

enum {
    START_REC_PRESET_START  = 0,
    START_REC_PRESET_STEP   = 15*60,    // 15 minutes
    START_REC_PRESET_MAX    = 120*60,   // 2 hours

    STOP_REC_PRESET_START   = 30*60,
    STOP_REC_PRESET_STEP    = 15*60,
    STOP_REC_PRESET_MAX     = 180*60,
} ;

enum {
    REC_STATE_NOT_STARTED = 0,
    REC_STATE_READY     = 1,    // Scheduled - start time set
    REC_STATE_STARTED   = 2,    // active - started recording
    REC_STATE_STOPPED   = 3,    // done - successfullt
    REC_STATE_FAILED    = 4,    // done - failure
} ;

WCHAR* kwszStateText[] = {
    L"Created",
    L"Scheduled",
    L"In progress",
    L"Done",
    L"Failed"
};


class CListData {
public:
    DWORD               m_nState;

    // When we create the recording, m_pIRecControl is not NULL.
    // If we close the property page dialog or tab out of the page,
    // m_pIRecControl is released. When we recreate the page, we
    // query for the list of recordings and m_pDVRRecorder is non-NULL
    // but m_pIRecControl is NULL.
    //
    // If the recording was not created by the property page, m_pIRecControl will
    // be NULl and m_pDVRRecorder will be non NULL. Note that the property page
    // does not refresh itself to display recordings that were not created by it
    // while it is being displayed (tab out and back in or close/open the box to
    // get the new list).
    IDVRRecordControl*  m_pIRecControl;
    IDVRRecorder*       m_pDVRRecorder;

    CListData(DWORD nState, IDVRRecordControl* pRecControl, IDVRRecorder *pDVRRecorder)
    {
        m_pIRecControl = pRecControl;
        m_pDVRRecorder = pDVRRecorder;
        m_nState = nState;
    }
    ~CListData()
    {
        if (m_pIRecControl)
        {
            m_pIRecControl -> Release () ;
        }
        if (m_pDVRRecorder)
        {
            m_pDVRRecorder -> Release () ;
        }
    }
};

enum {
    CAP_GRAPH_ACTIVE_SEC_TIMER      = 1,
    CAP_GRAPH_UPDATE_FREQ_MILLIS    = 1000,     //  millis
} ;

static 
void 
Format (WCHAR* buf, QWORD t, BOOL bDisplayMillis)
{
    t /= 10000;   // Convert to msec

    int sec = (int) (t/1000);
    int msec = (int) (t - 1000*sec);
    int hr = sec/3600;
    int min = (sec - hr*3600)/60;
    sec = sec - hr*3600 - min*60;

    if (bDisplayMillis)
    {
        wsprintfW(buf, L"%02d:%02d:%02d.%03d", hr, min, sec, msec);
    }
    else
    {
        wsprintfW(buf, L"%02d:%02d:%02d", hr, min, sec);
    }

}

static 
void 
Parse (WCHAR* buf, int* t)
{
    *t = -1;

    WCHAR* cp = buf + wcslen(buf) - 1;
    WCHAR *psec = NULL; 
    WCHAR *pmin = NULL;
    WCHAR *phr  = NULL;

    for (; cp >= buf; cp--)
    {
        if (*cp == L':')
        {
            if (!psec)
            {
                psec = cp + 1;
            }
            else if (!pmin)
            {
                pmin = cp + 1;
            }
            else
            {
                // Error
                return;
            }
        }
        else if ( *cp < L'0' || *cp > L'9')
        {
            return;
        }
    }
    if (!psec)
    {
        psec = cp + 1;
    }
    else if (!pmin)
    {
        pmin = cp + 1;
    }
    else if (!phr)
    {
        phr = cp + 1;
    }

    int seconds = 0;
    int n;

    if (psec)
    {
        swscanf(psec, L"%d", &n);
        seconds += n;
    }
    if (pmin)
    {
        swscanf(pmin, L"%d", &n);
        seconds += 60*n;
    }
    if (phr)
    {
        swscanf(phr, L"%d", &n);
        seconds += 3600* n;
    }

    *t = seconds;
}

static
void
MessageBoxError (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK | MB_ICONEXCLAMATION) ;
}

HRESULT
CDVRSinkProp::InitRecordingsLV_ (
    )
{
    HIMAGELIST  himlSmallState ;
    HICON       hicon ;
    int         i ;
    DWORD       dw ;
    HRESULT     hr = S_OK ;

    ASSERT (m_pLVRecordings) ;

    for (i = 0; i < RECORDING_COL_COUNT; i++) 
    {
        RECT r = {0, 0, g_DVRRecordingsLV [i].dwWidth, 1};

        MapDialogRect(m_hwnd, &r);

        m_pLVRecordings -> InsertColumnW (
            g_DVRRecordingsLV [i].szTitle,
            r.right,
            i
            ) ;
    }

    himlSmallState = ImageList_Create (16, 16, ILC_COLORDDB | ILC_MASK, 1, 0) ;
    if (himlSmallState) {

        hicon = (HICON) LoadImage (g_hInst, MAKEINTRESOURCE (IDI_READY_REC), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR) ;
        ImageList_AddIcon (himlSmallState, hicon) ;
        hicon = (HICON) LoadImage (g_hInst, MAKEINTRESOURCE (IDI_ACTIVE_REC), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR) ;
        ImageList_AddIcon (himlSmallState, hicon) ;
        hicon = (HICON) LoadImage (g_hInst, MAKEINTRESOURCE (IDI_DONE_REC), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR) ;
        ImageList_AddIcon (himlSmallState, hicon) ;
        hicon = (HICON) LoadImage (g_hInst, MAKEINTRESOURCE (IDI_FAILED_REC), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR) ;
        ImageList_AddIcon (himlSmallState, hicon) ;

        m_pLVRecordings -> SetImageList_State (himlSmallState) ;
    }
    else {
        dw = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dw) ;
    }

    return hr ;
}

HRESULT
CDVRSinkProp::RefreshRecordings ()
{
    if (!m_pLVRecordings)
    {
        return E_FAIL;
    }
    
    ReleaseAllRecordings_();
    
    if (!m_pRingBuffer)
    {
        return S_OK;
    }

    DWORD    dwCount;
    IDVRRecorder** ppIDVRRecorder;
    LPWSTR*  ppwszFileName;
    QWORD*   pcnsStartTime;
    QWORD*   pcnsStopTime;
    BOOL*    pbStarted;

    // This returns only recordings that have not completed.
    // If a recording failed (write or closing the file failed),
    // while the prop page was nto displayed, we won't know about it.
    HRESULT hr = m_pRingBuffer->GetRecordings(&dwCount,
                                    &ppIDVRRecorder,
                                    &ppwszFileName,
                                    &pcnsStartTime,
                                    &pcnsStopTime,
                                    &pbStarted);
    if (FAILED(hr) || dwCount == 0)
    {
        return hr;
    }

    WCHAR achBuffer[32];

    for (DWORD i = 0; i < dwCount; i++)
    {
        int row = m_pLVRecordings -> InsertRowTextW (
                    ppwszFileName[i],
                    RECORDING_FILENAME,
                    m_pLVRecordings -> GetItemCount()
                    ) ;
        if (row != -1) {
            CListData* p = new CListData(pbStarted[i]? REC_STATE_STARTED : 
                                         (pcnsStartTime[i] != MAXQWORD? REC_STATE_READY : REC_STATE_NOT_STARTED),
                                         NULL,
                                         ppIDVRRecorder[i]);

            if (!p)
            {
                m_pLVRecordings -> DeleteRow (row) ;
                hr = E_OUTOFMEMORY ;
                ppIDVRRecorder[i]->Release();
            }
            else
            {
                if (pcnsStartTime[i] != MAXQWORD)
                {
                    if (pcnsStartTime[i] > MAXLONGLONG)
                    {
                        pcnsStartTime[i] = MAXLONGLONG;
                    }
                    Format(achBuffer, pcnsStartTime[i], FALSE);
                    m_pLVRecordings -> SetTextW (achBuffer, row, RECORDING_START) ;
                }
                if (pcnsStopTime[i] != MAXQWORD)
                {
                    if (pcnsStopTime[i] > MAXLONGLONG)
                    {
                        pcnsStopTime[i] = MAXLONGLONG;
                    }
                    Format(achBuffer, pcnsStopTime[i], FALSE);
                    m_pLVRecordings -> SetTextW (achBuffer, row, RECORDING_STOP) ;
                }

                m_pLVRecordings -> SetData ((DWORD_PTR) p, row) ;
                m_pLVRecordings -> SetState (p->m_nState, row, RECORDING_STATE, kwszStateText[p->m_nState]) ;
            }
        }
        else {
            DWORD dw = GetLastError () ;
            hr = HRESULT_FROM_WIN32 (dw) ;
            ppIDVRRecorder[i]->Release();
        }

        CoTaskMemFree(ppwszFileName[i]);
    }

    CoTaskMemFree(ppIDVRRecorder);
    CoTaskMemFree(ppwszFileName);
    CoTaskMemFree(pcnsStartTime);
    CoTaskMemFree(pcnsStopTime);
    CoTaskMemFree(pbStarted);

    return S_OK;
}

HRESULT
CDVRSinkProp::InitCombo_ (
    IN  DWORD   dwId,
    IN  int     iStart,
    IN  int     iMax,
    IN  int     iStep
    )
{
    CCombobox   Combo (m_hwnd, dwId) ;
    int         i ;
    WCHAR       buf[32] ;

    for (i = iStart;
         i <= iMax;
         i += iStep) 
    {
         Format (buf, SecondsToDShowTime(i), FALSE);
         Combo.AppendW (buf) ;
    }

    Combo.SetCurSelected (0) ;

    return S_OK ;
}

void
CDVRSinkProp::ReleaseAllRecordings_ (
    )
{
    if (m_pLVRecordings) {
        while (m_pLVRecordings -> GetItemCount () > 0) {
            CListData* p = reinterpret_cast <CListData *> (m_pLVRecordings -> GetData (0)) ;
            delete p;
            m_pLVRecordings -> DeleteRow (0) ;
        }
    }
}

void
CDVRSinkProp::CreateRecording (
    )
{
    WCHAR               achFilename [MAX_PATH] ;
    WCHAR               achFullFilename [MAX_PATH] ;
    IUnknown *          punkRecorder ;
    int                 i ;
    HRESULT             hr ;
    IDVRRecordControl * pIRecControl ;
    int                 row ;
    DWORD               dw ;

    if (!m_pDVRStreamSink) 
    {
        MessageBoxError (
            TEXT ("Create Recording"),
            TEXT ("Failed to create recording - internal error.")
            ) ;
        return;
    }

    hr = CheckProfileLocked();
    if (FAILED(hr))
    {
        MessageBoxError (
            TEXT ("Create Recording"),
            TEXT ("Failed to lock profile; hr = %08xh"),
            hr
            ) ;
        return;
    }
    else if (hr == S_FALSE)
    {
        return;
    }

    i = GetWindowTextW (GetDlgItem(m_hwnd, IDC_REC_FILENAME), achFilename, MAX_PATH - 1) ;
    if (i > 0) {

        achFilename [i] = L'\0' ;
        if (!GetFullPathNameW(achFilename, sizeof(achFullFilename)/sizeof(WCHAR), achFullFilename, NULL))
        {
            wcscpy(achFullFilename, achFilename);
        }

        hr = m_pDVRStreamSink -> CreateRecorder (achFullFilename, 1 /* persistent */, & punkRecorder ) ;
        if (SUCCEEDED (hr)) {
            hr = punkRecorder -> QueryInterface (IID_IDVRRecordControl, (void **) & pIRecControl) ;
            if (SUCCEEDED (hr)) {
                row = m_pLVRecordings -> InsertRowTextW (
                        achFullFilename,
                        RECORDING_FILENAME,
                        m_pLVRecordings -> GetItemCount()
                        ) ;
                if (row != -1) {
                    CListData* p = new CListData(REC_STATE_NOT_STARTED, pIRecControl, NULL);
                    if (!p)
                    {
                        m_pLVRecordings -> DeleteRow (row) ;
                        hr = E_OUTOFMEMORY ;
                    }
                    else
                    {
                        m_pLVRecordings -> SetData ((DWORD_PTR) p, row) ;
                        pIRecControl -> AddRef () ;     //  listview's

                        m_pLVRecordings -> SetState (REC_STATE_NOT_STARTED, row, RECORDING_STATE, kwszStateText[REC_STATE_NOT_STARTED]) ;
                        m_pLVRecordings -> SetRowSelected ( row, TRUE ) ;
                    }
                }
                else {
                    dw = GetLastError () ;
                    hr = HRESULT_FROM_WIN32 (dw) ;
                }

                pIRecControl -> Release () ;
            }

            punkRecorder -> Release () ;
        }

        if (FAILED (hr)) {
            MessageBoxError (
                TEXT ("Create Recording"),
                TEXT ("Failed to create a recording for %s\n")
                TEXT ("hr = %08xh"),
                achFullFilename,
                hr
                ) ;
        }
    }
    else {
        MessageBoxError (
            TEXT ("Create Recording"),
            TEXT ("No recording filename was specified.")
            ) ;
    }
}

void
CDVRSinkProp::StopRecordingSelected (
    )
{
    HRESULT             hr ;
    IDVRRecordControl * pIRecControl ;
    IDVRRecorder *      pDVRRecorder;
    CCombobox           ComboStopTime (m_hwnd, IDC_STOP_ABS_SEC) ;
    WCHAR               achBuffer [32] ;
    int                 iStop ;
    int                 iRow ;

    hr = CheckProfileLocked();
    if (FAILED(hr))
    {
        MessageBoxError (
            TEXT ("Create Recording"),
            TEXT ("Failed to lock profile; hr = %08xh"),
            hr
            ) ;
        return;
    }
    else if (hr == S_FALSE)
    {
        return;
    }
 
    iRow = m_pLVRecordings -> GetSelectedRow () ;
    if (iRow != -1) {

        pIRecControl = (reinterpret_cast <CListData *> (m_pLVRecordings -> GetData (iRow))) -> m_pIRecControl;
        pDVRRecorder = (reinterpret_cast <CListData *> (m_pLVRecordings -> GetData (iRow))) -> m_pDVRRecorder;
        ASSERT (pIRecControl || pDVRRecorder) ;

        if (ComboStopTime.GetTextW (achBuffer, 32) > 0) {
            Parse (achBuffer, & iStop) ;
            if (iStop >= 0)
            {
                if (pIRecControl)
                {
                    hr = pIRecControl -> Stop (SecondsToDShowTime ((DWORD) iStop)) ;
                }
                else
                {
                    hr = pDVRRecorder -> StopRecording (SecondsToDShowTime ((DWORD) iStop)) ;
                }
                if (SUCCEEDED (hr)) {
                    Format(achBuffer, SecondsToDShowTime(iStop), FALSE);
                    m_pLVRecordings -> SetTextW (achBuffer, iRow, RECORDING_STOP) ;

                }
                else {
                    MessageBoxError (
                        TEXT ("Stop Recording"),
                        TEXT ("hr = %08xh"),
                        hr
                        ) ;
                }
            }
            else {
                MessageBoxError (
                    TEXT ("Stop Recording"),
                    TEXT ("Stop time invalid")
                    ) ;
            }
        }
        else {
            MessageBoxError (
                TEXT ("Stop Recording"),
                TEXT ("No stop time specified")
                ) ;
        }
    }
    else {
        MessageBoxError (
            TEXT ("Stop Recording"),
            TEXT ("No Recording is selected")
            ) ;
    }
}

void
CDVRSinkProp::StartRecordingSelected (
    )
{
    HRESULT             hr ;
    IDVRRecordControl * pIRecControl ;
    IDVRRecorder *      pDVRRecorder;
    CCombobox           ComboStartTime (m_hwnd, IDC_START_ABS_SEC) ;
    WCHAR               achBuffer [32] ;
    int                 iStart ;
    int                 iRow ;

    hr = CheckProfileLocked();
    if (FAILED(hr))
    {
        MessageBoxError (
            TEXT ("Create Recording"),
            TEXT ("Failed to lock profile; hr = %08xh"),
            hr
            ) ;
        return;
    }
    else if (hr == S_FALSE)
    {
        return;
    }

    iRow = m_pLVRecordings -> GetSelectedRow () ;
    if (iRow != -1) {

        CListData* pListData = reinterpret_cast <CListData *> (m_pLVRecordings -> GetData (iRow));
        pIRecControl = pListData -> m_pIRecControl ;
        pDVRRecorder = pListData -> m_pDVRRecorder;
        ASSERT (pIRecControl || pDVRRecorder) ;

        if (ComboStartTime.GetTextW (achBuffer, 32) > 0) {
            Parse (achBuffer, & iStart) ;
            if (iStart >= 0)
            {
                if (pIRecControl)
                {
                    hr = pIRecControl -> Start (SecondsToDShowTime ((DWORD) iStart)) ;
                }
                else
                {
                    hr = pDVRRecorder -> StartRecording (SecondsToDShowTime ((DWORD) iStart)) ;
                }
                if (SUCCEEDED (hr)) {
                    Format(achBuffer, SecondsToDShowTime(iStart), FALSE);
                    m_pLVRecordings -> SetTextW (achBuffer, iRow, RECORDING_START) ;
                    pListData -> m_nState = REC_STATE_READY;
                    m_pLVRecordings -> SetState (REC_STATE_READY, iRow, RECORDING_STATE, kwszStateText[REC_STATE_READY]) ;

                }
                else {
                    MessageBoxError (
                        TEXT ("Start Recording"),
                        TEXT ("hr = %08xh"),
                        hr
                        ) ;
                }
            }
            else {
                MessageBoxError (
                    TEXT ("Start Recording"),
                    TEXT ("Start time invalid")
                    ) ;
            }
        }
        else {
            MessageBoxError (
                TEXT ("Start Recording"),
                TEXT ("No start time specified")
                ) ;
        }
    }
    else {
        MessageBoxError (
            TEXT ("Start Recording"),
            TEXT ("No Recording is selected")
            ) ;
    }
}

CDVRSinkProp::CDVRSinkProp (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage       (
            pClassName,
            pIUnknown,
            IDD_DVR_SINK,
            IDS_DVR_SINK_TITLE
            )
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRSinkProp")) ;
    m_pDVRStreamSink = NULL ;
    m_pGraphHost = NULL ;
    m_pLVRecordings = NULL ;
    m_pRingBuffer = NULL;
}

HRESULT
CDVRSinkProp::OnActivate (
    )
{
    HRESULT  hr ;
    
    if (m_pDVRStreamSink)
    {
        hr = m_pDVRStreamSink->IsProfileLocked();
    }
    else
    { 
        hr = E_FAIL ;
    }

    ShowWindow(GetDlgItem(m_hwnd, IDC_LOCKED), hr == S_OK? SW_SHOW : SW_HIDE); 

    ShowWindow(GetDlgItem(m_hwnd, IDC_VIEW_DVRSTREAMSOURCE), m_pGraphHost? SW_SHOW : SW_HIDE); 
    ShowWindow(GetDlgItem(m_hwnd, IDC_REC_VIEW), m_pGraphHost? SW_SHOW : SW_HIDE); 

    if (!m_pGraphHost)
    {
        RECT r = {3, 0, 45, 30};

        MapDialogRect(m_hwnd, &r);

        MoveWindow(GetDlgItem(m_hwnd, IDC_BROADCAST), r.left, r.top, r.right, r.bottom, TRUE);
    }

    m_pLVRecordings = new CListview (m_hwnd, IDC_REC_LIST) ;

    if (m_pLVRecordings == NULL) 
    {
        DWORD dw = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dw) ;
    }
    else
    {
      hr = InitRecordingsLV_ () ;
      if (SUCCEEDED(hr))
      {
          RefreshRecordings () ;
      }
    }

    hr = InitCombo_ (IDC_START_ABS_SEC, START_REC_PRESET_START, START_REC_PRESET_MAX, START_REC_PRESET_STEP) ;

    hr = InitCombo_ (IDC_STOP_ABS_SEC, STOP_REC_PRESET_START, STOP_REC_PRESET_MAX, STOP_REC_PRESET_STEP) ;

    SetTimer (m_hwnd, CAP_GRAPH_ACTIVE_SEC_TIMER, CAP_GRAPH_UPDATE_FREQ_MILLIS, NULL) ;

    return CBasePropertyPage::OnActivate () ;
}

HRESULT
CDVRSinkProp::OnApplyChanges (
    )
{
    return CBasePropertyPage::OnApplyChanges () ;
}

HRESULT
CDVRSinkProp::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    HRESULT hr = pIUnknown -> QueryInterface (IID_IDVRStreamSink, (void **) &m_pDVRStreamSink) ;
    
    if (FAILED(hr)) 
    {
        return hr;
    }

    IDVRStreamSinkPriv * pDVRStreamSinkPriv;

    hr = m_pDVRStreamSink -> QueryInterface (IID_IDVRStreamSinkPriv, (void **) &pDVRStreamSinkPriv) ;
    if (SUCCEEDED(hr)) 
    {
        hr = pDVRStreamSinkPriv->GetDVRRingBufferWriter(&m_pRingBuffer);
        if (FAILED(hr)) 
        {
            m_pRingBuffer = NULL;
        }
        pDVRStreamSinkPriv->Release();
    }
    else
    {
        m_pRingBuffer = NULL;
    }

    IBaseFilter * pFilter ;
    HRESULT hrTmp = pIUnknown -> QueryInterface (IID_IBaseFilter, (void **) &pFilter) ;
    
    if (FAILED(hrTmp)) 
    {
        return CBasePropertyPage::OnConnect (pIUnknown) ;
    }

    FILTER_INFO FilterInfo;

    hrTmp = pFilter -> QueryFilterInfo(&FilterInfo) ;
    pFilter -> Release() ;
    if (FAILED(hrTmp)) 
    {
        return CBasePropertyPage::OnConnect (pIUnknown) ;
    }

    IFilterGraph* pGraph = FilterInfo.pGraph;

    if (!pGraph)
    {
        return CBasePropertyPage::OnConnect (pIUnknown) ;
    }

    IServiceProvider * pSvcProvider ;
    IMultiGraphHost *  pSvc ;

    hrTmp = pGraph -> QueryInterface (
                            IID_IServiceProvider,
                            (void **) & pSvcProvider
                            ) ;
    pGraph -> Release () ;
    if (FAILED (hrTmp))
    {
        return CBasePropertyPage::OnConnect (pIUnknown) ;
    }

    hrTmp = pSvcProvider -> QueryService (
                                GUID_MultiGraphHostService,
                                IID_IMultiGraphHost,
                                (void **) & pSvc
                                ) ;
    pSvcProvider -> Release () ;

    if (FAILED (hrTmp))
    {
        return CBasePropertyPage::OnConnect (pIUnknown) ;
    }

    m_pGraphHost = pSvc;

    return CBasePropertyPage::OnConnect (pIUnknown) ;
}

void
CDVRSinkProp::DeactivatePriv ()
{
    BOOL bWarn;

    KillTimer (m_hwnd, CAP_GRAPH_ACTIVE_SEC_TIMER) ;
    
    ReleaseAllRecordings_ () ;

    delete m_pLVRecordings ;
    m_pLVRecordings = NULL ;
}

HRESULT
CDVRSinkProp::OnDeactivate (
    )
{
    DeactivatePriv();
    return CBasePropertyPage::OnDeactivate () ;
}

HRESULT
CDVRSinkProp::OnDisconnect (
    )
{
    // OnDeactivate is not called if the property sheet dialog
    // is closed; it is called only when tabbing out of the property
    // sheet to another prop sheet
    //
    // Note also that if the dialog is displayed, and closed by clicking the
    // on the close button on the dialog frame, OnDisconnect is not called.
    // It is called only when the prop sheet is displayed again (in this case,
    // a new prop sheet is created after OnDisconnect is called and the old
    // property sheet is destroyed), or when the filter is destroyed (either
    // it is deleted from the graph or ther grpah is destroyed.) (All this 
    // was observed with graphedt and may just be the way graphedt does things.)
    //
    DeactivatePriv();

    if (m_pRingBuffer)
    {
        m_pRingBuffer -> Release() ;
    }
    m_pRingBuffer = NULL ;

    if (m_pDVRStreamSink)
    {
        m_pDVRStreamSink -> Release() ;
    }
    m_pDVRStreamSink = NULL ;

    if (m_pGraphHost )
    {
        m_pGraphHost -> Release () ;
    }
    m_pGraphHost = NULL ;
    return CBasePropertyPage::OnDisconnect () ;
}

INT_PTR
CDVRSinkProp::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    HRESULT hr = E_FAIL;

    switch (uMsg)
    {
        case WM_TIMER :
        {
            if (wParam == CAP_GRAPH_ACTIVE_SEC_TIMER) {
                UpdateCapGraphActiveSec_ () ;
            }
            break ;
        }

        case WM_DESTROY:
        {
            ReleaseAllRecordings_();
            break;
        }

        case WM_COMMAND :
        {
            switch (LOWORD (wParam)) 
            {
                case IDC_LOCK_DVRSTREAMSINK :
                    if (m_pDVRStreamSink)
                    {
                        hr = m_pDVRStreamSink->LockProfile();
                        if (SUCCEEDED(hr))
                        {
                            ShowWindow(GetDlgItem(hwnd, IDC_LOCKED), SW_SHOW); 
                        }
                        else
                        {
                            ::MessageBoxW(hwnd, kszLockFailedMsg, kszMsgBoxTitle, MB_OK | MB_ICONEXCLAMATION);      
                        }

                    }
                    hr = S_OK;
                    break ;

                case IDC_VIEW_DVRSTREAMSOURCE :
                    CreateLiveGraph();
                    hr = S_OK ;
                    break;

                case IDC_REC_VIEW :
                    CreateRecGraph();
                    hr = S_OK ;
                    break;

                case IDC_REC_CREATE :
                    CreateRecording () ;
                    break ;

                case IDC_REC_START :
                    StartRecordingSelected () ;
                    break ;

                case IDC_REC_STOP :
                    StopRecordingSelected () ;
                    break ;
            }
            if (SUCCEEDED(hr))
            {
                return TRUE;
            }
            break;

        }
    }

    return CBasePropertyPage::OnReceiveMessage (hwnd, uMsg, wParam, lParam) ;
}

CUnknown *
WINAPI
CDVRSinkProp::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CDVRSinkProp *  pProp ;

    pProp = new CDVRSinkProp (
                        NAME ("CDVRSinkProp"),
                        pIUnknown,
                        CLSID_DVRStreamSinkProp,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}

HRESULT 
CDVRSinkProp::CheckProfileLocked ()
{
    HRESULT hr = m_pDVRStreamSink->IsProfileLocked();

    if (FAILED(hr))
    {
        return hr;
    }

    if (hr == S_FALSE)
    {
        int id = ::MessageBox(m_hwnd, 
                              TEXT("The stream sink filter must be locked first.\nLock it now?"), 
                              kszMsgBoxTitle, 
                              MB_YESNO | MB_ICONQUESTION);

        if (id == IDNO)
        {
            return S_FALSE;
        }
        hr = m_pDVRStreamSink->LockProfile();
        if (SUCCEEDED(hr))
        {
            ShowWindow(GetDlgItem(m_hwnd, IDC_LOCKED), SW_SHOW); 
        }
    }
    return S_OK;
}

void
CDVRSinkProp::UpdateCapGraphActiveSec_ (
    )
{
    WCHAR   ach [32] ;
    HRESULT hr;

    IDVRStreamSinkPriv * pDVRStreamSinkPriv;
    IDVRRingBufferWriter*  pRingBuffer;

    // The ring buffer can change while we are displayed. This will seldom
    // happen, but can happen if the writer is locked while the prop page is 
    // displayed (locking the filter creates the ring buffer; the filter is 
    // locked when recordings are created and when the graph is run) or the
    // filter is stopped while the property page is displayed (the ring buffer
    // is closed)
    hr = m_pDVRStreamSink -> QueryInterface (IID_IDVRStreamSinkPriv, (void **) &pDVRStreamSinkPriv) ;
    if (SUCCEEDED(hr)) 
    {
        hr = pDVRStreamSinkPriv->GetDVRRingBufferWriter(&pRingBuffer);
        if (FAILED(hr)) 
        {
            pRingBuffer = NULL;
        }
        pDVRStreamSinkPriv->Release();
    }
    else
    {
        pRingBuffer = NULL;
    }

    if (pRingBuffer == m_pRingBuffer)
    {
        if (pRingBuffer)
        {
            pRingBuffer->Release();
        }
    }
    else
    {
        if (m_pRingBuffer)
        {
            m_pRingBuffer->Release();
        }
        m_pRingBuffer = pRingBuffer; // Could be NULL
        RefreshRecordings();
    }

    if (m_pRingBuffer)
    {
        QWORD tCurrent;

        if (SUCCEEDED(m_pRingBuffer->GetStreamTime(&tCurrent)))
        {
            Format(ach, tCurrent, TRUE);
            SendMessageW(GetDlgItem(m_hwnd, IDC_GRAPHTIME), WM_SETTEXT, 0, (LPARAM) ach);
        }
    }
    else
    {
        SendMessage(GetDlgItem(m_hwnd, IDC_GRAPHTIME), WM_SETTEXT, 0, (LPARAM) TEXT("Not writing"));
    }

    hr = m_pDVRStreamSink->IsProfileLocked();

    if (SUCCEEDED(hr))
    {
        ShowWindow(GetDlgItem(m_hwnd, IDC_LOCKED), hr == S_OK? SW_SHOW : SW_HIDE); 
    }

    if (m_pLVRecordings) 
    {
        int nCount = m_pLVRecordings -> GetItemCount () ;

        for (int i = 0; i < nCount; i++)
        {
            CListData* p = reinterpret_cast <CListData *> (m_pLVRecordings -> GetData (i)) ;
            if (!p || (p -> m_pIRecControl == NULL && p -> m_pDVRRecorder == NULL))
            {
                continue;
            }

            BOOL bStarted, bStopped;
            HRESULT hr;
            switch (p -> m_nState)
            {
                case REC_STATE_READY:
                case REC_STATE_STARTED:
                    HRESULT hrRec;
                    if (p->m_pIRecControl)
                    {
                         hr = p->m_pIRecControl->GetRecordingStatus(&hrRec, &bStarted, &bStopped);
                    }
                    else
                    {
                         hr = p->m_pDVRRecorder->GetRecordingStatus(&hrRec, &bStarted, &bStopped);
                    }
                    if (FAILED(hr))
                    {
                        // Call to GetRecordingStatus failed, do nothing
                    }
                    else if (FAILED(hrRec))
                    {
                        WCHAR buf[32];

                        p->m_nState = REC_STATE_FAILED;
                        wsprintfW(buf, L"%S; hr = %08xh", kwszStateText[p->m_nState], hr);
                        m_pLVRecordings -> SetState (p->m_nState, i, RECORDING_STATE, kwszStateText[p->m_nState]) ;
                    }
                    else if (bStopped)
                    {
                        p->m_nState = REC_STATE_STOPPED;
                        m_pLVRecordings -> SetState (p->m_nState, i, RECORDING_STATE, kwszStateText[p->m_nState]) ;
                    }
                    else if (bStarted && p->m_nState == REC_STATE_READY)
                    {
                        p->m_nState = REC_STATE_STARTED;
                        m_pLVRecordings -> SetState (p->m_nState, i, RECORDING_STATE, kwszStateText[p->m_nState]) ;
                    }

                default:
                    continue;
            }
        }
    }
}

HRESULT
CDVRSinkProp::CreateLiveGraph ()
{
    HRESULT         hr;
    BOOL            bRefresh = 0;
    IGraphBuilder*  pGB = NULL;
    IBaseFilter*    pSourceFilter = NULL;
    IEnumPins*      pEnum = NULL;
    LPCTSTR         szMsg = NULL;
    BOOL            bRestoreCursor = 0;
    HCURSOR         hPrevCursor;

    if (!m_pGraphHost) 
    {
        return S_OK;
    }

    hr = CheckProfileLocked();
    if (FAILED(hr))
    {
        szMsg = kszLockFailedMsg;
        goto Failed;
    }
    else if (hr == S_FALSE)
    {
        return S_OK;
    }

    hr = m_pGraphHost->CreateGraph(&pGB);
    if (FAILED(hr))
    {
        goto Failed;
    }
    hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    bRestoreCursor = 1;
    
    hr = CoCreateInstance (CLSID_DVRStreamSource, NULL, CLSCTX_INPROC, IID_IBaseFilter, (void**) &pSourceFilter);

    if (FAILED(hr))
    {
        szMsg = TEXT("Failed to instantiate the DVR Stream Source filter.");
        goto Failed;
    }

    hr = pGB->AddFilter(pSourceFilter, L"DVR Stream Source");
    if (FAILED(hr))
    {
        szMsg = TEXT("Failed to add the DVR Stream Source filter to the viewer graph.");
        goto Failed;
    }

    bRefresh = 1;

    IDVRStreamSource* pDVRSource;
    hr = pSourceFilter -> QueryInterface (IID_IDVRStreamSource, (void **) &pDVRSource) ;
    if (FAILED(hr)) 
    {
        szMsg = TEXT("Failed to retrieve the IDVRStreamSource interface on the DVR Stream Source filter.");
        goto Failed;
    }

    hr = pDVRSource->SetStreamSink(m_pDVRStreamSink);
    pDVRSource->Release();
    if (FAILED(hr))
    {
        szMsg = TEXT("Failed to set the stream sink on the DVR Stream Source filter.");
        goto Failed;
    }
    
    hr = pSourceFilter->EnumPins(&pEnum);
    if (FAILED(hr))
    {
        szMsg = TEXT("Failed to create a pin enumerator for the DVR Stream Source filter.");
        goto Failed;
    }

    ULONG nFetched;
    do
    {
        IPin* pPin;

        hr = pEnum->Next(1, &pPin, &nFetched);
        if (FAILED(hr))
        {
            szMsg = TEXT("Failed to retrieve a pin of the DVR Stream Source filter.");
            goto Failed;
        }
        if (hr == S_FALSE)
        {
            break;
        }
        hr = pGB->Render(pPin);
        pPin->Release();
        if (FAILED(hr))
        {
            szMsg = TEXT("Failed to render a pin of the DVR Stream Source filter.");
            goto Failed;
        }
    }
    while (1);

    hr = S_OK;

    goto Done;

Failed:
    ::MessageBoxW(m_hwnd, szMsg, kszMsgBoxTitle, MB_OK | MB_ICONEXCLAMATION);
    goto Done;

Done:
    if (bRefresh)
    {
        m_pGraphHost->RefreshView(pGB, 0 /* not modified */);
    }
    if (bRestoreCursor)
    {
        SetCursor(hPrevCursor);
    }
    if (pGB)
    {
        pGB->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pSourceFilter)
    {
        pSourceFilter->Release();
    }
    return hr;
}

HRESULT
CDVRSinkProp::CreateRecGraph ()
{
    HRESULT         hr;
    BOOL            bRefresh = 0;
    IGraphBuilder*  pGB = NULL;
    IBaseFilter*    pSourceFilter = NULL;
    IEnumPins*      pEnum = NULL;
    LPCTSTR         szMsg = NULL;
    BOOL            bRestoreCursor = 0;
    HCURSOR         hPrevCursor;
    WCHAR           wszFile[MAX_PATH];

    if (!m_pGraphHost) 
    {
        return S_OK;
    }

    int iRow = m_pLVRecordings -> GetSelectedRow () ;
    if (iRow != -1) 
    {
        if (m_pLVRecordings -> GetRowTextW (iRow, RECORDING_FILENAME, MAX_PATH, wszFile) == 0) 
        {
            MessageBoxError (
                TEXT ("View Recording"),
                TEXT ("Selected row's file name length is 0?!")
                ) ;
            return E_FAIL;
        }
    }
    else {
        MessageBoxError (
            TEXT ("View Recording"),
            TEXT ("No Recording is selected")
            ) ;
        return S_OK;
    }

    hr = m_pGraphHost->CreateGraph(&pGB);
    if (FAILED(hr))
    {
        goto Failed;
    }
    hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    bRestoreCursor = 1;
    
    hr = CoCreateInstance (CLSID_DVRPlay, NULL, CLSCTX_INPROC, IID_IBaseFilter, (void**) &pSourceFilter);

    if (FAILED(hr))
    {
        szMsg = TEXT("Failed to instantiate the DVR Play filter.");
        goto Failed;
    }

    hr = pGB->AddFilter(pSourceFilter, L"DVR Play");
    if (FAILED(hr))
    {
        szMsg = TEXT("Failed to add the DVR Play filter to the viewer graph.");
        goto Failed;
    }

    bRefresh = 1;

    IFileSourceFilter* pDVRFileSource;
    hr = pSourceFilter -> QueryInterface (IID_IFileSourceFilter, (void **) &pDVRFileSource) ;
    if (FAILED(hr)) 
    {
        szMsg = TEXT("Failed to retrieve the IFileSourceFilter interface on the DVR Play filter.");
        goto Failed;
    }

    hr = pDVRFileSource->Load((LPCOLESTR) wszFile, NULL /* pmt */);
    pDVRFileSource->Release();
    if (FAILED(hr))
    {
        szMsg = TEXT("DVR Play filter failed to open the file.");
        goto Failed;
    }
    
    hr = pSourceFilter->EnumPins(&pEnum);
    if (FAILED(hr))
    {
        szMsg = TEXT("Failed to create a pin enumerator for the DVR Play filter.");
        goto Failed;
    }

    ULONG nFetched;
    do
    {
        IPin* pPin;

        hr = pEnum->Next(1, &pPin, &nFetched);
        if (FAILED(hr))
        {
            szMsg = TEXT("Failed to retrieve a pin of the DVR Play filter.");
            goto Failed;
        }
        if (hr == S_FALSE)
        {
            break;
        }
        hr = pGB->Render(pPin);
        pPin->Release();
        if (FAILED(hr))
        {
            szMsg = TEXT("Failed to render a pin of the DVR Play filter.");
            goto Failed;
        }
    }
    while (1);

    hr = S_OK;

    goto Done;

Failed:
    ::MessageBoxW(m_hwnd, szMsg, kszMsgBoxTitle, MB_OK | MB_ICONEXCLAMATION);
    goto Done;

Done:
    if (bRefresh)
    {
        m_pGraphHost->RefreshView(pGB, 1 /* modified */);
    }
    if (bRestoreCursor)
    {
        SetCursor(hPrevCursor);
    }
    if (pGB)
    {
        pGB->Release();
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pSourceFilter)
    {
        pSourceFilter->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrsink\dvrsinkres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dvrsink.rc
//
#define IDS_DVR_SINK_TITLE              1301
#define IDD_DVR_SINK                    1302
#define IDC_DVR_SINK_FILENAME           1303
#define IDC_DVR_SINK_OPEN_FILE          1304
#define IDC_LOCK_DVRSTREAMSINK          1305
#define IDC_VIEW_DVRSTREAMSOURCE        1306
#define IDC_REC_CREATE                  1307
#define IDC_REC_LIST                    1308
#define IDC_LOCKED                      1309
#define IDC_REC_FILENAME                1310
#define IDC_REC_START                   1311
#define IDC_REC_STOP                    1312
#define IDC_START_ABS_SEC               1313
#define IDC_STOP_ABS_SEC                1314
#define IDC_REC_VIEW                    1315
#define IDC_BROADCAST                   1316
#define IDC_GRAPHTIME                   1317
#define IDI_ACTIVE_REC                  1318
#define IDI_READY_REC                   1319
#define IDI_DONE_REC                    1320
#define IDI_FAILED_REC                  1321
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1322
#define _APS_NEXT_COMMAND_VALUE         13061
#define _APS_NEXT_CONTROL_VALUE         1322
#define _APS_NEXT_SYMED_VALUE           1322
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrsink\uictrl.cpp ===
#include "dvrall.h"
#include "commctrl.h"
#include "uictrl.h"

//  ============================================================================
//  ============================================================================

CControlBase::CControlBase (
    HWND    hwnd,
    DWORD   id
    )
{
    ASSERT (hwnd) ;

    m_hwnd = GetDlgItem (hwnd, id) ;
    m_id = id ;
}

HWND
CControlBase::GetHwnd (
    )
{
    return m_hwnd ;
}

DWORD
CControlBase::GetId (
    )
{
    return m_id ;
}

//  ============================================================================
//  ============================================================================

CEditControl::CEditControl (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
    ASSERT (hwnd) ;
}

void
CEditControl::SetTextW (
    WCHAR * szText
    )
{
    ASSERT (szText) ;

    SetWindowText (m_hwnd, szText) ;
}

void
CEditControl::SetTextW (
    INT val
    )
{
    WCHAR achbuffer [32] ;
    SetTextW (_itow (val, achbuffer, 10)) ;
}

int
CEditControl::GetTextW (
    INT *   val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 31)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CEditControl::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    int r ;

    r = GetWindowText (m_hwnd, ach, MaxChars - 1) ;

    return r ;
}

LRESULT
CEditControl::ResetContent ()
{
    return SendMessage (m_hwnd, WM_CLEAR, 0, 0) ;
}

//  ============================================================================
//  ============================================================================

CCombobox::CCombobox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
}

int
CCombobox::AppendW (
    WCHAR *  sz
    )
{
    return (int) SendMessage (m_hwnd, CB_ADDSTRING, 0, (LPARAM) sz) ;
}

int
CCombobox::AppendW (
    INT val
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return AppendW (_itow (val, achbuffer, 10)) ;
}

int
CCombobox::InsertW (
    WCHAR * sz,
    int     index)
{
    return (int) SendMessage (m_hwnd, CB_INSERTSTRING, (WPARAM) index, (LPARAM) sz) ;
}

int
CCombobox::InsertW (
    INT val,
    int index
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return InsertW (_itow (val, achbuffer, 10), index) ;
}

BOOL
CCombobox::DeleteRow (
    int iRow
    )
{
    return (SendMessage (m_hwnd, CB_DELETESTRING, (WPARAM) iRow, 0) != CB_ERR) ;
}

int
CCombobox::GetItemCount (
    )
{
    return (int) SendMessage (m_hwnd, CB_GETCOUNT, 0, 0) ;
}

int
CCombobox::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    int     index ;
    int     count ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        //  might be that it's not a dropdown list - in which case we get;
        //  try to get just the edit control's text; if that fails, return
        //  a failure, otherwise we're ok

        count = GetWindowText (m_hwnd, ach, MaxChars - 1) ;
        if (count == 0) {
            return CB_ERR ;
        }

        return count ;
    }

    //  make sure it will fit
    if (SendMessage (m_hwnd, CB_GETLBTEXTLEN, (WPARAM) index, 0) + 1 > MaxChars) {
        return CB_ERR ;
    }

    count = (int) SendMessage (m_hwnd, CB_GETLBTEXT, (WPARAM) index, (LPARAM) ach) ;

    return count ;
}

int
CCombobox::GetTextW (
    int * val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 32)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CCombobox::Focus (
    int index
    )
{
    return (int) SendMessage (m_hwnd, CB_SETCURSEL, (WPARAM) index, 0) ;
}

LRESULT
CCombobox::ResetContent (
    )
{
    return SendMessage (m_hwnd, CB_RESETCONTENT, 0, 0) ;
}

int
CCombobox::SetItemData (
    DWORD_PTR   val,
    int         index
    )
{
    return (int) SendMessage (m_hwnd, CB_SETITEMDATA, (WPARAM) index, (LPARAM) val) ;
}

int
CCombobox::GetCurrentItemIndex (
    )
{
    return (int) SendMessage (m_hwnd, CB_GETCURSEL, 0, 0) ;
}

DWORD_PTR
CCombobox::GetItemData (
    DWORD_PTR * pval,
    int         index
    )
{
    DWORD_PTR   dwp ;

    ASSERT (pval) ;

    dwp = SendMessage (m_hwnd, CB_GETITEMDATA, (WPARAM) index, 0) ;
    (* pval) = dwp ;

    return dwp ;
}

DWORD_PTR
CCombobox::GetCurrentItemData (
    DWORD_PTR * pval
    )
{
    int index ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        (* pval) = CB_ERR ;
        return CB_ERR ;
    }

    return GetItemData (pval, index) ;
}

BOOL
CCombobox::SetCurSelected (
    IN  int iIndex
    )
{
    return (SendMessage (m_hwnd, CB_SETCURSEL, (WPARAM) iIndex, 0) != CB_ERR ? TRUE : FALSE) ;
}

//  ============================================================================
//  ============================================================================

CListview::CListview (
    HWND hwnd,
    DWORD id
    ) : CControlBase (hwnd, id),
        m_cColumns (0)
{
}

LRESULT
CListview::ResetContent (
    )
{
    return SendMessage (m_hwnd, LVM_DELETEALLITEMS, 0, 0) ;
}

BOOL
CListview::SetData (
    DWORD_PTR   dwData,
    int         iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.lParam   = (LPARAM) dwData ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::SetTextW (
    WCHAR * sz,
    int iRow,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    ASSERT (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = sz ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::SetTextW (
    int iVal,
    int iRow,
    int iCol
    )
{
    WCHAR   ach [32] ;

    wsprintf (ach, L"%d", iVal) ;
    return SetTextW (ach, iRow, iCol) ;
}

int
CListview::InsertRowIcon (
    int iIcon
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_IMAGE ;
    lvItem.iImage   = iIcon ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowValue (
    DWORD_PTR dwp
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.lParam   = (LPARAM) dwp ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowNumber (
    int i,
    int iCol
    )
{
    WCHAR achbuffer [16] ;

    return InsertRowTextW (
                    _itow (i, achbuffer, 10),
                    iCol
                    ) ;
}

int
CListview::InsertRowTextW (
    WCHAR * sz,
    int iCol,
    int iIndex
    )
{
    LVITEM  lvItem = {LVIF_TEXT, iIndex} ;

    ASSERT (sz) ;

    lvItem.iSubItem = iCol ;
    lvItem.pszText  = sz ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::SetRowSelected (
    int iIndex,
    BOOL fUnSelectAllOtherRows
    )
{
    LVITEM  lvItem = {LVIF_STATE} ;
    lvItem.iSubItem = 0 ;
    lvItem.stateMask = LVIS_SELECTED ;

    int nStart = fUnSelectAllOtherRows? 0 : iIndex;
    int nEnd = fUnSelectAllOtherRows? ListView_GetItemCount(m_hwnd) : iIndex + 1;

    for (int i = nStart; i < nEnd; i++)
    {
        lvItem.iItem = i;
        lvItem.state = i == iIndex? LVIS_SELECTED : 0;
        if (!ListView_SetItem (m_hwnd, & lvItem))
        {
            return 0 ;
        }
    }

    return 1 ;
}

BOOL
CListview::DeleteRow (
    int iRow
    )
{
    return ListView_DeleteItem (m_hwnd, iRow) ;
}

int
CListview::GetSelectedCount (
    )
{
    return ListView_GetSelectedCount (m_hwnd) ;
}

int
CListview::GetSelectedRow (
    int iStartRow
    )
{
    return ListView_GetNextItem (m_hwnd, iStartRow, LVNI_SELECTED) ;
}

DWORD_PTR
CListview::GetData (
    int iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = m_cColumns ;

    return ListView_GetItem (m_hwnd, & lvItem) ? lvItem.lParam : NULL ;
}

DWORD_PTR
CListview::GetData (
    )
{
    int iRow ;

    iRow = ListView_GetNextItem (m_hwnd, -1, LVNI_SELECTED) ;

    if (iRow == -1) {
        return NULL ;
    }

    return GetData (iRow) ;
}

DWORD
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    IN  int     cMax,
    OUT WCHAR * psz
    )
{
    //  leave room for the null-terminator
    ListView_GetItemText (m_hwnd, iRow, iCol, psz, cMax - 1) ;

    return wcslen (psz) ;
}

int
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    OUT int *   val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetRowTextW (iRow, iCol, 32, achbuffer)) {
        * val = _wtoi (achbuffer) ;
    }

    return (* val) ;
}

int
CListview::InsertColumnW (
    WCHAR * szColumnName,
    int ColumnWidth,
    int iCol
    )
{
    LVCOLUMN    lvColumn = {0} ;
    int         r ;

    ASSERT (szColumnName) ;

    lvColumn.mask       = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt        = LVCFMT_LEFT;
    lvColumn.cx         = ColumnWidth ;
    lvColumn.pszText    = szColumnName ;

    r = ListView_InsertColumn (m_hwnd, iCol, & lvColumn) ;

    if (r != -1) {
        m_cColumns++ ;
    }

    return r ;
}

HIMAGELIST
CListview::SetImageList_ (
    HIMAGELIST  imgList,
    int         List
    )
{
    return ListView_SetImageList (m_hwnd, imgList, List) ;
}

HIMAGELIST
CListview::SetImageList_SmallIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_SMALL) ;
}

HIMAGELIST
CListview::SetImageList_NormalIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_NORMAL) ;
}

HIMAGELIST
CListview::SetImageList_State (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_STATE) ;
}

BOOL
CListview::SetState (
    int Index,
    int Row,
    int Col,
    WCHAR* sz
    )
{
    //  setting or clearing ?
    if (Index > 0) {
        ListView_SetItemState (
                m_hwnd,
                Row,
                INDEXTOSTATEIMAGEMASK(Index),
                LVIS_STATEIMAGEMASK
                ) ;
    }
    else {
        ListView_SetItemState (m_hwnd, Row, 0, LVIS_STATEIMAGEMASK) ;
        ListView_RedrawItems (m_hwnd, Row, Row) ;
    }
    if (sz)
    {
        SetTextW(sz, Row, Col);
    }

    return TRUE ;
}

int
CListview::GetItemCount (
    )
{
    return (int) SendMessage (m_hwnd, LVM_GETITEMCOUNT, 0, 0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrsink\dvrsinkprop.h ===
#ifndef __dvrsinkprop_h
#define __dvrsinkprop_h

class CDVRSinkProp :
    public CBasePropertyPage
{
    IDVRStreamSink *  m_pDVRStreamSink ;
    
    IMultiGraphHost * m_pGraphHost ;

    CListview *       m_pLVRecordings ;

    IDVRRingBufferWriter* m_pRingBuffer ;

    HRESULT RefreshRecordings ();
    HRESULT InitRecordingsLV_ () ;
    HRESULT InitCombo_ (    
        IN  DWORD   dwId,
        IN  int     iStart,
        IN  int     iMax,
        IN  int     iStep
        ) ;
    void ReleaseAllRecordings_ () ;
    void CreateRecording () ;
    void StopRecordingSelected () ;
    void StartRecordingSelected () ;

    HRESULT CheckProfileLocked () ;

    void CDVRSinkProp::UpdateCapGraphActiveSec_ () ;

    public :

        CDVRSinkProp (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        ~CDVRSinkProp (
            )
        {
            TRACE_DESTRUCTOR (TEXT ("CDVRSinkProp")) ;
        }

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        INT_PTR
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;

        HRESULT CreateLiveGraph();

        HRESULT CreateRecGraph();

        void DeactivatePriv ();

} ;

#endif  //  __dvrsinkprop_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrsource\dvrsourceres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dvrsource.rc
//
#define IDS_DVR_SOURCE_TITLE            1101
#define IDD_DVR_SOURCE                  1102

#define IDC_DVR_SOURCE_FILENAME         1103
#define IDC_DVR_SOURCE_OPEN_FILE        1104

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1105
#define _APS_NEXT_COMMAND_VALUE         11061
#define _APS_NEXT_CONTROL_VALUE         1107
#define _APS_NEXT_SYMED_VALUE           1108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrsource\dvrsourceprop.cpp ===
#include "dvrall.h"

#include "dvrsourceres.h"       //  resource ids
#include "dvrsourceprop.h"

CDVRSourceProp::CDVRSourceProp (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage       (
            pClassName,
            pIUnknown,
            IDD_DVR_SOURCE,
            IDS_DVR_SOURCE_TITLE
            )
{
    TRACE_CONSTRUCTOR (TEXT ("CDVRSourceProp")) ;
}

HRESULT
CDVRSourceProp::OnActivate (
    )
{
    return CBasePropertyPage::OnActivate () ;
}

HRESULT
CDVRSourceProp::OnApplyChanges (
    )
{
    return CBasePropertyPage::OnApplyChanges () ;
}

HRESULT
CDVRSourceProp::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    return CBasePropertyPage::OnConnect (pIUnknown) ;
}

HRESULT
CDVRSourceProp::OnDeactivate (
    )
{
    return CBasePropertyPage::OnDeactivate () ;
}

HRESULT
CDVRSourceProp::OnDisconnect (
    )
{
    return CBasePropertyPage::OnDisconnect () ;
}

INT_PTR
CDVRSourceProp::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    return CBasePropertyPage::OnReceiveMessage (hwnd, uMsg, wParam, lParam) ;
}

CUnknown *
WINAPI
CDVRSourceProp::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CDVRSourceProp *  pProp ;

    pProp = new CDVRSourceProp (
                        NAME ("CDVRSourceProp"),
                        pIUnknown,
                        CLSID_DVRStreamSourceProp,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\inc\dvrmacros.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrmacros.h

    Abstract:

        This module contains ts/dvr-wide macros

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__dvrmacros_h
#define __tsdvr__dvrmacros_h

//  macros
#define RELEASE_AND_CLEAR(punk)                 if (punk) { (punk)->Release(); (punk) = NULL; }
#define DELETE_RESET(p)                         { delete (p); (p) = NULL ; }
#define DELETE_RESET_ARRAY(a)                   { delete [] (a); (a) = NULL ; }
#define CLOSE_RESET_REG_KEY(r)                  if ((r) != NULL) { RegCloseKey (r); (r) = NULL ;}
#define LOCK_HELD(crt)                          ((crt) -> OwningThread == (HANDLE) GetCurrentThreadId ())
#define LE_UNATTACHED(ple)                      (IsListEmpty (ple))
#define LE_ATTACHED(ple)                        (!LE_UNATTACHED(ple))
#define SET_UNATTACHED(ple)                     InitializeListHead (ple)
#define DVR_CONTAINS_FIELD(type, field, offset) ((FIELD_OFFSET(type, field) + sizeof(((type *)0)->field)) <= offset)

#endif  //  __tsdvr__dvrmacros_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrsource\dvrsourceprop.h ===
#ifndef __dvrsourceprop_h
#define __dvrsourceprop_h

class CDVRSourceProp :
    public CBasePropertyPage
{
    public :

        CDVRSourceProp (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        ~CDVRSourceProp (
            )
        {
            TRACE_DESTRUCTOR (TEXT ("CDVRSourceProp")) ;
        }

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        INT_PTR
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

#endif  //  __dvrsourceprop_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrprop\dvrsink\uictrl.h ===
class CControlBase ;
class CEditControl ;
class CCombobox ;
class CListview ;

class AM_NOVTABLE CControlBase
{
    protected :

        HWND    m_hwnd ;
        DWORD   m_id ;


    public :

        CControlBase (
            HWND    hwnd,
            DWORD   id
            ) ;

        HWND
        GetHwnd (
            ) ;

        DWORD
        GetId (
            ) ;

        virtual
        LRESULT
        ResetContent (
            ) = 0 ;
} ;

class CEditControl :
    public CControlBase
{
    public :

        CEditControl (
            HWND    hwnd,
            DWORD   id
            ) ;

        void
        SetTextW (
            WCHAR *
            ) ;

        void
        SetTextW (
            INT val
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        GetTextW (
            INT *   val
            ) ;

        LRESULT
        ResetContent (
            ) ;
} ;

class CCombobox :
    public CControlBase
{
    public :

        CCombobox (
            HWND    hwnd,
            DWORD   id) ;

        int
        AppendW (
            WCHAR *
            ) ;

        int
        AppendW (
            INT val
            ) ;

        int
        InsertW (
            WCHAR *,
            int index = 0
            ) ;

        int
        InsertW (
            INT val,
            int index = 0
            ) ;

        BOOL
        DeleteRow (
            int
            ) ;

        int
        GetItemCount (
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        GetTextW (
            int *
            ) ;

        LRESULT
        ResetContent (
            ) ;

        int
        Focus (
            int index = 0
            ) ;

        int
        SetItemData (
            DWORD_PTR val,
            int index
            ) ;

        DWORD_PTR
        GetCurrentItemData (
            DWORD_PTR *
            ) ;

        DWORD_PTR
        GetItemData (
            DWORD_PTR *,
            int index
            ) ;

        int
        GetCurrentItemIndex (
            ) ;

        BOOL
        SetCurSelected (
            IN  int
            ) ;
} ;

class CListview :
    public CControlBase
{
    int m_cColumns ;

    HIMAGELIST
    SetImageList_ (
        HIMAGELIST,
        int
        ) ;

    public :

        CListview (
            HWND hwnd,
            DWORD id
            ) ;

        LRESULT
        ResetContent (
            ) ;

        HIMAGELIST
        SetImageList_SmallIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_NormalIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_State (
            HIMAGELIST
            ) ;

        int
        GetItemCount (
            ) ;

        BOOL
        SetState (
            int Index,      //  1-based; if 0, clears
            int Row,
            int Col = 0,
            WCHAR* sz = NULL
            ) ;

        int
        InsertColumnW (
            WCHAR *,
            int ColumnWidth,
            int iCol = 0
            ) ;

        int
        InsertRowIcon (
            int
            ) ;

        int
        InsertRowTextW (
            WCHAR *,
            int iCol = 1,
            int iIndex = 0
            ) ;

        //  inserts a row, but converts the number to a string first
        int
        InsertRowNumber (
            int i,
            int iCol = 1
            ) ;

        int
        InsertRowValue (
            DWORD_PTR
            ) ;

        int
        SetRowSelected (
            int iIndex,
            BOOL fUnSelectAllOtherRows = FALSE
            ) ;

        BOOL
        DeleteRow (
            int
            ) ;

        BOOL
        SetData (
            DWORD_PTR   dwData,
            int         iRow
            ) ;

        BOOL
        SetTextW (
            WCHAR *,
            int iRow,
            int iCol
            ) ;

        BOOL
        SetTextW (
            int iVal,
            int iRow,
            int iCol
            ) ;

        int
        GetSelectedCount (
            ) ;

        int
        GetSelectedRow (
            int iStartRow = -1
            ) ;

        DWORD_PTR
        GetData (
            int iRow
            ) ;

        DWORD_PTR
        GetData (
            ) ;

        DWORD
        GetRowTextW (
            IN  int iRow,
            IN  int iCol,       //  0-based
            IN  int cMax,
            OUT WCHAR *
            ) ;

        int
        GetRowTextW (
            IN  int     iRow,
            IN  int     iCol,
            OUT int *   val
            ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\dvrval\dvrval.cpp ===
#include "windows.h"
#include "dvrioidl.h"
#include <stdio.h>
#include "nserror.h"

void __cdecl wmain(int argc, wchar_t* argv[])
{
    if (FAILED(CoInitialize(NULL)))
    {
        fprintf(stderr, "CoInitialize failed\n");
        return;
    }

    if (argc != 3 && argc != 4)
    {
        fprintf(stderr, "Usage: dvrval [-a|d]  asf_file input_data_file\n"
                "\t-a:\tReport all errors (default: stop after first one)\n"
                "\t-d:\tDump sample attributes to stdout (errors go to stderr)\n"
                "\t\t-d implies -a\n");
        return;
    }

    LPWSTR   pwszValFile = argv[2];
    LPWSTR   pwszFile = argv[1];
    BOOL     bCont = 0;
    BOOL     bDump = 0;

    if (argc == 4 && 
        (argv[1][0] == L'-' || argv[1][0] == L'/') &&
        (argv[1][1] == L'a' || argv[1][1] == L'A') &&
        argv[1][2] == L'\0')
    {
        pwszValFile = argv[3];
        pwszFile = argv[2];
        bCont = 1;
    }
    else if (argc == 4 && 
        (argv[1][0] == L'-' || argv[1][0] == L'/') &&
        (argv[1][1] == L'd' || argv[1][1] == L'd') &&
        argv[1][2] == L'\0')
    {
        pwszValFile = argv[3];
        pwszFile = argv[2];
        bCont = 1;
        bDump = 1;
    }
    else if (argc == 4)
    {
        fprintf(stderr, "Usage: dvrval [-a|d]  asf_file input_data_file\n"
                "\t-a:\tReport all errors (default: stop after first one)\n"
                "\t-d:\tDump sample attributes to stdout (errors go to stderr)\n"
                "\t\t-d implies -a\n");
        return;
    }

    
    IDVRReader* pDVRReader;

    HANDLE hVal;

    hVal = ::CreateFileW(pwszValFile, 
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                         NULL);

    if (hVal == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "CreateFile failed, last error = 0x%x\n", GetLastError());
        return;
    }

    HRESULT hr = DVRCreateReader(pwszFile, &pDVRReader);
    if (FAILED(hr))
    {
        fprintf(stderr, "DVRCreateReader failed, hr = 0x%x\n", hr);
        return;
    }

    hr = pDVRReader->Seek(0);
    if (FAILED(hr))
    {
        fprintf(stderr, "SetRange failed, hr = 0x%x\n", hr);
        return;
    }

    INSSBuffer *pSample;
    QWORD cnsStreamTimeOfSample;
    QWORD cnsFirstStreamTimeVal;
    DWORD cnsSampleDuration;
    DWORD dwFlags;
    WORD  wStreamNum;
    BYTE* pBuffer;
    DWORD dwLength;

    DWORD dwInputNumVal;
    QWORD cnsStreamTimeVal;
    DWORD dwFlagsVal;
    DWORD dwLengthVal;
    BYTE  buf[32000];
    DWORD dwRet;
    DWORD dwRead;
    BOOL bError = 1;
    int i;

    for (i = 1; ; i++)
    {
        dwRet = ReadFile(hVal, &dwInputNumVal, sizeof(dwInputNumVal), &dwRead, NULL);

        if (dwRet == 0)
        {
            fprintf(stderr,
                    "ReadFile failed (dwInputNumVal) for sample %d, last error = 0x%x\n",
                    i, GetLastError());
            break;

        }
        else if (dwRead != sizeof(dwInputNumVal))
        {
            if (dwRead == 0)
            {
                bError = 0;
            }
            else
            {
                fprintf(stderr, "EOF trying to read dwInputNumVal for sample %d; read %d bytes, expected to read %d bytes\n",
                        i, dwRead, sizeof(dwInputNumVal));
            }
            break;

        }

        dwRet = ReadFile(hVal, &cnsStreamTimeVal, sizeof(cnsStreamTimeVal), &dwRead, NULL);

        if (dwRet == 0)
        {
            fprintf(stderr,
                    "ReadFile failed (cnsStreamTimeVal) for sample %d, last error = 0x%x\n",
                    i, GetLastError());
            break;

        }
        else if (dwRead != sizeof(cnsStreamTimeVal))
        {
            fprintf(stderr, "EOF trying to read cnsStreamTimeVal for sample %d\n", i);
            break;

        }

        if (i == 1)
        {
            cnsFirstStreamTimeVal = cnsStreamTimeVal;
        }

        dwRet = ReadFile(hVal, &dwFlagsVal, sizeof(dwFlagsVal), &dwRead, NULL);

        if (dwRet == 0)
        {
            fprintf(stderr,
                    "ReadFile failed (dwFlagsVal) for sample %d, last error = 0x%x\n",
                    i, GetLastError());
            break;

        }
        else if (dwRead != sizeof(dwFlagsVal))
        {
            fprintf(stderr, "EOF trying to read dwFlagsVal for sample %d\n", i);
            break;

        }

        dwRet = ReadFile(hVal, &dwLengthVal, sizeof(dwLengthVal), &dwRead, NULL);

        if (dwRet == 0)
        {
            fprintf(stderr,
                    "ReadFile failed (dwLengthVal) for sample %d, last error = 0x%x\n",
                    i, GetLastError());
            break;

        }
        else if (dwRead != sizeof(dwLengthVal))
        {
            fprintf(stderr, "EOF trying to read dwLengthVal for sample %d\n", i);
            break;

        }

        if (dwLengthVal > sizeof(buf))
        {
            fprintf(stderr, 
                   "Sample %d: Length of sample is %u, max is %u\n",
                   i, dwLengthVal, sizeof(buf));
            break;

        }

        dwRet = ReadFile(hVal, buf, dwLengthVal, &dwRead, NULL);

        if (dwRet == 0)
        {
            fprintf(stderr,
                    "ReadFile failed (buf) for sample %d, last error = 0x%x\n",
                    i, GetLastError());
            break;

        }
        else if (dwRead != dwLengthVal)
        {
            fprintf(stderr, "EOF trying to read buf for sample %d\n", i);
            break;

        }

        hr = pDVRReader->GetNextSample(&pSample,
                                        &cnsStreamTimeOfSample,
                                        &cnsSampleDuration,
                                        &dwFlags,
                                        &wStreamNum);
        if (FAILED(hr))
        {
            fprintf(stderr, "GetNextSample failed for sample %d, hr = 0x%x\n", i, hr);
            break;
        }

        hr = pSample->GetBufferAndLength(&pBuffer, &dwLength);
        if (FAILED(hr))
        {
            fprintf(stderr, "GetBufferAndLength failed for sample %d, hr = 0x%x\n", i, hr);
            if (!bCont) break;
        }

        if (bDump)
        {
            printf ("Val sample %d: Time = %I64u, Input = %u, Flags = %u, Len = %u\n"
                    "GNS sample %d: Time = %I64u, Input = %u, Flags = %u, Len = %u\n",
                    i, (cnsStreamTimeVal - cnsFirstStreamTimeVal)/10000, dwInputNumVal, dwFlagsVal, dwLengthVal,
                    i, (cnsStreamTimeOfSample)/10000, wStreamNum - 1, dwFlags, dwLength);
        }

        // SDK returns cnsStreamTimeOfSample with a precision of millisec only
        if (cnsStreamTimeOfSample/10000 != (cnsStreamTimeVal - cnsFirstStreamTimeVal)/10000)
        {
            fprintf(stderr, 
                   "Sample %d: Sample stream time %I64u, Val stream time %I64u (untruncated: %I64u)\n",
                   i, cnsStreamTimeOfSample/10000, (cnsStreamTimeVal - cnsFirstStreamTimeVal)/10000,
                   (cnsStreamTimeVal - cnsFirstStreamTimeVal));
            if (!bCont) break;
        }

        if (dwFlags != dwFlagsVal)
        {
            fprintf(stderr, 
                   "Sample %d: Sample flags %u, Val flags %u\n",
                   i, dwFlags, dwFlagsVal);
            if (!bCont) break;
        }

        if (wStreamNum - 1 != dwInputNumVal)
        {
            fprintf(stderr, 
                   "Sample %d: Sample stream num (less 1) %u, Val input num %u\n",
                   i, wStreamNum - 1, dwInputNumVal);
            if (!bCont) break;
        }

        if (dwLength != dwLengthVal)
        {
            fprintf(stderr, 
                   "Sample %d: Sample length %u, Val length %u\n",
                   i, dwLength, dwLengthVal);
            if (!bCont) break;
        }
        else
        {

            for (; dwLength != 0; )
            {
                dwLength--;
                if (pBuffer[dwLength] != buf[dwLength])
                {
                    fprintf(stderr, 
                        "Sample %d: Sample buffers different at index %u\n",
                        i, dwLength);
                    break;
                }
            }
            if (dwLength > 0)
            {
                if (!bCont) break;
            }
        }
        pSample->Release();

    }

    if (!bError)
    {
        hr = pDVRReader->GetNextSample(&pSample,
                                        &cnsStreamTimeOfSample,
                                        &cnsSampleDuration,
                                        &dwFlags,
                                        &wStreamNum);

        if (FAILED(hr) && hr != NS_E_NO_MORE_SAMPLES)
        {
            fprintf(stderr, "GetNextSample failed for sample %d, hr = 0x%x\n", i, hr);
        }
        else if (hr != NS_E_NO_MORE_SAMPLES)
        {
            fprintf(stderr, "GetNextSample succeeded for sample %d but val file is at EOF\n", i);
            pSample->Release();
        }
    }


    pDVRReader->Release();
    CloseHandle(hVal);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\inc\dvrall.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrall.h

    Abstract:

        This module is the main header for all ts/dvr

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__dvrall_h
#define __tsdvr__dvrall_h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <tchar.h>
#include <limits.h>

//  dshow
#include <streams.h>
#include <dvdmedia.h>       //  MPEG2VIDEOINFO

//  WMSDK
#include <wmsdk.h>

//  project
#include "dvrdef.h"
#include "dvrfor.h"
#include "dvrtrace.h"
#include "dvrmacros.h"
#include "dvrds.h"
#include "dvrdspriv.h"
#include "dvrstats.h"
#include "dvrutil.h"
#include "dvrpolicy.h"
#include "dvrioidl.h"

//  prototype for analysis logic's class factory method to host logic into
//   DShow filter
HRESULT
CreateDVRAnalysisHostFilter (
    IN  IUnknown *  punkOuter,
    IN  IUnknown *  punkAnalysisLogic,
    IN  REFCLSID    rCLSID,
    OUT CUnknown ** punkAnalysisFilterHost
    ) ;

#endif  //  __tsdvr__dvrall_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\inc\dvrdef.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdef.h

    Abstract:

        This module all the #defines

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        04-Apr-2001     created

--*/

#ifndef __tsdvr__dvrdef_h
#define __tsdvr__dvrdef_h

//  ============================================================================
//  constants

//  universal undefined value
#define UNDEFINED   -1

//  max dshow REFERENCE_TIME
#define MAX_REFERENCE_TIME                  0x7FFFFFFFFFFFFFFF

//  mpeg-2
//  00 00 01
#define START_CODE_PREFIX_LENGTH            3

//  mpeg-2
//  00 00 01 xx
#define START_CODE_LENGTH                   (START_CODE_PREFIX_LENGTH + 1)

//  registry values
#define DVR_STATS_DISABLED                  0
#define DVR_STATS_ENABLED                   1

//  stream numbers in WMSDK profiles
#define WMSDK_MIN_VALID_STREAM_NUM          1
#define WMSDK_MAX_VALID_STREAM_NUM          63
#define WMSDK_PROFILE_MAX_STREAMS           (WMSDK_MAX_VALID_STREAM_NUM - WMSDK_MIN_VALID_STREAM_NUM)

#define MAX_PIN_BANK_SIZE                   WMSDK_PROFILE_MAX_STREAMS

//  for VBR, we compute the max bitrate as uncompressed frame size *
//   frames per second; some of the VIDEOINFOHEADER structs though, seem to
//   have the .AvgTimePerFrame member 0ed out, so this value is our guess
#define VBR_DEF_FPS                         30

//  play speed brackets
enum {
    PLAY_SPEED_BRACKET_FORWARD,             //  1x
    PLAY_SPEED_BRACKET_SLOW_FORWARD,        //  (0x, 1x)
    PLAY_SPEED_BRACKET_FAST_FORWARD,        //  (1x, ..)
    PLAY_SPEED_BRACKET_REVERSE,             //  -1x
    PLAY_SPEED_BRACKET_SLOW_REVERSE,        //  (-1x, 0x)
    PLAY_SPEED_BRACKET_FAST_REVERSE,        //  (.., -1x)

    //  ---------------------------------------------------
    PLAY_SPEED_BRACKET_COUNT                //  always last
} ;

//  ============================================================================
//  registry constants

//  -------------------------------
//  top level location
#define REG_DVR_TOP_LEVEL                       HKEY_CURRENT_USER
#define REG_DVR_ROOT                            TEXT ("SOFTWARE\\Microsoft\\DVR")

//  -------------------------------
//  analysis-related
#define REG_DVR_ANALYSIS_LOGIC_MPEG2_VIDEO      TEXT ("Analysis") TEXT ("\\") TEXT ("Mpeg-2 Video")
#define REG_DVR_ANALYSIS_LOGIC_HOSTING_FILTER   TEXT ("Analysis") TEXT ("\\") TEXT ("Filter")

#define REG_DVR_STATS_NAME                      TEXT ("Stats")
#define REG_DEF_STATS                           DVR_STATS_DISABLED

#define REG_ANALYSIS_HOSTING_FILTER_STATS       TEXT ("Hosting Filter")
#define REG_DEF_ANALYSIS_HOSTING_FILTER_STATS   DVR_STATS_DISABLED

#define REG_DVR_ANALYSIS_ROOT                   TEXT ("DVRAnalysis")
#define REG_DVR_STREAM_SINK_ROOT                TEXT ("DVRStreamSink")
#define REG_DVR_STREAM_SOURCE_ROOT              TEXT ("DVRStreamSource")
#define REG_DVR_PLAY_ROOT                       TEXT ("DVRPlay")
#define REG_DVR_STREAM_THROUGH_ROOT             TEXT ("DVRStreamThrough")

//  BUGBUG
//  temporary registry entries follow i.e. those that should eventually not
//   be used, but are currently useful for testing & integration purposes

//  WMSDK stream's buffer window
#define REG_WM_BUFFER_WINDOW_KEYNAME            TEXT ("WMBufferWindowMillis")
#define REG_DEF_WM_BUFFER_WINDOW                0

//  WMSDK packet size
#define REG_WM_PACKET_SIZE_KEYNAME            TEXT ("WMPacketSizeBytes")
#define REG_DEF_WM_PACKET_SIZE                0

//
//  The WMSDK validates mediatypes.  There are currently bugs in the
//   validation code that prevent us from storing audio and video subtypes
//   that they don't explicitely know about.  For now, we hack around
//   this by introducing our own hacky mediatypes, one for video and one
//   for audio, so we are not blocked.  We translate to/from on the in/out
//   of the SDK.  This is hideous but effective.
//
//  global variable if we are to use generic streams or not - settable via
//   the registry
extern BOOL g_fRegGenericStreams_Video ;
#define REG_VID_USE_GENERIC_STREAMS_DEFAULT     FALSE
#define REG_VID_USE_GENERIC_STREAMS_NAME        TEXT ("Video_UseGenericStreams")

extern BOOL g_fRegGenericStreams_Audio ;
#define REG_AUD_USE_GENERIC_STREAMS_DEFAULT     TRUE
#define REG_AUD_USE_GENERIC_STREAMS_NAME        TEXT ("Audio_UseGenericStreams")

//  BUGBUG
//  maybe temporary registry entries follow

#define REG_NUM_BACKING_FILES_NAME              TEXT ("NumBackingFiles")
#define REG_DEF_NUM_BACKING_FILES               6

#define REG_BACKING_FILE_DURATION_SECONDS_NAME  TEXT ("BackingFileDurationSeconds")
#define REG_DEF_BACKING_FILE_DURATION_SECONDS   600

#define REG_MAX_STREAM_DELTA_NAME               TEXT ("MaxStreamDeltaMillis")
#define REG_DEF_MAX_STREAM_DELTA                1

#define REG_SOURCE_ALLOCATOR_CBUFFERS_NAME      TEXT ("Allocator.cBuffers")
#define REG_DEF_SOURCE_ALLOCATOR_CBUFFERS       0x100

#define REG_SOURCE_ALLOCATOR_CBBUFFER_NAME      TEXT ("Allocator.cbBuffer")
#define REG_DEF_SOURCE_ALLOCATOR_CBBUFFER       0x2000

#define REG_SOURCE_ALLOCATOR_ALIGN_VAL_NAME     TEXT ("Allocator.cbAlign")
#define REG_DEF_SOURCE_ALLOCATOR_ALIGN_VAL      1

#define REG_SOURCE_ALLOCATOR_PREFIX_VAL_NAME    TEXT ("Allocator.cbPrefix")
#define REG_DEF_SOURCE_ALLOCATOR_PREFIX_VAL     0

#define REG_INLINE_DSHOW_PROPS_NAME             TEXT ("InlineDShowProps")
#define REG_DEF_INLINE_DSHOW_PROPS              TRUE

#define REG_SUCCEED_QUERY_ACCEPT_NAME           TEXT ("SucceedQueryAccept")
#define REG_DEF_SUCCEED_QUERY_ACCEPT            TRUE

#define REG_DOWNSTREAM_BUFFERING_MILLIS_NAME    TEXT ("DownstreamBufferingMillis")
#define REG_DEF_DOWNSTREAM_BUFFERING_MILLIS     100

//  this value toggles the use or lack thereof, of a continuity counter that
//   enables us to count samples written vs. those read out; this helps with
//   debugging, discontinuities, etc...
#define REG_USE_CONTINUITY_COUNTER_NAME         TEXT ("UseContinuityCounter")
#define REG_DEF_USE_CONTINUITY_COUNTER          TRUE

//  this value toggles a state where we don't send anything downstream until the
//   the first seek is made; the reason for this is that apps may want to seek
//   to the most forward position when the graph goes active;
#define REG_ONACTIVE_WAIT_FIRST_SEEK_NAME       TEXT ("OnActiveWaitFirstSeek")
#define REG_DEF_ONACTIVE_WAIT_FIRST_SEEK        FALSE

//  value toggles whether or not we implement IReferenceClock
#define REG_IMPLEMENT_IREFERENCECLOCK_NAME      TEXT ("ImplementIReferenceClock")
#define REG_DEF_IMPLEMENT_IREFERENCECLOCK       TRUE

//  ============================================================================

//  filter names
#define DVR_STREAM_SINK_FILTER_NAME         "DVRStreamSink"
#define DVR_STREAM_SOURCE_FILTER_NAME       "DVRStreamSource"
#define DVR_PLAY_FILTER_NAME                "DVRPlay"
#define DVR_STREAM_THROUGH_FILTER_NAME      "DVRStreamThrough"

//  analysis COM server names
#define DVR_MPEG2_FRAME_ANALYSIS            "DVR Mpeg-2 Frame Analysis"
#define DVR_MPEG2_FRAME_ANALYSIS_W          L"DVR Mpeg-2 Frame Analysis"

//  profile names & descriptions
#define DVR_STREAM_SINK_PROFILE_NAME        L"DVRStreamSink Profile"
#define DVR_STREAM_SINK_PROFILE_DESCRIPTION L"DVRStreamSink Configuration WM Profile"

//  WMSDK compatibility version
#define WMSDK_COMPATIBILITY_VERSION         WMT_VER_9_0

//  use these to set WM stream attributes
#define WM_MEDIA_VIDEO_TYPE_NAME            L"Video"
#define WM_MEDIA_AUDIO_TYPE_NAME            L"Audio"
#define WM_MEDIA_DATA_TYPE_NAME             L"Data"
#define WM_STREAM_CONNECTION_NAME           L"Connection"

#endif  //  __tsdvr__dvrdef_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\inc\dvrpolicy.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrdef.h

    Abstract:

        This module all the #defines

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        24-May-2001     created

--*/

#ifndef __tsdvr__dvrpolicy_h
#define __tsdvr__dvrpolicy_h

//  ============================================================================
//  ============================================================================

class CTSDVRSettings
{
    //
    //  ..Val_ is for values
    //  ..Flag_ is for flags i.e. TRUE (non-zero) or FALSE (zero)
    //

    //
    //  ..Instance is specific to the instance (DVRPlay, DVRStreamSource, etc..)
    //  ..DVR is global to DVR i.e. applies to everything
    //

    HKEY                m_hkeyDVRRoot ;
    HKEY                m_hkeyInstanceRoot ;
    CRITICAL_SECTION    m_crt ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    DWORD   GetVal_ (HKEY hkeyRoot, TCHAR * szValName, DWORD   dwDefVal) ;
    BOOL    GetFlag_ (HKEY hkeyRoot, TCHAR * szValName, BOOL   fDef) ;

    DWORD   InstanceGetVal_ (TCHAR * szValName, DWORD   dwDefVal)   { return GetVal_ (m_hkeyInstanceRoot, szValName, dwDefVal) ; }
    BOOL    InstanceGetFlag_ (TCHAR * szValName, BOOL    fDef)      { return GetFlag_ (m_hkeyInstanceRoot, szValName, fDef) ; }

    DWORD   DVRGetVal_ (TCHAR * szValName, DWORD   dwDefVal)        { return GetVal_ (m_hkeyDVRRoot, szValName, dwDefVal) ; }
    BOOL    DVRGetFlag_ (TCHAR * szValName, BOOL    fDef)           { return GetFlag_ (m_hkeyDVRRoot, szValName, fDef) ; }

    HRESULT
    OpenRegKeys_ (
        IN  HKEY    hkeyDefaultTopLevel,
        IN  TCHAR * pszDefaultDVRRoot,
        IN  TCHAR * pszDefaultInstanceRoot
        ) ;

    void
    CloseRegKeys_ (
        ) ;

    public :

        CTSDVRSettings (
            IN  HKEY    hkeyDefaultTopLevel,
            IN  TCHAR * pszDefaultDVRRoot,
            IN  TCHAR * pszInstanceRoot
            ) ;

        ~CTSDVRSettings (
            ) ;

        HKEY    GetDVRRegKey ()                 { return m_hkeyDVRRoot ; }
        HKEY    GetInstanceRegKey ()            { return m_hkeyInstanceRoot ; }

        DWORD   NumBackingFiles ()              { return DVRGetVal_ (REG_NUM_BACKING_FILES_NAME, REG_DEF_NUM_BACKING_FILES) ; }
        QWORD   BackingFileDurationEach ()      { return SecondsToWMSDKTime (DVRGetVal_ (REG_BACKING_FILE_DURATION_SECONDS_NAME, REG_DEF_BACKING_FILE_DURATION_SECONDS)) ; }
        QWORD   MaxStreamDelta ()               { return MillisToWMSDKTime (DVRGetVal_ (REG_MAX_STREAM_DELTA_NAME, REG_DEF_MAX_STREAM_DELTA)) ; }
        DWORD   WMBufferWindowMillis ()         { return DVRGetVal_ (REG_WM_BUFFER_WINDOW_KEYNAME, REG_DEF_WM_BUFFER_WINDOW) ; }
        DWORD   WMPacketSize ()                 { return DVRGetVal_ (REG_WM_PACKET_SIZE_KEYNAME, REG_DEF_WM_PACKET_SIZE) ; }
        BOOL    InlineDShowProps ()             { return InstanceGetFlag_ (REG_INLINE_DSHOW_PROPS_NAME, REG_DEF_INLINE_DSHOW_PROPS) ; }
        BOOL    SucceedQueryAccept ()           { return InstanceGetVal_ (REG_SUCCEED_QUERY_ACCEPT_NAME, REG_DEF_SUCCEED_QUERY_ACCEPT) ; }
        DWORD   DownstreamBufferingMillis ()    { return InstanceGetVal_ (REG_DOWNSTREAM_BUFFERING_MILLIS_NAME, REG_DEF_DOWNSTREAM_BUFFERING_MILLIS) ; }
        BOOL    UseContinuityCounter ()         { return DVRGetFlag_ (REG_USE_CONTINUITY_COUNTER_NAME, REG_DEF_USE_CONTINUITY_COUNTER) ; }
        BOOL    OnActiveWaitFirstSeek ()        { return InstanceGetVal_ (REG_ONACTIVE_WAIT_FIRST_SEEK_NAME, REG_DEF_ONACTIVE_WAIT_FIRST_SEEK) ; }
        BOOL    CanImplementIReferenceClock ()  { return InstanceGetFlag_ (REG_IMPLEMENT_IREFERENCECLOCK_NAME, REG_DEF_IMPLEMENT_IREFERENCECLOCK) ; }

        //  allocator props - for sourcing filters
        DWORD   AllocatorGetBufferSize ()       { return InstanceGetVal_ (REG_SOURCE_ALLOCATOR_CBBUFFER_NAME, REG_DEF_SOURCE_ALLOCATOR_CBBUFFER) ; }
        DWORD   AllocatorGetBufferCount ()      { return InstanceGetVal_ (REG_SOURCE_ALLOCATOR_CBUFFERS_NAME, REG_DEF_SOURCE_ALLOCATOR_CBUFFERS) ; }
        DWORD   AllocatorGetAlignVal ()         { return InstanceGetVal_ (REG_SOURCE_ALLOCATOR_ALIGN_VAL_NAME, REG_DEF_SOURCE_ALLOCATOR_ALIGN_VAL) ; }
        DWORD   AllocatorGetPrefixVal ()        { return InstanceGetVal_ (REG_SOURCE_ALLOCATOR_PREFIX_VAL_NAME, REG_DEF_SOURCE_ALLOCATOR_PREFIX_VAL) ; }

        //  stats
        BOOL    StatsEnabled ()                 { return DVRGetFlag_ (REG_DVR_STATS_NAME, REG_DEF_STATS) ; }
        DWORD   EnableStats (BOOL f) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRPolicy
{
    CTSDVRSettings  m_RegSettings ;
    LONG            m_lRef ;

    public :

        CDVRPolicy (
            IN  TCHAR *     pszInstRegRoot,
            OUT HRESULT *   phr
            ) ;

        ~CDVRPolicy (
            ) ;

        CTSDVRSettings * Settings ()    { return & m_RegSettings ; }

        //  lifetime
        ULONG AddRef ()     { return InterlockedIncrement (& m_lRef) ; }
        ULONG Release () ;
} ;

#endif  //  __tsdvr__dvrpolicy_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\inc\dvrfor.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrfor.h

    Abstract:

        This module contains forward declarations for all C++ classes
        defined in ts/dvr

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef __tsdvr__dvrfor_h
#define __tsdvr__dvrfor_h

class CDVRPin ;
//  filters\shared\dvrpins.h
//  common to DVR input and output pins

template <class T>
class CTDVRPinBank ;
//  filters\shared\dvrpins.h
//  generic DVR pin Bank

class CDVRSourcePinManager ;
//  filters\shared\dvrpins.h
//  source pin bank

class CDVRSinkPinManager ;
//  filters\shared\dvrpins.h
//  sink pin bank

class CDVRThroughSinkPinManager ;
//  filters\shared\dvrpins.h
//  inherits from CDVRSinkPinManager, but overrides the completeconnect to
//   callback on filter's

class CDVROutputPin ;
//  filters\shared\dvrpins.h
//  DVR-class filter input pin

class CDVRInputPin ;
//  filters\shared\dvrpins.h
//  DVR-class filter output pin

class CIDVRPinConnectionEvents ;
//  filters\shared\dvrpins.h
//  abstract callback interface for input pin events (connection, etc..)

class CIDVRDShowStream ;
//  filters\shared\dvrpins.h
//  abstract callback interface for input pin streaming events (delivery, etc..)

class CMpeg2VideoFrame ;
//  analysis\iframe\dvriframe.h
//  mpeg-2 I-frame detection code; analysis logic

class CDVRStreamSink ;
//  filters\dvrstreamsink\dvrstreamsink.h
//  DVR-class sink filter proper

class CDVRStreamSource ;
//  filters\dvrstreamsource\dvrstreamsource.h
//  DVR-class source filter proper

class CDVRStreamThrough ;
//  filters\dvrstreamthrough\dvrstreamthrough.h
//  DVR-class stream-through filter proper

class CWin32SharedMem ;
//  inc\dvrstats.h
//  generic win32 shared mem object

class CMpeg2VideoStreamStatsMem ;
//  inc\dvrstats.h
//  mpeg-2 video frame analysis shared mem

class CMpeg2VideoStreamStatsWriter ;
//  inc\dvrstats.h

class CMpeg2VideoStreamStatsReader ;
//  inc\dvrstats.h

class CDVRAnalysisBuffer ;
//  analysis\dvranalysis
//  media sample wrapper for analysis logic

class CDVRAnalysisBufferPool ;
//  analysis\dvranalysis
//  sample wrapper pool

class CDVRAnalysis ;
//  analysis\dvranalysis
//  analysis filter host

class CDVRAnalysisInput ;
//  analysis\dvranalysis
//  analysis input pin

class CDVRAnalysisOutput ;
//  analysis\dvranalysis
//  analysis output pin

template <class T, DWORD dwAllocationQuantum>
class TStructPool ;
//  inc\dvrutil.h
//  struct pool - for reuse rather than allocating every time

template <int iCacheSize>
class TSizedDataCache ;
//  inc\dvrutil.h
//  data cache

class CDataCache ;
//  inc\dvrutil.h
//  cache that allocates

template <class T>
class TCNonDenseVector ;
//  inc\dvrutil.h
//  non-dense vector template

template <class T>
class TCDenseVector ;
//  inc\dvrutil.h
//  dense vector template

template <class T>
class TCObjPool ;
//  inc\dvrutil.h
//  producer-consumer template

class CMediaSampleWrapperPool ;
//  inc\dvrutil.h
//  media sample wrapper pool

class CMediaSampleWrapper ;
//  inc\dvrutil.h
//  media sample wrapper i.e. wraps another media sample, but exposes own props

template <class T>
class CTSortedList ;
//  inc\dvrutil.h
//  generic sorted list

template <class T, LONG lMax>
class CTSizedQueue ;
//  inc\dvrutil.h
//  generic queue of T items; max size is lMax

class CDVRSourceProp ;
//  dvrprop\dvrsource\dvrsourceprop.h
//  DVR Stream source property page

class CDVRWriteManager ;
//  dvrfilters\shared\dvrdswrite.h
//  manages all writing operations; accepts dshow IMediaSamples

class CDVRWriter ;
//  dvrfilters\shared\dvrdswrite.h
//  DVR writer object; writes INSSBuffers

class CDVRIOWriter ;
//  dvrfilters\shared\dvrdswrite.h
//  uses our DVR IO layer to write INSSBuffers; derives from CDVRWriter

class CWMINSSBuffer3Wrapper ;
//  inc\dvrutil.h
//  IUnknown wrapper that exposes the INSSBuffer3 interface

class CPooledWMINSSBuffer3Wrapper ;
//  inc\dvrutil.h
//  CWMINSSBuffer3Wrapper child that is part of a pool

class CWMINSSBuffer3WrapperPool ;
//  inc\dvrutil.h
//  CPooledWMINSSBuffer3Wrapper pool

class CDVRMpeg2AttributeTranslator ;
//  inc\dvrutil.h
//  mpeg2 translator

class CDVRAttributeTranslator ;
//  inc\dvrutil.h
//  translator

template <class T>
class TCDynamicProdCons ;
//  inc\dvrutil.h
//  producer/consumer pool template; can be fixed size; grows to a max

class CTSDVRSettings ;
//  inc\dvrpolicy.h
//  used throughought to retrieve settings

class CDVRAnalysisFlags ;
//  inc\dvrutil.h
//  used to get/set analysis flags

class CDVRMpeg2VideoAnalysisFlags ;
//  inc\dvrutil.h
//  used to get/set mpeg-2 video analysis flags

class CDVRDShowReader ;
//  dvrfilters\shared
//  reads INNSBuffers

class CDVRDReaderThread ;
//  dvrfilters\shared\dvrdswrite
//  reader thread; hosted by the CDVRReadManager

class CDVRReadManager ;
//  dvrfilters\shared\dvrdsreader.h
//  abstract class; hosted by a sourcing filter

class CDVRRecordingReader ;
//  dvrfilters\shared\dvrdsreader.h
//  derived from CDVRReadManager; plays back recordings

class CDVRBroadcastStreamReader ;
//  dvrfilters\shared\dvrdsreader.h
//  derived from CDVRReadmanager; plays back broadcast stream content

class CDVRReaderProfile ;
//  dvrfilters\shared\dvrdsreader.h
//  wraps an IWMProfile pointer obtained from the IDVRReader; refcounted

template <
    class tKey,     //  <, >, == operators must work
    class tVal      //  = operator must work
    >
class CTSmallMap ;
//  inc\dvrutil.h
//  ok for very small maps

class CDVRDShowSeekingCore ;
//  dvrfilters\shared\dvrdsseek.h
//  core seeking functionality; manages & serializes all seeking operations

class CDVRDIMediaSeeking ;
//  dvrfilters\shared\dvrdsseek.h
//  IMediaSeeking interface implementations; parameter validation; wraps to core

class CSimpleBitfield ;
//  inc\dvrutil.h
//  simple bitfield

class CINSSBuffer3Attrib ;
//  inc\dvrutil.h
//  INSSBuffer3 attribute data

class CINSSBuffer3AttribList ;
//  inc\dvrutil.h
//  list of CINSSBuffer3Attrib

class CDVRRecording ;
//  dvrfilters\shared\dvrdsrec.h
//  recording object (IUnknown *); obtained via IDVRStreamSink

class CDVRThread ;
//  inc\dvrutil.h
//  copy/paste CAMThread but some of the members are now protected vs. private

class CDVRReceiveStatsMem ;
//  inc\dvrstats.h
//  received streams stats shared memory

class CDVRReceiveStatsWriter ;
//  inc\dvrstats.h
//  received streams stats writer object

class CDVRReceiveStatsReader ;
//  inc\dvrstats.h
//  received streams stats reader

class CDVRSendStatsMem ;
//  inc\dvrstats.h
//  send streams stats shared memory

class CDVRSendStatsWriter ;
//  inc\dvrstats.h
//  send streams stats writer object

class CDVRSendStatsReader ;
//  inc\dvrstats.h
//  send streams stats reader

template <class T>
class CTDynArray ;
//  inc\dvrutil.h
//  dynamically-allocated Array; both LIFO & FIFO behavior

template <class T>
class CTDynStack ;
//  inc\dvrutil.h
//  dynamically-allocated LIFO

template <class T>
class CTDynQueue ;
//  inc\dvrutil.h
//  dynamically-allocated FIFO

class CDVRClock ;
//  dvrfilters\shared\dvrclock.h
//  IReferenceClock implementation

class CDVRPolicy ;
//  inc\dvrpolicy.h
//  app-controllable/settable policies; accessed from everywhere

class CDVRReadController ;
//  dvrfilters\shared\dvrdsread.h
//  read controller; can be media-specific; controls 1x & trick mode playback

class CDVR_F_ReadController ;
//  dvrfilters\shared\dvrdsread.h
//  forward read controller

class CDVR_F1X_ReadController ;
//  dvrfilters\shared\dvrdsread.h
//  1x read controller

class CDVR_FF_ReadController ;
//  dvrfilters\shared\dvrdsread.h
//  +1x read controller

class CDVR_R_ReadController ;
//  dvrfilters\shared\dvrdsread.h
//  reverse read controller

#endif  //  __tsdvr__dvrfor_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\inc\dvrstats.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        dvrstats.h

    Abstract:

        This module contains all declarations related to statistical
        information.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        19-Feb-2001     created

    Notes:

--*/

#ifndef __tsdvr_dvrstats_h
#define __tsdvr_dvrstats_h

//  ============================================================================
//  shared memory object

class CWin32SharedMem
{
    BYTE *  m_pbShared ;
    DWORD   m_dwSize ;
    HANDLE  m_hMapping ;

    void
    Free_ (
        ) ;

    HRESULT
    Create_ (
        IN  TCHAR *     szName,
        IN  DWORD       dwSize
        ) ;

    public :

        CWin32SharedMem (
            IN  TCHAR *     szName,
            IN  DWORD       dwSize,
            OUT HRESULT *   phr
            ) ;

        virtual
        ~CWin32SharedMem (
            ) ;

        BYTE *  GetSharedMem ()     { return m_pbShared ; }
        DWORD   GetSharedMemSize () { return m_dwSize ; }
} ;

//  ============================================================================
//  ============================================================================
//      I-Frame Analysis stats

#define ANALYSIS_MPEG2_VIDEO_SHAREDMEM_NAME TEXT ("TSDVR_ANALYSIS_MPEG2_VIDEO_STATS")

struct ANALYSIS_MPEG2_VIDEO_STATS {
    ULONGLONG   ullGOPHeaderCount ;     //  observed GOP header count
    ULONGLONG   ullIFrameCount ;        //  observed I-frame count
    ULONGLONG   ullPFrameCount ;        //  observed P-frame count
    ULONGLONG   ullBFrameCount ;        //  observed B-frame count
} ;

/*++
    writer

    used purely internally
--*/
class CMpeg2VideoStreamStatsMem
{
    CWin32SharedMem *   m_pSharedMem ;

    protected :

        ANALYSIS_MPEG2_VIDEO_STATS *    m_pMpeg2VideoStreamStats ;

        CMpeg2VideoStreamStatsMem (
            ) : m_pMpeg2VideoStreamStats    (NULL),
                m_pSharedMem                (NULL) {}

        virtual
        ~CMpeg2VideoStreamStatsMem (
            )
        {
            delete m_pSharedMem ;
        }

        HRESULT
        Initialize (
            IN  BOOL    fEnable,
            IN  TCHAR * szSharedMemName = ANALYSIS_MPEG2_VIDEO_SHAREDMEM_NAME
            )
        //  not serialized !!
        {
            HRESULT hr ;

            if (fEnable &&
                !m_pSharedMem) {

                //  turn it on and we're not yet on

                m_pSharedMem = new CWin32SharedMem (
                                        szSharedMemName,
                                        sizeof ANALYSIS_MPEG2_VIDEO_STATS,
                                        & hr
                                        ) ;

                if (m_pSharedMem &&
                    SUCCEEDED (hr)) {

                    m_pMpeg2VideoStreamStats = reinterpret_cast <ANALYSIS_MPEG2_VIDEO_STATS *> (m_pSharedMem -> GetSharedMem ()) ;
                }
                else {
                    hr = (m_pSharedMem ? hr : E_OUTOFMEMORY) ;
                    DELETE_RESET (m_pSharedMem) ;
                }
            }
            else if (!fEnable) {
                //  turn stats off

                DELETE_RESET (m_pSharedMem) ;
                m_pMpeg2VideoStreamStats = NULL ;

                hr = S_OK ;
            }

            return hr ;
        }

        HRESULT
        Clear (
            )
        //  not serialized !!
        {
            if (m_pSharedMem) {

                //  frame this in a __try/__except because it's possible for
                //   another process to create the shared mem, but make it
                //   smaller; we'll AV when we exceed the original (smaller)
                //   size

                __try {

                    ZeroMemory (
                        m_pSharedMem -> GetSharedMem (),
                        m_pSharedMem -> GetSharedMemSize ()
                        ) ;

                }
                __except (GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    //  return an error code
                    return HRESULT_FROM_WIN32 (STATUS_ACCESS_VIOLATION) ;
                }
            }

            return S_OK ;
        }
} ;

class CMpeg2VideoStreamStatsWriter :
    private CMpeg2VideoStreamStatsMem
{
    public :

        CMpeg2VideoStreamStatsWriter (
            ) {}

        HRESULT
        Initialize (
            IN  BOOL    f
            )
        {
            HRESULT hr ;

            hr = CMpeg2VideoStreamStatsMem::Initialize (f) ;
            if (SUCCEEDED (hr)) {
                hr = Clear () ;
                if (FAILED (hr)) {
                    Initialize (FALSE) ;
                }
            }

            return hr ;
        }

        __inline void GOPHeader ()  { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> ullGOPHeaderCount++ ; }}
        __inline void I_Frame ()    { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> ullIFrameCount++ ; }}
        __inline void B_Frame ()    { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> ullBFrameCount++ ; }}
        __inline void P_Frame ()    { if (m_pMpeg2VideoStreamStats) { m_pMpeg2VideoStreamStats -> ullPFrameCount++ ; }}
} ;

//  COM-based host for the stream specific COM interfaces
class CMpeg2VideoStreamStatsReader :
    public  CUnknown,
    public  IDVRMpeg2VideoStreamStats,
    private CMpeg2VideoStreamStatsMem
{
    CDVRPolicy *    m_pPolicy ;

    public :

        CMpeg2VideoStreamStatsReader (
            IN  IUnknown *  pIUnknown,
            OUT HRESULT *   phr
            ) ;

        ~CMpeg2VideoStreamStatsReader (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  class factory
        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;

        //  stats interface
        DECLARE_IDVRMPEG2VIDEOSTREAMSTATS() ;
} ;

//  ============================================================================
//  ============================================================================

#define TSDVR_RECEIVE_STATS_SHAREDMEM_NAME      TEXT ("TSDVR_RECEIVE_STATS")

//  per pin
struct TSDVR_RECEIVE_STREAM_STATS {
    ULONGLONG       ullMediaSamplesIn ;
    ULONGLONG       ullTotalBytes ;
    ULONGLONG       ullDiscontinuities ;
    ULONGLONG       ullSyncPoints ;
    REFERENCE_TIME  rtLast ;
    ULONGLONG       ullWriteFailures ;
} ;

#define TSDVR_RECEIVE_MAX_STREAM_STATS      5

struct TSDVR_RECEIVE_STATS {
    TSDVR_RECEIVE_STREAM_STATS  StreamStats [TSDVR_RECEIVE_MAX_STREAM_STATS] ;
} ;

class CDVRReceiveStatsMem
{
    CWin32SharedMem *   m_pSharedMem ;

    protected :

        TSDVR_RECEIVE_STATS *   m_pDVRReceiveStats ;

        CDVRReceiveStatsMem (
            ) : m_pDVRReceiveStats   (NULL),
                m_pSharedMem            (NULL) {}

        virtual
        ~CDVRReceiveStatsMem (
            )
        {
            delete m_pSharedMem ;
        }

        HRESULT
        Initialize (
            IN  BOOL    fEnable,
            IN  TCHAR * szSharedMemName = TSDVR_RECEIVE_STATS_SHAREDMEM_NAME
            )
        //  not serialized !!
        {
            HRESULT hr ;

            if (fEnable &&
                !m_pSharedMem) {

                //  turn it on and we're not yet on

                m_pSharedMem = new CWin32SharedMem (
                                        szSharedMemName,
                                        sizeof TSDVR_RECEIVE_STATS,
                                        & hr
                                        ) ;

                if (m_pSharedMem &&
                    SUCCEEDED (hr)) {

                    m_pDVRReceiveStats = reinterpret_cast <TSDVR_RECEIVE_STATS *> (m_pSharedMem -> GetSharedMem ()) ;
                }
                else {
                    hr = (m_pSharedMem ? hr : E_OUTOFMEMORY) ;
                    DELETE_RESET (m_pSharedMem) ;
                }
            }
            else if (!fEnable) {
                //  turn stats off

                DELETE_RESET (m_pSharedMem) ;
                m_pDVRReceiveStats = NULL ;

                hr = S_OK ;
            }

            return hr ;
        }

        HRESULT
        Clear (
            )
        //  not serialized !!
        {
            if (m_pSharedMem) {

                //  frame this in a __try/__except because it's possible for
                //   another process to create the shared mem, but make it
                //   smaller; we'll AV when we exceed the original (smaller)
                //   size

                __try {

                    ZeroMemory (
                        m_pSharedMem -> GetSharedMem (),
                        m_pSharedMem -> GetSharedMemSize ()
                        ) ;

                }
                __except (GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    //  return an error code
                    return HRESULT_FROM_WIN32 (STATUS_ACCESS_VIOLATION) ;
                }
            }

            return S_OK ;
        }
} ;

class CDVRReceiveStatsWriter :
    private CDVRReceiveStatsMem
{
    public :

        CDVRReceiveStatsWriter (
            ) {}

        HRESULT
        Initialize (
            IN  BOOL    f
            )
        {
            HRESULT hr ;

            hr = CDVRReceiveStatsMem::Initialize (f) ;
            if (SUCCEEDED (hr)) {
                hr = Clear () ;
                if (FAILED (hr)) {
                    Initialize (FALSE) ;
                }
            }

            return hr ;
        }

        __inline void SampleIn (int iFlow, IMediaSample * pIMS)
        {
            REFERENCE_TIME  rtStart ;
            REFERENCE_TIME  rtStop ;

            if (m_pDVRReceiveStats &&
                iFlow < TSDVR_RECEIVE_MAX_STREAM_STATS) {

                m_pDVRReceiveStats -> StreamStats [iFlow].ullMediaSamplesIn++ ;

                m_pDVRReceiveStats -> StreamStats [iFlow].ullTotalBytes         += pIMS -> GetActualDataLength () ;
                m_pDVRReceiveStats -> StreamStats [iFlow].ullDiscontinuities    += (pIMS -> IsDiscontinuity () == S_OK ? 1 : 0) ;
                m_pDVRReceiveStats -> StreamStats [iFlow].ullSyncPoints         += (pIMS -> IsSyncPoint () == S_OK ? 1 : 0) ;

                if (pIMS -> GetTime (& rtStart, & rtStop) != VFW_E_SAMPLE_TIME_NOT_SET) {
                    m_pDVRReceiveStats -> StreamStats [iFlow].rtLast = rtStart ;
                }
            }
        }

        __inline void SampleWritten (int iFlow, HRESULT hrWriteCall)
        {
            if (m_pDVRReceiveStats &&
                iFlow < TSDVR_RECEIVE_MAX_STREAM_STATS) {

                m_pDVRReceiveStats -> StreamStats [iFlow].ullWriteFailures      += (FAILED (hrWriteCall) ? 1 : 0) ;
            }
        }
} ;

class CDVRReceiveStatsReader :
    public  CUnknown,
    public  IDVRReceiverStats,
    private CDVRReceiveStatsMem
{
    CDVRPolicy *    m_pPolicy ;

    public :

        CDVRReceiveStatsReader (
            IN  IUnknown *  pIUnknown,
            OUT HRESULT *   phr
            ) ;

        ~CDVRReceiveStatsReader (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  class factory
        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;

        //  stats interface
        DECLARE_IDVRRECEIVERSTATS() ;
} ;

//  ============================================================================
//  ============================================================================

#define TSDVR_SEND_STATS_SHAREDMEM_NAME      TEXT ("TSDVR_SEND_STATS")

//  per pin
struct TSDVR_SEND_STREAM_STATS {
    ULONGLONG       ullMediaSamplesIn ;
    ULONGLONG       ullTotalBytes ;
    ULONGLONG       ullDiscontinuities ;
    ULONGLONG       ullSyncPoints ;
    REFERENCE_TIME  rtLastNormalized ;
    REFERENCE_TIME  rtRefClockOnLastPTS ;
    LONG            lMediaSamplesOutstanding ;
    LONG            lPoolSize ;
} ;

#define TSDVR_SEND_MAX_STREAM_STATS      5

struct TSDVR_SEND_STATS {
    REFERENCE_TIME          rtNormalizer ;
    REFERENCE_TIME          rtRefClockStart ;
    ULONGLONG               ullReadFailures ;
    TSDVR_SEND_STREAM_STATS StreamStats [TSDVR_SEND_MAX_STREAM_STATS] ;
} ;

class CDVRSendStatsMem
{
    CWin32SharedMem *   m_pSharedMem ;

    protected :

        TSDVR_SEND_STATS *  m_pDVRSenderStats ;

        CDVRSendStatsMem (
            ) : m_pDVRSenderStats   (NULL),
                m_pSharedMem        (NULL) {}

        virtual
        ~CDVRSendStatsMem (
            )
        {
            delete m_pSharedMem ;
        }

        HRESULT
        Initialize (
            IN  BOOL    fEnable,
            IN  TCHAR * szSharedMemName = TSDVR_SEND_STATS_SHAREDMEM_NAME
            )
        //  not serialized !!
        {
            HRESULT hr ;

            if (fEnable &&
                !m_pSharedMem) {

                //  turn it on and we're not yet on

                m_pSharedMem = new CWin32SharedMem (
                                        szSharedMemName,
                                        sizeof TSDVR_SEND_STATS,
                                        & hr
                                        ) ;

                if (m_pSharedMem &&
                    SUCCEEDED (hr)) {

                    m_pDVRSenderStats = reinterpret_cast <TSDVR_SEND_STATS *> (m_pSharedMem -> GetSharedMem ()) ;
                }
                else {
                    hr = (m_pSharedMem ? hr : E_OUTOFMEMORY) ;
                    DELETE_RESET (m_pSharedMem) ;
                }
            }
            else if (!fEnable) {
                //  turn stats off

                DELETE_RESET (m_pSharedMem) ;
                m_pDVRSenderStats = NULL ;

                hr = S_OK ;
            }

            return hr ;
        }

        HRESULT
        Clear (
            )
        //  not serialized !!
        {
            if (m_pSharedMem) {

                //  frame this in a __try/__except because it's possible for
                //   another process to create the shared mem, but make it
                //   smaller; we'll AV when we exceed the original (smaller)
                //   size

                __try {

                    ZeroMemory (
                        m_pSharedMem -> GetSharedMem (),
                        m_pSharedMem -> GetSharedMemSize ()
                        ) ;

                }
                __except (GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    //  return an error code
                    return HRESULT_FROM_WIN32 (STATUS_ACCESS_VIOLATION) ;
                }
            }

            return S_OK ;
        }
} ;

class CDVRSendStatsWriter :
    private CDVRSendStatsMem
{
    public :

        CDVRSendStatsWriter (
            ) {}

        HRESULT
        Initialize (
            IN  BOOL    f
            )
        {
            HRESULT hr ;

            hr = CDVRSendStatsMem::Initialize (f) ;
            if (SUCCEEDED (hr)) {
                hr = Clear () ;
                if (FAILED (hr)) {
                    Initialize (FALSE) ;
                }
            }

            return hr ;
        }

        __inline void SetNormalizer (REFERENCE_TIME rtNormalizer, IReferenceClock * pIRefClock)
        {
            if (m_pDVRSenderStats) {
                m_pDVRSenderStats -> rtNormalizer = rtNormalizer ;

                if (pIRefClock) {
                    pIRefClock -> GetTime (& m_pDVRSenderStats -> rtRefClockStart) ;
                }
            }
        }

        __inline void SampleOut (int iFlow, IMediaSample * pIMS, IReferenceClock * pIRefClock)
        {
            REFERENCE_TIME  rtStart ;
            REFERENCE_TIME  rtStop ;

            if (m_pDVRSenderStats &&
                iFlow < TSDVR_SEND_MAX_STREAM_STATS) {

                m_pDVRSenderStats -> StreamStats [iFlow].ullMediaSamplesIn++ ;

                m_pDVRSenderStats -> StreamStats [iFlow].ullTotalBytes      += pIMS -> GetActualDataLength () ;
                m_pDVRSenderStats -> StreamStats [iFlow].ullDiscontinuities += (pIMS -> IsDiscontinuity () == S_OK ? 1 : 0) ;
                m_pDVRSenderStats -> StreamStats [iFlow].ullSyncPoints      += (pIMS -> IsSyncPoint () == S_OK ? 1 : 0) ;

                if (pIMS -> GetTime (& rtStart, & rtStop) != VFW_E_SAMPLE_TIME_NOT_SET) {
                    m_pDVRSenderStats -> StreamStats [iFlow].rtLastNormalized = rtStart ;

                    if (pIRefClock) {
                        pIRefClock -> GetTime (& m_pDVRSenderStats -> StreamStats [iFlow].rtRefClockOnLastPTS) ;
                    }
                }
            }
        }

        __inline void INSSBufferRead (HRESULT hrReadCall)
        {
            if (m_pDVRSenderStats &&
                FAILED (hrReadCall)) {
                m_pDVRSenderStats -> ullReadFailures++ ;
            }
        }

        __inline void MediaSampleWrapperOut (int iFlowId, LONG  lPoolSize)
        {
            if (m_pDVRSenderStats &&
                iFlowId < TSDVR_SEND_MAX_STREAM_STATS) {

                m_pDVRSenderStats -> StreamStats [iFlowId].lMediaSamplesOutstanding++ ;
                m_pDVRSenderStats -> StreamStats [iFlowId].lPoolSize = lPoolSize ;
            }
        }

        __inline void MediaSampleWrapperRecycled (int iFlowId, LONG lPoolSize)
        {
            if (m_pDVRSenderStats &&
                iFlowId < TSDVR_SEND_MAX_STREAM_STATS) {

                m_pDVRSenderStats -> StreamStats [iFlowId].lMediaSamplesOutstanding-- ;
            }
        }
} ;

class CDVRSendStatsReader :
    public  CUnknown,
    public  IDVRSenderStats,
    private CDVRSendStatsMem
{
    CDVRPolicy *    m_pPolicy ;

    public :

        CDVRSendStatsReader (
            IN  IUnknown *  pIUnknown,
            OUT HRESULT *   phr
            ) ;

        ~CDVRSendStatsReader (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  class factory
        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;

        //  stats interface
        DECLARE_IDVRSENDERSTATS() ;
} ;

#endif  //  __tsdvr_dvrstats_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\inc\dvrtrace.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrtrace.h

    Abstract:

        This module contains tracing wrappers for DirectShow's, with standard
            levels, etc..

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef _tsdvr__dvrtrace_h
#define _tsdvr__dvrtrace_h

//  standard levels
#define TRACE_ENTER_LEAVE_LEVEL             8
#define TRACE_ERROR_LEVEL                   3
#define CONSTRUCTOR_DESTRUCTOR_LEVEL        (TRACE_ENTER_LEAVE_LEVEL - 1)

//  ============================================================================
//  LOG_AREA_
//
//  These definitions broadly categorize related areas, so they can be turned
//   on with minimum/none frivolous, non-related tracing.

//  CONSTRUCTOR_DESTRUCTOR
//      falls into the memory management area
//
//      levels:
//          all 1: CONSTRUCTOR_DESTRUCTOR_LEVEL (defined above)
//          3
//          4
//          5
#define LOG_AREA_CONSTRUCTOR_DESTRUCTOR     LOG_MEMORY

//  WMSDK
//      used to trace operations that are specific to WMSDK such as profile
//      creation, manipulation, etc...
//
//      levels:
//          1   * ordinary runtime operations, such as profile creation,
//                  manipulation
//          2
//          3
//          4
//          5   * runtime dshow <-> wmsdk translation
#define LOG_AREA_WMSDK_DSHOW                LOG_CUSTOM1

//  IMediaSeeking
//      used to trace operations that are specifically related to IMediaSeeking
//      calls; also used to trace segment notifications
//
//      levels:
//          1   * SetPosition call parameters & return values;
//              * IDVRReader adjustments;
//              * new segment notifications/pin
//          2
//          3
//          4   * duration (static & live file)
//          5
#define LOG_AREA_SEEKING                    LOG_CUSTOM2

//  time-related tracing
//      used to trace out timestamp recovery & generation; a/v sync
//      adjustments; ref clock values
//
//      levels:
//          1   * timestamp normalization value discovery
//              * we're IReferenceClock (TRUE/FALSE)
//          2
//          3
//          4   * IReferenceClock thread activity
//          5   * all timestamps (in csv format)
#define LOG_AREA_TIME                       LOG_CUSTOM3

//  dshow
//
//      levels:
//          1   filtergraph state changes
#define LOG_AREA_DSHOW                      LOG_TRACE

#ifdef DEBUG

#define TRACE_0(ds,l,fmt)                    DbgLog((ds,l,fmt))
#define TRACE_1(ds,l,fmt,a)                  DbgLog((ds,l,fmt,a))
#define TRACE_2(ds,l,fmt,a,b)                DbgLog((ds,l,fmt,a,b))
#define TRACE_3(ds,l,fmt,a,b,c)              DbgLog((ds,l,fmt,a,b,c))
#define TRACE_4(ds,l,fmt,a,b,c,d)            DbgLog((ds,l,fmt,a,b,c,d))
#define TRACE_5(ds,l,fmt,a,b,c,d,e)          DbgLog((ds,l,fmt,a,b,c,d,e))
#define TRACE_6(ds,l,fmt,a,b,c,d,e,f)        DbgLog((ds,l,fmt,a,b,c,d,e,f))
#define TRACE_7(ds,l,fmt,a,b,c,d,e,f,g)      DbgLog((ds,l,fmt,a,b,c,d,e,f,g))
#define TRACE_8(ds,l,fmt,a,b,c,d,e,f,g,h)    DbgLog((ds,l,fmt,a,b,c,d,e,f,g,h))

#else

#define TRACE_0(ds,l,fmt)                    0
#define TRACE_1(ds,l,fmt,a)                  0
#define TRACE_2(ds,l,fmt,a,b)                0
#define TRACE_3(ds,l,fmt,a,b,c)              0
#define TRACE_4(ds,l,fmt,a,b,c,d)            0
#define TRACE_5(ds,l,fmt,a,b,c,d,e)          0
#define TRACE_6(ds,l,fmt,a,b,c,d,e,f)        0
#define TRACE_7(ds,l,fmt,a,b,c,d,e,f,g)      0
#define TRACE_8(ds,l,fmt,a,b,c,d,e,f,g,h)    0

#endif

//  ---------------------------------------------------------------------------
//  error
//  ---------------------------------------------------------------------------

#define TRACE_ERROR()                       TRACE_2(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u)"),TEXT(__FILE__), __LINE__)
#define TRACE_ERROR_0(fmt)                  TRACE_2(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__)
#define TRACE_ERROR_1(fmt,a)                TRACE_3(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a)
#define TRACE_ERROR_2(fmt,a,b)              TRACE_4(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b)
#define TRACE_ERROR_3(fmt,a,b,c)            TRACE_5(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b,c)
#define TRACE_ERROR_4(fmt,a,b,c,d)          TRACE_6(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b,c,d)
#define TRACE_ERROR_5(fmt,a,b,c,d,e)        TRACE_7(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b,c,d,e)
#define TRACE_ERROR_6(fmt,a,b,c,d,e,f)      TRACE_8(LOG_ERROR,TRACE_ERROR_LEVEL,TEXT("ERROR: %s(%u); ") fmt,TEXT(__FILE__), __LINE__,a,b,c,d,e,f)

#define ERROR_SPEW(v,op,c)                  TRACE_ERROR_5(TEXT("(%s = 0x%08xh) %s (%s = 0x%08xh)"),TEXT(#v),v,TEXT(#op),TEXT(#c),c)
#define ERROR_SPEW_EX(v,op,c,m)             TRACE_ERROR_6(TEXT("(%s = 0x%08xh) %s (%s = 0x%08xh); %s"),TEXT(#v),v,TEXT(#op),TEXT(#c),c,m)
#define ERROR_RET(v,op,c)                   if ((v) op (c)) { ERROR_SPEW(v,op,c); return ; }
#define ERROR_RET_VAL(v,op,c,r)             if ((v) op (c)) { ERROR_SPEW(v,op,c); return (r) ; }
#define ERROR_RET_EX(v,op,c,m)              if ((v) op (c)) { ERROR_SPEW_EX(v,op,c,m); return ; }
#define ERROR_RET_VAL_EX(v,op,c,r,m)        if ((v) op (c)) { ERROR_SPEW_EX(v,op,c,m); return (r) ; }

//  ---------------------------------------------------------------------------
//  constructor / destructor
//  ---------------------------------------------------------------------------

#define TRACE_CONSTRUCTOR(fmt)              TRACE_1(LOG_AREA_CONSTRUCTOR_DESTRUCTOR,CONSTRUCTOR_DESTRUCTOR_LEVEL,TEXT("[%08xh] CONSTRUCTOR : ") fmt TEXT("::") fmt, this)
#define TRACE_DESTRUCTOR(fmt)               TRACE_1(LOG_AREA_CONSTRUCTOR_DESTRUCTOR,CONSTRUCTOR_DESTRUCTOR_LEVEL,TEXT("[%08xh] DESTRUCTOR  : ") fmt TEXT("::~") fmt, this)

//  ---------------------------------------------------------------------------
//  enter
//  ---------------------------------------------------------------------------
#define TRACE_ENTER_0(fmt)                  TRACE_0(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt)
#define TRACE_ENTER_1(fmt,a)                TRACE_1(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a)
#define TRACE_ENTER_2(fmt,a,b)              TRACE_2(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b)
#define TRACE_ENTER_3(fmt,a,b,c)            TRACE_3(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b,c)
#define TRACE_ENTER_4(fmt,a,b,c,d)          TRACE_4(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b,c,d)
#define TRACE_ENTER_5(fmt,a,b,c,d,e)        TRACE_5(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b,c,d,e)
#define TRACE_ENTER_6(fmt,a,b,c,d,e,f)      TRACE_6(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("ENTER : ") fmt,a,b,c,d,e,f)

//  ---------------------------------------------------------------------------
//  object enter
//  ---------------------------------------------------------------------------
#define O_TRACE_ENTER_0(fmt)                TRACE_ENTER_1(TEXT("[%08xh] ") fmt, this)
#define O_TRACE_ENTER_1(fmt,a)              TRACE_ENTER_2(TEXT("[%08xh] ") fmt, this,a)
#define O_TRACE_ENTER_2(fmt,a,b)            TRACE_ENTER_3(TEXT("[%08xh] ") fmt, this,a,b)
#define O_TRACE_ENTER_3(fmt,a,b,c)          TRACE_ENTER_4(TEXT("[%08xh] ") fmt, this,a,b,c)
#define O_TRACE_ENTER_4(fmt,a,b,c,d)        TRACE_ENTER_5(TEXT("[%08xh] ") fmt, this,a,b,c,d)
#define O_TRACE_ENTER_5(fmt,a,b,c,d,e)      TRACE_ENTER_6(TEXT("[%08xh] ") fmt, this,a,b,c,d,e)

//  ---------------------------------------------------------------------------
//  leave
//  ---------------------------------------------------------------------------
#define TRACE_LEAVE_0(fmt)                  TRACE_0(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt)
#define TRACE_LEAVE_1(fmt,a)                TRACE_1(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a)
#define TRACE_LEAVE_2(fmt,a,b)              TRACE_2(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b)
#define TRACE_LEAVE_3(fmt,a,b,c)            TRACE_3(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b,c)
#define TRACE_LEAVE_4(fmt,a,b,c,d)          TRACE_4(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b,c,d)
#define TRACE_LEAVE_5(fmt,a,b,c,d,e)        TRACE_5(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b,c,d,e)
#define TRACE_LEAVE_6(fmt,a,b,c,d,e,f)      TRACE_6(LOG_TRACE,TRACE_ENTER_LEAVE_LEVEL,TEXT("LEAVE : ") fmt,a,b,c,d,e,f)

//  ---------------------------------------------------------------------------
//  object leave
//  ---------------------------------------------------------------------------
#define O_TRACE_LEAVE_0(fmt)                TRACE_LEAVE_1(TEXT("[%08xh] ") fmt, this)
#define O_TRACE_LEAVE_1(fmt,a)              TRACE_LEAVE_2(TEXT("[%08xh] ") fmt, this,a)
#define O_TRACE_LEAVE_2(fmt,a,b)            TRACE_LEAVE_3(TEXT("[%08xh] ") fmt, this,a,b)
#define O_TRACE_LEAVE_3(fmt,a,b,c)          TRACE_LEAVE_4(TEXT("[%08xh] ") fmt, this,a,b,c)
#define O_TRACE_LEAVE_4(fmt,a,b,c,d)        TRACE_LEAVE_5(TEXT("[%08xh] ") fmt, this,a,b,c,d)
#define O_TRACE_LEAVE_5(fmt,a,b,c,d,e)      TRACE_LEAVE_6(TEXT("[%08xh] ") fmt, this,a,b,c,d,e)

#endif  //  _tsdvr__dvrtrace_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\inc\dvrutil.h ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrutil.h

    Abstract:

        This module contains ts/dvr-wide utility prototypes

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#ifndef _tsdvr__dvrutil_h
#define _tsdvr__dvrutil_h

template <class T> T Min (T a, T b) { return (a < b ? a : b) ; }
template <class T> T Max (T a, T b) { return (a > b ? a : b) ; }

LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    ) ;

LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    ) ;

//  ============================================================================
//  timebase conversions

__inline
DWORD
QPCToMillis (
    IN  LONGLONG    llQPC,
    IN  DWORD       dwQPCFreq
    )
{
    return (DWORD) ((1000 * llQPC) / dwQPCFreq) ;
}

__inline
REFERENCE_TIME
QPCToDShow (
    IN  LONGLONG    llQPC,
    IN  LONGLONG    llQPCFreq
    )
{
    double dRetval ;

    dRetval = llQPC * (10000000.0 / ((double) llQPCFreq)) ;
    return (REFERENCE_TIME) dRetval ;
}

__inline
QWORD
MillisToWMSDKTime (
    IN  DWORD   dwMillis
    )
{
    return dwMillis * 10000I64 ;
}

__inline
REFERENCE_TIME
DShowTimeToMilliseconds (
    IN  REFERENCE_TIME  rt
    )
{
    return rt / 10000 ;
}

__inline
DWORD
DShowTimeToSeconds (
    IN  REFERENCE_TIME  rt
    )
{
    return (DWORD) (DShowTimeToMilliseconds (rt) / 1000) ;
}

__inline
DWORD
WMSDKTimeToSeconds (
    IN  QWORD   qw
    )
{
    //  both are 100 MHz clocks
    return DShowTimeToSeconds (qw) ;
}

__inline
QWORD
SecondsToWMSDKTime (
    IN  DWORD   dwSeconds
    )
{
    return MillisToWMSDKTime (dwSeconds * 1000) ;
}

__inline
REFERENCE_TIME
SecondsToDShowTime (
    IN  DWORD   dwSeconds
    )
{
    //  both are 100 MHz clocks
    return SecondsToWMSDKTime (dwSeconds) ;
}

__inline
QWORD
MinutesToWMSDKTime (
    IN  DWORD   dwMinutes
    )
{
    return SecondsToWMSDKTime (dwMinutes * 60) ;
}

__inline
QWORD
DShowToWMSDKTime (
    IN  REFERENCE_TIME  rt
    )
{
    //  both are 100 MHz clocks; rt should never be < 0
    ASSERT (rt >= 0I64) ;
    return (QWORD) rt ;
}

__inline
REFERENCE_TIME
WMSDKToDShowTime (
    IN  QWORD   qw
    )
{
    REFERENCE_TIME  rtRet ;

    //  both are 100 MHz clocks, but WMSDK is unsigned
    rtRet = (REFERENCE_TIME) qw ;
    if (rtRet < 0I64) {
        rtRet = MAX_REFERENCE_TIME ;
    }

    return rtRet ;
}

BOOL
AMMediaIsTimestamped (
    IN  AM_MEDIA_TYPE * pmt
    ) ;

__inline
REFERENCE_TIME
MillisToDShowTime (
    IN  DWORD   dwMillis
    )
{
    return WMSDKToDShowTime (MillisToWMSDKTime (dwMillis)) ;
}

//  ============================================================================
//  registry

//  value exists:           retrieves it
//  value does not exist:   sets it
BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR szValName,
    OUT DWORD * pdw
    ) ;

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdw
    ) ;

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    ) ;

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    ) ;

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    ) ;

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    ) ;

__inline
BOOL
IsMaybeStartCodePrefix (
    IN  BYTE *  pbBuffer,
    IN  LONG    lBufferLength
    )
{
    ASSERT (lBufferLength < START_CODE_PREFIX_LENGTH) ;

    if (lBufferLength == 1) {
        return (pbBuffer [0] == 0x00 ? TRUE : FALSE) ;
    }
    else if (lBufferLength == 2) {
        return (pbBuffer [0] == 0x00 && pbBuffer [1] == 0x00 ? TRUE : FALSE) ;
    }
    else {
        return FALSE ;
    }
}

__inline
BYTE
StartCode (
    IN BYTE *   pbStartCode
    )
{
    return pbStartCode [3] ;
}

__inline
BOOL
IsStartCodePrefix (
    IN  BYTE *  pbBuffer
    )
{
    return (pbBuffer [0] == 0x00 &&
            pbBuffer [1] == 0x00 &&
            pbBuffer [2] == 0x01) ;
}

//  TRUE :  (* ppbBuffer) points to prefix i.e. = {00,00,01}
//  FALSE:  (* piBufferLength) == 2
__inline
BOOL
SeekToPrefix (
    IN OUT  BYTE ** ppbBuffer,
    IN OUT  LONG *  plBufferLength
    )
{
    while ((* plBufferLength) >= START_CODE_PREFIX_LENGTH) {
        if (IsStartCodePrefix (* ppbBuffer)) {
            return TRUE ;
        }

        //  advance to next byte and decrement number of bytes left
        (* plBufferLength)-- ;
        (* ppbBuffer)++ ;
    }

    return FALSE ;
}

BOOL
IsBlankMediaType (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsAMVideo (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsWMVideo (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsAMAudio (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsWMAudio (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsHackedVideo (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsHackedAudio (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsVideo (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

BOOL
IsAudio (
    IN  const AM_MEDIA_TYPE * pmt
    ) ;

//  ============================================================================
//  ============================================================================

class DShowWMSDKHelpers
{
    //  validates and ensures that all values add up correctly
    static
    HRESULT
    FormatBlockSetValidForWMSDK_ (
        IN OUT  AM_MEDIA_TYPE * pmt
        ) ;

    public :

        //  validates and ensures that all values add up correctly
        static
        HRESULT
        MediaTypeSetValidForWMSDK (
            IN OUT  AM_MEDIA_TYPE * pmt
            ) ;

        //  call FreeMediaType ((AM_MEDIA_TYPE *) pWmt) to free
        static
        HRESULT
        TranslateDShowToWM (
            IN  AM_MEDIA_TYPE * pAmt,
            OUT WM_MEDIA_TYPE * pWmt
            ) ;

        static
        HRESULT
        TranslateWMToDShow (
            IN  WM_MEDIA_TYPE * pWmt,
            OUT AM_MEDIA_TYPE * pAmt
            ) ;

        static
        BOOL
        IsWMVideoStream (
            IN  REFGUID guidStreamType
            ) ;

        static
        BOOL
        IsWMAudioStream (
            IN  REFGUID guidStreamType
            ) ;

        static
        WORD
        PinIndexToWMStreamNumber (
            IN  LONG    lIndex
            ) ;

        static
        WORD
        PinIndexToWMInputStream (
            IN  LONG    lIndex
            ) ;

        static
        LONG
        WMStreamNumberToPinIndex (
            IN  WORD    wStreamNumber
            ) ;

        static
        CDVRAttributeTranslator *
        GetAttributeTranslator (
            IN  AM_MEDIA_TYPE *     pmtConnection,
            IN  CDVRPolicy *        pPolicy,
            IN  int                 iFlowId
            ) ;

        static
        HRESULT
        MaybeAddFormatSpecificExtensions (
            IN  IWMStreamConfig2 *  pIWMStreamConfig2,
            IN  AM_MEDIA_TYPE *     pmt
            ) ;

        static
        BOOL
        INSSBuffer3PropPresent (
            IN  INSSBuffer3 *   pINSSBuffer3,
            IN  REFGUID         rguid
            ) ;

        static
        HRESULT
        RecoverDShowAttributes (
            IN  INSSBuffer3 *   pINSSBuffer3,
            IN  IMediaSample *  pIMS
            ) ;

        static
        HRESULT
        SetDShowAttributes (
            IN  IMediaSample *  pIMS,
            IN  INSSBuffer3 *   pINSSBuffer3
            ) ;

        static
        HRESULT
        RecoverNewMediaType (
            IN  INSSBuffer3 *       pINSSBuffer3,
            OUT AM_MEDIA_TYPE **    ppmtNew         //  DeleteMediaType on this to free
            ) ;

        static
        HRESULT
        InlineNewMediaType (
            IN  INSSBuffer3 *   pINSSBuffer3,
            IN  AM_MEDIA_TYPE * pmtNew              //  can free this after the call
            ) ;
} ;

//  ----------------------------------------------------------------------------
//      TCNonDenseVector
//  ----------------------------------------------------------------------------

/*++
--*/
template <class T>
class TCNonDenseVector
{
    T **    m_pptTable ;                //  table pointer
    T       m_tEmptyVal ;               //  denotes an empty value in a block
    int     m_iTableRowCountInUse ;     //  rows currently in use
    int     m_iTableRowCountAvail ;     //  available rows (allocated)
    int     m_iBlockSize ;              //  allocation unit size;
                                        //  NOTE: = init table size
    int     m_iMaxIndexInsert ;         //  the max value set so far

    int GetAllocatedSize_ ()    { return m_iTableRowCountInUse * m_iBlockSize ; }

    DWORD
    AppendBlock_ (
        IN  T * ptBlock
        )
    {
        int     iNewTableSize ;
        T **    pptNewTable ;

        //  if we don't have any place to store the new block, allocate it now
        if (!m_pptTable ||
            (m_iTableRowCountInUse == m_iTableRowCountAvail)) {

            //  compute new table size; initial table size is m_iBlockSize
            iNewTableSize = Max <int> (m_iBlockSize, m_iTableRowCountAvail * 2) ;

            //  allocate
            pptNewTable = AllocateTable_ (iNewTableSize) ;
            if (pptNewTable) {
                //  we have a new table

                //  zero the entries out
                ZeroMemory (pptNewTable, iNewTableSize * sizeof (T *)) ;

                //  if we have an old one
                if (m_pptTable) {
                    //  copy the contents over to the newly allocated table and
                    //   free the old
                    CopyMemory (pptNewTable, m_pptTable, m_iTableRowCountAvail * sizeof (T *)) ;
                    FreeTable_ (m_pptTable) ;
                }

                //  set the member variables
                m_pptTable              = pptNewTable ;
                m_iTableRowCountAvail   = iNewTableSize ;
            }
            else {
                //  failed to allocate memory - send the failure back out
                return ERROR_NOT_ENOUGH_MEMORY ;
            }
        }

        //  one more row in use - update and set
        m_iTableRowCountInUse++ ;
        m_pptTable [m_iTableRowCountInUse - 1] = ptBlock ;      //  0-based

        //  success
        return NOERROR ;
    }

    DWORD
    AddBlock_ (
        )
    {
        DWORD   dw ;
        int     i ;
        T *     ptNew ;

        //  allocate the new block
        ptNew = AllocateBlock_ () ;

        if (ptNew) {
            //  initialize to empty
            for (i = 0; i < m_iBlockSize; i++) { ptNew [i] = m_tEmptyVal ; }

            //  append the block to the table
            dw = AppendBlock_ (ptNew) ;

            //  if we failed to append, free the block
            if (dw != NOERROR) {
                FreeBlock_ (ptNew) ;
            }
        }
        else {
            //  failed to allocate memory
            dw = ERROR_NOT_ENOUGH_MEMORY ;
        }

        return dw ;
    }

    protected :

        T *
        AllocateBlock_ (
            )
        {
            return reinterpret_cast <T *> (malloc (m_iBlockSize * sizeof T)) ;
        }

        T **
        AllocateTable_ (
            IN  int iNumEntries
            )
        {
            return reinterpret_cast <T **> (malloc (iNumEntries * sizeof (T *))) ;
        }

        void
        FreeBlock_ (
            IN  T * pBlock
            )
        {
            free (pBlock) ;
        }

        void
        FreeTable_ (
            IN  T **    pptTable
            )
        {
            free (pptTable) ;
        }

    public :

        TCNonDenseVector (
            IN  T   tEmptyVal,
            IN  int iBlockSize
            ) : m_pptTable              (NULL),
                m_iTableRowCountInUse   (0),
                m_tEmptyVal             (tEmptyVal),
                m_iTableRowCountAvail   (0),
                m_iMaxIndexInsert       (-1),
                m_iBlockSize            (iBlockSize) {}

        ~TCNonDenseVector (
            )
        {
            int i ;

            if (m_pptTable) {
                for (i = 0; i < m_iTableRowCountInUse ; i++) {
                    ASSERT (m_pptTable [i]) ;
                    FreeBlock_ (m_pptTable [i]) ;
                }

                FreeTable_ (m_pptTable) ;
            }
        }

        DWORD
        SetVal (
            IN  T   tVal,
            IN  int iIndex
            )
        {
            DWORD   dw ;
            int     iTableRow ;
            int     iBlockIndex ;

            //  add blocks until we have the desired index
            while (GetAllocatedSize_ () < iIndex + 1) {

                dw = AddBlock_ () ;
                if (dw != NOERROR) {
                    return dw ;
                }
            }

            //  compute the table row and row index
            iTableRow   = iIndex / m_iBlockSize ;
            iBlockIndex = iIndex % m_iBlockSize ;

            ASSERT (iTableRow <= m_iTableRowCountAvail) ;
            ASSERT (m_pptTable [iTableRow]) ;

            //  set the value
            m_pptTable [iTableRow] [iBlockIndex] = tVal ;

            //  update max, maybe
            m_iMaxIndexInsert = Max <int> (m_iMaxIndexInsert, iIndex) ;

            return NOERROR ;
        }

        //  returns the number of distinct slot inserts
        int ValCount ()     { return (m_pptTable ? m_iMaxIndexInsert + 1 : 0) ; }

        //  index is chosen as entry following max inserted so far
        DWORD
        AppendVal (
            IN  T       tVal,
            OUT int *   piAppendIndex
            )
        {
            DWORD   dw ;
            int     iAppendIndex ;

            //  iAppendIndex is 0-based
            iAppendIndex = ValCount () ;

            //  set it
            dw = SetVal (
                    tVal,
                    iAppendIndex
                    ) ;

            if (dw == NOERROR &&
                piAppendIndex) {

                //  return the index, if the call was successfull and caller
                //   wants to know
                (* piAppendIndex) = iAppendIndex ;

                ASSERT (iAppendIndex + 1 == ValCount ()) ;
            }

            return dw ;
        }

        //  NOTE: may allocated just to clear .. desired behavior ?
        void ClearVal (IN int iIndex)   { SetVal (iIndex, m_tEmptyVal) ; }

        DWORD
        GetVal (
            IN  int iIndex,
            OUT T * ptRet
            )
        {
            DWORD   dw ;

            if (iIndex + 1 <= GetAllocatedSize_ ()) {
                ASSERT (iIndex / m_iBlockSize <= m_iTableRowCountAvail) ;
                ASSERT (m_pptTable [iIndex / m_iBlockSize]) ;

                (* ptRet) = m_pptTable [iIndex / m_iBlockSize] [iIndex % m_iBlockSize] ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTDynArray
//  ----------------------------------------------------------------------------

template <class T>
class CTDynArray
{
    enum {
        INIT_TABLE_SIZE = 5
    } ;

    T **    m_ppBlockTable ;
    LONG    m_lAllocatedTableSize ;
    LONG    m_lAllocatedBlocks ;
    LONG    m_lAllocQuantum ;
    LONG    m_lMaxArrayLen ;
    LONG    m_lCurArrayLen ;
    LONG    m_lLastInsertSlotIndex ;

    LONG AllocatedArrayLength_ ()           { return m_lAllocatedBlocks * m_lAllocQuantum ; }
    LONG TableIndex_ (IN LONG lArrayIndex)  { return lArrayIndex / m_lAllocQuantum ; }
    LONG BlockIndex_ (IN LONG lArrayIndex)  { return lArrayIndex % m_lAllocQuantum ; }

    LONG NextInsertSlotIndex_ ()
    {
        return (AllocatedArrayLength_ () > 0 ? (m_lLastInsertSlotIndex + m_lCurArrayLen) % AllocatedArrayLength_ () : 0) ;
    }

    LONG FIFOPopIndex_ ()
    {
        return m_lLastInsertSlotIndex ;
    }

    void PostFIFOPopUpdate_ ()
    {
        ASSERT (m_lCurArrayLen > 0) ;
        m_lCurArrayLen-- ;
        m_lLastInsertSlotIndex = (m_lLastInsertSlotIndex + 1) % AllocatedArrayLength_ () ;
    }

    LONG LIFOPopIndex_ ()
    {
        ASSERT (m_lCurArrayLen > 0) ;
        return (m_lLastInsertSlotIndex + m_lCurArrayLen - 1) % AllocatedArrayLength_ () ;
    }

    void PostLIFOPopUpdate_ ()
    {
        ASSERT (m_lCurArrayLen > 0) ;
        m_lCurArrayLen-- ;
    }

    DWORD
    MaybeGrowTable_ (
        )
    {
        LONG    lNewSize ;
        T **    pptNew ;

        if (m_lAllocatedTableSize == m_lAllocatedBlocks) {
            //  need to allocate more table

            lNewSize = (m_lAllocatedTableSize > 0 ? m_lAllocatedTableSize * 2 : INIT_TABLE_SIZE) ;

            pptNew = AllocateTable_ (lNewSize) ;
            if (!pptNew) {
                return ERROR_NOT_ENOUGH_MEMORY ;
            }

            ZeroMemory (pptNew, lNewSize * sizeof (T *)) ;

            if (m_ppBlockTable) {
                ASSERT (m_lAllocatedTableSize > 0) ;
                CopyMemory (
                    pptNew,
                    m_ppBlockTable,
                    m_lAllocatedTableSize * sizeof (T *)
                    ) ;

                FreeTable_ (m_ppBlockTable) ;
            }

            m_ppBlockTable = pptNew ;
            m_lAllocatedTableSize = lNewSize ;
        }

        return NOERROR ;
    }

    T *
    Entry_ (
        IN  LONG    lIndex
        )
    {
        //  should not be asking if it's beyond
        ASSERT (lIndex < AllocatedArrayLength_ ()) ;

        ASSERT (TableIndex_ (lIndex) < m_lAllocatedTableSize) ;
        ASSERT (m_ppBlockTable [TableIndex_ (lIndex)]) ;

        return & m_ppBlockTable [TableIndex_ (lIndex)] [BlockIndex_ (lIndex)] ;
    }

    T
    Val_ (IN LONG lIndex)
    {
        return (* Entry_ (lIndex)) ;
    }

    DWORD
    Append_ (T tVal)
    {
        T *     ptNewBlock ;
        LONG    lNewBlockTableIndex ;
        DWORD   dw ;

        ASSERT (!ArrayMaxed ()) ;

        if ((NextInsertSlotIndex_ () == m_lLastInsertSlotIndex && m_lCurArrayLen > 0) ||
            AllocatedArrayLength_ () == 0) {

            //  table is full; need to allocate

            //  might need to extend the table to hold more blocks
            dw = MaybeGrowTable_ () ;
            if (dw != NOERROR) {
                return dw ;
            }

            ASSERT (m_lAllocatedTableSize > m_lAllocatedBlocks) ;

            //  allocate our new block
            ptNewBlock = AllocateBlock_ () ;
            if (!ptNewBlock) {
                return ERROR_NOT_ENOUGH_MEMORY ;
            }

            //  new block is inserted in table into OutSlotIndex's block; we'll
            //    then move out the OutSlotIndex
            lNewBlockTableIndex = TableIndex_ (m_lLastInsertSlotIndex) ;

            //  init the new block & make room for the new block (if there's
            //    something there now i.e. this is not our first time through)
            if (m_ppBlockTable [lNewBlockTableIndex]) {
                //  copy the contents of the block we're about to move out
                CopyMemory (
                    ptNewBlock,
                    m_ppBlockTable [lNewBlockTableIndex],
                    m_lAllocQuantum * sizeof T
                    ) ;

                //  shift the blocks that follow out
                MoveMemory (
                    & m_ppBlockTable [lNewBlockTableIndex + 1],
                    & m_ppBlockTable [lNewBlockTableIndex],
                    (m_lAllocatedBlocks - lNewBlockTableIndex) * sizeof (T *)
                    ) ;
            }

            //  insert into the table
            m_ppBlockTable [lNewBlockTableIndex] = ptNewBlock ;
            m_lAllocatedBlocks++ ;

            //  shift the OutSlot out, if this is not our first
            m_lLastInsertSlotIndex += (m_lAllocatedBlocks > 1 ? m_lAllocQuantum : 0) ;
        }

        //  append to tail
        (* Entry_ (NextInsertSlotIndex_ ())) = tVal ;
        m_lCurArrayLen++ ;

        return NOERROR ;
    }

    protected :

        T *
        AllocateBlock_ (
            )
        {
            return reinterpret_cast <T *> (malloc (m_lAllocQuantum * sizeof T)) ;
        }

        T **
        AllocateTable_ (
            IN  int iNumEntries
            )
        {
            return reinterpret_cast <T **> (malloc (iNumEntries * sizeof (T *))) ;
        }

        void
        FreeBlock_ (
            IN  T * pBlock
            )
        {
            free (pBlock) ;
        }

        void
        FreeTable_ (
            IN  T **    pptTable
            )
        {
            free (pptTable) ;
        }

    public :

        CTDynArray (
            IN  LONG    lAllocQuantum,
            IN  LONG    lMaxArrayLen = LONG_MAX
            ) : m_lAllocQuantum         (lAllocQuantum),
                m_lAllocatedBlocks      (0),
                m_lAllocatedTableSize   (0),
                m_ppBlockTable          (NULL),
                m_lMaxArrayLen          (lMaxArrayLen),
                m_lCurArrayLen          (0),
                m_lLastInsertSlotIndex  (0) {}

        ~CTDynArray (
            )
        {
            LONG    l ;

            for (l = 0; l < m_lAllocatedBlocks; l++) {
                FreeBlock_ (m_ppBlockTable [l]) ;
            }

            FreeTable_ (m_ppBlockTable) ;
        }

        LONG Length ()      { return m_lCurArrayLen ; }
        BOOL ArrayMaxed ()  { return (m_lCurArrayLen < m_lMaxArrayLen ? FALSE : TRUE) ; }
        BOOL Empty ()       { return (Length () > 0 ? FALSE : TRUE) ; }

        DWORD Push (IN T tVal)
        {
            DWORD   dw ;

            if (!ArrayMaxed ()) {
                dw = Append_ (tVal) ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD PopFIFO (OUT T * pt)
        {
            DWORD   dw ;

            if (m_lCurArrayLen > 0) {
                (* pt) = Val_ (FIFOPopIndex_ ()) ;
                PostFIFOPopUpdate_ () ;
                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD PopLIFO (OUT T * pt)
        {
            DWORD   dw ;

            if (m_lCurArrayLen > 0) {

                (* pt) = Val_ (LIFOPopIndex_ ()) ;
                PostLIFOPopUpdate_ () ;
                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTDynQueue
//  ----------------------------------------------------------------------------

template <class T>
class CTDynQueue :
    public CTDynArray <T>
{
    public :

        CTDynQueue (
            IN  LONG    lAllocQuantum,
            IN  LONG    lMaxQueueLen = LONG_MAX
            ) : CTDynArray <T> (lAllocQuantum,
                                lMaxQueueLen) {}

        DWORD Pop (OUT T * pt)
        {
            return PopFIFO (pt) ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTDynStack
//  ----------------------------------------------------------------------------

template <class T>
class CTDynStack :
    public CTDynArray <T>
{
    public :

        CTDynStack (
            IN  LONG    lAllocQuantum,
            IN  LONG    lMaxQueueLen = LONG_MAX
            ) : CTDynArray <T> (lAllocQuantum,
                                lMaxQueueLen) {}

        DWORD Pop (OUT T * pt)
        {
            return PopLIFO (pt) ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTQueue
//  ----------------------------------------------------------------------------

template <class T>
class CTQueue
{
    T *     m_pQueue ;
    LONG    m_lMaxQueueLen ;
    LONG    m_lQueueLen ;
    LONG    m_lHead ;

    LONG TailIndex_ ()
    {
        return ((m_lHead + m_lQueueLen) % m_lMaxQueueLen) ;
    }

    public :

        CTQueue (
            IN  T *     pQueue,
            IN  LONG    lMaxQueueLen
            ) : m_pQueue        (pQueue),
                m_lMaxQueueLen  (lMaxQueueLen),
                m_lHead         (0),
                m_lQueueLen     (0)

        {
            ASSERT (m_pQueue) ;
            ZeroMemory (m_pQueue, m_lMaxQueueLen * sizeof T) ;
        }

        LONG Length ()      { return m_lQueueLen ; }
        BOOL Full ()        { return (m_lQueueLen < m_lMaxQueueLen ? FALSE : TRUE) ; }
        BOOL Empty ()       { return (Length () > 0 ? FALSE : TRUE) ; }

        DWORD Push (IN T tVal)
        {
            DWORD   dw ;

            if (!Full ()) {
                m_pQueue [TailIndex_ ()] = tVal ;
                m_lQueueLen++ ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD Pop (OUT T * pt)
        {
            DWORD   dw ;

            if (m_lQueueLen > 0) {
                (* pt) = m_pQueue [m_lHead] ;
                m_lHead = (m_lHead + 1) % m_lMaxQueueLen ;
                m_lQueueLen-- ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }
} ;

template <class T,
          LONG lMax
          >
class CTSizedQueue :
    public CTQueue <T>
{
    T   m_Queue [lMax] ;

    public :

        CTSizedQueue (
            ) : CTQueue <T> (m_Queue, lMax) {}
} ;

//  ----------------------------------------------------------------------------
//      CDataCache
//  ----------------------------------------------------------------------------

class CDataCache
{
    BYTE *  m_pbCache ;
    BYTE *  m_pbCurrent ;
    int     m_iCacheSize ;

    public :

        CDataCache (
            IN  BYTE *  pbCache,
            IN  int     iCacheSize
            ) : m_pbCache       (pbCache),
                m_iCacheSize    (iCacheSize),
                m_pbCurrent     (pbCache) {}

        int CurCacheSize ()     { return (int) (m_pbCurrent - m_pbCache) ; }
        int CacheRemaining ()   { return m_iCacheSize - CurCacheSize () ; }
        BYTE * Get ()           { return m_pbCache ; }
        void Reset ()           { m_pbCurrent = m_pbCache ; }
        BOOL IsEmpty ()         { return CurCacheSize () == 0 ; }

        BOOL
        Append (
            IN  BYTE *  pb,
            IN  int     iLength
            )
        {
            if (iLength <= CacheRemaining ()) {
                CopyMemory (
                    m_pbCurrent,
                    pb,
                    iLength
                    ) ;

                m_pbCurrent += iLength ;
                return TRUE ;
            }
            else {
                return FALSE ;
            }
        }
} ;

template <int iCacheSize>
class TSizedDataCache :
    public CDataCache
{
    BYTE    m_pbCache [iCacheSize] ;

    public :

        TSizedDataCache (
            ) : CDataCache (
                    m_pbCache,
                    iCacheSize
                    ) {}
} ;

//  ----------------------------------------------------------------------------
//      TStructPool
//  ----------------------------------------------------------------------------

template <class T, DWORD dwAllocationQuantum = 5>
class TStructPool
{
    template <class T>
    struct CONTAINER
    {
        LIST_ENTRY  ListEntry ;
        DWORD       dwIndex ;
        T           Object ;

        static
        CONTAINER <T> *
        RecoverContainer (
            IN  T * pObject
            )
        {
            CONTAINER <T> * pContainer ;
            pContainer = CONTAINING_RECORD (pObject, CONTAINER <T>, Object) ;
            return pContainer ;
        }
    } ;

    template <class T>
    struct ALLOCATION_UNIT {
        LIST_ENTRY      ListEntry ;
        DWORD           dwInUseCount ;
        CONTAINER <T>   Container [dwAllocationQuantum] ;
    } ;

    LIST_ENTRY          m_AllocationUnits ;
    LIST_ENTRY          m_FreeList ;
    LIST_ENTRY          m_InUseList ;
    DWORD               m_dwTotalFreeCount ;

    ALLOCATION_UNIT <T> *
    GetOwningAllocationUnit_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        ALLOCATION_UNIT <T> * pAllocationUnit ;

        pAllocationUnit = CONTAINING_RECORD (pContainer, ALLOCATION_UNIT <T>, Container [pContainer -> dwIndex]) ;
        return pAllocationUnit ;
    }

    void
    InitializeAllocationUnit_ (
        IN  ALLOCATION_UNIT <T> *   pNewAllocationUnit
        )
    {
        DWORD   i ;

        for (i = 0; i < dwAllocationQuantum; i++) {
            pNewAllocationUnit -> Container [i].dwIndex = i ;
            InsertHeadList (& m_FreeList, & (pNewAllocationUnit -> Container [i].ListEntry)) ;
            m_dwTotalFreeCount++ ;
        }

        InsertHeadList (& m_AllocationUnits, & (pNewAllocationUnit -> ListEntry)) ;

        pNewAllocationUnit -> dwInUseCount = 0 ;
    }

    void
    MaybeRecycleAllocationUnit_ (
        IN  ALLOCATION_UNIT <T> *   pAllocationUnit
        )
    {
        DWORD   i ;

        if (pAllocationUnit -> dwInUseCount == 0 &&
            m_dwTotalFreeCount > dwAllocationQuantum) {

            for (i = 0; i < dwAllocationQuantum; i++) {
                FreeListPop_ (& (pAllocationUnit -> Container [i])) ;
            }

            RemoveEntryList (& (pAllocationUnit -> ListEntry)) ;

            delete pAllocationUnit ;
        }
    }

    void
    FreeListPush_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        InsertHeadList (& m_FreeList, & (pContainer -> ListEntry)) ;
        m_dwTotalFreeCount++ ;
    }

    void
    FreeListPop_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        RemoveEntryList (& (pContainer -> ListEntry)) ;
        m_dwTotalFreeCount-- ;
    }

    CONTAINER <T> *
    FreeListPop_ (
        )
    {
        LIST_ENTRY *    pListEntry ;
        CONTAINER <T> * pContainer ;

        if (IsListEmpty (& m_FreeList) == FALSE) {
            pListEntry = RemoveHeadList (& m_FreeList) ;
            m_dwTotalFreeCount-- ;

            pContainer = CONTAINING_RECORD (pListEntry, CONTAINER <T>, ListEntry) ;
            return pContainer ;
        }
        else {
            return NULL ;
        }
    }

    void
    InUseListPop_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        RemoveEntryList (& pContainer -> ListEntry) ;
    }

    void
    InUseListPush_ (
        IN  CONTAINER <T> * pContainer
        )
    {
        InsertHeadList (& m_InUseList, & (pContainer -> ListEntry)) ;
    }

    public :

        TStructPool (
            ) : m_dwTotalFreeCount (0)
        {
            InitializeListHead (& m_AllocationUnits) ;
            InitializeListHead (& m_FreeList) ;
            InitializeListHead (& m_InUseList) ;
        }

        ~TStructPool (
            )
        {
            ALLOCATION_UNIT <T> *   pAllocationUnit ;
            LIST_ENTRY *            pListEntry ;

            while (IsListEmpty (& m_AllocationUnits) == FALSE) {
                pListEntry = RemoveHeadList (& m_AllocationUnits) ;
                pAllocationUnit = CONTAINING_RECORD (pListEntry, ALLOCATION_UNIT <T>, ListEntry) ;
                delete pAllocationUnit ;
            }
        }

        T *
        Get (
            )
        {
            ALLOCATION_UNIT <T> *   pAllocationUnit ;
            CONTAINER <T> *         pContainer ;

            pContainer = FreeListPop_ () ;
            if (pContainer == NULL) {

                pAllocationUnit = new ALLOCATION_UNIT <T> ;
                if (pAllocationUnit == NULL) {
                    return NULL ;
                }

                InitializeAllocationUnit_ (pAllocationUnit) ;
                ASSERT (IsListEmpty (& m_FreeList) == FALSE) ;

                pContainer = FreeListPop_ () ;
            }

            ASSERT (pContainer) ;

            GetOwningAllocationUnit_ (pContainer) -> dwInUseCount++ ;
            InUseListPush_ (pContainer) ;

            return & (pContainer -> Object) ;
        }

        void
        Recycle (
            IN  T * pObject
            )
        {
            CONTAINER <T> *         pContainer ;
            ALLOCATION_UNIT <T> *   pAllocationUnit ;

            pContainer = CONTAINER <T>::RecoverContainer (pObject) ;

            InUseListPop_ (pContainer) ;
            FreeListPush_ (pContainer) ;

            pAllocationUnit = GetOwningAllocationUnit_ (pContainer) ;
            pAllocationUnit -> dwInUseCount-- ;

            MaybeRecycleAllocationUnit_ (pAllocationUnit) ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTSmallMap
//  ----------------------------------------------------------------------------

//  BUGBUG: fixme
template <
    class tKey,     //  <, >, == operators must work
    class tVal      //  = operator must work
    >
class CTSmallMap
{
    struct MAP_REF {
        tKey        key ;
        tVal        val ;
        MAP_REF *   pNext ;
    } ;

    TStructPool <MAP_REF>   m_MapRefPool ;
    MAP_REF *               m_pHead ;

    void
    Insert_ (
        IN  MAP_REF *   pMapRefNew
        )
    {
        MAP_REF **  ppCur ;

        ppCur = & m_pHead ;

        for (;;) {
            if (* ppCur) {
                if (pMapRefNew -> val <= (* ppCur) -> val) {
                    break ;
                }

                ppCur = & (* ppCur) -> pNext ;
            }
            else {
                break ;
            }
        }

        pMapRefNew -> pNext = (* ppCur) ;
        (* ppCur)           = pMapRefNew ;
    }

    public :

        CTSmallMap (
            ) : m_pHead (NULL) {}

        ~CTSmallMap (
            )
        {
            MAP_REF *   pDel ;

            while (m_pHead) {
                //  remove the head
                pDel = m_pHead ;
                m_pHead = m_pHead -> pNext ;

                m_MapRefPool.Recycle (pDel) ;
            }
        }

        BOOL
        Find (
            IN  tKey    key,
            OUT tVal *  ptVal
            )
        {
            MAP_REF *   pCur ;
            BOOL        r ;

            pCur = m_pHead ;

            r = FALSE ;

            while (pCur) {
                if (pCur -> key == key) {
                    (* ptVal) = pCur -> val ;
                    r = TRUE ;
                    break ;
                }

                pCur = pCur -> pNext ;
            }

            return r ;
        }

        BOOL
        CreateMap (
            IN  tKey    key,
            IN  tVal    val
            )
        {
            MAP_REF *   pMapRef ;
            BOOL        r ;
            tVal        valTmp ;

            r = Find (key, & valTmp) ;
            if (!r) {
                pMapRef = m_MapRefPool.Get () ;
                if (pMapRef) {
                    pMapRef -> key = key ;
                    pMapRef -> val = val ;

                    Insert_ (pMapRef) ;

                    //  success
                    r = TRUE ;
                }
                else {
                    //  memory allocation error
                    r = FALSE ;
                }
            }
            else {
                //  no duplicates allowed !!
                r = FALSE ;
            }

            return r ;
        }
} ;

//  ----------------------------------------------------------------------------
//  TCObjPool
//  ----------------------------------------------------------------------------

template <
    class T,
    T * Recover (IN LIST_ENTRY * ple)
    >
static
T *
ListHeadPop (
    IN  LIST_ENTRY *    pleHead
    )
{
    LIST_ENTRY *    pleItem ;
    T *             pt ;

    if (!IsListEmpty (pleHead)) {
        pleItem = pleHead -> Flink ;
        RemoveEntryList (pleItem) ;

        pt = Recover (pleItem) ;
    }
    else {
        pt = NULL ;
    }

    return pt ;
}

template <class T>
class TCProducerConsumer
{
    struct OBJ_CONTAINER {
        T           tObj ;
        LIST_ENTRY  ListEntry ;

        static OBJ_CONTAINER * Recover (IN LIST_ENTRY * ple)
        {
            OBJ_CONTAINER * pObj ;
            pObj = CONTAINING_RECORD (ple, OBJ_CONTAINER, ListEntry) ;
            return pObj ;
        }
    } ;

    struct OBJ_REQUEST {
        HANDLE          hEvent ;
        DWORD           dwRetVal ;
        T               tObj ;
        LIST_ENTRY      ListEntry ;

        static OBJ_REQUEST * Recover (IN LIST_ENTRY * ple)
        {
            OBJ_REQUEST *   pObj ;
            pObj = CONTAINING_RECORD (ple, OBJ_REQUEST, ListEntry) ;
            return pObj ;
        }
    } ;

    CRITICAL_SECTION    m_crt ;
    LIST_ENTRY          m_PoolContainer ;
    LIST_ENTRY          m_PoolRequest ;
    LIST_ENTRY          m_AvailObj ;
    LIST_ENTRY          m_RequestQueue ;
    int                 m_iRequestQueueLen ;
    int                 m_iAvailCount ;
    int                 m_iPoolMaxContainers ;
    int                 m_iPoolContainers ;
    int                 m_iPoolMaxRequests ;
    int                 m_iPoolRequests ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    void SatisfyRequest_ (IN OBJ_REQUEST * pObjRequest, IN T tItem)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest -> tObj     = tItem ;
        pObjRequest -> dwRetVal = NOERROR ;

        SetEvent (pObjRequest -> hEvent) ;
    }

    void RequestPoolPush_ (IN OBJ_REQUEST * pObjRequest)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        if (m_iPoolRequests < m_iPoolMaxRequests) {
            InsertHeadList (& m_PoolRequest, & pObjRequest -> ListEntry) ;
            m_iPoolRequests++ ;
        }
        else {
            delete pObjRequest ;
        }
    }

    OBJ_REQUEST * RequestPoolPop_ ()
    {
        OBJ_REQUEST *   pObjRequest ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest = ListHeadPop <OBJ_REQUEST, OBJ_REQUEST::Recover> (& m_PoolRequest) ;
        if (pObjRequest) {
            ASSERT (m_iPoolRequests > 0) ;
            m_iPoolRequests-- ;
        }

        return pObjRequest ;
    }

    void ContainerPoolPush_ (IN OBJ_CONTAINER * pObjContainer)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        if (m_iPoolContainers < m_iPoolMaxContainers) {
            m_iPoolContainers++ ;
            InsertHeadList (& m_PoolContainer, & pObjContainer -> ListEntry) ;
        }
        else {
            delete pObjContainer ;
        }
    }

    OBJ_CONTAINER * ContainerAvailPop_ ()
    {
        OBJ_CONTAINER * pObjContainer ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjContainer = ListHeadPop <OBJ_CONTAINER, OBJ_CONTAINER::Recover> (& m_AvailObj) ;
        if (pObjContainer) {
            ASSERT (m_iAvailCount > 0) ;
            m_iAvailCount-- ;
        }

        return pObjContainer ;
    }

    void ContainerAvailPush_ (OBJ_CONTAINER * pObjContainer)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        m_iAvailCount++ ;
        InsertHeadList (& m_AvailObj, & pObjContainer -> ListEntry) ;
    }

    OBJ_CONTAINER * ContainerPoolPop_ ()
    {
        OBJ_CONTAINER * pObjContainer ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjContainer = ListHeadPop <OBJ_CONTAINER, OBJ_CONTAINER::Recover> (& m_PoolContainer) ;
        if (pObjContainer) {
            ASSERT (m_iPoolContainers > 0) ;
            m_iPoolContainers-- ;
        }

        return pObjContainer ;
    }

    OBJ_REQUEST * GetRequestObj_ ()
    {
        OBJ_REQUEST *   pObjRequest ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest = RequestPoolPop_ () ;
        if (!pObjRequest) {
            pObjRequest = new OBJ_REQUEST ;
            if (pObjRequest) {
                pObjRequest -> hEvent = CreateEvent (NULL, TRUE, FALSE, NULL) ;
                if (pObjRequest -> hEvent == NULL) {
                    delete pObjRequest ;
                    pObjRequest = NULL ;
                }
            }
        }
        else {
            ResetEvent (pObjRequest -> hEvent) ;
        }

        return pObjRequest ;
    }

    OBJ_CONTAINER * GetContainerObj_ ()
    {
        OBJ_CONTAINER * pObjContainer ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjContainer = ContainerPoolPop_ () ;
        if (!pObjContainer) {
            pObjContainer = new OBJ_CONTAINER ;
        }

        return pObjContainer ;
    }

    void RequestQueuePush_ (IN OBJ_REQUEST * pObjRequest)
    {
        ASSERT (LOCK_HELD (& m_crt)) ;

        InsertTailList (& m_RequestQueue, & pObjRequest -> ListEntry) ;
        m_iRequestQueueLen++ ;
    }

    OBJ_REQUEST * RequestQueuePop_ ()
    {
        OBJ_REQUEST *   pObjRequest ;

        ASSERT (LOCK_HELD (& m_crt)) ;

        pObjRequest = ListHeadPop <OBJ_REQUEST, OBJ_REQUEST::Recover> (& m_RequestQueue) ;
        if (pObjRequest) {
            m_iRequestQueueLen-- ;
        }

        return pObjRequest ;
    }

    public :

        TCProducerConsumer (
            IN  int iPoolMaxContainers  = INT_MAX,
            IN  int iPoolMaxRequests    = INT_MAX
            ) : m_iAvailCount           (0),
                m_iRequestQueueLen      (0),
                m_iPoolMaxRequests      (iPoolMaxRequests),
                m_iPoolRequests         (0),
                m_iPoolMaxContainers    (iPoolMaxContainers),
                m_iPoolContainers       (0)
        {
            InitializeCriticalSection (& m_crt) ;

            InitializeListHead (& m_PoolContainer) ;
            InitializeListHead (& m_PoolRequest) ;
            InitializeListHead (& m_AvailObj) ;
            InitializeListHead (& m_RequestQueue) ;
        }

        ~TCProducerConsumer (
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            OBJ_REQUEST *   pObjRequest ;

            ASSERT (IsListEmpty (& m_RequestQueue)) ;
            ASSERT (IsListEmpty (& m_AvailObj)) ;

            Lock_ () ;

            pObjRequest = RequestPoolPop_ () ; ;
            while (pObjRequest) {
                CloseHandle (pObjRequest -> hEvent) ;
                delete pObjRequest ;

                pObjRequest = RequestPoolPop_ () ; ;
            }

            pObjContainer = ContainerPoolPop_ () ;
            while (pObjContainer) {
                delete pObjContainer ;
                pObjContainer = ContainerPoolPop_ () ;
            }

            Unlock_ () ;

            ASSERT (m_iPoolContainers == 0) ;
            ASSERT (m_iPoolRequests == 0) ;

            DeleteCriticalSection (& m_crt) ;
        }

        DWORD
        Pop (
            OUT T * ptItem
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            OBJ_REQUEST *   pObjRequest ;
            DWORD           dw ;
            DWORD           r ;

            Lock_ () ;

            pObjContainer = ContainerAvailPop_ () ;
            if (!pObjContainer) {
                pObjRequest = GetRequestObj_ () ;

                if (pObjRequest) {
                    RequestQueuePush_ (pObjRequest) ;
                    Unlock_ () ;

                    r = WaitForSingleObject (pObjRequest -> hEvent, INFINITE) ;

                    if (r == WAIT_OBJECT_0) {

                        Lock_ () ;

                        dw = pObjRequest -> dwRetVal ;
                        if (dw == NOERROR) {
                            (* ptItem) = pObjRequest -> tObj ;
                        }
                    }
                    else {
                        dw = ERROR_GEN_FAILURE ;

                        Lock_ () ;
                    }

                    RequestPoolPush_ (pObjRequest) ;
                }
                else {
                    dw = ERROR_GEN_FAILURE ;
                }
            }
            else {
                (* ptItem) = pObjContainer -> tObj ;
                ContainerPoolPush_ (pObjContainer) ;

                dw = NOERROR ;
            }

            Unlock_ () ;

            return dw ;
        }

        DWORD
        TryPop (
            OUT T * ptItem
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            DWORD           dw ;

            Lock_ () ;

            pObjContainer = ContainerAvailPop_ () ;
            if (pObjContainer) {
                (* ptItem) = pObjContainer -> tObj ;
                ContainerPoolPush_ (pObjContainer) ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            Unlock_ () ;

            return dw ;
        }

        DWORD
        Push (
            IN  T   tItem
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            OBJ_REQUEST *   pObjRequest ;
            DWORD           dw ;

            Lock_ () ;

            pObjRequest = RequestQueuePop_ () ;
            if (pObjRequest) {
                SatisfyRequest_ (pObjRequest, tItem) ;

                dw = NOERROR ;
            }
            else {
                pObjContainer = GetContainerObj_ () ;
                if (pObjContainer) {
                    pObjContainer -> tObj = tItem ;
                    ContainerAvailPush_ (pObjContainer) ;

                    dw = NOERROR ;
                }
                else {
                    dw = ERROR_GEN_FAILURE ;
                }
            }

            Unlock_ () ;

            return dw ;
        }

        //  all non-blocking - instantaneous values
        int AvailCount ()           { return m_iAvailCount ; }
        int RequestQueueLength ()   { return m_iRequestQueueLen ; }
        int ContainerPool ()        { return m_iPoolContainers ; }
        int RequestPool ()          { return m_iPoolRequests ; }
} ;

//  ----------------------------------------------------------------------------
//      TCDenseVector
//  ----------------------------------------------------------------------------

template <class T>
class TCDenseVector
/*++
    simple dense vector template;
    allocates from a specified heap or the process heap (default);
    grows and shrinks (reallocates) as required, as values are added and
      deleted;
    does not sort in any manner;
    can add member randomly; appending is most efficient
    can remove members randomly; deleted from end is most efficient
--*/
{
    //  default values
    enum {
        DEF_INITIAL_SIZE        = 4,    //  initialize size
        DEF_RESIZE_MULTIPLIER   = 2     //  multiplier/divisor of size
    } ;

    T *                 m_pVector ;                 //  vector of objects
    DWORD               m_cElements ;               //  number of elements; <= m_dwMaxSize
    DWORD               m_dwResizeMultiplier ;      //  resize/shrink multiplier/divisor
    DWORD               m_dwInitialSize ;           //  first allocation
    HANDLE              m_hHeap ;                   //  heap handle (not duplicated !)
    DWORD               m_dwMaxSize ;               //  current max size of vector
    CRITICAL_SECTION    m_crt ;                     //  used in the Lock/Unlock methods

    void
    MaybeGrow_ (
        )
    /*++
    --*/
    {
        T *     pNewVector ;
        DWORD   dwNewSize ;

        ASSERT (m_hHeap) ;

        //  if we're maxed out, grow the vector
        if (m_cElements == m_dwMaxSize) {

            if (m_pVector) {
                //  we've been called before, time to realloc

                ASSERT (m_dwMaxSize > 0) ;
                dwNewSize = m_dwResizeMultiplier * m_dwMaxSize ;

                pNewVector = reinterpret_cast <T *> (HeapReAlloc (
                                                        m_hHeap,
                                                        HEAP_GENERATE_EXCEPTIONS,
                                                        m_pVector,
                                                        dwNewSize * sizeof T
                                                        )) ;
            }
            else {
                //  this is the first time we are allocating
                dwNewSize = m_dwInitialSize ;

                pNewVector = reinterpret_cast <T *> (HeapAlloc (
                                                        m_hHeap,
                                                        HEAP_GENERATE_EXCEPTIONS,
                                                        dwNewSize * sizeof T
                                                        )) ;
            }

            //  specifying HEAP_GENERATE_EXCEPTIONS in the above calls ensures
            //  that the system will have raised an exception if there's
            //  insufficient memory
            ASSERT (pNewVector) ;

            //  reset array pointer and set the max size
            m_pVector = pNewVector ;
            m_dwMaxSize = dwNewSize ;
        }

        return ;
    }

    void
    MaybeShrink_ (
        )
    {
        T *     pNewVector ;
        DWORD   dwNewSize ;

        ASSERT (m_pVector) ;
        ASSERT (m_dwMaxSize > 0) ;
        ASSERT (m_dwResizeMultiplier > 0) ;
        ASSERT (m_hHeap) ;

        //  if we fall below the threshold, but are bigger than smallest size,
        //  try to realloc
        if (m_cElements >= m_dwInitialSize &&
            m_cElements <= (m_dwMaxSize / m_dwResizeMultiplier)) {

            dwNewSize = m_dwMaxSize / m_dwResizeMultiplier ;

            pNewVector = reinterpret_cast <T *> (HeapReAlloc (
                                                    m_hHeap,
                                                    HEAP_GENERATE_EXCEPTIONS,
                                                    m_pVector,
                                                    dwNewSize * sizeof T
                                                    )) ;

            //  specifying HEAP_GENERATE_EXCEPTIONS in the above calls ensures
            //  that the system will have raised an exception if there's
            //  insufficient memory
            ASSERT (pNewVector) ;

            //  reset array pointer and set the max size
            m_dwMaxSize = dwNewSize ;
            m_pVector = pNewVector ;
        }

        return ;
    }

    public :

        TCDenseVector (
            IN  HANDLE      hHeap               = NULL,                     //  could specify the heap handle
            IN  DWORD       dwInitialSize       = DEF_INITIAL_SIZE,         //  initial entries allocation
            IN  DWORD       dwResizeMultiplier  = DEF_RESIZE_MULTIPLIER     //  resize multiplier/divisor
            ) : m_pVector               (NULL),
                m_dwResizeMultiplier    (dwResizeMultiplier),
                m_dwInitialSize         (dwInitialSize),
                m_dwMaxSize             (0),
                m_cElements             (0),
                m_hHeap                 (hHeap)
        {
            //  if no heap was specified, grab the process' heap handle
            if (m_hHeap == NULL) {
                m_hHeap = GetProcessHeap () ;
            }

            InitializeCriticalSection (& m_crt) ;

            ASSERT (m_hHeap) ;
            ASSERT (dwResizeMultiplier > 0) ;
            ASSERT (dwInitialSize > 0) ;
        }

        ~TCDenseVector (
            )
        {
            //  there's nothing in the docs that says m_pVector can be NULL
            //  when calling HeapFree..
            if (m_pVector) {
                ASSERT (m_hHeap != NULL) ;
                HeapFree (
                    m_hHeap,
                    NULL,
                    m_pVector
                    ) ;
            }

            DeleteCriticalSection (& m_crt) ;
        }

        _inline
        const
        DWORD
        GetCount (
            )
        //  returns the number of elements currently in the vector
        {
            return m_cElements ;
        }

        __inline
        T *
        const
        GetVector (
            )
        //  returns the vector itself; caller then has direct access to the
        //  memory
        {
            return m_pVector ;
        }

        __inline
        void
        GetVector (
            OUT T **    ppT,
            OUT DWORD * pcElements
            )
        {
            ASSERT (ppT) ;
            ASSERT (pcElements) ;

            * ppT = m_pVector ;
            * pcElements = m_cElements ;
        }

        T
        operator [] (
            IN  DWORD   dwIndex
            )
        {
            T       t ;
            HRESULT hr ;

            hr = Get (dwIndex, & t) ;
            if (SUCCEEDED (hr)) {
                return t ;
            }
            else {
                return 0 ;
            }
        }

        __inline
        void
        Lock (
            )
        {
            EnterCriticalSection (& m_crt) ;
        }

        __inline
        void
        Unlock (
            )
        {
            LeaveCriticalSection (& m_crt) ;
        }

        __inline
        HRESULT
        const
        Get (
            IN  DWORD   dwIndex,
            OUT T *     pValue
            )
        //  returns the dwIndex'th element in the vector
        {
            ASSERT (pValue) ;

            if (dwIndex >= m_cElements) {
                return E_INVALIDARG ;
            }

            * pValue = m_pVector [dwIndex] ;

            return S_OK ;
        }

        HRESULT
        Append (
            IN  T       Value,
            OUT DWORD * pcTotalElements = NULL
            )
        /*++
            Purpose:

                Appends a new value to the end of the vector.  Optionally returns
                the number of elements in the vector.

            Parameters:

                Value               new item

                pcTotalElements     optional OUT parameter to return the number
                                      of elements in the vector AFTER the call;
                                      valid only if the call is successfull

            Return Values:

                S_OK                success
                E_OUTOFMEMORY       the vector is maxed and the memory reallocation
                                      failed

        --*/
        {
            return Insert (m_cElements,
                           Value,
                           pcTotalElements) ;
        }

        HRESULT
        Insert (
            IN  DWORD   dwIndex,
            IN  T       Value,
            OUT DWORD * pcTotalElements = NULL
            )
        /*++
            Purpose:

                Insert a new value at the specified Index

            Parameters:

                dwIndex             0-based index to the position where the
                                      new item should be inserted

                Value               new item

                pcTotalElements     optional OUT parameter to return the number
                                      of elements in the vector after the call;
                                      valid only if successfull

            Return Values:

                S_OK                success

                E_OUTOFMEMORY       the vector is maxed and the memory
                                      reallocation failed

                E_INVALIDARG        the specified index is out of range of the
                                      current contents of the vector; the min
                                      valid value is 0, and the max valid value
                                      is after the last elemtn

        --*/
        {
            //  make sure we're not going to insert off the end of the vector;
            //  m_cElements is the max valid index for a new element (in which
            //  case we are appending)
            if (dwIndex > m_cElements) {
                return E_INVALIDARG ;
            }

            //  if we didn't get this when we instantiated, we try again
            if (m_hHeap == NULL) {
                m_hHeap = GetProcessHeap () ;
                if (m_hHeap == NULL) {
                    return E_OUTOFMEMORY ;
                }
            }

            //  frame this in a try-except block to catch out-of-memory
            //  exceptions
            __try {
                MaybeGrow_ () ;
            }
            __except (GetExceptionCode () == STATUS_NO_MEMORY ||
                      GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                      EXCEPTION_EXECUTE_HANDLER :
                      EXCEPTION_CONTINUE_SEARCH) {

                return E_OUTOFMEMORY ;
            }

            //  the only failure to MaybeGrow_ is a win32 exception, so if we
            //  get to here, we've got the memory we need
            ASSERT (m_cElements < m_dwMaxSize) ;
            ASSERT (m_pVector) ;

            //  if there are elements to move, and we're not just appending, move
            //  the remaining elements out to make room
            if (m_cElements > 0 &&
                dwIndex < m_cElements) {

                //  expand
                MoveMemory (
                    & m_pVector [dwIndex + 1],
                    & m_pVector [dwIndex],
                    (m_cElements - dwIndex) * sizeof T
                    ) ;
            }

            //  insert the new item
            m_pVector [dwIndex] = Value ;
            m_cElements++ ;

            //  if the caller wants to know size, set that now
            if (pcTotalElements) {
                * pcTotalElements = m_cElements ;
            }

            return S_OK ;
        }

        HRESULT
        Remove (
            IN  DWORD   dwIndex,
            OUT T *     pValue = NULL
            )
        /*++
            Purpose:

                Removes an item at the specified 0-based index.  Optionally returns
                the value in the [out] parameter.

            Parameters:

                dwIndex     0-based index

                pValue      optional pointer to a value to obtain what was removed

            Return Values:

                S_OK            success

                E_INVALIDARG    an out-of-range index was specified

        --*/
        {
            ASSERT (m_hHeap != NULL) ;

            //  dwIndex is 0-based
            if (dwIndex >= m_cElements) {
                return E_INVALIDARG ;
            }

            //  if caller wants to get the Remove'd value, set it now
            if (pValue) {
                * pValue = m_pVector [dwIndex] ;
            }

            //  compact the remaining elements, unless we're removing the last element
            //  check above ensures that subtracting 1 does not wrap
            if (dwIndex < m_cElements - 1) {

                //  compact
                MoveMemory (
                        & m_pVector [dwIndex],
                        & m_pVector [dwIndex + 1],
                        (m_cElements - 1 - dwIndex) * sizeof T
                        ) ;
            }

            m_cElements-- ;

            __try {
                MaybeShrink_ () ;
            }
            __except (GetExceptionCode () == STATUS_NO_MEMORY ||
                      GetExceptionCode () == STATUS_ACCESS_VIOLATION ?
                      EXCEPTION_EXECUTE_HANDLER :
                      EXCEPTION_CONTINUE_SEARCH) {

                //  fail silently; we still have the memory we had before
            }

            return S_OK ;
        }
} ;

//  ----------------------------------------------------------------------------

//  shamelessly stolen from amfilter.h & amfilter.cpp
class CMediaSampleWrapper :
    public IMediaSample2    // The interface we support
{

protected:

    friend class CPooledMediaSampleWrapper ;

    virtual void Recycle_ () { delete this ; }

    /*  Values for dwFlags - these are used for backward compatiblity
        only now - use AM_SAMPLE_xxx
    */
    enum { Sample_SyncPoint       = 0x01,   /* Is this a sync point */
           Sample_Preroll         = 0x02,   /* Is this a preroll sample */
           Sample_Discontinuity   = 0x04,   /* Set if start of new segment */
           Sample_TypeChanged     = 0x08,   /* Has the type changed */
           Sample_TimeValid       = 0x10,   /* Set if time is valid */
           Sample_MediaTimeValid  = 0x20,   /* Is the media time valid */
           Sample_TimeDiscontinuity = 0x40, /* Time discontinuity */
           Sample_StopValid       = 0x100,  /* Stop time valid */
           Sample_ValidFlags      = 0x1FF
         };

    /* Properties, the media sample class can be a container for a format
       change in which case we take a copy of a type through the SetMediaType
       interface function and then return it when GetMediaType is called. As
       we do no internal processing on it we leave it as a pointer */

    DWORD            m_dwFlags;         /* Flags for this sample */
                                        /* Type specific flags are packed
                                           into the top word
                                        */
    DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */
    LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */
    LONG             m_lActual;         /* Length of data in this sample */
    LONG             m_cbBuffer;        /* Size of the buffer */
    REFERENCE_TIME   m_Start;           /* Start sample time */
    REFERENCE_TIME   m_End;             /* End sample time */
    LONGLONG         m_MediaStart;      /* Real media start position */
    LONG             m_MediaEnd;        /* A difference to get the end */
    AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */
    DWORD            m_dwStreamId;      /* Stream id */

    IUnknown *      m_pIMSCore ;

public:
    LONG             m_cRef;            /* Reference count */


public:

    CMediaSampleWrapper();

    virtual ~CMediaSampleWrapper();

    /* Note the media sample does not delegate to its owner */

    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  ========================================================================

    DWORD   GetTypeSpecificFlags ()                 { return m_dwTypeSpecificFlags ; }
    void    SetTypeSpecificFlags (IN DWORD dw)      { m_dwTypeSpecificFlags = dw ; }

    void Reset_ () ;

    HRESULT
    Init (
        IN  IUnknown *  pIMS,
        IN  BYTE *      pbPayload,
        IN  LONG        lPayloadLength
        ) ;

    HRESULT
    Init (
        IN  BYTE *  pbPayload,
        IN  LONG    lPayloadLength
        ) ;

    //  ========================================================================

    // set the buffer pointer and length. Used by allocators that
    // want variable sized pointers or pointers into already-read data.
    // This is only available through a CMediaSampleWrapper* not an IMediaSample*
    // and so cannot be changed by clients.
    HRESULT SetPointer(BYTE * ptr, LONG cBytes);

    // Get me a read/write pointer to this buffer's memory.
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);

    STDMETHODIMP_(LONG) GetSize(void);

    // get the stream time at which this sample should start and finish.
    STDMETHODIMP GetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );

    // Set the stream time at which this sample should start and finish.
    STDMETHODIMP SetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);

    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);

    // these allow for limited format changes in band

    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);

    // returns S_OK if there is a discontinuity in the data (this same is
    // not a continuation of the previous stream of data
    // - there has been a seek).
    STDMETHODIMP IsDiscontinuity(void);
    // set the discontinuity property - TRUE if this sample is not a
    // continuation, but a new sample after a seek.
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);

    // get the media times for this sample
    STDMETHODIMP GetMediaTime(
    	LONGLONG * pTimeStart,
	LONGLONG * pTimeEnd
    );

    // Set the media times for this sample
    STDMETHODIMP SetMediaTime(
    	LONGLONG * pTimeStart,
	LONGLONG * pTimeEnd
    );

    // Set and get properties (IMediaSample2)
    STDMETHODIMP GetProperties(
        DWORD cbProperties,
        BYTE * pbProperties
    );

    STDMETHODIMP SetProperties(
        DWORD cbProperties,
        const BYTE * pbProperties
    );
};

class CScratchMediaSample :
    public CMediaSampleWrapper
{
    BYTE *  m_pbAllocBuffer ;

    public :

        CScratchMediaSample (
            IN  LONG                lBufferLen,
            IN  REFERENCE_TIME *    pStartTime,
            IN  REFERENCE_TIME *    pEndTime,
            IN  DWORD               dwFlags,
            OUT HRESULT *           phr
            ) : m_pbAllocBuffer     (NULL),
                CMediaSampleWrapper ()
        {
            m_pbAllocBuffer = new BYTE [lBufferLen] ;
            if (m_pbAllocBuffer) {
                (* phr) = Init (m_pbAllocBuffer, lBufferLen) ;
                if (SUCCEEDED (* phr)) {

                    m_dwFlags = dwFlags ;

                    if (pStartTime) {
                        m_Start = (* pStartTime) ;
                        if (pEndTime) {
                            m_End = (* pEndTime) ;
                        }
                    }
                }
            }
            else {
                (* phr) = E_OUTOFMEMORY ;
            }

            return ;
        }

        ~CScratchMediaSample (
            )
        {
            delete [] m_pbAllocBuffer ;
        }
} ;

class CPooledMediaSampleWrapper :
    public CMediaSampleWrapper
{
    CMediaSampleWrapperPool *   m_pOwningPool ;

    protected :

        virtual void Recycle_ () ;

    public :

        CPooledMediaSampleWrapper (
            CMediaSampleWrapperPool *   pOwningPool
            ) : m_pOwningPool       (pOwningPool),
                CMediaSampleWrapper ()
        {
            ASSERT (m_pOwningPool) ;
        }
} ;

template <class T>
class TCDynamicProdCons
{
    TCProducerConsumer <T *>    m_Pool ;

    protected :

        LONG    m_lMaxAllocate ;
        LONG    m_lActualAllocated ;

        virtual T * NewObj_ () = 0 ;
        virtual void DeleteObj_ (T * pt) { delete pt ; }

    public :

        TCDynamicProdCons (
            IN  LONG    lMaxAllocate = LONG_MAX
            ) : m_lMaxAllocate      (lMaxAllocate),
                m_lActualAllocated  (0) {}

        virtual
        ~TCDynamicProdCons (
            )
        {
            T *     pObj ;
            DWORD   dw ;

            for (;;) {
                dw = m_Pool.TryPop (& pObj) ;
                if (dw == NOERROR) {
                    ASSERT (pObj) ;
                    ASSERT (m_lActualAllocated >= 0) ;

                    DeleteObj_ (pObj) ;
                    InterlockedDecrement (& m_lActualAllocated) ;
                }
                else {
                    break ;
                }
            }

            ASSERT (m_lActualAllocated == 0) ;
        }

        void SetMaxAllocate (IN LONG lMax)  { m_lMaxAllocate = lMax ; }
        LONG GetMaxAllocate ()              { return m_lMaxAllocate ; }

        T *
        TryGet (
            )
        {
            T *     pObj ;
            DWORD   dw ;

            dw = m_Pool.TryPop (& pObj) ;
            if (dw != NOERROR) {
                //  didn't get anything
                pObj = NULL ;

                //  may be able to allocate
                if (m_lActualAllocated < m_lMaxAllocate) {
                    pObj = NewObj_ () ;
                    if (pObj) {
                        InterlockedIncrement (& m_lActualAllocated) ;
                    }
                }
            }

            return pObj ;
        }

        T *
        Get (
            )
        {
            T *     pObj ;
            DWORD   dw ;

            pObj = TryGet () ;
            if (!pObj) {
                //  failed to get it non-blocking; blocking until we get 1
                dw = m_Pool.Pop (& pObj) ;
                if (dw != NOERROR) {
                    pObj = NULL ;
                }
            }

            return pObj ;
        }

        void
        Recycle (
            IN  T * pObj
            )
        {
            DWORD   dw ;

            ASSERT (m_lActualAllocated > 0) ;

            if (m_lActualAllocated <= m_lMaxAllocate) {
                dw = m_Pool.Push (pObj) ;
                if (dw != NOERROR) {
                    DeleteObj_ (pObj) ;
                    InterlockedDecrement (& m_lActualAllocated) ;
                }
            }
            else {
                DeleteObj_ (pObj) ;
                InterlockedDecrement (& m_lActualAllocated) ;
            }
        }
} ;

class CMediaSampleWrapperPool :
    public TCDynamicProdCons <CPooledMediaSampleWrapper>
{
    CDVRSendStatsWriter *   m_pDVRSendStatsWriter ;
    int                     m_iFlowId ;

    protected :

        virtual
        CPooledMediaSampleWrapper *
        NewObj_ (
            )
        {
            return new CPooledMediaSampleWrapper (this) ;
        }

    public :

        CMediaSampleWrapperPool (
            ) : TCDynamicProdCons <CPooledMediaSampleWrapper> (),
                m_pDVRSendStatsWriter (NULL) {}

        void SetFlowId (int iFlowId)    { m_iFlowId = iFlowId ; }
        void SetStatsWriter (CDVRSendStatsWriter * pDVRSendStatsWriter) { m_pDVRSendStatsWriter = pDVRSendStatsWriter ; }

        //  blocking
        CPooledMediaSampleWrapper *
        Get (
            ) ;

        //  non-blocking
        CPooledMediaSampleWrapper *
        TryGet (
            ) ;

        virtual
        void
        Recycle (
            IN  CPooledMediaSampleWrapper * pMSWrapper
            ) ;
} ;

//  ============================================================================
//      CINSSBuffer3Attrib
//  ============================================================================

class CINSSBuffer3Attrib
{
    GUID    m_guidAttribute ;
    BYTE *  m_pbAttribute ;
    DWORD   m_dwAttributeSize ;
    DWORD   m_dwAttributeAllocatedSize ;

    void
    FreeResources_ (
        )
    {
        DELETE_RESET_ARRAY (m_pbAttribute) ;
        m_dwAttributeAllocatedSize = 0 ;
    }

    public :

        CINSSBuffer3Attrib *    m_pNext ;

        CINSSBuffer3Attrib (
            ) ;

        virtual
        ~CINSSBuffer3Attrib (
            ) ;

        HRESULT
        SetAttributeData (
            IN  GUID    guid,
            IN  LPVOID  pvData,
            IN  DWORD   dwSize
            ) ;

        HRESULT
        IsEqual (
            IN  GUID    guid
            ) ;

        HRESULT
        GetAttribute (
            IN      GUID    guid,
            IN OUT  LPVOID  pvData,
            IN OUT  DWORD * pdwDataLen
            ) ;
} ;

class CINSSBuffer3AttribList :
    private TCDynamicProdCons <CINSSBuffer3Attrib>

{
    CINSSBuffer3Attrib *    m_pAttribListHead ;

    CINSSBuffer3Attrib *
    PopListHead_ (
        ) ;

    CINSSBuffer3Attrib *
    FindInList_ (
        IN  GUID    guid
        ) ;

    void
    InsertInList_ (
        IN  CINSSBuffer3Attrib *
        ) ;

    virtual
    CINSSBuffer3Attrib *
    NewObj_ (
        )
    {
        return new CINSSBuffer3Attrib ;
    }

    public :

        CINSSBuffer3AttribList (
            ) ;

        ~CINSSBuffer3AttribList (
            ) ;

        HRESULT
        AddAttribute (
            IN  GUID    guid,
            IN  LPVOID  pvData,
            IN  DWORD   dwSize
            ) ;

        HRESULT
        GetAttribute (
            IN      GUID    guid,
            IN OUT  LPVOID  pvData,
            IN OUT  DWORD * pdwDataLen
            ) ;

        void
        Reset (
            ) ;
} ;

//  ============================================================================
//      CWMINSSBuffer3Wrapper
//  ============================================================================

class CWMINSSBuffer3Wrapper :
    public INSSBuffer3
{
    CINSSBuffer3AttribList  m_AttribList ;
    IUnknown *              m_punkCore ;
    LONG                    m_cRef ;
    BYTE *                  m_pbBuffer ;
    DWORD                   m_dwBufferLength ;
    DWORD                   m_dwMaxBufferLength ;

    protected :

        virtual void Recycle_ ()    { delete this ; }

    public :

        CWMINSSBuffer3Wrapper (
            ) ;

        virtual
        ~CWMINSSBuffer3Wrapper (
            ) ;

        // IUnknown
        STDMETHODIMP QueryInterface ( REFIID riid, void **ppvObject );
        STDMETHODIMP_(ULONG) Release();
        STDMETHODIMP_(ULONG) AddRef();

        // INSSBuffer
        STDMETHODIMP GetLength( DWORD *pdwLength );
        STDMETHODIMP SetLength( DWORD dwLength );
        STDMETHODIMP GetMaxLength( DWORD * pdwLength );
        STDMETHODIMP GetBufferAndLength( BYTE ** ppdwBuffer, DWORD * pdwLength );
        STDMETHODIMP GetBuffer( BYTE ** ppdwBuffer );

        //  INSSBuffer2
        STDMETHODIMP GetSampleProperties( DWORD cbProperties, BYTE *pbProperties) ;     //  stubbed
        STDMETHODIMP SetSampleProperties( DWORD cbProperties, BYTE * pbProperties) ;    //  stubbed

        //  INSSBuffer3
        STDMETHODIMP SetProperty( GUID guidProperty, void * pvBufferProperty, DWORD dwBufferPropertySize) ;
        STDMETHODIMP GetProperty( GUID guidProperty, void * pvBufferProperty, DWORD *pdwBufferPropertySize) ;

        //  ====================================================================
        //  class methods

        HRESULT Init (IUnknown *, BYTE * pbBuffer, DWORD dwLength) ;
        void Reset_ () ;
} ;

//  ============================================================================
//  CPooledWMINSSBuffer3Wrapper
//  ============================================================================

class CPooledWMINSSBuffer3Wrapper :
    public CWMINSSBuffer3Wrapper
{
    CWMINSSBuffer3WrapperPool *    m_pOwningPool ;

    protected :

        virtual void Recycle_ () ;

    public :

        CPooledWMINSSBuffer3Wrapper (
            IN  CWMINSSBuffer3WrapperPool *  pOwningPool
            ) : m_pOwningPool           (pOwningPool),
                CWMINSSBuffer3Wrapper   ()
        {
            ASSERT (m_pOwningPool) ;
        }
} ;

//  ============================================================================
//  CWMINSSBuffer3WrapperPool
//  ============================================================================

class CWMINSSBuffer3WrapperPool :
    public TCDynamicProdCons <CPooledWMINSSBuffer3Wrapper>
{
    protected :

        virtual
        CPooledWMINSSBuffer3Wrapper *
        NewObj_ (
            )
        {
            return new CPooledWMINSSBuffer3Wrapper (this) ;
        }

    public :

        CWMINSSBuffer3WrapperPool (
            ) : TCDynamicProdCons <CPooledWMINSSBuffer3Wrapper> () {}

        CPooledWMINSSBuffer3Wrapper *
        Get (
            )
        {
            CPooledWMINSSBuffer3Wrapper * pNSSWrapper ;

            pNSSWrapper = TCDynamicProdCons <CPooledWMINSSBuffer3Wrapper>::Get () ;
            if (pNSSWrapper) {
                pNSSWrapper -> AddRef () ;
            }

            return pNSSWrapper ;
        }
} ;

//  ----------------------------------------------------------------------------
//  CTSortedList
//  ----------------------------------------------------------------------------

template <class T>
class CTSortedList
{
    struct OBJ_CONTAINER {
        T               tPayload ;
        LONG            lVal ;
        OBJ_CONTAINER * pNext ;
    } ;

    OBJ_CONTAINER *     m_pContainerPool ;
    OBJ_CONTAINER *     m_pListHead ;
    OBJ_CONTAINER **    m_ppCur ;
    LONG                m_lListLen ;

    OBJ_CONTAINER *
    GetContainer_ (
        )
    {
        OBJ_CONTAINER * pContainer ;

        if (m_pContainerPool) {
            pContainer          = m_pContainerPool ;
            m_pContainerPool    = m_pContainerPool -> pNext ;
        }
        else {
            pContainer = new OBJ_CONTAINER ;
        }

        return pContainer ;
    }

    void
    RecycleContainer_ (
        IN  OBJ_CONTAINER * pContainer
        )
    {
        pContainer -> pNext = m_pContainerPool ;
        m_pContainerPool    = pContainer ;
    }

    protected :

        virtual void InsertNewContainer_ (
            IN  OBJ_CONTAINER * pNewContainer
            )
        {
            OBJ_CONTAINER **    ppCur ;

            ppCur = & m_pListHead ;

            for (;;) {
                if (* ppCur) {
                    if (pNewContainer -> lVal <= (* ppCur) -> lVal) {
                        break ;
                    }

                    ppCur = & (* ppCur) -> pNext ;
                }
                else {
                    break ;
                }
            }

            pNewContainer -> pNext  = (* ppCur) ;
            (* ppCur)               = pNewContainer ;

            m_lListLen++ ;
        }

    public :

        CTSortedList (
            ) : m_pListHead         (NULL),
                m_lListLen          (0),
                m_ppCur             (NULL),
                m_pContainerPool    (NULL)
        {
        }

        ~CTSortedList (
            )
        {
            OBJ_CONTAINER * pContainer ;

            ASSERT (!m_pListHead) ;
            ASSERT (ListLen () == 0) ;

            while (m_pContainerPool) {
                pContainer = m_pContainerPool ;
                m_pContainerPool = m_pContainerPool -> pNext ;

                delete pContainer ;
            }
        }

        DWORD
        Insert (
            IN  T       tVal,
            IN  LONG    lVal
            )
        {
            OBJ_CONTAINER * pContainer ;
            DWORD           dw ;

            pContainer = GetContainer_ () ;
            if (pContainer) {

                pContainer -> tPayload  = tVal ;
                pContainer -> lVal      = lVal ;
                pContainer -> pNext     = pContainer ;

                InsertNewContainer_ (pContainer) ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_NOT_ENOUGH_MEMORY ;
            }

            return dw ;
        }

        DWORD
        SetPointer (
            IN  LONG    lIndex
            )
        {
            DWORD   dw ;
            LONG    i ;

            if (lIndex < m_lListLen) {
                m_ppCur = & m_pListHead ;
                for (i = 0; i < lIndex; i++) {
                    m_ppCur = & (* m_ppCur) -> pNext ;
                }

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD
        Advance (
            )
        {
            DWORD   dw ;

            if (m_ppCur &&
                (* m_ppCur) -> pNext) {

                m_ppCur = & (* m_ppCur) -> pNext ;

                dw = S_OK ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD
        GetCur (
            OUT T * ptVal
            )
        {
            DWORD   dw ;

            if (m_ppCur &&
                (* m_ppCur)) {
                (* ptVal) = (* m_ppCur) -> tPayload ;
                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        DWORD
        PopCur (
            )
        {
            OBJ_CONTAINER * pObjContainer ;
            DWORD           dw ;

            if (m_ppCur) {
                pObjContainer = (* m_ppCur) ;
                (* m_ppCur) = pObjContainer -> pNext ;

                ASSERT (m_lListLen > 0) ;
                m_lListLen-- ;

                pObjContainer -> pNext = pObjContainer ;

                RecycleContainer_ (pObjContainer) ;

                dw = NOERROR ;
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        void
        ResetList (
            )
        {
            DWORD   dw ;

            dw = SetPointer (0) ;
            for (;dw == NOERROR && ListLen () > 0;) {
                dw = PopCur () ;
            }
        }

        LONG ListLen ()     { return m_lListLen ; }
} ;

//  ============================================================================
//  ============================================================================

//  BUGBUG: for now do this based on media type
CDVRAnalysisFlags *
GetAnalysisTagger (
    IN  const AM_MEDIA_TYPE *   pmt
    ) ;

//  or the type of analysis
CDVRAnalysisFlags *
GetAnalysisTagger (
    IN  REFGUID rguidAnalysis
    ) ;

void
RecycleAnalysisTagger (
    IN  CDVRAnalysisFlags *
    ) ;

//  ----------------------------------------------

class CDVRAnalysisFlags
{
    DWORD   m_dwFlags ;

    protected :

        void SetBit_ (DWORD dwFlag)     { m_dwFlags |= dwFlag ; }
        BOOL IsBitSet_ (DWORD dwFlag)   { return ((m_dwFlags & dwFlag) ? TRUE : FALSE) ; }

        //  need instantiable children to use this class
        CDVRAnalysisFlags (
            ) {}

    public :

        virtual
        ~CDVRAnalysisFlags (
            ) {}

        virtual void Reset ()   { m_dwFlags = 0 ; }

        virtual
        HRESULT
        Mark (
            IN  REFGUID rguid
            ) = 0 ;

        virtual
        BOOL
        IsMarked (
            IN  REFGUID rguid
            ) = 0 ;

        HRESULT
        RetrieveFlags (
            IN  IMediaSample *  pIMediaSample
            ) ;

        HRESULT
        Tag (
            IN  IMediaSample *  pIMediaSample,
            IN  BOOL            fOverwrite = TRUE
            ) ;
} ;

class CDVRMpeg2VideoAnalysisFlags :
    public CDVRAnalysisFlags
{
    enum {
        DVR_ANALYSIS_MPEG2_VIDEO_GOP_HEADER     = 0x00000001,
        DVR_ANALYSIS_MPEG2_VIDEO_B_FRAME        = 0x00000002,
        DVR_ANALYSIS_MPEG2_VIDEO_P_FRAME        = 0x00000004,
    } ;

    public :

        CDVRMpeg2VideoAnalysisFlags (
            ) : CDVRAnalysisFlags () {}

        void FlagBFrame ()      { SetBit_ (DVR_ANALYSIS_MPEG2_VIDEO_B_FRAME) ; }
        BOOL IsBFrame ()        { return IsBitSet_ (DVR_ANALYSIS_MPEG2_VIDEO_B_FRAME) ; }

        void FlagPFrame ()      { SetBit_ (DVR_ANALYSIS_MPEG2_VIDEO_P_FRAME) ; }
        BOOL IsPFrame ()        { return IsBitSet_ (DVR_ANALYSIS_MPEG2_VIDEO_P_FRAME) ; }

        void FlagGOPHeader ()   { SetBit_ (DVR_ANALYSIS_MPEG2_VIDEO_GOP_HEADER) ; }
        BOOL IsGOPHeader ()     { return IsBitSet_ (DVR_ANALYSIS_MPEG2_VIDEO_GOP_HEADER) ; }

        virtual
        HRESULT
        Mark (
            IN  REFGUID rguid
            ) ;

        virtual
        BOOL
        IsMarked (
            IN  REFGUID rguid
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CDVRAttributeTranslator
{
    BOOL    m_fInlineDShowProps ;

    //  we have 1 attribute translator per stream (per pin), so we maintain 1
    //   continuity counter per stream; this allows us to discover
    //   discontinuities on a per-stream basis vs. global
    DWORD   m_dwContinuityCounterNext ;
    BOOL    m_fUseContinuityCounter ;

    //  this is the pin ID
    int     m_iFlowId ;

    protected :

        HRESULT
        InlineProperties_ (
            IN      IMediaSample *,
            IN OUT  INSSBuffer3 *
            ) ;

        HRESULT
        RecoverInlineProperties_ (
            IN      INSSBuffer *,
            IN OUT  IMediaSample *,
            OUT     AM_MEDIA_TYPE **                    //  dyn format change
            ) ;

        BOOL
        IsINSSBuffer3PropDiscontinuity_ (
            IN  INSSBuffer3 *   pINSSBuffer3
            ) ;

        HRESULT
        WriteINSSBuffer3PropContinuity_ (
            IN  INSSBuffer3 *   pINSSBuffer3
            ) ;

    public :

        CDVRAttributeTranslator (
            IN  CDVRPolicy *        pPolicy,
            IN  int                 iFlowId,
            IN  BOOL                fInlineDShowProps = TRUE
            ) ;

        virtual
        HRESULT
        SetAttributesWMSDK (
            IN  IReferenceClock *   pRefClock,
            IN  REFERENCE_TIME *    prtStartTime,
            IN  IMediaSample *      pIMS,
            OUT INSSBuffer3 *       pINSSBuffer3,
            OUT DWORD *             pdwWMSDKFlags,
            OUT QWORD *             pcnsSampleTime
            ) ;

        virtual
        HRESULT
        SetAttributesDShow (
            IN      INSSBuffer *        pINSSBuffer,
            IN      QWORD               cnsStreamTimeOfSample,
            IN      QWORD               cnsSampleDuration,
            IN      DWORD               dwFlags,
            IN OUT  IMediaSample *      pIMS,
            OUT     AM_MEDIA_TYPE **    ppmtNew                 //  dyn format change
            ) ;

        void InlineDShowAttributes (IN BOOL f)  { m_fInlineDShowProps = f ; }
} ;

class CDVRMpeg2AttributeTranslator :
    public CDVRAttributeTranslator
{
    CDVRMpeg2VideoAnalysisFlags     m_Mpeg2AnalysisReader ;

    HRESULT
    InlineAnalysisData_ (
        IN      IReferenceClock *   pRefClock,
        IN      IMediaSample *      pIMS,
        IN OUT  DWORD *             pdwWMSDKFlags,
        IN OUT  QWORD *             pcnsSampleTime,
        OUT     INSSBuffer3 *       pINSSBuffer3
        ) ;

    HRESULT
    InlineMpeg2Attributes_ (
        IN  INSSBuffer3 *   pINSSBuffer3,
        IN  IMediaSample *  pIMS
        ) ;

    public :

        CDVRMpeg2AttributeTranslator (
            IN  CDVRPolicy *        pPolicy,
            IN  int                 iFlowId,
            IN  BOOL                fInlineDShowProps = TRUE
            ) : CDVRAttributeTranslator (pPolicy, iFlowId, fInlineDShowProps) {}

        virtual
        HRESULT
        SetAttributesWMSDK (
            IN  IReferenceClock *   pRefClock,
            IN  REFERENCE_TIME *    prtStartTime,
            IN  IMediaSample *      pIMS,
            OUT INSSBuffer3 *       pINSSBuffer3,
            OUT DWORD *             pdwWMSDKFlags,
            OUT QWORD *             pcnsSampleTime
            ) ;

        virtual
        HRESULT
        SetAttributesDShow (
            IN      INSSBuffer *        pINSSBuffer,
            IN      QWORD               cnsStreamTimeOfSample,
            IN      QWORD               cnsSampleDuration,
            IN      DWORD               dwFlags,
            IN OUT  IMediaSample *      pIMS,
            OUT     AM_MEDIA_TYPE **    ppmtNew                 //  dyn format change
            ) ;
} ;

//  ============================================================================
//  ============================================================================

class CSimpleBitfield
{
    int     m_cBits ;
    BYTE *  m_pBits ;
    int     m_ByteArrayLength ;

    size_t
    DivRoundUpMaybe_ (
        IN  int num,
        IN  int den
        )
    {
        return (num) / (den) + ((num) % (den) ? 1 : 0) ;
    }

    public :

        CSimpleBitfield (
            IN  int         cBits,
            OUT HRESULT *   phr
            ) : m_cBits (cBits),
                m_pBits (NULL)
        {
            m_ByteArrayLength = DivRoundUpMaybe_ (m_cBits, 8) ;

            m_pBits = new BYTE [m_ByteArrayLength] ;
            if (m_pBits == NULL) {
                (* phr) = E_OUTOFMEMORY ;
                goto cleanup ;
            }

            (* phr) = S_OK ;

            ClearAll () ;

            cleanup :

            return ;
        }

        ~CSimpleBitfield (
            )
        {
            delete [] m_pBits ;
        }

        int BitfieldSize () { return m_cBits ; }

        void
        ClearAll (
            )
        {
            ZeroMemory (m_pBits, m_ByteArrayLength) ;
        }

        void
        Set (int b)
        {
            int     iB ;
            int     ib ;
            BYTE    mask ;

            ASSERT (b <= m_cBits) ;

            iB = b / 8 ;
            ib = b % 8 ;
            mask = 1 << ib ;
            m_pBits [iB] |= mask ;
        }

        void
        Unset (int b)
        {
            int     iB ;
            int     ib ;
            BYTE    mask ;

            ASSERT (b <= m_cBits) ;

            iB = b / 8 ;
            ib = b % 8 ;
            mask = ~(1 << ib) ;
            m_pBits [iB] &= mask ;
        }

        BOOL
        IsSet (int b)
        {
            int     iB ;
            int     ib ;
            BYTE    mask ;

            ASSERT (b <= m_cBits) ;

            iB = b / 8 ;
            ib = b % 8 ;
            mask = 1 << ib ;

            return m_pBits [iB] & mask ? TRUE : FALSE ;
        }
} ;

//  ============================================================================
//  ============================================================================

//  CAMThread has m_dwParam & m_dwReturnVal private, so derived classes cannot
//   access them, so we copy/paste CAMThread just so we can do this ..

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class AM_NOVTABLE CDVRThread {

    // make copy constructor and assignment operator inaccessible

    CDVRThread(const CDVRThread &refThread);
    CDVRThread &operator=(const CDVRThread &refThread);

//  only diff from CAMThread is protected: was moved up just a bit
protected:

    CAMEvent m_EventSend;
    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;

    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CDVRThread();
    virtual ~CDVRThread();

    CCritSec m_AccessLock;	// locks access by client threads
    CCritSec m_WorkerLock;	// locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    // wait for the next request
    DWORD GetRequest();

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper();
};

//  ============================================================================
//  ============================================================================

#endif  //  _tsdvr__dvrutil_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\capfilter.h ===
#define DELETE_RESET(p)         if (p) { delete (p) ; (p) = NULL ; }
#define DELETE_RESET_ARRAY(p)   if (p) { delete [] (p) ; (p) = NULL ; }
#define RELEASE_AND_CLEAR(p)    if (p) { (p) -> Release () ; (p) = NULL ; }

#define FILTER_NAME     L"DVR CapGraph Filter"

extern AMOVIESETUP_FILTER g_sudFilter ;

class CCapGraphFilter ;

class CCapGraphFilter :
    public CBaseFilter,
    public IFileSourceFilter
{
    enum CAP_GRAPH_STATE {
        STOPPED,
        PAUSED,
        RUNNING,
        NO_CAP_GRAPH
    } ;

    enum {
        REC_STATE_STOPPED   = 0,
        REC_STATE_STARTED   = 1
    } ;

    enum {
        START_REC_PRESET_START  = 0,
        START_REC_PRESET_STEP   = 5,
        START_REC_PRESET_MAX    = 60,

        STOP_REC_PRESET_START   = 30,
        STOP_REC_PRESET_STEP    = 5,
        STOP_REC_PRESET_MAX     = 90,
    } ;

    enum {
        CAP_GRAPH_ACTIVE_SEC_TIMER      = 1,
        CAP_GRAPH_UPDATE_FREQ_MILLIS    = 1000,     //  millis
    } ;

    CCritSec            m_Lock ;
    WCHAR *             m_pszFilename ;
    CDShowFilterGraph * m_pCaptureGraph ;
    CDVRCapGraph *      m_pDVRCapGraph ;
    CAP_GRAPH_STATE     m_CapGraphState ;

    HWND                m_hwndDialog ;
    HINSTANCE           m_hInstance ;
    HWND                m_hwndButtonStop ;
    HWND                m_hwndButtonRun ;
    HWND                m_hwndButtonPause ;
    HWND                m_hwndEditRecordingFilename ;
    HWND                m_hwndListRecordinds ;
    HWND                m_hwndLockDVRStreamSink ;
    HWND                m_hwndInitDVRStreamSource ;
    HWND                m_hwndCapGraphActiveSec ;
    CListview *         m_pLVRecordings ;
    DWORD               m_dwCapGraphActiveSec ;

    void LockFilter_ ()         { m_Lock.Lock () ; }
    void UnlockFilter_ ()       { m_Lock.Unlock () ; }

    void
    ChangeGraphState_ (
        IN  CAP_GRAPH_STATE NewCapGraphState
        ) ;

    void
    GraphLoaded_ (
        ) ;

    void
    ReleaseAllRecordings_ (
        ) ;

    HRESULT
    InitCombo_ (
        IN  DWORD   dwId,
        IN  int     iStart,
        IN  int     iMax,
        IN  int     iStep
        ) ;

    HRESULT
    InitRecordingsLV_ (
        ) ;

    void
    UpdateCapGraphActiveSec_ (
        ) ;

    public :

        CCapGraphFilter (
            IN  TCHAR *     tszName,
            IN  LPUNKNOWN   punk,
            OUT HRESULT *   phr
            ) ;

        ~CCapGraphFilter (
            ) ;

        DECLARE_IUNKNOWN ;

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        int GetPinCount ()                  { return 0 ; }
        CBasePin * GetPin (IN int Index)    { return NULL ; }

        static
        CUnknown *
        CreateInstance (
            IN  LPUNKNOWN   punk,
            OUT HRESULT *   phr
            ) ;

        HRESULT CapGraphRun () ;
        HRESULT CapGraphPause () ;
        HRESULT CapGraphStop () ;

        void    StartRecordingSelected () ;
        void    StopRecordingSelected () ;

        void LockDVRStreamSink () ;
        void InitDVRStreamSource () ;
        void CreateRecording () ;

        //  ====================================================================
        //  IFileSourceFilter

        STDMETHODIMP
        Load (
            IN  LPCOLESTR               pszFilename,
            IN  const AM_MEDIA_TYPE *   pmt
            ) ;

        STDMETHODIMP
        GetCurFile (
            OUT LPOLESTR *      ppszFilename,
            OUT AM_MEDIA_TYPE * pmt
            ) ;

        //  ====================================================================
        //  wndproc

        INT_PTR
        CapGraphDlgProc (
            IN  HWND    Hwnd,
            IN  UINT    Msg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;

        static
        INT_PTR
        StaticCapGraphDlgProc (
            IN  HWND    Hwnd,
            IN  UINT    Msg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            )
        {
            //  we get this message when we are created
            if (Msg == WM_INITDIALOG) {

                //  should only get it once
                ASSERT (GetWindowLong (Hwnd, GWL_USERDATA) == 0) ;
                SetWindowLong (Hwnd, GWL_USERDATA, (LONG) lParam) ;
            }

            if (GetWindowLong (Hwnd, GWL_USERDATA) != 0) {
                return (reinterpret_cast <CCapGraphFilter *> (GetWindowLong (Hwnd, GWL_USERDATA))) -> CapGraphDlgProc (Hwnd, Msg, wParam, lParam) ;
            }

            return FALSE ;
        }
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\precomp.h ===
#include <streams.h>
#include <commctrl.h>
#include "uictrl.h"
#include <dvrds.h>
#include "resource.h"
#include "fg.h"
#include "capfilter.h"

// {354AFF38-175F-492e-AE79-3B8FA0B817AA}
DEFINE_GUID(CLSID_CaptureGraphFilter,
0x354aff38, 0x175f, 0x492e, 0xae, 0x79, 0x3b, 0x8f, 0xa0, 0xb8, 0x17, 0xaa);

// {46A1BDC6-47E7-46c5-B5B6-FE24D99FBF14}
DEFINE_GUID(CLSID_CaptureGraphControlProp,
0x46a1bdc6, 0x47e7, 0x46c5, 0xb5, 0xb6, 0xfe, 0x24, 0xd9, 0x9f, 0xbf, 0x14);


#define RELEASE_AND_CLEAR(p)    if (p) { (p) -> Release () ; (p) = NULL ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\main.cpp ===
#include <streams.h>
#include <initguid.h>
#include "precomp.h"

AMOVIESETUP_FILTER
g_sudFilter = {
    & CLSID_CaptureGraphFilter,
    FILTER_NAME,
    MERIT_DO_NOT_USE,
    0,                          //  0 pins registered
    NULL
} ;

CFactoryTemplate g_Templates [] = {
    //  filter
    {   FILTER_NAME,
        & CLSID_CaptureGraphFilter,
        CCapGraphFilter::CreateInstance,
        NULL,
        & g_sudFilter
    },
};

int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);

//  register and unregister entry points

//
// DllRegisterSever
//
// Handle the registration of this filter
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2 (TRUE);
}

//
// DllUnregsiterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2 (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\capfilter.cpp ===
#include "precomp.h"

#define WM_CAPFILTER__STOP          (WM_USER + 1)

typedef
struct {
    WCHAR * szTitle ;
    DWORD   dwWidth ;
} COL_DETAIL ;

#define LV_COL(title, width)  { L#title, (width) }

//  ============================================================================
//  ============================================================================

static enum {
    RECORDING_FILENAME,
    RECORDING_START,
    RECORDING_STOP,
    RECORDING_STATE,

    RECORDING_COL_COUNT     //  always last
} ;

static COL_DETAIL
g_DVRRecordingsLV [] = {
    LV_COL  (Filename,  120),
    LV_COL  (Start,     40),
    LV_COL  (Stop,      40),
    LV_COL  (State,     60)
} ;

//  ============================================================================
//  ============================================================================

//  TRUE / FALSE for YES / NO
static
BOOL
MessageBoxQuestion (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    return MessageBox (NULL, achbuffer, title, MB_YESNO | MB_ICONQUESTION) == IDYES ;
}

//  error conditions
static
void
MessageBoxError (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK | MB_ICONEXCLAMATION) ;
}

//  variable param
static
void
MessageBoxVar (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK) ;
}

static
BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    BOOL    r ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;

    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    dwSize = sizeof (* pdwRet) ;
    dwType = REG_DWORD ;

    l = RegQueryValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            & dwType,
            (LPBYTE) pdwRet,
            & dwSize
            ) ;
    if (l == ERROR_SUCCESS) {
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

static
BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegDWORDVal (
                hkey,
                pszRegValName,
                pdwRet
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

static
__inline
QWORD
MillisToDShowTime (
    IN  DWORD   dwMillis
    )
{
    return dwMillis * 10000I64 ;
}

static
__inline
REFERENCE_TIME
SecondsToDShowTime (
    IN  DWORD   dwSeconds
    )
{
    //  both are 100 MHz clocks
    return MillisToDShowTime (dwSeconds * 1000) ;
}

//  ---------------------------------------------------------------------------
//  ---------------------------------------------------------------------------

CCapGraphFilter::CCapGraphFilter (
    IN  TCHAR *     tszName,
    IN  LPUNKNOWN   punk,
    OUT HRESULT *   phr
    ) : CBaseFilter                 (tszName,
                                     punk,
                                     & m_Lock,
                                     CLSID_CaptureGraphFilter
                                     ),
        m_pszFilename               (NULL),
        m_pCaptureGraph             (NULL),
        m_CapGraphState             (NO_CAP_GRAPH),
        m_hwndDialog                (NULL),
        m_hwndButtonStop            (NULL),
        m_hwndButtonRun             (NULL),
        m_hwndButtonPause           (NULL),
        m_hwndEditRecordingFilename (NULL),
        m_hwndListRecordinds        (NULL),
        m_hwndCapGraphActiveSec     (NULL),
        m_pLVRecordings             (NULL),
        m_hInstance                 (g_hInst),
        m_pDVRCapGraph              (NULL),
        m_dwCapGraphActiveSec       (0)
{
    CCombobox * pRecTime ;
    BOOL        r ;
    DWORD       dw ;
    int         i ;

    m_hwndDialog = CreateDialogParam (
                        m_hInstance,
                        MAKEINTRESOURCE (IDD_CAP_GRAPH_FILTER),
                        NULL,
                        StaticCapGraphDlgProc,
                        (LPARAM) this
                        ) ;
    if (m_hwndDialog == NULL)
    {
        dw = GetLastError () ;
        (* phr) = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    m_hwndButtonStop            = GetDlgItem (m_hwndDialog, IDC_CAP_GRAPH_STOP) ;
    m_hwndButtonRun             = GetDlgItem (m_hwndDialog, IDC_CAP_GRAPH_RUN) ;
    m_hwndButtonPause           = GetDlgItem (m_hwndDialog, IDC_CAP_GRAPH_PAUSE) ;
    m_hwndLockDVRStreamSink     = GetDlgItem (m_hwndDialog, IDC_LOCK_DVRSTREAMSINK) ;
    m_hwndInitDVRStreamSource   = GetDlgItem (m_hwndDialog, IDC_INIT_DVRSTREAMSOURCE) ;
    m_hwndEditRecordingFilename = GetDlgItem (m_hwndDialog, IDC_REC_FILENAME) ;
    m_hwndListRecordinds        = GetDlgItem (m_hwndDialog, IDC_REC_LIST) ;
    m_hwndCapGraphActiveSec     = GetDlgItem (m_hwndDialog, IDC_CAPGRAPH_ACTIVE_SEC) ;

    m_pLVRecordings             = new CListview (m_hwndDialog, IDC_REC_LIST) ;

    if (m_hwndButtonStop            == NULL ||
        m_hwndButtonRun             == NULL ||
        m_hwndButtonPause           == NULL ||
        m_hwndLockDVRStreamSink     == NULL ||
        m_hwndInitDVRStreamSource   == NULL ||
        m_hwndEditRecordingFilename == NULL ||
        m_hwndListRecordinds        == NULL ||
        m_hwndCapGraphActiveSec     == NULL ||
        m_pLVRecordings             == NULL) {

        dw = GetLastError () ;
        (* phr) = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    (* phr) = InitRecordingsLV_ () ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = InitCombo_ (IDC_START_ABS_SEC, START_REC_PRESET_START, START_REC_PRESET_MAX, START_REC_PRESET_STEP) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = InitCombo_ (IDC_STOP_ABS_SEC, STOP_REC_PRESET_START, STOP_REC_PRESET_MAX, STOP_REC_PRESET_STEP) ;
    if (FAILED (* phr)) { goto cleanup ; }

    SetWindowTextW (m_hwndCapGraphActiveSec, L"0") ;

    ChangeGraphState_ (m_CapGraphState) ;
    ShowWindow (m_hwndDialog, SW_SHOW) ;
    SetForegroundWindow (m_hwndDialog) ;

    //  success

    cleanup :

    return ;
}

CCapGraphFilter::~CCapGraphFilter ()
{
    if (m_hwndDialog) {
        SendMessage (m_hwndDialog, WM_CAPFILTER__STOP, 0, 0) ;
    }

    delete m_pLVRecordings ;
    delete m_pCaptureGraph ;
    delete [] m_pszFilename ;
}

HRESULT
CCapGraphFilter::InitRecordingsLV_ (
    )
{
    HIMAGELIST  himlSmallState ;
    HICON       hicon ;
    int         i ;
    DWORD       dw ;
    HRESULT     hr ;

    ASSERT (m_pLVRecordings) ;

    for (i = 0; i < RECORDING_COL_COUNT; i++) {
        m_pLVRecordings -> InsertColumnW (
            g_DVRRecordingsLV [i].szTitle,
            g_DVRRecordingsLV [i].dwWidth,
            i
            ) ;
    }

    himlSmallState = ImageList_Create (16, 16, ILC_COLORDDB | ILC_MASK, 1, 0) ;
    if (himlSmallState) {

        hicon = (HICON) LoadImage (m_hInstance, MAKEINTRESOURCE (IDI_ACTIVE_REC), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR) ;
        ImageList_AddIcon (himlSmallState, hicon) ;

        m_pLVRecordings -> SetImageList_State (himlSmallState) ;
    }
    else {
        dw = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dw) ;
    }

    return hr ;
}

HRESULT
CCapGraphFilter::InitCombo_ (
    IN  DWORD   dwId,
    IN  int     iStart,
    IN  int     iMax,
    IN  int     iStep
    )
{
    CCombobox   Combo (m_hwndDialog, dwId) ;
    int         i ;

    for (i = iStart;
         i <= iMax;
         i += iStep) {

         Combo.AppendW (i) ;
    }

    Combo.SetCurSelected (0) ;

    return S_OK ;
}

void
CCapGraphFilter::ReleaseAllRecordings_ (
    )
{
    IDVRRecordControl * pIRecControl ;

    if (m_pLVRecordings) {
        while (m_pLVRecordings -> GetItemCount () > 0) {
            pIRecControl = reinterpret_cast <IDVRRecordControl *> (m_pLVRecordings -> GetData (0)) ;
            ASSERT (pIRecControl) ;
            pIRecControl -> Release () ;

            m_pLVRecordings -> DeleteRow (0) ;
        }
    }
}

void
CCapGraphFilter::ChangeGraphState_ (
    IN  CAP_GRAPH_STATE NewCapGraphState
    )
{
    if (m_CapGraphState == STOPPED &&
        NewCapGraphState != STOPPED) {

        m_dwCapGraphActiveSec = 0 ;
        SetTimer (m_hwndDialog, CAP_GRAPH_ACTIVE_SEC_TIMER, CAP_GRAPH_UPDATE_FREQ_MILLIS, NULL) ;
    }
    else if (NewCapGraphState == STOPPED) {
        KillTimer (m_hwndDialog, CAP_GRAPH_ACTIVE_SEC_TIMER) ;
    }

    m_CapGraphState = NewCapGraphState ;

    EnableWindow (m_hwndButtonStop,   (m_CapGraphState != NO_CAP_GRAPH && m_CapGraphState != STOPPED)) ;
    EnableWindow (m_hwndButtonPause,  (m_CapGraphState != NO_CAP_GRAPH && m_CapGraphState != PAUSED)) ;
    EnableWindow (m_hwndButtonRun,    (m_CapGraphState != NO_CAP_GRAPH && m_CapGraphState != RUNNING)) ;

    EnableWindow (m_hwndEditRecordingFilename,  m_CapGraphState != NO_CAP_GRAPH) ;
    EnableWindow (m_hwndListRecordinds,         m_CapGraphState != NO_CAP_GRAPH) ;

    EnableWindow (GetDlgItem (m_hwndDialog, IDC_REC_CREATE),    m_CapGraphState != NO_CAP_GRAPH) ;
    EnableWindow (GetDlgItem (m_hwndDialog, IDC_REC_START),     m_CapGraphState != NO_CAP_GRAPH && m_pLVRecordings) ;
    EnableWindow (GetDlgItem (m_hwndDialog, IDC_REC_STOP),      m_CapGraphState != NO_CAP_GRAPH && m_pLVRecordings) ;
}

void
CCapGraphFilter::GraphLoaded_ (
    )
{
    //  DVRCapGraph ?
    EnableWindow (m_hwndLockDVRStreamSink,      (m_pDVRCapGraph ? TRUE : FALSE)) ;
    EnableWindow (m_hwndInitDVRStreamSource,    (m_pDVRCapGraph ? TRUE : FALSE)) ;
}

CUnknown *
CCapGraphFilter::CreateInstance (
    IN  LPUNKNOWN   punk,
    OUT HRESULT *   phr
    )
{
    CCapGraphFilter * pnf ;

    * phr = S_OK ;

    pnf = new CCapGraphFilter (
                    NAME ("CCapGraphFilter"),
                    punk,
                    phr
                    ) ;
    if (pnf == NULL) {
        * phr = E_OUTOFMEMORY ;
    }

    if (FAILED (* phr)) {
        DELETE_RESET (pnf) ;
    }

    return pnf ;
}

STDMETHODIMP
CCapGraphFilter::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  ------------------------------------------------------------------------
    //  IFileSourceFilter;

    if (riid == IID_IFileSourceFilter) {

        return GetInterface (
                    (IFileSourceFilter *) this,
                    ppv
                    ) ;
    }

    return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
}

//  ============================================================================
//  ICaptureGraphControl

HRESULT
CCapGraphFilter::CapGraphRun (
    )
{
    HRESULT hr ;

    if (m_pCaptureGraph) {
        hr = m_pCaptureGraph -> Run () ;
        if (SUCCEEDED (hr)) {
            ChangeGraphState_ (RUNNING) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CCapGraphFilter::CapGraphPause (
    )
{
    HRESULT hr ;

    if (m_pCaptureGraph) {
        hr = m_pCaptureGraph -> Pause () ;
        if (SUCCEEDED (hr)) {
            ChangeGraphState_ (PAUSED) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CCapGraphFilter::CapGraphStop (
    )
{
    HRESULT hr ;

    if (m_pCaptureGraph) {
        hr = m_pCaptureGraph -> Stop () ;
        if (SUCCEEDED (hr)) {
            ChangeGraphState_ (STOPPED) ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

//  ============================================================================

STDMETHODIMP
CCapGraphFilter::Load (
    IN  LPCOLESTR               pszFilename,
    IN  const AM_MEDIA_TYPE *   pmt
    )
{
    HRESULT hr ;

    if (!pszFilename) {
        return E_POINTER ;
    }

    LockFilter_ () ;

    DELETE_RESET_ARRAY (m_pszFilename) ;

    m_pszFilename = new WCHAR [lstrlenW (pszFilename) + 1] ;
    if (m_pszFilename) {
        lstrcpyW (m_pszFilename, pszFilename) ;

        ASSERT (m_pDVRCapGraph == NULL) ;
        ASSERT (m_pCaptureGraph == NULL) ;

        //  first try for a DVRCapture graph
        m_pDVRCapGraph = new CDVRCapGraph (this, m_pszFilename, & hr) ;
        if (m_pDVRCapGraph &&
            SUCCEEDED (hr)) {

            //  success
            m_pCaptureGraph = m_pDVRCapGraph ;
        }
        else {
            //  failure - try plan B
            DELETE_RESET (m_pDVRCapGraph) ;
            m_pCaptureGraph = new CDShowFilterGraph (this, m_pszFilename, & hr) ;
        }

        if (SUCCEEDED (hr) &&
            m_pCaptureGraph) {

            GraphLoaded_ () ;
            ChangeGraphState_ (STOPPED) ;
        }
        else {
            DELETE_RESET (m_pDVRCapGraph) ;
            DELETE_RESET (m_pCaptureGraph) ;
        }
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    UnlockFilter_ () ;

    return hr ;
}

STDMETHODIMP
CCapGraphFilter::GetCurFile (
    OUT LPOLESTR *      ppszFilename,
    OUT AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    if (!ppszFilename ||
        !pmt) {

        return E_POINTER ;
    }

    LockFilter_ () ;

    if (m_pszFilename) {
        (* ppszFilename) = reinterpret_cast <LPOLESTR> (CoTaskMemAlloc ((lstrlenW (m_pszFilename) + 1) * sizeof OLECHAR)) ;
        if (* ppszFilename) {

            //  outgoing filename
            lstrcpyW ((* ppszFilename), m_pszFilename) ;

            //  and media type
            pmt->majortype      = GUID_NULL;
            pmt->subtype        = GUID_NULL;
            pmt->pUnk           = NULL;
            pmt->lSampleSize    = 0;
            pmt->cbFormat       = 0;

            hr = S_OK ;
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        hr = E_UNEXPECTED ;
    }

    UnlockFilter_ () ;

    return hr ;
}

void
CCapGraphFilter::LockDVRStreamSink (
    )
{
    HRESULT             hr ;
    IDVRStreamSink *    pIDVRStreamSink ;

    //  button would not be enabled if this was NULL
    ASSERT (m_pDVRCapGraph) ;

    hr = m_pDVRCapGraph -> GetIDVRStreamSink (& pIDVRStreamSink) ;
    ASSERT (SUCCEEDED (hr)) ;
    ASSERT (pIDVRStreamSink) ;

    hr = pIDVRStreamSink -> LockProfile () ;
    pIDVRStreamSink -> Release () ;

    if (SUCCEEDED (hr)) {
        MessageBoxVar (
            TEXT ("Lock DVRStreamSink"),
            TEXT ("Operation succeeded")
            ) ;
    }
    else {
        MessageBoxError (
            TEXT ("Lock DVRStreamSink"),
            TEXT ("Operation failed\n")
            TEXT ("hr = %08xh"),
            hr
            ) ;
    }

    return ;
}

void
CCapGraphFilter::InitDVRStreamSource (
    )
{
    HRESULT             hr ;
    IDVRStreamSource *  pIDVRStreamSource ;
    IDVRStreamSink *    pIDVRStreamSink ;

    if (m_pGraph) {

        pIDVRStreamSource = FIND_FILTER (m_pGraph, IDVRStreamSource) ;

        if (pIDVRStreamSource) {
            hr = m_pDVRCapGraph -> GetIDVRStreamSink (& pIDVRStreamSink) ;
            ASSERT (SUCCEEDED (hr)) ;
            ASSERT (pIDVRStreamSink) ;

            hr = pIDVRStreamSource -> SetStreamSink (pIDVRStreamSink) ;
            if (SUCCEEDED (hr)) {
                MessageBoxVar (
                    TEXT ("Init DVRStreamSource Operation"),
                    TEXT ("Operation succeeded\n")
                    TEXT ("Graphedt: View/refresh to see the pins")
                    ) ;
            }
            else {
                MessageBoxError (
                    TEXT ("Init DVRStreamSource Operation"),
                    TEXT ("Operation failed\n")
                    TEXT ("hr = %08xh"),
                    hr
                    ) ;
            }

            pIDVRStreamSink -> Release () ;
            pIDVRStreamSource -> Release () ;
        }
    }

    return ;
}

void
CCapGraphFilter::CreateRecording (
    )
{
    WCHAR               achFilename [MAX_PATH] ;
    IUnknown *          punkRecorder ;
    int                 i ;
    HRESULT             hr ;
    IDVRRecordControl * pIRecControl ;
    int                 row ;
    DWORD               dw ;

    ASSERT (m_pDVRCapGraph) ;

    i = GetWindowTextW (m_hwndEditRecordingFilename, achFilename, MAX_PATH - 1) ;
    if (i > 0) {

        achFilename [i] = L'\0' ;

        hr = m_pDVRCapGraph -> CreateRecorder (achFilename, & punkRecorder) ;
        if (SUCCEEDED (hr)) {
            hr = punkRecorder -> QueryInterface (IID_IDVRRecordControl, (void **) & pIRecControl) ;
            if (SUCCEEDED (hr)) {
                row = m_pLVRecordings -> InsertRowTextW (
                        achFilename,
                        0
                        ) ;
                if (row != -1) {
                    m_pLVRecordings -> SetData ((DWORD_PTR) pIRecControl, row) ;
                    pIRecControl -> AddRef () ;     //  listview's

                    m_pLVRecordings -> SetState (REC_STATE_STOPPED, row) ;
                }
                else {
                    dw = GetLastError () ;
                    hr = HRESULT_FROM_WIN32 (dw) ;
                }

                pIRecControl -> Release () ;
            }

            punkRecorder -> Release () ;
        }

        if (FAILED (hr)) {
            MessageBoxError (
                TEXT ("Create Recording Operation"),
                TEXT ("Failed to create a recording for %s\n")
                TEXT ("hr = %08xh"),
                achFilename,
                hr
                ) ;
        }
    }
    else {
        MessageBoxError (
            TEXT ("Create Recording Operation"),
            TEXT ("No recording filename was specified.")
            ) ;
    }
}

void
CCapGraphFilter::StopRecordingSelected (
    )
{
    HRESULT             hr ;
    IDVRRecordControl * pIRecControl ;
    CCombobox           ComboStopTime (m_hwndDialog, IDC_STOP_ABS_SEC) ;
    WCHAR               achBuffer [32] ;
    int                 iStop ;
    int                 iRow ;

    iRow = m_pLVRecordings -> GetSelectedRow () ;
    if (iRow != -1) {

        pIRecControl = reinterpret_cast <IDVRRecordControl *> (m_pLVRecordings -> GetData (iRow)) ;
        ASSERT (pIRecControl) ;

        if (ComboStopTime.GetTextW (achBuffer, 32) > 0) {
            ComboStopTime.GetTextW (& iStop) ;
            hr = pIRecControl -> Stop (SecondsToDShowTime ((DWORD) iStop)) ;
            if (SUCCEEDED (hr)) {
                m_pLVRecordings -> SetTextW (iStop, iRow, RECORDING_STOP) ;

                MessageBoxVar (
                    TEXT ("Stop Recording"),
                    TEXT ("Operation succeeded")
                    ) ;
            }
            else {
                MessageBoxError (
                    TEXT ("Stop recording"),
                    TEXT ("hr = %08xh"),
                    hr
                    ) ;
            }
        }
        else {
            MessageBoxError (
                TEXT ("Stop recording"),
                TEXT ("No stop time specified")
                ) ;
        }
    }
    else {
        MessageBoxError (
            TEXT ("Stop recording"),
            TEXT ("No Recording is selected")
            ) ;
    }
}

void
CCapGraphFilter::StartRecordingSelected (
    )
{
    HRESULT             hr ;
    IDVRRecordControl * pIRecControl ;
    CCombobox           ComboStopTime (m_hwndDialog, IDC_START_ABS_SEC) ;
    WCHAR               achBuffer [32] ;
    int                 iStart ;
    int                 iRow ;

    iRow = m_pLVRecordings -> GetSelectedRow () ;
    if (iRow != -1) {

        pIRecControl = reinterpret_cast <IDVRRecordControl *> (m_pLVRecordings -> GetData (iRow)) ;
        ASSERT (pIRecControl) ;

        if (ComboStopTime.GetTextW (achBuffer, 32) > 0) {
            ComboStopTime.GetTextW (& iStart) ;
            hr = pIRecControl -> Start (SecondsToDShowTime ((DWORD) iStart)) ;
            if (SUCCEEDED (hr)) {
                m_pLVRecordings -> SetTextW (iStart, iRow, RECORDING_START) ;
                m_pLVRecordings -> SetState (REC_STATE_STARTED, iRow) ;

                MessageBoxVar (
                    TEXT ("Start Recording"),
                    TEXT ("Operation succeeded")
                    ) ;
            }
            else {
                MessageBoxError (
                    TEXT ("Start recording"),
                    TEXT ("hr = %08xh"),
                    hr
                    ) ;
            }
        }
        else {
            MessageBoxError (
                TEXT ("Start recording"),
                TEXT ("No start time specified")
                ) ;
        }
    }
    else {
        MessageBoxError (
            TEXT ("Start recording"),
            TEXT ("No Recording is selected")
            ) ;
    }
}

void
CCapGraphFilter::UpdateCapGraphActiveSec_ (
    )
{
    WCHAR   ach [32] ;

    wsprintf (ach, L"%d", ++m_dwCapGraphActiveSec) ;
    SetWindowTextW (m_hwndCapGraphActiveSec, ach) ;
}

INT_PTR
CCapGraphFilter::CapGraphDlgProc (
    IN  HWND    Hwnd,
    IN  UINT    Msg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    switch (Msg) {

        case WM_TIMER :
            if (wParam == CAP_GRAPH_ACTIVE_SEC_TIMER) {
                UpdateCapGraphActiveSec_ () ;
            }
            break ;

        case WM_CAPFILTER__STOP :
            ReleaseAllRecordings_ () ;
            KillTimer (m_hwndDialog, CAP_GRAPH_ACTIVE_SEC_TIMER) ;
            EndDialog (Hwnd, NO_ERROR) ;
            return TRUE ;

        case WM_COMMAND :

            switch (LOWORD (wParam)) {
                case IDC_CAP_GRAPH_STOP :
                    CapGraphStop () ;
                    break ;

                case IDC_CAP_GRAPH_PAUSE :
                    CapGraphPause () ;
                    break ;

                case IDC_CAP_GRAPH_RUN :
                    CapGraphRun () ;
                    break ;

                case IDC_LOCK_DVRSTREAMSINK :
                    LockDVRStreamSink () ;
                    break ;

                case IDC_INIT_DVRSTREAMSOURCE :
                    InitDVRStreamSource () ;
                    break ;

                case IDC_REC_CREATE :
                    CreateRecording () ;
                    break ;

                case IDC_REC_START :
                    StartRecordingSelected () ;
                    break ;

                case IDC_REC_STOP :
                    StopRecordingSelected () ;
                    break ;
            } ;
    } ;

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\fg.h ===
#ifndef __fg_h
#define __fg_h

class CCapGraphFilter ;

IUnknown *
FindFilter (
    IN  IFilterGraph *  pIFG,
    IN  REFIID          riid
    ) ;

#define FIND_FILTER(pfg, ifc)   (reinterpret_cast <ifc *> (FindFilter (pfg, IID_ ## ifc)))

class CDShowFilterGraph
{
    protected :

        CCapGraphFilter *   m_pCapGraphFilter ;
        IFilterGraph *      m_pIFilterGraph ;
        IMediaControl *     m_pIMediaControl ;
        IMediaEventEx *     m_pIMediaEventEx ;

    public :

        CDShowFilterGraph (
            IN  CCapGraphFilter *   pCapGraphFilter,
            IN  WCHAR *             pszGRF,
            OUT HRESULT *           phr
            ) ;

        virtual
        ~CDShowFilterGraph (
            ) ;

        ULONG AddRef () ;
        ULONG Release () ;
        HRESULT QueryInterface (REFIID riid, void ** ppv) ;

        HRESULT Run     () ;
        HRESULT Pause   () ;
        HRESULT Stop    () ;
} ;

class CDVRCapGraph :
    public CDShowFilterGraph
{
    IDVRStreamSink *    m_pIDVRStreamSink ;

    public :

        CDVRCapGraph (
            IN  CCapGraphFilter *   pCapGraphFilter,
            IN  WCHAR *             pszGRF,
            OUT HRESULT *           phr
            ) ;

        ~CDVRCapGraph (
            ) ;

        HRESULT
        GetIDVRStreamSink (
            OUT IDVRStreamSink **   ppIDVRStreamSink
            ) ;

        HRESULT
        CreateRecorder (
            IN  LPCWSTR     pszFilename,
            OUT IUnknown ** punkRecorder
            ) ;
} ;

#endif  //  __fg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\fg.cpp ===
#include "precomp.h"

IUnknown *
FindFilter (
    IN  IFilterGraph *  pIFG,
    IN  REFIID          riid
    )
{
    HRESULT         hr ;
    IEnumFilters *  pIEnumFilters ;
    IBaseFilter *   pIBaseFilter ;
    ULONG           ul ;
    IUnknown *      punkRet ;

    if (!pIFG) {
        return NULL ;
    }

    punkRet = NULL ;

    pIEnumFilters = NULL ;
    hr = pIFG -> EnumFilters (& pIEnumFilters) ;
    if (SUCCEEDED (hr)) {
        //  find the network provider

        ASSERT (pIEnumFilters) ;

        pIBaseFilter = NULL ;

        for (;;) {

            hr = pIEnumFilters -> Next (1, & pIBaseFilter, & ul) ;
            if (FAILED (hr) ||
                ul == 0) {

                break ;
            }

            ASSERT (pIBaseFilter) ;

            punkRet = NULL ;
            hr = pIBaseFilter -> QueryInterface (riid, (void **) & punkRet) ;

            if (SUCCEEDED (hr)) {
                ASSERT (punkRet) ;

                //  release the ref we got from the enumeration & break
                RELEASE_AND_CLEAR (pIBaseFilter) ;
                break ;
            }
            else {
                RELEASE_AND_CLEAR (pIBaseFilter) ;
            }
        }

        RELEASE_AND_CLEAR (pIEnumFilters) ;
    }

    return punkRet ;
}

//  ============================================================================
//  ============================================================================

CDShowFilterGraph::CDShowFilterGraph (
    IN  CCapGraphFilter *   pCapGraphFilter,
    IN  WCHAR *             pszGRF,
    OUT HRESULT *           phr
    ) : m_pIFilterGraph     (NULL),
        m_pIMediaControl    (NULL),
        m_pIMediaEventEx    (NULL),
        m_pCapGraphFilter   (pCapGraphFilter)
{
    IGraphBuilder * pIGraphBuilder ;

    ASSERT (pszGRF) ;
    ASSERT (m_pCapGraphFilter) ;

    pIGraphBuilder = NULL ;

    (* phr) = CoCreateInstance (CLSID_FilterGraph, NULL, CLSCTX_INPROC, IID_IFilterGraph, (void**) & m_pIFilterGraph) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIFilterGraph -> QueryInterface (IID_IGraphBuilder, (void **) & pIGraphBuilder) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = pIGraphBuilder -> RenderFile (pszGRF, NULL) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIFilterGraph -> QueryInterface (IID_IMediaControl, (void **) & m_pIMediaControl) ;
    if (FAILED (* phr)) { goto cleanup ; }

    (* phr) = m_pIFilterGraph -> QueryInterface (IID_IMediaEventEx, (void **) & m_pIMediaEventEx) ;
    if (FAILED (* phr)) { goto cleanup ; }

    cleanup :

    RELEASE_AND_CLEAR (pIGraphBuilder) ;

    return ;
}

CDShowFilterGraph::~CDShowFilterGraph (
    )
{
    RELEASE_AND_CLEAR (m_pIFilterGraph) ;
    RELEASE_AND_CLEAR (m_pIMediaControl) ;
    RELEASE_AND_CLEAR (m_pIMediaEventEx) ;
}

ULONG   CDShowFilterGraph::AddRef ()                                    { return m_pCapGraphFilter -> AddRef () ; }
ULONG   CDShowFilterGraph::Release ()                                   { return m_pCapGraphFilter -> Release () ; }
HRESULT CDShowFilterGraph::QueryInterface (REFIID riid, void ** ppv)    { return m_pCapGraphFilter -> QueryInterface (riid, ppv) ; }

HRESULT
CDShowFilterGraph::Run (
    )
{
    HRESULT hr ;

    ASSERT (m_pIMediaControl) ;
    hr = m_pIMediaControl -> Run () ;

    return hr ;
}

HRESULT
CDShowFilterGraph::Pause (
    )
{
    HRESULT hr ;

    ASSERT (m_pIMediaControl) ;
    hr = m_pIMediaControl -> Pause () ;

    return hr ;
}

HRESULT
CDShowFilterGraph::Stop (
    )
{
    HRESULT hr ;

    ASSERT (m_pIMediaControl) ;
    hr = m_pIMediaControl -> Stop () ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

CDVRCapGraph::CDVRCapGraph (
    IN  CCapGraphFilter *   pCapGraphFilter,
    IN  WCHAR *             pszGRF,
    OUT HRESULT *           phr
    ) : CDShowFilterGraph   (pCapGraphFilter,
                             pszGRF,
                             phr),
        m_pIDVRStreamSink   (NULL)
{
    if (FAILED (* phr)) { goto cleanup ; }

    m_pIDVRStreamSink = FIND_FILTER (m_pIFilterGraph, IDVRStreamSink) ;
    if (!m_pIDVRStreamSink) {
        (* phr) = E_NOINTERFACE ;
        goto cleanup ;
    }

    cleanup :

    return ;
}

CDVRCapGraph::~CDVRCapGraph (
    )
{
    RELEASE_AND_CLEAR (m_pIDVRStreamSink) ;
}

HRESULT
CDVRCapGraph::GetIDVRStreamSink (
    OUT IDVRStreamSink **   ppIDVRStreamSink
    )
{
    ASSERT (ppIDVRStreamSink) ;
    ASSERT (m_pIDVRStreamSink) ;

    (* ppIDVRStreamSink) = m_pIDVRStreamSink ;
    (* ppIDVRStreamSink) -> AddRef () ;

    return S_OK ;
}

HRESULT
CDVRCapGraph::CreateRecorder (
    IN  LPCWSTR     pszFilename,
    OUT IUnknown ** ppunkRecorder
    )
{
    HRESULT hr ;

    hr = m_pIDVRStreamSink -> CreateRecorder (pszFilename, 0, ppunkRecorder) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\uictrl.cpp ===
#include "precomp.h"

//  ============================================================================
//  ============================================================================

CControlBase::CControlBase (
    HWND    hwnd,
    DWORD   id
    )
{
    ASSERT (hwnd) ;

    m_hwnd = GetDlgItem (hwnd, id) ;
    m_id = id ;
}

HWND
CControlBase::GetHwnd (
    )
{
    return m_hwnd ;
}

DWORD
CControlBase::GetId (
    )
{
    return m_id ;
}

//  ============================================================================
//  ============================================================================

CEditControl::CEditControl (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
    ASSERT (hwnd) ;
}

void
CEditControl::SetTextW (
    WCHAR * szText
    )
{
    ASSERT (szText) ;

    SetWindowText (m_hwnd, szText) ;
}

void
CEditControl::SetTextW (
    INT val
    )
{
    WCHAR achbuffer [32] ;
    SetTextW (_itow (val, achbuffer, 10)) ;
}

int
CEditControl::GetTextW (
    INT *   val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 31)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CEditControl::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    int r ;

    r = GetWindowText (m_hwnd, ach, MaxChars - 1) ;

    return r ;
}

LRESULT
CEditControl::ResetContent ()
{
    return SendMessage (m_hwnd, WM_CLEAR, 0, 0) ;
}

//  ============================================================================
//  ============================================================================

CCombobox::CCombobox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
}

int
CCombobox::AppendW (
    WCHAR *  sz
    )
{
    return (int) SendMessage (m_hwnd, CB_ADDSTRING, 0, (LPARAM) sz) ;
}

int
CCombobox::AppendW (
    INT val
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return AppendW (_itow (val, achbuffer, 10)) ;
}

int
CCombobox::InsertW (
    WCHAR * sz,
    int     index)
{
    return (int) SendMessage (m_hwnd, CB_INSERTSTRING, (WPARAM) index, (LPARAM) sz) ;
}

int
CCombobox::InsertW (
    INT val,
    int index
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return InsertW (_itow (val, achbuffer, 10), index) ;
}

BOOL
CCombobox::DeleteRow (
    int iRow
    )
{
    return (SendMessage (m_hwnd, CB_DELETESTRING, (WPARAM) iRow, 0) != CB_ERR) ;
}

int
CCombobox::GetItemCount (
    )
{
    return (int) SendMessage (m_hwnd, CB_GETCOUNT, 0, 0) ;
}

int
CCombobox::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    int     index ;
    int     count ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        //  might be that it's not a dropdown list - in which case we get;
        //  try to get just the edit control's text; if that fails, return
        //  a failure, otherwise we're ok

        count = GetWindowText (m_hwnd, ach, MaxChars - 1) ;
        if (count == 0) {
            return CB_ERR ;
        }

        return count ;
    }

    //  make sure it will fit
    if (SendMessage (m_hwnd, CB_GETLBTEXTLEN, (WPARAM) index, 0) + 1 > MaxChars) {
        return CB_ERR ;
    }

    count = (int) SendMessage (m_hwnd, CB_GETLBTEXT, (WPARAM) index, (LPARAM) ach) ;

    return count ;
}

int
CCombobox::GetTextW (
    int * val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 32)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CCombobox::Focus (
    int index
    )
{
    return (int) SendMessage (m_hwnd, CB_SETCURSEL, (WPARAM) index, 0) ;
}

LRESULT
CCombobox::ResetContent (
    )
{
    return SendMessage (m_hwnd, CB_RESETCONTENT, 0, 0) ;
}

int
CCombobox::SetItemData (
    DWORD_PTR   val,
    int         index
    )
{
    return (int) SendMessage (m_hwnd, CB_SETITEMDATA, (WPARAM) index, (LPARAM) val) ;
}

int
CCombobox::GetCurrentItemIndex (
    )
{
    return (int) SendMessage (m_hwnd, CB_GETCURSEL, 0, 0) ;
}

DWORD_PTR
CCombobox::GetItemData (
    DWORD_PTR * pval,
    int         index
    )
{
    DWORD_PTR   dwp ;

    ASSERT (pval) ;

    dwp = SendMessage (m_hwnd, CB_GETITEMDATA, (WPARAM) index, 0) ;
    (* pval) = dwp ;

    return dwp ;
}

DWORD_PTR
CCombobox::GetCurrentItemData (
    DWORD_PTR * pval
    )
{
    int index ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        (* pval) = CB_ERR ;
        return CB_ERR ;
    }

    return GetItemData (pval, index) ;
}

BOOL
CCombobox::SetCurSelected (
    IN  int iIndex
    )
{
    return (SendMessage (m_hwnd, CB_SETCURSEL, (WPARAM) iIndex, 0) != CB_ERR ? TRUE : FALSE) ;
}

//  ============================================================================
//  ============================================================================

CListview::CListview (
    HWND hwnd,
    DWORD id
    ) : CControlBase (hwnd, id),
        m_cColumns (0)
{
}

LRESULT
CListview::ResetContent (
    )
{
    return SendMessage (m_hwnd, LVM_DELETEALLITEMS, 0, 0) ;
}

BOOL
CListview::SetData (
    DWORD_PTR   dwData,
    int         iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.lParam   = (LPARAM) dwData ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::SetTextW (
    WCHAR * sz,
    int iRow,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    ASSERT (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = sz ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::SetTextW (
    int iVal,
    int iRow,
    int iCol
    )
{
    WCHAR   ach [32] ;

    wsprintf (ach, L"%d", iVal) ;
    return SetTextW (ach, iRow, iCol) ;
}

int
CListview::InsertRowIcon (
    int iIcon
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_IMAGE ;
    lvItem.iImage   = iIcon ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowValue (
    DWORD_PTR dwp
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.lParam   = (LPARAM) dwp ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowNumber (
    int i,
    int iCol
    )
{
    WCHAR achbuffer [16] ;

    return InsertRowTextW (
                    _itow (i, achbuffer, 10),
                    iCol
                    ) ;
}

int
CListview::InsertRowTextW (
    WCHAR * sz,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    ASSERT (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = sz ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::DeleteRow (
    int iRow
    )
{
    return ListView_DeleteItem (m_hwnd, iRow) ;
}

int
CListview::GetSelectedCount (
    )
{
    return ListView_GetSelectedCount (m_hwnd) ;
}

int
CListview::GetSelectedRow (
    int iStartRow
    )
{
    return ListView_GetNextItem (m_hwnd, iStartRow, LVNI_SELECTED) ;
}

DWORD_PTR
CListview::GetData (
    int iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = m_cColumns ;

    return ListView_GetItem (m_hwnd, & lvItem) ? lvItem.lParam : NULL ;
}

DWORD_PTR
CListview::GetData (
    )
{
    int iRow ;

    iRow = ListView_GetNextItem (m_hwnd, -1, LVNI_SELECTED) ;

    if (iRow == -1) {
        return NULL ;
    }

    return GetData (iRow) ;
}

DWORD
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    IN  int     cMax,
    OUT WCHAR * psz
    )
{
    //  leave room for the null-terminator
    ListView_GetItemText (m_hwnd, iRow, iCol, psz, cMax - 1) ;

    return wcslen (psz) ;
}

int
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    OUT int *   val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetRowTextW (iRow, iCol, 32, achbuffer)) {
        * val = _wtoi (achbuffer) ;
    }

    return (* val) ;
}

int
CListview::InsertColumnW (
    WCHAR * szColumnName,
    int ColumnWidth,
    int iCol
    )
{
    LVCOLUMN    lvColumn = {0} ;
    int         r ;

    ASSERT (szColumnName) ;

    lvColumn.mask       = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt        = LVCFMT_LEFT;
    lvColumn.cx         = ColumnWidth ;
    lvColumn.pszText    = szColumnName ;

    r = ListView_InsertColumn (m_hwnd, iCol, & lvColumn) ;

    if (r != -1) {
        m_cColumns++ ;
    }

    return r ;
}

HIMAGELIST
CListview::SetImageList_ (
    HIMAGELIST  imgList,
    int         List
    )
{
    return ListView_SetImageList (m_hwnd, imgList, List) ;
}

HIMAGELIST
CListview::SetImageList_SmallIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_SMALL) ;
}

HIMAGELIST
CListview::SetImageList_NormalIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_NORMAL) ;
}

HIMAGELIST
CListview::SetImageList_State (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_STATE) ;
}

BOOL
CListview::SetState (
    int Index,
    int Row
    )
{
    //  setting or clearing ?
    if (Index > 0) {
        ListView_SetItemState (
                m_hwnd,
                Row,
                INDEXTOSTATEIMAGEMASK(Index),
                LVIS_STATEIMAGEMASK
                ) ;
    }
    else {
        ListView_SetItemState (m_hwnd, Row, 0, LVIS_STATEIMAGEMASK) ;
        ListView_RedrawItems (m_hwnd, Row, Row) ;
    }

    return TRUE ;
}

int
CListview::GetItemCount (
    )
{
    return (int) SendMessage (m_hwnd, LVM_GETITEMCOUNT, 0, 0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by capf.rc
//
#define IDD_CAP_GRAPH_FILTER            101
#define IDI_ACTIVE_REC                  102
#define IDC_CAP_GRAPH_STOP              1000
#define IDC_CAP_GRAPH_PAUSE             1001
#define IDC_CAP_GRAPH_RUN               1002
#define IDC_LOCK_DVRSTREAMSINK          1003
#define IDC_INIT_DVRSTREAMSOURCE        1004
#define IDC_REC_CREATE                  1007
#define IDC_REC_LIST                    1008
#define IDC_REC_FILENAME                1009
#define IDC_REC_START                   1010
#define IDC_REC_STOP                    1011
#define IDC_START_ABS_SEC               1012
#define IDC_STOP_ABS_SEC                1013
#define IDC_PLAY                        1015
#define IDC_CAPGRAPH_ACTIVE_SEC         1016
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\dll\precomp.h ===
#include "projpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\capfilter\uictrl.h ===
class CControlBase ;
class CEditControl ;
class CCombobox ;
class CListview ;

class AM_NOVTABLE CControlBase
{
    protected :

        HWND    m_hwnd ;
        DWORD   m_id ;


    public :

        CControlBase (
            HWND    hwnd,
            DWORD   id
            ) ;

        HWND
        GetHwnd (
            ) ;

        DWORD
        GetId (
            ) ;

        virtual
        LRESULT
        ResetContent (
            ) = 0 ;
} ;

class CEditControl :
    public CControlBase
{
    public :

        CEditControl (
            HWND    hwnd,
            DWORD   id
            ) ;

        void
        SetTextW (
            WCHAR *
            ) ;

        void
        SetTextW (
            INT val
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        GetTextW (
            INT *   val
            ) ;

        LRESULT
        ResetContent (
            ) ;
} ;

class CCombobox :
    public CControlBase
{
    public :

        CCombobox (
            HWND    hwnd,
            DWORD   id) ;

        int
        AppendW (
            WCHAR *
            ) ;

        int
        AppendW (
            INT val
            ) ;

        int
        InsertW (
            WCHAR *,
            int index = 0
            ) ;

        int
        InsertW (
            INT val,
            int index = 0
            ) ;

        BOOL
        DeleteRow (
            int
            ) ;

        int
        GetItemCount (
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        GetTextW (
            int *
            ) ;

        LRESULT
        ResetContent (
            ) ;

        int
        Focus (
            int index = 0
            ) ;

        int
        SetItemData (
            DWORD_PTR val,
            int index
            ) ;

        DWORD_PTR
        GetCurrentItemData (
            DWORD_PTR *
            ) ;

        DWORD_PTR
        GetItemData (
            DWORD_PTR *,
            int index
            ) ;

        int
        GetCurrentItemIndex (
            ) ;

        BOOL
        SetCurSelected (
            IN  int
            ) ;
} ;

class CListview :
    public CControlBase
{
    int m_cColumns ;

    HIMAGELIST
    SetImageList_ (
        HIMAGELIST,
        int
        ) ;

    public :

        CListview (
            HWND hwnd,
            DWORD id
            ) ;

        LRESULT
        ResetContent (
            ) ;

        HIMAGELIST
        SetImageList_SmallIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_NormalIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_State (
            HIMAGELIST
            ) ;

        int
        GetItemCount (
            ) ;

        BOOL
        SetState (
            int Index,      //  1-based; if 0, clears
            int Row
            ) ;

        int
        InsertColumnW (
            WCHAR *,
            int ColumnWidth,
            int iCol = 0
            ) ;

        int
        InsertRowIcon (
            int
            ) ;

        int
        InsertRowTextW (
            WCHAR *,
            int iCol = 1
            ) ;

        //  inserts a row, but converts the number to a string first
        int
        InsertRowNumber (
            int i,
            int iCol = 1
            ) ;

        int
        InsertRowValue (
            DWORD_PTR
            ) ;

        BOOL
        DeleteRow (
            int
            ) ;

        BOOL
        SetData (
            DWORD_PTR   dwData,
            int         iRow
            ) ;

        BOOL
        SetTextW (
            WCHAR *,
            int iRow,
            int iCol
            ) ;

        BOOL
        SetTextW (
            int iVal,
            int iRow,
            int iCol
            ) ;

        int
        GetSelectedCount (
            ) ;

        int
        GetSelectedRow (
            int iStartRow = -1
            ) ;

        DWORD_PTR
        GetData (
            int iRow
            ) ;

        DWORD_PTR
        GetData (
            ) ;

        DWORD
        GetRowTextW (
            IN  int iRow,
            IN  int iCol,       //  0-based
            IN  int cMax,
            OUT WCHAR *
            ) ;

        int
        GetRowTextW (
            IN  int     iRow,
            IN  int     iCol,
            OUT int *   val
            ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\dll\main.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        main.cpp

    Abstract:

        Contains filter registration information.

    Notes:

--*/

#include "precomp.h"
#include <initguid.h>

#include "dsnetifc.h"
#include "dsrecv.h"
#include "proprecv.h"
#include "dssend.h"
#include "propsend.h"

CFactoryTemplate g_Templates [] = {

    //  stream receiver filter
    {   NET_RECEIVE_FILTER_NAME,
        & CLSID_DSNetReceive,
        CNetworkReceiverFilter::CreateInstance,
        NULL,
        & g_sudRecvFilter
    },

    //  receiver property page
    {   NET_RECEIVE_PROP_PAGE_NAME,
        & CLSID_IPMulticastRecvProppage,
        CNetRecvProp::CreateInstance,
        NULL,
        NULL
    },

    //  sender filter
    {   NET_SEND_FILTER_NAME,
        & CLSID_DSNetSend,
        CNetworkSend::CreateInstance,
        NULL,
        & g_sudSendFilter
    },

    //  sender property page
    {   NET_SEND_PROP_PAGE_NAME,
        & CLSID_IPMulticastSendProppage,
        CNetSendProp::CreateInstance,
        NULL,
        NULL
    }
};

int g_cTemplates = sizeof (g_Templates) / sizeof (g_Templates[0]);

//  register and unregister entry points

//
// DllRegisterSever
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2 (TRUE);
}

//
// DllUnregsiterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2 (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\include\controls.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        controls.h

    Abstract:

        Class declarations for thin win32 control message wrappers.

    Notes:

--*/

#ifndef controls_h
#define controls_h

class CControlBase
{
    HWND    m_hwnd ;
    DWORD   m_id ;

    protected :

        CControlBase (
            HWND    hwnd,
            DWORD   id
            ) ;

    public :

        HWND
        GetHwnd (
            ) ;

        DWORD
        GetId (
            ) ;

        virtual
        int
        ResetContent (
            ) = 0 ;
} ;

class CEditControl :
    public CControlBase
{
    public :

        CEditControl (
            HWND    hwnd,
            DWORD   id
            ) ;

        void
        SetTextW (
            WCHAR *
            ) ;

        void
        SetText (
            INT val
            ) ;

        int
        GetText (
            INT *   val
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        ResetContent (
            ) ;

        BOOL
        IsEmpty (
            ) ;
} ;

class CCombobox :
    public CControlBase
{
    public :

        CCombobox (
            HWND    hwnd,
            DWORD   id) ;

        int
        AppendW (
            WCHAR *
            ) ;

        int
        Append (
            INT val
            ) ;

        int
        InsertW (
            WCHAR *,
            int index = 0
            ) ;

        int
        Insert (
            INT val,
            int index = 0
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        GetText (
            int *
            ) ;

        int
        ResetContent (
            ) ;

        int
        Focus (
            int index = 0
            ) ;

        int
        SetItemData (
            DWORD val,
            int index
            ) ;

        int
        GetCurrentItemData (
            DWORD *
            ) ;

        int
        GetItemData (
            DWORD *,
            int index
            ) ;

        int
        GetCurrentItemIndex (
            ) ;

        int
        FindW (
            WCHAR *
            ) ;
} ;

#endif  // controls_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\include\nutil.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        nutil.h

    Abstract:


    Notes:

--*/


#ifndef __nutil_h
#define __nutil_h

class CNetBuffer ;
class CNetInterface ;

LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    ) ;

LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    ) ;

BOOL
IsMulticastIP (
    IN DWORD dwIP   //  network order
    ) ;

BOOL
IsUnicastIP (
    IN DWORD dwIP   //  network order
    ) ;

//  value exists:           retrieves it
//  value does not exist:   sets it
BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR szValName,
    OUT DWORD * pdw
    ) ;

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    ) ;

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    ) ;

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    ) ;

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    ) ;

//  ---------------------------------------------------------------------------
//  CNetBuffer
//  ---------------------------------------------------------------------------

class CNetBuffer
{
    enum {
        NETBUFFER_HEADER_LEN    = 2         //  counter
    } ;

    BYTE *          m_pbBuffer ;            //  buffer pointer for data

    BYTE *          m_pbPayload ;
    DWORD           m_dwPayloadLength ;     //  data length; <= allocated; does
                                            //   not include the header

    DWORD           m_dwAllocLength ;       //  allocated buffer length

    public :

        CNetBuffer (
            IN  DWORD       dwAllocLength,      //  how much to allocate
            OUT HRESULT *   phr                 //  success/failre of init
            ) ;

        virtual
        ~CNetBuffer (
            ) ;

        DWORD   GetHeaderLength ()              { return NETBUFFER_HEADER_LEN ; }

        BYTE *  GetBuffer ()                    { return m_pbBuffer ; }
        DWORD   GetBufferLength ()              { return m_dwAllocLength ; }
        DWORD   GetBufferSendLength ()          { return GetActualPayloadLength () + GetHeaderLength () ; }

        BYTE *  GetPayloadBuffer ()             { return m_pbBuffer + GetHeaderLength () ; }
        DWORD   GetPayloadBufferLength ()       { return m_dwAllocLength - GetHeaderLength () ; }

        DWORD   GetActualPayloadLength ()               { return m_dwPayloadLength ; }
        void    SetActualPayloadLength (IN DWORD dw)    { ASSERT (dw <= m_dwAllocLength - GetHeaderLength ()) ; m_dwPayloadLength = dw ; }

        void    SetCounter (IN WORD w)          { * (UNALIGNED WORD *) (m_pbBuffer) = htons (w) ; }
        WORD    GetCounter ()                   { return ntohs (* (UNALIGNED WORD *) (m_pbBuffer)) ; }
} ;

#if 0
class CRTPUtil
{
    /*

    from RFC 1889:
    ============================================================================

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|X|  CC   |M|     PT      |       sequence number         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           timestamp                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           synchronization source (SSRC) identifier            |
    +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    |            contributing source (CSRC) identifiers             |
    |                             ....                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    The first twelve octets are present in every RTP packet, while the
    list of CSRC identifiers is present only when inserted by a mixer.
    The fields have the following meaning:

    version (V): 2 bits
        This field identifies the version of RTP. The version defined by
        this specification is two (2). (The value 1 is used by the first
        draft version of RTP and the value 0 is used by the protocol
        initially implemented in the "vat" audio tool.)

    padding (P): 1 bit
        If the padding bit is set, the packet contains one or more
        additional padding octets at the end which are not part of the
        payload. The last octet of the padding contains a count of how
        many padding octets should be ignored. Padding may be needed by
        some encryption algorithms with fixed block sizes or for
        carrying several RTP packets in a lower-layer protocol data
        unit.

    extension (X): 1 bit
        If the extension bit is set, the fixed header is followed by
        exactly one header extension, with a format defined in Section
        5.3.1.

    CSRC count (CC): 4 bits
        The CSRC count contains the number of CSRC identifiers that
        follow the fixed header.

    marker (M): 1 bit
        The interpretation of the marker is defined by a profile. It is
        intended to allow significant events such as frame boundaries to
        be marked in the packet stream. A profile may define additional
        marker bits or specify that there is no marker bit by changing
        the number of bits in the payload type field (see Section 5.3).

    payload type (PT): 7 bits
        This field identifies the format of the RTP payload and
        determines its interpretation by the application. A profile
        specifies a default static mapping of payload type codes to
        payload formats. Additional payload type codes may be defined
        dynamically through non-RTP means (see Section 3). An initial
        set of default mappings for audio and video is specified in the
        companion profile Internet-Draft draft-ietf-avt-profile, and
        may be extended in future editions of the Assigned Numbers RFC
        [6].  An RTP sender emits a single RTP payload type at any given
        time; this field is not intended for multiplexing separate media
        streams (see Section 5.2).

    sequence number: 16 bits
        The sequence number increments by one for each RTP data packet
        sent, and may be used by the receiver to detect packet loss and
        to restore packet sequence. The initial value of the sequence
        number is random (unpredictable) to make known-plaintext attacks
        on encryption more difficult, even if the source itself does not
        encrypt, because the packets may flow through a translator that
        does. Techniques for choosing unpredictable numbers are
        discussed in [7].

    timestamp: 32 bits
        The timestamp reflects the sampling instant of the first octet
        in the RTP data packet. The sampling instant must be derived

        from a clock that increments monotonically and linearly in time
        to allow synchronization and jitter calculations (see Section
        6.3.1).  The resolution of the clock must be sufficient for the
        desired synchronization accuracy and for measuring packet
        arrival jitter (one tick per video frame is typically not
        sufficient).  The clock frequency is dependent on the format of
        data carried as payload and is specified statically in the
        profile or payload format specification that defines the format,
        or may be specified dynamically for payload formats defined
        through non-RTP means. If RTP packets are generated
        periodically, the nominal sampling instant as determined from
        the sampling clock is to be used, not a reading of the system
        clock. As an example, for fixed-rate audio the timestamp clock
        would likely increment by one for each sampling period.  If an
        audio application reads blocks covering 160 sampling periods
        from the input device, the timestamp would be increased by 160
        for each such block, regardless of whether the block is
        transmitted in a packet or dropped as silent.

    The initial value of the timestamp is random, as for the sequence
    number. Several consecutive RTP packets may have equal timestamps if
    they are (logically) generated at once, e.g., belong to the same
    video frame. Consecutive RTP packets may contain timestamps that are
    not monotonic if the data is not transmitted in the order it was
    sampled, as in the case of MPEG interpolated video frames. (The
    sequence numbers of the packets as transmitted will still be
    monotonic.)

    SSRC: 32 bits
        The SSRC field identifies the synchronization source. This
        identifier is chosen randomly, with the intent that no two
        synchronization sources within the same RTP session will have
        the same SSRC identifier. An example algorithm for generating a
        random identifier is presented in Appendix A.6. Although the
        probability of multiple sources choosing the same identifier is
        low, all RTP implementations must be prepared to detect and
        resolve collisions.  Section 8 describes the probability of
        collision along with a mechanism for resolving collisions and
        detecting RTP-level forwarding loops based on the uniqueness of
        the SSRC identifier. If a source changes its source transport
        address, it must also choose a new SSRC identifier to avoid
        being interpreted as a looped source.

    CSRC list: 0 to 15 items, 32 bits each
        The CSRC list identifies the contributing sources for the
        payload contained in this packet. The number of identifiers is
        given by the CC field. If there are more than 15 contributing
        sources, only 15 may be identified. CSRC identifiers are
        inserted by mixers, using the SSRC identifiers of contributing
        sources. For example, for audio packets the SSRC identifiers of
        all sources that were mixed together to create a packet are
        listed, allowing correct talker indication at the receiver.
    */

    void WriteBIT   (BYTE * pb, int iByte, BOOL fBit, int iBit) { fBit ? (pb [iByte] |= 1 << iBit) : (pb [iByte] &= ~(1 << iBit)))
    void WriteBYTE  (BYTE * pb, int iByte, BYTE b)              { pb [iByte] = b ; }
    void WriteWORD  (BYTE * pb, int iByte, WORD w)              { (* (UNALIGNED WORD *) (& (pb [iByte]))) = w ; }
    void WriteDWORD (BYTE * pb, int iByte, DWORD dw)            { (* (UNALIGNED DWORD *) (& (pb [iByte]))) = dw ; }

    BOOL    GetBIT      (BYTE * pb, int iByte, int iBit)        { return ((pb [iByte] & (0x01 << iBit)) != 0x00 ? TRUE : FALSE) ; }
    BYTE    GetBYTE     (BYTE * pb, int iByte)                  { return pb [iByte] ; }
    WORD    GetWORD     (BYTE * pb, int iByte)                  { return (* (UNALIGNED WORD &) (& (pb [iByte]))) ; }
    DWORD   GetDWORD    (BYTE * pb, int iByte)                  { return (* (UNALIGNED DWORD &) (& (pb [iByte]))) ; }

    public :

        enum {
            RTP_CORE_HEADER_LENGTH  = 12,   //  [version, SSRC] fields

            RTP_CSRC_ID_LEN         = 4
        } ;

        static void Initialize (BYTE * pbRTPHeader)         { ZeroMemory (pbRTPHeader, RTP_CORE_HEADER_LENGTH) ; }

        static DWORD GetVersionNumber (BYTE * pbRTPHeader)  { return (GetBYTE (pbRTPHeader, 0) & 0x03) ; }
        static void WriteVersionNumber (
            IN  BYTE *  pbRTPHeader,
            IN  DWORD   dwVersionNumber)    { WriteBYTE (pbRTPHeader, 0, (0x03 & dwVersionNumber)) ; }

        static BOOL GetPaddingBit (BYTE * pbRTPHeader)      { return GetBIT (pbRTPHeader, 0, 2) ; }
        static void SetPaddingBit (
            IN  BYTE *  pbRTPHeader,
            IN  BOOL    fPadding)       { WriteBIT (pbRTPHeader, 0, fPadding, 2) ; }

        static BOOL GetExtensionBit (BYTE * pbRTPHeader)    { return GetBIT (pbRTPHeader, 0, 3) ; }
        static void SetExtensionBit (
            IN  BYTE *  pbRTPHeader,
            IN  BOOL    fExtension)     { WriteBIT (pbRTPHeader, 0, fExtension, 3) ; }

        static DWORD GetCSRCCount (BYTE * pbRTPHeader)      { return (GetBYTE (pbRTPHeader, 0) & 0xf0) ; }
        static void SetCSRCCount (
            IN  BYTE *  pbRTPHeader,
            IN  DWORD   dwCSRCCount)    { WriteBYTE (pbRTPHeader, 0, 0xf0 & dwCSRCCount) ; }

        static BOOL GetMarkerBit (BYTE * pbRTPHeader)       { return GetBIT (pbRTPHeader, 1, 0) ; }
        static void SetMarkerBit (
            IN  BYTE *  pbRTPHeader,
            IN  BOOL    fMarker)        { WriteBIT (pbRTPHeader, 1, fMarker, 0) ; }

        static DWORD GetPayloadType (BYTE * pbRTPHeader)    { return (GetBYTE (pbRTPHeader, 1) & 0xfe) ; }
        static void SetPayloadType (
            IN  BYTE *  pbRTPHeader,
            IN  int     iPayloadType)   { WriteBYTE (pbRTPHeader, 1, 0xfe & iPayloadType) ; }

        static WORD GetSequenceNumber (BYTE * pbRTPHeader)  { return ntohs (GetWORD (pbRTPHeader, 4)) ; }
        static void SetSequenceNumber (
            IN  BYTE *  pbRTPHeader,
            IN  WORD    wSequenceNum)   { WriteWORD (pbRTPHeader, 4, htons (wSequenceNum)) ; }

        static DWORD GetTimestamp (BYTE * pbRTPHeader)      { return ntohl (GetDWORD (pbRTPHeader, 7)) ; }
        static void SetTimestamp (
            IN  BYTE *  pbRTPHeader,
            IN  DWORD   dwTimestamp)    { WriteWORD (pbRTPHeader, 7, htonl (dwTimestamp)) ; }

        static DWORD GetSSRC (BYTE * pbRTPHeader)           { return ntohl (GetDWORD (pbRTPHeader, 11)) ; }
        static void SetSSRC (
            IN  BYTE *  pbRTPHeader,
            IN  DWORD   dwSSRC)         { WriteDWORD (pbRTPHeader, 11, htonl (dwSSRC)) ; }

        static DWORD GetCSRC (
            IN  BYTE *  pbRTPHeader,
            IN  int     iCSRCIndex)     { return ntohl (GetDWORD (pbRTPHeader, RTP_CORE_HEADER_LENGTH - 1 + (iCSRCIndex * RTP_CSRC_ID_LEN))) ; }
        static DWORD SetCSRC (
            IN  BYTE *  pbRTPHeader,
            IN  int     iRTPHeaderBufferLen,
            IN  DWORD   dwCSRC,
            IN  int     iCSRCIndex)
        {
            if ((iCSRCIndex + 1) * RTP_CSRC_ID_LEN <= iRTPHeaderBufferLen) {
                WriteDWORD (pbRTPHeader, RTP_CORE_HEADER_LENGTH - 1 + (iCSRCIndex * RTP_CSRC_ID_LEN), htonl (dwCSRC)) ;
                return NOERROR ;

            }
            else {
                return ERROR_GEN_FAILURE ;
            }
        }

        static int HeaderLength (
            IN BYTE * pbRTPHeader)
        {
            return RTP_CORE_HEADER_LENGTH + GetCSRCCount (pbRTPHeader) * RTP_CSRC_ID_LEN ;
        }
} ;
#endif

//  ---------------------------------------------------------------------------
//  CNetInterface - enumerates the network interfaces on the host
//  ---------------------------------------------------------------------------

class CNetInterface
{
    enum {
        NUM_NIC_FIRST_GUESS = 3,    //  1 NIC, 1 loopback, 1 extra
        MAX_SUPPORTED_IFC   = 32
    } ;

    INTERFACE_INFO *    m_pNIC ;
    ULONG               m_cNIC ;
    HANDLE              m_hHeap ;

    public :

        CNetInterface (
            ) ;

        ~CNetInterface (
            ) ;

        BOOL
        IsInitialized (
            ) ;

        HRESULT
        Initialize (
            ) ;

        INTERFACE_INFO *
        operator [] (
            ULONG i
            ) ;
} ;

#endif  //  __nutil_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\alloc.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        alloc.cpp

    Abstract:


    Notes:

--*/

#include "precomp.h"
#include "le.h"
#include "dsnetifc.h"
#include "buffpool.h"
#include "netrecv.h"
#include "dsrecv.h"
#include "mspool.h"
#include "alloc.h"

CNetRecvAlloc::CNetRecvAlloc (
    CBufferPool *               pBufferPool,
    CTSMediaSamplePool *        pMSPool,
    CNetworkReceiverFilter *    pRecvFilter
    ) : m_pBufferPool   (pBufferPool),
        m_pMSPool       (pMSPool),
        m_pRecvFilter   (pRecvFilter)
{
    ASSERT (m_pBufferPool) ;
    ASSERT (m_pMSPool) ;
    ASSERT (m_pRecvFilter) ;
}

CNetRecvAlloc::~CNetRecvAlloc (
    )
{
}

//  -------------------------------------------------------------------
//  IUnknown methods

STDMETHODIMP
CNetRecvAlloc::QueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (ppv == NULL) {
        return E_INVALIDARG ;
    }

    if (riid == IID_IUnknown ||
        riid == IID_IMemAllocator) {

        (* ppv) = reinterpret_cast <void *> (this) ;
    }
    else {
        return E_NOINTERFACE ;
    }

    ASSERT (* ppv) ;
    (reinterpret_cast <IUnknown *> (* ppv)) -> AddRef () ;

    return S_OK ;
}

STDMETHODIMP_(ULONG)
CNetRecvAlloc::AddRef (
    )
{
    return m_pRecvFilter -> AddRef () ;
}

STDMETHODIMP_(ULONG)
CNetRecvAlloc::Release (
    )
{
    return m_pRecvFilter -> Release () ;
}

//  -------------------------------------------------------------------
//  IMemAlloc methods

// negotiate buffer sizes, buffer count and alignment. pRequest is filled
// in by the caller with the requested values. pActual will be returned
// by the allocator with the closest that the allocator can come to this.
// Cannot be called unless the allocator is decommitted.
// Calls to GetBuffer need not succeed until Commit is called.
STDMETHODIMP
CNetRecvAlloc::SetProperties (
	IN  ALLOCATOR_PROPERTIES *  pRequest,
	OUT ALLOCATOR_PROPERTIES *  pActual
    )
{
    //  outright ignore what is requested
    return GetProperties (pActual) ;
}

// return the properties actually being used on this allocator
STDMETHODIMP
CNetRecvAlloc::GetProperties (
	OUT ALLOCATOR_PROPERTIES *  pProps
    )
{
    if (pProps == NULL) {
        return E_POINTER ;
    }

    pProps -> cBuffers  = m_pMSPool -> GetPoolSize () ;
    pProps -> cbBuffer  = m_pBufferPool -> GetBufferAllocatedLength () ;
    pProps -> cbAlign   = 1 ;
    pProps -> cbPrefix  = 0 ;

    return S_OK ;
}

// commit the memory for the agreed buffers
STDMETHODIMP
CNetRecvAlloc::Commit (
    )
{
    return S_OK ;
}

// release the memory for the agreed buffers. Any threads waiting in
// GetBuffer will return with an error. GetBuffer calls will always fail
// if called before Commit or after Decommit.
STDMETHODIMP
CNetRecvAlloc::Decommit (
    )
{
    return S_OK ;
}

// get container for a sample. Blocking, synchronous call to get the
// next free buffer (as represented by an IMediaSample interface).
// on return, the time etc properties will be invalid, but the buffer
// pointer and size will be correct.
// Will only succeed if memory is committed. If GetBuffer is blocked
// waiting for a buffer and Decommit is called on another thread,
// GetBuffer will return with an error.
STDMETHODIMP
CNetRecvAlloc::GetBuffer (
    OUT IMediaSample **     ppBuffer,
    IN  REFERENCE_TIME *    pStartTime,
    IN  REFERENCE_TIME *    pEndTime,
    IN  DWORD dwFlags
    )
{
    return E_NOTIMPL ;
}

// put a buffer back on the allocators free list.
// this is typically called by the Release() method of the media
// sample when the reference count goes to 0
//
STDMETHODIMP
CNetRecvAlloc::ReleaseBuffer (
    IN  IMediaSample * pBuffer
    )
{
    return E_NOTIMPL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\include\le.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        le.h

    Abstract:


    Notes:

--*/

#ifndef __le_h
#define __le_h

//  list macros (defined in ntrtl.h)

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#ifndef InitializeListHead
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#endif //   InitializeListHead

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#ifndef IsListEmpty
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#endif  //  IsListEmpty

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#ifndef RemoveHeadList
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#endif  //  RemoveHeadList

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#ifndef RemoveTailList
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#endif  //  RemoveTailList

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#ifndef RemoveEntryList
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#endif  //  RemoveEntryList

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#ifndef InsertTailList
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#endif  //  InsertTailList

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#ifndef InsertHeadList
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
#endif  //  InsertHeadList

//
//  inserts NewListEntry after ListEntry
//
//  VOID
//  InsertListEntry (
//      PLIST_ENTRY ListEntry,
//      PLIST_ENTRY NewListEntry
//      ) ;
//

#define InsertListEntry(ListEntry,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListEntry;\
    _EX_ListEntry = (ListEntry);\
    _EX_Flink = _EX_ListEntry->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListEntry;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListEntry->Flink = (Entry);\
    }

//
//  moves entire contents of FromListHead list to ToListHead list,
//  preserving order
//
//  VOID
//  MoveEntryList (
//      PLIST_ENTRY FromListHead,
//      PLIST_ENTRY ToListHead
//      ) ;
//

#define MoveEntryList(FromListHead,ToListHead) {\
    PLIST_ENTRY _EX_FromListHead;\
    PLIST_ENTRY _EX_ToListHead;\
    _EX_FromListHead = (FromListHead);\
    _EX_ToListHead = (ToListHead);\
    _EX_ToListHead->Flink = _EX_FromListHead->Flink;\
    _EX_ToListHead->Blink = _EX_FromListHead->Blink;\
    _EX_ToListHead->Flink->Blink = _EX_ToListHead;\
    _EX_ToListHead->Blink->Flink = _EX_ToListHead;\
    (FromListHead)->Flink = (FromListHead)->Blink = (FromListHead);\
    }

#endif  //  __le_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\buffpool.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        buffpool.cpp

    Abstract:


    Notes:

--*/


#include "precomp.h"
#include "le.h"
#include "buffpool.h"

//  ----------------------------------------------------------------------------
//  CBufferPoolBuffer
//  ----------------------------------------------------------------------------

CBufferPoolBuffer::CBufferPoolBuffer (
    IN  CBufferPool *   pBufferPool,
    IN  DWORD           dwBufferLength,
    OUT HRESULT *       phr
    ) : CNetBuffer      (dwBufferLength,
                         phr
                         ),
        m_pBufferPool   (pBufferPool),
        m_lRef          (0)
{
    //  initialize our LIST_ENTRY so it's not bogus
    InitializeListHead (& m_ListEntry) ;
}

CBufferPoolBuffer::~CBufferPoolBuffer (
    ) {}

ULONG
CBufferPoolBuffer::Release (
    )
{
    if (InterlockedDecrement (& m_lRef) == 0) {
        //  ref went to 0; recycle the CBufferPoolBuffer
        m_pBufferPool -> Recycle (this) ;
    }

    return m_lRef ;
}

//  ----------------------------------------------------------------------------
//  CBufferPool

CBufferPool::CBufferPool (
    IN  HKEY        hkeyRoot,
    OUT HRESULT *   phr
    ) : m_dwBufferAllocatedLength   (REG_DEF_BUFFER_LEN),
        m_dwPoolSize                (0)

{
    CBufferPoolBuffer * pBuffer ;
    DWORD               dwPoolSize ;

    dwPoolSize = REG_DEF_RECV_BUFFER_POOL ;
    GetRegDWORDValIfExist (
            hkeyRoot,
            REG_RECV_BUFFER_POOL_NAME,
            & dwPoolSize
            ) ;
    if (IsOutOfBounds <DWORD> (dwPoolSize, MIN_VALID_RECV_POOL_SIZE, MAX_VALID_RECV_POOL_SIZE)) {
        dwPoolSize = SetInBounds <DWORD> (dwPoolSize, MIN_VALID_RECV_POOL_SIZE, MAX_VALID_RECV_POOL_SIZE) ;
        SetRegDWORDVal (
            hkeyRoot,
            REG_RECV_BUFFER_POOL_NAME,
            dwPoolSize
            ) ;
    }

    m_dwBufferAllocatedLength = REG_DEF_BUFFER_LEN ;
    GetRegDWORDValIfExist (
            hkeyRoot,
            REG_BUFFER_LEN_NAME,
            & m_dwBufferAllocatedLength
            ) ;
    if (IsOutOfBounds <DWORD> (m_dwBufferAllocatedLength, MIN_VALID_IOBUFFER_LENGTH, MAX_VALID_IOBUFFER_LENGTH)) {
        m_dwBufferAllocatedLength = SetInBounds <DWORD> (m_dwBufferAllocatedLength, MIN_VALID_IOBUFFER_LENGTH, MAX_VALID_IOBUFFER_LENGTH) ;
        SetRegDWORDVal (
            hkeyRoot,
            REG_BUFFER_LEN_NAME,
            m_dwBufferAllocatedLength
            ) ;
    }

    //
    //  start with the non-failable operations
    //

    //  initialize the various lists we maintain
    InitializeListHead (& m_Buffers) ;      //  CBufferPoolBuffers
    InitializeListHead (& m_RequestPool) ;  //  request pool
    InitializeListHead (& m_Request) ;      //  outstanding requests

    //  our crit sect
    InitializeCriticalSection (& m_crt) ;

    //  now allocate each buffer
    for (m_dwPoolSize = 0; m_dwPoolSize < dwPoolSize; m_dwPoolSize++) {
        pBuffer = new CBufferPoolBuffer (
                        this,
                        m_dwBufferAllocatedLength,
                        phr
                        ) ;

        if (pBuffer == NULL ||
            FAILED (* phr)) {

            (* phr) = (FAILED (* phr) ? * phr : E_OUTOFMEMORY) ;
            return ;
        }

        //  hook into our list
        pBuffer -> InsertHead (& m_Buffers) ;
    }
}

CBufferPool::~CBufferPool (
    )
{
    CBufferPoolBuffer * pBuffer ;
    LIST_ENTRY *        pListEntry ;
    BLOCK_REQUEST *     pBlockRequest ;

    //  should not have any outstanding requests
    ASSERT (IsListEmpty (& m_Request)) ;

    //  release all resources associated with our request pool (non-outstanding)
    while (!IsListEmpty (& m_RequestPool)) {
        pListEntry = RemoveHeadList (& m_RequestPool) ;
        pBlockRequest = CONTAINING_RECORD (pListEntry, BLOCK_REQUEST, ListEntry) ;

        delete pBlockRequest ;
    }

    //  release all of our CBufferPoolBuffers
    while (!IsListEmpty (& m_Buffers)) {
        //  set pListEntry to head of our list
        pListEntry = m_Buffers.Flink ;

        //  recover the buffer; unhook it
        pBuffer = CBufferPoolBuffer::RecoverCBuffer (pListEntry) ;
        pBuffer -> Unhook () ;

        //  delete it
        delete pBuffer ;
    }

    //  our crit sect
    DeleteCriticalSection (& m_crt) ;
}

void
CBufferPool::Recycle (
    IN  CBufferPoolBuffer *   pBuffer
    )
/*++
    Routine Description:

        Recycles a CBufferPoolBuffer object.  Examines if there are outstanding
        requests in the list.  If there are, the request is set, signaled,
        and unhooked; the CBufferPoolBuffer never goes back into our list; only the
        request references it, so it's important during shutdown to have
        the request list be empty.

    Arguments:

        pBuffer - the buffer to recycle

    Return Values:

        none
--*/
{
    LIST_ENTRY *    pListEntry ;
    BLOCK_REQUEST * pBlockRequest ;

    Lock_ () ;

    //  check if there are queued outstanding requests
    if (!IsListEmpty (& m_Request)) {

        //  list is not empty, so there are queued requests

        //  pull from the head and recover the BLOCK_REQUEST
        pListEntry = RemoveHeadList (& m_RequestPool) ;
        pBlockRequest = CONTAINING_RECORD (pListEntry, BLOCK_REQUEST, ListEntry) ;

        //  set the buffer and addref (BLOCK_REQUEST's)
        pBlockRequest -> pBuffer = pBuffer ;
        pBuffer -> AddRef () ;

        //  signal; do this last
        SetEvent (pBlockRequest -> hEvent) ;
    }
    else {
        //  list is empty, so nobody is waiting

        //  insert into our list
        pBuffer -> InsertHead (& m_Buffers) ;
    }

    Unlock_ () ;
}

CBufferPoolBuffer *
CBufferPool::GetBuffer (
    IN  HANDLE  hEvent,
    IN  DWORD   dwTimeout
    )
/*++
    Routine Description:

        Gets a buffer if successful.

    Arguments:

        hEvent      - win32 event; must be of the manual reset variety

        dwTimeout   - max millis willing to wait for a buffer if none are
                        available

    Return Values:

        success     - non-NULL CBufferPoolBuffer pointer
        failure     - NULL

--*/
{
    DWORD           r ;
    CBufferPoolBuffer *       pBuffer ;
    LIST_ENTRY *    pListEntry ;
    BLOCK_REQUEST * pBlockRequest ;

    pBuffer = NULL ;

    Lock_ () ;

    if (!IsListEmpty (& m_Buffers)) {
        //  buffers are available

        //  recover & unhook
        pListEntry = m_Buffers.Flink ;
        pBuffer = CBufferPoolBuffer::RecoverCBuffer (pListEntry) ;
        pBuffer -> Unhook () ;

        //  outgoing ref
        pBuffer -> AddRef () ;
    }
    else {
        //  no buffers are available, wait

        //  get a request
        pBlockRequest = GetRequestLocked_ () ;
        if (pBlockRequest == NULL) {
            //  memory allocation failure most likely
            Unlock_ () ;

            return NULL ;
        }

        //  non-signal the event we'll wait on
        pBlockRequest -> hEvent = hEvent ;
        ResetEvent (pBlockRequest -> hEvent) ;

        //  insert into tail of request queue
        InsertTailList (& m_Request, & pBlockRequest -> ListEntry) ;

        //  release the lock and wait
        Unlock_ () ;
        r = WaitForSingleObject (hEvent, dwTimeout) ;

        //  reacquire the lock
        Lock_ () ;

        if (r == WAIT_TIMEOUT) {
            //  might have timed out and blocked on the lock aquisition while
            //  the BLOCK_REQUEST was being completed on the other side; if
            //  this is the case, we succeed the call, even though we timed
            //  out waiting

            if (pBlockRequest -> pBuffer == NULL) {

                //  actual timeout; recycle the BLOCK_REQUEST and punt
                RemoveEntryList (& pBlockRequest -> ListEntry) ;
                RecycleRequestLocked_ (pBlockRequest) ;
                Unlock_ () ;

                return NULL ;
            }
        }

        //  we have a buffer, whether or not we timed out in the process of
        //  getting it

        //  we'll return this
        pBuffer = pBlockRequest -> pBuffer ;

        //  recycle the request struct
        RecycleRequestLocked_ (pBlockRequest) ;
    }

    Unlock_ () ;

    return pBuffer ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\include\projpch.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        projpch.h

    Abstract:

        Common include for all components hosted in the AX file.

    Notes:

--*/

#ifndef __projpch_h
#define __projpch_h

#include <winsock2.h>
#include <streams.h>
#include <tchar.h>
#include <ws2tcpip.h>

#include "nutil.h"

#define LOOPBACK_IFC                    L"Loopback"
#define ANY_IFC                         L"any"
#define UNDEFINED_STR                   L"undefined"
//  combo boxes don't like to have -1 data associated with them, so we flag with the
//   next most unlikely value, I think ..
#define UNDEFINED                       ((-1) & ~1)

#define MAX_UDP_PAYLOAD                 (65535 - 20 - 8)
#define TS_PACKET_LENGTH                188

#define MAX_IOBUFFER_LENGTH             8192
#define MIN_VALID_IOBUFFER_LENGTH       100
#define MAX_VALID_IOBUFFER_LENGTH       MAX_UDP_PAYLOAD

#define RECV_POOL_SIZE                  64
#define MIN_VALID_RECV_POOL_SIZE        10
#define MAX_VALID_RECV_POOL_SIZE        128

#define RECV_MAX_PEND_READS             30
#define MIN_VALID_RECV_MAX_PEND_READS   1
#define MAX_VALID_RECV_MAX_PEND_READS   MAX_VALID_RECV_POOL_SIZE

#define RELEASE_AND_CLEAR(p)            if (p) { (p) -> Release () ; (p) = NULL ; }
#define DELETE_RESET(p)                 { delete (p) ; (p) = NULL ; }

template <class T> T Min (T a, T b) { return (a < b ? a : b) ; }
template <class T> T Max (T a, T b) { return (a > b ? a : b) ; }

template <class T> BOOL IsInBounds (T tVal, T tMin, T tMax) {
    if      (tVal < tMin)   return FALSE ;
    else if (tVal > tMax)   return FALSE ;
    else                    return TRUE ;
}

template <class T> BOOL IsOutOfBounds (T tVal, T tMin, T tMax) {
    return (IsInBounds (tVal, tMin, tMax) ? FALSE : TRUE) ;
}

template <class T> T SetInBounds (T tVal, T tMin, T tMax) {
    if      (tVal < tMin)   return tMin ;
    else if (tVal > tMax)   return tMax ;
    else                    return tVal ;
}

#define REG_DSNET_TOP_LEVEL             HKEY_LOCAL_MACHINE
#define REG_DSNET_ROOT                  TEXT ("SOFTWARE") TEXT ("\\") TEXT ("Microsoft") TEXT ("\\") TEXT ("DSNet")
#define REG_DSNET_RECV_ROOT             REG_DSNET_ROOT TEXT ("\\") TEXT ("Receive")
#define REG_DSNET_SEND_ROOT             REG_DSNET_ROOT TEXT ("\\") TEXT ("Send")

#define REG_BUFFER_LEN_NAME             TEXT ("IOBufferLength")
#define REG_DEF_BUFFER_LEN              MAX_IOBUFFER_LENGTH

#define REG_RECV_BUFFER_POOL_NAME       TEXT ("ReceiveBufferPool")
#define REG_DEF_RECV_BUFFER_POOL        RECV_POOL_SIZE

#define REG_RECV_MAX_READS_NAME         TEXT ("ReceiveMaxPendedReads")
#define REG_DEF_RECV_MAX_READS          RECV_MAX_PEND_READS

#define REG_RECV_REPORT_DISC_NAME       TEXT ("ReportDiscontinuities")
#define REG_DEF_RECV_REPORT_DISC        TRUE

#endif  __projpch_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\buffpool.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        buffpool.h

    Abstract:


    Notes:

--*/

#ifndef __buffpool_h
#define __buffpool_h

class CBufferPool ;
class CBufferPoolBuffer ;

/*++
    Class Name:

        CBufferPoolBuffer

    Abstract:

        Class of buffers into which we receive our multicast transport stream.

        We make no attempt to discover the right buffer size by peeking at
        the buffer size that is being multicast.  If we are instantiated and
        too small, too bad.  Since we're also writing the sender, we can
        coordinate buffer sizes for these two to be in sync.

--*/
class CBufferPoolBuffer :
    public CNetBuffer
{
    LONG            m_lRef ;                //  this object's ref; 0 when we're available
    CBufferPool *   m_pBufferPool ;         //  back pointer
    DWORD_PTR       m_dwCompletionContext ; //  anything
    LIST_ENTRY      m_ListEntry ;           //  list's link
    OVERLAPPED      m_Overlapped ;          //  OVERLAPPED struct we use

    public :

        CBufferPoolBuffer (
            IN  CBufferPool *   pBufferPool,        //  back pointer
            IN  DWORD           dwBufferLength,     //  how much to allocator
            OUT HRESULT *       phr                 //  success/failre of init
            ) ;

        ~CBufferPoolBuffer (
            ) ;

        //  LIST_ENTRY manipulation
        void InsertHead (IN LIST_ENTRY * pListHead) { ASSERT (IsListEmpty (& m_ListEntry)) ; InsertHeadList (pListHead, & m_ListEntry) ; }
        void Unhook ()                              { RemoveEntryList (& m_ListEntry) ; InitializeListHead (& m_ListEntry) ; }

        //  returns a pointer to the object's OVERLAPPED struct
        OVERLAPPED * GetOverlapped ()   { return & m_Overlapped ; }

        //  given a LIST_ENTRY, recovers the hosting CBufferPoolBuffer object
        static CBufferPoolBuffer * RecoverCBuffer (IN LIST_ENTRY * pListEntry)    { CBufferPoolBuffer * pBuffer = CONTAINING_RECORD (pListEntry, CBufferPoolBuffer, m_ListEntry) ;
                                                                          return pBuffer ; }

        //  async IO completion context; allows us to store information that
        //  allows us to recover when the IO completes
        void        SetCompletionContext (IN DWORD_PTR dw)  { m_dwCompletionContext = dw ; }
        DWORD_PTR   GetCompletionContext ()                 { return m_dwCompletionContext ; }

        //  refcounting
        ULONG AddRef () { return InterlockedIncrement (& m_lRef) ; }

        ULONG
        Release (
            ) ;
} ;

class CBufferPool
{
    //  struct is used to request a CBufferPoolBuffer object; the buffer pool maintains a
    //  pool of these structs to queue buffer requests when none are available.
    struct BLOCK_REQUEST {
        LIST_ENTRY  ListEntry ;
        HANDLE      hEvent ;
        CBufferPoolBuffer *   pBuffer ;
    } ;

    LIST_ENTRY          m_Buffers ;         //  CBufferPoolBuffer list
    LIST_ENTRY          m_RequestPool ;     //  BLOCK_REQUEST list; pool
    LIST_ENTRY          m_Request ;         //  BLOCK_REQUEST list; outstanding
    CRITICAL_SECTION    m_crt ;             //  lock to access the various lists
    DWORD               m_dwBufferAllocatedLength ; //  allocated length of each
    DWORD               m_dwPoolSize ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    //  gets a request object; must hold the pool lock
    BLOCK_REQUEST *
    GetRequestLocked_ (
        )
    {
        LIST_ENTRY *    pListEntry ;
        BLOCK_REQUEST * pBlockRequest ;

        if (IsListEmpty (& m_RequestPool) == FALSE) {
            //  list of unused is not empty; grab one
            pListEntry = RemoveHeadList (& m_RequestPool) ;
            pBlockRequest = CONTAINING_RECORD (pListEntry, BLOCK_REQUEST, ListEntry) ;
        }
        else {
            //  list is empty; must allocate
            pBlockRequest = new BLOCK_REQUEST ;
        }

        //  initialize correctly if we got 1
        if (pBlockRequest) {
            pBlockRequest -> hEvent = NULL ;
            pBlockRequest -> pBuffer = NULL ;
        }

        return pBlockRequest ;
    }

    //  recycles the given block request
    void
    RecycleRequestLocked_ (
        IN  BLOCK_REQUEST * pBlockRequest
        )
    {
        InsertHeadList (& m_RequestPool, & pBlockRequest -> ListEntry) ;
    }

    public :

        CBufferPool (
            IN  HKEY        hkeyRoot,
            OUT HRESULT *   phr             //  success/failure
            ) ;

        ~CBufferPool (
            ) ;

        DWORD GetBufferAllocatedLength ()   { return m_dwBufferAllocatedLength ; }
        DWORD GetBufferPoolSize ()          { return m_dwPoolSize ; }

        void
        Recycle (
            CBufferPoolBuffer *
            ) ;

        CBufferPoolBuffer *
        GetBuffer (
            IN  HANDLE  hEvent,                 //  manual reset
            IN  DWORD   dwTimeout = INFINITE
            ) ;
} ;

#endif  //  __buffpool_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\alloc.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        alloc.h

    Abstract:


    Notes:

--*/

#ifndef __alloc_h
#define __alloc_h

class CBufferPool ;
class CTSMediaSamplePool ;
class CNetworkReceiverFilter ;

/*++
    Class Name:

        CNetRecvAlloc

    Abstract:

        IMemAllocator object.  We insist on being the allocator.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        10/31/2000

--*/
class CNetRecvAlloc :
    public IMemAllocator
{
    CBufferPool *               m_pBufferPool ;
    CTSMediaSamplePool *        m_pMSPool ;
    CNetworkReceiverFilter *    m_pRecvFilter ;

    public :

        CNetRecvAlloc (
            CBufferPool *               pBufferPool,
            CTSMediaSamplePool *        pMSPool,
            CNetworkReceiverFilter *    pRecvFilter
            ) ;

        ~CNetRecvAlloc (
            ) ;

        //  -------------------------------------------------------------------
        //  class methods

        //  -------------------------------------------------------------------
        //  IUnknown methods

        STDMETHODIMP
        QueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        STDMETHODIMP_(ULONG)
        AddRef (
            ) ;

        STDMETHODIMP_(ULONG)
        Release (
            ) ;

        //  -------------------------------------------------------------------
        //  IMemAlloc methods

        // negotiate buffer sizes, buffer count and alignment. pRequest is filled
        // in by the caller with the requested values. pActual will be returned
        // by the allocator with the closest that the allocator can come to this.
        // Cannot be called unless the allocator is decommitted.
        // Calls to GetBuffer need not succeed until Commit is called.
        STDMETHODIMP
        SetProperties (
		    IN  ALLOCATOR_PROPERTIES *  pRequest,
		    OUT ALLOCATOR_PROPERTIES *  pActual
            ) ;

        // return the properties actually being used on this allocator
        STDMETHODIMP
        GetProperties (
		    OUT ALLOCATOR_PROPERTIES *  pProps
            ) ;


        // commit the memory for the agreed buffers
        STDMETHODIMP
        Commit (
            ) ;

        // release the memory for the agreed buffers. Any threads waiting in
        // GetBuffer will return with an error. GetBuffer calls will always fail
        // if called before Commit or after Decommit.
        STDMETHODIMP
        Decommit (
            ) ;

        // get container for a sample. Blocking, synchronous call to get the
        // next free buffer (as represented by an IMediaSample interface).
        // on return, the time etc properties will be invalid, but the buffer
        // pointer and size will be correct.
        // Will only succeed if memory is committed. If GetBuffer is blocked
        // waiting for a buffer and Decommit is called on another thread,
        // GetBuffer will return with an error.
        STDMETHODIMP
        GetBuffer (
            OUT IMediaSample **     ppBuffer,
            IN  REFERENCE_TIME *    pStartTime,
            IN  REFERENCE_TIME *    pEndTime,
            IN  DWORD dwFlags
            ) ;

        // put a buffer back on the allocators free list.
        // this is typically called by the Release() method of the media
        // sample when the reference count goes to 0
        //
        STDMETHODIMP
        ReleaseBuffer (
            IN  IMediaSample * pBuffer
            ) ;
} ;

#endif  //  __alloc_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\dsrecv.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dsrecv.cpp

    Abstract:


    Notes:

--*/


#include "precomp.h"
#include "le.h"
#include "nutil.h"
#include "dsnetifc.h"
#include "buffpool.h"
#include "netrecv.h"
#include "dsrecv.h"
#include "mspool.h"
#include "alloc.h"

//  ---------------------------------------------------------------------------
//  ---------------------------------------------------------------------------

CNetOutputPin::CNetOutputPin (
    IN  TCHAR *         szName,
    IN  CBaseFilter *   pFilter,
    IN  CCritSec *      pLock,
    OUT HRESULT *       pHr,
    IN  LPCWSTR         pszName
    ) : CBaseOutputPin  (szName,
                         pFilter,
                         pLock,
                         pHr,
                         pszName
                         ) {}

CNetOutputPin::~CNetOutputPin (
    ) {}

HRESULT
CNetOutputPin::GetMediaType (
    IN  int             iPosition,
    OUT CMediaType *    pmt
    )
{
    HRESULT hr ;

    if (iPosition == 0) {
        ASSERT (pmt) ;
        pmt -> InitMediaType () ;

        (* pmt) = m_MediaType ;

        hr = S_OK ;
    }
    else {
        hr = VFW_S_NO_MORE_ITEMS ;
    }

    return hr ;
}

HRESULT
CNetOutputPin::CheckMediaType (
    IN  const CMediaType * pmt
    )
{
    HRESULT hr ;

    ASSERT (pmt) ;
    hr = ((* pmt) == m_MediaType ? S_OK : S_FALSE) ;

    return hr ;
}

HRESULT
CNetOutputPin::InitAllocator (
    OUT IMemAllocator ** ppAlloc
    )
{
    (* ppAlloc) = NET_RECV (m_pFilter) -> GetRecvAllocator () ;
    (* ppAlloc) -> AddRef () ;

    return S_OK ;
}

HRESULT
CNetOutputPin::DecideBufferSize (
    IN  IMemAllocator *         pIMemAllocator,
    OUT ALLOCATOR_PROPERTIES *  pProp
    )
{
    HRESULT hr ;

    if (pIMemAllocator == NET_RECV (m_pFilter) -> GetRecvAllocator ()) {
        //  we're the allocator; get the properties and succeed
        hr = NET_RECV (m_pFilter) -> GetRecvAllocator () -> GetProperties (pProp) ;
    }
    else {
        //  this is not our allocator; fail the call
        hr = E_FAIL ;
    }

    return hr ;
}

HRESULT
CNetOutputPin::SetMediaType (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;

    m_MediaType.InitMediaType () ;
    m_MediaType = (* pmt) ;

    return S_OK ;
}

HRESULT
CNetOutputPin::GetMediaType (
    OUT AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;

    ZeroMemory (pmt, sizeof AM_MEDIA_TYPE) ;
    CopyMediaType (pmt, & m_MediaType) ;

    return S_OK ;
}

//  ---------------------------------------------------------------------------
//  ---------------------------------------------------------------------------

CNetworkReceiverFilter::CNetworkReceiverFilter (
    IN  TCHAR *     tszName,
    IN  LPUNKNOWN   punk,
    IN  REFCLSID    clsid,
    OUT HRESULT *   phr
    ) : CBaseFilter         (
                             tszName,
                             punk,
                             & m_crtFilterLock,
                             clsid
                             ),
        CPersistStream      (punk,
                             phr
                             ),
        m_pOutput           (NULL),
        m_pIMemAllocator    (NULL),
        m_ulIP              (UNDEFINED),
        m_ulNIC             (UNDEFINED),
        m_pBufferPool       (NULL),
        m_pNetReceiver      (NULL),
        m_pMSPool           (NULL),
        m_pNetRecvAlloc     (NULL),
        m_wCounterExpect    (UNDEFINED),
        m_hkeyRoot          (NULL),
        m_fReportDisc       (REG_DEF_RECV_REPORT_DISC)
{
    LONG    l ;
    DWORD   dwDisposition ;
    DWORD   dw ;
    BOOL    r ;

    l = RegCreateKeyEx (
            REG_DSNET_TOP_LEVEL,
            REG_DSNET_RECV_ROOT,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & m_hkeyRoot,
            & dwDisposition
            ) ;
    if (l != ERROR_SUCCESS) {
        dw = GetLastError () ;
        (* phr) = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    dw = REG_DEF_RECV_REPORT_DISC ;
    r = GetRegDWORDValIfExist (
            m_hkeyRoot,
            REG_RECV_REPORT_DISC_NAME,
            & dw
            ) ;
    if (r) {
        m_fReportDisc = (dw ? TRUE : FALSE) ;
    }

    //  instantiate the output pin
    m_pOutput = new CNetOutputPin (
                            NAME ("CNetOutputPin"),
                            this,
                            & m_crtFilterLock,
                            phr,
                            L"Stream"
                            ) ;
    if (m_pOutput == NULL ||
        FAILED (* phr)) {

        (* phr) = (FAILED (* phr) ? * phr : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  the buffer pool
    m_pBufferPool = new CBufferPool (m_hkeyRoot, phr) ;
    if (m_pBufferPool == NULL ||
        FAILED (*phr)) {

        (* phr) = (FAILED (* phr) ? * phr : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  the receiver object
    m_pNetReceiver = new CNetReceiver (m_hkeyRoot, m_pBufferPool, this, phr) ;
    if (m_pNetReceiver == NULL ||
        FAILED (*phr)) {

        (* phr) = (FAILED (* phr) ? * phr : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  the media sample pool
    m_pMSPool = new CTSMediaSamplePool (m_pBufferPool -> GetBufferPoolSize (), this, phr) ;
    if (m_pMSPool == NULL ||
        FAILED (*phr)) {

        (* phr) = (FAILED (* phr) ? * phr : E_OUTOFMEMORY) ;
        goto cleanup ;
    }

    //  IMemAllocator
    m_pNetRecvAlloc = new CNetRecvAlloc (m_pBufferPool, m_pMSPool, this) ;
    if (m_pNetRecvAlloc == NULL) {
        (* phr) = E_OUTOFMEMORY ;
        goto cleanup ;
    }

    cleanup :

    return ;
}

CNetworkReceiverFilter::~CNetworkReceiverFilter ()
{
    delete m_pNetReceiver ;
    delete m_pOutput ;
    RELEASE_AND_CLEAR (m_pIMemAllocator) ;
    delete m_pBufferPool ;
    delete m_pMSPool ;
    delete m_pNetRecvAlloc ;

    if (m_hkeyRoot != NULL) {
        RegCloseKey (m_hkeyRoot) ;
    }
}

CBasePin *
CNetworkReceiverFilter::GetPin (
    IN  int Index
    )
{
    CBasePin *  pPin ;

    LockFilter () ;

    if (Index == 0) {
        pPin = m_pOutput ;
    }
    else {
        pPin = NULL ;
    }

    UnlockFilter () ;

    return pPin ;
}

STDMETHODIMP
CNetworkReceiverFilter::Pause (
    )
{
    HRESULT hr ;

    LockFilter () ;

    if (m_ulIP == UNDEFINED ||
        m_ulNIC == UNDEFINED) {

        hr = E_FAIL ;
    }
    else if  (m_State == State_Stopped) {

        //  --------------------------------------------------------------------
        //  stopped -> pause transition; get the filter up and running

        //  activate the receiver; joins the multicast group and starts the
        //  thread
        hr = m_pNetReceiver -> Activate (m_ulIP, m_usPort, m_ulNIC) ;

        if (SUCCEEDED (hr)) {
            m_State = State_Paused ;

            if (m_pOutput &&
                m_pOutput -> IsConnected ()) {
                m_pOutput -> Active () ;
            }

            //  first packet will be a discontinuity
            m_wCounterExpect = UNDEFINED ;
        }
    }
    else {
        //  --------------------------------------------------------------------
        //  run -> pause transition; do nothing but set the state

        m_State = State_Paused ;

        hr = S_OK ;
    }

    UnlockFilter () ;

    return hr ;
}

STDMETHODIMP
CNetworkReceiverFilter::Stop (
    )
{
    LockFilter () ;

    //  synchronous call to stop the receiver (leaves the multicast group
    //  and terminates the thread)
    m_pNetReceiver -> Stop () ;

    //  if we have an output pin (we should) stop it
    if (m_pOutput) {
        m_pOutput -> Inactive () ;
    }

    m_State = State_Stopped ;

    UnlockFilter () ;

    return S_OK ;
}

CUnknown *
CNetworkReceiverFilter::CreateInstance (
    IN  LPUNKNOWN   punk,
    OUT HRESULT *   phr
    )
{
    CNetworkReceiverFilter * pnf ;

    (* phr) = S_OK ;

    pnf = new CNetworkReceiverFilter (
                    NAME ("CNetworkReceiverFilter"),
                    punk,
                    CLSID_DSNetReceive,
                    phr
                    ) ;
    if (pnf == NULL ||
        FAILED (* phr)) {
        (* phr) = (FAILED (* phr) ? (* phr) : E_OUTOFMEMORY) ;
        DELETE_RESET (pnf) ;
    }

    return pnf ;
}

STDMETHODIMP
CNetworkReceiverFilter::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  property pages

    if (riid == IID_ISpecifyPropertyPages) {

        return GetInterface (
                    (ISpecifyPropertyPages *) this,
                    ppv
                    ) ;
    }

    //  multicast config

    else if (riid == IID_IMulticastConfig) {

        return GetInterface (
                    (IMulticastConfig *) this,
                    ppv
                    ) ;
    }

    //  multicast receiver config

    else if (riid == IID_IMulticastReceiverConfig) {

        return GetInterface (
                    (IMulticastReceiverConfig *) this,
                    ppv
                    ) ;
    }

    //  we do persist

    else if (riid == IID_IPersistStream) {

        return GetInterface (
                    (IPersistStream *) this,
                    ppv
                    ) ;
    }

    //  fallback - call the baseclass

    else {
        return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
    }
}

STDMETHODIMP
CNetworkReceiverFilter::GetPages (
    IN OUT CAUUID * pPages
    )
{
    HRESULT hr ;

    pPages -> cElems = 1 ;

    pPages -> pElems = (GUID *) CoTaskMemAlloc (pPages -> cElems * sizeof GUID) ;

    if (pPages -> pElems) {
        (pPages -> pElems) [0] = CLSID_IPMulticastRecvProppage ;
        hr = S_OK ;
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    return hr ;
}

STDMETHODIMP
CNetworkReceiverFilter::SetNetworkInterface (
    IN  ULONG   ulNIC
    )
{
    HRESULT hr ;

    LockFilter () ;

    if (m_State != State_Stopped) {
        hr = E_UNEXPECTED ;
    }
    else if (IsUnicastIP (ulNIC) ||
        ulNIC == INADDR_ANY) {

        m_ulNIC = ulNIC ;
        hr = S_OK ;
    }
    else {
        hr = E_INVALIDARG ;
    }

    UnlockFilter () ;

    return hr ;
}

STDMETHODIMP
CNetworkReceiverFilter::GetNetworkInterface (
    OUT ULONG * pulNIC
    )
{
    HRESULT hr ;

    LockFilter () ;

    if (pulNIC) {
        (* pulNIC) = m_ulNIC ;
        hr = S_OK ;
    }
    else {
        hr = E_INVALIDARG ;
    }

    UnlockFilter () ;

    return hr ;
}

STDMETHODIMP
CNetworkReceiverFilter::SetMulticastGroup (
    IN  ULONG   ulIP,
    IN  USHORT  usPort
    )
{
    HRESULT hr ;

    LockFilter () ;

    if (m_State != State_Stopped) {
        hr = E_UNEXPECTED ;
    }
    else if (IsMulticastIP (ulIP)) {

        m_ulIP      = ulIP ;
        m_usPort    = usPort ;

        hr = S_OK ;
    }
    else {
        hr = E_INVALIDARG ;
    }

    UnlockFilter () ;

    return hr ;
}

STDMETHODIMP
CNetworkReceiverFilter::GetMulticastGroup (
    OUT ULONG *     pIP,
    OUT USHORT  *   pPort
    )
{
    HRESULT hr ;

    LockFilter () ;

    if (pIP &&
        pPort) {

        (* pIP)     = m_ulIP ;
        (* pPort)   = m_usPort ;

        hr = S_OK ;
    }
    else {
        hr = E_INVALIDARG ;
    }

    UnlockFilter () ;

    return hr ;
}

STDMETHODIMP
CNetworkReceiverFilter::SetOutputPinMediaType (
    IN  AM_MEDIA_TYPE * pmtNew
    )
{
    HRESULT     hr ;

    if (!pmtNew) {
        return E_POINTER ;
    }

    Lock_ () ;

    if (m_State == State_Stopped) {

        if (m_pOutput -> IsConnected ()) {

            //  connected
            //      1. check with connected if this is ok
            //      2. if so, set it
            //      3. and reconnect

            hr = m_pOutput -> GetConnected () -> QueryAccept (pmtNew) ;
            hr = (hr == S_OK ? S_OK : E_FAIL) ;
            if (SUCCEEDED (hr)) {
                hr = m_pOutput -> SetMediaType (pmtNew) ;
                if (SUCCEEDED (hr)) {
                    hr = ReconnectPin (
                            m_pOutput,
                            pmtNew
                            ) ;
                }
            }
        }
        else {
            //  not connected; just set it
            hr = m_pOutput -> SetMediaType (pmtNew) ;
        }
    }
    else {
        hr = E_FAIL ;
    }

    Unlock_ () ;

    return hr ;
}

STDMETHODIMP
CNetworkReceiverFilter::GetOutputPinMediaType (
    OUT AM_MEDIA_TYPE * pmt
    )
{
    if (!pmt) {
        return E_POINTER ;
    }

    return m_pOutput -> GetMediaType (pmt) ;
}

STDMETHODIMP
CNetworkReceiverFilter::GetClassID (
    OUT CLSID * pCLSID
    )
{
    (* pCLSID) = m_clsid ;
    return S_OK ;
}

HRESULT
CNetworkReceiverFilter::WriteToStream (
    IN  IStream *   pIStream
    )
{
    HRESULT         hr ;
    AM_MEDIA_TYPE   mt ;

    LockFilter () ;

    ZeroMemory (& mt, sizeof mt) ;
    hr = GetOutputPinMediaType (& mt) ;

    if (SUCCEEDED (hr)) {
        hr = pIStream -> Write ((BYTE *) & m_ulIP, sizeof m_ulIP, NULL) ;
        if (SUCCEEDED (hr)) {
            hr = pIStream -> Write ((BYTE *) & m_usPort, sizeof m_usPort, NULL) ;
            if (SUCCEEDED (hr)) {
                hr = pIStream -> Write ((BYTE *) & m_ulNIC, sizeof m_ulNIC, NULL) ;
                if (SUCCEEDED (hr)) {
                    hr = pIStream -> Write ((BYTE *) & mt, sizeof mt, NULL) ;
                    if (SUCCEEDED (hr) &&
                        mt.cbFormat > 0) {

                        hr = pIStream -> Write ((BYTE *) mt.pbFormat, mt.cbFormat, NULL) ;
                    }
                }
            }
        }
    }

    UnlockFilter () ;

    return hr ;
}

HRESULT
CNetworkReceiverFilter::ReadFromStream (
    IN  IStream *   pIStream
    )
{
    HRESULT         hr ;
    AM_MEDIA_TYPE   mt ;

    ZeroMemory (& mt, sizeof mt) ;

    LockFilter () ;

    hr = pIStream -> Read ((BYTE *) & m_ulIP, sizeof m_ulIP, NULL) ;
    if (SUCCEEDED (hr)) {
        hr = pIStream -> Read ((BYTE *) & m_usPort, sizeof m_usPort, NULL) ;
        if (SUCCEEDED (hr)) {
            hr = pIStream -> Read ((BYTE *) & m_ulNIC, sizeof m_ulNIC, NULL) ;
            if (SUCCEEDED (hr)) {
                hr = pIStream -> Read ((BYTE *) & mt, sizeof mt, NULL) ;
                if (SUCCEEDED (hr)) {

                    mt.pbFormat = NULL ;

                    //  gather a format block if there is one
                    if (mt.cbFormat > 0) {

                        mt.pbFormat = (BYTE *) CoTaskMemAlloc (mt.cbFormat * sizeof BYTE) ;
                        if (mt.pbFormat) {
                            hr = pIStream -> Read ((BYTE *) mt.pbFormat, mt.cbFormat, NULL) ;
                        }
                        else {
                            hr = E_OUTOFMEMORY ;
                        }
                    }

                    if (SUCCEEDED (hr)) {
                        hr = SetOutputPinMediaType (& mt) ;
                    }

                    CoTaskMemFree (mt.pbFormat) ;
                }
            }
        }
    }

    UnlockFilter () ;

    return hr ;
}

void
CNetworkReceiverFilter::ProcessBuffer (
    IN  CBufferPoolBuffer *   pBuffer
    )
{
    HRESULT         hr ;
    IMediaSample2 * pIMediaSample ;
    BOOL            fDiscontinuity ;

    ASSERT (pBuffer) ;

    hr = m_pMSPool -> GetMediaSampleSynchronous (
                            pBuffer,
                            pBuffer -> GetPayloadBuffer (),
                            pBuffer -> GetActualPayloadLength (),
                            & pIMediaSample
                            ) ;
    if (SUCCEEDED (hr)) {
        ASSERT (pIMediaSample) ;

        //  check for discontinuity
        fDiscontinuity = (m_wCounterExpect == pBuffer -> GetCounter () ? FALSE : TRUE) ;
        pIMediaSample -> SetDiscontinuity (fDiscontinuity && m_fReportDisc) ;

        //  expect this the next time
        m_wCounterExpect = pBuffer -> GetCounter () + 1 ;

        //  send the media sample down
        m_pOutput -> Deliver (pIMediaSample) ;
        pIMediaSample -> Release () ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\dsrecv.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dsrecv.h

    Abstract:


    Notes:

--*/

#define NET_RECEIVE_FILTER_NAME             L"IP Multicast Stream Receiver"
#define NET_RECEIVE_PROP_PAGE_NAME          L"Net Receive Properties"

extern AMOVIESETUP_FILTER g_sudRecvFilter ;

class CNetOutputPin ;
class CNetworkReceiverFilter ;
class CBufferPoolBuffer ;
class CBufferPool ;
class CNetReceiver ;
class CTSMediaSamplePool ;
class CNetRecvAlloc ;

/*++
    Class Name:

        CNetOutputPin

    Abstract:

        Filter output pin.

--*/
class CNetOutputPin :
    public CBaseOutputPin
{
    CMediaType  m_MediaType ;

    public :

        CNetOutputPin (
            IN  TCHAR *         szName,
            IN  CBaseFilter *   pFilter,
            IN  CCritSec *      pLock,
            OUT HRESULT *       pHr,
            IN  LPCWSTR         pszName
            ) ;

        ~CNetOutputPin () ;

        HRESULT
        GetMediaType (
            IN  int             iPosition,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType * pmt
            ) ;

        HRESULT
        DecideBufferSize (
            IN  IMemAllocator *,
            OUT ALLOCATOR_PROPERTIES *
            ) ;

        virtual
        HRESULT
        InitAllocator (
            OUT IMemAllocator ** ppAlloc
            ) ;

        HRESULT
        SetMediaType (
            IN  AM_MEDIA_TYPE * pmt
            ) ;

        HRESULT
        GetMediaType (
            OUT AM_MEDIA_TYPE * pmt
            ) ;
} ;

//  ---------------------------------------------------------------------------

class CNetworkReceiverFilter :
    public CBaseFilter,
    public IMulticastReceiverConfig,
    public ISpecifyPropertyPages,
    public CPersistStream
/*++
    Class Name:

        CNetworkReceiverFilter

    Abstract:

        Object implements our filter.
--*/
{
    CCritSec                m_crtFilterLock ;   //  filter lock
    CNetOutputPin *         m_pOutput ;         //  output pin
    IMemAllocator *         m_pIMemAllocator ;  //  mem allocator
    CNetReceiver *          m_pNetReceiver ;    //  receiver object
    ULONG                   m_ulIP ;            //  multicast ip; network order
    USHORT                  m_usPort ;          //  multicast port; network order
    ULONG                   m_ulNIC ;           //  NIC; network order
    CBufferPool *           m_pBufferPool ;     //  buffer pool object
    CTSMediaSamplePool *    m_pMSPool ;         //  media sample pool
    CNetRecvAlloc *         m_pNetRecvAlloc ;   //  allocator
    WORD                    m_wCounterExpect ;  //  expected counter value
    HKEY                    m_hkeyRoot ;
    BOOL                    m_fReportDisc ;     //  TRUE/FALSE report discontinuities

    void Lock_ ()       { m_pLock -> Lock () ; }
    void Unlock_ ()     { m_pLock -> Unlock () ; }

    public :

        CNetworkReceiverFilter (
            IN  TCHAR *     tszName,
            IN  LPUNKNOWN   punk,
            IN  REFCLSID    clsid,
            OUT HRESULT *   phr
            ) ;

        ~CNetworkReceiverFilter (
            ) ;

        void LockFilter ()              { m_crtFilterLock.Lock () ; }
        void UnlockFilter ()            { m_crtFilterLock.Unlock () ; }

        DECLARE_IUNKNOWN ;
        DECLARE_IMULTICASTRECEIVERCONFIG () ;

        //  --------------------------------------------------------------------
        //  CBaseFilter methods

        int GetPinCount ()              { return 1 ; }

        CBasePin *
        GetPin (
            IN  int Index
            ) ;

        CNetRecvAlloc *
        GetRecvAllocator (
            )
        {
            return m_pNetRecvAlloc ;
        }

        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        static
        CUnknown *
        CreateInstance (
            IN  LPUNKNOWN   punk,
            OUT HRESULT *   phr
            ) ;

        STDMETHODIMP
        GetPages (
            IN OUT CAUUID * pPages
            ) ;

        STDMETHODIMP
        Pause (
            ) ;

        STDMETHODIMP
        Stop (
            ) ;

        //  --------------------------------------------------------------------
        //  CPersistStream

        HRESULT
        WriteToStream (
            IN  IStream *   pIStream
            ) ;

        HRESULT
        ReadFromStream (
            IN  IStream *   pIStream
            ) ;

        int SizeMax ()  { return (sizeof m_ulIP + sizeof m_usPort + sizeof m_ulNIC) ; }

        STDMETHODIMP
        GetClassID (
            OUT CLSID * pCLSID
            ) ;

        //  class methods

        void
        ProcessBuffer (
            IN  CBufferPoolBuffer *
            ) ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\main.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        main.cpp

    Abstract:


    Notes:

--*/


#include "precomp.h"
#include "dsnetifc.h"
#include "proprecv.h"
#include "netrecv.h"
#include "dsrecv.h"

AMOVIESETUP_FILTER
g_sudRecvFilter = {
    & CLSID_DSNetReceive,
    NET_RECEIVE_FILTER_NAME,
    MERIT_DO_NOT_USE,
    0,                                              //  0 pins registered
    NULL
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\mspool.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        mspool.cpp

    Abstract:


    Notes:

--*/

#include "precomp.h"
#include "dsnetifc.h"
#include "le.h"
#include "buffpool.h"
#include "dsrecv.h"
#include "mspool.h"

//  ---------------------------------------------------------------------------
//      CTSMediaSample
//  ---------------------------------------------------------------------------

CTSMediaSample::CTSMediaSample (
    IN  CTSMediaSamplePool * pMSPool
    ) : m_pMSPool               (pMSPool),
        m_lRef                  (0),
        m_pBuffer               (NULL),
        m_dwFlags               (0),
        m_dwTypeSpecificFlags   (0),
        m_pbPayload             (NULL),
        m_lActual               (0),
        m_rtStart               (0),
        m_rtEnd                 (0),
        m_llMediaStart          (0),
        m_llMediaEnd            (0),
        m_pMediaType            (NULL),
        m_dwStreamId            (0)
{
    ASSERT (m_pMSPool) ;
}

CTSMediaSample::~CTSMediaSample (
    )
{
    ASSERT (m_pMediaType == NULL) ;
}

//  -------------------------------------------------------------------
//  init

void
CTSMediaSample::ResetMS_ (
    )
{
    //  the flags
    m_dwFlags = 0x00000000 ;

    //  the media type, if it is set
    if (m_pMediaType != NULL) {
        DeleteMediaType (m_pMediaType) ;
        m_pMediaType = NULL ;
    }
}

HRESULT
CTSMediaSample::Init (
    IN  CBufferPoolBuffer * pBuffer,
    IN  BYTE *              pbPayload,
    IN  int                 iPayloadLength,
    IN  LONGLONG *          pllMediaStart,
    IN  LONGLONG *          pllMediaEnd,
    IN  REFERENCE_TIME *    prtStart,
    IN  REFERENCE_TIME *    prtEnd,
    IN  DWORD               dwMediaSampleFlags
    )
{
    ASSERT (pBuffer) ;
    ASSERT ((dwMediaSampleFlags | SAMPLE_VALIDFLAGS) == SAMPLE_VALIDFLAGS) ;

    //  buffer we'll be referencing
    m_pBuffer = pBuffer ;
    m_pBuffer -> AddRef () ;

    //  set media sample properties
    m_pbPayload = pbPayload ;               //  pbPayload might not align with
                                            //    start of CBufferPoolBuffer's buffer
    m_lActual   = iPayloadLength ;          //  nor may the length be same as
                                            //    CBufferPoolBuffer's length
    m_dwFlags   = dwMediaSampleFlags ;

    //  we don't support in-band media type changes
    ASSERT ((m_dwFlags & SAMPLE_TYPECHANGED) == 0) ;

    //  pts
    if (m_dwFlags & SAMPLE_TIMEVALID) {
        //  overflows should be a non-issue
        m_rtStart = (* prtStart) ;

        if (m_dwFlags & SAMPLE_STOPVALID) {
            m_rtEnd = (* prtEnd) ;
        }
    }

    //  media times
    if (m_dwFlags & SAMPLE_MEDIATIMEVALID) {
        m_llMediaStart  = (* pllMediaStart) ;
        m_llMediaEnd    = (* pllMediaEnd) ;
    }

    return S_OK ;
}

//  -------------------------------------------------------------------
//  IUnknown methods

STDMETHODIMP
CTSMediaSample::QueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (ppv == NULL) {
        return E_INVALIDARG ;
    }

    if (riid == IID_IUnknown        ||
        riid == IID_IMediaSample    ||
        riid == IID_IMediaSample2) {

        (* ppv) = reinterpret_cast <void *> (this) ;
    }
    else {
        return E_NOINTERFACE ;
    }

    (reinterpret_cast <IUnknown *> (* ppv)) -> AddRef () ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
CTSMediaSample::AddRef (
    )
{
    return InterlockedIncrement (& m_lRef) ;
}

STDMETHODIMP_(ULONG)
CTSMediaSample::Release (
    )
{
    if (InterlockedDecrement (& m_lRef) == 0) {

        //  release the buffer we're referencing
        m_pBuffer -> Release () ;
        m_pBuffer = NULL ;

        //  reset our internal fields
        ResetMS_ () ;

        //  recycle ourselves into the pool
        m_pMSPool -> RecycleMS (this) ;

        return 0 ;
    }

    return m_lRef ;
}

//  -------------------------------------------------------------------
//  IMediaSample

// get me a read/write pointer to this buffer's memory. I will actually
// want to use sizeUsed bytes.
STDMETHODIMP
CTSMediaSample::GetPointer (
    OUT BYTE ** ppBuffer
    )
{
    if (ppBuffer == NULL) {
        return E_POINTER ;
    }

    (* ppBuffer) = m_pbPayload ;

    return S_OK ;
}

// return the size in bytes of the buffer data area
STDMETHODIMP_(LONG)
CTSMediaSample::GetSize (
    )
{
    return m_lActual ;
}

// get the stream time at which this sample should start and finish.
STDMETHODIMP
CTSMediaSample::GetTime (
    OUT REFERENCE_TIME * pTimeStart,	// put time here
	OUT REFERENCE_TIME * pTimeEnd
    )
{
    HRESULT hr ;

    if ((m_dwFlags & SAMPLE_TIMEVALID) == 0) {
        return VFW_E_SAMPLE_TIME_NOT_SET ;
    }

    if (pTimeStart == NULL ||
        pTimeEnd == NULL) {

        return E_POINTER ;
    }

    //  start time is there; maybe stop time

    (* pTimeStart) = m_rtStart ;

    //  do we have a stop time ?
    if ((m_dwFlags & SAMPLE_STOPVALID) != 0) {
        (* pTimeEnd) = m_rtEnd ;
        hr = S_OK ;
    }
    else {
        //  apparently this breaks older stuff if we don't do this ..
        (* pTimeEnd) = m_rtStart + 1 ;
        hr = VFW_S_NO_STOP_TIME ;
    }

    return hr ;
}

// Set the stream time at which this sample should start and finish.
// pTimeStart==pTimeEnd==NULL will invalidate the time stamps in
// this sample
STDMETHODIMP
CTSMediaSample::SetTime (
    IN  REFERENCE_TIME * pTimeStart,	// put time here
	IN  REFERENCE_TIME * pTimeEnd
    )
{
    //  caller wishes to explicitely clear the time
    if (pTimeStart == NULL) {
        //  clear the flags
        m_dwFlags &= ~(SAMPLE_TIMEVALID | SAMPLE_STOPVALID) ;
        return S_OK ;
    }

    //  we have been given a start time

    m_dwFlags |= SAMPLE_TIMEVALID ;
    m_rtStart = * pTimeStart ;

    //  do we have a stop time ?
    if (pTimeEnd != NULL) {
        m_dwFlags |= SAMPLE_STOPVALID ;
        m_rtEnd = (* pTimeEnd) ;
    }
    else {
        //  clear the stop time valid flag
        m_dwFlags &= ~SAMPLE_STOPVALID ;
    }

    return S_OK ;
}

// sync-point property. If true, then the beginning of this
// sample is a sync-point. (note that if AM_MEDIA_TYPE.bTemporalCompression
// is false then all samples are sync points). A filter can start
// a stream at any sync point.  S_FALSE if not sync-point, S_OK if true.

STDMETHODIMP
CTSMediaSample::IsSyncPoint (
    )
{
    return (m_dwFlags & SAMPLE_SYNCPOINT) ? S_OK : S_FALSE ;
}

STDMETHODIMP
CTSMediaSample::SetSyncPoint (
    IN  BOOL bIsSyncPoint
    )
{
    if (bIsSyncPoint) {
        m_dwFlags |= SAMPLE_SYNCPOINT ;
    }
    else {
        m_dwFlags &= ~SAMPLE_SYNCPOINT ;
    }

    return S_OK ;
}

// preroll property.  If true, this sample is for preroll only and
// shouldn't be displayed.
STDMETHODIMP
CTSMediaSample::IsPreroll (
    )
{
    return (m_dwFlags & SAMPLE_PREROLL) ? S_OK : S_FALSE ;
}

STDMETHODIMP
CTSMediaSample::SetPreroll (
    BOOL bIsPreroll
    )
{
    if (bIsPreroll) {
        m_dwFlags |= SAMPLE_PREROLL ;
    }
    else {
        m_dwFlags &= ~SAMPLE_PREROLL ;
    }

    return S_OK ;
}

STDMETHODIMP_(LONG)
CTSMediaSample::GetActualDataLength (
    )
{
    return m_lActual ;
}

STDMETHODIMP
CTSMediaSample::SetActualDataLength (
    IN  long    lActual
    )
{
    if (lActual > m_lActual) {
        return VFW_E_BUFFER_OVERFLOW ;
    }

    m_lActual = lActual ;
    return S_OK ;
}

// these allow for limited format changes in band - if no format change
// has been made when you receive a sample GetMediaType will return S_FALSE

STDMETHODIMP
CTSMediaSample::GetMediaType (
    AM_MEDIA_TYPE ** ppMediaType
    )
{
    if (ppMediaType == NULL) {
        return E_POINTER ;
    }

    if ((m_dwFlags & SAMPLE_TYPECHANGED) == 0) {
        ASSERT (m_pMediaType == NULL) ;
        (* ppMediaType) = NULL ;
        return S_FALSE ;
    }

    ASSERT (m_pMediaType != NULL) ;

    (* ppMediaType) = CreateMediaType (m_pMediaType) ;
    if (* ppMediaType) {
        return E_OUTOFMEMORY ;
    }

    return S_OK ;
}

STDMETHODIMP
CTSMediaSample::SetMediaType (
    AM_MEDIA_TYPE * pMediaType
    )
{
    if (m_pMediaType != NULL) {
        DeleteMediaType (m_pMediaType) ;
        m_pMediaType = NULL ;
    }

    //  explicitely being cleared
    if (pMediaType == NULL) {
        m_dwFlags &= ~SAMPLE_TYPECHANGED ;
        return S_OK ;
    }

    m_pMediaType = CreateMediaType (pMediaType) ;
    if (m_pMediaType == NULL) {
        m_dwFlags &= ~SAMPLE_TYPECHANGED ;
        return E_OUTOFMEMORY ;
    }

    m_dwFlags |= SAMPLE_TYPECHANGED ;

    return S_OK ;
}

// returns S_OK if there is a discontinuity in the data (this frame is
// not a continuation of the previous stream of data
// - there has been a seek or some dropped samples).
STDMETHODIMP
CTSMediaSample::IsDiscontinuity (
    )
{
    return (m_dwFlags & SAMPLE_DISCONTINUITY) ? S_OK : S_FALSE ;
}

// set the discontinuity property - TRUE if this sample is not a
// continuation, but a new sample after a seek or a dropped sample.
STDMETHODIMP
CTSMediaSample::SetDiscontinuity (
    BOOL bDiscontinuity
    )
{
    if (bDiscontinuity) {
        m_dwFlags |= SAMPLE_DISCONTINUITY ;
    }
    else {
        m_dwFlags &= ~SAMPLE_DISCONTINUITY ;
    }

    return S_OK ;
}

// get the media times for this sample
STDMETHODIMP
CTSMediaSample::GetMediaTime (
    OUT LONGLONG * pTimeStart,
	OUT LONGLONG * pTimeEnd
    )
{
    if ((m_dwFlags & SAMPLE_MEDIATIMEVALID) == 0) {
        return VFW_E_MEDIA_TIME_NOT_SET ;
    }

    if (pTimeStart == NULL ||
        pTimeEnd == NULL) {

        return E_POINTER ;
    }

    (* pTimeStart)  = m_llMediaStart ;
    (* pTimeEnd)    = m_llMediaEnd ;

    return S_OK ;
}

// Set the media times for this sample
// pTimeStart==pTimeEnd==NULL will invalidate the media time stamps in
// this sample
STDMETHODIMP
CTSMediaSample::SetMediaTime (
    IN  LONGLONG * pTimeStart,
	IN  LONGLONG * pTimeEnd
    )
{
    //  caller is explicitely clearing the media time
    if (pTimeStart == NULL) {
        //  toggle the bit OFF
        m_dwFlags &= ~SAMPLE_MEDIATIMEVALID ;
        return S_OK ;
    }

    if (pTimeEnd == NULL) {
        return E_POINTER ;
    }

    //  toggle the bit ON
    m_dwFlags |= SAMPLE_MEDIATIMEVALID ;

    //  and save the times
    m_rtStart   = (* pTimeStart) ;
    m_rtEnd     = (* pTimeEnd) ;

    return S_OK ;
}

//  -------------------------------------------------------------------
//  IMediaSample methods

// Set and get properties (IMediaSample2)
STDMETHODIMP
CTSMediaSample::GetProperties (
    IN  DWORD   cbProperties,
    OUT BYTE *  pbProperties
    )
{
    AM_SAMPLE2_PROPERTIES   Props ;
    HRESULT                 hr ;

    hr = S_OK ;

    if (cbProperties > 0) {
        if (pbProperties) {
            Props.cbData                = Min <DWORD> (cbProperties, sizeof Props) ;
            Props.dwSampleFlags         = m_dwFlags & ~SAMPLE_VALIDFLAGS ;
            Props.dwTypeSpecificFlags   = m_dwTypeSpecificFlags ;
            Props.pbBuffer              = m_pbPayload ;
            Props.cbBuffer              = m_lActual ;       //  same as actual
            Props.lActual               = m_lActual ;
            Props.tStart                = m_rtStart ;
            Props.tStop                 = m_rtEnd ;
            Props.dwStreamId            = m_dwStreamId ;

            if (m_dwFlags & AM_SAMPLE_TYPECHANGED) {
                Props.pMediaType = m_pMediaType ;
            } else {
                Props.pMediaType = NULL ;
            }

            memcpy (pbProperties, & Props, Props.cbData) ;
        }
        else {
            hr = E_POINTER ;
        }
    }

    return hr ;
}

STDMETHODIMP
CTSMediaSample::SetProperties (
    IN  DWORD           cbProperties,
    IN  const BYTE *    pbProperties
    )
{
    return E_NOTIMPL ;
}

//  ---------------------------------------------------------------------------
//      CTSMediaSamplePool
//  ---------------------------------------------------------------------------

CTSMediaSamplePool::CTSMediaSamplePool (
    IN  DWORD                       dwPoolSize,
    IN  CNetworkReceiverFilter *    pHostingFilter,
    OUT HRESULT *                   phr
    ) : m_hEvent            (NULL),
        m_dwPoolSize        (0),
        m_pHostingFilter    (pHostingFilter)
{
    CTSMediaSample *    pMS ;
    DWORD               dw ;

    ASSERT (m_pHostingFilter) ;

    InitializeListHead (& m_leMSPool) ;
    InitializeCriticalSection (& m_crt) ;

    ASSERT (dwPoolSize > 0) ;
    m_hEvent = CreateEvent (NULL, TRUE, TRUE, NULL) ;
    if (m_hEvent == NULL) {
        dw = GetLastError () ;
        (* phr) = HRESULT_FROM_WIN32 (dw) ;
        return ;
    }

    for (m_dwPoolSize = 0; m_dwPoolSize < dwPoolSize; m_dwPoolSize++) {
        pMS = new CTSMediaSample (this) ;
        if (pMS == NULL) {
            (* phr) = E_OUTOFMEMORY ;
            return ;
        }

        InsertHeadList (& m_leMSPool, & pMS -> m_ListEntry) ;
    }

    ASSERT (m_dwPoolSize > 0) ;
}

CTSMediaSamplePool::~CTSMediaSamplePool (
    )
{
    DWORD i ;
    LIST_ENTRY *        pListEntry ;
    CTSMediaSample *    pMS ;

    for (i = 0; i < m_dwPoolSize; i++) {
        ASSERT (!IsListEmpty (& m_leMSPool)) ;
        pListEntry = RemoveHeadList (& m_leMSPool) ;
        pMS = CONTAINING_RECORD (pListEntry, CTSMediaSample, m_ListEntry) ;

        delete pMS ;
    }

    ASSERT (IsListEmpty (& m_leMSPool)) ;

    DeleteCriticalSection (& m_crt) ;
}

void
CTSMediaSamplePool::RecycleMS (
    IN  CTSMediaSample * pMS
    )
{
    ASSERT (pMS) ;

    Lock_ () ;

    //  always signal the event
    SetEvent (m_hEvent) ;
    InsertHeadList (& m_leMSPool, & pMS -> m_ListEntry) ;

    //  media sample's ref to the filter
    m_pHostingFilter -> Release () ;

    Unlock_ () ;
}

HRESULT
CTSMediaSamplePool::GetMediaSample_ (
    IN  CBufferPoolBuffer * pBuffer,
    IN  BYTE *              pbPayload,
    IN  int                 iPayloadLength,
    IN  LONGLONG *          pllMediaStart,
    IN  LONGLONG *          pllMediaEnd,
    IN  REFERENCE_TIME *    prtStart,
    IN  REFERENCE_TIME *    prtEnd,
    IN  DWORD               dwMediaSampleFlags,
    OUT IMediaSample2 **    ppMS
    )
{
    CTSMediaSample *    pTSMS ;
    LIST_ENTRY *        pListEntry ;

    ASSERT (pllMediaStart) ;
    ASSERT (pllMediaEnd) ;
    ASSERT (prtStart) ;
    ASSERT (prtEnd) ;

    Lock_ () ;

    //  while the list is empty, non-signal the event and wait for a media
    //  sample
    while (IsListEmpty (& m_leMSPool)) {
        //  media sample list is empty; setup to wait

        //  non-signal the event
        ResetEvent (m_hEvent) ;

        //  release the lock and wait
        Unlock_ () ;
        WaitForSingleObject (m_hEvent, INFINITE) ;

        //  event has been signaled; reaquire the lock
        Lock_ () ;
    }

    //  remove the head of the media sample list
    pListEntry = RemoveHeadList (& m_leMSPool) ;
    pTSMS = CONTAINING_RECORD (pListEntry, CTSMediaSample, m_ListEntry) ;

    //  media sample's ref to the filter (so the filter does not get deleted
    //  while media samples are outstanding)
    m_pHostingFilter -> AddRef () ;

    //  we have the media sample and have addref'd the filter, so we can
    //   now release the lock
    Unlock_ () ;

    //  set the caller's ref
    ASSERT (pTSMS) ;
    pTSMS -> AddRef () ;

    //  assert we're within the bounds of the io block
    ASSERT (pBuffer -> GetPayloadBuffer () <= pbPayload &&
            pbPayload + iPayloadLength <= pBuffer -> GetPayloadBuffer () + pBuffer -> GetPayloadBufferLength ()) ;

    //  init the media sample wrapper
    pTSMS -> Init (
                pBuffer,
                pbPayload,
                iPayloadLength,
                pllMediaStart,
                pllMediaEnd,
                prtStart,
                prtEnd,
                dwMediaSampleFlags
                ) ;

    //  set the outgoing parameter
    (* ppMS) = pTSMS ;

    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\precomp.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        precomp.h

    Abstract:

        Globals to the receiver.

    Notes:

--*/


#include "projpch.h"
#include <commctrl.h>

#define NET_RECV(pf)            (reinterpret_cast <CNetworkReceiverFilter *> (pf))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\mspool.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        mspool.h

    Abstract:


    Notes:

--*/

#ifndef __mspool_h
#define __mspool_h

class CTSMediaSamplePool ;
class CTSMediaSample ;
class CNetworkReceiverFilter ;

//  media sample flags
#define SAMPLE_SYNCPOINT            0x00000001
#define SAMPLE_PREROLL              0x00000002
#define SAMPLE_DISCONTINUITY        0x00000004
#define SAMPLE_TYPECHANGED          0x00000008
#define SAMPLE_TIMEVALID            0x00000010
#define SAMPLE_MEDIATIMEVALID       0x00000020
#define SAMPLE_TIMEDISCONTINUITY    0x00000040
#define SAMPLE_STOPVALID            0x00000080
#define SAMPLE_VALIDFLAGS           0x000000ff

class CTSMediaSample :
    public IMediaSample2
{
    CTSMediaSamplePool *    m_pMSPool ;
    LONG                    m_lRef ;
    DWORD                   m_dwFlags ;                 //  ORed SAMPLE_* values
    DWORD                   m_dwTypeSpecificFlags ;
    BYTE *                  m_pbPayload ;
    LONG                    m_lActual ;
    REFERENCE_TIME          m_rtStart ;
    REFERENCE_TIME          m_rtEnd ;
    LONGLONG                m_llMediaStart ;
    LONGLONG                m_llMediaEnd ;
    AM_MEDIA_TYPE *         m_pMediaType ;
    DWORD                   m_dwStreamId ;

    //
    //  this media sample always wraps something
    //

    CBufferPoolBuffer *     m_pBuffer ;                 //  we're wrapping an IO block

    void
    ResetMS_ (
        ) ;

    public :

        LIST_ENTRY  m_ListEntry ;

        CTSMediaSample (
            IN  CTSMediaSamplePool *
            ) ;

        ~CTSMediaSample (
            ) ;

        //  -------------------------------------------------------------------
        //  init

        HRESULT
        Init (
            IN  CBufferPoolBuffer * pBuffer,
            IN  BYTE *              pbPayload,
            IN  int                 iPayloadLength,
            IN  LONGLONG *          pllMediaStart,
            IN  LONGLONG *          pllMediaEnd,
            IN  REFERENCE_TIME *    prtStart,
            IN  REFERENCE_TIME *    prtEnd,
            IN  DWORD               dwMediaSampleFlags
            ) ;

        //  -------------------------------------------------------------------
        //  IUnknown methods

        STDMETHODIMP
        QueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        STDMETHODIMP_(ULONG)
        AddRef (
            ) ;

        STDMETHODIMP_(ULONG)
        Release (
            ) ;

        //  -------------------------------------------------------------------
        //  IMediaSample methods

        // get me a read/write pointer to this buffer's memory. I will actually
        // want to use sizeUsed bytes.
        STDMETHODIMP
        GetPointer (
            OUT BYTE ** ppBuffer
            ) ;

        // return the size in bytes of the buffer data area
        STDMETHODIMP_(LONG)
        GetSize (
            ) ;

        // get the stream time at which this sample should start and finish.
        STDMETHODIMP
        GetTime (
    	    OUT REFERENCE_TIME * pTimeStart,	// put time here
	        OUT REFERENCE_TIME * pTimeEnd
            ) ;

        // Set the stream time at which this sample should start and finish.
        // pTimeStart==pTimeEnd==NULL will invalidate the time stamps in
        // this sample
        STDMETHODIMP
        SetTime (
    	    IN  REFERENCE_TIME * pTimeStart,	// put time here
	        IN  REFERENCE_TIME * pTimeEnd
            ) ;

        // sync-point property. If true, then the beginning of this
        // sample is a sync-point. (note that if AM_MEDIA_TYPE.bTemporalCompression
        // is false then all samples are sync points). A filter can start
        // a stream at any sync point.  S_FALSE if not sync-point, S_OK if true.

        STDMETHODIMP
        IsSyncPoint (
            ) ;

        STDMETHODIMP
        SetSyncPoint (
            IN  BOOL bIsSyncPoint
            ) ;

        // preroll property.  If true, this sample is for preroll only and
        // shouldn't be displayed.
        STDMETHODIMP
        IsPreroll (
            ) ;

        STDMETHODIMP
        SetPreroll (
            BOOL bIsPreroll
            ) ;

        STDMETHODIMP_(LONG)
        GetActualDataLength (
            ) ;

        STDMETHODIMP
        SetActualDataLength (
            IN  long
            ) ;

        // these allow for limited format changes in band - if no format change
        // has been made when you receive a sample GetMediaType will return S_FALSE

        STDMETHODIMP
        GetMediaType (
            AM_MEDIA_TYPE ** ppMediaType
            ) ;

        STDMETHODIMP
        SetMediaType(
            AM_MEDIA_TYPE * pMediaType
            ) ;

        // returns S_OK if there is a discontinuity in the data (this frame is
        // not a continuation of the previous stream of data
        // - there has been a seek or some dropped samples).
        STDMETHODIMP
        IsDiscontinuity (
            ) ;

        // set the discontinuity property - TRUE if this sample is not a
        // continuation, but a new sample after a seek or a dropped sample.
        STDMETHODIMP
        SetDiscontinuity (
            BOOL bDiscontinuity
            ) ;

        // get the media times for this sample
        STDMETHODIMP
        GetMediaTime (
    	    OUT LONGLONG * pTimeStart,
	        OUT LONGLONG * pTimeEnd
            ) ;

        // Set the media times for this sample
        // pTimeStart==pTimeEnd==NULL will invalidate the media time stamps in
        // this sample
        STDMETHODIMP
        SetMediaTime (
    	    IN  LONGLONG * pTimeStart,
	        IN  LONGLONG * pTimeEnd
            ) ;

        //  -------------------------------------------------------------------
        //  IMediaSample methods

        // Set and get properties (IMediaSample2)
        STDMETHODIMP
        GetProperties (
            IN  DWORD   cbProperties,
            OUT BYTE *  pbProperties
            ) ;

        STDMETHODIMP
        SetProperties (
            IN  DWORD           cbProperties,
            IN  const BYTE *    pbProperties
            ) ;
} ;

class CTSMediaSamplePool
{
    LIST_ENTRY                  m_leMSPool ;
    CNetworkReceiverFilter *    m_pHostingFilter ;
    DWORD                       m_dwPoolSize ;
    CRITICAL_SECTION            m_crt ;
    HANDLE                      m_hEvent ;

    void Lock_ ()       { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()     { LeaveCriticalSection (& m_crt) ; }

    HRESULT
    GetMediaSample_ (
        IN  CBufferPoolBuffer * pBuffer,
        IN  BYTE *              pbPayload,
        IN  int                 iPayloadLength,
        IN  LONGLONG *          pllMediaStart,
        IN  LONGLONG *          pllMediaEnd,
        IN  REFERENCE_TIME *    prtStart,
        IN  REFERENCE_TIME *    prtEnd,
        IN  DWORD               dwMediaSampleFlags,
        OUT IMediaSample2 **    ppMS
        ) ;

    public :

        CTSMediaSamplePool (
            IN  DWORD                       dwPoolSize,
            IN  CNetworkReceiverFilter *    pHostingFilter,
            OUT HRESULT *                   phr
            ) ;

        ~CTSMediaSamplePool (
            ) ;

        DWORD
        GetPoolSize (
            )
        {
            return m_dwPoolSize ;
        }

        void
        RecycleMS (
            IN  CTSMediaSample *
            ) ;

        //  synchronous
        HRESULT
        GetMediaSampleSynchronous (
            IN  CBufferPoolBuffer * pBuffer,
            IN  BYTE *              pbPayload,
            IN  int                 iPayloadLength,
            IN  LONGLONG *          pllMediaStart,
            IN  LONGLONG *          pllMediaEnd,
            IN  REFERENCE_TIME *    prtStart,
            IN  REFERENCE_TIME *    prtEnd,
            IN  DWORD               dwMediaSampleFlags,
            OUT IMediaSample2 **    ppMS
            )
        {
            return GetMediaSample_ (
                        pBuffer,
                        pbPayload,
                        iPayloadLength,
                        pllMediaStart,
                        pllMediaEnd,
                        prtStart,
                        prtEnd,
                        dwMediaSampleFlags,
                        ppMS
                        ) ;
        }

        HRESULT
        GetMediaSampleSynchronous (
            IN  CBufferPoolBuffer * pBuffer,
            IN  BYTE *              pbPayload,
            IN  int                 iPayloadLength,
            OUT IMediaSample2 **    ppMS
            )
        {
            LONGLONG        llMediaStart ;
            LONGLONG        llMediaEnd ;
            REFERENCE_TIME  rtStart ;
            REFERENCE_TIME  rtEnd ;

            return GetMediaSample_ (
                        pBuffer,
                        pbPayload,
                        iPayloadLength,
                        & llMediaStart,     //  dummy
                        & llMediaEnd,       //  dummy
                        & rtStart,          //  dummy
                        & rtEnd,            //  dummy
                        0,                  //  no flags (no dummy param gets used)
                        ppMS
                        ) ;
        }
} ;

#endif  //  __mspool_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\netrecv.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        netrecv.h

    Abstract:

        Contains the class declaration for CNetReceiver, which is a general,
        non dshow-specific multicast receiver.

    Notes:

--*/


#ifndef __netrecv_h
#define __netrecv_h

class CBufferPool ;
class CBufferPoolBuffer ;
class CNetworkReceiverFilter ;

class CNetReceiver
{
    enum {
        PULSE_MILLIS    = 100   //  worker thread times out periodically to
                                //   perform housekeeping work
    } ;

    enum {
        EVENT_STOP,
        EVENT_GET_BLOCK,
        EVENT_COUNT         //  always last
    } ;

    HANDLE                      m_hThread ;                 //  worker thread
    HANDLE                      m_hEvents [EVENT_COUNT] ;   //  win32 events
    WSADATA                     m_wsaData ;                 //  wsainit
    SOCKET                      m_hAsyncSocket ;            //  socket
    CBufferPool *               m_pBufferPool ;             //  buffer pool
    LONG                        m_lReadsPended ;            //  outstanding io count
    CNetworkReceiverFilter *    m_pRecvFilter ;             //  back pointer to host
    CRITICAL_SECTION            m_crt ;                     //  crit sect
    DWORD                       m_dwMaxPendReads ;          //  max pended reads

    void Lock_ ()               { EnterCriticalSection (& m_crt) ; }
    void Unlock_ ()             { LeaveCriticalSection (& m_crt) ; }

    HRESULT
    JoinMulticast_ (
        IN  ULONG   ulIP,           //  IP; class d; network order
        IN  USHORT  usPort,         //  port; network order
        IN  ULONG   ulNIC           //  network interface; network order
        ) ;

    void
    LeaveMulticast_ (
        ) ;

    void
    PendReads_ (
        IN  DWORD   dwBufferWaitMax = 0
        ) ;

    public :

        CNetReceiver (
            IN  HKEY                        hkeyRoot,
            IN  CBufferPool *               pBufferPool,
            IN  CNetworkReceiverFilter *    pRecvFilter,
            OUT HRESULT *                   phr
            ) ;

        ~CNetReceiver (
            ) ;

        //  synchronous call to join the multicast and start the thread
        HRESULT
        Activate (
            IN  ULONG   ulIP,           //  IP; class d; network order
            IN  USHORT  usPort,         //  port; network order
            IN  ULONG   ulNIC           //  network interface; network order
            ) ;

        //  synchronous call to stop the thread and leave the multicast
        HRESULT
        Stop (
            ) ;

        //  handles the receiver-specific read completion
        void
        ReadCompletion (
            IN  CBufferPoolBuffer *,
            IN  DWORD
            ) ;

        //  entry point for an async read completion
        static
        void
        CALLBACK
        AsyncCompletionCallback (
            IN  DWORD           dwError,
            IN  DWORD           dwBytesReceived,
            IN  LPWSAOVERLAPPED pOverlapped,
            IN  DWORD           dwFlags
            ) ;

        void
        ThreadProc (
            ) ;

        static
        DWORD
        WINAPI
        ThreadEntry (
            IN  LPVOID  pv
            )
        {
            (reinterpret_cast <CNetReceiver *> (pv)) -> ThreadProc () ;
            return EXIT_SUCCESS ;
        }
} ;

#endif  //  __netrecv_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\netrecv.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        netrecv.cpp

    Abstract:


    Notes:

--*/


#include "precomp.h"
#include "nutil.h"
#include "dsnetifc.h"
#include "le.h"
#include "buffpool.h"
#include "netrecv.h"
#include "dsrecv.h"

//  ---------------------------------------------------------------------------
//  ---------------------------------------------------------------------------

CNetReceiver::CNetReceiver (
    IN  HKEY                        hkeyRoot,
    IN  CBufferPool *               pBufferPool,
    IN  CNetworkReceiverFilter *    pRecvFilter,
    OUT HRESULT *                   phr
    ) : m_hAsyncSocket              (INVALID_SOCKET),
        m_hThread                   (NULL),
        m_pBufferPool               (pBufferPool),
        m_lReadsPended              (0),
        m_pRecvFilter               (pRecvFilter),
        m_dwMaxPendReads            (RECV_MAX_PEND_READS)
{
    DWORD   dw ;
    DWORD   i ;

    GetRegDWORDValIfExist (
            hkeyRoot,
            REG_RECV_MAX_READS_NAME,
            & m_dwMaxPendReads
            ) ;
    if (IsOutOfBounds <DWORD> (m_dwMaxPendReads, MIN_VALID_RECV_MAX_PEND_READS, MAX_VALID_RECV_MAX_PEND_READS)) {
        m_dwMaxPendReads = SetInBounds <DWORD> (m_dwMaxPendReads, MIN_VALID_RECV_MAX_PEND_READS, MAX_VALID_RECV_MAX_PEND_READS) ;
        SetRegDWORDVal (
            hkeyRoot,
            REG_RECV_MAX_READS_NAME,
            m_dwMaxPendReads
            ) ;
    }

    m_dwMaxPendReads = Min <DWORD> (m_dwMaxPendReads, pBufferPool -> GetBufferPoolSize ()) ;

    //  non-failables first
    InitializeCriticalSection (& m_crt) ;
    ZeroMemory (& m_hEvents, EVENT_COUNT * sizeof HANDLE) ;

    //  ask for winsock 2.0
    i = WSAStartup (MAKEWORD(2, 0), & m_wsaData) ;
    if (i) {
        (* phr) = E_FAIL ;
        return ;
    }

    //  get our event objects
    for (i = 0; i < EVENT_COUNT; i++) {
        //  manual reset; non-signaled
        m_hEvents [i] = CreateEvent (NULL, TRUE, FALSE, NULL) ;

        if (m_hEvents [i] == NULL) {
            dw = GetLastError () ;
            (* phr) = HRESULT_FROM_WIN32 (dw) ;
            return ;
        }
    }

    //  make we haven't been told to pend more than we can
    m_dwMaxPendReads = Min <DWORD> (m_dwMaxPendReads, m_pBufferPool -> GetBufferPoolSize ()) ;
}

CNetReceiver::~CNetReceiver (
    )
{
    DWORD   i ;

    ASSERT (m_hAsyncSocket == INVALID_SOCKET) ;

    for (i = 0; i < EVENT_COUNT; i++) {
        if (m_hEvents [i] != NULL) {
            CloseHandle (m_hEvents [i]) ;
        }
        else {
            break ;
        }
    }

    WSACleanup () ;

    DeleteCriticalSection (& m_crt) ;
}

void
CALLBACK
CNetReceiver::AsyncCompletionCallback (
    IN  DWORD           dwError,
    IN  DWORD           dwBytesReceived,
    IN  LPWSAOVERLAPPED pOverlapped,
    IN  DWORD           dwFlags
    )
/*++
    Description:

        This routine is the async completion callback.  The callback is made
        on the thread that pended the IO when it becomes alertable.

    Parameters:

        dwError         - win32 error code, if any; NO_ERROR if successful

        dwBytesReceived - bytes received in the passed buffer

        pOverlapped     - OVERLAPPED struct specified in the pended read; we
                            use this to recover the original data structure

        dwFlags         - flags

    Return Values:

        none

--*/
{
    CBufferPoolBuffer * pBuffer ;
    CNetReceiver *      pNetReceiver ;

    //  recover the CBufferPoolBuffer associated with this operation
    pBuffer = reinterpret_cast <CBufferPoolBuffer *> (pOverlapped -> hEvent) ;

    //  then the receiver associated with the buffer
    pNetReceiver = reinterpret_cast <CNetReceiver *> (pBuffer -> GetCompletionContext ()) ;

    //  set the valid length of data in the CBufferPoolBuffer object
    pBuffer -> SetActualPayloadLength (dwBytesReceived - pBuffer -> GetHeaderLength ()) ;

    //  pass this off to the receiver
    pNetReceiver -> ReadCompletion (pBuffer, dwError) ;
}

void
CNetReceiver::ReadCompletion (
    IN  CBufferPoolBuffer * pBuffer,
    IN  DWORD               dwError
    )
/*++
    Routine Description:

        Processes a read completion, after all the context has been
        recovered by the original entry point.

    Arguments:

        pBuffer -   CBufferPoolBuffer object that was used to read into.

        dwError -   win32 error, if any; NO_ERROR if successful

    Return Values:

        none
--*/
{
    //  decrement the oustanding reads counter
    InterlockedDecrement (& m_lReadsPended) ;

    //  before processing any further pend another if we can
    PendReads_ () ;

    //  only pass up buffers we know are valid
    if (dwError == NO_ERROR) {
        m_pRecvFilter -> ProcessBuffer (pBuffer) ;
    }

    //  io's ref
    pBuffer -> Release () ;
}

void
CNetReceiver::PendReads_ (
    IN  DWORD   dwBufferWaitMax
    )
/*++
    Routine Description:

        Pends async reads on the socket, if we have less outstanding than
        is our max count.

    Arguments:

        dwBufferWaitMax - caller can specify how long they are willing to wait
                            (block) on the call to get a buffer to pend an IO
                            into.

    Return Values:

        none
--*/
{
    CBufferPoolBuffer * pBuffer ;
    int                 i ;
    WSABUF              wsabuf ;
    DWORD               dwBytesRead ;
    DWORD               dw ;
    DWORD               dwFlags ;

    Lock_ () ;

    //  don't pend if we might be shutdown
    if (m_hAsyncSocket != INVALID_SOCKET) {

        //  while we have reads to pend
        while (m_lReadsPended < (LONG) m_dwMaxPendReads) {

            //  get a buffer
            pBuffer = m_pBufferPool -> GetBuffer (
                                            m_hEvents [EVENT_GET_BLOCK],
                                            dwBufferWaitMax
                                            ) ;

            if (pBuffer) {
                //  got a buffer

                //  init the overlapped struct so we can recover pBuffer from
                //  the completion routine; we can legally set the .hEvent
                //  member to a value we wish because our completion routine
                //  param is non-NULL when we pend the read.
                pBuffer -> GetOverlapped () -> Offset       = 0 ;
                pBuffer -> GetOverlapped () -> OffsetHigh   = 0 ;
                pBuffer -> GetOverlapped () -> hEvent       = (HANDLE) pBuffer ;

                pBuffer -> SetCompletionContext ((DWORD_PTR) this) ;

                wsabuf.buf  = reinterpret_cast <char *> (pBuffer -> GetBuffer ()) ;
                wsabuf.len  = pBuffer -> GetBufferLength () ;

                //  no flags
                dwFlags = 0 ;

                //  keep the buffer's ref as the io's

                //  and pend the read
                i = WSARecv (
                        m_hAsyncSocket,
                        & wsabuf,
                        1,
                        & dwBytesRead,
                        & dwFlags,
                        pBuffer -> GetOverlapped (),
                        CNetReceiver::AsyncCompletionCallback
                        ) ;

                if (i == SOCKET_ERROR) {
                    dw = WSAGetLastError () ;
                    if (dw != WSA_IO_PENDING) {
                        //  legitimate error; release and abort
                        pBuffer -> Release () ;
                        break ;
                    }

                    //  otherwise the error is WSA_IO_PENDING and we'll get notified
                    //  later
                }

                //  we might have completed synchronously; we'll still have
                //  a notification queued to us, regardless of sync/async
                //  completion; in the case of a sync completion, we'll dequeue
                //  in sequence with other possibly async-completed
                //  notifications

                InterlockedIncrement (& m_lReadsPended) ;
            }
            else {
                //  did not get a buffer; most likely all are spoken for and
                //  we timedout waiting
                break ;
            }
        }
    }

    Unlock_ () ;
}

HRESULT
CNetReceiver::JoinMulticast_ (
    IN  ULONG   ulIP,           //  IP; network order
    IN  USHORT  usPort,         //  port; network order
    IN  ULONG   ulNIC           //  network interface; network order
    )
/*++
    Routine Description:

        Joins an IP multicast group (ip, port).  Will listen for multicast
        traffic on the specified group only on the interface.

    Arguments:

        ulIP    - multicast IP; must be class D; network order
        usPort  - multicast port; network order
        ulNIC   - NIC; network order

    Return Values:

        S_OK            - success
        failed HRESULT  - failure
--*/
{
    BOOL                t ;
    struct ip_mreq      mreq ;
    int                 i ;
    struct sockaddr_in  saddr ;
    DWORD               dw ;

    Lock_ () ;

    //  create our socket; async
    m_hAsyncSocket = WSASocket(
                        AF_INET,
                        SOCK_DGRAM,
                        0,
                        NULL,
                        0,
                        WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF | WSA_FLAG_OVERLAPPED
                        ) ;
    if (m_hAsyncSocket == INVALID_SOCKET) {
        goto failure ;
    }

    t = TRUE ;
    i = setsockopt(
            m_hAsyncSocket,
            SOL_SOCKET,
            SO_REUSEADDR,
            (char *)& t,
            sizeof t
            ) ;
    if (i == SOCKET_ERROR) {
        goto failure ;
    }

    ZeroMemory (& saddr, sizeof saddr) ;
    saddr.sin_family            = AF_INET ;
    saddr.sin_port              = usPort ;          //  want data on this UDP port
    saddr.sin_addr.S_un.S_addr  = INADDR_ANY ;      //  don't care about NIC we're bound to

    i = bind(
            m_hAsyncSocket,
            (LPSOCKADDR) & saddr,
            sizeof saddr
            ) ;
    if (i == SOCKET_ERROR) {
        goto failure ;
    }

    ZeroMemory (& mreq, sizeof mreq) ;
    mreq.imr_multiaddr.s_addr   = ulIP ;            //  mcast IP (port specified when we bind)
    mreq.imr_interface.s_addr   = ulNIC ;           //  over this NIC

    i = setsockopt (
            m_hAsyncSocket,
            IPPROTO_IP,
            IP_ADD_MEMBERSHIP,
            (char *) & mreq,
            sizeof mreq
            ) ;
    if (i == SOCKET_ERROR) {
        goto failure ;
    }

    Unlock_ () ;

    //  success
    return S_OK ;

    failure :

    dw = WSAGetLastError () ;
    LeaveMulticast_ () ;

    Unlock_ () ;

    return HRESULT_FROM_WIN32 (dw) ;
}

void
CNetReceiver::LeaveMulticast_ (
    )
/*++
    Routine Description:

        Leaves a multicast, if we are currently joined.  Does nothing if not
        joined.

    Arguments:

        none

    Return Values:

        none
--*/
{
    Lock_ () ;

    if (m_hAsyncSocket != INVALID_SOCKET) {
        closesocket (m_hAsyncSocket) ;
        m_hAsyncSocket = INVALID_SOCKET ;
    }

    Unlock_ () ;
}

void
CNetReceiver::ThreadProc (
    )
/*++
    Routine Description:

        Worker thread proc.  Thread loops until the stop event becomes
        signaled.  Thread blocks in an alertable state so it can handle
        async io completions on the socket.  If it times out, it tries to
        pend reads.

    Arguments:

        none

    Return Values:

        none
--*/
{
    DWORD   r ;

    for (;;) {
        r = WaitForMultipleObjectsEx (EVENT_COUNT, m_hEvents, FALSE, PULSE_MILLIS, TRUE) ;

        //  stop event was signaled; break
        if (r - WAIT_OBJECT_0 == EVENT_STOP) {
            break ;
        }

        //  timed out; try to pend more reads
        if (r == WAIT_TIMEOUT) {
            PendReads_ () ;
        }
    }

    return ;
}

HRESULT
CNetReceiver::Activate (
    IN  ULONG   ulIP,           //  IP; network order
    IN  USHORT  usPort,         //  port; network order
    IN  ULONG   ulNIC           //  network interface; network order
    )
/*++
    Routine Description:

        Activates this object.  When this object is active, it is joined to
        a multicast group (ulIP, usPort) on the specified NIC; it hosts a
        thread that pends async IO on the socket, and processes completions
        by posting the buffers into the filter.

    Arguments:

        ulIP    - multicast IP; must be class D; network order
        usPort  - multicast port; network order
        ulNIC   - NIC; network order

    Return Values:

        S_OK            - success
        failed HRESULT  - failure

--*/
{
    HRESULT hr ;
    DWORD   dw ;

    Lock_ () ;

    ASSERT (IsMulticastIP (ulIP)) ;              //  class d
    ASSERT (m_hThread == NULL) ;                //  no thread
    ASSERT (m_hEvents [EVENT_STOP] != NULL) ;   //  we can stop it

    //  initialize
    ResetEvent (m_hEvents [EVENT_STOP]) ;
    m_lReadsPended = 0 ;

    //  join the specified multicast group
    hr = JoinMulticast_ (ulIP, usPort, ulNIC) ;
    if (SUCCEEDED (hr)) {

        //  create the thread
        m_hThread = CreateThread (
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) CNetReceiver::ThreadEntry,
                        this,
                        NULL,
                        & dw
                        ) ;
        if (m_hThread) {

            //  success
            hr = S_OK ;
            ASSERT (m_hAsyncSocket != INVALID_SOCKET) ;
        }
        else {
            //  failed; shut everything down
            dw = GetLastError () ;
            LeaveMulticast_ () ;
            hr = HRESULT_FROM_WIN32 (dw) ;
        }
    }
    else {
        ASSERT (m_hAsyncSocket == INVALID_SOCKET) ;
    }

    Unlock_ () ;

    return S_OK ;
}

HRESULT
CNetReceiver::Stop (
    )
{
    //  signal thread to stop
    SetEvent (m_hEvents [EVENT_STOP]) ;

    //  leave the multicast
    LeaveMulticast_ () ;

    if (m_hThread) {
        //  wait for our thread to complete; cleanup
        WaitForSingleObject (m_hThread, INFINITE) ;
        CloseHandle (m_hThread) ;
        m_hThread = NULL ;
    }

    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\resrecv.h ===
#define IDS_IPMULTICAST_RECV_CONFIG     1
#define IDD_IPMULTICAST_RECV_CONFIG     101
#define IDC_NIC                         1002
#define IDC_PORT                        1003
#define IDC_IP                          1004
#define IDC_SAVE                        1005
#define IDC_TTL                         1006
#define IDC_MEDIATYPE                   1007
#define IDC_SET_GPNIC                   1008
#define IDC_SET_MT                      1009
#define IDS_IPMULTICAST_SEND_CONFIG     2
#define IDD_IPMULTICAST_SEND_CONFIG     102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\proprecv.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        proprecv.h

    Abstract:

        Class declarations for the classes we use to get/set/display
        property page information.

    Notes:

--*/


#ifndef __proprecv_h
#define __proprecv_h

/*++
    Class Name:

        CNetRecvProp

    Abstract:

        This class is used to gather & post data to the receiver's property
        page.

--*/

class CNetRecvProp :
    public CBasePropertyPage
{
    HWND                        m_hwnd ;                    //  property page's HWND
    IMulticastReceiverConfig *  m_pIMulticastRecvConfig ;   //  multicast config COM ifc
    CNetInterface               m_NIC ;

    HRESULT
    OnSetGroupNIC_ (
        ) ;

    HRESULT
    OnSetMediaType_ (
        ) ;

    void
    Refresh_ (
        ) ;

    public :

        CNetRecvProp (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        BOOL
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

#endif  //  __proprecv_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\main.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        main.cpp

    Abstract:


    Notes:

--*/

#include "precomp.h"
#include "dsnetifc.h"
#include "propsend.h"
#include "netsend.h"
#include "dssend.h"

AMOVIESETUP_FILTER
g_sudSendFilter = {
    & CLSID_DSNetSend,
    NET_SEND_FILTER_NAME,
    MERIT_DO_NOT_USE,
    0,                                              //  0 pins registered
    NULL
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\dssend.cpp ===
/*++

 (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dssend.cpp

    Abstract:


--*/

#include "precomp.h"
#include "dsnetifc.h"
#include "netsend.h"
#include "dssend.h"

#define NET_SEND(pf)    (reinterpret_cast <CNetworkSend *> (pf))

//  ---------------------------------------------------------------------------
//  ---------------------------------------------------------------------------

CInputPin::CInputPin (
    IN  TCHAR *         szName,
    IN  CBaseFilter *   pFilter,
    IN  CCritSec *      pLock,
    OUT HRESULT *       pHr,
    IN  LPCWSTR         pszName
    ) : CBaseInputPin   (szName,
                         pFilter,
                         pLock,
                         pHr,
                         pszName
                         )
{
}

CInputPin::~CInputPin (
    )
{
}

HRESULT
CInputPin::GetMediaType (
    IN  int             iPos,
    OUT CMediaType *    pmt
    )
{
    ASSERT (pmt) ;

    if (iPos == 0) {

        pmt -> InitMediaType () ;

        pmt -> SetType      (& MEDIATYPE_Stream) ;
        //  don't care about subtype

        return S_OK ;
    }

    return VFW_S_NO_MORE_ITEMS ;
}

HRESULT
CInputPin::CheckMediaType (
    IN  const CMediaType *  pmt
    )
{
    //  don't care about subtype
    if (pmt -> majortype    == MEDIATYPE_Stream) {

        return NOERROR ;
    }

    return S_FALSE ;
}

HRESULT
CInputPin::Receive (
    IN  IMediaSample * pIMediaSample
    )
{
    HRESULT hr ;

    ASSERT (m_pFilter) ;
    ASSERT (pIMediaSample) ;

    NET_SEND (m_pFilter) -> LockReceive () ;

    hr = CBaseInputPin::Receive (pIMediaSample) ;
    if (SUCCEEDED (hr)) {
        hr = NET_SEND (m_pFilter) -> Send (pIMediaSample) ;
    }

    NET_SEND (m_pFilter) -> UnlockReceive () ;

    return hr ;
}

//  ----------------------------------------------------------------------------

CNetworkSend::CNetworkSend (
    IN  TCHAR *     tszName,
    IN  LPUNKNOWN   punk,
    OUT HRESULT *   phr
    ) : CBaseFilter     (
                         tszName,
                         punk,
                         & m_crtFilter,
                         CLSID_DSNetSend
                         ),
        CPersistStream  (punk,
                         phr
                         ),
        m_pInput        (NULL),
        m_ulIP          (UNDEFINED),
        m_ulNIC         (UNDEFINED),
        m_ulScope       (DEFAULT_SCOPE),
        m_pNetSender    (NULL),
        m_hkeyRoot      (NULL)
{
    DWORD   dw ;
    LONG    l ;
    DWORD   dwDisposition ;

    (* phr) = S_OK ;

    l = RegCreateKeyEx (
            REG_DSNET_TOP_LEVEL,
            REG_DSNET_SEND_ROOT,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & m_hkeyRoot,
            & dwDisposition
            ) ;
    if (l != ERROR_SUCCESS) {
        dw = GetLastError () ;
        (* phr) = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    m_pInput = new CInputPin (
                            NAME ("CInputPin"),
                            this,
                            & m_crtFilter,
                            phr,
                            L"Stream"
                            ) ;
    if (m_pInput == NULL ||
        FAILED (* phr)) {

        (* phr) = FAILED (* phr) ? (* phr) : E_OUTOFMEMORY ;
        goto cleanup ;
    }

    //  integral number of transport packets
    m_pNetSender = new CNetSender (m_hkeyRoot, phr) ;
    if (m_pNetSender == NULL ||
        FAILED (* phr)) {

        (* phr) = FAILED (* phr) ? (* phr) : E_OUTOFMEMORY ;
        goto cleanup ;
    }

    cleanup :

    return ;
}

CNetworkSend::~CNetworkSend ()
{
    delete m_pInput ;
    delete m_pNetSender ;

    if (m_hkeyRoot != NULL) {
        RegCloseKey (m_hkeyRoot) ;
    }
}

CBasePin *
CNetworkSend::GetPin (
    IN  int Index
    )
{
    CBasePin * pPin ;

    LockFilter () ;

    if (Index == 0) {
        pPin = m_pInput ;
    }
    else {
        pPin = NULL ;
    }

    UnlockFilter () ;

    return pPin ;
}

STDMETHODIMP
CNetworkSend::Pause (
    )
{
    HRESULT hr ;

    LockFilter () ;

    if  (m_State == State_Stopped) {

        //  --------------------------------------------------------------------
        //  stopped -> paused state transition; try to join the multicast

        hr = m_pNetSender -> JoinMulticast (
                m_ulIP,
                m_usPort,
                m_ulNIC,
                m_ulScope
                ) ;
        if (SUCCEEDED (hr)) {
            //  change the state, THEN activate the input pin
            m_State = State_Paused ;

            if (m_pInput &&
                m_pInput -> IsConnected ()) {
                m_pInput -> Active () ;
            }
        }
    }
    else {
        //  --------------------------------------------------------------------
        //  run -> paused transition; just set it

        m_State = State_Paused ;
    }

    UnlockFilter () ;

    return S_OK ;
}

STDMETHODIMP
CNetworkSend::Stop (
    )
{
    HRESULT hr ;

    LockReceive () ;
    LockFilter () ;

    //  inactivate the input pin
    if (m_pInput) {
        m_pInput -> Inactive () ;
    }

    //  leave the multicast
    hr = m_pNetSender -> LeaveMulticast () ;

    //  set the state
    m_State = State_Stopped ;

    UnlockFilter () ;
    UnlockReceive () ;

    return S_OK ;
}

CUnknown *
CNetworkSend::CreateInstance (
    IN  LPUNKNOWN   punk,
    OUT HRESULT *   phr
    )
{
    CNetworkSend * pnf ;

    (* phr) = S_OK ;

    pnf = new CNetworkSend (
                    NAME ("CNetworkSend"),
                    punk,
                    phr
                    ) ;
    if (pnf == NULL) {
        * phr = E_OUTOFMEMORY ;
    }

    if (FAILED (* phr)) {
        DELETE_RESET (pnf) ;
    }

    return pnf ;
}

STDMETHODIMP
CNetworkSend::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  property pages

    if (riid == IID_ISpecifyPropertyPages) {

        return GetInterface (
                    (ISpecifyPropertyPages *) this,
                    ppv
                    ) ;
    }

    //  multicast

    else if (riid == IID_IMulticastConfig) {

        return GetInterface (
                    (IMulticastConfig *) this,
                    ppv
                    ) ;
    }

    //  multicast sender

    else if (riid == IID_IMulticastSenderConfig) {

        return GetInterface (
                    (IMulticastSenderConfig *) this,
                    ppv
                    ) ;
    }

    //  we do persist

    else if (riid == IID_IPersistStream) {

        return GetInterface (
                    (IPersistStream *) this,
                    ppv
                    ) ;
    }

    //  fallback - call the baseclass

    else {
        return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
    }
}

STDMETHODIMP
CNetworkSend::GetPages (
    IN OUT CAUUID * pPages
    )
{
    pPages -> cElems = 1 ;

    pPages -> pElems = (GUID *) CoTaskMemAlloc (pPages -> cElems * sizeof GUID) ;

    if (pPages -> pElems == NULL) {
        return E_OUTOFMEMORY;
    }

    (pPages -> pElems) [0] = CLSID_IPMulticastSendProppage ;

    return S_OK ;
}

HRESULT
CNetworkSend::Send (
    IN  IMediaSample * pIMediaSample
    )
{
    BYTE *  pbBuffer ;
    HRESULT hr ;

    //  should have the receiver lock

    //  recover the buffer pointer and send it out
    hr = pIMediaSample -> GetPointer (& pbBuffer) ;
    if (SUCCEEDED (hr)) {
        hr = m_pNetSender -> Send (
                                pbBuffer,
                                pIMediaSample -> GetActualDataLength ()
                                ) ;
    }

    return hr ;
}

STDMETHODIMP
CNetworkSend::SetNetworkInterface (
    IN  ULONG   ulNIC
    )
{
    HRESULT hr ;

    if (m_State != State_Stopped) {
        //  can only set this if we're stopped
        hr = E_UNEXPECTED ;
    }
    else if (IsUnicastIP (ulNIC) ||
             ulNIC == INADDR_ANY) {

        //  looks like a valid NIC; set it
        m_ulNIC = ulNIC ;
        hr = S_OK ;
    }
    else {
        hr = E_INVALIDARG ;
    }

    return hr ;
}

STDMETHODIMP
CNetworkSend::GetNetworkInterface (
    OUT ULONG * pulNIC
    )
{
    HRESULT hr ;

    if (pulNIC) {
        (* pulNIC) = m_ulNIC ;
        hr = S_OK ;
    }
    else {
        hr = E_INVALIDARG ;
    }

    return hr ;
}

STDMETHODIMP
CNetworkSend::SetMulticastGroup (
    IN  ULONG   ulIP,
    IN  USHORT  usPort
    )
{
    HRESULT hr ;

    if (m_State != State_Stopped) {
        //  can only do this when stopped
        hr = E_UNEXPECTED ;
    }
    else if (IsMulticastIP (ulIP)) {

        //  looks like a valid multicast IP address; we place no restrictions
        //  on the port

        m_ulIP      = ulIP ;
        m_usPort    = usPort ;

        hr = S_OK ;
    }
    else {
        hr = E_INVALIDARG ;
    }

    return hr ;
}

STDMETHODIMP
CNetworkSend::GetMulticastGroup (
    OUT ULONG *     pIP,
    OUT USHORT  *   pPort
    )
{
    HRESULT hr ;

    if (pIP == NULL ||
        pPort == NULL) {

        hr = E_INVALIDARG ;
    }
    else {
        (* pIP)     = m_ulIP ;
        (* pPort)   = m_usPort ;

        hr = S_OK ;
    }

    return hr ;
}

STDMETHODIMP
CNetworkSend::SetScope (
    IN  ULONG   ulScope
    )
{
    m_ulScope = ulScope ;

    return S_OK ;
}

STDMETHODIMP
CNetworkSend::GetScope (
    OUT ULONG * pulScope
    )
{
    if (!pulScope) {
        return E_POINTER ;
    }

    (* pulScope) = m_ulScope ;

    return S_OK ;
}

STDMETHODIMP
CNetworkSend::GetClassID (
    OUT CLSID * pCLSID
    )
{
    (* pCLSID) = CLSID_DSNetSend ;
    return S_OK ;
}

HRESULT
CNetworkSend::WriteToStream (
    IN  IStream *   pIStream
    )
{
    HRESULT hr ;

    LockFilter () ;

    hr = pIStream -> Write ((BYTE *) & m_ulIP, sizeof m_ulIP, NULL) ;
    if (SUCCEEDED (hr)) {
        hr = pIStream -> Write ((BYTE *) & m_usPort, sizeof m_usPort, NULL) ;
        if (SUCCEEDED (hr)) {
            hr = pIStream -> Write ((BYTE *) & m_ulNIC, sizeof m_ulNIC, NULL) ;
            if (SUCCEEDED (hr)) {
                hr = pIStream -> Write ((BYTE *) & m_ulScope, sizeof m_ulScope, NULL) ;
            }
        }
    }

    UnlockFilter () ;

    return hr ;
}

HRESULT
CNetworkSend::ReadFromStream (
    IN  IStream *   pIStream
    )
{
    HRESULT hr ;

    LockFilter () ;

    hr = pIStream -> Read ((BYTE *) & m_ulIP, sizeof m_ulIP, NULL) ;
    if (SUCCEEDED (hr)) {
        hr = pIStream -> Read ((BYTE *) & m_usPort, sizeof m_usPort, NULL) ;
        if (SUCCEEDED (hr)) {
            hr = pIStream -> Read ((BYTE *) & m_ulNIC, sizeof m_ulNIC, NULL) ;
            if (SUCCEEDED (hr)) {
                hr = pIStream -> Read ((BYTE *) & m_ulScope, sizeof m_ulScope, NULL) ;
            }
        }
    }

    UnlockFilter () ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\dssend.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        dssend.h

    Abstract:


    Notes:

--*/


#define NET_SEND_FILTER_NAME                L"IP Multicast Stream Sender"
#define NET_SEND_PROP_PAGE_NAME             L"Send Properties"

extern AMOVIESETUP_FILTER g_sudSendFilter ;

class CInputPin ;
class CNetworkSend ;
class CNetSender ;

/*++
    Class Name:

        CInputPin

    Abstract:

        Input pin implementation.

--*/
class CInputPin :
    public CBaseInputPin
{
    public :

        CInputPin (
            IN  TCHAR *         szName,
            IN  CBaseFilter *   pFilter,
            IN  CCritSec *      pLock,
            OUT HRESULT *       pHr,
            IN  LPCWSTR         pszName
            ) ;

        ~CInputPin () ;

        HRESULT
        GetMediaType (
            IN  int             iPos,
            OUT CMediaType *    pmt
            ) ;

        HRESULT
        CheckMediaType (
            IN  const CMediaType *  pmt
            ) ;

        STDMETHODIMP
        Receive (
            IN  IMediaSample *
            ) ;
} ;

/*++
    Class Name:

        CNetworkSend

    Abstract:

        Filter object.  Implements all filter-related functionality.  Hosts
        the multicast net sender object.  Gathers multicast group, TTL, and
        NIC settings, and uses them to properly configure the multicast network
        sender.

--*/
class CNetworkSend :
    public CBaseFilter,                 //  dshow filter
    public IMulticastSenderConfig,      //  our own interface; configs mcast
    public ISpecifyPropertyPages,       //  get prop page info
    public CPersistStream               //  persist information
{
    enum {
        DEFAULT_SCOPE   = 1
    } ;

    CCritSec        m_crtFilter ;       //  filter lock
    CCritSec        m_crtRecv ;         //  receiver lock;
                                        //   always acquire before filter lock
                                        //   if both must be acquired
    CInputPin *     m_pInput ;          //  input pin
    CNetSender *    m_pNetSender ;      //  network sender (multicaster)
    ULONG           m_ulIP ;            //  IP address; network order
    USHORT          m_usPort ;          //  port; network order
    ULONG           m_ulNIC ;           //  NIC; network order
    ULONG           m_ulScope ;         //  multicast scope
    HKEY            m_hkeyRoot ;

    public :

        CNetworkSend (
            IN  TCHAR *     tszName,
            IN  LPUNKNOWN   punk,
            OUT HRESULT *   phr
            ) ;

        ~CNetworkSend (
            ) ;

        //  --------------------------------------------------------------------
        //  class methods

        //  synchronous send
        HRESULT
        Send (
            IN  IMediaSample *
            ) ;

        //  explicit receiver lock aquisition and release
        void LockReceive ()             { m_crtRecv.Lock () ; }
        void UnlockReceive ()           { m_crtRecv.Unlock () ; }

        //  explicit filter lock aquisition and release
        void LockFilter ()              { m_crtFilter.Lock () ; }
        void UnlockFilter ()            { m_crtFilter.Unlock () ; }

        //  --------------------------------------------------------------------
        //  COM interfaces

        DECLARE_IUNKNOWN ;
        DECLARE_IMULTICASTSENDERCONFIG () ;

        //  override this so we can succeed or delegate to base classes
        STDMETHODIMP
        NonDelegatingQueryInterface (
            IN  REFIID  riid,
            OUT void ** ppv
            ) ;

        //  --------------------------------------------------------------------
        //  CBaseFilter methods

        int GetPinCount ()              { return 1 ; }

        CBasePin *
        GetPin (
            IN  int Index
            ) ;

        STDMETHODIMP
        Pause (
            ) ;

        STDMETHODIMP
        Stop (
            ) ;

        STDMETHODIMP
        GetClassID (
            OUT CLSID * pCLSID
            ) ;

        //  --------------------------------------------------------------------
        //  class factory calls this

        static
        CUnknown *
        CreateInstance (
            IN  LPUNKNOWN   punk,
            OUT HRESULT *   phr
            ) ;

        //  --------------------------------------------------------------------
        //  ISpecifyPropertyPages

        STDMETHODIMP
        GetPages (
            IN OUT CAUUID * pPages
            ) ;

        //  --------------------------------------------------------------------
        //  CPersistStream

        HRESULT
        WriteToStream (
            IN  IStream *   pIStream
            ) ;

        HRESULT
        ReadFromStream (
            IN  IStream *   pIStream
            ) ;

        int
        SizeMax (
            )
        {
            return (sizeof m_ulIP + sizeof m_usPort + sizeof m_ulNIC) ;
        }
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\receiver\proprecv.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        proprecv.cpp

    Abstract:

        Class implementation to get/set/display property pages.

    Notes:

--*/


#include "precomp.h"
#include "resrecv.h"
#include "dsnetifc.h"
#include "proprecv.h"
#include "controls.h"
#include "nutil.h"

//  order is important !  Keep these in the same order as the
//  detail declarations in g_CannedType.
static
enum {
    MEDIATYPE_MPEG2_TRANSPORT,
    MEDIATYPE_MPEG2_PROGRAM,
    MEDIATYPE_UNKNOWN,

    NUM_CANNED_TYPE,                //  count - always last
} ;

//  keep these in the same order as the enum'd types above
static
struct {
    WCHAR * szDescription ;

    struct {
        const GUID *    pMajorType ;
        const GUID *    pSubType ;
        BOOL            bFixedSizeSamples ;
        const GUID *    pFormatType ;
        int             cbFormat ;
        BYTE *          pbFormat ;
    } MediaType ;

} g_CannedType [] = {

    //  mpeg-2 transport stream
    {
        L"mpeg-2 transport stream",
        {
            & MEDIATYPE_Stream,                 //  majortype
            & MEDIASUBTYPE_MPEG2_TRANSPORT,     //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },

    //  mpeg-2 program stream
    {
        L"mpeg-2 program stream",
        {
            & MEDIATYPE_Stream,                 //  majortype
            & MEDIASUBTYPE_MPEG2_PROGRAM,       //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },

    //  unknown
    {
        L"UNKNOWN",
        {
            NULL,                               //  majortype
            NULL,                               //  subtype
            TRUE,                               //  bFixedSizeSamples
            NULL,                               //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },
} ;

static
BOOL
SameAsCannedType (
    IN  AM_MEDIA_TYPE * pmt,
    IN  int             iCannedIndex
    )
{
    BOOL    f ;

    ASSERT (pmt) ;
    ASSERT (iCannedIndex < NUM_CANNED_TYPE) ;

    if (iCannedIndex != MEDIATYPE_UNKNOWN) {
        f = ((pmt -> majortype    == (* g_CannedType [iCannedIndex].MediaType.pMajorType)     &&
              pmt -> subtype      == (* g_CannedType [iCannedIndex].MediaType.pSubType)       &&
              pmt -> formattype   == (* g_CannedType [iCannedIndex].MediaType.pFormatType)) ? TRUE : FALSE) ;
    }
    else {
        f = FALSE ;
    }

    return f ;
}

//  error conditions
static
void
MessageBoxError (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK | MB_ICONEXCLAMATION) ;
}

//  ---------------------------------------------------------------------------

CNetRecvProp::CNetRecvProp (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage       (
                                 pClassName,
                                 pIUnknown,
                                 IDD_IPMULTICAST_RECV_CONFIG,
                                 IDS_IPMULTICAST_RECV_CONFIG
                                 ),
        m_hwnd                  (NULL),
        m_pIMulticastRecvConfig (NULL)
{
    * pHr = S_OK ;
}

void
CNetRecvProp::Refresh_ (
    )
{
    //  synchronize the display to our config

    CCombobox       MediaTypes  (m_hwnd, IDC_MEDIATYPE) ;
    CCombobox       NICs        (m_hwnd, IDC_NIC) ;
    CEditControl    IP          (m_hwnd, IDC_IP) ;
    CEditControl    Port        (m_hwnd, IDC_PORT) ;
    ULONG           ul, ul2 ;
    USHORT          us ;
    HRESULT         hr ;
    int             i, k ;
    WCHAR           ach [32] ;
    AM_MEDIA_TYPE   mt ;

    //  -----------------------------------------------------------------------
    //  NIC

    hr = m_pIMulticastRecvConfig -> GetNetworkInterface (& ul) ;
    if (FAILED (hr)) {
        return ;
    }

    for (i = 0;;i++) {
        k = NICs.GetItemData (& ul2, i) ;
        if (k == CB_ERR) {
            //  should not happen; undefine it
            m_pIMulticastRecvConfig -> SetNetworkInterface (UNDEFINED) ;
            for (i = 0;;i++) {
                NICs.GetItemData (& ul2, i) ;
                if (ul2 == UNDEFINED) {
                    NICs.Focus (i) ;
                    break ;
                }
            }

            break ;
        }

        if (ul2 == ul) {
            NICs.Focus (i) ;
            break ;
        }
    }

    //  -----------------------------------------------------------------------
    //  group

    hr = m_pIMulticastRecvConfig -> GetMulticastGroup (& ul, & us) ;
    if (FAILED (hr)) {
        return ;
    }

    if (ul != UNDEFINED) {
        IP.SetTextW (AnsiToUnicode (inet_ntoa (* (struct in_addr *) & ul), ach, 32)) ;
    }
    else {
        IP.SetTextW (UNDEFINED_STR) ;
    }

    us = ntohs (us) ;
    Port.SetTextW (_itow (us, ach, 10)) ;

    //  -----------------------------------------------------------------------
    //  media type

    ZeroMemory (& mt, sizeof mt) ;
    hr = m_pIMulticastRecvConfig -> GetOutputPinMediaType (& mt) ;
    if (SUCCEEDED (hr)) {
        //  look for a match

        for (i = 0; i < NUM_CANNED_TYPE; i++) {
            MediaTypes.GetItemData (& ul, i) ;

            if (SameAsCannedType (& mt, i)) {
                MediaTypes.Focus (i) ;
                break ;
            }
            else {
                MediaTypes.Focus (MEDIATYPE_UNKNOWN) ;
            }
        }
    }

    return ;
}

HRESULT
CNetRecvProp::OnActivate (
    )
{
    CCombobox           NICs        (m_hwnd, IDC_NIC) ;
    CCombobox           MediaTypes  (m_hwnd, IDC_MEDIATYPE) ;
    int                 iIndex ;
    INTERFACE_INFO *    pIfc ;
    DWORD               i ;
    WCHAR               ach [32] ;

    //  ------------------------------------------------------------------------
    //  populate the NICs

    //  setup the NICs

    ASSERT (m_NIC.IsInitialized ()) ;

    for (i = 0, pIfc = m_NIC [i] ;
         pIfc ;
         i++, pIfc = m_NIC [i]) {

        if ((pIfc -> iiFlags & IFF_UP) &&
            (pIfc -> iiFlags & IFF_MULTICAST)) {

            iIndex = NICs.AppendW (AnsiToUnicode (inet_ntoa (pIfc -> iiAddress.AddressIn.sin_addr), ach, 32)) ;
            if (iIndex == CB_ERR) {
                return E_FAIL ;
            }

            NICs.SetItemData (* (DWORD *) (& pIfc -> iiAddress.AddressIn.sin_addr), iIndex) ;
        }
    }

    //  wildcard
    iIndex = NICs.AppendW (ANY_IFC) ;
    if (iIndex == CB_ERR) {
        return E_FAIL ;
    }
    NICs.SetItemData (INADDR_ANY, iIndex) ;

    //  undefined
    iIndex = NICs.AppendW (UNDEFINED_STR) ;
    if (iIndex == CB_ERR) {
        return E_FAIL ;
    }
    NICs.SetItemData (UNDEFINED, iIndex) ;

    //  ------------------------------------------------------------------------
    //  populate the media types

    for (i = 0; i < NUM_CANNED_TYPE; i++) {
        iIndex = MediaTypes.AppendW (g_CannedType [i].szDescription) ;
        if (iIndex != CB_ERR) {

            //  i corresponds to the canned type enumeration and is used
            //  used later to index into the g_CannedType array to retrieve
            //  pin type information
            MediaTypes.SetItemData (i, iIndex) ;
        }
    }
    MediaTypes.Focus (0) ;

    Refresh_ () ;

    return S_OK ;
}

HRESULT
CNetRecvProp::OnSetGroupNIC_ (
    )
{
    CCombobox       NICs        (m_hwnd, IDC_NIC) ;
    CEditControl    IP          (m_hwnd, IDC_IP) ;
    CEditControl    Port        (m_hwnd, IDC_PORT) ;
    int             i ;
    ULONG           ulIP ;
    USHORT          usPort ;
    ULONG           ulNIC ;
    HRESULT         hr ;
    WCHAR           wach [32] ;
    char            ach [32] ;
    CMediaType      cmt ;

    if (IP.IsEmpty () ||
        Port.IsEmpty ()) {

        return E_INVALIDARG ;
    }

    //  IP
    IP.GetTextW (wach, 32) ;
    ulIP = inet_addr (UnicodeToAnsi (wach, ach, 32)) ;
    if (ulIP == INADDR_NONE) {
        return E_FAIL ;
    }

    //  port
    Port.GetText (& i) ;
    i &= 0x0000ffff ;
    usPort = htons ((USHORT) i) ;

    //  NIC
    NICs.GetCurrentItemData (& ulNIC) ;

    hr = m_pIMulticastRecvConfig -> SetMulticastGroup (ulIP, usPort) ;
    if (SUCCEEDED (hr)) {
        hr = m_pIMulticastRecvConfig -> SetNetworkInterface (ulNIC) ;
    }

    return hr ;
}

HRESULT
CNetRecvProp::OnSetMediaType_ (
    )
{
    CCombobox   MediaTypes  (m_hwnd, IDC_MEDIATYPE) ;
    ULONG       ulCannedIndex ;
    HRESULT     hr ;
    CMediaType  cmt ;

    //  media type
    MediaTypes.GetCurrentItemData (& ulCannedIndex) ;

    if (ulCannedIndex != MEDIATYPE_UNKNOWN) {

        ASSERT (ulCannedIndex < NUM_CANNED_TYPE) ;

        cmt.InitMediaType () ;
        cmt.SetType         (g_CannedType [ulCannedIndex].MediaType.pMajorType) ;
        cmt.SetSubtype      (g_CannedType [ulCannedIndex].MediaType.pSubType) ;
        cmt.SetFormatType   (g_CannedType [ulCannedIndex].MediaType.pFormatType) ;

        hr = m_pIMulticastRecvConfig -> SetOutputPinMediaType (& cmt) ;
    }

    return hr ;
}

HRESULT
CNetRecvProp::OnApplyChanges (
    )
{
    HRESULT hr ;

    hr = OnSetGroupNIC_ () ;
    if (SUCCEEDED (hr)) {
        hr = OnSetMediaType_ () ;
    }

    return hr ;
}

HRESULT
CNetRecvProp::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    HRESULT hr ;

    ASSERT (pIUnknown) ;

    if (!m_NIC.IsInitialized ()) {
        hr = m_NIC.Initialize () ;
        if (FAILED (hr)) {
            return hr ;
        }
    }

    hr = pIUnknown -> QueryInterface (
                            IID_IMulticastReceiverConfig,
                            (void **) & m_pIMulticastRecvConfig
                            ) ;

    return hr ;
}

HRESULT
CNetRecvProp::OnDeactivate (
    )
{
    return S_OK ;
}

HRESULT
CNetRecvProp::OnDisconnect (
    )
{
    RELEASE_AND_CLEAR (m_pIMulticastRecvConfig) ;
    return S_OK ;
}

BOOL
CNetRecvProp::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    HRESULT hr ;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT (m_hwnd == NULL) ;
            m_hwnd = hwnd ;
            return TRUE ;
        }

        case WM_DESTROY :
        {
            m_hwnd = NULL ;
            break ;
        }

        case WM_COMMAND:
        {
            switch (LOWORD (wParam)) {
                case IDC_SET_GPNIC :
                    hr = OnSetGroupNIC_ () ;
                    if (FAILED (hr)) {
                        MessageBoxError (TEXT ("Failed to Save"), TEXT ("The returned error code is %08xh"), hr) ;
                        Refresh_ () ;
                    }
                    break ;

                case IDC_SET_MT :
                    hr = OnSetMediaType_ () ;
                    if (FAILED (hr)) {
                        MessageBoxError (TEXT ("Failed to Save"), TEXT ("The returned error code is %08xh"), hr) ;
                        Refresh_ () ;
                    }
                    break ;
            } ;

            return TRUE ;
        }

    }

    return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

CUnknown *
WINAPI
CNetRecvProp::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CNetRecvProp *  pProp ;

    pProp = new CNetRecvProp (
                        NAME ("CNetRecvProp"),
                        pIUnknown,
                        CLSID_IPMulticastRecvProppage,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\netsend.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        netsend.h

    Abstract:


    Notes:

--*/

#ifndef __netsend_h
#define __netsend_h

/*++
    Class Name:

        CNetSender

    Abstract:

        This class joins, leaves, and sends to the specified multicast
        group.  Creates a synchronous socket to send on.

        It does not serialize access and relies on calling software to do
        this.

--*/
class CNetSender
{
    SOCKET              m_hSocket ;                 //  socket to send on
    DWORD               m_dwPTTransmitLength ;      //  desired transmit length (max)
    WSADATA             m_wsaData ;                 //  used during initialization
    CNetBuffer          m_NetBuffer ;
    WORD                m_wCounter ;
    struct sockaddr_in  m_saddrDest ;


    public :

        CNetSender (
            IN  HKEY        hkeyRoot,
            OUT HRESULT *   phr
            ) ;

        ~CNetSender (
            ) ;

        //  joins a multicast
        HRESULT
        JoinMulticast (
            IN  ULONG   ulIP,
            IN  USHORT  usPort,
            IN  ULONG   ulNIC,
            IN  ULONG   ulTTL
            ) ;

        //  leaves the multicast; can safely be called if we're not part of
        //  a multicast
        HRESULT
        LeaveMulticast (
            ) ;

        //  send; synchronous operation
        HRESULT
        Send (
            IN  BYTE *  pbBuffer,
            IN  DWORD   dwLength
            ) ;
} ;

#endif  //  __netsend_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\netsend.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        netsend.cpp

    Abstract:


--*/

#include "precomp.h"
#include "dsnetifc.h"
#include "netsend.h"
#include "dssend.h"

//  ----------------------------------------------------------------------------

CNetSender::CNetSender (
    IN  HKEY        hkeyRoot,
    OUT HRESULT *   phr
    ) : m_hSocket               (INVALID_SOCKET),
        m_dwPTTransmitLength    (REG_DEF_BUFFER_LEN),
        m_NetBuffer             (m_dwPTTransmitLength,
                                 phr)
{
    int i ;

    m_dwPTTransmitLength = REG_DEF_BUFFER_LEN ;
    GetRegDWORDValIfExist (
            hkeyRoot,
            REG_BUFFER_LEN_NAME,
            & m_dwPTTransmitLength
            ) ;
    if (IsOutOfBounds <DWORD> (m_dwPTTransmitLength, MIN_VALID_IOBUFFER_LENGTH, MAX_VALID_IOBUFFER_LENGTH)) {
        m_dwPTTransmitLength = SetInBounds <DWORD> (m_dwPTTransmitLength, MIN_VALID_IOBUFFER_LENGTH, MAX_VALID_IOBUFFER_LENGTH) ;
        SetRegDWORDVal (
            hkeyRoot,
            REG_BUFFER_LEN_NAME,
            m_dwPTTransmitLength
            ) ;
    }

    //  align on ts packet boundary
    m_dwPTTransmitLength = (m_dwPTTransmitLength / TS_PACKET_LENGTH) * TS_PACKET_LENGTH ;

    //  we want winsock 2.0
    ZeroMemory (& m_wsaData, sizeof m_wsaData) ;

    if (FAILED (* phr)) {
        goto cleanup ;
    }

    i = WSAStartup (MAKEWORD(2, 0), & m_wsaData) ;
    if (i) {
        (* phr) = E_FAIL ;
        goto cleanup ;
    }

    cleanup :

    return ;
}

CNetSender::~CNetSender (
    )
{
    //  should have left the multicast prior to being deleted
    ASSERT (m_hSocket == INVALID_SOCKET) ;

    WSACleanup () ;
}

HRESULT
CNetSender::Send (
    IN  BYTE *  pbBuffer,
    IN  DWORD   dwLength
    )
{
    HRESULT hr ;
    int     i ;
    DWORD   dw ;
    DWORD   dwSnarf ;

    //
    //  Note we do nothing to serialize on the receiver.  Depending on the
    //  distance, receiving host config and operations environment, receiver
    //  might get these out of order, duplicates, or miss them altogether.
    //  This is a quick/dirty sample, so we punt that schema.  Besides, we
    //  anticipate usage of this code to be such that the sender and receivers
    //  are on the same segment, so there's very little likelyhood the receiver
    //  will need to deal with this situation.
    //

    ASSERT (pbBuffer) ;

    if (m_hSocket != INVALID_SOCKET) {

        //  we have a valid socket to send on; loop through the buffer, snarf
        //  the max we can and send it off; we're doing synchronous sends

        while (dwLength > 0) {

            //  snarf what's left of the buffer, or the send quantum we're
            //  setup for
            dwSnarf = Min <DWORD> (m_dwPTTransmitLength, dwLength) ;
            ASSERT (m_dwPTTransmitLength == m_NetBuffer.GetPayloadBufferLength ()) ;

            //  counter
            m_NetBuffer.SetCounter (m_wCounter++) ;

            //  then content
            CopyMemory (m_NetBuffer.GetPayloadBuffer (), pbBuffer, dwSnarf) ;
            m_NetBuffer.SetActualPayloadLength (dwSnarf) ;

            //  then send
            i = sendto (
                    m_hSocket,
                    (char *) m_NetBuffer.GetBuffer (),
                    (int) m_NetBuffer.GetBufferSendLength (),
                    0,
                    (LPSOCKADDR) & m_saddrDest,
                    sizeof m_saddrDest
                    ) ;

            if (i != (int) m_NetBuffer.GetBufferSendLength ()) {
                dw = GetLastError () ;
                return HRESULT_FROM_WIN32 (dw) ;
            }

            //  increment decrement
            pbBuffer += dwSnarf ;
            dwLength -= dwSnarf ;
        }

        hr = S_OK ;
    }
    else {
        hr = E_UNEXPECTED ;
    }

    return hr ;
}

HRESULT
CNetSender::JoinMulticast (
    IN  ULONG   ulIP,
    IN  USHORT  usPort,
    IN  ULONG   ulNIC,
    IN  ULONG   ulTTL
    )
{
    BOOL                t ;
    int                 i ;
    struct sockaddr_in  saddr ;
    DWORD               dw ;

    LeaveMulticast () ;
    ASSERT (m_hSocket == INVALID_SOCKET) ;

    m_hSocket = WSASocket (
        AF_INET,
        SOCK_DGRAM,
        0,
        NULL,
        0,
        WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF) ;

    if (m_hSocket == INVALID_SOCKET) {
        goto JoinFail ;
    }

    t = TRUE ;
    i = setsockopt (
            m_hSocket,
            SOL_SOCKET,
            SO_REUSEADDR,
            (char *) & t,
            sizeof t
            ) ;
    if (i == SOCKET_ERROR) {
        goto JoinFail ;
    }

    ZeroMemory (& saddr, sizeof saddr) ;
    saddr.sin_family            = AF_INET ;
    saddr.sin_port              = usPort ;      //  want data on this UDP port
    saddr.sin_addr.S_un.S_addr  = INADDR_ANY ;  //  don't care about NIC we're bound to

    i = bind (
            m_hSocket,
            (LPSOCKADDR) & saddr,
            sizeof saddr
            ) ;
    if (i == SOCKET_ERROR) {
        goto JoinFail ;
    }

    i = setsockopt (
            m_hSocket,
            IPPROTO_IP,
            IP_MULTICAST_TTL,
            (char *) & ulTTL,
            sizeof ulTTL
            ) ;
    if (i == SOCKET_ERROR) {
        goto JoinFail ;
    }

    i = setsockopt (
            m_hSocket,
            IPPROTO_IP,
            IP_MULTICAST_IF,
            (char *) & ulNIC,
            sizeof ulNIC
            ) ;
    if (i == SOCKET_ERROR) {
        goto JoinFail ;
    }

    ZeroMemory (& m_saddrDest, sizeof m_saddrDest) ;
    m_saddrDest.sin_family              = AF_INET ;
    m_saddrDest.sin_port                = usPort ;
    m_saddrDest.sin_addr.S_un.S_addr    = ulIP ;

    //  counter is set per multicast session
    m_wCounter = (WORD) GetTickCount () ;

    return TRUE ;

    JoinFail:

    dw = WSAGetLastError () ;
    if (dw == NOERROR) {
        //  make sure an error is propagated out
        dw = ERROR_GEN_FAILURE ;
    }

    LeaveMulticast () ;

    return HRESULT_FROM_WIN32 (dw) ;

    /*
    DWORD       dw ;
    int         i ;
    BOOL        t ;
    DWORD       r ;
    SOCKADDR_IN SockAddr ;
    SOCKET      McastSocket ;

    LeaveMulticast () ;
    ASSERT (m_hSocket == INVALID_SOCKET) ;

    r = NOERROR ;

    //  get a synchronous socket
    m_hSocket = WSASocket(
                    AF_INET,
                    SOCK_DGRAM,
                    0,
                    NULL,
                    0,
                    WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF) ;
    if (m_hSocket == INVALID_SOCKET) {
        goto failure ;
    }

    //  make the addr be reuseable
    t = TRUE ;
    i = setsockopt (
            m_hSocket,
            SOL_SOCKET,
            SO_REUSEADDR,
            (char *) & t,
            sizeof t) ;
    if (i == SOCKET_ERROR) {
        goto failure ;
    }

    //  setup for bind
    ZeroMemory (& SockAddr, sizeof SockAddr) ;
    SockAddr.sin_family             = AF_INET ;
    SockAddr.sin_addr.S_un.S_addr   = ulNIC ;           //  NIC & port
    SockAddr.sin_port               = usPort ;

    i = bind(
            m_hSocket,
            (LPSOCKADDR) & SockAddr,
             sizeof SockAddr) ;
    if (i == SOCKET_ERROR) {
        goto failure ;
    }

    //  set the TTL
    i = WSAIoctl (
            m_hSocket,
            SIO_MULTICAST_SCOPE,
            & ulTTL,
            sizeof ulTTL,
            NULL,
            0,
            & dw,
            NULL,
            NULL) ;
    if (i) {
        goto failure ;
    }

    //  setup for multicast join
    ZeroMemory (& SockAddr, sizeof SockAddr) ;
    SockAddr.sin_family             = AF_INET ;
    SockAddr.sin_addr.S_un.S_addr   = ulIP ;            //  IP & port
    SockAddr.sin_port               = usPort ;

    //  join
    McastSocket = WSAJoinLeaf (
                    m_hSocket,
                    (SOCKADDR *) & SockAddr,
                    sizeof SockAddr,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    JL_SENDER_ONLY) ;
    if (McastSocket == INVALID_SOCKET) {
        goto failure ;
    }

    //  connect the socket to the outbound
    i = WSAConnect (
            m_hSocket,
            (SOCKADDR *) & SockAddr,
            sizeof SockAddr,
            NULL,
            NULL,
            NULL,
            NULL
            ) ;
    if (i == SOCKET_ERROR) {
        goto failure ;
    }

    //  counter is set per multicast session
    m_wCounter = (WORD) GetTickCount () ;

    return S_OK ;

    failure :

    dw = WSAGetLastError () ;
    LeaveMulticast () ;

    return HRESULT_FROM_WIN32 (dw) ;
    */
}

HRESULT
CNetSender::LeaveMulticast (
    )
{
    if (m_hSocket != INVALID_SOCKET) {
        closesocket (m_hSocket) ;
        m_hSocket = INVALID_SOCKET ;
    }

    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\precomp.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        precomp.h

    Abstract:


    Notes:

--*/

#include "projpch.h"
#include <commctrl.h>
//#include <ws2tcpip.h>
#include "nutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\ressend.h ===
#define IDS_IPMULTICAST_RECV_CONFIG     1
#define IDD_IPMULTICAST_RECV_CONFIG     101
#define IDC_NIC                         1002
#define IDC_PORT                        1003
#define IDC_IP                          1004
#define IDC_SAVE                        1005
#define IDC_TTL                         1006
#define VERSION_RES_LANGUAGE            0x409
#define VERSION_RES_CHARSET             1252
#define IDS_IPMULTICAST_SEND_CONFIG     2
#define IDD_IPMULTICAST_SEND_CONFIG     102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\propsend.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        propsend.h

    Abstract:


    Notes:

--*/


#ifndef __propsend_h
#define __propsend_h

/*++
    Class Name:

        CNetSendProp

    Abstract:

        This class is used to gather & post data from/to the property page.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        30-Oct-2000      mgates      created

--*/

class CNetSendProp :
    public CBasePropertyPage
{
    HWND                        m_hwnd ;                        //  property page HWND
    IMulticastSenderConfig *    m_pIMulticastSendConfig ;       //  interface pointer
    CNetInterface               m_NIC ;

    //  called when the "save" button is pressed
    HRESULT
    OnSave_ (
        ) ;

    //  refreshes the property page contents with valid properties
    void
    Refresh_ (
        ) ;

    public :

        CNetSendProp (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        BOOL
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

#endif  //  __propsend_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\sender\propsend.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        propsend.cpp

    Abstract:


    Notes:

--*/


#include "precomp.h"
#include "ressend.h"
#include "dsnetifc.h"
#include "propsend.h"
#include "controls.h"
#include "nutil.h"

//  error conditions
static
void
MessageBoxError (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK | MB_ICONEXCLAMATION) ;
}

//  ----------------------------------------------------------------------------

CNetSendProp::CNetSendProp (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage       (
                                 pClassName,
                                 pIUnknown,
                                 IDD_IPMULTICAST_SEND_CONFIG,
                                 IDS_IPMULTICAST_SEND_CONFIG
                                 ),
        m_hwnd                  (NULL),
        m_pIMulticastSendConfig (NULL)
{
    (* pHr) = S_OK ;
}

void
CNetSendProp::Refresh_ (
    )
{
    //  synchronize the display to our config

    CCombobox       NICs    (m_hwnd, IDC_NIC) ;
    CCombobox       Scopes  (m_hwnd, IDC_TTL) ;
    CEditControl    IP      (m_hwnd, IDC_IP) ;
    CEditControl    Port    (m_hwnd, IDC_PORT) ;
    ULONG           ul, ul2 ;
    USHORT          us ;
    HRESULT         hr ;
    int             i, k ;
    WCHAR           wach [32] ;

    //  ------------------------------------------------------------------------
    //  NIC

    hr = m_pIMulticastSendConfig -> GetNetworkInterface (& ul) ;
    if (FAILED (hr)) {
        return ;
    }

    for (i = 0;;i++) {
        k = NICs.GetItemData (& ul2, i) ;
        if (k == CB_ERR) {
            //  should not happen; undefine it
            m_pIMulticastSendConfig -> SetNetworkInterface (UNDEFINED) ;
            for (i = 0;;i++) {
                NICs.GetItemData (& ul2, i) ;
                if (ul2 == UNDEFINED) {
                    NICs.Focus (i) ;
                    break ;
                }
            }

            break ;
        }

        if (ul2 == ul) {
            NICs.Focus (i) ;
            break ;
        }
    }

    //  ------------------------------------------------------------------------
    //  multicast group info

    hr = m_pIMulticastSendConfig -> GetMulticastGroup (& ul, & us) ;
    if (FAILED (hr)) {
        return ;
    }

    if (ul != UNDEFINED) {
        IP.SetTextW (AnsiToUnicode (inet_ntoa (* (struct in_addr *) & ul), wach, 32)) ;
    }
    else {
        IP.SetTextW (UNDEFINED_STR) ;
    }

    us = ntohs (us) ;
    Port.SetTextW (_itow (us, wach, 10)) ;

    //  ------------------------------------------------------------------------
    //  scope
    hr = m_pIMulticastSendConfig -> GetScope (& ul) ;
    if (FAILED (hr)) {
        return ;
    }

    for (i = 0;;i++) {
        k = Scopes.GetItemData (& ul2, i) ;
        if (k == CB_ERR) {
            //  we've either run out, or something it's not one of our
            //   predefined values; insert it and set the focus

            i = Scopes.Append (ul2) ;
            if (i == CB_ERR) {
                //  leave it blank if this failed
                return ;
            }

            Scopes.SetItemData (ul2, i) ;
            Scopes.Focus (i) ;

            break ;
        }

        if (ul2 == ul) {
            //  found the one
            Scopes.Focus (i) ;
            break ;
        }
    }

    return ;
}

HRESULT
CNetSendProp::OnActivate (
    )
{
    CCombobox           NICs    (m_hwnd, IDC_NIC) ;
    CCombobox           Scopes  (m_hwnd, IDC_TTL) ;
    int                 iIndex ;
    INTERFACE_INFO *    pIfc ;
    DWORD               i ;
    WCHAR               wach [32] ;

    //  setup the NICs

    ASSERT (m_NIC.IsInitialized ()) ;

    for (i = 0, pIfc = m_NIC [i] ;
         pIfc ;
         i++, pIfc = m_NIC [i]) {

        if ((pIfc -> iiFlags & IFF_UP) &&
            (pIfc -> iiFlags & IFF_MULTICAST)) {

            iIndex = NICs.AppendW (AnsiToUnicode (inet_ntoa (pIfc -> iiAddress.AddressIn.sin_addr), wach, 32)) ;
            if (iIndex == CB_ERR) {
                return E_FAIL ;
            }

            NICs.SetItemData (* (DWORD *) (& pIfc -> iiAddress.AddressIn.sin_addr), iIndex) ;
        }
    }

    //  wildcard
    iIndex = NICs.AppendW (ANY_IFC) ;
    if (iIndex == CB_ERR) {
        return E_FAIL ;
    }
    NICs.SetItemData (INADDR_ANY, iIndex) ;

    //  undefined
    iIndex = NICs.AppendW (UNDEFINED_STR) ;
    if (iIndex == CB_ERR) {
        return E_FAIL ;
    }
    NICs.SetItemData (UNDEFINED, iIndex) ;

    //  scope
    for (i = 0; i < 6; i++) {
        iIndex = Scopes.Append (1 << i) ;
        if (iIndex == CB_ERR) {
            return E_FAIL ;
        }

        Scopes.SetItemData ((DWORD) (1 << i), iIndex) ;
    }
    Scopes.Focus () ;

    Refresh_ () ;

    return S_OK ;
}

HRESULT
CNetSendProp::OnSave_ (
    )
{
    CCombobox       NICs (m_hwnd, IDC_NIC) ;
    CCombobox       Scopes (m_hwnd, IDC_TTL) ;
    CEditControl    IP (m_hwnd, IDC_IP) ;
    CEditControl    Port (m_hwnd, IDC_PORT) ;
    int             i ;
    ULONG           ulIP ;
    USHORT          usPort ;
    ULONG           ulNIC ;
    ULONG           ulScope ;
    HRESULT         hr ;
    char            ach [32] ;
    WCHAR           wach [32] ;

    if (IP.IsEmpty () ||
        Port.IsEmpty ()) {

        return E_INVALIDARG ;
    }

    //  IP
    IP.GetTextW (wach, 32) ;
    ulIP = inet_addr (UnicodeToAnsi (wach, ach, 32)) ;
    if (ulIP == INADDR_NONE) {
        return E_FAIL ;
    }

    //  port
    Port.GetText (& i) ;
    i &= 0x0000ffff ;
    usPort = htons ((USHORT) i) ;

    //  NIC
    NICs.GetCurrentItemData (& ulNIC) ;

    //  scope
    Scopes.GetCurrentItemData (& ulScope) ;

    hr = m_pIMulticastSendConfig -> SetMulticastGroup (ulIP, usPort) ;
    if (SUCCEEDED (hr)) {
        hr = m_pIMulticastSendConfig -> SetNetworkInterface (ulNIC) ;
        if (SUCCEEDED (hr)) {
            hr = m_pIMulticastSendConfig -> SetScope (ulScope) ;
        }
    }

    return S_OK ;
}

HRESULT
CNetSendProp::OnApplyChanges (
    )
{
    return OnSave_ () ;
}

HRESULT
CNetSendProp::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    HRESULT hr ;

    ASSERT (pIUnknown) ;

    if (!m_NIC.IsInitialized ()) {
        hr = m_NIC.Initialize () ;
        if (FAILED (hr)) {
            return hr ;
        }
    }

    hr = pIUnknown -> QueryInterface (
                            IID_IMulticastSenderConfig,
                            (void **) & m_pIMulticastSendConfig
                            ) ;

    return hr ;
}

HRESULT
CNetSendProp::OnDeactivate (
    )
{
    return S_OK ;
}

HRESULT
CNetSendProp::OnDisconnect (
    )
{
    RELEASE_AND_CLEAR (m_pIMulticastSendConfig) ;
    return S_OK ;
}

BOOL
CNetSendProp::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    HRESULT hr ;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT (m_hwnd == NULL) ;
            m_hwnd = hwnd ;
            return TRUE ;
        }

        case WM_DESTROY :
        {
            m_hwnd = NULL ;
            break ;
        }

        case WM_COMMAND:
        {
            switch (LOWORD (wParam)) {
                case IDC_SAVE :
                    hr = OnSave_ () ;
                    if (FAILED (hr)) {
                        MessageBoxError (TEXT ("Failed to Save"), TEXT ("The returned error code is %08xh"), hr) ;
                    }
                    break ;
            } ;

            return TRUE ;
        }

    }

    return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

CUnknown *
WINAPI
CNetSendProp::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CNetSendProp *  pProp ;

    pProp = new CNetSendProp (
                        NAME ("CNetSendProp"),
                        pIUnknown,
                        CLSID_IPMulticastSendProppage,
                        pHr
                        ) ;

    if (pProp == NULL) {
        (* pHr) = E_OUTOFMEMORY ;
    }

    return pProp ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\util\controls.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        controls.cpp

    Abstract:

        Thin win32 control message wrapper classes.

    Notes:

--*/

#include "projpch.h"
#include <commctrl.h>
#include "controls.h"

/*++
        CControlBase
--*/

CControlBase::CControlBase (
    HWND    hwnd,
    DWORD   id
    )
{
    ASSERT (hwnd) ;

    m_hwnd = GetDlgItem (hwnd, id) ;
    m_id = id ;
}

HWND
CControlBase::GetHwnd (
    )
{
    return m_hwnd ;
}

DWORD
CControlBase::GetId (
    )
{
    return m_id ;
}

/*++
        CEditControl
--*/

CEditControl::CEditControl (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
    ASSERT (hwnd) ;
}

void
CEditControl::SetTextW (
    WCHAR * szText
    )
{
    ASSERT (szText) ;
    SetWindowTextW (GetHwnd (), szText) ;
}

void
CEditControl::SetText (
    INT val
    )
{
    WCHAR achbuffer [32] ;
    SetTextW (_itow (val, achbuffer, 10)) ;
}

int
CEditControl::GetText (
    INT *   val
    )
{
    WCHAR    achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 31)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CEditControl::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    ASSERT (ach) ;
    return GetWindowTextW (GetHwnd (), ach, MaxChars) ;
}

BOOL
CEditControl::IsEmpty (
    )
{
    WCHAR    c [2] ;
    return GetWindowTextW (GetHwnd (), c, 2) == 0 ;
}

int CEditControl::ResetContent ()
{
    return SendMessage (GetHwnd (), WM_CLEAR, 0, 0) ;
}

/*++
        CComboBox
--*/

CCombobox::CCombobox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
}

int
CCombobox::AppendW (
    WCHAR *  sz
    )
{
    return SendMessage (GetHwnd (), CB_ADDSTRING, 0, (LPARAM) sz) ;
}

int
CCombobox::Append (
    INT val
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return AppendW (_itow (val, achbuffer, 10)) ;
}

int
CCombobox::InsertW (
    WCHAR * sz,
    int     index)
{
    return SendMessage (GetHwnd (), CB_INSERTSTRING, (WPARAM) index, (LPARAM) sz) ;
}

int
CCombobox::Insert (
    INT val,
    int index
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return InsertW (_itow (val, achbuffer, 10), index) ;
}


int
CCombobox::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    int index ;
    int count ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        //  might be that it's not a dropdown list - in which case we get;
        //  try to get just the edit control's text; if that fails, return
        //  a failure, otherwise we're ok
        count = GetWindowTextW (GetHwnd (), ach, MaxChars) ;
        if (count == 0) {
            return CB_ERR ;
        }

        return count ;
    }

    if (SendMessage (GetHwnd (), CB_GETLBTEXTLEN, (WPARAM) index, 0) + 1 > MaxChars) {
        return CB_ERR ;
    }

    return SendMessage (GetHwnd (), CB_GETLBTEXT, (WPARAM) index, (LPARAM) ach) ;
}

int
CCombobox::GetText (
    int * val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 32)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}


int
CCombobox::Focus (
    int index
    )
{
    return SendMessage (GetHwnd (), CB_SETCURSEL, (WPARAM) index, 0) ;
}

int
CCombobox::ResetContent (
    )
{
    return SendMessage (GetHwnd (), CB_RESETCONTENT, 0, 0) ;
}

int
CCombobox::SetItemData (
    DWORD   val,
    int     index
    )
{
    return SendMessage (GetHwnd (), CB_SETITEMDATA, (WPARAM) index, (LPARAM) val) ;
}

int
CCombobox::GetCurrentItemIndex (
    )
{
    return SendMessage (GetHwnd (), CB_GETCURSEL, 0, 0) ;
}

int
CCombobox::GetItemData (
    DWORD * pval,
    int     index
    )
{
    int i ;

    ASSERT (pval) ;

    i = SendMessage (GetHwnd (), CB_GETITEMDATA, (WPARAM) index, 0) ;
    if (i == CB_ERR) {
        return CB_ERR ;
    }

    * pval = i ;
    return i ;
}

int
CCombobox::GetCurrentItemData (
    DWORD * pval
    )
{
    int index ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        return CB_ERR ;
    }

    return GetItemData (pval, index) ;
}

int
CCombobox::FindW (
    WCHAR * sz
    )
{
    ASSERT (sz) ;
    return SendMessageW (GetHwnd (), CB_FINDSTRING, (WPARAM) -1, (LPARAM) sz) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dvrapp\controls.h ===
#ifndef __uictrl_h
#define __uictrl_h

class CControlBase ;
class CEditControl ;
class CCombobox ;
class CListview ;
class CTrackbar ;

class CControlBase
{
    protected :

        HWND    m_hwnd ;
        DWORD   m_id ;

        //  include this only if we're ansi
#ifndef UNICODE     //  -------------------------------------------------------

        enum {
            MAX_STRING = 128        //  128 = max PIN_INFO.achName length
        } ;

        char    m_achBuffer [MAX_STRING] ;
        char *  m_pchScratch ;
        int     m_pchScratchMaxString ;

        char *
        GetScratch_ (
            IN OUT  int * pLen
            )
        /*++
            Fetches a scratch buffer.

            pLen
                IN      char count requested
                OUT     char count obtained
        --*/
        {
            //  the easy case
            if (* pLen <= m_pchScratchMaxString) {
                return m_pchScratch ;
            }
            //  a longer string than is currently available is requested
            else {
                assert (* pLen > MAX_STRING) ;

                //  first free up m_pchScratch if it points to a
                //  heap-allocated memory
                if (m_pchScratch != & m_achBuffer [0]) {
                    assert (m_pchScratch != NULL) ;
                    delete m_pchScratch ;
                }

                //  allocate
                m_pchScratch = new char [* pLen] ;

                //  if the above call failed, we failover to the stack-
                //  allocated buffer
                if (m_pchScratch == NULL) {
                    m_pchScratch = & m_achBuffer [0] ;
                    * pLen = MAX_STRING ;
                }

                assert (m_pchScratch != NULL) ;
                assert (* pLen >= MAX_STRING) ;

                return m_pchScratch ;
            }
        }

#endif  //  UNICODE  ----------------------------------------------------------

        //  called when converting to UI char set
        TCHAR *
        ConvertToUIString_ (
            IN  WCHAR * sz
            ) ;

        //  called to obtain a UI-compatible buffer of the specified length
        TCHAR *
        GetUICompatibleBuffer_ (
            IN  WCHAR *     sz,
            IN OUT int *    pLen
            ) ;

        //  called with a UI-filled buffer; ensures that szUnicode has what sz
        //  points to; obtain sz via GetUICompatibleBuffer_
        WCHAR *
        ConvertToUnicodeString_ (
            IN  TCHAR * sz,             //  buffer to convert; null-terminated
            IN  WCHAR * szUnicode,      //  requested buffer
            IN  int     MaxLen          //  max length of szUnicode buffer
            ) ;

    public :

        CControlBase (
            HWND    hwnd,
            DWORD   id
            ) ;

#ifndef UNICODE
        CControlBase::~CControlBase (
            )
        {
            //  if m_pchScratch points to heap-allocated memory, free it now
            if (m_pchScratch != & m_achBuffer [0]) {
                assert (m_pchScratch != NULL) ;
                delete m_pchScratch ;
            }
        }
#endif  //  UNICODE

        HWND
        GetHwnd (
            ) ;

        DWORD
        GetId (
            ) ;

        virtual
        int
        ResetContent (
            ) { return 1 ; }
} ;

class CListbox :
    public CControlBase
{
    public :

        CListbox (
            HWND    hwnd,
            DWORD   id
            ) ;

        int
        AppendW (
            WCHAR *
            ) ;

        void
        ShowItem (
            int iRow
            ) ;

        int
        ResetContent (
            ) ;
} ;

class CEditControl :
    public CControlBase
{
    public :

        CEditControl (
            HWND    hwnd,
            DWORD   id
            ) ;

        void
        SetTextW (
            WCHAR *
            ) ;

        void
        SetTextW (
            INT val
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        GetTextW (
            INT *   val
            ) ;

        int
        ResetContent (
            ) ;
} ;

class CCombobox :
    public CControlBase
{
    public :

        CCombobox (
            HWND    hwnd,
            DWORD   id) ;

        int
        AppendW (
            WCHAR *
            ) ;

        int
        AppendW (
            INT val
            ) ;

        int
        InsertW (
            WCHAR *,
            int index = 0
            ) ;

        int
        InsertW (
            INT val,
            int index = 0
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        GetTextW (
            int *
            ) ;

        int
        ResetContent (
            ) ;

        int
        Focus (
            int index = 0
            ) ;

        int
        SetItemData (
            DWORD val,
            int index
            ) ;

        int
        GetCurrentItemData (
            DWORD *
            ) ;

        int
        GetItemData (
            DWORD *,
            int index
            ) ;

        int
        GetCurrentItemIndex (
            ) ;

        int
        FindW (
            WCHAR *
            ) ;
} ;

class CListview :
    public CControlBase
{
    int m_cColumns ;

    HIMAGELIST
    SetImageList_ (
        HIMAGELIST,
        int
        ) ;

    public :

        CListview (
            HWND hwnd,
            DWORD id
            ) ;

        int
        ResetContent (
            ) ;

        HIMAGELIST
        SetImageList_SmallIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_NormalIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_State (
            HIMAGELIST
            ) ;

        int
        GetItemCount (
            ) ;

        BOOL
        SetState (
            int Index,      //  1-based; if 0, clears
            int Row
            ) ;

        int
        InsertColumnW (
            WCHAR *,
            int ColumnWidth,
            int iCol = 0
            ) ;

        int
        InsertRowIcon (
            int
            ) ;

        int
        InsertRowTextW (
            WCHAR *,
            int iCol = 0
            ) ;

        //  inserts a row, but converts the number to a string first
        int
        InsertRowNumber (
            int i,
            int iCol = 1
            ) ;

        int
        InsertRowValue (
            DWORD
            ) ;

        BOOL
        DeleteRow (
            int
            ) ;

        BOOL
        SetData (
            DWORD dwData,
            int iRow
            ) ;

        BOOL
        SetTextW (
            WCHAR *,
            int iRow,
            int iCol
            ) ;

        int
        GetSelectedCount (
            ) ;

        int
        GetSelectedRow (
            int iStartRow = -1
            ) ;

        DWORD
        GetData (
            int iRow
            ) ;

        DWORD
        GetData (
            ) ;

        DWORD
        GetRowTextW (
            IN  int iRow,
            IN  int iCol,       //  0-based
            IN  int cMax,
            OUT WCHAR *
            ) ;
} ;

class CTrackbar :
    public CControlBase
{
    public :

        CTrackbar (
            HWND hwnd,
            DWORD id
            ) ;

        //  sets min/max
        void
        SetRange (
            IN  long    lLow,
            IN  long    lHigh
            ) ;

        void
        GetRange (
            OUT long *  plLow,
            OUT long *  plHigh
            ) ;

        //  "filler" bar - lMax must be <= max SetRange (min,max)
        void
        SetAvailable (
            IN  long    lMin,
            IN  long    lMax
            ) ;

        //  moves the selector
        void
        SetSelector (
            IN  long    lPos
            ) ;

        void
        SetSelectorToMax (
            ) ;

        void
        SetSelPositionRatio (
            double  d           //   [0,1]
            ) ;

        long
        GetSelPositionValue (
            ) ;

        double
        GetSelPositionRatio (
            ) ;
} ;

class CProgressInd :
    public CControlBase
{
    public :

        CProgressInd (
            HWND hwnd,
            DWORD id
            ) ;

        void
        SetRange (
            IN  long    lLow,
            IN  long    lHigh
            ) ;

        void
        SetPosition (
            IN  long    lPos
            ) ;
} ;

#endif  // __uictrl_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dvrapp\main.cpp ===
#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "dvrds.h"
#include "main.h"
#include "controls.h"

#define DVRAPP_REG_ROOT                     __T("SOFTWARE\\Microsoft\\dvrapp")
#define DVRAPP_REG_CAPTURE_GRAPHS           __T("CaptureGraphs")
#define DVRAPP_REG_SEEK_TO_LIVE_ON_START    __T("SeekToLiveOnStart")

#define MAX_REG_VAL                     16
#define TIMER_MILLIS                    1000
#define NOTIFY_ON                       0x00000000
#define NOTIFY_OFF                      0x00000001

#define UNDEFINED                       -1

//  forward decl
class CFilterGraphContext ;
class CBroadcastViewContext ;
class CRecordingContext ;

//  prototypes
static  void Initialize (HINSTANCE hInstance, int nCmdShow) ;
static  void Uninitialize () ;
static  void MessageLoop () ;
static  void InitializeDialog (DWORD   idd,HWND    hwnd,WPARAM  wparam) ;
static  BOOL CALLBACK Main_DialogProc (HWND window, UINT message, WPARAM wparam, LPARAM lparam) ;
static  void MessageBoxError (CHAR * title, CHAR * szfmt, ...) ;
static  void MessageBoxMsg (CHAR * title, CHAR * szfmt, ...) ;
static  BOOL RegistryInitialize () ;
static  void RestoreFilterGraphs () ;
static  BOOL AddEachFilterGraph (IN WCHAR *) ;
static  void SaveFilterGraphInRegistry (IN WCHAR *) ;
static  HMENU DisplayPopupMenu (IN int, IN HANDLE) ;
static  void OnDeleteFilterGraph () ;
static  void OnAddFilterGraph () ;
static  void ReleaseAllFilterGraphs () ;
static  void ReleaseAllrecordings () ;
static  void OnFilterGraphClick (IN int) ;
static  void CALLBACK TimerCallback (IN HWND,IN UINT,IN UINT_PTR,IN DWORD) ;
static  void PeriodicFilterGraphStateSync () ;
static  void OnFilterGraphCommand (IN WORD) ;
static  void ProcessEvent (IN CFilterGraphContext *, IN LONG, IN LONG, IN LONG) ;
static  void StopAndDrainAllEvents (IN CFilterGraphContext *) ;
static  void OnCreateBroadcastViewer () ;
static  void OnCreateRecording () ;
static  CFilterGraphContext * CreateEmptyFilterGraph () ;
static  IUnknown * FindFilter (IN  CFilterGraphContext *, IN  REFIID) ;
static  HRESULT RenderAllPins (IN  CFilterGraphContext *, IN  IBaseFilter *) ;
static  CFilterGraphContext * CreateViewerGraph (IN  IDVRStreamSink *) ;
static  BOOL CALLBACK BroadcastView_DialogProc (HWND window, UINT message, WPARAM wparam, LPARAM lparam) ;
static  CBroadcastViewContext * BroadcastViewContext (IN  HWND) ;
static  HRESULT InitBroadcastViewDialog (IN  HWND, IN  LPARAM) ;
static  void ShowHideBroadcastView (IN  HWND, IN  CBroadcastViewContext *, IN WORD) ;
static  void BroadcastViewGraphTransition (IN  HWND, IN  WORD, IN  CBroadcastViewContext *) ;
        void CALLBACK UpdateBroadcastView (HWND, UINT, UINT, DWORD) ;
static  void OnSeek (IN  HWND) ;
static  void SeekToLive (IN  HWND) ;
static  long DShowTimeToSeekBarTime (IN  REFERENCE_TIME) ;
static  REFERENCE_TIME SeekBarTimeToDShowTime (IN  long) ;
static  REFERENCE_TIME SecondsToDShow (IN long) ;
static  long DShowToSeconds (IN REFERENCE_TIME) ;
static  long DShowToMillis (IN  REFERENCE_TIME) ;
static  BOOL CALLBACK CreateRecording_DialogProc (IN  HWND, IN  UINT, IN  WPARAM, IN  LPARAM) ;
static  CRecordingContext * RecordingContext (IN  HWND) ;
static  HRESULT InitCreateRecordingDialog (IN  HWND, IN  LPARAM) ;
static  void UninitCreateRecordingDialog (IN  HWND) ;
void    CALLBACK UpdateRecordableSlider (HWND, UINT, UINT, DWORD) ;
static  HRESULT AddGraphToRot (IUnknown *, DWORD *) ;
static  void RemoveGraphFromRot (DWORD ) ;
static  void DShowToHMS (IN TCHAR *,IN long, IN REFERENCE_TIME) ;
static  void MillisToHMS (IN TCHAR *,IN long, IN int) ;

//  variables
static  HWND                g_MainWindow ;
        HINSTANCE           g_hInstance ;
static  HMENU               g_menuBar ;
static  HMENU               g_menuCaptureGraphs ;
static  HMENU               g_menuRecordings ;
static  HMENU               g_menuCreate ;
static  CListview *         g_pCaptureGraphs ;
static  CListview *         g_pRecordings ;
static  OPENFILENAME        g_ofn ;
static  HWND                g_hwndMessageBar ;
static  HKEY                g_hkeyRoot ;
static  HKEY                g_hkeyFilterGraphs ;
static  UINT_PTR            g_uiptrTimer ;
static  BOOL                g_fSeekToLiveOnStart ;

//  ---------------------------------------------------------------------------
//  ---------------------------------------------------------------------------

//  hideous hack: this enum must be kept in sync with FILTER_STATE's values
enum {
    STATE_STOPPED,              //  == State_Stopped
    STATE_PAUSED,               //  == State_Paused
    STATE_RUNNING,              //  == State_Running
    STATE_INDETERMINATE
} ;

//  ---------------------------------------------------------------------------
//  ---------------------------------------------------------------------------

class CFilterGraphContext
{
    IFilterGraph *      m_pIFilterGraph ;
    IMediaControl *     m_pIMediaControl ;
    IMediaEventEx *     m_pIMediaEventEx ;
    IGraphBuilder *     m_pIGraphBuilder ;
    IReferenceClock *   m_pIRefClock ;
    DWORD               m_dwFilterGraphState ;
    LONG                m_lRef ;
    DWORD               m_dwStartRunTickCount ;
    REFERENCE_TIME      m_rtStart ;
    DWORD               m_dwRotContext ;

    HRESULT
    StartClock_ (
        )
    {
        HRESULT         hr ;
        IMediaFilter *  pIMediaFilter ;

        if (!m_pIRefClock) {
            hr = m_pIFilterGraph -> QueryInterface (IID_IMediaFilter, (void **) & pIMediaFilter) ;
            if (SUCCEEDED (hr)) {
                hr = pIMediaFilter -> GetSyncSource (& m_pIRefClock) ;
                pIMediaFilter -> Release () ;

                if (SUCCEEDED (hr)) {
                    ASSERT (m_pIRefClock) ;
                    hr = m_pIRefClock -> GetTime (& m_rtStart) ;
                    m_dwStartRunTickCount = GetTickCount () ;
                }
            }
        }
        else {
            hr = S_OK ;
        }

        if (FAILED (hr)) {
            StopClock_ () ;
        }

        return hr ;
    }

    HRESULT
    StopClock_ (
        )
    {
        RELEASE_AND_CLEAR (m_pIRefClock) ;
        m_dwStartRunTickCount = UNDEFINED ;

        return S_OK ;
    }

    public :

        CFilterGraphContext (
            IN  IFilterGraph *  pinIFilterGraph,
            IN  IMediaControl * pinIMediaControl,
            IN  IMediaEventEx * pinIMediaEventEx,
            IN  IGraphBuilder * pinIGraphBuilder
            ) : m_pIFilterGraph         (pinIFilterGraph),
                m_pIMediaControl        (pinIMediaControl),
                m_pIMediaEventEx        (pinIMediaEventEx),
                m_pIGraphBuilder        (pinIGraphBuilder),
                m_pIRefClock            (NULL),
                m_lRef                  (1),
                m_dwStartRunTickCount   (UNDEFINED)
        {
            assert (m_pIFilterGraph) ;
            assert (m_pIMediaControl) ;
            assert (m_pIMediaEventEx) ;
            assert (m_pIGraphBuilder) ;

            m_pIFilterGraph -> AddRef () ;
            m_pIMediaControl -> AddRef () ;
            m_pIMediaEventEx -> AddRef () ;
            m_pIGraphBuilder -> AddRef () ;

            ::AddGraphToRot (m_pIFilterGraph, & m_dwRotContext) ;
        }

        ~CFilterGraphContext (
            )
        {
            ::RemoveGraphFromRot (m_dwRotContext) ;

            RELEASE_AND_CLEAR (m_pIFilterGraph) ;
            RELEASE_AND_CLEAR (m_pIMediaControl) ;
            RELEASE_AND_CLEAR (m_pIMediaEventEx) ;
            RELEASE_AND_CLEAR (m_pIGraphBuilder) ;
            RELEASE_AND_CLEAR (m_pIRefClock) ;
        }

        IFilterGraph *  FilterGraph ()                  { return m_pIFilterGraph ; }
        IMediaControl * MediaControl ()                 { return m_pIMediaControl ; }
        IMediaEventEx * MediaEventEx ()                 { return m_pIMediaEventEx ; }
        IGraphBuilder * GraphBuilder ()                 { return m_pIGraphBuilder ; }
        DWORD           FilterGraphState ()             { return m_dwFilterGraphState ; }
        void            SetFilterGraphState (DWORD dw)  { m_dwFilterGraphState = dw ; }

        DWORD           MillisRunning ()                { return (m_dwStartRunTickCount != UNDEFINED ? GetTickCount () - m_dwStartRunTickCount : 0) ; }

        REFERENCE_TIME  GraphClockTimeRunning ()
        {
            REFERENCE_TIME  rt ;
            HRESULT         hr ;

            if (m_pIRefClock) {
                hr = m_pIRefClock -> GetTime (& rt) ;
                if (SUCCEEDED (hr)) {
                    rt -= m_rtStart ;
                }
                else {
                    rt = 0 ;
                }
            }
            else {
                rt = 0 ;
            }

            return rt ;
        }

        HRESULT Pause ()
        {
            HRESULT         hr ;

            hr = m_pIMediaControl -> Pause () ;
            if (SUCCEEDED (hr)) {
                //  doesn't restart if already started
                hr = StartClock_ () ;
            }

            return hr ;
        }

        HRESULT Run ()
        {
            HRESULT hr ;

            hr = m_pIMediaControl -> Run () ;
            if (SUCCEEDED (hr)) {
                //  doesn't restart if already started
                hr = StartClock_ () ;
            }

            return hr ;
        }

        HRESULT Stop ()
        {
            HRESULT hr ;

            hr = m_pIMediaControl -> Stop () ;
            if (SUCCEEDED (hr)) {
                hr = StopClock_ () ;
            }

            return hr ;
        }

        ULONG
        AddRef (
            )
        {
            return InterlockedIncrement (& m_lRef) ;
        }

        ULONG
        Release (
            )
        {
            if (InterlockedDecrement (& m_lRef) == 0) {
                delete this ;
                return 0 ;
            }

            return m_lRef ;
        }
} ;

class CBroadcastViewContext
{
    CFilterGraphContext *   m_pFilterGraphContext ;
    IMediaSeeking *         m_pIMediaSeeking ;
    IVideoFrameStep *       m_pIVideoFrameStep ;
    BOOL                    m_fIsStopped ;

    public :

        CBroadcastViewContext (
            CFilterGraphContext *   pFilterGraphContext
            ) : m_pFilterGraphContext   (pFilterGraphContext),
                m_pIMediaSeeking        (NULL),
                m_pIVideoFrameStep      (NULL),
                m_fIsStopped            (TRUE)
        {
            assert (m_pFilterGraphContext) ;
            m_pFilterGraphContext -> AddRef () ;
        }

        ~CBroadcastViewContext (
            )
        {
            m_pFilterGraphContext -> Release () ;
            RELEASE_AND_CLEAR (m_pIMediaSeeking) ;
            RELEASE_AND_CLEAR (m_pIVideoFrameStep) ;
        }

        CFilterGraphContext *   FilterGraphContext ()   { return m_pFilterGraphContext ; }
        IMediaSeeking *         IMediaSeeking ()        { return m_pIMediaSeeking ; }

        HRESULT Pause ()        { m_fIsStopped = FALSE ; return m_pFilterGraphContext -> Pause () ; }
        HRESULT Run ()          { m_fIsStopped = FALSE ; return m_pFilterGraphContext -> Run () ;   }
        HRESULT Stop ()         { m_fIsStopped = TRUE  ; return m_pFilterGraphContext -> Stop () ;  }
        BOOL    IsStopped ()    { return m_fIsStopped ; }

        HRESULT GetCurrentDuration (REFERENCE_TIME * prt)    { return m_pIMediaSeeking -> GetDuration (prt) ; }
        HRESULT GetCurrentPosition (REFERENCE_TIME * prt)    { return m_pIMediaSeeking -> GetCurrentPosition (prt) ; }
        HRESULT GetAvailable (REFERENCE_TIME * prtMin, REFERENCE_TIME * prtMax)
        {
            HRESULT         hr ;
            REFERENCE_TIME  rtDur ;

            hr = m_pIMediaSeeking -> GetAvailable (prtMin, prtMax) ;
            if (SUCCEEDED (hr)) {
                hr = m_pIMediaSeeking -> GetDuration (& rtDur) ;
                if (SUCCEEDED (hr)) {
                    //  IMediaSeeking quirk necessitates this
                    (* prtMax) = (* prtMin) + rtDur ;
                }
            }

            return hr ;
        }

        BOOL CanFrameStep ()                { return (m_pIVideoFrameStep ? TRUE : FALSE) ; }
        BOOL CanFrameStepMultiple ()        { return (m_pIVideoFrameStep -> CanStep (2, NULL) == S_OK ? TRUE : FALSE) ; }
        HRESULT Step (IN DWORD dwFrames)    { return m_pIVideoFrameStep -> Step (dwFrames, NULL) ; }
        void CancelStep ()                  { if (m_pIVideoFrameStep) { m_pIVideoFrameStep -> CancelStep () ; } }

        HRESULT SeekRestart (REFERENCE_TIME * prt)
        {
            return m_pIMediaSeeking -> SetPositions (prt, AM_SEEKING_AbsolutePositioning, NULL, AM_SEEKING_NoPositioning) ;
        }

        OAFilterState GraphState ()  { OAFilterState s ; HRESULT hr = m_pFilterGraphContext -> MediaControl () -> GetState (0, & s) ; return s ; }

        HRESULT Init ()
        {
            HRESULT hr ;

            hr = m_pFilterGraphContext -> FilterGraph () -> QueryInterface (IID_IMediaSeeking, (void **) & m_pIMediaSeeking) ;
            if (FAILED (hr)) { goto cleanup ; }

            hr = m_pFilterGraphContext -> FilterGraph () -> QueryInterface (IID_IVideoFrameStep, (void **) & m_pIVideoFrameStep) ;
            if (FAILED (hr)) { goto cleanup ; }

            cleanup :

            return hr ;
        }
} ;

class CRecordingContext
{
    CFilterGraphContext *   m_pFilterGraphContext ;
    REFERENCE_TIME          m_rtStart ;
    REFERENCE_TIME          m_rtStop ;

    public :

        CRecordingContext (
        CFilterGraphContext *   pFilterGraphContext
            ) : m_pFilterGraphContext   (pFilterGraphContext),
                m_rtStart               (UNDEFINED),
                m_rtStop                (UNDEFINED) {}

        CFilterGraphContext *   FiltergraphContext ()   { return m_pFilterGraphContext ; }

        //HRESULT         SetStart (IN REFERENCE_TIME rt)     { m_rtStart = rt ; return S_OK ; }
        //REFERENCE_TIME  GetStart
        //HRESULT SetStop (IN REFERENCE_TIME rt)      { m_rtStop = rt ; return S_OK ; }
} ;

//  file open filter
TCHAR g_FileOpenFilter [] = {
    __T("Filter Graphs (*.grf)\0*.grf") __T("\0")
} ;

typedef
struct {
    WCHAR * title ;
    DWORD   width ;
} COL_DETAIL ;

#define LV_COL(title, width)  { L#title, width }

//  ---------------------------------------------------------------------------
//  enumerates our filter graph columns

static
enum {
    FG_PATH,
    FG_RUN_DURATION,

    //  -----------------------------------
    FG_COL_COUNT,           //  always last
} ;

static
COL_DETAIL
g_FilterGraphsColumns [] = {
    LV_COL (Path,       200),
    LV_COL (Duration,   100)
} ;

//  ---------------------------------------------------------------------------
//  enumerates our recordings columns

static
enum {
    R_NAME,
    R_START,
    R_STOP,

    //  -----------------------------------
    R_COL_COUNT             //  always last
} ;

static
COL_DETAIL
g_recordingsColumns [] = {
    LV_COL (Recording,      100),
    LV_COL (Start,          60),
    LV_COL (Stop,           60),
} ;

#define FIND_FILTER(pf, ifc)   (reinterpret_cast <ifc *> (FindFilter (pf, IID_ ## ifc)))

//  implementation

extern
"C"
int
WINAPI
_tWinMain (
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    int         nCmdShow
    )
{
    Initialize (hInstance, nCmdShow) ;
    MessageLoop () ;
    Uninitialize () ;

    return 0 ;
}

static
void
Initialize (
    HINSTANCE   hInstance,
    int         nCmdShow
    )
{
    INITCOMMONCONTROLSEX    ctrls = {0} ;
    HRESULT hr ;
    BOOL                    r ;

    assert (hInstance) ;

    g_hInstance = hInstance ;

    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED) ;
    GOTO_NE (hr, S_OK, error) ;

    ctrls.dwSize = sizeof ctrls ;
    ctrls.dwICC = ICC_PROGRESS_CLASS;

    r = InitCommonControlsEx (& ctrls) ;
    GOTO_NE (r, TRUE, error) ;

    g_MainWindow = CreateDialogParam (g_hInstance, MAKEINTRESOURCE (IDD_MAIN), NULL, Main_DialogProc, 0) ;
    GOTO_EQ (g_MainWindow, NULL, error) ;

    InitializeDialog (IDD_MAIN, g_MainWindow, 0) ;

    g_ofn.lStructSize       = sizeof g_ofn ;
    g_ofn.hInstance         = g_hInstance ;
    g_ofn.lpstrFilter       = g_FileOpenFilter ;
    g_ofn.lpstrTitle        = __T("open filter") ;
    g_ofn.nMaxFile          = MAX_PATH ;
    g_ofn.nMaxFileTitle     = MAX_PATH ;
    g_ofn.Flags             = OFN_FILEMUSTEXIST | OFN_EXPLORER ;
    g_ofn.hwndOwner         = g_MainWindow ;

    g_hwndMessageBar = GetDlgItem (g_MainWindow, IDC_MESSAGE_BAR) ;

    ShowWindow (g_MainWindow, TRUE) ;

    r = RegistryInitialize () ;
    GOTO_NE (r, TRUE, error) ;

    g_uiptrTimer = SetTimer (
                        g_MainWindow,
                        NULL,
                        TIMER_MILLIS,
                        TimerCallback
                        ) ;
    GOTO_EQ (g_uiptrTimer, 0, error) ;

    return ;

    error :

    DWORD dw = GetLastError () ;

    ExitProcess (EXIT_FAILURE) ;
}

static
void
Uninitialize (
    )
{
    CLOSE_RESET_REG_KEY (g_hkeyRoot) ;
    CLOSE_RESET_REG_KEY (g_hkeyFilterGraphs) ;

    CoUninitialize () ;
}

static
CFilterGraphContext *
GetFilterGraphContext (
    IN  CListview * pfg,
    IN  int         row
    )
{
    return reinterpret_cast <CFilterGraphContext *> (pfg -> GetData (row)) ;
}

static
long
DShowTimeToSeekBarTime (
    IN  REFERENCE_TIME  rt
    )
{
    return (long) (rt / 1000000) ;
}

static
REFERENCE_TIME
SeekBarTimeToDShowTime (
    IN  long    l
    )
{
    return (l * 1000000) ;
}

static
REFERENCE_TIME
SecondsToDShow (
    IN long l
    )
{
    REFERENCE_TIME  rt ;

    rt = l ;
    return rt * 10000000 ;
}

static
long
DShowToMillis (
    IN  REFERENCE_TIME  rt
    )
{
    long    l ;

    l = (long) (rt / 10000) ;
    return l ;
}

static
long
DShowToSeconds (
    IN REFERENCE_TIME   rt
    )
{
    long    l ;

    l = DShowToMillis (rt) ;
    l /= 1000 ;

    return l ;
}

static
void
DShowToHMS (
    IN  TCHAR *         ach,
    IN  long            lBufferLen,
    IN  REFERENCE_TIME  rtTime
    )
{
    int iMillis ;
    int iSeconds ;
    int iMinutes ;
    int iHours ;
    int iBytes ;

    iMillis    = DShowToMillis (rtTime) ;
    iSeconds   = iMillis / 1000 ; iMillis -= (iSeconds * 1000) ;
    iMinutes   = iSeconds / 60 ;  iSeconds -= (iMinutes * 60) ;
    iHours     = iMinutes / 60 ;  iMinutes -= (iHours * 60) ;

    iBytes = _sntprintf (ach, lBufferLen, __T("%02d:%02d:%02d:%03d"), iHours, iMinutes, iSeconds, iMillis) ;
    if (iBytes < 0) {
        ach [0] = __T('\0') ;
    }
}

static
void
MillisToHMS (
    IN TCHAR *  ach,
    IN long     lBufferLen,
    IN int      iMillis
    )
{
    int iSeconds ;
    int iMinutes ;
    int iHours ;
    int iBytes ;

    iSeconds   = iMillis / 1000 ; iMillis -= (iSeconds * 1000) ;
    iMinutes   = iSeconds / 60 ;  iSeconds -= (iMinutes * 60) ;
    iHours     = iMinutes / 60 ;  iMinutes -= (iHours * 60) ;

    iBytes = _sntprintf (ach, lBufferLen, __T("%02d:%02d:%02d:%03d"), iHours, iMinutes, iSeconds, iMillis) ;
    if (iBytes < 0) {
        ach [0] = __T('\0') ;
    }
}

static
void
DisplayCapGraphState (
    IN  CListview * pfg,
    IN  int         row,
    IN  DWORD       state
    )
{
    pfg -> SetState (state == STATE_RUNNING ? STATE_ACTIVE : STATE_INACTIVE, row) ;
}

static
void
SetCapGraphState (
    IN  CListview * pfg,
    IN  int         row,
    IN  DWORD       state
    )
{
    GetFilterGraphContext (pfg, row) -> SetFilterGraphState (state) ;
    DisplayCapGraphState (pfg, row, state) ;
}

static
HRESULT
AddGraphToRot(
    IUnknown *pUnkGraph,
    DWORD *pdwRegister
    )
{
    IMoniker * pMoniker;
    IRunningObjectTable *pROT;
    WCHAR wsz[128];
    HRESULT hr;

    if (FAILED(GetRunningObjectTable(0, &pROT))) {
        return E_FAIL;
    }

    wsprintfW(wsz, L"FilterGraph %08x pid %08x", (DWORD_PTR)pUnkGraph,
              GetCurrentProcessId());

    hr = CreateItemMoniker(L"!", wsz, &pMoniker);
    if (SUCCEEDED(hr)) {
        hr = pROT->Register(0, pUnkGraph, pMoniker, pdwRegister);
        pMoniker->Release();
    }
    pROT->Release();
    return hr;
}

static
void
RemoveGraphFromRot(
    DWORD pdwRegister
    )
{
    IRunningObjectTable *pROT;

    if (SUCCEEDED(GetRunningObjectTable(0, &pROT))) {
        pROT->Revoke(pdwRegister);
        pROT->Release();
    }
}

static
void
PeriodicFilterGraphStateSync (
    )
{
    CFilterGraphContext *   pFilterGraphContext ;
    int                     row ;
    int                     cFilterGraphs ;
    OAFilterState           fs ;
    HRESULT                 hr ;
    DWORD                   dwTicksNow ;
    TCHAR                   ach [128] ;

    //  all the same thread, so there's no need to do any thread sync stuff here

    dwTicksNow = GetTickCount () ;

    cFilterGraphs = g_pCaptureGraphs -> GetItemCount () ;
    for (row = 0; row < cFilterGraphs; row++) {

        pFilterGraphContext = GetFilterGraphContext (g_pCaptureGraphs, row) ;

        hr = pFilterGraphContext -> MediaControl () -> GetState (0, & fs) ;
        if (SUCCEEDED (hr)) {

            //  if the state has stopped set it here ..
            if (pFilterGraphContext -> FilterGraphState () == STATE_STOPPED &&
                (DWORD) fs != pFilterGraphContext -> FilterGraphState ()) {

                SetCapGraphState (g_pCaptureGraphs, row, pFilterGraphContext -> FilterGraphState ()) ;
                hr = pFilterGraphContext -> MediaControl () -> Stop () ;
            }
            //  otherwise, the filter graph dictates ..
            else if ((DWORD) fs != pFilterGraphContext -> FilterGraphState ()) {

                SetCapGraphState (g_pCaptureGraphs, row, fs) ;
            }
        }
        else {
            //  not really sure ..
            SetCapGraphState (g_pCaptureGraphs, row, STATE_INDETERMINATE) ;
        }

        //MillisToHMS (ach, 128, pFilterGraphContext -> MillisRunning ()) ;
        //g_pCaptureGraphs -> SetTextW (ach, row, FG_RUN_DURATION) ;

        DShowToHMS (ach, 128, pFilterGraphContext -> GraphClockTimeRunning ()) ;
        g_pCaptureGraphs -> SetTextW (ach, row, FG_RUN_DURATION) ;
    }
}

static
void
CALLBACK
TimerCallback (
    IN  HWND        window,
    IN  UINT        uiMsg,
    IN  UINT_PTR    uiptrTimer,
    IN  DWORD       dwSystemTime
    )
{
    PeriodicFilterGraphStateSync () ;
}

static
BOOL
RegistryInitialize (
    )
{
    LONG    l ;
    DWORD   dw ;
    BOOL    r ;

    g_hkeyRoot = NULL ;
    g_hkeyFilterGraphs = NULL ;

    l = RegCreateKeyEx (
                    HKEY_CURRENT_USER,
                    DVRAPP_REG_ROOT,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    & g_hkeyRoot,
                    & dw
                    ) ;
    if (l == ERROR_SUCCESS) {
        assert (g_hkeyRoot != NULL) ;

        l = RegCreateKeyEx (g_hkeyRoot,
                            DVRAPP_REG_CAPTURE_GRAPHS,
                            NULL,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            & g_hkeyFilterGraphs,
                            & dw
                            ) ;

        if (l == ERROR_SUCCESS) {
            RestoreFilterGraphs () ;

            g_fSeekToLiveOnStart = TRUE ;
            dw = g_fSeekToLiveOnStart ;     //  default
            r = GetRegDWORDValIfExist (g_hkeyRoot, DVRAPP_REG_SEEK_TO_LIVE_ON_START, & dw) ;
            if (r) {
                g_fSeekToLiveOnStart = (dw != 0) ;
            }
        }
    }

    return l == ERROR_SUCCESS ;
}

static
void
RestoreFilterGraphs (
    )
{
    LONG    l ;
    TCHAR   szFilterGraph [MAX_PATH] ;
    WCHAR   szwFilterGraph [MAX_PATH] ;
    TCHAR   szValName [MAX_REG_VAL] ;
    DWORD   t ;
    DWORD   ValLen ;
    DWORD   GraphPathLen ;
    BOOL    r ;

    assert (g_hkeyFilterGraphs != NULL) ;

    for (int i = 0;;) {

        ValLen = sizeof szValName / sizeof TCHAR ;
        GraphPathLen = sizeof szFilterGraph / sizeof TCHAR ;

        l = RegEnumValue (
                    g_hkeyFilterGraphs,
                    i,
                    szValName,
                    & ValLen,
                    NULL,
                    & t,
                    (LPBYTE) szFilterGraph,
                    & GraphPathLen
                    ) ;

        if (l == ERROR_NO_MORE_ITEMS ||
            t != REG_SZ) {
            break ;
        }

        r = AddEachFilterGraph (
                    GET_UNICODE (szFilterGraph, szwFilterGraph, MAX_PATH)
                    ) ;

        if (r == TRUE) {

            //  success; next
            i++ ;
        }
        else {

            //  we failed; delete the entry from the registry;
            RegDeleteValue (
                    g_hkeyFilterGraphs,
                    szValName
                    ) ;

            //  and don't increment the index
        }
    }
}

static
void
ReleaseAllFilterGraphs (
    )
{
    int                     row ;
    int                     cGraphs ;
    CFilterGraphContext *   pFilterGraphContext ;

    cGraphs = g_pCaptureGraphs -> GetItemCount () ;
    for (row = 0; row < cGraphs; row++) {
        pFilterGraphContext = GetFilterGraphContext (g_pCaptureGraphs, row) ;

        StopAndDrainAllEvents (pFilterGraphContext) ;
        pFilterGraphContext -> Release () ;
    }

    g_pCaptureGraphs -> ResetContent () ;
}

static
void
ReleaseAllrecordings (
    )
{
    IFilterGraph *  pIFilterGraph ;
    IBaseFilter *   pIBaseFilter ;
    int             row ;
    int             crecordings ;

    //  release any associated filter graph
    pIFilterGraph = reinterpret_cast <IFilterGraph *> (GetWindowLong (g_pRecordings -> GetHwnd (), GWL_USERDATA)) ;
    RELEASE_AND_CLEAR (pIFilterGraph) ;

    //  set the "owning filter graph" pointer to 0
    SetWindowLong (g_pRecordings -> GetHwnd (), GWL_USERDATA, 0) ;

    crecordings = g_pRecordings -> GetItemCount () ;
    for (row = 0; row < crecordings; row++) {
        pIBaseFilter = reinterpret_cast <IBaseFilter *> (g_pRecordings -> GetData (row)) ;
        assert (pIBaseFilter) ;
        RELEASE_AND_CLEAR (pIBaseFilter) ;
    }

    //  no more recordings
    g_pRecordings -> ResetContent () ;
}

static
void
MessageLoop (
    )
{
	MSG		msg;

    assert (g_MainWindow) ;

	while (GetMessage (&msg, NULL, 0, 0)) {
		if (IsDialogMessage (g_MainWindow, &msg))
			continue;

		TranslateMessage (&msg);
		DispatchMessage (&msg);
	}
}

static
void
DebugOut (
    TCHAR *  szfmt,
    ...
    )
{
    TCHAR    achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    _vstprintf (achbuffer, szfmt, va) ;

    OutputDebugString (achbuffer) ;
    OutputDebugString (__T("\n")) ;
}

static
void
MessageBoxError (
    TCHAR *  title,
    TCHAR *  szfmt,
    ...
    )
{
    TCHAR    achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    _vstprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK | MB_ICONEXCLAMATION) ;
}

static
void
MessageBoxMsg (
    TCHAR *  title,
    TCHAR *  szfmt,
    ...
    )
{
    TCHAR    achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    _vstprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK) ;
}

static
void
MessageBar (
    TCHAR * szfmt = NULL,
    ...
    )
{
    TCHAR    achbuffer [256] ;
    va_list va ;

    if (szfmt) {

        va_start (va, szfmt) ;
        _vstprintf (achbuffer, szfmt, va) ;

        SetWindowText (g_hwndMessageBar, achbuffer) ;
    }
    else {
        //  clear the message bar
        SetWindowText (g_hwndMessageBar, __T("")) ;
    }
}

static
void
PurgeMenu (
    HMENU   menu
    )
{
	int cmenuItems ;

	cmenuItems = GetMenuItemCount (menu) ;

    while (cmenuItems &&
           cmenuItems != -1) {

        RemoveMenu (menu, 0, MF_BYPOSITION) ;
		cmenuItems = GetMenuItemCount (menu) ;
    }
}

static
HMENU
DisplayPopupMenu (
    IN  int     iMenuIndex,
    IN  HANDLE  hMenuPopup
    )
{
    CFilterGraphContext *   pFG ;
    HMENU                   hmenu ;
    int                     row ;
    IBaseFilter *           pIBaseFilter ;
    HRESULT                 hr ;

    hmenu = NULL ;

    switch (iMenuIndex) {
        case MENU_INDEX_RECORDINGS :

            PurgeMenu (
                g_menuRecordings
                ) ;

            //  if there are recordings
            row = g_pRecordings -> GetSelectedRow () ;
            if (row != -1) {
                AppendMenu (
                    g_menuRecordings,
                    MF_STRING,
                    IDM_F_PROPERTY,
                    MENU_CHOICE_PROPERTIES
                    ) ;

                hmenu = g_menuRecordings ;
            }

            break ;

        case MENU_INDEX_CAPTURE_GRAPHS :

            if (hMenuPopup != g_menuCreate) {

                PurgeMenu (
                    g_menuCaptureGraphs
                    ) ;

                //  always
                AppendMenu (
                    g_menuCaptureGraphs,
                    MF_STRING,
                    IDM_FG_ADD,
                    MENU_CHOICE_ADD_FILTER_GRAPH
                    ) ;

                //  if there's a graph that's selected
                AppendMenu (
                    g_menuCaptureGraphs,
                    MF_STRING,
                    IDM_FG_DEL,
                    MENU_CHOICE_DEL_FILTER_GRAPH
                    ) ;

                row = g_pCaptureGraphs -> GetSelectedRow () ;
                if (row != -1) {

                    AppendMenu (
                            g_menuCaptureGraphs,
                            MF_SEPARATOR,
                            NULL,
                            NULL
                            ) ;

                    InsertMenu (
                        g_menuCaptureGraphs,
                        MENU_INDEX_CAPTURE_GRAPHS,
                        MF_STRING | MF_POPUP | MF_BYPOSITION,
                        (DWORD) g_menuCreate,
                        MENU_NAME_CREATE) ;

                    pFG = GetFilterGraphContext (g_pCaptureGraphs, row) ;

                    if (pFG -> FilterGraphState () == STATE_STOPPED) {
                        //  stopped

                        AppendMenu (
                            g_menuCaptureGraphs,
                            MF_STRING,
                            IDM_FG_RUN,
                            MENU_CHOICE_RUN_FILTER_GRAPH
                            ) ;

                        //  don't pause a capture graph
                        //AppendMenu (
                        //    g_menuCaptureGraphs,
                        //    MF_STRING,
                        //    IDM_FG_PAUSE,
                        //    MENU_CHOICE_PAUSE_FILTER_GRAPH
                        //    ) ;
                    }
                    else if (pFG -> FilterGraphState () == STATE_PAUSED) {
                        //  paused

                        AppendMenu (
                            g_menuCaptureGraphs,
                            MF_STRING,
                            IDM_FG_RUN,
                            MENU_CHOICE_RUN_FILTER_GRAPH
                            ) ;

                        AppendMenu (
                            g_menuCaptureGraphs,
                            MF_STRING,
                            IDM_FG_STOP,
                            MENU_CHOICE_STOP_FILTER_GRAPH
                            ) ;
                    }
                    else {
                        //  started

                        //  don't pause a capture graph
                        //AppendMenu (
                        //    g_menuCaptureGraphs,
                        //    MF_STRING,
                        //    IDM_FG_PAUSE,
                        //    MENU_CHOICE_PAUSE_FILTER_GRAPH
                        //    ) ;

                        AppendMenu (
                            g_menuCaptureGraphs,
                            MF_STRING,
                            IDM_FG_STOP,
                            MENU_CHOICE_STOP_FILTER_GRAPH
                            ) ;
                    }
                }
            }

            hmenu = g_menuCaptureGraphs ;

            break ;
    } ;

    return hmenu ;
}

static
IUnknown *
FindFilter (
    IN  CFilterGraphContext *   pFGContext,
    IN  REFIID                  riid
    )
{
    HRESULT         hr ;
    IEnumFilters *  pIEnumFilters ;
    IBaseFilter *   pIBaseFilter ;
    ULONG           ul ;
    IUnknown *      punkRet ;

    assert (pFGContext) ;

    punkRet = NULL ;

    pIEnumFilters = NULL ;
    hr = pFGContext -> FilterGraph () -> EnumFilters (& pIEnumFilters) ;
    if (SUCCEEDED (hr)) {
        //  find the network provider

        ASSERT (pIEnumFilters) ;

        pIBaseFilter = NULL ;

        for (;;) {

            hr = pIEnumFilters -> Next (1, & pIBaseFilter, & ul) ;
            if (FAILED (hr) ||
                ul == 0) {

                break ;
            }

            ASSERT (pIBaseFilter) ;

            punkRet = NULL ;
            hr = pIBaseFilter -> QueryInterface (riid, (void **) & punkRet) ;

            if (SUCCEEDED (hr)) {
                ASSERT (punkRet) ;

                //  release the ref we got from the enumeration & break
                RELEASE_AND_CLEAR (pIBaseFilter) ;
                break ;
            }
            else {
                RELEASE_AND_CLEAR (pIBaseFilter) ;
            }
        }

        RELEASE_AND_CLEAR (pIEnumFilters) ;
    }

    return punkRet ;
}

static
CFilterGraphContext *
CreateEmptyFilterGraph (
    )
{
    IFilterGraph *          pIFilterGraph ;
    IMediaControl *         pIMediaControl ;
    IGraphBuilder *         pIBuilder;
    IMediaEventEx *         pIMediaEventEx ;
    HRESULT                 hr ;
    CFilterGraphContext *   pFilterGraphContext ;

    pFilterGraphContext = NULL ;

    //  instantiate a filter graph object
    pIFilterGraph = NULL ;
    hr = CoCreateInstance (CLSID_FilterGraph,
                              NULL,
                              CLSCTX_INPROC,
                              IID_IFilterGraph,
                              (void**) & pIFilterGraph
                              ) ;

    if (SUCCEEDED (hr)) {

        assert (pIFilterGraph) ;

        //  grab the graph builder interface
        pIBuilder = NULL ;
        pIMediaControl = NULL ;
        pIMediaEventEx = NULL ;

        pIFilterGraph -> QueryInterface (IID_IGraphBuilder, (void **) & pIBuilder) ;
        pIFilterGraph -> QueryInterface (IID_IMediaControl, (void **) & pIMediaControl) ;
        pIFilterGraph -> QueryInterface (IID_IMediaEventEx, (void **) & pIMediaEventEx) ;

        if (pIMediaControl  &&
            pIMediaEventEx  &&
            pIBuilder) {

            //  struct AddRef's interface pointers
            pFilterGraphContext = new CFilterGraphContext (
                                                pIFilterGraph,
                                                pIMediaControl,
                                                pIMediaEventEx,
                                                pIBuilder
                                                ) ;

        }

        RELEASE_AND_CLEAR (pIMediaControl) ;
        RELEASE_AND_CLEAR (pIMediaEventEx) ;
        RELEASE_AND_CLEAR (pIBuilder) ;
    }

    RELEASE_AND_CLEAR (pIFilterGraph) ;

    return pFilterGraphContext ;
}

static
BOOL
AddEachFilterGraph (
    IN  WCHAR * szwFilterGraphPath
    )
{
    int                     row ;
    HRESULT                 hr ;
    TCHAR                   achbuffer [MAX_PATH] ;
    CFilterGraphContext *   pFilterGraphContext ;
    BOOL                    r ;

    assert (szwFilterGraphPath) ;

    MessageBar (__T("Opening %s"), GET_TCHAR (szwFilterGraphPath, achbuffer, MAX_PATH)) ;

    r = FALSE ;

    pFilterGraphContext = CreateEmptyFilterGraph () ;
    if (pFilterGraphContext) {

        MessageBar (__T("rendering %s"), GET_TCHAR (szwFilterGraphPath, achbuffer, MAX_PATH)) ;

        //  and render the graph
        hr = pFilterGraphContext -> GraphBuilder () -> RenderFile (szwFilterGraphPath,NULL) ;

        if (SUCCEEDED (hr)) {

            //  insert it into our graphs listview
            row = g_pCaptureGraphs -> InsertRowValue ((DWORD) pFilterGraphContext) ;
            if (row != -1) {

                //  listview's
                pFilterGraphContext -> AddRef () ;

                //  now the visible stuff
                if (g_pCaptureGraphs -> SetTextW (szwFilterGraphPath, row, 0)  != -1) {

                    SetCapGraphState (g_pCaptureGraphs, row, STATE_STOPPED) ;

                    //  now hook in our event notification mechanism
                    pFilterGraphContext -> MediaEventEx () -> SetNotifyWindow (
                                                (OAHWND) g_MainWindow,
                                                (LONG) WM_DVRAPP_AMOVIE_EVENT,
                                                (LONG) pFilterGraphContext
                                                ) ;

                    //  turn on notifications
                    pFilterGraphContext -> MediaEventEx () -> SetNotifyFlags (NOTIFY_ON) ;

                    r = TRUE ;
                }
            }
        }

        pFilterGraphContext -> Release () ;
    }

    MessageBar () ;

    return r ;
}

static
void
OnAddFilterGraph (
    )
{
    static TCHAR    szFile [MAX_PATH] ;
    static WCHAR    szwFile [MAX_PATH] ;
    static TCHAR    szTitle [MAX_PATH] ;

    BOOL            r ;

    g_ofn.lpstrFile         = szFile ;
    g_ofn.lpstrFileTitle    = szTitle ;

    if (GetOpenFileName (& g_ofn)) {
        r = AddEachFilterGraph (
                    GET_UNICODE (szFile, szwFile, MAX_PATH)
                    ) ;

        if (r == TRUE) {
            SaveFilterGraphInRegistry (
                            GET_UNICODE (szFile, szwFile, MAX_PATH)
                            ) ;
        }
    }
}

static
void
SaveFilterGraphInRegistry (
    IN  WCHAR * szwFilterGraph
    )
{
    DWORD   i ;
    LONG    l ;
    TCHAR   achbuffer [MAX_REG_VAL] ;
    TCHAR   sztfg [MAX_PATH] ;
    DWORD   t ;

    assert (szwFilterGraph) ;

    //  find an open value index
    for (i = 0;; i++) {
        t = REG_SZ ;
        l = RegQueryValueEx (
                    g_hkeyFilterGraphs,
                    _itot (i, achbuffer, MAX_REG_VAL),
                    NULL,
                    & t,
                    NULL,
                    NULL
                    ) ;

        //  try the next value if there's already a filter graph associated with this number
        if (l == ERROR_SUCCESS) {
            continue ;
        }

        //  set the value
        l = RegSetValueEx (
                g_hkeyFilterGraphs,
                achbuffer,                                          //  is the number that is available
                NULL,
                REG_SZ,
                (CONST BYTE *) GET_TCHAR (szwFilterGraph, sztfg, MAX_PATH),
                (wcslen (szwFilterGraph) + 1) * sizeof WCHAR        //  include NULL-terminator
                ) ;

        break ;
    }
}

static
void
DeleteFilterGraphFromRegistry (
    IN  WCHAR * szFilterGraph
    )
{
    LONG    l ;
    TCHAR * sztFilterGraph ;
    TCHAR   sztEachFilterGraph [MAX_PATH] ;
    TCHAR   sztValName [MAX_REG_VAL] ;
    TCHAR   sztBuffer [MAX_PATH] ;
    DWORD   t ;
    DWORD   ValLen ;
    DWORD   GraphPathLen ;
    BOOL    r ;

    assert (szFilterGraph) ;
    assert (g_hkeyFilterGraphs != NULL) ;

    //  convert in string to TCHAR
    sztFilterGraph = GET_TCHAR (szFilterGraph, sztBuffer, MAX_PATH) ;

    //  find the entry
    for (int i = 0;;i++) {

        ValLen = sizeof sztValName / sizeof TCHAR ;
        GraphPathLen = sizeof sztEachFilterGraph / sizeof TCHAR ;

        l = RegEnumValue (
                    g_hkeyFilterGraphs,
                    i,
                    sztValName,
                    & ValLen,
                    NULL,
                    & t,
                    (LPBYTE) sztEachFilterGraph,
                    & GraphPathLen
                    ) ;

        if (l == ERROR_NO_MORE_ITEMS ||
            t != REG_SZ) {
            break ;
        }

        if (_tcsicmp (sztFilterGraph, sztEachFilterGraph) == 0) {
            RegDeleteValue (
                    g_hkeyFilterGraphs,
                    sztValName
                    ) ;

            //  successfully deleted
            return ;
        }
    }

    //  never did find it
    return ;
}

static
void
StopAndDrainAllEvents (
    IN  CFilterGraphContext *  pFilterGraphContext
    )
{
    MSG msg ;

    assert (pFilterGraphContext) ;

    //  turn off event notifications
    pFilterGraphContext -> MediaEventEx () -> SetNotifyFlags (NOTIFY_OFF) ;

    //  BUGBUG: what if messages are being posted faster than we can read through them .. ?

    while (PeekMessage (
                & msg,
                g_MainWindow,
                WM_DVRAPP_AMOVIE_EVENT,
                WM_DVRAPP_AMOVIE_EVENT,
                PM_NOREMOVE
                )) {

        //  if the message was for us
        if (msg.lParam == (LPARAM) pFilterGraphContext) {

            //  remove it & ignore it
            PeekMessage (
                    & msg,
                    g_MainWindow,
                    WM_DVRAPP_AMOVIE_EVENT,
                    WM_DVRAPP_AMOVIE_EVENT,
                    PM_REMOVE
                    ) ;
        }
    }
}

static
void
OnDeleteFilterGraph (
    )
{
    int                     row ;
    IFilterGraph *          pIFilterGraphFilters ;
    WCHAR                   szFilterGraph [MAX_PATH] ;
    CFilterGraphContext *   pFilterGraphContext ;

    row = g_pCaptureGraphs -> GetSelectedRow () ;
    assert (row != -1) ;

    pFilterGraphContext = GetFilterGraphContext (g_pCaptureGraphs, row) ;
    assert (pFilterGraphContext) ;

    //  delete from the registry
    g_pCaptureGraphs -> GetRowTextW (row, 0, MAX_PATH, szFilterGraph) ;
    DeleteFilterGraphFromRegistry (
                szFilterGraph
                ) ;

    //  if we are currently displaying this filter graph in the filter listview, clear it out
    pIFilterGraphFilters = reinterpret_cast <IFilterGraph *> (GetWindowLong (g_pRecordings -> GetHwnd (), GWL_USERDATA)) ;
    if (pIFilterGraphFilters == pFilterGraphContext -> FilterGraph ()) {
        ReleaseAllrecordings () ;
    }

    //  delete from the listview
    g_pCaptureGraphs -> DeleteRow (row) ;

    StopAndDrainAllEvents (pFilterGraphContext) ;

    pFilterGraphContext -> Release () ;
}

static
void
OnFilterGraphClick (
    IN  int     iItem
    )
{
    CFilterGraphContext *   pFilterGraphContext ;

    assert (iItem != -1) ;

    pFilterGraphContext = GetFilterGraphContext (g_pCaptureGraphs, iItem) ;
    assert (pFilterGraphContext) ;
}

static
void
OnFilterGraphCommand (
    IN  WORD    wCmd
    )
{
    HRESULT                 hr ;
    int                     row ;
    CFilterGraphContext *   pFilterGraphContext ;

    row = g_pCaptureGraphs -> GetSelectedRow () ;
    assert (row != -1) ;

    pFilterGraphContext = GetFilterGraphContext (g_pCaptureGraphs, row) ;
    assert (pFilterGraphContext) ;

    switch (wCmd) {
        case IDM_FG_STOP :
            hr = pFilterGraphContext -> Stop () ;
            if (SUCCEEDED (hr)) {
                SetCapGraphState (g_pCaptureGraphs, row, STATE_STOPPED) ;
            }
            else {
                SetCapGraphState (g_pCaptureGraphs, row, STATE_INDETERMINATE) ;
            }
            break ;

        case IDM_FG_RUN :
            hr = pFilterGraphContext -> Run () ;
            if (SUCCEEDED (hr)) {
                SetCapGraphState (g_pCaptureGraphs, row, STATE_RUNNING) ;
            }
            else {
                SetCapGraphState (g_pCaptureGraphs, row, STATE_INDETERMINATE) ;
            }
            break ;

        case IDM_FG_PAUSE :
            hr = pFilterGraphContext -> Pause () ;
            if (SUCCEEDED (hr)) {
                SetCapGraphState (g_pCaptureGraphs, row, STATE_PAUSED) ;
            }
            else {
                SetCapGraphState (g_pCaptureGraphs, row, STATE_INDETERMINATE) ;
            }
            break ;
    } ;

    return ;
}

static
void
ProcessEvent (
    IN  CFilterGraphContext *   pFilterGraphContext,
    IN  LONG                    lEventCode,
    IN  LONG                    lParam1,
    IN  LONG                    lParam2
    )
{
    assert (pFilterGraphContext) ;

    switch (lEventCode) {
        case EC_COMPLETE :
            pFilterGraphContext -> SetFilterGraphState (STATE_STOPPED) ;
            break ;

        default :
            break ;
    } ;
}

static
HRESULT
RenderAllPins (
    IN  CFilterGraphContext *   pFGContext,
    IN  IBaseFilter *           pIBaseFilter
    )
//  pIBaseFilter should already be in pFGContext
{
    HRESULT     hr ;
    IPin *      pIPin ;
    IEnumPins * pIEnumPins ;
    ULONG       ulGot ;
    int         i ;

    i = 0 ;

    hr = pIBaseFilter -> EnumPins (& pIEnumPins) ;
    while (SUCCEEDED (hr)) {
        hr = pIEnumPins -> Next (1, & pIPin, & ulGot) ;
        if (hr == S_OK &&
            ulGot > 0) {

            MessageBar (__T("rendering pins (%d)"), ++i) ;

            hr = pFGContext -> GraphBuilder () -> Render (pIPin) ;
            pIPin -> Release () ;
        }
        else {
            //  don't fail because of this dshow habit
            hr = (hr == S_FALSE ? S_OK : hr) ;

            break ;
        }
    }

    if (pIEnumPins) {
        pIEnumPins -> Release () ;
    }

    MessageBar () ;

    return hr ;
}

static
CFilterGraphContext *
CreateViewerGraph (
    IN  IDVRStreamSink *    pIDVRStreamSink
    )
{
    CFilterGraphContext *   pFilterGraphViewer ;
    HRESULT                 hr ;
    IDVRStreamSource *      pIDVRStreamSource ;
    IBaseFilter *           pISourceBaseFilter ;

    pFilterGraphViewer = NULL ;

    MessageBar (__T("DVRStreamSink the profile")) ;
    hr = pIDVRStreamSink -> LockProfile () ;
    if (SUCCEEDED (hr)) {
        pFilterGraphViewer = CreateEmptyFilterGraph () ;
        if (pFilterGraphViewer) {
            hr = CoCreateInstance (
                    CLSID_DVRStreamSource,
                    NULL,
                    CLSCTX_INPROC,
                    IID_IDVRStreamSource,
                    (void**) & pIDVRStreamSource) ;
            if (SUCCEEDED (hr)) {

                hr = pIDVRStreamSource -> QueryInterface (IID_IBaseFilter, (void **) & pISourceBaseFilter) ;
                if (SUCCEEDED (hr)) {

                    hr = pFilterGraphViewer -> FilterGraph () -> AddFilter (pISourceBaseFilter, L"\0") ;
                    if (SUCCEEDED (hr)) {
                        MessageBar (__T("associating the stream sink")) ;
                        hr = pIDVRStreamSource -> SetStreamSink (pIDVRStreamSink) ;
                        if (SUCCEEDED (hr)) {
                            hr = RenderAllPins (pFilterGraphViewer, pISourceBaseFilter) ;
                            if (FAILED (hr)) {
                                MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("failed to render some pins")) ;
                            }
                        }
                        else {
                            MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("SetStreamSink call failed")) ;
                        }
                    }
                    else {
                        MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("failed to add filter to graph")) ;
                    }

                    pISourceBaseFilter -> Release () ;
                }
                else {
                    MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("failed to recover IBaseFilter")) ;
                }

                pIDVRStreamSource -> Release () ;
            }
            else {
                MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("failed to instantiate DVRStreamSource filter")) ;
            }
        }
        else {
            MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("Failed to create new filter graph")) ;
        }
    }
    else {
        MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("failed to lock the sink")) ;
    }

    //  if anything failed, release and return NULL, otherwise, keep the ref as
    //   the call's
    if (FAILED (hr)) {
        RELEASE_AND_CLEAR (pFilterGraphViewer) ;
    }

    return pFilterGraphViewer ;
}

static
void
OnCreateBroadcastViewer (
    )
{
    CFilterGraphContext *   pFilterGraphViewer ;
    CFilterGraphContext *   pFilterGraphCapture ;
    IDVRStreamSink *        pIDVRStreamSink ;
    IDVRStreamSource *      pIDVRStreamSource ;
    IBaseFilter *           pISourceBaseFilter ;
    int                     row ;
    HRESULT                 hr ;
    HWND                    hwndDialog ;

    //  first make sure we're setup ok
    row = g_pCaptureGraphs -> GetSelectedRow () ;
    assert (row != -1) ;

    pFilterGraphCapture = GetFilterGraphContext (g_pCaptureGraphs, row) ;
    assert (pFilterGraphCapture) ;

    pIDVRStreamSink = FIND_FILTER (pFilterGraphCapture, IDVRStreamSink) ;
    if (pIDVRStreamSink) {

        pFilterGraphViewer = CreateViewerGraph (pIDVRStreamSink) ;
        if (pFilterGraphViewer) {

            hwndDialog = CreateDialogParam (
                            g_hInstance,
                            MAKEINTRESOURCE (IDD_VIEW_DIALOG),
                            g_MainWindow,
                            BroadcastView_DialogProc,
                            (LPARAM) pFilterGraphViewer
                            ) ;
            if (hwndDialog) {
                ShowWindow (hwndDialog, SW_SHOW) ;
            }
            else {
                MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("failed to instantiate the dialog")) ;
            }

            pFilterGraphViewer -> Release () ;
        }

        pIDVRStreamSink -> Release () ;
    }
    else {
        MessageBoxError (TEXT ("Create Broadcast Viewer"), TEXT ("DVRStreamSink filter not found")) ;
    }
}

static
void
OnCreateRecording (
    )
{
    CFilterGraphContext *   pFilterGraphCapture ;
    int                     row ;
    HRESULT                 hr ;


    MessageBoxError (TEXT ("Create recording"), TEXT ("not implemented")) ;
    return ;


    //  first make sure we're setup ok
    row = g_pCaptureGraphs -> GetSelectedRow () ;
    assert (row != -1) ;

    pFilterGraphCapture = GetFilterGraphContext (g_pCaptureGraphs, row) ;
    assert (pFilterGraphCapture) ;

    DialogBoxParam (
        g_hInstance,
        MAKEINTRESOURCE (IDD_CREATE_RECORDING),
        g_MainWindow,
        CreateRecording_DialogProc,
        (LPARAM) pFilterGraphCapture
        ) ;
}

//  los massivos functionos
static
void
InitializeDialog (
    DWORD   idd,
    HWND    hwnd,
    WPARAM  wparam
    )
{
    HIMAGELIST  himlSmallState ;
    HICON       hicon ;

    switch (idd) {
        case    IDD_MAIN :
        {
            int         i ;

            g_pCaptureGraphs = new CListview (hwnd, IDC_FILTERGRAPHS) ;
            g_pRecordings = new CListview (hwnd, IDC_FILTERS) ;

            if (g_pCaptureGraphs == NULL ||
                g_pRecordings == NULL) {

                ExitProcess (EXIT_FAILURE) ;
            }

            //  create filter graph columns
            for (i = 0; i < FG_COL_COUNT; i++) {
                g_pCaptureGraphs -> InsertColumnW (g_FilterGraphsColumns [i].title, g_FilterGraphsColumns [i].width, i) ;
            }

            //  create recordings columns
            for (i = 0; i < R_COL_COUNT; i++) {
                g_pRecordings -> InsertColumnW (g_recordingsColumns [i].title, g_recordingsColumns [i].width, i) ;
            }

            himlSmallState = ImageList_Create (16, 16, ILC_COLORDDB | ILC_MASK, 1, 0) ;
            if (himlSmallState) {

                hicon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE (IDI_ACTIVE), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR) ;
                ImageList_AddIcon (himlSmallState, hicon) ;

                g_pCaptureGraphs -> SetImageList_State (himlSmallState) ;
                g_pRecordings -> SetImageList_State (himlSmallState) ;
            }

            //  generate our menus
            g_menuBar           = CreateMenu () ;
            g_menuCaptureGraphs = CreatePopupMenu () ;
            g_menuRecordings    = CreatePopupMenu () ;
            g_menuCreate        = CreatePopupMenu () ;

            if (g_menuBar           == NULL ||
                g_menuCaptureGraphs == NULL ||
                g_menuRecordings       == NULL ||
                g_menuCreate        == NULL) {

                ExitProcess (EXIT_FAILURE) ;
            }

            InsertMenu (
                g_menuBar,
                MENU_INDEX_CAPTURE_GRAPHS,
                MF_STRING | MF_POPUP | MF_BYPOSITION,
                (DWORD) g_menuCaptureGraphs,
                MENU_NAME_CAPTURE_GRAPHS) ;

            InsertMenu (
                g_menuBar,
                MENU_INDEX_RECORDINGS,
                MF_STRING | MF_POPUP | MF_BYPOSITION,
                (DWORD) g_menuRecordings,
                MENU_NAME_RECORDINGS) ;

            if (SetMenu (g_MainWindow, g_menuBar) == NULL) {
                ExitProcess (EXIT_FAILURE) ;
            }

            //  don't insert the create menu ; it gets inserted into the capture
            //   graph menu once we have capture graphs ; we do however, build
            //   it up

            AppendMenu (
                g_menuCreate,
                MF_STRING,
                IDM_FG_CREATE_BROADCAST_VIEWER,
                MENU_CHOICE_CREATE_BROADCAST_VIEWER
                ) ;

            AppendMenu (
                g_menuCreate,
                MF_STRING,
                IDM_FG_CREATE_RECORDING,
                MENU_CHOICE_CREATE_RECORDING
                ) ;
        }
            break ;
    } ;
}

static
CBroadcastViewContext *
BroadcastViewContext (
    IN  HWND    hwnd
    )
{
    return reinterpret_cast <CBroadcastViewContext *> (GetWindowLongPtr (hwnd, DWLP_USER)) ;
}

static
void
OnSeek (
    IN  HWND    hwndDialog
    )
{
    CBroadcastViewContext * pBVContext ;
    CTrackbar               tb (hwndDialog, IDC_SEEK) ;
    double                  d ;
    TCHAR                   ach [256] ;
    REFERENCE_TIME          rtAvailMin ;
    REFERENCE_TIME          rtAvailMax ;
    REFERENCE_TIME          rtPosition ;
    REFERENCE_TIME          rtSeekTo ;
    HRESULT                 hr ;
    long                    lMin ;
    long                    lMax ;
    long                    lTo ;
    long                    lPos ;

    pBVContext = BroadcastViewContext (hwndDialog) ;

    d = tb.GetSelPositionRatio () ;

    pBVContext -> GetAvailable (& rtAvailMin, & rtAvailMax) ;

    rtSeekTo = (REFERENCE_TIME) (rtAvailMin + (rtAvailMax - rtAvailMin) * d) ;

    pBVContext -> CancelStep () ;
    hr = pBVContext -> SeekRestart (& rtSeekTo) ;
    if (SUCCEEDED (hr)) {

        lPos = DShowTimeToSeekBarTime (rtSeekTo) ;
        lMin = DShowTimeToSeekBarTime (rtAvailMin) ;
        lMax = DShowTimeToSeekBarTime (rtAvailMax) ;

        tb.SetRange     (lMin, lMax) ;      //  scales the trackbar
        tb.SetSelector  (lPos) ;            //  reposition the selector

        //  new position
        pBVContext -> GetCurrentPosition (& rtPosition) ;

        _sntprintf (ach, 64, __T("%d"), DShowToSeconds (rtAvailMin)) ; SetDlgItemText (hwndDialog, IDC_MIN_AVAIL, ach) ;
        _sntprintf (ach, 64, __T("%d"), DShowToSeconds (rtAvailMax)) ; SetDlgItemText (hwndDialog, IDC_MAX_AVAIL, ach) ;
        _sntprintf (ach, 64, __T("%d"), DShowToSeconds (rtPosition)) ; SetDlgItemText (hwndDialog, IDC_CUR_POS, ach) ;
    }
}

static
void
SeekToLive (
    IN  HWND    hwndDialog
    )
{
    CTrackbar   tb (hwndDialog, IDC_SEEK) ;

    tb.SetSelectorToMax () ;
    OnSeek (hwndDialog) ;
}

void
CALLBACK
UpdateBroadcastView (
    HWND    hwnd,
    UINT    uMsg,
    UINT    idEvent,
    DWORD   dwTime
    )
{
    CBroadcastViewContext * pBVContext ;
    REFERENCE_TIME          rtPosition ;
    REFERENCE_TIME          rtAvailMin ;
    REFERENCE_TIME          rtAvailMax ;
    HRESULT                 hr ;
    CTrackbar               tb (hwnd, IDC_SEEK) ;
    long                    lMin ;
    long                    lMax ;
    long                    lPos ;
    TCHAR                   ach [128] ;

    if (idEvent == BV_PERIODIC_TIMER) {
        pBVContext = BroadcastViewContext (hwnd) ;

        //  get
        pBVContext -> GetCurrentPosition (& rtPosition) ;
        pBVContext -> GetAvailable (& rtAvailMin, & rtAvailMax) ;

        //  scale
        lPos = DShowTimeToSeekBarTime (rtPosition) ;
        lMin = DShowTimeToSeekBarTime (rtAvailMin) ;
        lMax = DShowTimeToSeekBarTime (rtAvailMax) ;

        //  post
        tb.SetRange     (lMin, lMax) ;      //  scales the trackbar
        tb.SetAvailable (lMin, lPos) ;      //  shows what we have to seek in

        DShowToHMS (ach, 128, rtAvailMin) ; SetDlgItemText (hwnd, IDC_MIN_AVAIL, ach) ;
        DShowToHMS (ach, 128, rtAvailMax) ; SetDlgItemText (hwnd, IDC_MAX_AVAIL, ach) ;
        DShowToHMS (ach, 128, rtPosition) ; SetDlgItemText (hwnd, IDC_CUR_POS, ach) ;

        DShowToHMS (ach, 128, pBVContext -> FilterGraphContext () -> GraphClockTimeRunning ()) ;
        SetDlgItemText (hwnd, IDC_GRAPH_RUNTIME, ach) ;
    }
}

static
HRESULT
InitBroadcastViewDialog (
    IN  HWND    hwndDialog,
    IN  LPARAM  lparam
    )
{
    HRESULT                 hr ;
    UINT                    ui ;
    CBroadcastViewContext * pBroadcastViewContext ;
    CCombobox               replay (hwndDialog, IDC_REPLAY_SECONDS) ;
    CCombobox               frames (hwndDialog, IDC_FRAME_STEP_FRAMES) ;
    int                     i ;
    TCHAR                   ach [32] ;
    int                     iFrames ;

    pBroadcastViewContext = new CBroadcastViewContext (reinterpret_cast <CFilterGraphContext *> (lparam)) ;
    SetWindowLongPtr (hwndDialog, DWLP_USER, (LONG_PTR) pBroadcastViewContext) ;

    if (pBroadcastViewContext) {
        hr = pBroadcastViewContext -> Init () ;
        if (SUCCEEDED (hr)) {
            ShowHideBroadcastView (hwndDialog, pBroadcastViewContext, IDC_OFF) ;
            SetTimer (hwndDialog, BV_PERIODIC_TIMER, BV_UPDATE_PERIOD_MILLIS, UpdateBroadcastView) ;

            for (i = 5; i < 15; i++) {
                _sntprintf (ach, 32, __T("%d"), i) ;
                replay.AppendW (ach) ;
            }
            replay.Focus (0) ;

            if (pBroadcastViewContext -> CanFrameStep ()) {
                iFrames = (pBroadcastViewContext -> CanFrameStepMultiple () ? 10 : 1) ;

                for (i = 1; i < 10; i++) {
                    _sntprintf (ach, 32, __T("%d"), i) ;
                    frames.AppendW (ach) ;
                }
                frames.Focus (0) ;
            }
            else {
                ShowWindow (GetDlgItem (hwndDialog, IDC_FRAME_STEP_FRAMES),         FALSE) ;
                ShowWindow (GetDlgItem (hwndDialog, IDC_FRAME_STEP),                FALSE) ;
                ShowWindow (GetDlgItem (hwndDialog, IDC_FRAME_STEP_FRAMES_LABEL),   FALSE) ;
            }
        }
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    return hr ;
}

static
void
UninitBroadcastViewDialog (
    IN  HWND    hwndDialog
    )
{
    delete BroadcastViewContext (hwndDialog) ;
    SetWindowLongPtr (hwndDialog, DWLP_USER, 0) ;
    KillTimer (hwndDialog, BV_PERIODIC_TIMER) ;
}

static
void
ShowHideBroadcastView (
    IN  HWND                    hwndDialog,
    IN  CBroadcastViewContext * pBroadcastViewContext,
    IN  WORD                    wButtonClicked
    )
{
    ShowWindow (GetDlgItem (hwndDialog, IDC_PAUSE), wButtonClicked == IDC_VIEW ? TRUE : FALSE) ;
    ShowWindow (GetDlgItem (hwndDialog, IDC_VIEW),  wButtonClicked != IDC_VIEW ? TRUE : FALSE) ;
    ShowWindow (GetDlgItem (hwndDialog, IDC_OFF),   wButtonClicked != IDC_OFF ? TRUE : FALSE) ;
}

static
void
Replay (
    IN  HWND    hwndDialog
    )
{
    CCombobox               replay (hwndDialog, IDC_REPLAY_SECONDS) ;
    CTrackbar               tb (hwndDialog, IDC_SEEK) ;
    CBroadcastViewContext * pBVContext ;
    int                     iSec ;
    REFERENCE_TIME          rtJump ;
    REFERENCE_TIME          rtNow ;
    REFERENCE_TIME          rtTo ;
    REFERENCE_TIME          rtAvailMin ;
    REFERENCE_TIME          rtAvailMax ;
    long                    lNow ;
    long                    lMin ;
    long                    lMax ;
    TCHAR                   ach [256] ;
    double                  dRatio ;

    iSec = 0 ;
    replay.GetTextW (& iSec) ;
    if (iSec > 0) {
        rtJump = SecondsToDShow (iSec) ;

        pBVContext = BroadcastViewContext (hwndDialog) ;
        pBVContext -> GetAvailable (& rtAvailMin, & rtAvailMax) ;
        pBVContext -> GetCurrentPosition (& rtNow) ;

        rtTo = Max <REFERENCE_TIME> (rtAvailMin, rtNow - rtJump) ;

        dRatio = (double) (rtTo - rtAvailMin) / (double) (rtAvailMax - rtAvailMin) ;

        lNow = DShowTimeToSeekBarTime (rtNow) ;
        lMin = DShowTimeToSeekBarTime (rtAvailMin) ;
        lMax = DShowTimeToSeekBarTime (rtAvailMax) ;

        //  post
        tb.SetRange     (lMin, lMax) ;      //  scales the trackbar
        tb.SetAvailable (lMin, lNow) ;      //  shows what we have to seek in
        tb.SetSelPositionRatio  (dRatio) ;

        //  go
        OnSeek (hwndDialog) ;
    }
    else {
        MessageBoxError (__T("Replay"), __T("%d is not valid"), iSec) ;
    }
}

static
void
FrameStep (
    IN  HWND    hwndDialog
    )
{
    CBroadcastViewContext * pBVContext ;
    CCombobox               frames (hwndDialog, IDC_FRAME_STEP_FRAMES) ;
    DWORD                   dwFrames ;

    pBVContext = BroadcastViewContext (hwndDialog) ;
    frames.GetTextW ((int *) & dwFrames) ;

    assert (pBVContext -> CanFrameStep ()) ;
    pBVContext -> Step (dwFrames) ;

    ShowWindow (GetDlgItem (hwndDialog, IDC_PAUSE), FALSE) ;
    ShowWindow (GetDlgItem (hwndDialog, IDC_VIEW),  TRUE) ;
    ShowWindow (GetDlgItem (hwndDialog, IDC_OFF),   TRUE) ;
}

static
void
BroadcastViewGraphTransition (
    IN  HWND                    hwndDialog,
    IN  WORD                    wButtonClicked,
    IN  CBroadcastViewContext * pBroadcastViewContext
    )
{
    HRESULT hr ;
    BOOL    fIsStopped ;

    switch (wButtonClicked) {
        case IDC_PAUSE :
            hr = pBroadcastViewContext -> Pause () ;
            break ;

        case IDC_VIEW :
            fIsStopped = pBroadcastViewContext -> IsStopped () ;
            hr = pBroadcastViewContext -> Run () ;
            if (fIsStopped &&
                g_fSeekToLiveOnStart) {
                SeekToLive (hwndDialog) ;
            }
            break ;

        case IDC_OFF :
            hr = pBroadcastViewContext -> Stop () ;
            break ;
    }

    if (SUCCEEDED (hr)) {
        ShowHideBroadcastView (hwndDialog, pBroadcastViewContext, wButtonClicked) ;
    }
}

static
CRecordingContext *
RecordingContext (
    IN  HWND    hwndDialog
    )
{
    return reinterpret_cast <CRecordingContext *> (GetWindowLongPtr (hwndDialog, DWLP_USER)) ;
}

void
CALLBACK
UpdateRecordableSlider (
    HWND    hwnd,
    UINT    uMsg,
    UINT    idEvent,
    DWORD   dwTime
    )
{
    TCHAR   ach [64] ;

    _sntprintf (ach, 64, __T("%d"), RecordingContext (hwnd) -> FiltergraphContext () -> MillisRunning () / 1000) ;
    SetDlgItemText (hwnd, IDC_MIN_TIME, ach) ;
}

static
HRESULT
InitCreateRecordingDialog (
    IN  HWND    hwndDialog,
    IN  LPARAM  lparam
    )
{
    CRecordingContext * pRecordingContext ;

    pRecordingContext = new CRecordingContext (reinterpret_cast <CFilterGraphContext *> (lparam)) ;
    SetWindowLongPtr (hwndDialog, DWLP_USER, (LONG_PTR) pRecordingContext) ;

    SetTimer (hwndDialog, REC_PERIODIC_TIMER, REC_UPDATE_PERIOD_MILLIS, UpdateRecordableSlider) ;

    assert (pRecordingContext) ;

    return S_OK ;
}

static
void
UninitCreateRecordingDialog (
    IN  HWND    hwndDialog
    )
{
    delete RecordingContext (hwndDialog) ;
    SetWindowLongPtr (hwndDialog, DWLP_USER, 0) ;
    KillTimer (hwndDialog, REC_PERIODIC_TIMER) ;
}

static
void
OnSetRecordSlider (
    IN  HWND    hwndDialog
    )
{
    return ;
}

static
BOOL
CALLBACK
CreateRecording_DialogProc (
    IN  HWND    window,
    IN  UINT    message,
    IN  WPARAM  wparam,
    IN  LPARAM  lparam
    )
{
    switch (message) {
        case    WM_DESTROY :
            UninitCreateRecordingDialog (window) ;
            EndDialog (window, NO_ERROR) ;
            return FALSE ;

	    case	WM_CLOSE :
            UninitCreateRecordingDialog (window) ;
            EndDialog (window, NO_ERROR) ;
            return TRUE ;

        case    WM_INITDIALOG :
            assert (lparam) ;
            InitCreateRecordingDialog (window, lparam) ;
            return TRUE ;

        case    WM_NOTIFY :
            if ((int) wparam == IDC_RECORDING_EXTENT                                                            &&
                reinterpret_cast <LPNMHDR> (lparam) -> hwndFrom == GetDlgItem (window, IDC_RECORDING_EXTENT)    &&
                reinterpret_cast <LPNMHDR> (lparam) -> code     == NM_RELEASEDCAPTURE) {
                OnSetRecordSlider (window) ;
            }
            break ;

        case    WM_COMMAND :
            switch (LOWORD (wparam)) {
                case IDC_PAUSE :
                case IDC_VIEW :
                case IDC_OFF :
                    break ;

                default :
                    break ;
            } ;
    } ;

    return FALSE ;
}

static
BOOL
CALLBACK
BroadcastView_DialogProc (
    IN  HWND    window,
    IN  UINT    message,
    IN  WPARAM  wparam,
    IN  LPARAM  lparam
    )
{
    CBroadcastViewContext * pBroadcastViewContext ;
    HRESULT                 hr ;

    switch (message) {
        case    WM_DESTROY :
            UninitBroadcastViewDialog (window) ;
            EndDialog (window, NO_ERROR) ;
            return FALSE ;

	    case	WM_CLOSE :
            UninitBroadcastViewDialog (window) ;
            EndDialog (window, NO_ERROR) ;
            return TRUE ;

        case    WM_NOTIFY :
            if ((int) wparam == IDC_SEEK                                                            &&
                reinterpret_cast <LPNMHDR> (lparam) -> hwndFrom == GetDlgItem (window, IDC_SEEK)    &&
                reinterpret_cast <LPNMHDR> (lparam) -> code     == NM_RELEASEDCAPTURE) {
                OnSeek (window) ;
            }
            break ;

        case    WM_INITDIALOG :
            assert (lparam) ;
            InitBroadcastViewDialog (window, lparam) ;
            return TRUE ;

        case    WM_COMMAND :
            switch (LOWORD (wparam)) {
                case IDC_PAUSE :
                case IDC_VIEW :
                case IDC_OFF :
                    BroadcastViewGraphTransition (window, LOWORD (wparam), BroadcastViewContext (window)) ;
                    break ;

                case IDC_LIVE :
                    SeekToLive (window) ;
                    break ;

                case IDC_REPLAY :
                    Replay (window) ;
                    break ;

                case IDC_FRAME_STEP :
                    FrameStep (window) ;
                    break ;

                default :
                    break ;
            } ;
    } ;

    return FALSE ;
}

static
BOOL
CALLBACK
Main_DialogProc (
    HWND    window,
    UINT    message,
    WPARAM  wparam,
    LPARAM  lparam
    )
{
    static POINT    point ;
    static HMENU    hmenu ;

    switch (message) {
        case    WM_DVRAPP_AMOVIE_EVENT :
            CFilterGraphContext *   pFilterGraphContext ;
            LONG                    EventCode ;
            LONG                    lParam1 ;
            LONG                    lParam2 ;
            HRESULT                 hr ;

            pFilterGraphContext = reinterpret_cast <CFilterGraphContext *> (lparam) ;
            assert (pFilterGraphContext) ;

            hr = pFilterGraphContext -> MediaEventEx () -> GetEvent (
                                                                & EventCode,
                                                                & lParam1,
                                                                & lParam2,
                                                                0                       //  never block !
                                                                ) ;
            assert (SUCCEEDED (hr)) ;

            ProcessEvent (
                    pFilterGraphContext,
                    EventCode,
                    lParam1,
                    lParam2
                    ) ;

            pFilterGraphContext -> MediaEventEx () -> FreeEventParams (
                                                                EventCode,
                                                                lParam1,
                                                                lParam2
                                                                ) ;

            break ;

        case    WM_NOTIFY :
            if ((int) wparam == IDC_FILTERGRAPHS) {
                if ((reinterpret_cast <LPNMITEMACTIVATE> (lparam)) -> hdr.code == NM_CLICK &&
                    (reinterpret_cast <LPNMITEMACTIVATE> (lparam)) -> iItem != -1) {

                    OnFilterGraphClick (
                            (reinterpret_cast <LPNMITEMACTIVATE> (lparam)) -> iItem
                            ) ;

                    return TRUE ;
                }
            }
            break ;

	    case	WM_CLOSE:
            KillTimer (window, g_uiptrTimer) ;
            ReleaseAllFilterGraphs () ;
            ReleaseAllrecordings () ;
            delete g_pCaptureGraphs ;
            delete g_pRecordings ;
            DestroyWindow (window) ;
		    PostQuitMessage (EXIT_SUCCESS) ;
            return TRUE ;

        case    WM_INITDIALOG :
            return TRUE ;

        case    WM_INITMENUPOPUP :
            if (HIWORD (lparam) == FALSE) {
                DisplayPopupMenu (LOWORD (lparam), (HANDLE) wparam) ;
            }
            return TRUE ;

        case    WM_CONTEXTMENU :
            point.x = LOWORD(lparam) ;
            point.y = HIWORD(lparam) ;
            hmenu = DisplayPopupMenu (g_pCaptureGraphs -> GetHwnd () == (HWND) wparam ? MENU_INDEX_CAPTURE_GRAPHS : MENU_INDEX_RECORDINGS, NULL) ;
            if (hmenu) {
                TrackPopupMenu (hmenu, 0, point.x, point.y, 0, window, NULL) ;
            }
            return TRUE ;

        case    WM_COMMAND :
            switch (LOWORD (wparam)) {
                case IDM_FG_ADD :
                    OnAddFilterGraph () ;
                    break ;

                case IDM_FG_DEL :
                    OnDeleteFilterGraph () ;
                    break ;

                case IDM_FG_STOP :
                case IDM_FG_RUN :
                case IDM_FG_PAUSE :
                    OnFilterGraphCommand (LOWORD (wparam)) ;
                    break ;

                case IDM_F_PROPERTY :
                    MessageBoxMsg (__T("Properties"), __T("not implemented")) ;
                    break ;

                case IDM_FG_CREATE_BROADCAST_VIEWER :
                    OnCreateBroadcastViewer () ;
                    break ;

                case IDM_FG_CREATE_RECORDING :
                    OnCreateRecording () ;
                    break ;

                default :
                    break ;
            } ;
    } ;

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dsnet\util\nutil.cpp ===
/*++

    Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

    Module Name:

        nutil.cpp

    Abstract:


    Notes:

--*/

#include "projpch.h"

static unsigned char chMinClassD_IP [] = { 224, 0,   0,   0   } ;
static unsigned char chMaxClassD_IP [] = { 239, 255, 255, 255 } ;

LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = L'\0';
	MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);

	return buffer;
}

LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = '\0';
	WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len, NULL, FALSE);

	return buffer;
}

BOOL
IsMulticastIP (
    IN DWORD dwIP   //  network order
    )
{
    return (((unsigned char *) & dwIP) [0] >= chMinClassD_IP [0] &&
            ((unsigned char *) & dwIP) [0] <= chMaxClassD_IP [0]) ;
}

BOOL
IsUnicastIP (
    IN DWORD dwIP   //  network order
    )
{
    return (((unsigned char *) & dwIP) [0] < chMinClassD_IP [0]) ;
}

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR szValName,
    OUT DWORD * pdw
    )
//  value exists:           retrieves it
//  value does not exist:   sets it
{
    BOOL    r ;
    DWORD   dwCurrent ;

    r = GetRegDWORDVal (
            hkeyRoot,
            szValName,
            & dwCurrent
            ) ;
    if (r) {
        (* pdw) = dwCurrent ;
    }
    else {
        r = SetRegDWORDVal (
                hkeyRoot,
                szValName,
                (* pdw)
                ) ;
    }

    return r ;
}

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegDWORDVal (
                hkey,
                pszRegValName,
                pdwRet
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    BOOL    r ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;

    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    dwSize = sizeof (* pdwRet) ;
    dwType = REG_DWORD ;

    l = RegQueryValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            & dwType,
            (LPBYTE) pdwRet,
            & dwSize
            ) ;
    if (l == ERROR_SUCCESS) {
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        r = SetRegDWORDVal (
                hkey,
                pszRegValName,
                dwVal
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    )
{
    LONG    l ;

    l = RegSetValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            REG_DWORD,
            (const BYTE *) & dwVal,
            sizeof dwVal
            ) ;

    return (l == ERROR_SUCCESS ? TRUE : FALSE) ;
}

//  ---------------------------------------------------------------------------
//  CNetBuffer
//  ---------------------------------------------------------------------------

CNetBuffer::CNetBuffer (
    IN  DWORD       dwBufferLength,     //  how much to allocator
    OUT HRESULT *   phr                 //  success/failre of init
    ) : m_pbBuffer          (NULL),
        m_dwAllocLength     (dwBufferLength + NETBUFFER_HEADER_LEN)
{
    m_pbBuffer = new BYTE [m_dwAllocLength] ;
    (* phr) = (m_pbBuffer ? S_OK : E_OUTOFMEMORY) ;
}

CNetBuffer::~CNetBuffer (
    )
{
    delete [] m_pbBuffer ;
}

//  ---------------------------------------------------------------------------
//  CNetInterface
//  ---------------------------------------------------------------------------

CNetInterface::CNetInterface (
    ) : m_pNIC  (NULL),
        m_hHeap (NULL) {}

CNetInterface::~CNetInterface (
    )
{
    if (m_pNIC) {
        ASSERT (m_hHeap) ;
        HeapFree (m_hHeap, NULL, m_pNIC) ;
    }
}

BOOL
CNetInterface::IsInitialized (
    )
{
    return m_pNIC != NULL ;
}

HRESULT
CNetInterface::Initialize (
    )
{
    SOCKET  sock ;
    DWORD   retval ;
    WSADATA wsadata ;
    ULONG   size ;

    //  can't initialize twice
    if (m_pNIC) {
        return HRESULT_FROM_WIN32 (ERROR_GEN_FAILURE) ;
    }

    //  initialize local variables
    sock = INVALID_SOCKET ;

    m_hHeap = GetProcessHeap () ;
    if (m_hHeap == NULL) {
        retval = GetLastError () ;
        return HRESULT_FROM_WIN32 (retval) ;
    }

    if (WSAStartup (MAKEWORD(2, 0), & wsadata)) {
        retval = WSAGetLastError () ;
        return HRESULT_FROM_WIN32 (retval) ;
    }

    sock = WSASocket (AF_INET,
                      SOCK_RAW,
                      IPPROTO_RAW,
                      NULL,
                      0,
                      NULL) ;
    if (sock == INVALID_SOCKET) {
        retval = WSAGetLastError () ;
        goto error ;
    }

    for (m_cNIC = NUM_NIC_FIRST_GUESS;; m_cNIC++) {

        size = m_cNIC * sizeof INTERFACE_INFO ;

        __try {

            m_pNIC = reinterpret_cast <INTERFACE_INFO *> (m_pNIC ? HeapReAlloc (m_hHeap, HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, m_pNIC, size) :
                                                                   HeapAlloc (m_hHeap, HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, size)) ;

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            retval = ERROR_NOT_ENOUGH_MEMORY ;
            goto error ;
        }

        // make the call
        if (WSAIoctl (sock,
                      SIO_GET_INTERFACE_LIST,
                      NULL,
                      0,
                      m_pNIC,
                      size,
                      & size,
                      NULL,
                      NULL) == 0) {

            //  call succeeded
            m_cNIC = size / sizeof INTERFACE_INFO ;
            break ;
        }

        // have we reached MAX_SUPPORTED_IFC
        if (m_cNIC == MAX_SUPPORTED_IFC) {

            m_cNIC = 0 ;
            retval = ERROR_GEN_FAILURE ;
            goto error ;
        }
    }

    WSACleanup () ;

    return S_OK ;

    error :

    if (m_pNIC) {
        ASSERT (m_hHeap) ;
        HeapFree (m_hHeap, NULL, m_pNIC) ;
        m_pNIC = NULL ;
    }

    if (sock != INVALID_SOCKET) {
        closesocket (sock) ;
    }

    WSACleanup () ;

    return HRESULT_FROM_WIN32 (retval) ;
}

INTERFACE_INFO *
CNetInterface::operator [] (
    ULONG i
    )
{
    if (i >= m_cNIC) {
        return NULL ;
    }

    return & m_pNIC [i] ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dvrapp\controls.cpp ===
#include "precomp.h"
#include "controls.h"

LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    )
{
	int	x;

	x = MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);
	buffer [x] = 0;

	return buffer;
}

LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    )
{
	int	x;

	x = WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len, NULL, FALSE);
	buffer [x] = 0;

	return buffer;
}


/*++
    ---------------------------------------------------------------------------
        C C o n t r o l B a s e
    ---------------------------------------------------------------------------
--*/

CControlBase::CControlBase (
    HWND    hwnd,
    DWORD   id
    )
{
    assert (hwnd) ;

    m_hwnd = GetDlgItem (hwnd, id) ;
    m_id = id ;

#ifndef UNICODE
    m_pchScratch = & m_achBuffer [0] ;
    m_pchScratchMaxString = MAX_STRING ;
#endif  //  UNICODE
}

TCHAR *
CControlBase::ConvertToUIString_ (
    IN     WCHAR *  szIn
    )
{
    //  we convert or not based on what the UI is.  If UNICODE is defined
    //  the UI is unicode, and thus is compatible with the sz parameter.
    //  If UNICODE is not defined, then the UI is ansi and a conversion
    //  must be made.

#ifdef UNICODE
    return szIn ;         //  the easy case - UI is UNICODE
#else   //  ansi

    int     len ;
    char *  szOut ;

    //  compute required length and get a scratch buffer
    len = wcslen (szIn) + 1 ;           //  include null-terminator
    szOut = GetScratch_ (& len) ;

    //  we'll get _something_ via the above call
    assert (szOut) ;

    return UnicodeToAnsi (
                szIn,
                szOut,
                len
                ) ;
#endif  //  UNICODE
}

//  called to obtain a UI-compatible buffer
TCHAR *
CControlBase::GetUICompatibleBuffer_ (
    IN  WCHAR *     sz,
    IN OUT int *    pLen
    )
{
#ifdef UNICODE  //  easy case
    return sz ;
#else   //  ansi
    return GetScratch_ (pLen) ;
#endif  //  UNICODE
}

//  called with a UI-filled buffer; ensures that szUnicode has what sz
//  points to; obtain sz via GetUICompatibleBuffer_ to minimize
//  string operations i.e. sz may be szUnicode
WCHAR *
CControlBase::ConvertToUnicodeString_ (
    IN  TCHAR * sz,             //  buffer to convert; null-terminated
    IN  WCHAR * szUnicode,      //  requested buffer
    IN  int     MaxLen          //  max length of szUnicode buffer
    )
{
#ifdef UNICODE
    //  assert assumes that sz was obtained via call to GetUICompatibleBuffer_ ()
    assert (sz == szUnicode) ;
    return sz ;
#else   //  ansi
    //  assert assumes that sz was obtained via call to GetUICompatibleBuffer_ ()
    assert ((LPVOID) & sz [0] != (LPVOID) & szUnicode [0]) ;
    return AnsiToUnicode (sz, szUnicode, MaxLen) ;
#endif  //  UNICODE
}

HWND
CControlBase::GetHwnd (
    )
{
    return m_hwnd ;
}

DWORD
CControlBase::GetId (
    )
{
    return m_id ;
}

/*++
    ---------------------------------------------------------------------------
        C L i s t b o x
    ---------------------------------------------------------------------------
--*/

CListbox::CListbox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id) {}

int
CListbox::AppendW (
    WCHAR * szString
    )
{
    return SendMessage (m_hwnd, LB_ADDSTRING, 0, (LPARAM) ConvertToUIString_ (szString)) ;
}

int
CListbox::ResetContent (
    )
{
    SendMessage (m_hwnd, LB_RESETCONTENT, 0, 0) ;
    return 1 ;
}

void
CListbox::ShowItem (
    int iRow
    )
{
    SendMessage (m_hwnd, LB_SETCURSEL, (WPARAM) iRow, 0) ;
}

/*++
    ---------------------------------------------------------------------------
        C E d i t C o n t r o l
    ---------------------------------------------------------------------------
--*/

CEditControl::CEditControl (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
    assert (hwnd) ;
}

void
CEditControl::SetTextW (
    WCHAR * szText
    )
{
    assert (szText) ;

    SetWindowText (m_hwnd, ConvertToUIString_ (szText)) ;
}

void
CEditControl::SetTextW (
    INT val
    )
{
    WCHAR achbuffer [32] ;
    SetTextW (_itow (val, achbuffer, 10)) ;
}

int
CEditControl::GetTextW (
    INT *   val
    )
{
    WCHAR   achbuffer [32] ;

    assert (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 31)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CEditControl::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    TCHAR * szUI ;
    int     len ;
    int     r ;

    //  get our UI compatible buffer
    len = MaxChars ;
    szUI = GetUICompatibleBuffer_ (ach, & len) ;

    assert (szUI) ;
    assert (len <= MaxChars) ;

    //  get the text (include null-terminator in length)
    r = GetWindowText (m_hwnd, szUI, len) + 1 ;

    //  make sure we have it in our UNICODE buffer
    ConvertToUnicodeString_ (szUI, ach, r) ;

    return r ;
}

int CEditControl::ResetContent ()
{
    return SendMessage (m_hwnd, WM_CLEAR, 0, 0) ;
}

/*++
    ---------------------------------------------------------------------------
        C C o m b o b o x
    ---------------------------------------------------------------------------
--*/

CCombobox::CCombobox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
}

int
CCombobox::AppendW (
    WCHAR *  sz
    )
{
    return SendMessage (m_hwnd, CB_ADDSTRING, 0, (LPARAM) ConvertToUIString_ (sz)) ;
}

int
CCombobox::AppendW (
    INT val
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return AppendW (_itow (val, achbuffer, 10)) ;
}

int
CCombobox::InsertW (
    WCHAR * sz,
    int     index)
{
    return SendMessage (m_hwnd, CB_INSERTSTRING, (WPARAM) index, (LPARAM) ConvertToUIString_ (sz)) ;
}

int
CCombobox::InsertW (
    INT val,
    int index
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return InsertW (_itow (val, achbuffer, 10), index) ;
}

int
CCombobox::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    int     index ;
    int     count ;
    int     len ;
    TCHAR * szUI ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        //  might be that it's not a dropdown list - in which case we get;
        //  try to get just the edit control's text; if that fails, return
        //  a failure, otherwise we're ok

        //  first get a UI compatible buffer
        len = MaxChars ;
        szUI = GetUICompatibleBuffer_ (ach, & len) ;
        assert (szUI) ;

        count = GetWindowText (m_hwnd, szUI, len) ;
        if (count == 0) {
            return CB_ERR ;
        }

        assert (count <= len) ;
        assert (len <= MaxChars) ;

        //  now convert back to UNICODE
        ConvertToUnicodeString_ (szUI, ach, count) ;

        return count ;
    }

    //  make sure it will fit
    if (SendMessage (m_hwnd, CB_GETLBTEXTLEN, (WPARAM) index, 0) + 1 > MaxChars) {
        return CB_ERR ;
    }

    //  get a UI compatible buffer
    len = MaxChars ;
    szUI = GetUICompatibleBuffer_ (ach, & len) ;
    assert (szUI) ;

    count = SendMessage (m_hwnd, CB_GETLBTEXT, (WPARAM) index, (LPARAM) szUI) ;

    assert (count < len) ;
    assert (len <= MaxChars) ;

    //  include NULL terminator
    ConvertToUnicodeString_ (szUI, ach, count + 1) ;

    return count ;
}

int
CCombobox::GetTextW (
    int * val
    )
{
    WCHAR   achbuffer [32] ;

    assert (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 32)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}


int
CCombobox::Focus (
    int index
    )
{
    return SendMessage (m_hwnd, CB_SETCURSEL, (WPARAM) index, 0) ;
}

int
CCombobox::ResetContent (
    )
{
    return SendMessage (m_hwnd, CB_RESETCONTENT, 0, 0) ;
}

int
CCombobox::SetItemData (
    DWORD   val,
    int     index
    )
{
    return SendMessage (m_hwnd, CB_SETITEMDATA, (WPARAM) index, (LPARAM) val) ;
}

int
CCombobox::GetCurrentItemIndex (
    )
{
    return SendMessage (m_hwnd, CB_GETCURSEL, 0, 0) ;
}

int
CCombobox::GetItemData (
    DWORD * pval,
    int     index
    )
{
    int i ;

    assert (pval) ;

    i = SendMessage (m_hwnd, CB_GETITEMDATA, (WPARAM) index, 0) ;
    if (i == CB_ERR) {
        return CB_ERR ;
    }

    * pval = i ;
    return i ;
}

int
CCombobox::GetCurrentItemData (
    DWORD * pval
    )
{
    int index ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        return CB_ERR ;
    }

    return GetItemData (pval, index) ;
}

int
CCombobox::FindW (
    WCHAR * sz
    )
{
    assert (sz) ;
    return SendMessage (m_hwnd, CB_FINDSTRING, (WPARAM) -1, (LPARAM) ConvertToUIString_ (sz)) ;
}


/*++
    ---------------------------------------------------------------------------
        C L i s t v i e w
    ---------------------------------------------------------------------------
--*/

CListview::CListview (
    HWND hwnd,
    DWORD id
    ) : CControlBase (hwnd, id),
        m_cColumns (0)
{
}

int
CListview::ResetContent (
    )
{
    return SendMessage (m_hwnd, LVM_DELETEALLITEMS, 0, 0) ;
}

BOOL
CListview::SetData (
    DWORD dwData,
    int iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.lParam   = (LPARAM) dwData ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::SetTextW (
    WCHAR * sz,
    int iRow,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    assert (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = ConvertToUIString_ (sz) ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowIcon (
    int iIcon
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_IMAGE ;
    lvItem.iImage   = iIcon ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowValue (
    DWORD dw
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.lParam   = (LPARAM) dw ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowNumber (
    int i,
    int iCol
    )
{
    WCHAR achbuffer [16] ;

    return InsertRowTextW (
                    _itow (i, achbuffer, 10),
                    iCol
                    ) ;
}

int
CListview::InsertRowTextW (
    WCHAR * sz,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    assert (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = ConvertToUIString_ (sz) ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::DeleteRow (
    int iRow
    )
{
    return ListView_DeleteItem (m_hwnd, iRow) ;
}

int
CListview::GetSelectedCount (
    )
{
    return ListView_GetSelectedCount (m_hwnd) ;
}

int
CListview::GetSelectedRow (
    int iStartRow
    )
{
    return ListView_GetNextItem (m_hwnd, iStartRow, LVNI_SELECTED) ;
}

DWORD
CListview::GetData (
    int iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = m_cColumns ;

    return ListView_GetItem (m_hwnd, & lvItem) ? lvItem.lParam : NULL ;
}

DWORD CListview::GetData (
    )
{
    int iRow ;

    iRow = ListView_GetNextItem (m_hwnd, -1, LVNI_SELECTED) ;

    if (iRow == -1) {
        return NULL ;
    }

    return GetData (iRow) ;
}

DWORD
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    IN  int     cMax,
    OUT WCHAR * psz
    )
{
    int     len ;
    TCHAR * szUI ;

    len = cMax ;
    szUI = GetUICompatibleBuffer_ (psz, & len) ;
    assert (szUI) ;

    ListView_GetItemText (m_hwnd, iRow, iCol, szUI, len) ;

    assert (len <= cMax) ;

    ConvertToUnicodeString_ (szUI, psz, len) ;

    return wcslen (psz) ;
}


int
CListview::InsertColumnW (
    WCHAR * szColumnName,
    int ColumnWidth,
    int iCol
    )
{
    LVCOLUMN    lvColumn = {0} ;
    int         r ;

    assert (szColumnName) ;

    lvColumn.mask       = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt        = LVCFMT_LEFT;
    lvColumn.cx         = ColumnWidth ;
    lvColumn.pszText    = ConvertToUIString_ (szColumnName) ;

    r = ListView_InsertColumn (m_hwnd, iCol, & lvColumn) ;

    if (r != -1) {
        m_cColumns++ ;
    }

    return r ;
}

HIMAGELIST
CListview::SetImageList_ (
    HIMAGELIST  imgList,
    int         List
    )
{
    return ListView_SetImageList (m_hwnd, imgList, List) ;
}

HIMAGELIST
CListview::SetImageList_SmallIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_SMALL) ;
}

HIMAGELIST
CListview::SetImageList_NormalIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_NORMAL) ;
}

HIMAGELIST
CListview::SetImageList_State (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_STATE) ;
}

BOOL
CListview::SetState (
    int Index,
    int Row
    )
{
    //  setting or clearing ?
    if (Index > 0) {
        ListView_SetItemState (
                m_hwnd,
                Row,
                INDEXTOSTATEIMAGEMASK(Index),
                LVIS_STATEIMAGEMASK
                ) ;
    }
    else {
        ListView_SetItemState (m_hwnd, Row, 0, LVIS_STATEIMAGEMASK) ;
        ListView_RedrawItems (m_hwnd, Row, Row) ;
    }

    return TRUE ;
}

int
CListview::GetItemCount (
    )
{
    return SendMessage (m_hwnd, LVM_GETITEMCOUNT, 0, 0) ;
}

/*++
    ---------------------------------------------------------------------------
        C T r a c k b a r
    ---------------------------------------------------------------------------
--*/

CTrackbar::CTrackbar (
    HWND hwnd,
    DWORD id
    ) : CControlBase (hwnd, id) {}

void
CTrackbar::SetRange (
    IN  long    lLow,
    IN  long    lHigh
    )
{
    SendMessage (m_hwnd, TBM_SETRANGEMIN, (WPARAM) TRUE, (LPARAM) lLow) ;
    SendMessage (m_hwnd, TBM_SETRANGEMAX, (WPARAM) TRUE, (LPARAM) lHigh) ;
}

void
CTrackbar::GetRange (
    OUT long *  plLow,
    OUT long *  plHigh
    )
{
    (* plLow) = SendMessage (m_hwnd, TBM_GETRANGEMIN, 0, 0) ;
    (* plHigh) = SendMessage (m_hwnd, TBM_GETRANGEMAX, 0, 0) ;
}

void
CTrackbar::SetSelector (
    IN  long    lPos
    )
{
    SendMessage (m_hwnd, TBM_SETPOS, (WPARAM) TRUE, (LPARAM) lPos) ;
}

void
CTrackbar::SetSelectorToMax (
    )
{
    SetSelector (SendMessage (m_hwnd, TBM_GETRANGEMAX, 0, 0)) ;
}

void
CTrackbar::SetAvailable (
    IN  long    lMin,
    IN  long    lMax
    )
{
    SendMessage (m_hwnd, TBM_SETSEL, (WPARAM) TRUE, (LPARAM) MAKELONG (lMin, lMax)) ;
}

long
CTrackbar::GetSelPositionValue (
    )
{
    return SendMessage (m_hwnd, TBM_GETPOS, 0, 0) ;
}

double
CTrackbar::GetSelPositionRatio (
    )
{
    long iPos ;
    long lMin ;
    long lMax ;

    iPos = GetSelPositionValue () ;
    GetRange (& lMin, & lMax) ;

    return ((double) (iPos - lMin) / (double) (lMax - lMin)) ;
}

void
CTrackbar::SetSelPositionRatio (
    double  d           //   [0,1]
    )
{
    long lPos ;
    long lMin ;
    long lMax ;

    GetRange (& lMin, & lMax) ;

    lPos = lMin + (long) (d * (double) (lMax - lMin)) ;

    SetSelector (lPos) ;
}

/*++
    ---------------------------------------------------------------------------

    ---------------------------------------------------------------------------
--*/

CProgressInd::CProgressInd (
    HWND hwnd,
    DWORD id
    ) : CControlBase (hwnd, id) {}

void
CProgressInd::SetRange (
    IN  long    lLow,
    IN  long    lHigh
    )
{
    SendMessage (m_hwnd, PBM_SETRANGE32, (WPARAM) lLow, (LPARAM) lHigh) ;
}

void
CProgressInd::SetPosition (
    IN  long    lPos
    )
{
    SendMessage (m_hwnd, PBM_SETPOS, (WPARAM) lPos, 0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dvrapp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by main.rc
//
#define IDD_MAIN                        101
#define IDD_STRESS                      104
#define IDD_CONFIG                      105
#define IDD_VIEW_DIALOG                 106
#define IDI_ACTIVE                      107
#define IDD_RECORDING                   108
#define IDD_CREATE_RECORDING            108
#define IDC_SESSIONS                    1000
#define IDC_FILTERGRAPHS                1000
#define IDC_FILTERS                     1001
#define IDC_PID_MAPS                    1002
#define IDC_MAP_PID                     1003
#define IDC_MAP_PIN                     1004
#define IDC_MAP_MEDIASAMPLECONTENT      1005
#define IDC_MAP                         1006
#define IDC_MESSAGE_BOARD               1007
#define IDC_STOP                        1008
#define IDC_GO                          1009
#define IDC_BDA_PEST                    1010
#define IDC_CLEAR_MESSAGE_BOARD         1011
#define IDC_MESSAGE_BAR                 1013
#define IDC_THREAD_POOL                 1014
#define IDC_SPEW                        1015
#define IDC_PAUSE                       1016
#define IDC_REPLAY                      1017
#define IDC_LIVE                        1018
#define IDC_FRAME_STEP                  1019
#define IDC_REPLAY_SECONDS              1020
#define IDC_VIEW                        1021
#define IDC_OFF                         1022
#define IDC_MIN_AVAIL                   1023
#define IDC_MAX_AVAIL                   1024
#define IDC_CUR_POS                     1025
#define IDC_FRAME_STEP_FRAMES           1026
#define IDC_SEEK                        1029
#define IDC_FRAME_STEP_FRAMES_LABEL     1031
#define IDC_SLIDER2                     1033
#define IDC_RECORDING_EXTENT            1033
#define IDC_COMBO1                      1034
#define IDC_MIN_TIME                    1035
#define IDC_REC_START                   1036
#define IDC_REC_STOP                    1037
#define IDC_START_TIME_EDIT             1038
#define IDC_STOP_TIME_EDIT              1039
#define IDC_GRAPH_RUNTIME               1039

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1040
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dvrapp\main.h ===
#ifndef __main_h
#define __main_h

#define BV_PERIODIC_TIMER                   1
#define BV_UPDATE_PERIOD_MILLIS             100

#define REC_PERIODIC_TIMER                  2
#define REC_UPDATE_PERIOD_MILLIS            1000

#define MENU_NAME_CAPTURE_GRAPHS        __T("&Capture Graphs")
#define MENU_CHOICE_ADD_FILTER_GRAPH        __T("Add...")
#define MENU_CHOICE_DEL_FILTER_GRAPH        __T("Delete")
#define MENU_CHOICE_RUN_FILTER_GRAPH        __T("Run")
#define MENU_CHOICE_PAUSE_FILTER_GRAPH      __T("Pause")
#define MENU_CHOICE_STOP_FILTER_GRAPH       __T("Stop")
#define MENU_CHOICE_PROPERTIES              __T("Properties ...")
#define MENU_CHOICE_CREATE_BROADCAST_VIEWER __T("Viewer")
#define MENU_CHOICE_CREATE_RECORDING        __T("Recording...")

#define MENU_NAME_CREATE                __T("&Create")

#define MENU_NAME_RECORDINGS            __T("&Recordings")

enum {
    MENU_INDEX_CAPTURE_GRAPHS   = 0,
    MENU_INDEX_RECORDINGS
} ;

//  commands
enum {
    WM_DVRAPP_AMOVIE_EVENT = WM_USER + 1,
    IDM_FG_ADD,                             //  add filter graph
    IDM_FG_DEL,                             //  delete selected filter graph
    IDM_FG_RUN,                             //  start selected filter graph
    IDM_FG_PAUSE,                           //  pause selected filter graph
    IDM_FG_STOP,                            //  stop selected filter graph
    IDM_F_PROPERTY,                         //  filter properties
    IDM_FG_CREATE_BROADCAST_VIEWER,         //  create cap graph viewer
    IDM_FG_CREATE_RECORDING,                //  create a recording object
} ;

//  states (general)
enum {
    STATE_INACTIVE  = 0,
    STATE_ACTIVE    = 1
} ;

extern HINSTANCE    g_hInstance ;

template <class T> T Min (T a, T b) { return (a < b ? a : b) ; }
template <class T> T Max (T a, T b) { return (a > b ? a : b) ; }

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    )
{
    LONG    l ;

    l = RegSetValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            REG_DWORD,
            (const BYTE *) & dwVal,
            sizeof dwVal
            ) ;

    return (l == ERROR_SUCCESS ? TRUE : FALSE) ;
}

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    BOOL    r ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;

    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    dwSize = sizeof (* pdwRet) ;
    dwType = REG_DWORD ;

    l = RegQueryValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            & dwType,
            (LPBYTE) pdwRet,
            & dwSize
            ) ;
    if (l == ERROR_SUCCESS) {
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dwCurrent ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegDWORDVal (
                hkey,
                pszRegValName,
                pdwRet
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR szValName,
    OUT DWORD * pdw
    )
//  value exists:           retrieves it
//  value does not exist:   sets it
{
    BOOL    r ;
    DWORD   dwCurrent ;

    r = GetRegDWORDVal (
            hkeyRoot,
            szValName,
            & dwCurrent
            ) ;
    if (r) {
        (* pdw) = dwCurrent ;
    }
    else {
        r = SetRegDWORDVal (
                hkeyRoot,
                szValName,
                (* pdw)
                ) ;
    }

    return r ;
}

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdw
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dwCurrent ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdw) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegDWORDValIfExist (
                hkey,
                pszRegValName,
                pdw
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        r = SetRegDWORDVal (
                hkey,
                pszRegValName,
                dwVal
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

#endif  //  __main_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\dvrapp\precomp.h ===
#include <streams.h>
#include <commctrl.h>
#include <commdlg.h>
#include <assert.h>
#include <stdio.h>
#include <limits.h>
#include <tchar.h>

#define GOTO_EQ(val,comp,label)             if ((val) == (comp)) goto label
#define GOTO_NE(val,comp,label)             if ((val) != (comp)) goto label
#define RELEASE_AND_CLEAR(punk)             if (punk) { (punk) -> Release () ; (punk) = NULL ; }
#define DELETE_RESET(p)                     if (p) { delete (p) ; (p) = NULL ; }
#define CLOSE_RESET_REG_KEY(r)              if ((r) != NULL) { RegCloseKey (r); (r) = NULL ;}
#define GET_FILTER(pf,row)                  (reinterpret_cast <IBaseFilter *> (pf -> GetData (row)))

#ifdef UNICODE
#define GET_UNICODE(szt,szw,bl)     (szt)
#else
#define GET_UNICODE(szt,szw,bl)     AnsiToUnicode(szt,szw,bl)
#endif

#ifdef UNICODE
#define GET_TCHAR(szw,szt,bl)       (szw)
#else
#define GET_TCHAR(szw,szt,bl)       UnicodeToAnsi(szw,szt,bl)
#endif

LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    ) ;

LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\bnetfilt.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
// bnetfilt.cpp : defines random Quartz additions to BoxNet
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static enum Mode { MODE_SOURCE, MODE_SINK, MODE_SINK2 };
static BOOL PromptUser(OLECHAR *oszFileName, Mode mode, UINT nIDTitle, bool *pfTruncate = 0);

//
// AttemptFileOpen
//
// Checks if this filter needs a file opening for it.
// If so, it asks the user for a filename and opens it.
void AttemptFileOpen(IBaseFilter *pFilter)
{
    OLECHAR oszFileName[MAX_PATH];
    HRESULT hr;
    IFileSourceFilter *pIFileSource = NULL;
    hr = pFilter->QueryInterface(IID_IFileSourceFilter, (void**) &pIFileSource);
    if(SUCCEEDED(hr))
    {
        if(PromptUser(oszFileName, MODE_SOURCE, IDS_SOURCE_DIALOG_TITLE))
        {
            hr = pIFileSource->Load(oszFileName, NULL);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
        }
        pIFileSource->Release();
    }

    IFileSinkFilter2 *pIFileSink2 = NULL;
    hr = pFilter->QueryInterface(IID_IFileSinkFilter2, (void**) &pIFileSink2);
    if(SUCCEEDED(hr))
    {
        bool fTruncate;
        if(PromptUser(oszFileName, MODE_SINK2, IDS_SINK_DIALOG_TITLE, &fTruncate))
        {
            hr = pIFileSink2->SetFileName(oszFileName, NULL);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
            hr = pIFileSink2->SetMode(fTruncate ? AM_FILE_OVERWRITE : 0);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
        }
        pIFileSink2->Release();
    }
    else
    {
  
        IFileSinkFilter *pIFileSink = NULL;
        hr = pFilter->QueryInterface(IID_IFileSinkFilter, (void**) &pIFileSink);
        if(SUCCEEDED(hr))
        {
            if(PromptUser(oszFileName, MODE_SINK, IDS_SINK_DIALOG_TITLE))
            {
                hr = pIFileSink->SetFileName(oszFileName, NULL);
                if (FAILED(hr))
                    DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
            }
            pIFileSink->Release();
        }
    }
}

// handle the custom truncate button in the file-save dialog
UINT_PTR CALLBACK TruncateDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
      case WM_INITDIALOG:
          // Save off the long pointer to the OPENFILENAME structure.
          SetWindowLongPtr(hDlg, DWLP_USER, lParam);

          {
              LPOPENFILENAME lpOFN = (LPOPENFILENAME)lParam;
              DWORD *pfSink2 = (DWORD *)(lpOFN->lCustData);

              if(!(*pfSink2))
              {
                  Edit_Enable(GetDlgItem(hDlg, IDC_TRUNCATE), FALSE);
              }
          }

          break;

      case WM_DESTROY:
      {
          LPOPENFILENAME lpOFN = (LPOPENFILENAME)GetWindowLongPtr(hDlg, DWLP_USER);
          DWORD *pfTruncate = (DWORD *)(lpOFN->lCustData);

          HWND hButtonWnd = ::GetDlgItem(hDlg, IDC_TRUNCATE);
          *pfTruncate = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
      }
      break;

      default:
          return FALSE;
    }
    return TRUE;
    
}

// Helper to prompt user for a file name and return it
BOOL PromptUser(OLECHAR* oszFileName, Mode mode, UINT nIDTitle, bool *pfTruncate)
{
    CString strTitle;
    TCHAR tszFile[MAX_PATH];
    tszFile[0] = TEXT('\0');
    DWORD fTruncate;

    OPENFILENAME    ofn;
    ZeroMemory (&ofn, sizeof ofn);	

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = AfxGetMainWnd()->GetSafeHwnd();

    TCHAR tszMediaFileMask[201];

    int iSize = ::LoadString(AfxGetInstanceHandle(), IDS_MEDIA_FILES, tszMediaFileMask, 198);
    ofn.lpstrFilter = tszMediaFileMask;
    // avoid LoadString problems with \0\0
    tszMediaFileMask[iSize] = TEXT('\0');
    tszMediaFileMask[iSize + 1] = TEXT('\0');

    // win95 seems to be confused otherwise
    tszMediaFileMask[iSize + 2] = TEXT('\0');
    
    strTitle.LoadString( nIDTitle );

    ofn.nFilterIndex = 1;
    ofn.lpstrFile = tszFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = strTitle;

    if(mode == MODE_SOURCE)
    {
        ofn.Flags = OFN_FILEMUSTEXIST;
    }
    else if(mode == MODE_SINK || mode== MODE_SINK2)
    {
        DWORD &fSink2 = fTruncate;
        fSink2 = (mode == MODE_SINK2);
            
        ofn.lCustData         = (LPARAM)&fTruncate;
	ofn.lpfnHook 	       = TruncateDlgProc;
	ofn.lpTemplateName    = MAKEINTRESOURCE(IDD_TRUNCATE);        
        ofn.Flags = OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_HIDEREADONLY ;
        ofn.hInstance = AfxGetInstanceHandle();
    }

    // Get the user's selection

    if (!GetOpenFileName(&ofn)) {
        DWORD dw = CommDlgExtendedError();
        return FALSE;
    }

    if(pfTruncate)
    {
        *pfTruncate = !!fTruncate;
    }

#ifdef UNICODE

    wcscpy(oszFileName, tszFile);
#else

    MultiByteToWideChar(CP_ACP, 0, tszFile, -1, oszFileName, MAX_PATH);
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\bnetdoc.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetdoc.h : declares CBoxNetDoc
//


// forward declarations
class CCmd;
class CRegFilter;
class CPropObject;


const int MAX_STRING_LEN=1000;
const int MAXFILTERS = 100;
typedef struct { //fit
    int iFilterCount;
    struct {
        DWORD dwUnconnectedInputPins;
        DWORD dwUnconnectedOutputPins;
        FILTER_INFO finfo;
        IBaseFilter * pFilter;
        bool IsSource;
    } Item[MAXFILTERS];
} FILTER_INFO_TABLE;

// for passing internal messages (see bnetdoc.cpp, search WM_USER_EC_EVENT)
struct NetDocUserMessage
{
    long        lEventCode;
    LONG_PTR    lParam1;
    LONG_PTR    lParam2;
};

// *
// * CBoxNetDoc
// *

// A CBoxNetDoc is intended to reflect the contents of the graph it instantiates
// and allows the user to interact with.
// Therefore it maintains a list of all the filters and connections(links) that are
// currently in the graph.
class CBoxNetDoc : public CDocument {

    DECLARE_DYNCREATE(CBoxNetDoc)

public:

    // <lHint> codes for ModifiedDoc(), UpdateAllViews(), etc.
    enum EHint
    {
        HINT_DRAW_ALL = 0,              // redraw entire view (must be zero!)
        HINT_CANCEL_VIEWSELECT,         // cancel any view-specific selection
        HINT_CANCEL_MODES,              // cancel any current modes
        HINT_DRAW_BOX,                  // draw only specified box
        HINT_DRAW_BOXANDLINKS,          // draw only box and connected links
        HINT_DRAW_BOXTAB,               // draw only specified box tab
        HINT_DRAW_LINK                  // draw only specified box link
    };

public:
    // contents of the document
    CBoxList        m_lstBoxes;         // each CBox in document
    CLinkList       m_lstLinks;         // each CBoxLink in document

    CSize       GetSize(void);  // the document's current size (pixels)

protected:
    // undo/redo stacks
    CMaxList        m_lstUndo;          // each CCmd in undo stack
    CMaxList        m_lstRedo;          // each CCmd in redo stack

public:
    // construction and destruction
                 CBoxNetDoc();
    virtual      ~CBoxNetDoc();
    virtual void DeleteContents();  // release quartz mapper & graph
    virtual void OnCloseDocument();

    virtual BOOL OnNewDocument();   // get quartz mapper & graph
    virtual Close() { OnFileClose();}

    // storage & serialization
    virtual BOOL AttemptFileRender(LPCTSTR lpszPathName);
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);  
    virtual BOOL OnOpenDocumentInternal(LPCTSTR lpszPathName);

    virtual BOOL SaveModified(void);

    static DWORD WINAPI NotificationThread(LPVOID lpData);

private:
    virtual void CloseDownThread();     // close the notification thread

    BOOL m_bNewFilenameRequired;
    CString m_sOriginalPath;
    BOOL m_bNew;  // Was created as a new document (via File|New)

    // This constant is NOT localisable
    static const OLECHAR m_StreamName[];

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    void MyDump(CDumpContext& dc) const;
#endif

public:
    // general public functions
    void ModifiedDoc(CView* pSender, LPARAM lHint = 0L,
        CObject* pHint = NULL);
    void DeselectAll();
    BOOL IsNew() { return m_bNew;}

public:
    // CBox lists and box selection
    void GetBoundingRect(CRect *prc, BOOL fBoxSel);
    void SelectBox(CBox *pbox, BOOL fSelect);
    void SelectLink(CBoxLink *plink, BOOL fSelect);
    BOOL IsSelectionEmpty() { return (IsLinkSelectionEmpty() && IsBoxSelectionEmpty()); }
    BOOL IsBoxSelectionEmpty();
    void GetBoxes(CBoxList *plstDst, BOOL fSelected = FALSE);
    void GetBoxSelection(CBoxList *plstDst)
        { GetBoxes(plstDst, TRUE); }
    void SetBoxes(CBoxList *plstSrc, BOOL fSelected = FALSE);
    void InvalidateBoxes(CBoxList *plst);
    void SetBoxSelection(CBoxList *plstDst)
        { SetBoxes(plstDst, TRUE); }
    void MoveBoxSelection(CSize sizOffset);

    void SelectBoxes(CList<CBox *, CBox*> *plst);
    void SelectLinks(CList<CBoxLink *, CBoxLink *> *plst);

private:
    BOOL IsLinkSelectionEmpty();

public:
    // command processing
    void CmdDo(CCmd *pcmd);
    void CmdUndo();
    BOOL CanUndo();
    void CmdRedo();
    BOOL CanRedo();
    void CmdRepeat();
    BOOL CanRepeat();

protected:
    // message callback helper functions
    void UpdateEditUndoRedoRepeat(CCmdUI* pCmdUI, BOOL fEnable,
        unsigned idStringFmt, CMaxList *plst);

    virtual void SetTitle( LPCTSTR lpszTitle );

protected:
    void OnQuartzAbortStop();

    // message callback functions
    //{{AFX_MSG(CBoxNetDoc)
    afx_msg void OnFileRender();
    afx_msg void OnURLRender();
    afx_msg void OnUpdateFileRender(CCmdUI*);
    afx_msg void OnUpdateURLRender(CCmdUI *);
    afx_msg void OnUpdateFileSave(CCmdUI*);
    afx_msg void OnEditUndo();
    afx_msg void OnEditRedo();
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
    afx_msg void OnEditSelectAll();
    afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
    afx_msg void OnQuartzDisconnect();
    afx_msg void OnQuartzRun();
    afx_msg void OnUpdateQuartzDisconnect(CCmdUI* pCmdUI);
    afx_msg void OnWindowRefresh();
    afx_msg void OnWindowZoom33() { CBox::SetZoom(33); OnWindowRefresh(); }
    afx_msg void OnWindowZoom50() { CBox::SetZoom(50); OnWindowRefresh(); }
    afx_msg void OnWindowZoom100() { CBox::SetZoom(100); OnWindowRefresh(); }
    afx_msg void OnWindowZoom200() { CBox::SetZoom(200); OnWindowRefresh(); }
    afx_msg void OnUpdateQuartzRun(CCmdUI* pCmdUI);
    afx_msg void OnUpdateQuartzPause(CCmdUI* pCmdUI);
    afx_msg void OnUpdateQuartzStop(CCmdUI* pCmdUI);
    afx_msg void OnQuartzStop();
    afx_msg void OnQuartzPause();
    afx_msg void OnUpdateUseClock(CCmdUI* pCmdUI);
    afx_msg void OnUseClock();
    afx_msg void OnUpdateConnectSmart(CCmdUI* pCmdUI);
    afx_msg void OnConnectSmart();
    afx_msg void OnUpdateAutoArrange(CCmdUI* pCmdUI);
    afx_msg void OnAutoArrange();
    afx_msg void OnSaveGraphAsHTML();
    afx_msg void OnSaveGraphAsXML();
    afx_msg void OnConnectToGraph();
    afx_msg void OnGraphStats();
    afx_msg void OnGraphAddFilterToCache();
    afx_msg void OnUpdateGraphAddFilterToCache(CCmdUI* pCmdUI);
    afx_msg void OnGraphEnumCachedFilters();
    //}}AFX_MSG

    afx_msg void OnInsertFilter();

    // -- Pin properties menu --
    afx_msg void OnUpdateQuartzRender(CCmdUI* pCmdUI);
    afx_msg void OnQuartzRender();

    afx_msg void OnUpdateReconnect( CCmdUI* pCmdUI );
    afx_msg void OnReconnect( void );

    DECLARE_MESSAGE_MAP()

    // --- Quartz Stuff ---
public:
    void OnGraphEnumCachedFiltersInternal( void );

    IGraphBuilder  *IGraph(void) const {
        ASSERT(m_pGraph);
        return (*m_pGraph).operator IGraphBuilder*();
    }
    IMediaEvent *IEvent(void) const {
        ASSERT(m_pMediaEvent);
        return (*m_pMediaEvent).operator IMediaEvent *();
    }

    void OnWM_USER(NetDocUserMessage *);
    HRESULT UpdateFilters(void);
    void UpdateFiltersInternal(void);
    void      SelectedSocket(CBoxSocket *psock) { m_psockSelected = psock; }
    CBoxSocket    *SelectedSocket(void) { ASSERT_VALID(m_psockSelected); return m_psockSelected; }
    void      CurrentPropObject(CPropObject *pPropObject) { m_pCurrentPropObject = pPropObject; }
    CPropObject   *CurrentPropObject(void) { ASSERT(m_pCurrentPropObject); return m_pCurrentPropObject; }

    // Unknown state used after failure of Play, Pause or Stop. In this
    // case some filters might have changed state while others haven't.
    enum State { Playing, Paused, Stopped, Unknown };


    BOOL      IsStopped(void) { return m_State == Stopped; }
    State     GetState(void) { return m_State; }

    static const int m_iMaxInsertFilters;   // the maximum length of the insert menu
                            // need hard coded restriction for message map
    BOOL        m_fConnectSmart;        // true -> use Connect
                                        // false -> use ConnectDirect
    BOOL        m_fAutoArrange;         // true -> re-arrange graph view on refresh
                                        // false -> don't re-arrange graph view
    BOOL        m_fRegistryChanged;     // true -> registry has changed since last insert filters
                                        // false -> registry hasn't changed
    int         m_nLive;                // Set by CMultiGraphHost::LiveSourceReader; the graph is a live
                                        // reader that must be seeked when the graph starts. Also 
                                        // the minimum seek time to which this graph can seek to 
                                        // increases with time.
    void LiveSourceReader(BOOL bAdd) 
    {
        if (bAdd)
        {
            m_nLive++;
        }
        else if (m_nLive > 0)
        {
            m_nLive--;
        }
    }
    BOOL GetLiveSourceReader() { return m_nLive? 1 : 0;}
    enum {
        UNDEFINED = 0,
        SEEK_ON_RUN,
        SEEKED
    } m_nSeekOnRun;

    //
    // Array which holds the three Handles passed to the thread.
    // 1 = event handle for EC_ notifications,
    // 2 = event handle to terminate thread,
    // 3 = event handle to registry change
    //
    HANDLE  m_phThreadData[3];

    // The window our thread posts a message to
    HWND        m_hWndPostMessage;

    void SetSelectClock(CBox *pBox);  // Notification of which clock was selected
    void UpdateClockSelection();


    void ConnectToGraph();

    void PrintGraphAsHTML(HANDLE hFile);

    HRESULT ProcessPendingReconnect( void );
    HRESULT StartReconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin );

private:

    BOOL    CreateGraphAndMapper(void);

    CQCOMInt<IMediaEvent>       *m_pMediaEvent;
    IStream                     *m_pMarshalStream;

    CBoxSocket  *m_psockSelected;   // the socket the user last right clicked on.
    CPropObject *m_pCurrentPropObject;  // the property object the user last right clicked on

    HRESULT GetFiltersInGraph(void);
    HRESULT GetLinksInGraph(void);  
    HRESULT FilterDisplay(void);
    void    SetBoxesHorizontally(void);
    void    SetBoxesVertically(void);
    void    RealiseGrid(void);

    void WriteString(HANDLE hFile, LPCTSTR lpctstr, ...);

    void PrintFilterObjects(HANDLE hFile, TCHAR atchBuffer[], FILTER_INFO_TABLE *pfit);
    void PopulateFIT(HANDLE hFile, IFilterGraph *pGraph, TCHAR atchBuffer[],
            FILTER_INFO_TABLE *pfit);
    BOOL GetNextOutFilter(FILTER_INFO_TABLE &fit, int *iOutFilter);
    int LocateFilterInFIT(FILTER_INFO_TABLE &fit, IBaseFilter *pFilter);
    void MakeScriptableFilterName(WCHAR awch[], BOOL bSourceFilter);

    HRESULT SafePrintGraphAsHTML( HANDLE hFile );
    HRESULT SafeEnumCachedFilters( void );

    State   m_State;

    // Handle to the thread
    HANDLE      m_hThread;

    BOOL    m_fUsingClock;          // true (default) if using the default clock

    TCHAR m_tszStgPath[MAX_PATH];  // remember the path to our storage
    CString m_strHTMLPath; // remember the last html doc we saved
    CString m_strXMLPath; // remember the last html doc we saved
    long m_lSourceFilterCount; // Append digits to source filter names to make them unique


    // Internal Reconnect Functions.
    enum ASYNC_RECONNECT_FLAGS
    {
        ASYNC_RECONNECT_NO_FLAGS = 0,
        ASYNC_RECONNECT_UNBLOCK = 1
    };

    HRESULT EndReconnect( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin );
    HRESULT EndReconnectInternal( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin );
    void ReleaseReconnectResources( ASYNC_RECONNECT_FLAGS arfFlags );

public:
    bool AsyncReconnectInProgress( void ) const;
    CQCOMInt<IGraphBuilder> *m_pGraph;

private:
    HANDLE m_hPendingReconnectBlockEvent;
    CComPtr<IPinFlowControl> m_pPendingReconnectOutputPin;

};


// Our message number
#define WM_USER_EC_EVENT WM_USER + 73


// a CRect's width or height must not exceed 0x8000
#define MAX_DOCUMENT_SIZE 32767
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\bnetdoc.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetdoc.cpp : defines CBoxNetDoc
//

#include "stdafx.h"
#include <wininet.h>
#include "rndrurl.h"
#include "congraph.h"
#include <evcode.h>
#include "filtervw.h"
#include "gstats.h"
#include "DCF.h"
#include <atlimpl.cpp>
#include "Reconfig.h"
#include "GEErrors.h"

#ifndef OATRUE
#define OATRUE (-1)
#define OAFALSE (0)
#endif


// !!!! should be in public header!
EXTERN_GUID(IID_IXMLGraphBuilder,
0x1bb05960, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

interface IXMLGraphBuilder : IUnknown
{
    STDMETHOD(BuildFromXML) (IGraphBuilder *pGraph, IXMLElement *pxml) = 0;
    STDMETHOD(SaveToXML) (IGraphBuilder *pGraph, BSTR *pbstrxml) = 0;
    STDMETHOD(BuildFromXMLFile) (IGraphBuilder *pGraph, WCHAR *wszFileName, WCHAR *wszBaseURL) = 0;
};

// CLSID_XMLGraphBuilder
// {1BB05961-5FBF-11d2-A521-44DF07C10000}
EXTERN_GUID(CLSID_XMLGraphBuilder,
0x1bb05961, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);
// !!!!!!!!!!!!!!!
// !!!!!!!!!

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CBoxNetDoc, CDocument)

static BOOL GetErrorText( CString& str, HRESULT hr )
{
    UINT nResource;

    switch( hr ){
    case STG_E_FILENOTFOUND:
        nResource = IDS_FILENOTFOUND;
        break;

    case STG_E_ACCESSDENIED:
        nResource = IDS_ACCESSDENIED;
        break;

    case STG_E_FILEALREADYEXISTS:
        nResource = IDS_NOTSTORAGEOBJECT;;
        break;

    case STG_E_TOOMANYOPENFILES:
        nResource = IDS_TOOMANYOPENFILES;
        break;

    case STG_E_INSUFFICIENTMEMORY:
        nResource = IDS_INSUFFICIENTMEMORY;
        break;

    case STG_E_INVALIDNAME:
        nResource = IDS_INVALIDNAME;
        break;

    case STG_E_SHAREVIOLATION:
    case STG_E_LOCKVIOLATION:
        nResource = IDS_FILE_ALREADY_OPEN;
        break;

    case HRESULT_FROM_WIN32( ERROR_NOT_READY ):
        nResource = IDS_DEVICE_NOT_READY;
        break;

    default:
        return FALSE;
    }

    str.LoadString( nResource );
    return TRUE;

}

static void DisplayErrorMessage( HRESULT hr )
{
    CString str;

    if( GetErrorText( str, hr ) )
        AfxMessageBox( str );
    else
        DisplayQuartzError( IDS_GENERAL_FILE_OPEN, hr );
}

//
// Constructor
//
CBoxNetDoc::CBoxNetDoc()
    : m_pGraph(NULL)
    , m_pMediaEvent(NULL)
    , m_hThread(NULL)
    , m_hWndPostMessage(NULL)
    , m_bNewFilenameRequired(FALSE)
    , m_State(Stopped)
    , m_fUsingClock(FALSE)
    , m_fConnectSmart(TRUE)
    , m_fAutoArrange(TRUE)
    , m_fRegistryChanged(FALSE)
    , m_pMarshalStream(NULL)
    , m_psockSelected(NULL)
    , m_hPendingReconnectBlockEvent(NULL)
    , m_bNew(0)
    , m_nLive(0)
    , m_nSeekOnRun(UNDEFINED)
{

    m_phThreadData[0] = NULL;
    m_phThreadData[1] = NULL;
    m_phThreadData[2] = NULL;

    m_tszStgPath[0] = TEXT('\0');
    m_lSourceFilterCount=0;

    //
    // I am assuming that OLECHAR == WCHAR
    //  (which is true for WIN32 && !OLE2ANSI - which is true since MFC40)
    //
    ASSERT(sizeof(OLECHAR) == sizeof(WCHAR));
}

const OLECHAR CBoxNetDoc::m_StreamName[] = L"ActiveMovieGraph"; // DON'T LOCALISE

//
// m_iMaxInsertFilters
//
// the maximum length of the insert menu
// need hard coded restriction for message map
const int CBoxNetDoc::m_iMaxInsertFilters = 1000;


//
// Destructor
//
CBoxNetDoc::~CBoxNetDoc() {
    ASSERT(m_lstUndo.GetCount() == 0);
    ASSERT(m_lstRedo.GetCount() == 0);
    ASSERT(m_lstLinks.GetCount() == 0);
    ASSERT(m_lstBoxes.GetCount() == 0);
    CFilterView::DelFilterView();
    CGraphStats::DelGraphStats();

    ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );
}

//
// OnNewDocument
//
// Instantiate a graph and mapper for this document.
BOOL CBoxNetDoc::OnNewDocument() {

    if (!CDocument::OnNewDocument())
        return FALSE;

    //
    // We don't have a path to the storage anymore
    //
    m_tszStgPath[0] = TEXT('\0');

    if (!CreateGraphAndMapper()) {
        AfxMessageBox(IDS_CANTINITQUARTZ);
        return FALSE;
    }

    m_State = Stopped;

    // saves are allowed even if there is nothing to be saved.
    m_bNewFilenameRequired = FALSE;
    m_sOriginalPath.Empty();

    m_bNew = TRUE;

    return TRUE;
}

void CBoxNetDoc::OnCloseDocument( )
{
    // We need to close down the thread here as the view window
    // (and thus m_hWndPostMessage) will have been destroyed by the time
    // that CDocument::OnCloseDocument calls DeleteContents.
    CloseDownThread();
    CDocument::OnCloseDocument();
}

//
// DeleteContents
//
// Release the Quartz Graph & mapper
// NB DeleteContents & OnNewDocument are not called symmetrically,
//    so treat the interface pointers with care.
void CBoxNetDoc::DeleteContents(void) {

    ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );

    // !!! why do we think we need to disconnect everything here?
    CloseDownThread();

    // flush the Undo & redo lists, as the graph & mapper interfaces the commands
    // use are about to become invalid.
    m_lstUndo.DeleteRemoveAll();
    m_lstRedo.DeleteRemoveAll();

    //
    // Disconnect each link item and delete it
    //
    while ( m_lstLinks.GetCount() > 0 ) {
        delete m_lstLinks.RemoveHead();
    }

    m_lstBoxes.DeleteRemoveAll();

/*
    if (m_pUnkSeekProvider)
    {
        m_pSeekProvider->SetDoc(NULL);
        m_pUnkSeekProvider->Release();
        m_pUnkSeekProvider = NULL;
        m_pSeekProvider = NULL; // don't delete; jsut release the IUnknown
    }
*/
    delete m_pGraph, m_pGraph = NULL;

    delete m_pMediaEvent, m_pMediaEvent = NULL;
}

//
// CloseDownThread
//
void CBoxNetDoc::CloseDownThread()
{
    //
    // Tell the thread which waits for graph notifications to terminate
    // itself. If it is done, close the handles
    //
    if (m_phThreadData[1] && m_hThread) {
        SetEvent(m_phThreadData[1]);
        WaitForSingleObject(m_hThread, INFINITE);
    }

    //
    // The thread is closed. Remove all remaining WM_USER_EC_EVENT
    // message from the message queue and free the memory we allocated.
    //
    if( m_hWndPostMessage ){
        MSG Msg;
        while ( PeekMessage(&Msg, m_hWndPostMessage, WM_USER_EC_EVENT, WM_USER_EC_EVENT, PM_REMOVE) ) {
            NetDocUserMessage *plParams = (NetDocUserMessage *)Msg.lParam;
            // should call this function, so that filter graph manager can cleanup
            IEvent()->FreeEventParams(plParams->lEventCode, plParams->lParam1, plParams->lParam2);
            delete plParams;
            plParams = NULL;
        }
        m_hWndPostMessage = NULL;
    }


    if (m_hThread) {
        if (!CloseHandle(m_hThread)) {
            TRACE("Closing thread handle failed\n");
        }
        m_hThread = NULL;
    }

    //
    // Don't close m_phThreadData[0], as it is owned by GetEventHandle
    //

    if (m_phThreadData[1] != NULL) {
        if (!CloseHandle(m_phThreadData[1])) {
            TRACE("Closing event handle 1 failed\n");
        }
        m_phThreadData[1] = NULL;
    }
    if (m_phThreadData[2] != NULL) {
        if (!CloseHandle(m_phThreadData[2])) {
            TRACE("Closing event handle 2 failed\n");
        }
        m_phThreadData[2] = NULL;
    }
}

BOOL CBoxNetDoc::AttemptFileRender( LPCTSTR lpszPathName)
{
    if (!OnNewDocument())
        return FALSE;

    m_bNew = FALSE;

    CmdDo(new CCmdRenderFile(CString(lpszPathName)) );

    // BUG? What if that failed? We have destroyed our previous graph for nothing

    SetModifiedFlag( FALSE );
    m_State = Stopped;

    m_bNewFilenameRequired = TRUE;
    m_sOriginalPath = lpszPathName;

    return TRUE;
}

BOOL CBoxNetDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    CBoxNetDoc* pDoc = NULL;
    CGraphDocTemplate* pDocTemplate = GBL(m_pDocTemplate);

    if (pDocTemplate->GetCount() == 2) 
    {
        POSITION pos = pDocTemplate->GetFirstDocPosition();
        pDoc = (CBoxNetDoc*) pDocTemplate->GetNextDoc(pos);
        if (pDoc == this)
        {
            pDoc = (CBoxNetDoc*) pDocTemplate->GetNextDoc(pos);
        }

        if (pDoc && !pDoc->IsModified() && pDoc->IsNew())
        {
            // Close it if we open another one
        }
        else
        {
            // Do not close it
            pDoc = NULL;
        }
    }

    BOOL rv = OnOpenDocumentInternal(lpszPathName);

    if (pDoc)
    {
        // Close it
        pDoc->OnFileClose();
    }

    return rv;
}

//
// OnOpenDocumentInternal
//
// If this file is a storage, look for a "Graph" stream in it.
// If found, try passing it to the graph as a serialized graph.
// If not found, fail (wrong format file)
// If not a storage, try renderfile'ing it into the current document.
BOOL CBoxNetDoc::OnOpenDocumentInternal(LPCTSTR lpszPathName) {

    HRESULT hr;

    if (!CreateGraphAndMapper()) {
        AfxMessageBox(IDS_CANTINITQUARTZ);
        return FALSE;
    }

    WCHAR * pwcFileName;

#ifndef UNICODE
    WCHAR wszPathName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, lpszPathName, -1, wszPathName, MAX_PATH);
    pwcFileName = wszPathName;
#else
    pwcFileName = lpszPathName;
#endif

    if (0 == lstrcmpi(lpszPathName + lstrlen(lpszPathName) - 3, TEXT("xgr"))) {
        BeginWaitCursor();

        IXMLGraphBuilder *pxmlgb;
        HRESULT hr = CoCreateInstance(CLSID_XMLGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                      IID_IXMLGraphBuilder, (void**)&pxmlgb);

        if (SUCCEEDED(hr)) {
            DeleteContents();

            if (!CreateGraphAndMapper()) {
                pxmlgb->Release();

                AfxMessageBox(IDS_CANTINITQUARTZ);
                return FALSE;
            }

            hr = pxmlgb->BuildFromXMLFile(IGraph(), pwcFileName, NULL);

            pxmlgb->Release();

            SetModifiedFlag(FALSE);
        }

        UpdateFilters();

        EndWaitCursor();

        if (SUCCEEDED(hr))
            return TRUE;

        DisplayQuartzError( IDS_FAILED_TO_LOAD_GRAPH, hr );

        return FALSE;
    } else if (0 != lstrcmpi(lpszPathName + lstrlen(lpszPathName) - 3, TEXT("grf"))) {
        return AttemptFileRender( lpszPathName );
    }

    CComPtr<IStorage> pStr;

    hr = StgOpenStorage( pwcFileName
                         , NULL
                         ,  STGM_TRANSACTED | STGM_READ
                         , NULL
                         , 0
                         , &pStr
                         );


    // If it is not a storage object. Try render it...
    if( hr == STG_E_FILEALREADYEXISTS ) {
        return AttemptFileRender( lpszPathName );
    }

    // Other error
    if( FAILED( hr ) ){
        DisplayErrorMessage( hr );
        return FALSE;
    }

    // else open must have suceeded.
    DeleteContents();

    try{

        if (!CreateGraphAndMapper()) {
            AfxMessageBox(IDS_CANTINITQUARTZ);
            return FALSE;
        }

        // Get an interface to the graph's IPersistStream and ask it to load
        CQCOMInt<IPersistStream> pips(IID_IPersistStream, IGraph());

        IStream * pStream;

        // Open the filtergraph stream in the file
        hr = pStr->OpenStream( m_StreamName
                                      , NULL
                                      , STGM_READ|STGM_SHARE_EXCLUSIVE
                                      , 0
                                      , &pStream
                                      );

        // Something went wrong. Attempt to render the file
        if( FAILED( hr ) ) {
            return AttemptFileRender( lpszPathName );
        }

        hr = pips->Load(pStream);
        pStream->Release();

        if (SUCCEEDED(hr)) {    // the graph liked it. we're done
            m_State = Stopped;
            UpdateFilters();
            UpdateClockSelection();
            SetModifiedFlag(FALSE);

            //
            // remember the path to this storage
            //
            _tcsncpy(m_tszStgPath, lpszPathName, MAX_PATH);

            return TRUE;
        }

        //
        // Might have been a valid graph, but we are missing the media
        // files used in the graph.
        //
        if ((HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND)
            || (HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND))
        {
            AfxMessageBox(IDS_MISSING_FILE_IN_GRAPH);
        } else {
            DisplayQuartzError( IDS_FAILED_TO_LOAD_GRAPH, hr );
        }

    }
    catch (CHRESULTException) {
        AfxMessageBox(IDS_NOINTERFACE);
    }

    return FALSE;
}


void CBoxNetDoc::OnConnectToGraph()
{
    IUnknown *punkGraph;
#if 0
    // experimental code to connect to garph on other machines....
    COSERVERINFO server;
    server.dwReserved1 = 0;
    server.pwszName = L"\\\\davidmay9";
    server.pAuthInfo = NULL;
    server.dwReserved2 = 0;

    MULTI_QI mqi;
    mqi.pIID = &IID_IUnknown;
    mqi.pItf = NULL;

    HRESULT hr = CoCreateInstanceEx(CLSID_FilterGraph, NULL,
                                    CLSCTX_REMOTE_SERVER, &server,
                                    1, &mqi);

    if (FAILED(hr))
        return;
    punkGraph = mqi.pItf;

#else
#if 0
    {
        const TCHAR szRegKey[] = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\FilterGraph");
        const TCHAR szRegName[] = TEXT("Add To ROT on Create");

        HKEY hKey = 0;
        LONG lRet;

        DWORD dwValue = 0;
        DWORD dwDisp;
        lRet = RegCreateKeyEx(HKEY_CURRENT_USER, szRegKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                              MAXIMUM_ALLOWED, NULL, &hKey, &dwDisp);

        if (lRet == ERROR_SUCCESS) {
            DWORD   dwType, dwLen;

            dwLen = sizeof(DWORD);
            RegQueryValueEx(hKey, szRegName, 0L, &dwType, (LPBYTE)&dwValue, &dwLen);
        }
        if (!dwValue) {
            int iChoice = AfxMessageBox(IDS_GRAPHSPY_NOT_ENABLED, MB_YESNO);

            if (iChoice == IDYES) {
                // change registry entry

                dwValue = 1;
                lRet = RegSetValueEx( hKey, szRegName, 0, REG_DWORD,
                                      (unsigned char *)&dwValue, sizeof(dwValue) );

            }

            // in either case, it won't work this time
            return;
        }

        if (hKey) {
            RegCloseKey(hKey);
        }
    }
#endif

    IMoniker *pmk;

    IRunningObjectTable *pirot;
    if (FAILED(GetRunningObjectTable(0, &pirot)))
        return;

    CConGraph dlgConnectToGraph(&pmk, pirot, AfxGetMainWnd());

    if (dlgConnectToGraph.DoModal() != IDOK || pmk == NULL) {
        pirot->Release();
        return;
    }

    HRESULT hr = pirot->GetObject(pmk, &punkGraph);
    pirot->Release();
#endif

    if (SUCCEEDED(hr)) {
        IGraphBuilder *pGraph;

        hr = punkGraph->QueryInterface(IID_IGraphBuilder, (void **) &pGraph);
        punkGraph->Release();

        if (SUCCEEDED(hr)) {
            DeleteContents();

            m_pGraph = new CQCOMInt<IGraphBuilder>(IID_IGraphBuilder, pGraph);
            pGraph->Release();

            // really just create all *but* the graph, of course
            if (!CreateGraphAndMapper()) {
                AfxMessageBox(IDS_CANTINITQUARTZ);
                return;
            }

            m_State = Stopped; // !!! get from graph?
            m_bNewFilenameRequired = TRUE;
            m_sOriginalPath.Empty();

            UpdateFilters();
            SetModifiedFlag(FALSE);
        }
    }
    else
    {
        char buf[128];

        sprintf(buf, "Failed to connect to graph, hr = 0x%x", hr);
        AfxMessageBox(buf);
    }
}


//
// SaveModified
//
// Only save the document if the filter graph needs saving
BOOL CBoxNetDoc::SaveModified(void) {

    // HRESULT hr = (*m_pPerStorage)->IsDirty();
    HRESULT hr = S_OK;
    if (hr == S_OK) {
// Disable Save
        return CDocument::SaveModified();
    }
    else if (hr == S_FALSE) {
        return TRUE;
    }
    else {
        //
        // We need to return here to allow file.new / file.exit
        // - this can happen after a unsucessful load on a storage
        //   (eg missing media file in the graph)
        return TRUE;
    }
}

// WriteString
//
// Helper function to facilitate writing text to a file
//
void CBoxNetDoc::WriteString(HANDLE hFile, LPCTSTR lptstr, ...)
{
    DWORD cbWritten = 0;
    TCHAR atchBuffer[MAX_STRING_LEN];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, lptstr);

    wvsprintf(atchBuffer, lptstr, va);

    DWORD cbToWrite=lstrlen(atchBuffer)*sizeof(TCHAR);

    if (!WriteFile(hFile, atchBuffer, cbToWrite, &cbWritten, NULL) ||
            (cbWritten != cbToWrite))
        AfxMessageBox(IDS_SAVE_HTML_ERR);
}

// GetNextOutFilter
//
// This function does a linear search and returns in iOutFilter the index of
// first filter in the filter information table  which has zero unconnected
// input pins and atleast one output pin  unconnected.
// Returns FALSE when there are none o.w. returns TRUE
//
BOOL CBoxNetDoc::GetNextOutFilter(FILTER_INFO_TABLE &fit, int *iOutFilter)
{
    for (int i=0; i < fit.iFilterCount; ++i) {
        if ((fit.Item[i].dwUnconnectedInputPins == 0) &&
                (fit.Item[i].dwUnconnectedOutputPins > 0)) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // then things with more outputs than inputs
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > fit.Item[i].dwUnconnectedInputPins) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // if that doesn't work, find one that at least has unconnected output pins....
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > 0) {
            *iOutFilter=i;
            return TRUE;
        }
    }
    return FALSE;
}

// LocateFilterInFIT
//
// Returns the index into the filter information table corresponding to
// the given IBaseFilter
//
int CBoxNetDoc::LocateFilterInFIT(FILTER_INFO_TABLE &fit, IBaseFilter *pFilter)
{
    int iFilter=-1;
    for (int i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].pFilter == pFilter)
            iFilter=i;
    }

    return iFilter;
}

// MakeScriptableFilterName
//
// Replace any spaces and minus signs in the filter name with an underscore.
// If it is a source filtername than it actually is a file path (with the
// possibility of some stuff added at the end for uniqueness), we create a good filter
// name for it here.
//
void CBoxNetDoc::MakeScriptableFilterName(WCHAR awch[], BOOL bSourceFilter)
{
    if (bSourceFilter) {
        WCHAR awchBuf[MAX_FILTER_NAME];
        BOOL bExtPresentInName=FALSE;
        int iBuf=0;
        for (int i=0; awch[i] != L'\0';++i) {
            if (awch[i]==L'.' && awch[i+1]!=L')') {
                for (int j=1; j <=3; awchBuf[iBuf]=towupper(awch[i+j]),++j,++iBuf);
                awchBuf[iBuf++]=L'_';
                wcscpy(&(awchBuf[iBuf]), L"Source_");
                bExtPresentInName=TRUE;
                break;
            }
        }

        // If we have a filename with no extension than create a suitable name

        if (!bExtPresentInName) {
            wcscpy(awchBuf, L"Source_");
        }

        // make source filter name unique by appending digit always, we don't want to
        // bother to make it unique only if its another instance of the same source
        // filter
        WCHAR awchSrcFilterCnt[10];
        wcscpy(&(awchBuf[wcslen(awchBuf)]),
                _ltow(m_lSourceFilterCount++, awchSrcFilterCnt, 10));
        wcscpy(awch, awchBuf);
    } else {

        for (int i = 0; i < MAX_FILTER_NAME; i++) {
            if (awch[i] == L'\0')
                break;
            else if ((awch[i] == L' ') || (awch[i] == L'-'))
                awch[i] = L'_';
        }
    }
}

// PopulateFIT
//
// Scans through all the filters in the graph, storing the number of input and out
// put pins for each filter, and identifying the source filters in the filter
// inforamtion table. The object tag statements are also printed here
//
void CBoxNetDoc::PopulateFIT(HANDLE hFile, IFilterGraph *pGraph, TCHAR atchBuffer[],
        FILTER_INFO_TABLE *pfit)
{
    HRESULT hr;
    IEnumFilters *penmFilters=NULL;
    if (FAILED(hr=pGraph->EnumFilters(&penmFilters))) {
        WriteString(hFile, TEXT("'Error[%x]:EnumFilters failed!\r\n"), hr);
    }

    IBaseFilter *pFilter;
    ULONG n;
    while (penmFilters && (penmFilters->Next(1, &pFilter, &n) == S_OK)) {
    pfit->Item[pfit->iFilterCount].pFilter = pFilter;

        // Get the input and output pin counts for this filter

        IEnumPins *penmPins=NULL;
        if (FAILED(hr=pFilter->EnumPins(&penmPins))) {
            WriteString(hFile, TEXT("'Error[%x]: EnumPins for Filter Failed !\r\n"), hr);
        }

        IPin *ppin = NULL;
        while (penmPins && (penmPins->Next(1, &ppin, &n) == S_OK)) {
            PIN_DIRECTION pPinDir;
            if (SUCCEEDED(hr=ppin->QueryDirection(&pPinDir))) {
                if (pPinDir == PINDIR_INPUT)
                    pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins++;
                else
                    pfit->Item[pfit->iFilterCount].dwUnconnectedOutputPins++;
            } else {
                WriteString(hFile, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
            }

            ppin->Release();
        }

        if (penmPins)
            penmPins->Release();

        // Mark the source filters, remember at this point any filters that have
        // all input pins connected (or don't have any input pins) must be sources

        if (pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins==0)
            pfit->Item[pfit->iFilterCount].IsSource=TRUE;


    if (FAILED(hr=pFilter->QueryFilterInfo(&pfit->Item[pfit->iFilterCount].finfo))) {
        WriteString(hFile, atchBuffer,TEXT("'Error[%x]: QueryFilterInfo Failed!\r\n"),hr);

    } else {
            if (pfit->Item[pfit->iFilterCount].finfo.pGraph) {
                pfit->Item[pfit->iFilterCount].finfo.pGraph->Release();
            }

            MakeScriptableFilterName(pfit->Item[pfit->iFilterCount].finfo.achName,
                    pfit->Item[pfit->iFilterCount].IsSource);
    }

    pfit->iFilterCount++;
    }

    if (penmFilters)
        penmFilters->Release();
}

void CBoxNetDoc::PrintFilterObjects(HANDLE hFile, TCHAR atchBuffer[], FILTER_INFO_TABLE *pfit)
{
    for (int i=0; i < pfit->iFilterCount; i++) {
        IPersist *pPersist = NULL;

        IBaseFilter *pFilter = pfit->Item[i].pFilter;
        HRESULT hr;

        if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IPersist, (void**) &pPersist))) {
            CLSID clsid;

            if (SUCCEEDED(hr=pPersist->GetClassID(&clsid))) {
                WCHAR szGUID[100];
                StringFromGUID2(clsid, szGUID, 100);
                szGUID[37] = L'\0';
                WriteString(hFile, TEXT("<OBJECT ID=%ls CLASSID=\"CLSID:%ls\">"
                       "</OBJECT>\r\n"),
                       pfit->Item[i].finfo.achName, szGUID+1);
            } else {
                WriteString(hFile, TEXT("'Error[%x]: GetClassID for Filter Failed !\r\n"), hr);
            }

            pPersist->Release();
        } else {
            WriteString(hFile, TEXT("'Error[%x]: Filter doesn't support IID_IPersist!\r\n"), hr);
        }
    }
}

//
// PrintGraphAsHTML
//
// Writes an HTML page which instantiates the graph and different filters
// using the <OBJECT> tag and VB script methods to add the different filters
// to the graph and make the connections.
//
void CBoxNetDoc::PrintGraphAsHTML(HANDLE hFile)
{
    HRESULT hr;
    ULONG n;
    IFilterGraph *pGraph = IGraph();
    FILTER_INFO_TABLE fit;
    TCHAR atchBuffer[MAX_STRING_LEN];
    atchBuffer[0]=L'\0';
    ZeroMemory(&fit, sizeof(fit));

    // write the initial header tags and instantiate the filter graph
    WriteString(hFile, TEXT("<HTML>\r\n<HEAD>\r\n<TITLE> Saved Graph </TITLE>\r\n"
            "</HEAD>\r\n<BODY>\r\n<OBJECT ID=Graph CLASSID="
            "\"CLSID:E436EBB3-524F-11CE-9F53-0020AF0BA770\"></OBJECT>\r\n"));

    // Fill up the Filter information table and also print the <OBJECT> tag
    // filter instantiations
    PopulateFIT(hFile, pGraph, atchBuffer, &fit);

    PrintFilterObjects(hFile, atchBuffer, &fit);

    WriteString(hFile, TEXT("<SCRIPT language=\"VBScript\">\r\n<!--\r\n"
            "Dim bGraphRendered\r\nbGraphRendered=False\r\n"
            "Sub Window_OnLoad()\r\n"));

    // write the declarations (Dim statement) for the FilterInfo variables
    // which will be returned by AddFilter
    int i;
    for (i = 0; i < fit.iFilterCount; i++) {
        if (fit.Item[i].IsSource) {
            WriteString(hFile, TEXT("\tDim %ls_Info\r\n"), fit.Item[i].finfo.achName);
        }
    }

    // Put the conditional if statement for adding filters and connecting, we don't
    // want to reconnect every the user comes back to this page and Window_OnLoad()
    // gets called
    WriteString(hFile, TEXT("\tif bGraphRendered = False Then\r\n"));

    // write the statements for adding the different filters to the graph, make
    // sure we treat the source filters special since they also will need a
    // a filename
    for (i = fit.iFilterCount-1; i >=0 ; i--) {
        if (fit.Item[i].IsSource) {
            WriteString(hFile, TEXT("\t\tset %ls_Info=Graph.AddFilter(%ls, \"%ls\")\r\n"),
                    fit.Item[i].finfo.achName, fit.Item[i].finfo.achName,
                    fit.Item[i].finfo.achName);

            IFileSourceFilter *pFileSourceFilter=NULL;
            if (FAILED(hr=fit.Item[i].pFilter->QueryInterface(IID_IFileSourceFilter,
                        reinterpret_cast<void **>(&pFileSourceFilter)))) {
                WriteString(hFile, TEXT("'Error[%x]: Couldn't get IFileSourceFilter interface"
                        "from source filter!\r\n"), hr);
            } else {

                LPWSTR lpwstr;
                hr = pFileSourceFilter->GetCurFile(&lpwstr, NULL);
                pFileSourceFilter->Release();

                if (FAILED(hr)) {
                WriteString(hFile,
                            TEXT("'Error[%x]: IFileSourceFilter::GetCurFile failed\r\n"), hr);
                } else {
                    WriteString(hFile, TEXT("\t\t%ls_Info.Filename=\"%ls\"\r\n"),
                            fit.Item[i].finfo.achName, lpwstr);
                    CoTaskMemFree(lpwstr);
                }
            }
        } else {
            WriteString(hFile, TEXT("\t\tcall Graph.AddFilter(%ls, \"%ls\")\r\n"),
                    fit.Item[i].finfo.achName, fit.Item[i].finfo.achName);
        }
    }

    // Find a filter with zero unconnected input pins and > 0 unconnected output pins
    // Connect the output pins and subtract the connections counts for that filter.
    // Quit when there is no such filter left
    for (i=0; i< fit.iFilterCount; i++) {
        int iOutFilter=-1; // index into the fit
        if (!GetNextOutFilter(fit, &iOutFilter))
            break;
        ASSERT(iOutFilter !=-1);
        IEnumPins *penmPins=NULL;
        if (FAILED(hr=fit.Item[iOutFilter].pFilter->EnumPins(&penmPins))) {
            WriteString(hFile, TEXT("'Error[%x]: EnumPins failed for Filter!\r\n"), hr);
        }
        IPin *ppinOut=NULL;
        while (penmPins && (penmPins->Next(1, &ppinOut, &n)==S_OK)) {
            PIN_DIRECTION pPinDir;
            if (FAILED(hr=ppinOut->QueryDirection(&pPinDir))) {
                WriteString(hFile, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
                ppinOut->Release();
                continue;
            }
            if (pPinDir == PINDIR_OUTPUT) {
                LPWSTR pwstrOutPinID;
                LPWSTR pwstrInPinID;
                IPin *ppinIn=NULL;
                PIN_INFO pinfo;
                FILTER_INFO finfo;
                if (FAILED(hr=ppinOut->QueryId(&pwstrOutPinID))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinOut->ConnectedTo(&ppinIn))) {

                    // It is ok if a particular pin is not connected since we allow
                    // a pruned graph to be saved
                    if (hr == VFW_E_NOT_CONNECTED) {
                        fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                    } else {
                        WriteString(hFile, TEXT("'Error[%x]: ConnectedTo Failed! \r\n"), hr);
                    }
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinIn->QueryId(&pwstrInPinID))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                if (FAILED(hr=ppinIn->QueryPinInfo(&pinfo))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryPinInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                ppinIn->Release();
                if (pinfo.pFilter) {
                    pinfo.pFilter->Release();
                }
                int iToFilter = LocateFilterInFIT(fit, pinfo.pFilter);
                ASSERT(iToFilter < fit.iFilterCount);
                if (FAILED(hr=pinfo.pFilter->QueryFilterInfo(&finfo))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryFilterInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                if (finfo.pGraph) {
                    finfo.pGraph->Release();
                }
                MakeScriptableFilterName(finfo.achName, fit.Item[iToFilter].IsSource);
                WriteString(hFile, TEXT("\t\tcall Graph.ConnectFilters(%ls,"
                        "\"%ls\", %ls,\"%ls\")\r\n"), fit.Item[iOutFilter].finfo.achName,
                        pwstrOutPinID, finfo.achName, pwstrInPinID);

                CoTaskMemFree(pwstrOutPinID);
                CoTaskMemFree(pwstrInPinID);

                // decrement the count for the unconnected pins for these two filters
                fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                fit.Item[iToFilter].dwUnconnectedInputPins--;
            }
            ppinOut->Release();
        }
        if (penmPins)
            penmPins->Release();
    }

    // Release all the filters in the fit
    for (i = 0; i < fit.iFilterCount; i++)
        fit.Item[i].pFilter->Release();

    WriteString(hFile, TEXT("\t\tbGraphRendered=True\r\n\tend if\r\n"
            "\t'Graph.Control.Run\r\nEnd Sub\r\n"
            "Sub Window_OnUnLoad()\r\n\t'Graph.Control.Stop\r\n"
            "\t'Graph.Position.CurrentPosition=0\r\nEnd Sub\r\n"
            "-->\r\n</SCRIPT>\r\n</BODY>\r\n</HTML>\r\n"));
}


// OnSaveGraphAsHTML
//
// Called when the user selects "Save As HTML" in the File Menu. Puts up
// a Save File dialog, retrieves the filename selected(entered) and opens
// (creates) a file and calls PrintGraphAsHTML for actually saving the graph
// as HTML text.
//
void CBoxNetDoc::OnSaveGraphAsHTML()
{
    CString strExt, strFilter;
    HANDLE hFile;

    strExt.LoadString(IDS_SAVE_HTML_EXT);
    strFilter.LoadString(IDS_SAVE_HTML_FILTER);
    CFileDialog dlgSaveAsHTML(FALSE, strExt, m_strHTMLPath, 0, strFilter,
            AfxGetMainWnd());

    if (dlgSaveAsHTML.DoModal() != IDOK)
        return;

    m_strHTMLPath=dlgSaveAsHTML.GetPathName();

    if ((hFile=CreateFile(m_strHTMLPath, GENERIC_WRITE, FILE_SHARE_READ,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        AfxMessageBox(IDS_SAVE_HTML_FILE_ERR);
        return;
    }

    m_lSourceFilterCount=0;

    HRESULT hr = SafePrintGraphAsHTML( hFile );

    CloseHandle(hFile);

    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }
}

// OnSaveGraphAsXML
//
// Called when the user selects "Save As XML" in the File Menu. Puts up
// a Save File dialog, retrieves the filename selected(entered) and opens
// (creates) a file and calls PrintGraphAsXML for actually saving the graph
// as XML text.
//
void CBoxNetDoc::OnSaveGraphAsXML()
{
    CString strExt, strFilter;
    HANDLE hFile;

    strExt.LoadString(IDS_SAVE_XML_EXT);
    strFilter.LoadString(IDS_SAVE_XML_FILTER);
    CFileDialog dlgSaveAsXML(FALSE, strExt, m_strXMLPath, OFN_OVERWRITEPROMPT, strFilter,
            AfxGetMainWnd());

    if (dlgSaveAsXML.DoModal() != IDOK)
        return;

    m_strXMLPath=dlgSaveAsXML.GetPathName();

    if ((hFile=CreateFile(m_strXMLPath, GENERIC_WRITE, FILE_SHARE_READ,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        AfxMessageBox(IDS_SAVE_XML_FILE_ERR);
        return;
    }

    IXMLGraphBuilder *pxmlgb;
    HRESULT hr = CoCreateInstance(CLSID_XMLGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                  IID_IXMLGraphBuilder, (void**)&pxmlgb);

    if (SUCCEEDED(hr)) {
        BSTR bstrXML;
        hr = pxmlgb->SaveToXML(IGraph(), &bstrXML);

        if (SUCCEEDED(hr)) {
            DWORD cbToWrite = SysStringLen(bstrXML) * 2 + 1;
            char *pszXML = new char[cbToWrite];

            if (pszXML) {
                WideCharToMultiByte(CP_ACP, 0,
                                    bstrXML, -1,
                                    pszXML, cbToWrite,
                                    NULL, NULL);
                cbToWrite = lstrlenA(pszXML);

                DWORD cbWritten;
                if (!WriteFile(hFile, pszXML, cbToWrite, &cbWritten, NULL) ||
                    (cbWritten != cbToWrite)) {

                    hr = E_FAIL;
                }

                delete[] pszXML;
            }

            SysFreeString(bstrXML);
        }
        pxmlgb->Release();
    }

    if (FAILED(hr)) {
        AfxMessageBox(IDS_SAVE_XML_FILE_ERR);
    }

    CloseHandle(hFile);
    return;
}

//
// OnSaveDocument
//
// This method will be called during the SAVE and SAVE AS operations.
//
//
BOOL CBoxNetDoc::OnSaveDocument(LPCTSTR lpszPathName) {


    HRESULT hr;

        //
        // SAVE AS
        //

        LPOLESTR oleszPath;

#ifndef UNICODE
        WCHAR wszPath[MAX_PATH];

        MultiByteToWideChar(CP_ACP, 0, lpszPathName, -1, wszPath, MAX_PATH);

        oleszPath = wszPath;
#else
        oleszPath = (LPOLESTR) lpszPathName;  // cast away const
#endif

        // Although File|Save is disabled when m_bNewFilenameRequired is set,
        // it is possible to get here with the original path name by trying
        // to close the window. StgCreateDocfile is broken on Win2K and Whistler
        // in that although it fails to open the file in exclusive share mode,
        // it wipes out the contents of the file. 
        if (m_bNewFilenameRequired && m_sOriginalPath.CompareNoCase(lpszPathName) == 0)
        {
            CString s("The graph will be saved to the file ");
            
            s += m_sOriginalPath + "\nand the original file contents will be lost.\n\n"
                "Do you wish to save the graph to a different file?\n\n"
                "(Hitting \"No\" will save the graph to the file.)";

            switch (AfxMessageBox(s, MB_YESNOCANCEL|MB_ICONQUESTION))
            {
            case IDCANCEL:
                return FALSE;

            case IDNO:
                break;

            case IDYES:
                return DoSave(NULL);
            }
        }

    CComPtr<IStorage> pStr = NULL;
    hr = StgCreateDocfile( oleszPath
                           ,  STGM_CREATE
                           | STGM_TRANSACTED
                           | STGM_READWRITE
                           | STGM_SHARE_EXCLUSIVE
                           , 0
                           , &pStr
                           );
    if(FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    IStream * pStream;

    // Open the filtergraph stream in the file
    hr = pStr->CreateStream( m_StreamName
                             , STGM_WRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE
                             , 0
                             , 0
                             , &pStream
                             );
    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    // Get an interface to the graph's IPersistStream
    CQCOMInt<IPersistStream> pips(IID_IPersistStream, IGraph());

    hr = pips->Save(pStream, TRUE);

    pStream->Release();

    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    hr = pStr->Commit(STGC_DEFAULT);
    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    m_bNewFilenameRequired = FALSE;
    SetModifiedFlag(FALSE);
    m_sOriginalPath.Empty();

    return TRUE;
}

void CBoxNetDoc::SetTitle( LPCTSTR lpszTitle )
{
    if( m_bNewFilenameRequired ){
        CString strTitle( lpszTitle );
        CString strUntitled;

        strUntitled.LoadString(AFX_IDS_UNTITLED);

        if( strUntitled != strTitle ){
            CString strReadOnly;

            strReadOnly.LoadString( IDS_READ_ONLY );
            strTitle += strReadOnly;
        }
        CDocument::SetTitle( strTitle );

    }
    else
        CDocument::SetTitle( lpszTitle );

}


/////////////////////////////////////////////////////////////////////////////
// diagnostics


#ifdef _DEBUG
void CBoxNetDoc::AssertValid() const
{
    CDocument::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CBoxNetDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);

    dc << TEXT("IFilterGraph :") << IGraph() << TEXT("\n");
    dc << m_lstLinks;
    dc << m_lstBoxes;

}

void CBoxNetDoc::MyDump(CDumpContext& dc) const
{
    dc << TEXT("========= BNETDOC Dump =============\n");
    dc << TEXT("FilterGraph:  ") << (void *)IGraph() << TEXT("\n");

    //
    // Output box information
    //
    dc << TEXT("-------- Boxes --------------\n");

    POSITION pos = m_lstBoxes.GetHeadPosition();
    while (pos != NULL) {
        CBox * pBox = m_lstBoxes.GetNext(pos);

        pBox->MyDump(dc);
    }

    //
    // Output link informatin
    //
    dc << TEXT("--------- Links ---------------\n");

    pos = m_lstLinks.GetHeadPosition();
    while (pos != NULL) {
        CBoxLink * pLink = m_lstLinks.GetNext(pos);

        pLink->MyDump(dc);
    }

    dc << TEXT("========== (end) ============\n");

}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// general functions


/* ModifiedDoc(pSender, lHint, pHint)
 *
 * Indicates that the document has been modified.  The parameters are passed
 * to UpdateAllViews().
 */
void CBoxNetDoc::ModifiedDoc(CView* pSender, LPARAM lHint, CObject* pHint)
{
    SetModifiedFlag(TRUE);
    UpdateAllViews(pSender, lHint, pHint);
}


/* DeselectAll()
 *
 * Deselect all objects that can be selected, including objects for which
 * the document maintains the selection state and document for which
 * views maintain the selection state.
 */
void CBoxNetDoc::DeselectAll()
{
    UpdateAllViews(NULL, CBoxNetDoc::HINT_CANCEL_VIEWSELECT);
    SelectBox(NULL, FALSE);
    SelectLink(NULL, FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// CBox lists and box selection


/* GetBoundingRect(prc, fBoxSel)
 *
 * Set <*prc> to be the bounding rectangle around all items
 * (if <fBoxSel> is FALSE) or around selected boxes (if <fBoxSel>
 * is TRUE).  If there are no items in the bounding rectangle,
 * the null rectangle (all fields zero) is returned.
 */
void CBoxNetDoc::GetBoundingRect(CRect *prc, BOOL fBoxSel)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    BOOL            fNoBoxFoundYet = TRUE;

    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) m_lstBoxes.GetNext(pos);
        if (!fBoxSel || pbox->IsSelected())
        {
            if (fNoBoxFoundYet)
            {
                *prc = pbox->GetRect();
                fNoBoxFoundYet = FALSE;
            }
            else
                prc->UnionRect(prc, &pbox->GetRect());
        }
    }

    if (fNoBoxFoundYet)
        prc->SetRectEmpty();
}


/* SelectBox(pbox, fSelect)
 *
 * Select <pbox> if <fSelect> is TRUE, deselect if <fSelect> is FALSE.
 * If <pbox> is NULL, do the same for all boxes in the document.
 */
void CBoxNetDoc::SelectBox(CBox *pbox, BOOL fSelect)
{
    if (pbox == NULL)
    {
        POSITION        pos;            // position in linked list

        // enumerate all boxes in document
        for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
        {
            pbox = (CBox *) m_lstBoxes.GetNext(pos);
            SelectBox(pbox, fSelect);
        }

        return;
    }

    // do nothing if box is already selected/deselected as requested
    if (fnorm(fSelect) == fnorm(pbox->IsSelected()))
        return;

    // repaint <pbox>
    pbox->SetSelected(fSelect);
    UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_BOX, pbox);

    if (pbox->IsSelected()) {   // select its links

        CBoxSocket *psock;
        CSocketEnum NextSocket(pbox);
        while ( 0 != (psock = NextSocket())) {

            if (psock->IsConnected()) {
                SelectLink(psock->m_plink, TRUE);
            }
        }
    }

}


//
// SelectLink
//
// do plink->SetSelected(fSelect) iff plink !=NULL
// otherwise SetSelect all links
void CBoxNetDoc::SelectLink(CBoxLink *plink, BOOL fSelect) {

    if (plink == NULL) {    // select all

        POSITION posNext = m_lstLinks.GetHeadPosition();

        while (posNext != NULL) {

             SelectLink(m_lstLinks.GetNext(posNext), fSelect);
        }
        return;
    }

    if (fnorm(fSelect) == fnorm(plink->IsSelected())) {
        return; // already as requested
    }

    plink->SetSelected(fSelect);
    UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);
}


//
// IsBoxSelectionEmpty
//
// Return TRUE if no boxes are selected, FALSE otherwise.
BOOL CBoxNetDoc::IsBoxSelectionEmpty() {

    POSITION pos = m_lstBoxes.GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
            return FALSE;
    }

    // no selected box found
    return TRUE;
}


//
// IsLinkSelectionEmpty
//
// Return TRUE if no links are selected, FALSE otherwise.
BOOL CBoxNetDoc::IsLinkSelectionEmpty() {

    POSITION    pos = m_lstLinks.GetHeadPosition();

    while (pos != NULL) {

        CBoxLink *plink = m_lstLinks.GetNext(pos);
        if (plink->IsSelected()) {
            return FALSE;
        }
    }

    // no selected link found
    return TRUE;
}

/* GetBoxes(plstDst, fSelected)
 *
 * Call RemoveAll() on <plstDst>, then add pointers to each selected CBox
 * (if <fSelected> is TRUE) or each CBox (if <fSelected> is FALSE) in the
 * CBoxNetDoc to <plstDst>.
 */
void CBoxNetDoc::GetBoxes(CBoxList *plstDst, BOOL fSelected)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    plstDst->RemoveAll();
    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = m_lstBoxes.GetNext(pos);
        if (!fSelected || pbox->IsSelected())
            plstDst->AddTail(pbox);
    }
}


/* SetBoxes(plstSrc, fSelected)
 *
 * Set the selection (if <fSelected> is TRUE) or the current list of boxes
 * (if <fSelected> is FALSE) to be the elements in <plstSrc> (which should be
 * a list of CBox pointers).  In the latter case, <plstSrc> is copied, so
 * the caller is responsible for later freeing <plstSrc>.
 */
void CBoxNetDoc::SetBoxes(CBoxList *plstSrc, BOOL fSelected)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    if (fSelected)
    {
        DeselectAll();

        // select all in <plstSrc>
        for (pos = plstSrc->GetHeadPosition(); pos != NULL; )
        {
            pbox = plstSrc->GetNext(pos);
            SelectBox(pbox, TRUE);
        }
    }
    else
    {
        // empty the list of boxes in the document
        m_lstBoxes.RemoveAll();

        // set the list to be a copy of <plstSrc>
        for (pos = plstSrc->GetHeadPosition(); pos != NULL; )
        {
            pbox = plstSrc->GetNext(pos);
            m_lstBoxes.AddTail(pbox);
            pbox->AddToGraph();
            // pins could have changed
            pbox->Refresh();
        }
    }
}


//
// SelectBoxes
//
// Select the boxes in the supplied list
void CBoxNetDoc::SelectBoxes(CList<CBox *, CBox*> *plst) {

    POSITION posNext = plst->GetHeadPosition();

    while (posNext != NULL) {

        CBox *pbox = plst->GetNext(posNext);
        SelectBox(pbox, TRUE);
    }
}


//
// SelectLinks
//
// Select the links on the supplied list
void CBoxNetDoc::SelectLinks(CList<CBoxLink *, CBoxLink *> *plst) {

    POSITION posNext = plst->GetHeadPosition();

    while (posNext != NULL) {

        CBoxLink *plink = plst->GetNext(posNext);
        SelectLink(plink, TRUE);
    }
}


/* InvalidateBoxes(plst)
 *
 * Causes all boxes in <plst> (a list of CBox objects) to be redrawn.
 */
void CBoxNetDoc::InvalidateBoxes(CBoxList *plst)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    for (pos = plst->GetHeadPosition(); pos != NULL; )
    {
        pbox = plst->GetNext(pos);
        UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_BOX, pbox);
    }
}


/* MoveBoxSelection(sizOffset)
 *
 * Move each selected box by <sizOffset> pixels.
 */
void CBoxNetDoc::MoveBoxSelection(CSize sizOffset)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc

    // move each box by <sizOffset>
    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
        {
            // erase box
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOXANDLINKS, pbox);

            // move box
            pbox->Move(sizOffset);

            // draw box in new location
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOXANDLINKS, pbox);
        }
    }

    // move by <sizOffset> each link that connects two selected boxes
    for (pos = m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = m_lstLinks.GetNext(pos);
        if (plink->m_psockTail->m_pbox->IsSelected() &&
            plink->m_psockHead->m_pbox->IsSelected())
        {
            // erase link
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);

            // draw link in new location
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);
        }
    }
}


//
// --- Command Processing ---
//
// The way the user affects the state of this document

//
// CmdDo(pcmd)
//
// Do command <pcmd>, and add it to the undo stack.  <pcmd> needs to have
// been allocated by the "new" operator.
void CBoxNetDoc::CmdDo(CCmd *pcmd) {

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdDo '%s'\n", (LPCSTR) strCmd);
#endif

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // do command
    pcmd->Do(this);

    if (pcmd->CanUndo(this))
    {
        // command supports Undo, so add it to the undo stack
        pcmd->m_fRedo = FALSE;
        m_lstUndo.AddHead(pcmd);
    }
    else
    {
        // command can't be undone, so disable Undo
        m_lstUndo.DeleteRemoveAll();

    delete pcmd;
    }

    // delete the redo stack
    m_lstRedo.DeleteRemoveAll();
}


//
// CmdUndo()
//
// Undo the last command.
void CBoxNetDoc::CmdUndo() {

    ASSERT(CanUndo());

    CCmd *      pcmd;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // pop the undo stack
    pcmd = (CCmd *) m_lstUndo.RemoveHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdUndo '%s'\n", (LPCSTR) strCmd);
#endif

    // undo the command
    pcmd->Undo(this);

    // add command to the redo stack
    pcmd->m_fRedo = TRUE;
    m_lstRedo.AddHead(pcmd);
}


//
// CanUndo()
//
// Return TRUE iff CmdUndo() can be performed.
BOOL CBoxNetDoc::CanUndo() {

    return !m_lstUndo.IsEmpty();
}


//
// CmdRedo()
//
// Redo the last undone command.  This is only valid if the redo stack
// is not empty.
void CBoxNetDoc::CmdRedo() {

    ASSERT(CanRedo());

    CCmd *      pcmd;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // pop the redo stack
    pcmd = (CCmd *) m_lstRedo.RemoveHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdRedo '%s'\n", (LPCSTR) strCmd);
#endif

    // redo the command
    pcmd->Redo(this);

    // add command to the undo stack
    pcmd->m_fRedo = FALSE;
    m_lstUndo.AddHead(pcmd);
}


//
// CanRedo()
//
// Return TRUE iff CmdRedo() can be performed.
BOOL CBoxNetDoc::CanRedo() {

    return !m_lstRedo.IsEmpty();
}


//
// CmdRepeat()
//
// Repeat the last command.  This is only valid if you can repeat
void CBoxNetDoc::CmdRepeat() {

    ASSERT(CanRepeat());

    CCmd *      pcmd;
    CCmd *      pcmdRepeat;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // get the command at the top of the undo stack
    pcmd = (CCmd *) m_lstUndo.GetHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdRepeat '%s'\n", (LPCSTR) strCmd);
#endif

    // create a duplicate of the command
    pcmdRepeat = pcmd->Repeat(this);

    // do command
    pcmdRepeat->Do(this);

    // add command to the undo stack
    pcmdRepeat->m_fRedo = FALSE;
    m_lstUndo.AddHead(pcmdRepeat);
}


//
// CanRepeat()
//
// Return TRUE iff CmdRepeat() can be performed.
BOOL CBoxNetDoc::CanRepeat() {

    // can't do Repeat if the undo stack is empty (no command to repeat)
    // or the redo stack is empty (can't Repeat after Undo)
    if (m_lstUndo.IsEmpty() || !m_lstRedo.IsEmpty())
        return FALSE;

    // can only repeat commands that support Repeat()
    CCmd *pcmd = (CCmd *) m_lstUndo.GetHead();
    return pcmd->CanRepeat(this);
}


/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CBoxNetDoc, CDocument)
    //{{AFX_MSG_MAP(CBoxNetDoc)
    ON_COMMAND(ID_FILE_RENDER, OnFileRender)
    ON_COMMAND(ID_URL_RENDER, OnURLRender)
    ON_UPDATE_COMMAND_UI(ID_FILE_RENDER, OnUpdateFileRender)
    ON_UPDATE_COMMAND_UI(ID_URL_RENDER, OnUpdateURLRender)
    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
    ON_COMMAND(ID_QUARTZ_DISCONNECT, OnQuartzDisconnect)
    ON_COMMAND(ID_QUARTZ_RUN, OnQuartzRun)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_DISCONNECT, OnUpdateQuartzDisconnect)
    ON_COMMAND(ID_WINDOW_REFRESH, OnWindowRefresh)
    ON_COMMAND(ID_WINDOW_ZOOM33, OnWindowZoom33)
    ON_COMMAND(ID_WINDOW_ZOOM50, OnWindowZoom50)
    ON_COMMAND(ID_WINDOW_ZOOM100, OnWindowZoom100)
    ON_COMMAND(ID_WINDOW_ZOOM200, OnWindowZoom200)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_RUN, OnUpdateQuartzRun)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_PAUSE, OnUpdateQuartzPause)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_STOP, OnUpdateQuartzStop)
    ON_COMMAND(ID_QUARTZ_STOP, OnQuartzStop)
    ON_COMMAND(ID_QUARTZ_PAUSE, OnQuartzPause)
    ON_UPDATE_COMMAND_UI(ID_USE_CLOCK, OnUpdateUseClock)
    ON_COMMAND(ID_USE_CLOCK, OnUseClock)
    ON_UPDATE_COMMAND_UI(ID_CONNECT_SMART, OnUpdateConnectSmart)
    ON_COMMAND(ID_CONNECT_SMART, OnConnectSmart)
    ON_UPDATE_COMMAND_UI(ID_AUTOARRANGE, OnUpdateAutoArrange)
    ON_COMMAND(ID_AUTOARRANGE, OnAutoArrange)
    ON_COMMAND(ID_GRAPH_ADDFILTERTOCACHE, OnGraphAddFilterToCache)
    ON_UPDATE_COMMAND_UI(ID_GRAPH_ADDFILTERTOCACHE, OnUpdateGraphAddFilterToCache)
    ON_COMMAND(ID_GRAPH_ENUMCACHEDFILTERS, OnGraphEnumCachedFilters)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_INSERT_FILTER, OnInsertFilter)
    ON_COMMAND(ID_CONNECT_TO_GRAPH, OnConnectToGraph)
    ON_COMMAND(ID_GRAPH_STATS, OnGraphStats)

    // -- pin properties menu --
    ON_UPDATE_COMMAND_UI(ID_RENDER, OnUpdateQuartzRender)
    ON_COMMAND(ID_RENDER, OnQuartzRender)

    ON_UPDATE_COMMAND_UI(ID_RECONNECT, OnUpdateReconnect)
    ON_COMMAND(ID_RECONNECT, OnReconnect)

    ON_COMMAND(ID_FILE_SAVE_AS_HTML, OnSaveGraphAsHTML)
    ON_COMMAND(ID_FILE_SAVE_AS_XML, OnSaveGraphAsXML)

END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// message callback helper functions


/* UpdateEditUndoRedoRepeat(pCmdUI, fEnable, idStringFmt, plst)
 *
 * Update the menu item UI for the Undo, Redo, and Repeat commands.
 * <pCmdUI> is the CCmdUI for the menu item.  <fEnable> is TRUE iff
 * the command can be enabled.  <idStringFmt> is the ID of the string
 * resource containing the wsprintf() format string to use for the
 * menu item (e.g. "Undo %s").  <plst> is the CCmd list containing the
 * command; the head of this list will be examined to get the name of
 * the command for use in the menu item text (e.g. "Undo Delete Boxes").
 */
void CBoxNetDoc::UpdateEditUndoRedoRepeat(CCmdUI* pCmdUI, BOOL fEnable,
    unsigned idStringFmt, CMaxList *plst)
{
    CString         strCmd;         // command label
    CString         strMenuFmt;     // menu item label (wsprint format)
    char            achMenu[100];   // result menu item label

    // load the string item that represents  the command (e.g. "Delete Boxes")
    // used in the menu item (e.g. "Undo Delete Boxes")
    strMenuFmt.LoadString(idStringFmt);
    if (fEnable)
        strCmd.LoadString(((CCmd *) plst->GetHead())->GetLabel());
    else
        strCmd = "";                // can't undo/redo/repeat
    wsprintf(achMenu, strMenuFmt, (LPCSTR) strCmd);
    pCmdUI->SetText(achMenu);

    // enable/disable the menu item
    pCmdUI->Enable(fEnable);
}


/////////////////////////////////////////////////////////////////////////////
// message callback functions


void CBoxNetDoc::OnEditUndo()
{
    CmdUndo();
}


void CBoxNetDoc::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    UpdateEditUndoRedoRepeat(pCmdUI, CanUndo(), IDS_MENU_UNDO, &m_lstUndo);
}


void CBoxNetDoc::OnEditRedo()
{
    if( CanRedo() )
        CmdRedo();
    else
        CmdRepeat();
}


void CBoxNetDoc::OnUpdateEditRedo(CCmdUI* pCmdUI)
{
    // The Redo command may be a Repeat command depending on the context
    // The changing of the status bar text is handled by CMainFrame::GetMessageString
    if( CanRedo() )
        UpdateEditUndoRedoRepeat(pCmdUI, CanRedo(), IDS_MENU_REDO, &m_lstRedo);
    else
        UpdateEditUndoRedoRepeat(pCmdUI, CanRepeat(), IDS_MENU_REPEAT, &m_lstUndo);

}

void CBoxNetDoc::OnEditSelectAll()
{
    // deselect all, select all boxes
    // !!!! need to select all links....
    DeselectAll();
    SelectBox(NULL, TRUE);
}


void CBoxNetDoc::OnUpdateEditSelectAll(CCmdUI* pCmdUI)
{
    // check if there are any boxes to select
    pCmdUI->Enable(m_lstBoxes.GetCount() != 0);
}

//
// OnInsertFilter
//
// Display a list view which allows the user to select a filter to insert
// into the graph.
//
void CBoxNetDoc::OnInsertFilter()
{
    //
    // Make sure common controls are available
    //
    InitCommonControls();

    CFilterView::GetFilterView( this, AfxGetMainWnd() );
}

//
// OnGraphStas
//
// Display a list of graph-wide statistics.
//
void CBoxNetDoc::OnGraphStats()
{
    CGraphStats::GetGraphStats( this, AfxGetMainWnd() );
}

//
// OnQuartzDisconnect
//
// user wants everything disconnected
void CBoxNetDoc::OnQuartzDisconnect()
{
    CmdDo(new CCmdDisconnectAll());

}


//
// OnQuartzRun
//
// Play the graph
void CBoxNetDoc::OnQuartzRun (void) {

    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());

        hr = IMC->Run();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTPLAY, hr );
            TRACE("Run failed hr = %x\n", hr);

            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }

            if (m_State != Stopped && m_nSeekOnRun == UNDEFINED)
            {
                m_nSeekOnRun = SEEK_ON_RUN;
            }
            return;
        }

        // Calling Run on the filtergraph will have it call Pause if we have
        // not already done so. Calling Pause on the video renderer will make
        // it show its video window because of the auto show property there
        // is in IVideoWindow. Showing the window will send an EC_REPAINT as
        // it needs an image to draw. So if we show the window manually we
        // must do so after calling Run/Pause otherwise we get an EC_REPAINT
        // sent just before we call Run/Pause ourselves which is redundant
        // (because the repaint has the graph stopped and paused all over!)

        CQCOMInt<IVideoWindow> IVW(IID_IVideoWindow, IGraph());
        IVW->SetWindowForeground(OATRUE);
        m_State = Playing;
        if (m_nSeekOnRun == UNDEFINED)
        {
            m_nSeekOnRun = SEEK_ON_RUN;
        }
    }
    catch (CHRESULTException hre) {

        DisplayQuartzError( IDS_CANTPLAY, hre.Reason() );
    }

    return;

}


//
// OnQuartzPause
//
// Change state between play & pause
void CBoxNetDoc::OnQuartzPause (void) {

    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());
        State OldState = m_State;

        hr = IMC->Pause();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTPAUSE, hr );
            TRACE("Pause failed hr = %x\n", hr);

            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }

            if (OldState == Stopped && m_State != Stopped && m_nSeekOnRun == UNDEFINED)
            {
                m_nSeekOnRun = SEEK_ON_RUN;
            }
        return;
        }

        // Calling Run on the filtergraph will have it call Pause if we have
        // not already done so. Calling Pause on the video renderer will make
        // it show its video window because of the auto show property there
        // is in IVideoWindow. Showing the window will send an EC_REPAINT as
        // it needs an image to draw. So if we show the window manually we
        // must do so after calling Run/Pause otherwise we get an EC_REPAINT
        // sent just before we call Run/Pause ourselves which is redundant
        // (because the repaint has the graph stopped and paused all over!)

        CQCOMInt<IVideoWindow> IVW(IID_IVideoWindow, IGraph());
        IVW->SetWindowForeground(OATRUE);
        m_State = Paused;
        if (OldState == Stopped && m_nSeekOnRun == UNDEFINED)
        {
            m_nSeekOnRun = SEEK_ON_RUN;
        }
    }
    catch (CHRESULTException hre) {

        DisplayQuartzError( IDS_CANTPAUSE, hre.Reason() );
    }

    return;
}


//
// OnUpdateQuartzDisconnect
//
// Are there any links to disconnect?
void CBoxNetDoc::OnUpdateQuartzDisconnect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( CCmdDisconnectAll::CanDo(this) );
}

#ifdef DSHOW_USE_WM_CERT

#include <..\..\..\filters\asf\wmsdk\inc\wmsdkidl.h>

// note: this object is a SEMI-COM object, and can only be created statically.
class CKeyProvider : public IServiceProvider {
public:
    STDMETHODIMP_(ULONG) AddRef() { return 2; }
    STDMETHODIMP_(ULONG) Release() { return 1; }

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == IID_IServiceProvider || riid == IID_IUnknown) {
            *ppv = (void *) static_cast<IServiceProvider *>(this);
            return NOERROR;
        }
        return E_NOINTERFACE;
    }


    STDMETHODIMP QueryService(REFIID siid, REFIID riid, void **ppv)
    {
        if (siid == __uuidof(IWMReader) && riid == IID_IUnknown) {

            IUnknown *punkCert;

            HRESULT hr = WMCreateCertificate( &punkCert );
            if (SUCCEEDED(hr)) {
                *ppv = (void *) punkCert;
            }
            return hr;
        }
        return E_NOINTERFACE;
    }

} g_keyprov;

#endif


//
// CreateGraphAndMapper
//
// CoCreates the filtergraph and mapper. Called by new documents
// and loading documents. Can be called multiple times harmlessly.
BOOL CBoxNetDoc::CreateGraphAndMapper(void) {

    if (m_pGraph && m_pMediaEvent) { // already been done.
        return TRUE;
    }

    try {

        HRESULT hr; // return code

        ASSERT(m_pMediaEvent == NULL);

        if (!m_pGraph)
            m_pGraph = new CQCOMInt<IGraphBuilder>(IID_IGraphBuilder, CLSID_FilterGraph);

        m_pMediaEvent = new CQCOMInt<IMediaEvent>(IID_IMediaEvent, IGraph());

        //
        // Creation of a seperate thread which will translate event signals
        // to messages. This is used to avoid busy polling of the event
        // states in the OnIdle method.
        //

        //
        // the event handle that is signalled when event notifications arrive
        // is created by the filter graph, but we can get it ourselves.
        //
        hr = IEvent()->GetEventHandle((OAEVENT*)&m_phThreadData[0]);
        if (FAILED(hr)) {
            TRACE("Failed to get event handle\n");
            throw CHRESULTException();
        }

        ASSERT(m_phThreadData[0]);
        ASSERT(!m_phThreadData[1]);
        ASSERT(!m_phThreadData[2]);

        m_phThreadData[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_phThreadData[2] = CreateEvent(NULL, FALSE, FALSE, NULL);
        RegNotifyChangeKeyValue(HKEY_CLASSES_ROOT, TRUE,
        REG_NOTIFY_CHANGE_LAST_SET, m_phThreadData[2], TRUE);

        if (m_phThreadData[1] == NULL) {
            //
            // Failed to create event - we'll go on anyway but GraphEdt
            // won't respond to EC_ notifications (not a major problem)
            //
        }
        else {
            // Old quartz.dll will hang if we don't support IMarshal
            IMarshal *pMarshal;
            HRESULT hr = IGraph()->QueryInterface(IID_IMarshal, (void **)&pMarshal);
            if (SUCCEEDED(hr)) {
                pMarshal->Release();
                //
                // Start up the thread which just waits for
                // any EC_  notifications and translate them into messages
                // for our message loop.
                //
                CoMarshalInterThreadInterfaceInStream(IID_IMediaEvent, IEvent(), &m_pMarshalStream);
            }
            DWORD dw;
            m_hThread = CreateThread(NULL, 0, NotificationThread,
                                     (LPVOID) this, 0, &dw);
        }
#ifdef DSHOW_USE_WM_CERT
        IObjectWithSite* pObjectWithSite = NULL;
        HRESULT hrKey = IGraph()->QueryInterface(IID_IObjectWithSite, (void**)&pObjectWithSite);
        if (SUCCEEDED(hrKey))
        {
            pObjectWithSite->SetSite((IUnknown *) &g_keyprov);
            pObjectWithSite->Release();
        }
#endif
        UpdateClockSelection();

        ASSERT(m_pGraph != NULL);
        ASSERT(m_pMediaEvent != NULL);

/*
        m_pSeekProvider = new CFloatingTimelineSeekProvider;
        if (m_pSeekProvider)
        {
            IUnknown* pUnkSeekProvider;
            m_pSeekProvider->SetDoc(this);
            if (SUCCEEDED(m_pSeekProvider->QueryInterface(IID_IUnknown, &pUnkSeekProvider))
            {
                IRegisterServiceProvider* pSvcProvider;
                if (SUCCEEDED(IGraph()->QueryInterface(IID_IRegisterServiceProvider, &pSvcProvider))
                {
                    // RegisterService does not addref pUnkSeekProvider
                    pSvcProvider->RegisterService(GUID_FloatingTimelineSeekService, pUnkSeekProvider);
                    pSvcProvider->Release();

                    // We hold on to pUnkSeekProvider and release it when the graph is deleted.
                    m_pUnkSeekProvider = pUnkSeekProvider;
                }
                else
                {
                    // deletes m_pSeekProvider
                    m_pSeekProvider->SetDoc(NULL);
                    m_pSeekProvider = NULL;
                    pUnkSeekProvider->Release();
                }
            }
            else
            {
                delete m_pSeekProvider;
                m_pSeekProvider = NULL;
            }
        }
*/
        IRegisterServiceProvider* pSvcProvider;
        if (SUCCEEDED(IGraph()->QueryInterface(IID_IRegisterServiceProvider, (void**) &pSvcProvider)))
        {
            // RegisterService does not addref pUnkSeekProvider
            pSvcProvider->RegisterService(GUID_MultiGraphHostService, GBL(m_pMultiGraphHostUnknown));
            pSvcProvider->Release();
        }

    }
    catch (CHRESULTException) {

        delete m_pGraph, m_pGraph = NULL;

        delete m_pMediaEvent, m_pMediaEvent = NULL;

        return FALSE;
    }

    return TRUE;
}


//
// GetFiltersInGraph
//
// If an 'intelligent' feature is used the graph may add filters without
// telling us. Therefore enumerate the filters and links
// in the graph
HRESULT CBoxNetDoc::GetFiltersInGraph( void )
{
    m_lstLinks.DeleteRemoveAll();

    POSITION posNext;
    CBox *pCurrentBox;
    POSITION posCurrent;

    // We want the list to allocate at least one unit each time
    // a box is added to the list.
    int nListAllocationBlockSize = max( m_lstBoxes.GetCount(), 1 );

    // The list deletes any boxes which are left on the list when the
    // function exists.
    CBoxList lstExistingBoxes( TRUE, nListAllocationBlockSize );

    // Copy the boxes on m_lstBoxes to lstExistingBoxes.
    posNext = m_lstBoxes.GetHeadPosition();

    while( posNext != NULL ) {
        posCurrent = posNext;
        pCurrentBox = m_lstBoxes.GetNext( posNext );

        try {
            lstExistingBoxes.AddHead( pCurrentBox );
        } catch( CMemoryException* pOutOfMemory ) {
            pOutOfMemory->Delete();
            return E_OUTOFMEMORY;
        }

        m_lstBoxes.RemoveAt( posCurrent );

        pCurrentBox = NULL;
    }

    // m_lstBoxes should be empty.
    ASSERT( 0 == m_lstBoxes.GetCount() );

    // Put all the filters in the filter graph on the box list.
    // Each box corresponds to a filter.  The boxes list's order is
    // the same as the filter graph enumerator's order.  The box list
    // must be in this order because SetBoxesHorizontally() will not
    // display the boxes correctly if the box list and the filter graph
    // enumerator have a different order.

    CComPtr<IEnumFilters> pFiltersInGraph;

    HRESULT hr = IGraph()->EnumFilters( &pFiltersInGraph );
    if( FAILED( hr ) ) {
        return hr;
    }

    CBox* pNewBox;
    HRESULT hrNext;
    IBaseFilter* apNextFiler[1];
    CComPtr<IBaseFilter> pNextFilter;

    do
    {
        ULONG ulNumFiltersEnumerated;

        hrNext = pFiltersInGraph->Next( 1, apNextFiler, &ulNumFiltersEnumerated );
        if( FAILED( hrNext ) ) {
            return hrNext;
        }

        // IEnumFilters::Next() only returns two success values: S_OK and S_FALSE.
        ASSERT( (S_OK == hrNext) || (S_FALSE == hrNext) );

        // IEnumFilters::Next() returns S_OK if it has not finished enumerating the
        // filters in the filter graph.
        if( S_OK == hrNext ) {

            pNextFilter.Attach( apNextFiler[0] );
            apNextFiler[0] = NULL;

            try {
                if( !lstExistingBoxes.RemoveBox( pNextFilter, &pNewBox ) ) {
                    // This is a new filter Graph Edit has not previously seen.
                    // CBox::CBox() can throw a CHRESULTException.  new can throw a CMemoryException.
                    pNewBox = new CBox( pNextFilter, this );
                } else {
                    hr = pNewBox->Refresh();
                    if( FAILED( hr ) ) {
                        delete pNewBox;
                        return hr;
                    }
                }

                // AddHead() can throw a CMemoryException.
                m_lstBoxes.AddHead( pNewBox );

                pNewBox = NULL;
                pNextFilter = NULL;

            } catch( CHRESULTException chr ) {
                return chr.Reason();
            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                delete pNewBox;
                return E_OUTOFMEMORY;
            }
        }

    } while( S_OK == hrNext );

    return NOERROR;
}


//
// GetLinksInGraph
//
// For each filter see what its pins are connected to.
// I only check output pins. Each link in the graph _Must_ be between an
// input/output pair, so by checking only output pins I get all the links,
// but see no duplicates.
HRESULT CBoxNetDoc::GetLinksInGraph(void) {

    POSITION posBox = m_lstBoxes.GetHeadPosition();
    while (posBox != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(posBox);

        CSocketEnum NextSocket(pbox, CSocketEnum::Output);
        CBoxSocket *psock;
        while (0 != (psock = NextSocket())) {

            CBoxSocket *psockHead = psock->Peer();

            if (psockHead != NULL) {

                CBoxLink *plink = new CBoxLink(psock, psockHead, TRUE);

                m_lstLinks.AddTail(plink);
            }
        }
    }
    return NOERROR;
}

//
// FilterDisplay
//
// Lines the filters across the screen.
HRESULT CBoxNetDoc::FilterDisplay(void) {

    if (m_fAutoArrange) {

        SetBoxesHorizontally();

        SetBoxesVertically();

        RealiseGrid();      // the filters are currently at 1 pixel spacings.
                            // lay them out allowing for their width.
    }

    return NOERROR;
}

//
// SetBoxesHorizontally
//
void CBoxNetDoc::SetBoxesHorizontally(void) {

    CList<CBox *, CBox *> lstXPositionedBoxes;

    POSITION    pos = m_lstBoxes.GetHeadPosition();
    while (pos != NULL) {

        CBox *pbox = (CBox *) m_lstBoxes.GetNext(pos);

        pbox->Location(CPoint(0,0));    // a box starts at the origin

        CSocketEnum NextInput(pbox, CSocketEnum::Input);    // input pin enumerator

        CBoxSocket  *psock;
        int     iX = 0; // the point this box will be placed at.
        int     iXClosestPeer = -1; // the closest box to an input pin on this
                        // box.
                        //  #a# --------]
                        //              +---#c#
                        //       #b# ---]
                        // ie b is closest peer to c

        while (0 != (psock = NextInput())) {

            if (psock->IsConnected()) { // find out what to.

                CBoxSocket *pPeer = psock->Peer();
                if ( pPeer) {
                    if ( pPeer->pBox()->X() > iXClosestPeer ) {
                        iXClosestPeer = pPeer->pBox()->X();
                    }
                }
            }
        }

        iX = iXClosestPeer + 1;

        pbox->X(iX);

        // insert pbox into the corect place on the sorted list.

        POSITION    posSorted = lstXPositionedBoxes.GetHeadPosition();
        POSITION    prev = posSorted;
        BOOL        fInserted = FALSE;

        while (posSorted != NULL) {

            prev = posSorted;

            CBox *pboxSorted = lstXPositionedBoxes.GetNext(posSorted);

            if (pboxSorted->X() >= pbox->X()) { // this is where we want to put it
                lstXPositionedBoxes.InsertAfter(prev, pbox);
                fInserted = TRUE;
                break;
            }
        }
        if ((posSorted == NULL) && !fInserted) {    // we fell off the end without adding
            lstXPositionedBoxes.AddTail(pbox);
        }

    }

    m_lstBoxes.RemoveAll();
    m_lstBoxes.AddHead(&lstXPositionedBoxes);
}


//
// SetBoxesVertically
//
void CBoxNetDoc::SetBoxesVertically(void) {

    CList<CBox *, CBox *>   lstPositionedBoxes;

    POSITION posOld = m_lstBoxes.GetHeadPosition();

    while (posOld != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(posOld);

        pbox->CalcRelativeY();

        POSITION    posNew = lstPositionedBoxes.GetTailPosition();
        POSITION    prev = posNew;
        CBox        *pboxPositioned;

        while (posNew != NULL) {

            prev = posNew;  // store posNew, because GetPrev side effects it.

            pboxPositioned = lstPositionedBoxes.GetPrev(posNew);

            if (pboxPositioned->X() < pbox->X())
                break;

            //cyclic-looking graphs throw this assert
            //ASSERT(pboxPositioned->X() == pbox->X());

            if (pboxPositioned->RelativeY() <= pbox->RelativeY())
                break;

            pboxPositioned->Y(pboxPositioned->Y() + 1);
        }

        if (prev == NULL) { // we fell of the head of the list
            pbox->Y(0);
            lstPositionedBoxes.AddHead(pbox);
        }
        else if (pboxPositioned->X() < pbox->X()) {
            pbox->Y(0);
            lstPositionedBoxes.InsertAfter(prev, pbox);
        }
        else {
            pbox->Y(pboxPositioned->Y() + 1);
            lstPositionedBoxes.InsertAfter(prev, pbox);
        }
    }

    m_lstBoxes.RemoveAll();
    m_lstBoxes.AddHead(&lstPositionedBoxes);

}

//
// RealiseGrid
//
// pre: m_lstBoxes is sorted by X(), then Y() of each box.
//  The boxes are laid out on a grid at 1 pixel intervals
//  The origin is at 0,0 and no positions are negative
//
// post:    m_lstBoxes are laid out so that there are
//      gaps between each box and sufficient room allowed
//      for the biggest box on screen.
//
// Lines up the columns neatly, but not rows. this would require
// another pass over the list.
void CBoxNetDoc::RealiseGrid(void) {

    int iColumnX = 0;   // the left edge of this column
    int iColumnY = 0;   // the top edge of the next box to be placed in
                // this column.
    int iNextColumnX = 0;   // the left edge of the next column.
    int iCurrentColumn = 0;
    const int iColumnGap = 30;
    const int iRowGap = 15;

    POSITION pos = m_lstBoxes.GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(pos);

        if (iCurrentColumn < pbox->X()) {   // we've got to the next column
            iColumnY = 0;
            iColumnX = iNextColumnX;
        }

        iCurrentColumn = pbox->X();

        //
        // Make sure that the document doesn't exceed the document size.
        // This case will be VERY, VERY rare and thus we don't do any fancy
        // layout, but just pile them on top of each other at the end of
        // the document.
        //
        if ((iColumnX + pbox->Width()) > MAX_DOCUMENT_SIZE ) {
            iColumnX = MAX_DOCUMENT_SIZE - pbox->Width();
        }

        if ((iColumnY + pbox->Height()) > MAX_DOCUMENT_SIZE ) {
            iColumnY = MAX_DOCUMENT_SIZE - pbox->Height();
        }

        pbox->X(iColumnX);
        pbox->Y(iColumnY);

        iNextColumnX = max(iNextColumnX, pbox->X() + pbox->Width() + iColumnGap);
        iColumnY += pbox->Height() + iRowGap;

    }
}


//
// UpdateFilters
//
// A quartz operation has just changed the filters in the graph, such that the display
// may not reflect the filters in the graph. May occur, for example, after intelligent
// connect.
// Refreshes the box & link lists and repaints the doc.
HRESULT CBoxNetDoc::UpdateFilters(void)
{
    IGraphConfigCallback* pUpdateFiltersCallback = CUpdateFiltersCallback::CreateInstance();
    if( NULL == pUpdateFiltersCallback ) {
        return E_FAIL;
    }

    HRESULT hr = IfPossiblePreventStateChangesWhileOperationExecutes( IGraph(), pUpdateFiltersCallback, (void*)this );

    pUpdateFiltersCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

void CBoxNetDoc::UpdateFiltersInternal(void) {

    BeginWaitCursor();

    GetFiltersInGraph();
    GetLinksInGraph();
    FilterDisplay();

    ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);

    EndWaitCursor();
}


//
// OnUpdateQuartzRender
//
void CBoxNetDoc::OnUpdateQuartzRender(CCmdUI* pCmdUI) {

    pCmdUI->Enable(CCmdRender::CanDo(this));
}


//
// OnQuartzRender
//
// Attempt to render the pin the user just clicked on.
void CBoxNetDoc::OnQuartzRender() {

    CmdDo(new CCmdRender());

}


//
// OnWindowRefresh
//
// Lay out the filter graph for the user.
void CBoxNetDoc::OnWindowRefresh() {

    UpdateFilters();
}


//
// OnUpdateQuartzRun
//
// Updates the 'Play' menu position
void CBoxNetDoc::OnUpdateQuartzRun(CCmdUI* pCmdUI) {

    if (  (m_State == Paused) || (m_State == Unknown)
        ||(m_State == Stopped)) {
        pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }
}


void CBoxNetDoc::OnUpdateQuartzPause(CCmdUI* pCmdUI)
{
    if (  (m_State == Playing) || (m_State == Unknown)
        ||(m_State == Stopped)) {
    pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }

}

void CBoxNetDoc::OnUpdateQuartzStop(CCmdUI* pCmdUI)
{
    if (  (m_State == Playing) || (m_State == Unknown)
        ||(m_State == Paused)) {
        pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }

}


//
// stop the graph, but don't rewind visibly as there has been either
// an error (in which case we shouldn't mess with the graph) or the
// window has been closed.
void CBoxNetDoc::OnQuartzAbortStop()
{
    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());


        hr = IMC->Stop();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTSTOP, hr );
            TRACE("Stop failed hr = %x\n", hr);
        }

        m_State = Stopped;
        m_nSeekOnRun = UNDEFINED;

        IMediaPosition* pMP;
        hr = IMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
        if (SUCCEEDED(hr)) {
            pMP->put_CurrentPosition(0);
            pMP->Release();
        }


    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_CANTSTOP, hre.Reason() );
    }

    return;

}

// Graphedt does not have any notion of seeking so when we stop we do the
// intuitive thing to reset the current position back to the start of the
// stream. If play is to continue from the current position then the user
// can press Pause (and Run). To process the Stop we first Pause then set
// the new start position (while paused) and finally Stop the whole graph

void CBoxNetDoc::OnQuartzStop()
{
    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());

        hr = IMC->Pause();

        if (SUCCEEDED(hr)) {
            // Reset our position to the start again

            IMediaPosition* pMP;
            hr = IMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
            if (SUCCEEDED(hr)) {
                pMP->put_CurrentPosition(0);
                pMP->Release();
            }

            // Wait for the Pause to complete. If it does not complete within the
            // specified time we ask the user if (s)he wants to wait a little longer
            // or attempt to stop anyway.
            for(;;){
                const int iTimeout = 10 * 1000;
                OAFilterState state;

                hr = IMC->GetState(iTimeout, &state);
                if( hr == S_OK || hr == VFW_S_CANT_CUE )
                    break;

                if( IDCANCEL == AfxMessageBox( IDS_PAUSE_TIMEOUT, MB_RETRYCANCEL | MB_ICONSTOP ) )
                    break;
            }
        } else
            DisplayQuartzError( IDS_CANTPAUSE, hr );

        // And finally stop the graph

        hr = IMC->Stop();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTSTOP, hr );
            TRACE("Stop failed hr = %x\n", hr);
            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }
        } else
            m_State = Stopped;

        if (m_State == Stopped)
        {
            m_nSeekOnRun = UNDEFINED;
        }
    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_CANTSTOP, hre.Reason() );
    }

    return;

}
//
// GetSize
//
// Use the co-ordinates of the boxes to decide the document
// size needed to lay out this graph.
CSize CBoxNetDoc::GetSize(void) {

    CSize DocSize(0,0);
    POSITION pos;

    pos = m_lstBoxes.GetHeadPosition();

    // Scan the list for the extreme edges.
    while (pos != NULL) {

        CRect rect = m_lstBoxes.GetNext(pos)->GetRect();
        if (rect.right > DocSize.cx) {
            DocSize.cx = rect.right;
        }
        if (rect.bottom > DocSize.cy) {
            DocSize.cy = rect.bottom;
        }
    }

    return DocSize;
}


//
// NotificationThread
//
// This thread just blocks and waits for the event handle from
// IMediaEvent and waits for any events.
//
// There is a second event handle which will be signal as soon as this
// thread should exit.
//
DWORD WINAPI CBoxNetDoc::NotificationThread(LPVOID lpData)
{
    CoInitialize(NULL);

    //  Open a scope to make sure pMediaEvent is released before we call
    //  CoUninitialize
    {
        CBoxNetDoc * pThis = (CBoxNetDoc *) lpData;

        IMediaEvent * pMediaEvent;

        //  Unmarshal our interface
        if (pThis->m_pMarshalStream) {
            CoGetInterfaceAndReleaseStream(
                pThis->m_pMarshalStream, IID_IMediaEvent, (void **)&pMediaEvent);
            pThis->m_pMarshalStream = NULL;
        } else {
            pMediaEvent = pThis->IEvent();
            pMediaEvent->AddRef();
        }

        BOOL fExitOk = FALSE;

        while (!fExitOk) {
            DWORD dwReturn;
            dwReturn = WaitForMultipleObjects(3, pThis->m_phThreadData, FALSE, INFINITE);

            switch (dwReturn) {

            case WAIT_OBJECT_0:
                {
//                    TRACE("Event signaled to Thread\n");

                    //
                    // Get the event now and post a message to our window proc
                    // which will deal with the event. Use post message to
                    // avoid a dead lock once the main thread has decided to
                    // close us down and waits for us to exit.
                    //

                    NetDocUserMessage * pEventParams = new NetDocUserMessage;
                    if (!pEventParams) {
                        // no more memory - let others deal with it.
                        break;
                    }

                    // Must have an IEvent - otherwise signalling of this message
                    // would have been impossible.
                    HRESULT hr;
                    hr = pMediaEvent->GetEvent(&pEventParams->lEventCode, &pEventParams->lParam1, &pEventParams->lParam2, 0);

                    if (FAILED(hr)) {
                        delete pEventParams;
                        break;
                    }

                    BOOL fSuccess = FALSE;
                    if (pThis->m_hWndPostMessage && IsWindow(pThis->m_hWndPostMessage)) {
                        fSuccess =
                            ::PostMessage(pThis->m_hWndPostMessage, WM_USER_EC_EVENT, 0, (LPARAM) pEventParams);
                    }

                    if (!fSuccess) {
                        // should call this function, so that filter graph manager can cleanup
                        pMediaEvent->FreeEventParams(pEventParams->lEventCode, pEventParams->lParam1, pEventParams->lParam2);
                        delete pEventParams;
                    }

                }

                break;

            case (WAIT_OBJECT_0 + 1):
                fExitOk = TRUE;
                break;

            case (WAIT_OBJECT_0 + 2):
            pThis->m_fRegistryChanged = TRUE;

            // reset the registry notification
            RegNotifyChangeKeyValue(HKEY_CLASSES_ROOT, TRUE,
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                        pThis->m_phThreadData[2], TRUE);

            break;

            case (WAIT_FAILED):
                // one of our objects has gone - no need to hang around further
                fExitOk = TRUE;
                break;

            default:
                ASSERT(!"Unexpected return value");
            }
        }
        pMediaEvent->Release();

    }

    CoUninitialize();

    return(0);
}

//
// OnWM_USER
//
void CBoxNetDoc::OnWM_USER(NetDocUserMessage * lParam)
{
    switch (lParam->lEventCode) {
#ifdef DEVICE_REMOVAL
      case EC_DEVICE_LOST:
      {
          IUnknown *punk = (IUnknown *)lParam->lParam1;
          IBaseFilter *pf;
          HRESULT hr = punk->QueryInterface(IID_IBaseFilter, (void **)&pf);
          ASSERT(hr == S_OK);
          FILTER_INFO fi;
          hr = pf->QueryFilterInfo(&fi);
          pf->Release();
          ASSERT(hr == S_OK);
          if(fi.pGraph) {
              fi.pGraph->Release();
          }

          TCHAR szTmp[100];
          wsprintf(szTmp, "device %ls %s.", fi.achName, lParam->lParam2 ?
                   TEXT("arrived") : TEXT("removed"));
          MessageBox(0, szTmp, TEXT("device removal  notification"), 0);
      }
          break;
#endif

    case EC_ERRORABORT:
    DisplayQuartzError( (UINT) IDS_EC_ERROR_ABORT, (HRESULT) lParam->lParam1 );
        /* fall through */

    case EC_USERABORT:
        // stop without the rewind or we will re-show the window
        OnQuartzAbortStop();
        // post dummy message to update the UI (mfc needs this help)
        ::PostMessage( m_hWndPostMessage, WM_NULL, 0, 0);
        break;

    case EC_COMPLETE:
        OnQuartzStop();
        // post dummy message to update the UI (mfc needs this help)
        ::PostMessage( m_hWndPostMessage, WM_NULL, 0, 0);
        break;

    case EC_ERROR_STILLPLAYING:
        {
            int iChoice = AfxMessageBox(IDS_IS_GRAPH_PLAYING, MB_YESNO);
            if (iChoice == IDNO) {
                OnQuartzAbortStop();
            }
        }
        break;

    case EC_CLOCK_CHANGED:
        UpdateClockSelection();
        break;

    case EC_GRAPH_CHANGED:
        UpdateFilters();
        SetModifiedFlag(FALSE);
        break;

    default:
        break;
    }
    // should call this function, so that filter graph manager can cleanup
    IEvent()->FreeEventParams(lParam->lEventCode, lParam->lParam1, lParam->lParam2);
    delete lParam;
}


//
// OnUpdateUseClock
//
void CBoxNetDoc::OnUpdateUseClock(CCmdUI* pCmdUI)  {

    pCmdUI->SetCheck(m_fUsingClock);

}

//
// OnUseClock
//
// if we are using the clock, set no clock.
// if we are not using a clock ask for the default
void CBoxNetDoc::OnUseClock() {

    try {

        CQCOMInt<IMediaFilter> IMF(IID_IMediaFilter, IGraph());

        if (m_fUsingClock) {
            // we don't want to use the clock anymore

            HRESULT hr;

            hr = IMF->SetSyncSource(NULL);
            if (FAILED(hr)) {
                DisplayQuartzError( IDS_CANTSETCLOCK, hr );
                TRACE("SetSyncSource(NULL) failed hr = %x\n", hr);
                return;
            }
        }
        else {
            HRESULT hr = IGraph()->SetDefaultSyncSource();

            if (FAILED(hr)) {
                DisplayQuartzError( IDS_CANTSETCLOCK, hr );
                TRACE("SetDefaultSyncSource failed hr = %x\n", hr);
                return;
            }
        }

        // m_fUsingClock will be updated on the EC_CLOCK_CHANGED notification
    }
    catch (CHRESULTException) {
        // just catch it...
    }
}


//
// OnUpdateConnectSmart
//
void CBoxNetDoc::OnUpdateConnectSmart(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_fConnectSmart);
}

//
// OnConnectSmart
//
// Only need to invert the flag. All the magic is done elsewhere.
//
void CBoxNetDoc::OnConnectSmart()
{
    m_fConnectSmart = !m_fConnectSmart;
}

//
// OnUpdateConnectSmart
//
void CBoxNetDoc::OnUpdateAutoArrange(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_fAutoArrange);
}

//
// OnAutoArrange
//
// Toggle automatic graph re-arrangement.
void CBoxNetDoc::OnAutoArrange() {

    m_fAutoArrange = !m_fAutoArrange;
}

//
// OnFileRender
//
void CBoxNetDoc::OnFileRender()
{
    char szNameOfFile[MAX_PATH];
    szNameOfFile[0] = 0;

    OPENFILENAME ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize   = sizeof(OPENFILENAME);
    ofn.hwndOwner     = AfxGetMainWnd()->GetSafeHwnd();

    TCHAR tszMediaFileMask[201];
    int iSize = ::LoadString(AfxGetInstanceHandle(), IDS_MEDIA_FILES, tszMediaFileMask, 198);
    ASSERT(iSize);
    // Load String has problems with the 2nd \0 at the end
    tszMediaFileMask[iSize] = 0;
    tszMediaFileMask[iSize + 1] = 0;
    tszMediaFileMask[iSize + 2] = 0;

    ofn.lpstrFilter   = tszMediaFileMask;

    ofn.nFilterIndex  = 1;
    ofn.lpstrFile     = szNameOfFile;
    ofn.nMaxFile      = MAX_PATH;
    ofn.lpstrTitle    = TEXT("Select a file to be rendered.");
    ofn.Flags         = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    // get users selection
    if (!GetOpenFileName(&ofn)) {
        // no file selected - continue
        return;
    }

    WCHAR szwName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, szNameOfFile, -1, szwName, MAX_PATH);

    CmdDo( new CCmdRenderFile(szwName) );

    SetModifiedFlag();
}

//
// OnURLRender
//
void CBoxNetDoc::OnURLRender()
{
    char szNameOfFile[INTERNET_MAX_URL_LENGTH];
    CRenderURL dlgRenderURL(szNameOfFile, INTERNET_MAX_URL_LENGTH, AfxGetMainWnd());

    if (dlgRenderURL.DoModal() != IDOK)
        return;

    WCHAR szwName[INTERNET_MAX_URL_LENGTH];
    MultiByteToWideChar(CP_ACP, 0, szNameOfFile, -1, szwName, INTERNET_MAX_URL_LENGTH);

    CmdDo( new CCmdRenderFile(szwName) );

    SetModifiedFlag();
}

//
// OnUpdateFileRender
//
void CBoxNetDoc::OnUpdateFileRender(CCmdUI *pCmdUI)
{
    pCmdUI->Enable(m_State == Stopped);
}

//
// OnUpdateURLRender
//
void CBoxNetDoc::OnUpdateURLRender(CCmdUI *pCmdUI)
{
    pCmdUI->Enable(m_State == Stopped);
}

void CBoxNetDoc::OnUpdateFileSave(CCmdUI *pCmdUI)
{
    pCmdUI->Enable( !m_bNewFilenameRequired );
}


//
// SetSelectClock
//
// Sets the Graphs clock to the one found in pBox and removes the dialog
// box if we succeeded.
//
void CBoxNetDoc::SetSelectClock(CBox *pBox)
{
    if (!pBox->HasClock()) {
        AfxMessageBox(IDS_NO_REFCLOCK);
        return;
    }

    try {
        CQCOMInt<IMediaFilter> pMF(IID_IMediaFilter, IGraph());
        CQCOMInt<IReferenceClock> pRC(IID_IReferenceClock, pBox->pIFilter());

        HRESULT hr = pMF->SetSyncSource(pRC);
        if (FAILED(hr)) {
            throw CE_FAIL();
        }

    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_FAILED_SETSYNC, hre.Reason() );
    }
}


//
// UpdateClockSelection
//
// Sets the CBox::m_fClockSelected flag of the filter that provides the
// current clock to true.
//
void CBoxNetDoc::UpdateClockSelection()
{
    // Get current clock
    CQCOMInt<IMediaFilter> pMF(IID_IMediaFilter, IGraph());

    IReferenceClock * pRefClock;

    if (FAILED(pMF->GetSyncSource(&pRefClock))) {
        pRefClock = NULL;
    }

    m_fUsingClock = (pRefClock != NULL);

    // iterate through all boxes (filters) in the graph
    POSITION pos = m_lstBoxes.GetHeadPosition();
    while (pos) {
        CBox *pbox = m_lstBoxes.GetNext(pos);

        pbox->m_fClockSelected = FALSE;

        if (pbox->HasClock()) {
            try {
                // pbox has a IReferenceClock interface
                CQCOMInt<IReferenceClock> pRC(IID_IReferenceClock, pbox->pIFilter());

                ASSERT(pRC);

                pbox->m_fClockSelected = ((IReferenceClock *) pRC == pRefClock);
            }
            catch (CHRESULTException) {
                // failed to get IReferenceClock
                ASSERT(!pbox->m_fClockSelected);
            }
        }
    }

    if (pRefClock) {
        pRefClock->Release();
    }

    //
    // Redraw the whole filter graph.
    //
    UpdateAllViews(NULL, HINT_DRAW_ALL);
}

#pragma warning(disable:4514)

void CBoxNetDoc::OnGraphAddFilterToCache()
{
    CCmdAddFilterToCache* pCmdAddFilterToCache;

    try
    {
        pCmdAddFilterToCache = new CCmdAddFilterToCache;
    }
    catch( CMemoryException* peOutOfMemory )
    {
        DisplayQuartzError( E_OUTOFMEMORY );
        peOutOfMemory->Delete();
        return;
    }

    CmdDo( pCmdAddFilterToCache );
}

void CBoxNetDoc::OnUpdateGraphAddFilterToCache(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( CCmdAddFilterToCache::CanDo( this ) );
}

void CBoxNetDoc::OnGraphEnumCachedFilters()
{
    HRESULT hr = SafeEnumCachedFilters();
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
    }
}

void CBoxNetDoc::OnGraphEnumCachedFiltersInternal()
{
    IGraphConfig* pGraphConfig;

    HRESULT hr = IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }

    hr = S_OK;
    CDisplayCachedFilters dlgCurrentCachedFilters( pGraphConfig, &hr );
    if( FAILED( hr ) )
    {
        pGraphConfig->Release();
        DisplayQuartzError( hr );
        return;
    }

    INT_PTR nReturnValue = dlgCurrentCachedFilters.DoModal();

    // Handle the return value from DoModal
    switch( nReturnValue )
    {
    case -1:
        // CDialog::DoModal() returns -1 if it cannot create the dialog box.
        AfxMessageBox( IDS_CANT_CREATE_DIALOG );
        break;

    case IDABORT:
        // An error occured while the dialog box was being displayed.
        // CDisplayCachedFilters handles all internal errors.
        break;

    case IDOK:
        // No error occured.  The user finished looking at the dialog box.
        break;

    default:
        // This code should never be executed.
        ASSERT( false );
        break;
    }

    pGraphConfig->Release();
}

void CBoxNetDoc::OnUpdateReconnect( CCmdUI* pCmdUI )
{
    pCmdUI->Enable( CCmdReconnect::CanDo(this) );
}

void CBoxNetDoc::OnReconnect( void )
{
    CCmdReconnect* pCmdReconnect;

    try
    {
        pCmdReconnect = new CCmdReconnect;
    }
    catch( CMemoryException* peOutOfMemory )
    {
        DisplayQuartzError( E_OUTOFMEMORY );
        peOutOfMemory->Delete();
        return;
    }

    CmdDo( pCmdReconnect );
}

HRESULT CBoxNetDoc::StartReconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin )
{
    if( AsyncReconnectInProgress() ) {
        return E_FAIL;
    }

    CComPtr<IPinFlowControl> pDynamicOutputPin;

    HRESULT hr = pOutputPin->QueryInterface( IID_IPinFlowControl, (void**)&pDynamicOutputPin );
    if( FAILED( hr ) ) {
        return hr;
    }

    SECURITY_ATTRIBUTES* DEFAULT_SECURITY_ATTRIBUTES = NULL;
    const BOOL AUTOMATIC_RESET = FALSE;
    const BOOL INITIALLY_UNSIGNALED = FALSE;
    const LPCTSTR UNNAMED_EVENT = NULL;

    HANDLE hBlockEvent = ::CreateEvent( DEFAULT_SECURITY_ATTRIBUTES, AUTOMATIC_RESET, INITIALLY_UNSIGNALED, UNNAMED_EVENT );
    if( NULL == hBlockEvent ) {
        DWORD dwLastWin32Error = ::GetLastError();
        return AmHresultFromWin32( dwLastWin32Error );
    }

    hr = pDynamicOutputPin->Block( AM_PIN_FLOW_CONTROL_BLOCK, hBlockEvent );
    if( FAILED( hr ) ) {
        // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
        EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );

        return hr;
    }

    const DWORD PIN_BLOCKED = WAIT_OBJECT_0;

    // There are 200 milliseconds in one fifth of a second.
    const DWORD ONE_FIFTH_OF_A_SECOND = 200;

    DWORD dwReturnValue = ::WaitForSingleObject( hBlockEvent, ONE_FIFTH_OF_A_SECOND );

    if( WAIT_TIMEOUT != dwReturnValue ) {
        if( PIN_BLOCKED != dwReturnValue ) {
            // Block() should not fail because we are unblocking the pin and
            // we are passing in valid arguments.
            EXECUTE_ASSERT( SUCCEEDED( pDynamicOutputPin->Block(0, NULL) ) );
        }

        // This call should not fail because we have access to hBlockEvent
        // and hBlockEvent is a valid event.
        EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );
    }

    switch( dwReturnValue ) {
    case PIN_BLOCKED:
        // EndReconnect() always unblocks the output pin.
        hr = EndReconnect( pFilterGraph, pDynamicOutputPin );
        if( FAILED( hr ) ) {
            return hr;
        }

        return S_OK;

    case WAIT_TIMEOUT:
        {
            const TIMERPROC NO_TIMER_PROCEDURE = NULL;

            // SetTimer() returns 0 if an error occurs.
            if( 0 == ::SetTimer( m_hWndPostMessage, CBoxNetView::TIMER_PENDING_RECONNECT, ONE_FIFTH_OF_A_SECOND, NO_TIMER_PROCEDURE ) ) {
                // Block() should not fail because we are unblocking the pin and
                // we are passing in valid arguments.
                EXECUTE_ASSERT( SUCCEEDED( pDynamicOutputPin->Block(0, NULL) ) );

                // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
                EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );

                DWORD dwLastWin32Error = ::GetLastError();
                return AmHresultFromWin32( dwLastWin32Error );
            }
        }

        m_hPendingReconnectBlockEvent = hBlockEvent;
        m_pPendingReconnectOutputPin = pDynamicOutputPin; // CComPtr::operator=() will automatically addref this pin.
        return GE_S_RECONNECT_PENDING;

    case WAIT_FAILED:
        {
            DWORD dwLastWin32Error = ::GetLastError();
            return AmHresultFromWin32( dwLastWin32Error );
        }

    case WAIT_ABANDONED:
    default:
        DbgBreak( "An Unexpected case occured in CBoxNetDoc::StartReconnect()." );
        return E_UNEXPECTED;
    }
}

HRESULT CBoxNetDoc::EndReconnect( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin )
{
    HRESULT hr = EndReconnectInternal( pFilterGraph, pDynamicOutputPin );

    // Unblock the output pin.
    HRESULT hrBlock = pDynamicOutputPin->Block( 0, NULL );

    if( FAILED( hr ) ) {
        return hr;
    } else if( FAILED( hrBlock ) ) {
        return hrBlock;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::EndReconnectInternal( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin )
{
    CComPtr<IGraphConfig> pGraphConfig;

    HRESULT hr = pFilterGraph->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return hr;
    }

    CComPtr<IPin> pOutputPin;

    hr = pDynamicOutputPin->QueryInterface( IID_IPin, (void**)&pOutputPin );
    if( FAILED( hr ) ) {
        return hr;
    }

    hr = pGraphConfig->Reconnect( pOutputPin, NULL, NULL, NULL, NULL, AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS );

    UpdateFilters();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::ProcessPendingReconnect( void )
{
    // ::KillTimer() does not remove WM_TIMER messages which have already been posted to a
    // window's message queue.  Therefore, it is possible to receive WM_TIMER messages after
    // the pin has been reconnected.
    if( !AsyncReconnectInProgress() ) {
        return S_FALSE;
    }

    const DWORD DONT_WAIT = 0;
    const DWORD PIN_BLOCKED = WAIT_OBJECT_0;

    DWORD dwReturnValue = ::WaitForSingleObject( m_hPendingReconnectBlockEvent, DONT_WAIT );

    if( (WAIT_TIMEOUT != dwReturnValue) && (PIN_BLOCKED != dwReturnValue) ) {
        ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );
    }

    switch( dwReturnValue ) {
    case WAIT_TIMEOUT:
        return S_FALSE;

    case PIN_BLOCKED:
        {
            HRESULT hr = EndReconnect( IGraph(), m_pPendingReconnectOutputPin );

            ReleaseReconnectResources( ASYNC_RECONNECT_NO_FLAGS );

            if( FAILED( hr ) ) {
                return hr;
            }

            return S_OK;
        }

    case WAIT_FAILED:
        {
            DWORD dwLastWin32Error = ::GetLastError();
            return AmHresultFromWin32( dwLastWin32Error );
        }

    case WAIT_ABANDONED:
    default:
        DbgBreak( "An Unexpected case occured in CBoxNetDoc::ProcessPendingReconnect()." );
        return E_UNEXPECTED;
    }
}

void CBoxNetDoc::ReleaseReconnectResources( ASYNC_RECONNECT_FLAGS arfFlags )
{
    if( !AsyncReconnectInProgress() ) {
        return;
    }

    if( arfFlags & ASYNC_RECONNECT_UNBLOCK ) {
        // Block() should not fail because we are unblocking the pin and
        // we are passing in valid arguments.
        EXECUTE_ASSERT( SUCCEEDED( m_pPendingReconnectOutputPin->Block(0, NULL) ) );
    }

    m_pPendingReconnectOutputPin = NULL; // Release our reference on the output pin.

    // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
    EXECUTE_ASSERT( ::CloseHandle( m_hPendingReconnectBlockEvent ) );
    m_hPendingReconnectBlockEvent = NULL;

    // Since the timer exists and m_hWndPostMessage is a valid window handle, this function
    // should not fail.
    EXECUTE_ASSERT( ::KillTimer( m_hWndPostMessage, CBoxNetView::TIMER_PENDING_RECONNECT ) );
}

bool CBoxNetDoc::AsyncReconnectInProgress( void ) const
{
    // Make sure the pending reconnect state is consitent.  Either the user is waiting on event
    // m_hPendingReconnectBlockEvent and m_pPendingReconnectOutputPin contains the pin being
    // reconnected or both variables should be unused.
    ASSERT( ( m_pPendingReconnectOutputPin && (NULL != m_hPendingReconnectBlockEvent) ) ||
            ( !m_pPendingReconnectOutputPin && (NULL == m_hPendingReconnectBlockEvent) ) );

    return (m_pPendingReconnectOutputPin && (NULL != m_hPendingReconnectBlockEvent));
}

HRESULT CBoxNetDoc::SafePrintGraphAsHTML( HANDLE hFile )
{
    CPrintGraphAsHTMLCallback::PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL sPrintGraphAsHTMLInternalParameters;

    sPrintGraphAsHTMLInternalParameters.pDocument = this;
    sPrintGraphAsHTMLInternalParameters.hFileHandle = hFile;

    IGraphConfigCallback* pPrintGraphAsHTMLCallback = CPrintGraphAsHTMLCallback::CreateInstance();
    if( NULL == pPrintGraphAsHTMLCallback ) {
        return E_FAIL;
    }

    HRESULT hr = IfPossiblePreventStateChangesWhileOperationExecutes( IGraph(), pPrintGraphAsHTMLCallback, (void*)&sPrintGraphAsHTMLInternalParameters );

    pPrintGraphAsHTMLCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::SafeEnumCachedFilters( void )
{
    IGraphConfigCallback* pEnumFilterCacheCallback = CEnumerateFilterCacheCallback::CreateInstance();
    if( NULL == pEnumFilterCacheCallback ) {
        return E_FAIL;
    }

    HRESULT hr = PreventStateChangesWhileOperationExecutes( IGraph(), pEnumFilterCacheCallback, (void*)this );

    pEnumFilterCacheCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\bnetvw.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetvw.cpp : defines CBoxNetView
//

#include "stdafx.h"
#include <activecf.h>                   // Quartz clipboard definitions
#include <measure.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CBoxNetView, CScrollView)

/////////////////////////////////////////////////////////////////////////////
// construction and destruction


CBoxNetView::CBoxNetView() :
    m_fMouseDrag(FALSE),
    m_fMoveBoxSelPending(FALSE),
    m_fMoveBoxSel(FALSE),
    m_fGhostSelection(FALSE),
    m_fSelectRect(FALSE),
    m_pSelectClockFilter(NULL),
    m_fNewLink(FALSE),
    m_fGhostArrow(FALSE),
    m_psockHilite(NULL)
{
    CString szMeasurePath;
    szMeasurePath.LoadString(IDS_MEASURE_DLL);

    m_hinstPerf = LoadLibrary(szMeasurePath);

}


//
// Destructor
//
CBoxNetView::~CBoxNetView() {
#if 0
// THIS DOES NOT BELONG HERE!!
// THIS HAS TO BE AT THE VERY END OF THE APPLICATION
// THINGS GO ON *AFTER* THIS POINT AND THEY ACCESS VIOLATE WITH THIS HERE
    if (m_hinstPerf) {
        // allow perf library to clean up!
        CString szTerminateProc;
        szTerminateProc.LoadString(IDS_TERMINATE_PROC);

        typedef void WINAPI MSR_TERMINATE_PROC(void);

        MSR_TERMINATE_PROC *TerminateProc;
        TerminateProc =
            (MSR_TERMINATE_PROC *) GetProcAddress(m_hinstPerf, szTerminateProc);

        if (TerminateProc) {
            TerminateProc();
        }
        else {
            AfxMessageBox(IDS_NO_TERMINATE_PROC);
        }

        FreeLibrary(m_hinstPerf);
    }
#endif
}


/////////////////////////////////////////////////////////////////////////////
// diagnostics


#ifdef _DEBUG
void CBoxNetView::AssertValid() const
{
    CScrollView::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CBoxNetView::Dump(CDumpContext& dc) const
{
    CScrollView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// general public functions

//
// OnInitialUpdate
//
// Set the initial scroll size
void CBoxNetView::OnInitialUpdate(void) {

    SetScrollSizes(MM_TEXT, GetDocument()->GetSize());

    CScrollView::OnInitialUpdate();

    GetDocument()->m_hWndPostMessage = m_hWnd;

    CGraphEdit * pMainFrame = (CGraphEdit*) AfxGetApp( );
    CWnd * pMainWnd = pMainFrame->m_pMainWnd;
    CMainFrame * pF = (CMainFrame*) pMainWnd;
    
#if 0
    if (GetDocument()->IsDVRCaptureGraph())
    {
        ((CMDIChildWnd*) GetParentFrame())->SetHandles(pF->m_hDVRCaptureMenu, GetParentFrame()->m_hAccelTable);
    }
    else
    {
        ((CMDIChildWnd*) GetParentFrame())->SetHandles(pF->m_hRegularMenu, GetParentFrame()->m_hAccelTable);
    }
#endif

    pF->CreateSeekBar(m_wndSeekBar, 10000, 500);
    ((CChildFrame*) GetParentFrame())->SetSeekBar(&m_wndSeekBar);

    SetTimer(TIMER_SEEKBAR, 200, NULL);
}


/* OnUpdate()
 *
 * pHint can be a pointer to a CBox, if only that CBox needs to be redrawn.
 */
void CBoxNetView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    CBox *      pbox;
    CBoxSocket *psock;
    CBoxLink *  plink;
    CRect       rc;

    SetScrollSizes(MM_TEXT, GetDocument()->GetSize());

#if 0
    CMainFrame *pMainFrame = (CMainFrame*)AfxGetApp()->m_pMainWnd;
    
    if (GetDocument()->IsDVRCaptureGraph())
    {
        ((CMDIChildWnd*) GetParentFrame())->SetHandles(pMainFrame->m_hDVRCaptureMenu, GetParentFrame()->m_hAccelTable);
    }
    else
    {
        ((CMDIChildWnd*) GetParentFrame())->SetHandles(pMainFrame->m_hRegularMenu, GetParentFrame()->m_hAccelTable);
    }
    //AfxGetMainWnd()->DrawMenuBar();
    if (pMainFrame->MDIGetActive() == GetParentFrame())
    {
        // Update the menu bar
        ((CChildFrame*) GetParentFrame())->UpdateMenuBar();
    }
#endif

    switch ((int) lHint)
    {

    case CBoxNetDoc::HINT_DRAW_ALL:

        // repaint entire window
//        TRACE("HINT_DRAW_ALL\n");
        InvalidateRect(NULL, TRUE);
        break;

    case CBoxNetDoc::HINT_CANCEL_VIEWSELECT:

        // cancel any selection maintained by the view
//        TRACE("HINT_CANCEL_VIEWSELECT\n");
        break;

    case CBoxNetDoc::HINT_CANCEL_MODES:

        // cancel modes like select rectangle, drag boxes, etc.
//        TRACE("HINT_CANCEL_MODES\n");
        CancelModes();
        break;

    case CBoxNetDoc::HINT_DRAW_BOX:

        // repaint given box
        pbox = (CBox *) pHint;
        gpboxdraw->GetOrInvalBoundRect(pbox, &rc, FALSE, this);
//        TRACE("HINT_DRAW_BOX: (%d,%d,%d,%d)\n", rc.left, rc.top, rc.right, rc.bottom);
        break;

    case CBoxNetDoc::HINT_DRAW_BOXANDLINKS:

        // repaint given box
        pbox = (CBox *) pHint;
        gpboxdraw->GetOrInvalBoundRect(pbox, &rc, TRUE, this);
//        TRACE("HINT_DRAW_BOXANDLINKS: (%d,%d,%d,%d)\n", rc.left, rc.top, rc.right, rc.bottom);
        break;

    case CBoxNetDoc::HINT_DRAW_BOXTAB:

        // repaint given box tab
        psock = (CBoxSocket *) pHint;
        gpboxdraw->DrawTab(psock, &rc, NULL, FALSE, FALSE);
//        TRACE("HINT_DRAW_BOXTAB\n");
        InvalidateRect(&(rc - GetScrollPosition()), TRUE);
        break;

    case CBoxNetDoc::HINT_DRAW_LINK:

        // repaint given link
        plink = (CBoxLink *) pHint;
        gpboxdraw->GetOrInvalLinkRect(plink, &rc, this);
//        TRACE("HINT_DRAW_LINK\n");
        break;



    }
}


void CBoxNetView::OnDraw(CDC* pdc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CRect           rc;

    if (pdc->IsPrinting()) {
        pdc->SetMapMode(MM_ISOTROPIC);

        CSize DocSize = GetDocument()->GetSize();
        CSize PrintSize(pdc->GetDeviceCaps(HORZRES),pdc->GetDeviceCaps(VERTRES));

        if ((DocSize.cx != 0) && (DocSize.cy != 0)) {
            // choose smaller of PrintX/docX or PrintY/DocY as isotropic scale factor
            if (PrintSize.cx * DocSize.cy < PrintSize.cy * DocSize.cx) {
                PrintSize.cy = (DocSize.cy * PrintSize.cx) / DocSize.cx;
                PrintSize.cx = (DocSize.cx * PrintSize.cx) / DocSize.cx;
            }
            else {
                PrintSize.cx = (DocSize.cx * PrintSize.cy) / DocSize.cx;
                PrintSize.cy = (DocSize.cy * PrintSize.cy) / DocSize.cx;
            }
        }

        pdc->SetWindowExt(DocSize);
        pdc->SetViewportExt(PrintSize);
    }
    else {
        pdc->SetMapMode(MM_TEXT);
    }

    // save the clipping region
    pdc->SaveDC();

    // draw all boxes in list that might be within clipping region
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (pdc->RectVisible(pbox->GetRect()))
        {
//            TRACE("draw box 0x%08lx\n", (LONG) (LPCSTR) pbox);
            gpboxdraw->DrawBox(pbox, pdc, m_psockHilite);
        }
    }

    if (!pdc->IsPrinting()) {
        // fill the unpainted portion of the window with background color
        pdc->GetClipBox(&rc);
        CBrush br(gpboxdraw->GetBackgroundColor());
        CBrush *pbrPrev = pdc->SelectObject(&br);
        pdc->PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATCOPY);
        if (pbrPrev != NULL)
            pdc->SelectObject(pbrPrev);
    }

    // restore the clipping region
    pdc->RestoreDC(-1);

    // draw all links that might be within clipping region
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = (CBoxLink *) pdoc->m_lstLinks.GetNext(pos);
        gpboxdraw->GetOrInvalLinkRect(plink, &rc);
        if (pdc->RectVisible(&rc))
        {
//            TRACE("draw link 0x%08lx\n", (LONG) (LPCSTR) plink);
            gpboxdraw->DrawLink(plink, pdc);
        }
    }

    // paint the ghost selection (if it's currently visible)
    if (m_fGhostSelection)
        GhostSelectionDraw(pdc);

    // paint the ghost arrow (if it's currently visible)
    if (m_fGhostArrow)
        GhostArrowDraw(pdc);

    // paint the select-rectangle rectangle (if we're in that mode)
    if (m_fSelectRect)
        SelectRectDraw(pdc);
}


/* eHit = HitTest(pt, ppbox, ptabpos, ppsock, pplink, pptProject, ppbend)
 *
 * See if <pt> hits something in the view.
 *
 * If <pt> hits a link, return the HT_XXX code, and set <**pplink>,
 * <*pptProject>, and/or <*ppbend>, as defined by CBoxDraw::HitTestLink().
 * If not, set <*pplink> to NULL.
 *
 * If <pt> hits a box, return the HT_XXX code, set <*ppbox>, <*ptabpos> and/or
 * <*ppsock>, as defined by CBoxDraw::HitTestBox().  If not, set <*ppbox>
 * to NULL.
 *
 * If <pt> hits nothing, return HT_MISS.
 */
CBoxDraw::EHit CBoxNetView::HitTest(CPoint pt, CBox **ppbox,
    CBoxTabPos *ptabpos, CBoxSocket **ppsock, CBoxLink **pplink,
    CPoint *pptProject)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBoxDraw::EHit  eHit;           // hit-test result code
    POSITION        pos;            // position in linked list

    // these pointers must be NULL if they aren't valid
    *ppbox = NULL;
    *pplink = NULL;

    // adjust for the current scroll position
    pt += CSize(GetDeviceScrollPosition());

    // see if <pt> hits any box
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        *ppbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        eHit = gpboxdraw->HitTestBox(*ppbox, pt, ptabpos, ppsock);
        if (eHit != CBoxDraw::HT_MISS)
            return eHit;
    }
    *ppbox = NULL;

    // see if <pt> hits any link
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        *pplink = (CBoxLink *) pdoc->m_lstLinks.GetNext(pos);
        eHit = gpboxdraw->HitTestLink(*pplink, pt, pptProject);
        if (eHit != CBoxDraw::HT_MISS)
            return eHit;
    }
    *pplink = NULL;

    // hit the background
    return CBoxDraw::HT_MISS;
}



/* CancelModes()
 *
 * Cancel all CBoxNetView modes (e.g. mouse-drag mode, move-selection mode,
 * etc.), including deselecting anything selected in the view (but not
 * including items for which the document maintains the selection state).
 * This is a superset of CancelViewSelection().
 */
void CBoxNetView::CancelModes()
{
    if (m_fMouseDrag)
        MouseDragEnd();
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingEnd(TRUE);
    if (m_fMoveBoxSel)
        MoveBoxSelEnd(TRUE);
    if (m_fGhostSelection)
        GhostSelectionDestroy();
    if (m_fSelectRect)
        SelectRectEnd(TRUE);
    if (m_fNewLink)
        NewLinkEnd(TRUE);
    if (m_fGhostArrow)
        GhostArrowEnd();
    if (m_psockHilite != NULL)
        SetHiliteTab(NULL);
}


/////////////////////////////////////////////////////////////////////////////
// printing support


BOOL CBoxNetView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}


void CBoxNetView::OnBeginPrinting(CDC* /*pdc*/, CPrintInfo* /*pInfo*/)
{
}


void CBoxNetView::OnEndPrinting(CDC* /*pdc*/, CPrintInfo* /*pInfo*/)
{
}


/////////////////////////////////////////////////////////////////////////////
// mouse-drag mode


/* MouseDragBegin(nFlags, pt, pboxMouse)
 *
 * Enter mouse-drag mode.  In this mode, the mouse is captured, and the
 * following information is maintained:
 *   -- <m_fMouseShift>: TRUE if Shift held down when mouse clicked;
 *   -- <m_ptMouseAnchor>: the point at which the click occurred;
 *   -- <m_ptMousePrev>: the previous position of the mouse (as specified
 *      in the previous call to MouseDragBegin() or MouseDragContinue();
 *   -- <m_pboxMouse>: set to <pboxMouse>, which should point to the
 *      initially clicked-on box (or NULL if none);
 *   -- <m_fMouseBoxSel>: TRUE if clicked-on box was initially selected.
 */
void CBoxNetView::MouseDragBegin(UINT nFlags, CPoint pt, CBox *pboxMouse)
{
    m_fMouseDrag = TRUE;
    m_fMouseShift = ((nFlags & MK_SHIFT) != 0);
    m_ptMouseAnchor = m_ptMousePrev = pt;
    m_pboxMouse = pboxMouse;
    m_fMouseBoxSel = (pboxMouse == NULL ? FALSE : pboxMouse->IsSelected());
    SetCapture();
}


/* MouseDragContinue(pt)
 *
 * Continue mouse-drag mode (initiated by MouseDragBegin()), and specify
 * that the current mouse position is at <pt> (which causes <m_ptMousePrev>
 * to be set to this value).
 */
void CBoxNetView::MouseDragContinue(CPoint pt)
{
    m_ptMousePrev = pt;
}


/* MouseDragEnd()
 *
 * End mouse-drag mode (initiated by MouseDragBegin().
 */
void CBoxNetView::MouseDragEnd()
{
    m_fMouseDrag = FALSE;
    if (this == GetCapture())
        ReleaseCapture();
}


/////////////////////////////////////////////////////////////////////////////
// move-selection-pending mode (for use within mouse-drag mode)

/* MoveBoxSelPendingBegin(pt)
 *
 * Enter move-selection-pending mode.  In this mode, if the user waits long
 * enough, or drags the mouse far enough, the user enters move-selection mode
 * (in which the selected boxes and connected links are dragged to a new
 * location).  If not (i.e. if the user releases the mouse button quickly,
 * without dragging far) then if the user shift-clicked on a selected box then
 * the box is deselected.
 *
 * <pt> is the current location of the mouse.
 */
void CBoxNetView::MoveBoxSelPendingBegin(CPoint pt)
{
    m_fMoveBoxSelPending = TRUE;

    // set <m_rcMoveSelPending>; if the mouse leaves this rectangle
    // end move-selection-pending mode and begin move-selection mode
    CSize siz = CSize(GetSystemMetrics(SM_CXDOUBLECLK),
                      GetSystemMetrics(SM_CYDOUBLECLK));
    m_rcMoveSelPending = CRect(pt - siz, siz + siz);

    // set a timer to potentially end move-selection-pending mode
    // and begin move-selection mode
    SetTimer(TIMER_MOVE_SEL_PENDING, GetDoubleClickTime(), NULL);

    MFGBL(SetStatus(IDS_STAT_MOVEBOX));
}


/* MoveBoxSelPendingContinue(pt)
 *
 * Continue move-selection-pending mode.  See if the user dragged the mouse
 * (which is at <pt>) far enough to enter move-selection mode.
 */
void CBoxNetView::MoveBoxSelPendingContinue(CPoint pt)
{
    if (!m_rcMoveSelPending.PtInRect(pt))
    {
        // mouse moved far enough -- end move-selection-pending mode
        MoveBoxSelPendingEnd(FALSE);
    }
}


/* MoveBoxSelPendingEnd(fCancel)
 *
 * End move-selection-pending mode.  If <fCancel> is FALSE, then enter
 * move-selection mode.  If <fCancel> is TRUE, then if the user shift-clicked
 * on a selecte box, deselect it.
 */
void CBoxNetView::MoveBoxSelPendingEnd(BOOL fCancel)
{
    CBoxNetDoc *    pdoc = GetDocument();

    // end move-selection-pending mode
    m_fMoveBoxSelPending = FALSE;
    KillTimer(TIMER_MOVE_SEL_PENDING);

    if (fCancel)
    {
        // if the user shift-clicked a selected box, deselect it
        if (m_fMouseShift && m_fMouseBoxSel)
            pdoc->SelectBox(m_pboxMouse, FALSE);
    }
    else
    {
        // begin move-selection mode
        MoveBoxSelBegin();

        // give the user some feedback immediately (rather than waiting until
        // they move the mouse)
        CPoint pt;
        ::GetCursorPos(&pt);
        ScreenToClient(&pt);
        MoveBoxSelContinue(pt - m_ptMouseAnchor);
    }
}


/////////////////////////////////////////////////////////////////////////////
// move-selection mode


/* MoveBoxSelBegin()
 *
 * Enter into move-selection mode.  While in this mode, the selection is
 * not actually moved (until the mode is ended).  Instead, a ghost selection
 * is moved.
 */
void CBoxNetView::MoveBoxSelBegin()
{
    GhostSelectionCreate();
    m_fMoveBoxSel = TRUE;
    MFGBL(SetStatus(IDS_STAT_MOVEBOX));
}


/* MoveBoxSelContinue(sizOffset)
 *
 * Continue move-selection mode.  Request that the ghost selection (showing
 * where the selection would be moved to if it were dropped right now)
 * move to offset <sizOffset> from the selection location.
 */
void CBoxNetView::MoveBoxSelContinue(CSize sizOffset)
{
    GhostSelectionMove(sizOffset);
}


/* MoveBoxSelEnd(fCancel)
 *
 * End move-selection mode.  If <fCancel> is FALSE, then move the selection
 * to where the ghost selection was moved by calls to MoveBoxSelContinue().
 * If <fCancel> is TRUE, don't move the selection.
 */
void CBoxNetView::MoveBoxSelEnd(BOOL fCancel)
{
    GhostSelectionDestroy();

    m_fMoveBoxSel = FALSE;

    if (!fCancel)
        MoveBoxSelection(m_sizGhostSelOffset);
}


/* MoveBoxSelection(sizOffset)
 *
 * Create and execute a command to move each selected box by <sizOffset>.
 */
void CBoxNetView::MoveBoxSelection(CSize sizOffset)
{
    CBoxNetDoc *    pdoc = GetDocument();

    pdoc->CmdDo(new CCmdMoveBoxes(sizOffset));
}


/* sizOffsetNew = ConstrainMoveBoxSel(sizOffset, fCalcSelBoundRect)
 *
 * Assume you want to move the current selection by <sizOffset>.
 * This function returns the offset that you should actually move the
 * current selection by, if you want to be restricted to being below and
 * to the right of (0,0).
 *
 * If <fCalcSelBoundRect> is TRUE, then set <m_rcSelBound> to the
 * bounding rectangle of the current selection (required in order to
 * constrain the selection).  Otherwise, assume <m_rcSelBound> has already
 * been calculated.
 *
 * We restrict the selection to be moved no further than 0 for top and
 * left and to MAX_DOCUMENT_SIZE for right and bottom.
 *
 * In this function we restrict the user's ability to exceed the maximum
 * size of the ScrollView. Note that Filters are only added to the
 * visible part of the existing ScrollView.
 *
 * The only place where a further check has to be made is in the
 * automatic filter layout. (bnetdoc.cpp CBoxNetDoc::
 *
 */
CSize CBoxNetView::ConstrainMoveBoxSel(CSize sizOffset,
    BOOL fCalcSelBoundRect)
{
    CBoxNetDoc *    pdoc = GetDocument();

    if (fCalcSelBoundRect)
        pdoc->GetBoundingRect(&m_rcSelBound, TRUE);

    // constrain <sizOffset> to be below and to the right of (0,0)
    CRect rc(m_rcSelBound);
    rc.OffsetRect(sizOffset);
    if (rc.left < 0)
        sizOffset.cx -= rc.left;
    if (rc.top < 0)
        sizOffset.cy -= rc.top;
    if (rc.right > MAX_DOCUMENT_SIZE)
        sizOffset.cx -= (rc.right - MAX_DOCUMENT_SIZE);
    if (rc.bottom > MAX_DOCUMENT_SIZE)
        sizOffset.cy -= (rc.bottom - MAX_DOCUMENT_SIZE);

    return sizOffset;
}


/////////////////////////////////////////////////////////////////////////////
// ghost-selection mode


/* GhostSelectionCreate()
 *
 * Create a "ghost selection", which appears to the user as a copy of the
 * current selection, but only drawn in "skeletal form" (e.g. only the
 * outline of boxes), and drawn with pixels inverted.
 *
 * Start the ghost selection at the same location as the current
 * selection.
 */
void CBoxNetView::GhostSelectionCreate()
{
    CBoxNetDoc *    pdoc = GetDocument();
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // draw the ghost selection
    m_sizGhostSelOffset = CSize(0, 0);
    GhostSelectionDraw(&dc);

    // get the bounding rectangle for the box selection
    pdoc->GetBoundingRect(&m_rcSelBound, TRUE);
}


/* GhostSelectionMove(sizOffset)
 *
 * Move the ghost selection (created by GhostSelectionCreate()) to the
 * location of the current selection, but offset by <sizOffset> pixels.
 * The ghost selection will be restricted to being below and to the
 * right of (0,0), and will snap to the current grid setting.
 */
void CBoxNetView::GhostSelectionMove(CSize sizOffset)
{
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // keep below/right of (0,0) and snap to grid
    sizOffset = ConstrainMoveBoxSel(sizOffset, FALSE);

    // erase previous ghost selection
    GhostSelectionDraw(&dc);

    // move and redraw ghost selection
    m_sizGhostSelOffset = sizOffset;
    GhostSelectionDraw(&dc);
}


/* GhostSelectionDestroy()
 *
 * Destroy the ghost selection (created by GhostSelectionCreate()).
 */
void CBoxNetView::GhostSelectionDestroy()
{
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // erase current ghost selection
    GhostSelectionDraw(&dc);
}


/* GhostSelectionDraw(pdc)
 *
 * Draw the current ghost selection in <pdc>.
 */
void CBoxNetView::GhostSelectionDraw(CDC *pdc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc

    // draw all selected boxes in "ghost form"
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
            gpboxdraw->DrawBox(pbox, pdc, NULL, &m_sizGhostSelOffset);
    }

    // draw all links to selected boxes in "ghost form"
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = (CBoxLink *) pdoc->m_lstBoxes.GetNext(pos);
        if (plink->m_psockTail->m_pbox->IsSelected() ||
            plink->m_psockHead->m_pbox->IsSelected())
            gpboxdraw->DrawLink(plink, pdc, FALSE, &m_sizGhostSelOffset);
    }
}


/////////////////////////////////////////////////////////////////////////////
// select-rectangle mode


/* SelectRectBegin(pt)
 *
 * Enter into select-rectangle mode.  While in this mode, a rectangle is drawn
 * in the window.  When the mode ends, all boxes that intersect the rectangle
 * will be selected.
 *
 * <pt> defines the anchor point, i.e. the point to use to start drawing the
 * rectangle (i.e. it must be one of the corners of the desired rectangle).
 */
void CBoxNetView::SelectRectBegin(CPoint pt)
{
    CClientDC       dc(this);       // DC onto window

    // exit select-rectangle mode
    m_fSelectRect = TRUE;
    m_ptSelectRectAnchor = m_ptSelectRectPrev = pt;

    // draw the initial selection rectangle
    SelectRectDraw(&dc);

    MFGBL(SetStatus(IDS_STAT_SELECTRECT));
}


/* SelectRectContinue(pt)
 *
 * Continue select-rectangle mode.  Draw the rectangle from the anchor point
 * (specified in SelectRectBegin()) to <pt>.
 */
void CBoxNetView::SelectRectContinue(CPoint pt)
{
    CClientDC       dc(this);       // DC onto window

    // move the selection rectangle
    SelectRectDraw(&dc);
    m_ptSelectRectPrev = pt;
    SelectRectDraw(&dc);
}


/* SelectRectEnd(fCancel)
 *
 * End select-rectangle mode.  If <fCancel> is FALSE, then select all boxes
 * that intersect the rectangle.
 */
void CBoxNetView::SelectRectEnd(BOOL fCancel)
{
    CClientDC       dc(this);       // DC onto window

    // erase the selection rectangle
    SelectRectDraw(&dc);

    // exit select-rectangle mode
    m_fSelectRect = FALSE;

    if (!fCancel)
    {
        // select all boxes intersecting the rectangle
        CRect rc(m_ptSelectRectAnchor.x, m_ptSelectRectAnchor.y,
            m_ptSelectRectPrev.x, m_ptSelectRectPrev.y);
        NormalizeRect(&rc);
        rc.OffsetRect(GetDeviceScrollPosition());
        SelectBoxesIntersectingRect(&rc);
    }
}


/* SelectRectDraw(pdc)
 *
 * Draw the current select-rectangle rectangle (assuming that we are in
 * select-rectangle mode, initiated by SelectRectBegin()).  Calling this
 * function again will erase the rectangle (assuming that <m_ptSelectRectPrev>
 * and <m_ptSelectRectAnchor> haven't changed).
 */
void CBoxNetView::SelectRectDraw(CDC *pdc)
{
    // use DrawFocusRect() to invert the pixels in a rectangle frame
    CRect rc(m_ptSelectRectAnchor.x, m_ptSelectRectAnchor.y,
        m_ptSelectRectPrev.x, m_ptSelectRectPrev.y);
    NormalizeRect(&rc);
    pdc->DrawFocusRect(&rc);
}


/* SelectBoxesIntersectingRect(CRect *prc)
 *
 * Select all boxes that intersect <*prc>.
 */
void CBoxNetView::SelectBoxesIntersectingRect(CRect *prc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CRect           rcTmp;

    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (rcTmp.IntersectRect(&pbox->GetRect(), prc))
            pdoc->SelectBox(pbox, TRUE);

    }
}


/////////////////////////////////////////////////////////////////////////////
// new-link mode


/* NewLinkBegin(CPoint pt, CBoxSocket *psock)
 *
 * Enter into new-link mode.  While in this mode, the user is dragging from
 * one socket to another socket to create a link.  A ghost arrow is displayed
 * (from the clicked-on socket to the current mouse location) to give the user
 * feedback.
 *
 * <pt> is the clicked-on point; <psock> is the clicked-on socket.
 */
void CBoxNetView::NewLinkBegin(CPoint pt, CBoxSocket *psock)
{
    CBoxNetDoc *    pdoc = GetDocument();

    GetDocument()->DeselectAll();
    m_fNewLink = TRUE;
    m_psockNewLinkAnchor = psock;
    GhostArrowBegin(pt);
    MFGBL(SetStatus(IDS_STAT_DRAGLINKEND));
}


/* NewLinkContinue(pt)
 *
 * Continue new-link mode.  Draw the ghost arrow from the anchor socket
 * (specified in SelectRectBegin()) to <pt>.
 */
void CBoxNetView::NewLinkContinue(CPoint pt)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // a socket in a box
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CPoint          ptProject;      // point on link line segment nearest <pt>

    GhostArrowContinue(pt);

    // set <psock> to the socket <pt> is over (NULL if none)
    if (HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject)
        != CBoxDraw::HT_TAB)
        psock = NULL;

    // if <pt> is over a socket that is not already connected, highlight it
    if ((psock == NULL) || (psock->m_plink != NULL))
    {
        SetHiliteTab(NULL);
        MFGBL(SetStatus(IDS_STAT_DRAGLINKEND));
    }
    else
    {
        SetHiliteTab(psock);
        MFGBL(SetStatus(IDS_STAT_DROPLINKEND));
    }
}


/* NewLinkEnd(fCancel)
 *
 * End new-link mode.  If <fCancel> is FALSE, then create a link from
 * the anchor socket (specified in NewLinkBegin()) to <m_psockHilite>.
 */
void CBoxNetView::NewLinkEnd(BOOL fCancel)
{
    CBoxNetDoc *    pdoc = GetDocument();

    GhostArrowEnd();

    if (!fCancel)
    {
        // make link between <m_psockNewLinkAnchor> and <m_psockHilite>
        if (m_psockNewLinkAnchor->GetDirection()
             == m_psockHilite->GetDirection()) {
            //
            // We cannot connect pins of same direction
            // (different error messages for two input or output pins
            //
            if (m_psockNewLinkAnchor->GetDirection() == PINDIR_INPUT) {
                AfxMessageBox(IDS_CANTCONNECTINPUTS);
            }
            else {
                AfxMessageBox(IDS_CANTCONNECTOUTPUTS);
            }
        }
        else {
            pdoc->CmdDo(new CCmdConnect(m_psockNewLinkAnchor, m_psockHilite));
        }
    }

    // end new-link mode
    SetHiliteTab(NULL);
    m_fNewLink = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// ghost-arrow mode


/* GhostArrowBegin(pt)
 *
 * Create a ghost arrow that's initially got its head and tail at <pt>.
 * The ghost arrow appears to float above all boxes.  There can only be
 * one active ghost arrow in CBoxNetView at a time.
 */
void CBoxNetView::GhostArrowBegin(CPoint pt)
{
    CClientDC       dc(this);

    m_fGhostArrow = TRUE;
    m_ptGhostArrowTail = m_ptGhostArrowHead = pt;
    GhostArrowDraw(&dc);
}


/* GhostArrowContinue(pt)
 *
 * Move the head of the ghost arrow (created by GhostArrowCreate()) to <pt>.
 */
void CBoxNetView::GhostArrowContinue(CPoint pt)
{
    CClientDC       dc(this);

    GhostArrowDraw(&dc);
    m_ptGhostArrowHead = pt;
    GhostArrowDraw(&dc);
}


/* GhostArrowEnd()
 *
 * Erase the ghost arrow that was created by GhostArrowCreate().
 */
void CBoxNetView::GhostArrowEnd()
{
    CClientDC       dc(this);

    GhostArrowDraw(&dc);
    m_fGhostArrow = FALSE;
}


/* GhostArrowDraw(pdc)
 *
 * Draw the ghost arrow that was created by GhostArrowCreate().
 */
void CBoxNetView::GhostArrowDraw(CDC *pdc)
{
    gpboxdraw->DrawArrow(pdc, m_ptGhostArrowTail, m_ptGhostArrowHead, TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// highlight-tab mode


/* SetHiliteTab(psock)
 *
 * Set the currently-highlighted box socket tab to be <psock>
 * (NULL if no socket should be highlighted).
 */
void CBoxNetView::SetHiliteTab(CBoxSocket *psock)
{
    if (m_psockHilite == psock)
        return;
    if (m_psockHilite != NULL)
        OnUpdate(this, CBoxNetDoc::HINT_DRAW_BOXTAB, m_psockHilite);
    m_psockHilite = psock;
    if (m_psockHilite != NULL)
        OnUpdate(this, CBoxNetDoc::HINT_DRAW_BOXTAB, m_psockHilite);
}




/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CBoxNetView, CScrollView)
    //{{AFX_MSG_MAP(CBoxNetView)
    ON_WM_SETCURSOR()
    ON_WM_ERASEBKGND()
    ON_WM_LBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_TIMER()
    ON_COMMAND(ID_CANCEL_MODES, OnCancelModes)
        ON_WM_RBUTTONDOWN()
        ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
        ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
        ON_UPDATE_COMMAND_UI(IDM_SAVE_PERF_LOG, OnUpdateSavePerfLog)
        ON_COMMAND(IDM_SAVE_PERF_LOG, OnSavePerfLog)
        ON_UPDATE_COMMAND_UI(ID_NEW_PERF_LOG, OnUpdateNewPerfLog)
        ON_COMMAND(ID_NEW_PERF_LOG, OnNewPerfLog)
        ON_COMMAND(ID_FILE_SET_LOG, OnFileSetLog)
        ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)

    ON_COMMAND(ID__PROPERTIES, OnProperties)
    ON_UPDATE_COMMAND_UI(ID__PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID__SELECTCLOCK, OnSelectClock)


//    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateSave)  // Disable Save
//    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_AS, OnUpdateSave) // Disable Save

    ON_MESSAGE(WM_USER_EC_EVENT, OnUser)   // event notification messages

END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// message callback functions


BOOL CBoxNetView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
    CBoxNetDoc*     pdoc = GetDocument();
    CPoint          pt;             // point to hit-test
    CBoxDraw::EHit  eHit;           // hit-test result code
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // a socket in a box
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CPoint          ptProject;      // point on link line segment nearest <pt>

    // set <pt> to the location of the cursor
    ::GetCursorPos(&pt);
    ScreenToClient(&pt);

    // hit-test all items in document
    eHit = HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject);

    // set the cursor and/or set status bar text accordingly
    switch(eHit)
    {

    case CBoxDraw::HT_MISS:         // didn't hit anything

        // default message
        MFGBL(SetStatus(AFX_IDS_IDLEMESSAGE));
        break;

    case CBoxDraw::HT_TAB:          // hit a box tab <*ppsock>

        MFGBL(SetStatus(IDS_STAT_BOXTABEMPTY));
        break;

    case CBoxDraw::HT_EDGE:         // hit the edge box (set <*ptabpos> to it)
    case CBoxDraw::HT_BOX:          // hit elsewhere on the box
    case CBoxDraw::HT_BOXLABEL:     // hit the box label
    case CBoxDraw::HT_BOXFILE:      // hit the box filename
    case CBoxDraw::HT_TABLABEL:     // hit box tab label <*ppsock>

        // can drag box to move it
        MFGBL(SetStatus(IDS_STAT_MOVEBOX));
        break;

    case CBoxDraw::HT_LINKLINE:     // hit a link line segment
        MFGBL(SetStatus(AFX_IDS_IDLEMESSAGE));
        break;
    }

    return CScrollView::OnSetCursor(pWnd, nHitTest, message);
}


BOOL CBoxNetView::OnEraseBkgnd(CDC* pdc)
{
    // do nothing -- OnDraw() draws the background
    return TRUE;
}


void CBoxNetView::OnLButtonDown(UINT nFlags, CPoint pt)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBoxDraw::EHit  eHit;           // hit-test result code
    CBox *          pbox;           // clicked-on box (NULL if none)
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // clicked-on socket tab (if applicable)
    CBoxLink *      plink;          // clicked-on link (if applicable)
    CPoint          ptProject;      // point on link line segment nearest <pt>
    CSize           siz;

    // see what item mouse clicked on
    eHit = HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject);

    // enter mouse-drag mode
    MouseDragBegin(nFlags, pt, pbox);

    // figure out what action to take as a result of the click
    switch(eHit)
    {

    case CBoxDraw::HT_BOX:
    case CBoxDraw::HT_BOXLABEL:
    case CBoxDraw::HT_BOXFILE:
    case CBoxDraw::HT_TABLABEL:

        // user clicked on box <pbox>

        if (!pbox->IsSelected()) {      // user clicked on an unselected box

            if (!m_fMouseShift || pdoc->IsSelectionEmpty()) {   // deselect all, select this box

                GetDocument()->DeselectAll();
                pdoc->SelectBox(pbox, TRUE);
            }
            else {      // shift-click -- add box to selection

                pdoc->SelectBox(pbox, TRUE);
            }
        }

        // enter move-selection-pending mode (start moving the selection if
        // the user waits long enough or drags the mouse far enough)
        MoveBoxSelPendingBegin(pt);
        break;

    case CBoxDraw::HT_TAB:

        // user clicked on the box tab of socket <psock>
        if (psock->m_plink == NULL) {
            NewLinkBegin(pt, psock);            // enter new-link mode
        }

        break;

    case CBoxDraw::HT_LINKLINE:

        if (!m_fMouseShift || pdoc->IsSelectionEmpty()) { // deselect all, select this link

            GetDocument()->DeselectAll();
            pdoc->SelectLink(plink, TRUE);
        }
        else {  // shift-click -- add box to link

            pdoc->SelectLink(plink, TRUE);
        }

        break;

    default:

        // didn't click on anything -- deselect all items and enter
        // select-rectangle mode
        GetDocument()->DeselectAll();
        SelectRectBegin(pt);
        break;

    }

    CScrollView::OnLButtonDown(nFlags, pt);
}


void CBoxNetView::OnMouseMove(UINT nFlags, CPoint pt)
{
    // do nothing if not currently in mouse-drag mode
    if (!m_fMouseDrag)
        return;

    // update active modes
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingContinue(pt);
    if (m_fMoveBoxSel)
        MoveBoxSelContinue(pt - m_ptMouseAnchor);
    if (m_fSelectRect)
        SelectRectContinue(pt);
    if (m_fNewLink)
        NewLinkContinue(pt);

    // update drag state
    MouseDragContinue(pt);

    CScrollView::OnMouseMove(nFlags, pt);
}


void CBoxNetView::OnLButtonUp(UINT nFlags, CPoint pt) {

    // do nothing if not currently in mouse-drag mode
    if (!m_fMouseDrag)
        return;

    // update active modes
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingEnd(TRUE);
    if (m_fMoveBoxSel)
        MoveBoxSelEnd(FALSE);
    if (m_fSelectRect)
        SelectRectEnd(FALSE);
    if (m_fNewLink)
        NewLinkEnd(m_psockHilite == NULL);

    // update drag state
    MouseDragEnd();

    CScrollView::OnLButtonUp(nFlags, pt);
}


void CBoxNetView::OnTimer(UINT nIDEvent)
{
    // dispatch timer to code that created it
    switch (nIDEvent)
    {

    case TIMER_MOVE_SEL_PENDING:
        MoveBoxSelPendingEnd(FALSE);
        break;

    case TIMER_SEEKBAR:
        CheckSeekBar( );
        break;

    case TIMER_PENDING_RECONNECT:
        CBoxNetDoc* pDoc = GetDocument();

        HRESULT hr = pDoc->ProcessPendingReconnect();

        // ProcessPendingReconnect() returns S_OK if the output pin was successfully reconnected.
        if( S_OK == hr ) {
            AfxMessageBox( IDS_ASYNC_RECONNECT_SUCCEEDED );
        } else if( FAILED( hr ) ) {
            CString strErrorMessage;

            try
            {
                strErrorMessage.Format( IDS_ASYNC_RECONNECT_FAILED, hr );
                if( 0 == AfxMessageBox( (LPCTSTR)strErrorMessage ) ) {
                    TRACE( TEXT("WARNING: ProcessPendingReconnect() failed but the user could not be notified because AfxMessageBox() also failed.") );
                }

            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                TRACE( TEXT("WARNING: ProcessPendingReconnect() failed but the user could not be notified because a CMemoryException was thrown.") );
            }
        }
   
        break;
    }

    CScrollView::OnTimer(nIDEvent);
}


void CBoxNetView::OnCancelModes() {

    CancelModes();
}


//
// OnRButtonDown
//
// Pop up a context sensitive shortcut menu
void CBoxNetView::OnRButtonDown(UINT nFlags, CPoint point)
{
    CBoxNetDoc      *pdoc = GetDocument();
    CBoxDraw::EHit  eHit;               // hit-test result code
    CBox            *pbox;              // clicked-on box (NULL if none)
    CBoxTabPos      tabpos;             // the position of a socket tab on a box
    CBoxSocket      *psock;             // clicked-on socket tab (if applicable)
    CBoxLink        *plink;             // clicked-on link (if applicable)
    CPoint          ptProject;          // point on link line segment nearest <pt>

    // see what item mouse clicked on
    eHit = HitTest(point, &pbox, &tabpos, &psock, &plink, &ptProject);

    // figure out what action to take as a result of the click
    switch(eHit)
    {

    case CBoxDraw::HT_BOX:
    case CBoxDraw::HT_BOXLABEL:
    case CBoxDraw::HT_BOXFILE:
    case CBoxDraw::HT_TABLABEL: {
            // user clicked on box <pbox>

            pdoc->CurrentPropObject(pbox);

            CMenu       menu;
            menu.LoadMenu(IDR_FILTERMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PrepareFilterMenu(menuPopup, pbox);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    case CBoxDraw::HT_TAB: {
            // user clicked on the box tab of socket <psock>

            pdoc->SelectedSocket(psock);        // set the selected socket, so the ui can be updated correctly
            pdoc->CurrentPropObject(psock);

            CMenu       menu;
            menu.LoadMenu(IDR_PINMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PreparePinMenu(menuPopup);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    case CBoxDraw::HT_LINKLINE: {       // the filter menu (properties) also applies
                                        // to links
            // user clicked on link <plink>

            pdoc->CurrentPropObject(plink);

            CMenu       menu;
            menu.LoadMenu(IDR_LINKMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PrepareLinkMenu(menuPopup);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    default:
        break;

    }

        
    CScrollView::OnRButtonDown(nFlags, point);
}


//
// OnUpdateProperties
//
void CBoxNetView::OnUpdateProperties(CCmdUI* pCmdUI) {

    pCmdUI->Enable(GetDocument()->CurrentPropObject()->CanDisplayProperties());
}

//
// OnProperties
//
// The user wants to  edit/view the properties of the
// selected object
void CBoxNetView::OnProperties() {

    GetDocument()->CurrentPropObject()->CreatePropertyDialog(this);
}

//
// OnUpdateSelectClock
//
//void CBoxNetView::OnUpdateSelectClock(CCmdUI* pCmdUI)
//{
//}

//
// OnSelectClock
//
void CBoxNetView::OnSelectClock()
{
    ASSERT (m_pSelectClockFilter);
    GetDocument()->SetSelectClock(m_pSelectClockFilter);

    m_pSelectClockFilter = NULL;
}


//
// PrepareLinkMenu
//
void CBoxNetView::PrepareLinkMenu(CMenu *menuPopup) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }
}

//
// PrepareFilterMenu
//
// The MFC OnUpdate routing does not get popups right. therefore
// DIY
void CBoxNetView::PrepareFilterMenu(CMenu *menuPopup, CBox *pbox) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }

    //
    // Only enable clock selection if the filter has a clock and it
    // is not yet selected.
    //
    if (pbox->HasClock() && !pbox->HasSelectedClock()) {
        menuPopup->EnableMenuItem(ID__SELECTCLOCK, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__SELECTCLOCK, MF_GRAYED);
    }

    m_pSelectClockFilter = pbox;
}


//
// PreparePinMenu
//
// The MFC OnUpdate routing does not get popups right. therefore
// DIY
void CBoxNetView::PreparePinMenu(CMenu *menuPopup) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }

    if (CCmdRender::CanDo(GetDocument())) {
        menuPopup->EnableMenuItem(ID_RENDER, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID_RENDER, MF_GRAYED);
    }

    if (CCmdReconnect::CanDo(GetDocument())) {
        menuPopup->EnableMenuItem(ID_RECONNECT, MF_ENABLED);
    } else {
        menuPopup->EnableMenuItem(ID_RECONNECT, MF_GRAYED);
    }
}


void CBoxNetView::OnUpdateEditDelete(CCmdUI* pCmdUI) {
    // Delete is enabled if the selection is not empty
    pCmdUI->Enable( CCmdDeleteSelection::CanDo(GetDocument()) );
        
}


void CBoxNetView::OnEditDelete()  {

    GetDocument()->CmdDo(new CCmdDeleteSelection());

}

//
// OnUpdateSave
//
// Disable Save for BETA 1!
//
// void CBoxNetView::OnUpdateSave(CCmdUI* pCmdUI)
// {
//    pCmdUI->Enable(FALSE);         // Disable Save
// }


//
// --- Performance Logging ---
//
// I dynamically load measure.dll in the CBoxNetView constructor.
// if anyone uses it (staically or dynamically) they will get this
// copy of the dll. I provide access to the dump log procedure.

//
// OnUpdateSavePerfLog
//
// Enable dumping of the log when NOPERF is not defined
void CBoxNetView::OnUpdateSavePerfLog(CCmdUI* pCmdUI) {

    pCmdUI->Enable((m_hinstPerf != NULL));

}


//
// OnSavePerfLog
//
// Dump the performance log to the user specified file
void CBoxNetView::OnSavePerfLog() {

    CString strText;
    CString szDumpProc;
    szDumpProc.LoadString(IDS_DUMP_PROC);

    ASSERT(m_hinstPerf);

    MSR_DUMPPROC *DumpProc;
    DumpProc = (MSR_DUMPPROC *) GetProcAddress(m_hinstPerf, szDumpProc);
    if (DumpProc == NULL) {
        AfxMessageBox(IDS_NO_DUMP_PROC);
        return;
    }

    strText.LoadString( IDS_TEXT_FILES );

    CFileDialog SaveLogDialog(FALSE,
                              ".txt",
                              "PerfLog.txt",
                              0,
                              strText,
                              this);

    if( IDOK == SaveLogDialog.DoModal() ){
        HANDLE hFile = CreateFile(SaveLogDialog.GetPathName(),
                                  GENERIC_WRITE,
                                  0,
                                  NULL,
                                  CREATE_ALWAYS,
                                  0,
                                  NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            AfxMessageBox(IDS_BAD_PERF_LOG);
            return;
        }

        DumpProc(hFile);           // This writes the log out to the file

        CloseHandle(hFile);
    }
                
}


void CBoxNetView::OnFileSetLog( void ){
    CString strText;
    HANDLE hRenderLog;

    strText.LoadString( IDS_TEXT_FILES );

    CFileDialog SaveLogDialog(FALSE
                             ,".txt"
                             ,""
                                         ,0
                                         ,strText
                                         ,this
                             );

    if( IDOK == SaveLogDialog.DoModal() ){
        hRenderLog = CreateFile( SaveLogDialog.GetPathName()
                               , GENERIC_WRITE
                               , 0    // no sharing
                               , NULL // no security
                               , OPEN_ALWAYS
                               , 0    // no attributes, no flags
                               , NULL // no template
                               );

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            // Seek to end of file
            SetFilePointer(hRenderLog, 0, NULL, FILE_END);
            GetDocument()->IGraph()->SetLogFile((DWORD_PTR) hRenderLog);
        }
    }
}

//
// OnUpdateNewPerfLog
//
// Grey the item if measure.dll was not found
void CBoxNetView::OnUpdateNewPerfLog(CCmdUI* pCmdUI) {

    pCmdUI->Enable((m_hinstPerf != NULL));
        
}


//
// OnNewPerfLog
//
// Reset the contents of the one and only performance log.
void CBoxNetView::OnNewPerfLog() {

    CString szControlProc;
    szControlProc.LoadString(IDS_CONTROL_PROC);

    ASSERT(m_hinstPerf);

    MSR_CONTROLPROC *ControlProc;
    ControlProc = (MSR_CONTROLPROC *) GetProcAddress(m_hinstPerf, szControlProc);
    if (ControlProc == NULL) {
        AfxMessageBox(IDS_NO_CONTROL_PROC);
        return;
    }

    ControlProc(MSR_RESET_ALL);
}

// *** Drag and drop functions ***

//
// OnCreate
//
// Register this window as a drop target
int CBoxNetView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;

    // We can handle CFSTR_VFW_FILTERLIST, the base class provides for
    // file drag and drop.
    m_cfClipFormat = (CLIPFORMAT) RegisterClipboardFormat( CFSTR_VFW_FILTERLIST );
    m_DropTarget.Register( this );
        
    return 0;
}


DROPEFFECT CBoxNetView::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
    //
    // If the filter graph is not stopped we don't want filters to be
    // dropped onto GraphEdt
    //
    if (!CCmdAddFilter::CanDo(GetDocument())) {
        return(m_DropEffect = DROPEFFECT_NONE);
    }

    // Can we handle this format?
    if( pDataObject->IsDataAvailable( m_cfClipFormat ) )
        return (m_DropEffect = DROPEFFECT_COPY);

    // No, see if the base class can
    m_DropEffect = DROPEFFECT_NONE;
    return CView::OnDragEnter(pDataObject, dwKeyState, point);
}

DROPEFFECT CBoxNetView::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
    // Can we handle this format?
    if( m_DropEffect == DROPEFFECT_COPY )
        return m_DropEffect;

    // No, see if the base class can
    return CView::OnDragEnter(pDataObject, dwKeyState, point);
}

//
// OnUser
//
// On event notifications from the filter graph a WM_USER message is
// being posted from a thread which waits for these notifications.
// We just pass the call on to the handler in the document.
//
// We need to return 1 to indicate that the message has been handled
//
afx_msg LRESULT CBoxNetView::OnUser(WPARAM wParam, LPARAM lParam)
{
    //
    // Call the handler on CBoxNetDoc
    //
    GetDocument()->OnWM_USER((NetDocUserMessage *) lParam);

    return(1);
}


void CBoxNetView::CheckSeekBar( )
{
    CBoxNetDoc      *pDoc = GetDocument();

    if (!pDoc)
    {
        return;
    }

    BOOL fLiveReader = pDoc->GetLiveSourceReader();
    BOOL bSeek = 0;

    CQCOMInt<IMediaSeeking> IMS( IID_IMediaSeeking, GetDocument()->IGraph() );
    if( !IMS )
    {
        return;
    }

    REFERENCE_TIME StartTime;
    REFERENCE_TIME StopTime;
    REFERENCE_TIME CurrentTime;
    REFERENCE_TIME Duration = 0;
    double NewPosition;

    if (fLiveReader)
    {
        HRESULT hr = IMS->GetAvailable(&StartTime, &StopTime);

        if (FAILED(hr))
        {
            return;
        }

        // Do not set Duration tp StopTime - StartTime.
        // IMediaSeeking::GetAvailable makes an assumption
        // that the seek time always starts at 0 and 
        // sets the StopTime to 
        // max(StopTime reported by filters, duration reported by filters)
        // instead of
        // max(StopTime reported by filters, StartTime+duration reported by filters)
        if(FAILED(IMS->GetDuration( &Duration )))
        {
            return;
        }
        bSeek = pDoc->m_nSeekOnRun == CBoxNetDoc::SEEK_ON_RUN;
        StopTime = StartTime + Duration;
    }
    if (!fLiveReader)
    {
        if(FAILED(IMS->GetDuration( &Duration )))
        {
            return;
        }
        StartTime = 0;
        StopTime = Duration;
    }
    if (Duration == 0)
    {
        CurrentTime = 0;
        IMS->GetCurrentPosition( &CurrentTime ); 
        NewPosition = 0;
    }
    else
    {
        double Pos;
        if(m_wndSeekBar.DidPositionChange( ))
        {
            Pos = m_wndSeekBar.GetPosition( );
            bSeek = 1;
        }
        else if ( bSeek )
        {
            Pos = 1.0; // go to live 
        }
        if (bSeek)
        {
            pDoc->m_nSeekOnRun = CBoxNetDoc::SEEKED; // One seek done

            REFERENCE_TIME NewTime = REFERENCE_TIME( Pos * double( Duration ) );
            NewTime += StartTime;
            IMS->SetPositions( &NewTime, AM_SEEKING_AbsolutePositioning, NULL, AM_SEEKING_NoPositioning );
            if( m_wndSeekBar.IsSeekingRandom( ) )
            {
                CQCOMInt<IMediaControl> IMC( IID_IMediaControl, GetDocument()->IGraph() );
                IMC->Run( );
            }
        }
        CurrentTime = 0;
        IMS->GetCurrentPosition( &CurrentTime );
        
        if (CurrentTime > StartTime)
        {
            NewPosition = double( CurrentTime - StartTime ) / double( Duration );
        }
        else
        {
            NewPosition = 0;
        }
    }

    m_wndSeekBar.SetPosition( NewPosition, StartTime, StopTime, CurrentTime );

}

void CBoxNetView::OnDestroy() 
{
	CScrollView::OnDestroy();
	
    // Fix Manbugs #33781
    //
    // This call used to live in the ~CBoxNetView destructor.
    // When running with debug MFC libraries, we would get an ASSERT failure
    // in CWnd::KillTimer.  Since the owning window had already been destroyed,
    // the inline ASSERT(::IsWindow(m_hWnd)) call failed.  
    //
    // Fix is to kill the timer during processing of WM_DESTROY, when 
    // the window handle is still valid.

    KillTimer( TIMER_SEEKBAR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\bnetvw.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
// bnetvw.h : declares CBoxNetView
//

/////////////////////////////////////////////////////////////////////////////
// CBoxNetView
//

// forward declaration
class CPropDlg;

class CBoxNetView : public CScrollView
{
    DECLARE_DYNCREATE(CBoxNetView)

public:
    // construction and destruction
    CBoxNetView();
    virtual ~CBoxNetView();

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    // View updatiing, & drawing

    virtual void           OnInitialUpdate(void);
    virtual void           OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void           OnDraw(CDC* pdc);  // overridden to draw this view


    // What, if anything, is under the point pt?
    virtual CBoxDraw::EHit HitTest(CPoint	pt,
                                   CBox		**ppbox,
                                   CBoxTabPos	*ptabpos,
                                   CBoxSocket	**ppsock,
                                   CBoxLink	**pplink,
                                   CPoint	*pptProject
                                   );

protected:
    // general protected functions
    CBoxNetDoc* CBoxNetView::GetDocument(void) { ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CBoxNetDoc)));
                                                 return (CBoxNetDoc*) m_pDocument;
                                               }
    void CancelModes();

protected:
    // printing support
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pdc, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pdc, CPrintInfo* pInfo);

public:
    // IDs for timers used by view
    enum
    {
        TIMER_MOVE_SEL_PENDING = 1,  // used during move-selection-pending mode
        TIMER_SEEKBAR = 2,
        TIMER_PENDING_RECONNECT = 3
    };

protected:

    // view modes that are cancelled when the mouse button is released
    BOOL        m_fMouseDrag;       // mouse is being dragged in window?
    BOOL        m_fMoveBoxSelPending; // waiting to enter move-sel mode?
    BOOL        m_fMoveBoxSel;      // currently moving selection of boxes?
    BOOL        m_fGhostSelection;  // there is currently a ghost selection?
    BOOL        m_fSelectRect;      // draw a rectangle round boxes to select?
    BOOL        m_fNewLink;         // create a new link?
    BOOL        m_fGhostArrow;      // there is currently a ghost arrow?
    CBoxSocket *m_psockHilite;      // currently-hilited socket tab (or NULL)

private:
    // context menus

    void	PreparePinMenu(CMenu *pmenuPopup);
    void        PrepareLinkMenu(CMenu *pmenuPopup);
    void	PrepareFilterMenu(CMenu *pmenuPopup, CBox *);

protected:
    // state/functions for mouse-drag mode (iff <m_fMouseDrag>)
    BOOL        m_fMouseShift;      // user shift-clicked?
    CPoint      m_ptMouseAnchor;    // where mouse drag began
    CPoint      m_ptMousePrev;      // where mouse was previously
    CBox *      m_pboxMouse;        // box clicked on at start of drag
    BOOL        m_fMouseBoxSel;     // clicked-on box was initally selected?
    void MouseDragBegin(UINT nFlags, CPoint pt, CBox *pboxMouse);
    void MouseDragContinue(CPoint pt);
    void MouseDragEnd();

protected:
    // state/functions for move-selection-pending mode
    // (iff <m_fMoveBoxSelPending>)
    CRect       m_rcMoveSelPending; // start move-selection when outside this
    void MoveBoxSelPendingBegin(CPoint pt);
    void MoveBoxSelPendingContinue(CPoint pt);
    void MoveBoxSelPendingEnd(BOOL fCancel);

protected:
    // state/functions for move-selection mode
    // (iff <m_fMoveBoxSel>)
    void MoveBoxSelBegin();
    void MoveBoxSelContinue(CSize sizOffset);
    void MoveBoxSelEnd(BOOL fCancel);
    void MoveBoxSelection(CSize sizOffset);
    CSize ConstrainMoveBoxSel(CSize sizOffset, BOOL fCalcSelBoundRect);

protected:
    // state/functions for ghost-selection mode
    // (iff <m_fGhostSelection>)
    CSize       m_sizGhostSelOffset; // ghost sel. offset from sel. this much
    CRect       m_rcSelBound;       // bounding rectangle around non-ghost sel.
    void GhostSelectionCreate();
    void GhostSelectionMove(CSize sizOffset);
    void GhostSelectionDestroy(void);
    void GhostSelectionDraw(CDC *pdc);

protected:
    // state/functions for select-rectangle mode
    // (iff <m_fSelectRect>)
    CPoint      m_ptSelectRectAnchor; // where select-rect drag began
    CPoint      m_ptSelectRectPrev; // previous mouse drag location
    void SelectRectBegin(CPoint pt);
    void SelectRectContinue(CPoint pt);
    void SelectRectEnd(BOOL fCancel);
    void SelectRectDraw(CDC *pdc);
    void SelectBoxesIntersectingRect(CRect *prc);

protected:
    // state/functions for new-link mode
    // (iff <m_fNewLink>)
    CBoxSocket *m_psockNewLinkAnchor; // clicked-on socket tab
    void NewLinkBegin(CPoint pt, CBoxSocket *psock);
    void NewLinkContinue(CPoint pt);
    void NewLinkEnd(BOOL fCancel);

protected:
    // state/functions for ghost-arrow mode
    // (iff <m_fGhostArrow>)
    CPoint      m_ptGhostArrowTail; // tail of ghost arrow
    CPoint      m_ptGhostArrowHead; // head of ghost arrow
    void GhostArrowBegin(CPoint pt);
    void GhostArrowContinue(CPoint pt);
    void GhostArrowEnd();
    void GhostArrowDraw(CDC *pdc);

protected:
    // state/functions for highlight-tab mode (iff <m_psockHilite> not NULL)
    void SetHiliteTab(CBoxSocket *psock);

protected:
    // performace logging module handle. NULL if not present
    HINSTANCE	m_hinstPerf;

protected:
    // Drag and drop attributes
    COleDropTarget      m_DropTarget;
    DROPEFFECT          m_DropEffect;
    CLIPFORMAT          m_cfClipFormat;

public:
    // Drag and drop functions
    virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
    virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);

protected:
    // message callback functions
    //{{AFX_MSG(CBoxNetView)
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg BOOL OnEraseBkgnd(CDC* pdc);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnCancelModes();
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
    afx_msg void OnEditDelete();
    afx_msg void OnUpdateSavePerfLog(CCmdUI* pCmdUI);
    afx_msg void OnSavePerfLog();
    afx_msg void OnUpdateNewPerfLog(CCmdUI* pCmdUI);
    afx_msg void OnNewPerfLog();
	afx_msg void OnFileSetLog();
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG

    afx_msg void OnProperties();
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnSelectClock();
    afx_msg LRESULT OnUser(WPARAM, LPARAM);

    DECLARE_MESSAGE_MAP()

    CBox * m_pSelectClockFilter;

public:

    HWND m_hWndSlider;
    CSeekDialog m_wndSeekBar;
    void CheckSeekBar( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\boxdraw.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// boxdraw.cpp : defines CBoxDraw
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// Global (shared) CBoxDraw object

CBoxDraw * gpboxdraw;


/////////////////////////////////////////////////////////////////////////////
// CBoxDraw constants


// background color of boxes and container
const COLORREF  CBoxDraw::m_crBkgnd(RGB(192, 192, 192));

// margins (left/right, top/bottom) around box labels and box tab labels
const CSize     CBoxDraw::m_sizLabelMargins(2, 0);

// hit test: "close enough" if this many pixels away
const int       CBoxDraw::m_iHotZone(3);

// box tab labels: font face, height (pixels) for box labels and box tab labels
const CString   CBoxDraw::m_stBoxFontFace("Arial");
const int       CBoxDraw::m_iBoxLabelHeight(16);
const int       CBoxDraw::m_iBoxTabLabelHeight(14);

// color of unhighlighted links and highlighted links
const COLORREF  CBoxDraw::m_crLinkNoHilite(RGB(0, 0, 0));
const COLORREF  CBoxDraw::m_crLinkHilite(RGB(0, 0, 255));

// radius of circle used to highlight bends
const int       CBoxDraw::m_iHiliteBendsRadius(3);



/////////////////////////////////////////////////////////////////////////////
// CBoxDraw construction and destruction


CBoxDraw::CBoxDraw() {
}


/* Init()
 *
 * Initialize the object.  May throw an exception, so don't call from
 * a constructor.
 */
void CBoxDraw::Init()
{
    // load composite bitmaps
    if (!m_abmEdges[FALSE].LoadBitmap(IDB_EDGES) ||
        !m_abmEdges[TRUE].LoadBitmap(IDB_EDGES_HILITE) ||
        !m_abmTabs[FALSE].LoadBitmap(IDB_TABS) ||
        !m_abmTabs[TRUE].LoadBitmap(IDB_TABS_HILITE) ||
        !m_abmClocks[FALSE].LoadBitmap(IDB_CLOCK) ||
        !m_abmClocks[TRUE].LoadBitmap(IDB_CLOCK_SELECT))
            AfxThrowResourceException();

    // get the size of each bitmap (just look at the unhighlighted versions
    // since unhighlighted and highlighted versions are the same size)
    // and compute the size of a single "tile" within the composite bitmap
    BITMAP bm;
    m_abmEdges[FALSE].GetObject(sizeof(bm), &bm);
    m_sizEdgesTile.cx = bm.bmWidth / 3;
    m_sizEdgesTile.cy = bm.bmHeight / 3;
    m_abmTabs[FALSE].GetObject(sizeof(bm), &bm);
    m_sizTabsTile.cx = bm.bmWidth / 3;
    m_sizTabsTile.cy = bm.bmHeight / 3;
    m_abmClocks[FALSE].GetObject(sizeof(bm), &bm);
    m_sizClock.cx = bm.bmWidth;
    m_sizClock.cy = bm.bmHeight;

    // create the brushes and pens for drawing links
    m_abrLink[FALSE].CreateSolidBrush(m_crLinkNoHilite);
    m_abrLink[TRUE].CreateSolidBrush(m_crLinkHilite);
    m_apenLink[FALSE].CreatePen(PS_SOLID, 1, m_crLinkNoHilite);
    m_apenLink[TRUE].CreatePen(PS_SOLID, 1, m_crLinkHilite);

    RecreateFonts();
}

void CBoxDraw::RecreateFonts()
{
    // create the font for box labels
    if (!m_fontBoxLabel.CreateFont(m_iBoxLabelHeight * CBox::s_Zoom / 100, 0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS,
            CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FF_SWISS, m_stBoxFontFace))
        AfxThrowResourceException();

    // create the font for tab labels
    if (!m_fontTabLabel.CreateFont(m_iBoxTabLabelHeight * CBox::s_Zoom / 100, 0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS,
            CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FF_SWISS, m_stBoxFontFace))
        AfxThrowResourceException();
}

/* Exit()
 *
 * Free the resources held by the object.
 */
void CBoxDraw::Exit() {

}



/////////////////////////////////////////////////////////////////////////////
// box drawing


/* GetOrInvalBoundRect(pbox, prc, [fLinks], [pwnd])
 *
 * Set <*prc> to be a bounding rectangle around <pbox>.  If <fLinks> is TRUE
 * then include the bounding rectangles of the links to/from <pbox>.
 *
 * If <pwnd> is not NULL, then invalidate the area covering <pbox> (and the
 * links to/from <pbox>, if <fLinks> is TRUE).  This is usually more efficient
 * than invalidating all of <pwnd>, for links that have at least one bend.
 */
void CBoxDraw::GetOrInvalBoundRect(CBox *pbox, CRect *prc, BOOL fLinks,
    CScrollView *pScroll)
{
    CRect               rc;

    // get the bounding rect of <pbox>; invalidate if requested
    *prc = pbox->GetRect();
    if (pScroll != NULL)
        pScroll->InvalidateRect(&(*prc - pScroll->GetScrollPosition()), TRUE);

    if (fLinks)
    {
        // include the bounding rect of each link; invalidate if requested
	CSocketEnum Next(pbox);
	CBoxSocket *psock;

	while (0 != (psock = Next()))
	{
            if (psock->m_plink != NULL)
            {
                // socket is connected via a link
                GetOrInvalLinkRect(psock->m_plink, &rc, pScroll);
                prc->UnionRect(prc, &rc);
            }
        }
    }
}


/* DrawCompositeFrame(hdcDst, xDst, yDst, cxDst, cyDst,
 *  hdcSrc, cxTile, cyTile, fMiddle)
 *
 * Draw a <cxDst> by <cyDst> pixel "frame" (as specified below) at (xDst,yDst)
 * in <hdcDst>.
 *
 * Assume <hdcSrc> is a DC onto a bitmap that contains a 3x3 grid of "tiles"
 * that each is <cxTile> pixels wide and <cyTile> pixels high.  The corner
 * tiles contain images of the corners.  The center top, bottom, left, and
 * right tiles contain images that are stretched to compose the corresponding
 * sides of the frame.
 *
 * If <fMiddle> is TRUE then the middle tile is stretched to fill the middle
 * of the frame, otherwise the middle of the frame is left undrawn.
 */
void NEAR PASCAL
DrawCompositeFrame(HDC hdcDst, int xDst, int yDst, int cxDst, int cyDst,
    HDC hdcSrc, int cxTile, int cyTile, BOOL fMiddle)
{
    // draw upper-left, upper-right, lower-left, lower-right corners
    BitBlt(hdcDst, xDst + 0, yDst + 0,
        cxTile, cyTile,
        hdcSrc, cxTile * 0, cyTile * 0, SRCCOPY);
    BitBlt(hdcDst, xDst + cxDst - cxTile, yDst + 0,
        cxTile, cyTile,
        hdcSrc, cxTile * 2, cyTile * 0, SRCCOPY);
    BitBlt(hdcDst, xDst + 0, yDst + cyDst - cyTile,
        cxTile, cyTile,
        hdcSrc, cxTile * 0, cyTile * 2, SRCCOPY);
    BitBlt(hdcDst, xDst + cxDst - cxTile, yDst + cyDst - cyTile,
        cxTile, cyTile,
        hdcSrc, cxTile * 2, cyTile * 2, SRCCOPY);

    // draw left, right, top, and bottom edges
    SetStretchBltMode(hdcDst, COLORONCOLOR);
    StretchBlt(hdcDst, xDst + 0, yDst + cyTile * 1,
        cxTile, cyDst - cyTile - cyTile,
        hdcSrc, cxTile * 0, cyTile * 1,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxDst - cxTile, yDst + cyTile * 1,
        cxTile, cyDst - cyTile - cyTile,
        hdcSrc, cxTile * 2, cyTile * 1,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxTile * 1, yDst + 0,
        cxDst - cxTile - cxTile, cyTile,
        hdcSrc, cxTile * 1, cyTile * 0,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxTile * 1, yDst + cyDst - cyTile,
        cxDst - cxTile - cxTile, cyTile,
        hdcSrc, cxTile * 1, cyTile * 2,
        cxTile, cyTile, SRCCOPY);

    if (fMiddle)
    {
        // draw middle tile
        StretchBlt(hdcDst, xDst + cxTile * 1, yDst + cyTile * 1,
            cxDst - cxTile - cxTile,
            cyDst - cyTile - cyTile,
            hdcSrc, cxTile * 1, cyTile * 1,
            cxTile, cyTile, SRCCOPY);
    }
}


/* DrawFrame(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the frame of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the frame.  In this case, <pdc> must be a
 * DC onto the window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> is ignored.
 */
void CBoxDraw::DrawFrame(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CDC         dcBitmap;

    GetFrameRect(pbox, prc);

    if (fDraw)
    {
        dcBitmap.CreateCompatibleDC(NULL);
        dcBitmap.SelectObject(&m_abmEdges[fnorm(pbox->IsSelected())]);
        DrawCompositeFrame(pdc->m_hDC, prc->left, prc->top,
            prc->Width(), prc->Height(),
            dcBitmap.m_hDC, m_sizEdgesTile.cx, m_sizEdgesTile.cy, FALSE);
    }
}


/* DrawBoxLabel(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box label of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the box label -- note that this will also
 * cause the *entire* box to be filled with the background color, not just the
 * bounding rectangle of the box.  In this case, <pdc> must be a DC onto the
 * window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 *
 * Also deals with the clock icon.
 */
void CBoxDraw::DrawBoxLabel(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontBoxLabel);

    // set <*prc> to be the bounding rectangle of the box label
    GetInsideRect(pbox, &rcBox);

    // calculate how much space we need for label and clock icon
    CSize szLabel = pdc->GetTextExtent(pbox->m_stLabel, pbox->m_stLabel.GetLength());

    INT iDiff = 0;

    if (pbox->HasClock()) {
        // increase label size by clock width + small gap
        szLabel.cx += m_sizClock.cx + 5;

        // make sure label height is at least clock height high
        if (m_sizClock.cy > szLabel.cy) {
            iDiff = m_sizClock.cy - szLabel.cy;
            szLabel.cy = m_sizClock.cy;
        }
    }

    *prc = CRect(rcBox.TopLeft(), szLabel);
    CSize siz = rcBox.Size() - prc->Size();
    prc->OffsetRect(siz.cx / 2, siz.cy / 2);

    if (fDraw)
    {
        // draw the box label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, rcBox,
            pbox->m_stLabel, pbox->m_stLabel.GetLength(), NULL);

        if (pbox->HasClock()) {
            // draw clock behind filter name
            CDC dcBitmap;
            dcBitmap.CreateCompatibleDC(NULL);

            // select the appropriate bitmap
            if (pbox->HasSelectedClock())
                dcBitmap.SelectObject(&m_abmClocks[1]);
            else
                dcBitmap.SelectObject(&m_abmClocks[0]);

            pdc->BitBlt(prc->left + szLabel.cx - m_sizClock.cx,
                        prc->top + iDiff / 2,
                        m_sizClock.cx, m_sizClock.cy,
                        &dcBitmap, 0, 0, SRCCOPY);
        }
    }
}

/* DrawBoxFile(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box label of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the box label -- note that this will also
 * cause the *entire* box to be filled with the background color, not just the
 * bounding rectangle of the box.  In this case, <pdc> must be a DC onto the
 * window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 */
/*void CBoxDraw::DrawBoxFile(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontBoxLabel);

    // set <*prc> to be the bounding rectangle of the box label
    GetInsideRect(pbox, &rcBox);

    *prc = CRect(rcBox.TopLeft(), pdc->GetTextExtent(pbox->m_stFilename, pbox->m_stFilename.GetLength()));
    CSize siz = rcBox.Size() - prc->Size();
    prc->OffsetRect(siz.cx / 2, siz.cy * 3 / 4);

    if (fDraw)
    {
        // draw the box label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, rcBox,
            pbox->m_stFilename, pbox->m_stFilename.GetLength(), NULL);
    }
}
*/

/* DrawTabLabel(pbox, psock, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box tab label of
 * socket <psock> of box <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the tab label.  In this case, <pdc> must
 * be a DC onto the window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 */
void CBoxDraw::DrawTabLabel(CBox *pbox, CBoxSocket *psock, CRect *prc, CDC *pdc,
    BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    CPoint      pt;             // point on edge of <pbox> corresp. to <psock>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontTabLabel);

    // set <*prc> to be the bounding rectangle of the tab label
    GetInsideRect(pbox, &rcBox);
    pt = BoxTabPosToPoint(pbox, psock->m_tabpos);
    *prc = CRect(pt,
        pdc->GetTextExtent(psock->m_stLabel, psock->m_stLabel.GetLength()));
    if (psock->m_tabpos.m_fLeftRight)
    {
        // center label vertically beside <pt>, set flush to box left or right
        // (adjusting for margins)
        prc->OffsetRect((psock->m_tabpos.m_fLeftTop ? m_sizLabelMargins.cx
                        : -(prc->Width() + m_sizLabelMargins.cx)),
            -prc->Height() / 2);
    }
    else
    {
        // center label horizontally beside <pt>, set flush to box top or bottom
        // (adjusting for margins)
        prc->OffsetRect(-prc->Width() / 2,
            (psock->m_tabpos.m_fLeftTop ? m_sizLabelMargins.cy
             : -(prc->Height() + m_sizLabelMargins.cy)));
    }

    if (fDraw)
    {
        // draw the tab label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, prc,
            psock->m_stLabel, psock->m_stLabel.GetLength(), NULL);
    }
}


/* DrawTab(psock, prc, pdc, fDraw, fHilite)
 *
 * Set <*prc> to be the bounding rectangle around the box tab <psock>.
 *
 * Then, if <fDraw> is TRUE, draw the tab.  In this case, <pdc> must
 * be a DC onto the window containing the box network.
 *
 * If <fHilite> is TRUE, then the tab is drawn in a hilited state.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> is unused.
 */
void CBoxDraw::DrawTab(CBoxSocket *psock, CRect *prc, CDC *pdc,
    BOOL fDraw, BOOL fHilite)
{
    CRect       rcBox;          // inside rectangle of <psock->m_pbox>
    CPoint      pt;             // point on edge of box corresp. to <psock>

    // set <*prc> to be the bounding rectangle of the tab
    GetInsideRect(psock->m_pbox, &rcBox);
    pt = BoxTabPosToPoint(psock->m_pbox, psock->m_tabpos);
    *prc = CRect(pt, m_sizTabsTile);
    if (psock->m_tabpos.m_fLeftRight)
    {
        // center tab vertically beside <pt>, set flush to box left or right
        prc->OffsetRect((psock->m_tabpos.m_fLeftTop ? -m_sizTabsTile.cx : 0),
            -prc->Height() / 2);
    }
    else
    {
        // center tab horizontally beside <pt>, set flush to box top or bottom
        prc->OffsetRect(-prc->Width() / 2,
            (psock->m_tabpos.m_fLeftTop ? -m_sizTabsTile.cy : 0));
    }

    if (fDraw)
    {
        // set <rcTile> to the rectangle in the bitmap containing the tile;
        // note that, in the 3x3 tiled bitmap, only 4 of the 9 tiles are used:
        //
        //      unused  top     unused
        //      left    unused  right
        //      unused  bottom  unused
        //
        CRect rcTile(CPoint(0, 0), m_sizTabsTile);
        if (psock->m_tabpos.m_fLeftRight)
        {
            // tile is on left or right side of bitmap
            rcTile.OffsetRect(0, m_sizTabsTile.cy);
            if (!psock->m_tabpos.m_fLeftTop)
                rcTile.OffsetRect(2 * m_sizTabsTile.cx, 0);
        }
        else
        {
            // tile is on top or bottom of bitmap
            rcTile.OffsetRect(m_sizTabsTile.cx, 0);
            if (!psock->m_tabpos.m_fLeftTop)
                rcTile.OffsetRect(0, 2 * m_sizTabsTile.cy);
        }

        // draw the tab
        CDC dcBitmap;
        dcBitmap.CreateCompatibleDC(NULL);
        dcBitmap.SelectObject(&m_abmTabs[fnorm(fHilite)]);
        pdc->BitBlt(prc->left, prc->top, prc->Width(), prc->Height(),
            &dcBitmap, rcTile.left, rcTile.top, SRCCOPY);
    }
}


/* pt = GetTabCenter(psock)
 *
 * Return the coordinates of the center of the box tab <psock>.
 */
CPoint CBoxDraw::GetTabCenter(CBoxSocket *psock)
{
    CRect           rc;         // bounding rectangle of tab

    DrawTab(psock, &rc, NULL, FALSE, FALSE);
    return CPoint((rc.left + rc.right) / 2, (rc.top + rc.bottom) / 2);
}


/* tabpos = BoxTabPosFromPoint(pbox, pt, piError)
 *
 * Figure out which edge of <pbox> <pt> is closest to, and return the
 * CBoxTabPos position that represents the point on that edge closest
 * to <pt>, and set <*piError> to the distance between that point and <pt>.
 */
CBoxTabPos CBoxDraw::BoxTabPosFromPoint(CBox *pbox, CPoint pt, LPINT piError)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    int         dxLeft, dxRight, dyTop, dyBottom;
    CBoxTabPos  tabpos;

    // CTabPos::GetPos() values are relative to the height or width
    // of the inside of the box
    GetInsideRect(pbox, &rcBox);

    // calculate the distance to each edge
    dxLeft = iabs(pt.x - rcBox.left);
    dxRight = iabs(pt.x - rcBox.right);
    dyTop = iabs(pt.y - rcBox.top);
    dyBottom = iabs(pt.y - rcBox.bottom);

    // figure out which edge <pt> is closest to
    if (imin(dxLeft, dxRight) < imin(dyTop, dyBottom))
    {
        tabpos.m_fLeftRight = TRUE;
        // <pt> is closest to the left or right edge
        tabpos.SetPos(ibound(pt.y, rcBox.top, rcBox.bottom) - rcBox.top,
            rcBox.Height());
        if (dxLeft < dxRight)
        {
            tabpos.m_fLeftTop = TRUE;
            *piError = dxLeft;
        }
        else
        {
            tabpos.m_fLeftTop = FALSE;
            *piError = dxRight;
        }
        *piError = max(*piError, ioutbound(pt.y, rcBox.top, rcBox.bottom));
    }
    else
    {
        tabpos.m_fLeftRight = FALSE;
        // <pt> is closest to the top or bottom edge
        tabpos.SetPos(ibound(pt.x, rcBox.left, rcBox.right) - rcBox.left,
            rcBox.Width());
        if (dyTop < dyBottom)
        {
            tabpos.m_fLeftTop = TRUE;
            *piError = dyTop;
        }
        else
        {
            tabpos.m_fLeftTop = FALSE;
            *piError = dyBottom;
        }
        *piError = max(*piError, ioutbound(pt.x, rcBox.left, rcBox.right));
    }

    return tabpos;
}


/* pt = BoxTabPosToPoint(pbox, tabpos)
 *
 * Convert <tabpos>, a box tab position on <pbox>, to a point that's
 * on one of the inside edges of <pbox>, and return the point.
 */
CPoint CBoxDraw::BoxTabPosToPoint(const CBox *pbox, CBoxTabPos tabpos)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    CPoint      pt;

    // CTabPos::GetPos() values are relative to the height or width
    // of the inside of the box
    GetInsideRect(pbox, &rcBox);

    pt = rcBox.TopLeft();
    if (tabpos.m_fLeftRight)
    {
        // tab is on left or right edge
        pt.y += tabpos.GetPos(rcBox.Height());
        if (!tabpos.m_fLeftTop)
            pt.x = rcBox.right;
    }
    else
    {
        // tab is on top or bottom edge
        pt.x += tabpos.GetPos(rcBox.Width());
        if (!tabpos.m_fLeftTop)
            pt.y = rcBox.bottom;
    }

    return pt;
}


/* DrawBox(pbox, pdc, [psockHilite], [psizGhostOffset])
 *
 * Draw the box <pbox> in <pdc> (a DC onto the window containing the box
 * network), and then exclude the portion that was painted from the
 * clipping region of <pdc>.
 *
 * If <psockHilite> is not NULL, then highlight socket tab <psockHilite>
 * if <pbox> contains it.
 *
 * If <psizGhostOffset> not NULL then, instead of drawing the box, draw a
 * "ghost" version of the box, offset by <*psizGhostOffset>, by inverting
 * destination pixels; calling DrawBox() again with the same value of
 * <psizGhostOffset> will invert the same pixels again and return <pdc>
 * to its original state.
 */
void CBoxDraw::DrawBox(CBox *pbox, CDC *pdc, CBoxSocket *psockHilite,
    CSize *psizGhostOffset)
{
    CRect       rc;

    /* if <psizGhostOffset> specified, just invert the pixels between the
     * frame and the inside of the box (all offset by <psizGhostOffset>)
     */
    if (psizGhostOffset)
    {
        CRect rcFrame, rcInside;
        GetFrameRect(pbox, &rcFrame);
        rcFrame.OffsetRect(*psizGhostOffset);
        GetInsideRect(pbox, &rcInside);
        rcInside.OffsetRect(*psizGhostOffset);
        InvertFrame(pdc, &rcFrame, &rcInside);
        return;
    }

    CSocketEnum Next(pbox);
    CBoxSocket *psock;
    // draw each socket's tab and tab label
    while (0 != (psock = Next()))
    {
        DrawTab(psock, &rc, pdc, TRUE, (psock == psockHilite));
        pdc->ExcludeClipRect(&rc);
        DrawTabLabel(pbox, psock, &rc, pdc, TRUE);
	// TBD: don't invalidate the clip rect here if printing
	// (or printer drops box label later)
	if (!pdc->IsPrinting())
	    pdc->ExcludeClipRect(&rc);
    }

    // draw the box filename
//    DrawBoxFile(pbox, &rc, pdc, TRUE);
//    pdc->ExcludeClipRect(&rc);

    // draw the box label
    DrawBoxLabel(pbox, &rc, pdc, TRUE);
    pdc->ExcludeClipRect(&rc);

    // draw the box frame
    DrawFrame(pbox, &rc, pdc, TRUE);
    pdc->ExcludeClipRect(&rc);
}


/* eHit = HitTestBox(pbox, pt, ptabpos, ppsock)
 *
 * See if <pt> hits some part of <pbox>.  Return the following hit-test code:
 *
 *   HT_MISS        didn't hit anything
 *   HT_TAB         hit a box tab (set <*ppsock> to it)
 *   HT_EDGE        hit the edge of the box (set <*ptabpos> to it)
 *   HT_TABLABEL    hit a box tab label (set <*ppsock> to it)
 *   HT_BOXLABEL    hit the box label
 *   HT_BOXFILE     hit the box filename
 *   HT_BOX         hit elsewhere on the box
 */
CBoxDraw::EHit CBoxDraw::HitTestBox(CBox *pbox, CPoint pt,
    CBoxTabPos *ptabpos, CBoxSocket **ppsock)
{
    CClientDC       dc(CWnd::GetDesktopWindow()); // to get label sizes etc.
    int             iError;
    CRect           rc;

    // for efficiency, before continuing further, first check if <pt> is even
    // in the bounding rectangle of the box
    if (!pbox->GetRect().PtInRect(pt))
        return HT_MISS;

    // see if <pt> is in a tab or tab label
    CSocketEnum Next(pbox);
    while (0 != (*ppsock = Next())) {

        DrawTab(*ppsock, &rc, &dc, FALSE, FALSE);
	rc.InflateRect(1,1);	// give users more chance of hitting tabs.
        if (rc.PtInRect(pt))
            return HT_TAB;
        DrawTabLabel(pbox, *ppsock, &rc, &dc, FALSE);
        if (rc.PtInRect(pt))
            return HT_TABLABEL;
    }

    // see if <pt> is in the box label
    DrawBoxLabel(pbox, &rc, &dc, FALSE);
    if (rc.PtInRect(pt))
        return HT_BOXLABEL;

    // see if <pt> is in the box label
//    DrawBoxFile(pbox, &rc, &dc, FALSE);
//    if (rc.PtInRect(pt))
//        return HT_BOXFILE;

    // see if <pt> is near the edge of the box
    *ptabpos = BoxTabPosFromPoint(pbox, pt, &iError);
    if (iError <= 3/*close-enough-zone*/)
        return HT_EDGE;

    // see if <pt> is anywhere else in the box
    DrawFrame(pbox, &rc, &dc, FALSE);
    if (rc.PtInRect(pt))
        return HT_BOX;

    return HT_MISS;
}


/////////////////////////////////////////////////////////////////////////////
// Link drawing and hit testing


/* An arrow is drawn as a pie (a slice of a circle) of radius ARROW_RADIUS.
 * The angle of the arrow pie slice is twice the slope "rise/run", where
 * "rise" is ARROW_SLOPERISE and "run" is ARROW_SLOPERUN.
 */


#define ARROW_RADIUS        12  // radius of pie for 1-wide line arrow
#define ARROW_SLOPERISE     3   // "rise" of arrow angle
#define ARROW_SLOPERUN      8   // "run" of arrow angle


/* DrawArrowHead(hdc, ptTip, ptTail, fPixel)
 *
 * Imagine a line drawn from <ptTip> to <ptTail>, with an arrowhead with its
 * tip at <ptTip>.  Draw this arrowhead.
 *
 * If <fPixel> is TRUE, then the arrowhead points to the pixel at <ptTip>
 * i.e. the rectangle (ptTip.x,ptTip.y, ptTip.x+1,ptTip.y+1); a one-pixel-wide
 * horizontal or vertical line drawn to <ptTip> should line up with this
 * rectangle, and the arrowhead should not obscure this rectangle.
 *
 * If <fPixel> is FALSE, then the arrowhead points to the gridline intersection
 * at <ptTip>, not the pixel at <ptTip>.  (One implication of this is that the
 * pixel at <ptTip>, will be obscured by the arrowhead when the tail of the
 * arrow is to the right and below the tip.)
 *
 * In order for DrawArrowHead() to function correctly, the current pen
 * must be non-null and one unit thick.
 */
void NEAR PASCAL
DrawArrowHead(HDC hdc, POINT ptTip, POINT ptTail, BOOL fPixel)
{
    int     dxLine, dyLine;     // delta from tip to end of line
    POINT   ptBoundA, ptBoundB; // ends of boundary lines
    int     dxBound, dyBound;

    // adjust for the way Windows draws pies
    if (ptTail.x >= ptTip.x)
        ptTip.x++;
    if (ptTail.y >= ptTip.y)
        ptTip.y++;
    if (fPixel)
    {
        if (ptTail.x > ptTip.x)
            ptTip.x++;
        if (ptTail.y > ptTip.y)
            ptTip.y++;
    }

    // calculate the extent of the line
    dxLine = ptTip.x - ptTail.x;
    dyLine = ptTip.y - ptTail.y;

    if ((iabs(dxLine) < ARROW_RADIUS) && (iabs(dyLine) < ARROW_RADIUS))
        return;         // line too short to draw arrow

    // calculate <ptBoundA> and <ptBoundB>; if you draw a line from
    // <ptTip> to <ptBoundA>, that line will touch one side of the
    // arrow; if you draw a line from <ptTip> to <ptBoundB>, that line
    // will touch the other side of the arrow; the first line will
    // always come before the second line if you orbit <ptTip>
    // counterclockwise (like Pie() does)
    dxBound = ((2 * dyLine * ARROW_SLOPERISE + ARROW_SLOPERUN)
        / ARROW_SLOPERUN) / 2;
    dyBound = ((2 * dxLine * ARROW_SLOPERISE + ARROW_SLOPERUN)
        / ARROW_SLOPERUN) / 2;
    ptBoundA.x = ptTail.x + dxBound;
    ptBoundA.y = ptTail.y - dyBound;
    ptBoundB.x = ptTail.x - dxBound;
    ptBoundB.y = ptTail.y + dyBound;

    // draw the arrowhead
    Pie(hdc, ptTip.x - ARROW_RADIUS, ptTip.y - ARROW_RADIUS,
             ptTip.x + ARROW_RADIUS, ptTip.y + ARROW_RADIUS,
         ptBoundA.x, ptBoundA.y, ptBoundB.x, ptBoundB.y);
}


/* GetOrInvalLinkRect(plink, prc, [pwnd])
 *
 * Set <*prc> to be a bounding rectangle around <plink>.  If <pwnd> is not
 * NULL, then invalidate the area covering at least <plink> in <pwnd>.
 * (This is usually more efficient than invalidating all of <pwnd>,
 * for links that have at least one bend.)
 */
void CBoxDraw::GetOrInvalLinkRect(CBoxLink *plink, CRect *prc, CScrollView *pScroll)
{
    CPoint          ptPrev, ptCur;  // endpoints of current line segment
    int             iSeg = 0;       // current line segment (0, 1, 2, ...)
    CRect           rc;
    const int       iLineWidth = 1;

    // enumerate the line segments of the link, starting at the arrowtail
    ptPrev = GetTabCenter(plink->m_psockTail);
    ptCur = GetTabCenter(plink->m_psockHead);

    // set <rc> to be the rectangle with corners at <ptPrev> and <ptCur>
    rc.TopLeft() = ptPrev;
    rc.BottomRight() = ptCur;
    NormalizeRect(&rc);

    // inflate <rc> to account for arrowheads, line width, and hilited bends
    const int iInflate = max(ARROW_SLOPERISE, m_iHiliteBendsRadius) + 1;
    rc.InflateRect(iInflate, iInflate);

    // enlarge <prc> as necessary to include <rc>
    if (iSeg++ == 0)
        *prc = rc;
    else
        prc->UnionRect(prc, &rc);

    // invalidate <rc> if requested
    if (pScroll != NULL)
        pScroll->InvalidateRect(&(rc - pScroll->GetScrollPosition()), TRUE);

    ptPrev = ptCur;
}


/* SelectLinkBrushAndPen(pdc, fHilite)
 *
 * Select the brush and pen used to draw links into <pdc>.  If <fHilite>,
 * select the brush and pen used to draw highlighted links.
 */
void CBoxDraw::SelectLinkBrushAndPen(CDC *pdc, BOOL fHilite)
{
    pdc->SelectObject(&m_abrLink[fnorm(fHilite)]);
    pdc->SelectObject(&m_apenLink[fnorm(fHilite)]);
}


/* DrawArrow(pdc, ptTail, ptHead, [fGhost], [fArrowhead], [fHilite])
 *
 * Draw an arrow from <ptTail> to <ptHead>.  If <fGhost> is FALSE, draw in
 * the normal color for links (if <fHilite> is FALSE) or the highlight color
 * for links (if <fHilite> is TRUE).  Otherwise, draw by inverting destination
 * pixels so that calling DrawGhostArrow() again with the same parameters will
 * return <pdc> to its original state.
 *
 * If <fArrowhead>, draw the arrowhead.  Otherwise, just draw a line with
 * no arrowhead.
 */
void CBoxDraw::DrawArrow(CDC *pdc, CPoint ptTail, CPoint ptHead, BOOL fGhost,
    BOOL fArrowhead, BOOL fHilite)
{
    // draw in "xor" mode if <fGhost>, black otherwise
    int iPrevROP = pdc->SetROP2(fGhost ? R2_NOT : R2_COPYPEN);

    // select brush and pen
    SelectLinkBrushAndPen(pdc, fHilite);

    // draw line
    pdc->MoveTo(ptTail);
    pdc->LineTo(ptHead);

    // draw arrowhead (if requested)
    if (fArrowhead)
        DrawArrowHead(pdc->m_hDC, ptHead, ptTail, FALSE);

    // revert to previous raster operation
    pdc->SetROP2(iPrevROP);
}


/* DrawLink(plink, pdc, [fHilite], [psizGhostOffset])
 *
 * Draw the link <plink> in <pdc> (a DC onto the window containing the box
 * network), using the normal color for links (if <fHilite> is FALSE) or
 * the using the highlight color for links (if <fHilite> is TRUE). and also draw
 * the head and tail the same way.
 *
 * If <psizGhostOffset> not NULL then, instead of drawing the link, draw a
 * "ghost" version of the link, offset by <*psizGhostOffset>, by inverting
 * destination pixels; calling DrawLink() again with the same value of
 * <psizGhostOffset> will invert the same pixels again and return <pdc>
 * to its original state.  Special case: if <psizeGhostOffset> is not NULL,
 * then for each end of the link (arrowtail and arrowhead), if that end
 * is connected to a box that is not selected, don't offset that end
 * (so that, during a box-move operation, links to boxes that aren't selected
 * are shown still connected to those boxes).
 */
void CBoxDraw::DrawLink(CBoxLink *plink, CDC *pdc, BOOL fHilite, CSize *psizGhostOffset)
{
    CSize           sizOffset;      // amount to offset vertices by
    CPoint          pt1, pt2;

    if (psizGhostOffset == NULL) {	// reflect true state, unless drawing ghost
        fHilite = plink->IsSelected();	//!!! override paramter!
    }

    // set <sizOffset> to the amount to offset link drawing by
    if (psizGhostOffset != NULL)
        sizOffset = *psizGhostOffset;
    else
        sizOffset = CSize(0, 0);

    // draw all line segments, except for the line segment containing the
    // arrowhead, starting from the tail end of the link
    CPoint pt = GetTabCenter(plink->m_psockTail);
    BOOL fMovingBothEnds = (plink->m_psockTail->m_pbox->IsSelected() &&
                            plink->m_psockHead->m_pbox->IsSelected());

    // draw the line segment that includes the arrowhead
    CPoint ptHead = GetTabCenter(plink->m_psockHead);
    pt1 = pt + (plink->m_psockTail->m_pbox->IsSelected()
                    ? sizOffset : CSize(0, 0));
    pt2 = ptHead + (plink->m_psockHead->m_pbox->IsSelected()
                    ? sizOffset : CSize(0, 0));

    DrawArrow(pdc, pt1, pt2, (psizGhostOffset != NULL), TRUE, fHilite);
}


/* iNew = RestrictRange(i, i1, i2)
 *
 * If <i> is between <i1> or <i2> (or equal to <i1> or <i2>), return <i>.
 * Otherwise, return whichever of <i1> or <i2> that <i> is closest to.
 */
int NEAR PASCAL
RestrictRange(int i, int i1, int i2)
{
    if (i1 < i2)
        return ibound(i, i1, i2);
    else
        return ibound(i, i2, i1);

    return i;
}


/* lSq = Square(l)
 *
 * Return the sqare of <l>.
 */
inline long Square(long l)
{
    return l * l;
}


/* iSqDist = SquareDistance(pt1, pt2)
 *
 * Return the square of the distance between <pt1> and <pt2>.
 */
inline long SquareDistance(POINT pt1, POINT pt2)
{
    return Square(pt1.x - pt2.x) + Square(pt1.y - pt2.y);
}


/* ptProject = ProjectPointToLineSeg(pt1, pt2, pt3)
 *
 * Return the point nearest to <pt3> that lies on the line segment between
 * <pt1> and <pt2>.  This is equivalent to projecting <pt3> onto line <pt1pt2>,
 * except that if the projected point lies on <pt1pt2> but not between <pt1>
 * and <pt2> then return whichever of <pt1> or <pt3> that the projected point
 * is nearest to.
 */
POINT NEAR PASCAL
ProjectPointToLineSeg(POINT pt1, POINT pt2, POINT pt3)
{
    POINT       ptProject;  // <pt3> projected on <pt1pt2>

    // calculate <l12s>, <l13s>, and <l23s> (the square of the distance
    // between <pt1> and <pt2>, <pt1> and <pt3>, and <pt2> and pt3>,
    // respectively), using the Pythagorean Theorem
    long l12s = SquareDistance(pt1, pt2);
    long l13s = SquareDistance(pt1, pt3);
    long l23s = SquareDistance(pt2, pt3);

    // Based on the Pythagorean Theorm, and using the fact that
    // triangles <pt1pt3> and <pt2pt3> have a right angle at vertex
    // <ptProject>, the distance <pt1ptProject> is:
    //
    //     (l12s + l13s - l23s) / (2 * square_root(l12s))
    //
    // This value is needed to compute <ptProject> below, but by doing
    // some substitution below it turns out we only need the numerator
    // <lNum> of this expression:
    long lNum = l12s + l13s - l23s;

    // special case: if line is zero-length, then return either end
    if (l12s == 0)
        return pt1;

    // calculate <ptProject.x> based on similar triangles pt1ptProjectptQ
    // and pt1pt2ptR, where points <ptQ> and <ptR> are projections of
    // points <ptProject> and <pt2>, respectively, onto the x axis;
    // calculate <ptProject.y> similarly
    ptProject.x = (int) (((pt2.x - pt1.x) * lNum) / (2 * l12s) + pt1.x);
    ptProject.y = (int) (((pt2.y - pt1.y) * lNum) / (2 * l12s) + pt1.y);

    // <ptProject> is on the line <pt1pt2>; now see if <ptProject> is
    // on the line segment <pt1pt2> (i.e. between <pt1> and <pt2>);
    // if not, return whichever of <pt1> or <pt2> <ptProject> is closest to
    ptProject.x = RestrictRange(ptProject.x, pt1.x, pt2.x);
    ptProject.y = RestrictRange(ptProject.y, pt1.y, pt2.y);

    return ptProject;
}


/* eHit = HitTestLink(plink, pt, pptProject, ppbend)
 *
 * See if <pt> hits some part of <plink>.  Return the following hit-test code:
 *
 *   HT_MISS        didn't hit anything
 *   HT_LINKLINE    hit test: hit a link line (set <*pplink> to it; set
 *                  <*ppbend> to the bend at the end of the line segment
 *                  toward the arrowhead, or to NULL if it's the line segment
 *                  with the arrowhead)
 *   HT_LINKBEND    hit test: hit a bend in the link (set <*ppbend> to it;
 *                  set <*pplink> to the link)
 *
 * If something other than HT_MISS is returned, <*pptProject> is set to
 * the point nearest to <pt> on a line segment of the link.
 */
CBoxDraw::EHit CBoxDraw::HitTestLink(CBoxLink *plink, CPoint pt, CPoint *pptProject)
{
    CPoint          ptPrev, ptCur;  // endpoints of current line segment
    CPoint          ptProject;      // <pt> projected onto a line segment

    // these variables keep track of the closest line segment to <pt>
    long            lSqDistSeg;
    long            lSqDistSegMin = 0x7fffffff;
    CPoint          ptProjectSeg;

    // these variables keep track of the closest bend point to <pt>
    CPoint          ptProjectBend;

    // enumerate the line segments of the link, starting at the arrowtail
    ptPrev = GetTabCenter(plink->m_psockTail);

    ptCur = GetTabCenter(plink->m_psockHead);
    // see how close <pt> is to line segment (ptPrev,ptCur)
    ptProject = ProjectPointToLineSeg(ptPrev, ptCur, pt);
    lSqDistSeg = SquareDistance(ptProject, pt);
    if (lSqDistSegMin > lSqDistSeg) {
        lSqDistSegMin = lSqDistSeg;
        ptProjectSeg = ptProject;
    }

    ptPrev = ptCur;

    // see if <pt> was close enough to the closest line segment
    if (lSqDistSegMin <= Square(m_iHotZone))
    {
        *pptProject = ptProjectSeg;
        return HT_LINKLINE;
    }

    return HT_MISS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\box.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// box.cpp : defines CBoxTabPos, CBoxSocket, CBox
//

#include "stdafx.h"
#include <streams.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

int CBox::s_Zoom = 100;

void CBox::SetZoom(int iZoom) {
    s_Zoom = iZoom;
    gpboxdraw->RecreateFonts();
}


// these lines copied from SDK\CLASSES\BASE\FILTER.H
#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();
#define QueryPinInfoReleaseFilter(pi) if ((pi).pFilter) (pi).pFilter->Release();

// *
// * CBoxSocket
// *

//
// 'Copy' Constructor
//
// Duplicate this socket, inc. addref of the IPin
// It only makes sense to copy a socket onto a new box, so
// we need a CBox * as well.
CBoxSocket::CBoxSocket(const CBoxSocket& sock, CBox *pbox)
    : m_pbox(pbox)
    , m_plink(NULL)                     // no links copied.
    , m_stLabel(sock.m_stLabel)
    , m_tabpos(sock.m_tabpos)
    , m_IPin(sock.m_IPin) {

   ASSERT(*m_pbox != *pbox);

   ASSERT_VALID(this);

}


//
// Constructor
//
CBoxSocket::CBoxSocket(CBox *pbox,
                       CString stLabel,
                       CBoxTabPos::EEdge eEdge,
                       unsigned uiVal,          // positon as fraction
                       unsigned uiValMax,       // along edge uiVal/uiValMax
                       IPin *pPin)
    : m_pbox(pbox),
      m_stLabel(stLabel),
      m_tabpos(eEdge, uiVal, uiValMax),
      m_plink(NULL),
      m_IPin(pPin) {

    ASSERT_VALID(this);

}


//
// Destructor
//
CBoxSocket::~CBoxSocket() {

    ASSERT_VALID(this);

}

#ifdef _DEBUG
//
// AssertValid
//
void CBoxSocket::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(m_pbox);

}
#endif // _DEBUG

//
// GetDirection
//
PIN_DIRECTION CBoxSocket::GetDirection(void) {

    HRESULT hr;

    PIN_DIRECTION pd;
    hr = pIPin()->QueryDirection(&pd);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }

    ASSERT( (pd == PINDIR_INPUT) || (pd == PINDIR_OUTPUT) );

    return pd;
}


//
// IsConnected
//
BOOL CBoxSocket::IsConnected(void) {

    HRESULT hr;
    IPin *pConnected;
    hr = pIPin()->ConnectedTo(&pConnected);
    if (FAILED(hr)) {   // not connected.
        ASSERT(m_plink == NULL);
        return FALSE;
    }
    else if (hr == S_OK) {
        pConnected->Release();
        return TRUE;
    }
    else {
        TRACE("ConnectedTo Error\n");
        throw CHRESULTException(hr);
        return FALSE;   // need this to keep the compiler happy...
    }
}


//
// Peer
//
// return the socket this is connected to.
// only valid if connected.
// returns null in error case.
CBoxSocket *CBoxSocket::Peer(void) {

    IPin *pConnected;
    HRESULT hr = pIPin()->ConnectedTo(&pConnected);
    if(FAILED(hr)) {
       return NULL;     // should only fail if not connected
    }

    PIN_INFO piPeer;
    hr = pConnected->QueryPinInfo(&piPeer);
    if (FAILED(hr)) {
        pConnected->Release();
        return NULL;
    }

    CBox *pbox = m_pbox->pDoc()->m_lstBoxes.GetBox(piPeer.pFilter);
    QueryPinInfoReleaseFilter(piPeer);
    if (pbox == NULL) {
        pConnected->Release();
        return NULL;
    }

    CBoxSocket *pSocket = pbox->GetSocket(pConnected);
    pConnected->Release();
    return pSocket;
}


// *
// * CBoxSocketList
// *

//
// GetSocket
//
// Return the socket on this list that manages this pin. Return
// NULL if not present.
CBoxSocket *CBoxSocketList::GetSocket(IPin *pPin) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBoxSocket *psock = GetNext(pos);
        if ( CIPin(pPin) == CIPin(psock->pIPin()) )
            return psock;

    }

    return NULL;
}


// *
// * CBox
// *

//
// Copy Constructor
//
CBox::CBox(const CBox& box)
    : m_fSelected(box.m_fSelected)
    , m_fHasClock(box.m_fHasClock)
    , m_fClockSelected(FALSE)
    , m_IFilter(box.m_IFilter)
    , m_rcBound(box.m_rcBound)
    , m_stLabel(box.m_stLabel)
    , m_pDoc(box.m_pDoc)
    , m_RelativeY(box.m_RelativeY)
    , m_lInputTabPos(box.m_lInputTabPos)
    , m_lOutputTabPos(box.m_lOutputTabPos)
    , m_iTotalInput(box.m_iTotalInput)
    , m_iTotalOutput(box.m_iTotalOutput) {

    POSITION posNext = box.m_lstSockets.GetHeadPosition();

    while (posNext != NULL) {

        CBoxSocket *psock = (CBoxSocket *) box.m_lstSockets.GetNext(posNext);
        CBoxSocket *psockNew = new CBoxSocket(*psock, this);
        m_lstSockets.AddTail(psockNew);
    }
}


//
// CBox::Constructor
//
CBox::CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc, CString *pName, CPoint point)
    : m_IFilter(pFilter)
    , m_fSelected(FALSE)
    , m_fClockSelected(FALSE)
    , m_pDoc(pDoc)
    , m_rcBound(point, CSize(0,0))
    , m_RelativeY(0.0f)
{

    //
    // Do we have a IReferenceClock
    //
    IReferenceClock * pClock;
    HRESULT hr = pIFilter()->QueryInterface(IID_IReferenceClock, (void **) &pClock);
    m_fHasClock = SUCCEEDED(hr);
    if (SUCCEEDED(hr)) {
        pClock->Release();
    }

    m_stFilter = *pName;

    // See if this filter needs a file opening
    // needs a better soln - what about other interfaces?
    AttemptFileOpen(pIFilter());

    GetLabelFromFilter( &m_stLabel );
    UpdateSockets();

    //
    // If point was not (-1, -1) then we can exit now.
    //
    if ((point.x != -1) || (point.y != -1)) {
        return;
    }

    //
    // We need to place the box out of the way from other boxes in the
    // view.
    //

    CWnd *pWnd;
    CScrollView * pScrollView;
    {
        // Get the only view from the document and recast it into a CWnd.
        // the view.
        POSITION pos = pDoc->GetFirstViewPosition();
        ASSERT(pos);

        pScrollView = (CScrollView *) pDoc->GetNextView(pos);
        pWnd = (CWnd *) pScrollView;
        ASSERT(!pos);
    }

    // Get the dimension of the window in device units.
    RECT rectWndSize;
    pWnd->GetClientRect(&rectWndSize);

    // Use the DC to convert from device units to logical units
    CDC * pDC   = pWnd->GetDC();
    pDC->DPtoLP(&rectWndSize);
    pWnd->ReleaseDC(pDC);

    //
    // Place the box at the bottom of the window minus the size of the box
    // minus a bit. Note that the window size equals to the size needed to
    // contain all filters.
    //
    int newPosition = rectWndSize.bottom - Height();

    if (newPosition < 0) {
        newPosition = 0;
    }

    //
    // If there are no filters above us, we can move further up.
    //
    CSize pSize = pScrollView->GetTotalSize();
    CPoint pt = pScrollView->GetScrollPosition();

    if (newPosition > pSize.cy) {
        newPosition = pSize.cy;
    }

    Location(CPoint(pt.x, newPosition));
}

//
// Constructor(IBaseFilter *)
//
CBox::CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc)
    : m_pDoc(pDoc)
    , m_IFilter(pFilter)
    , m_fSelected(FALSE)
    , m_fClockSelected(FALSE)
    , m_rcBound(0,0,0,0)
{

    //
    // Do we have a IReferenceClock
    //
    IReferenceClock * pClock;
    HRESULT hr = pIFilter()->QueryInterface(IID_IReferenceClock, (void **) &pClock);
    m_fHasClock = SUCCEEDED(hr);
    if (SUCCEEDED(hr)) {
        pClock->Release();
    }

    GetLabelFromFilter( &m_stLabel );

    UpdateSockets();
}

// CBox::GetFilterLabel
//
// Get the filters name from the filter or the registry
//
void CBox::GetLabelFromFilter( CString *pstLabel )
{
    // Try and get the filter name
    if (m_stFilter == "") {
        FILTER_INFO fi;
        m_IFilter->QueryFilterInfo( &fi );
        QueryFilterInfoReleaseGraph( fi );

        if ((fi.achName != NULL) && (fi.achName[0] != 0)) {
            // the filter has a name
            m_stFilter = CString( fi.achName );
        }
        else {
            // If that lot failed attempt to get the name from the ClsID
            // get the name through the clsid
            CLSID clsidTemp;
            m_IFilter->GetClassID(&clsidTemp);
            WCHAR szGuid[40];
            StringFromGUID2(clsidTemp, szGuid, 40 );
            m_stFilter = szGuid;
        }
    }

    // Try and get the box label (either the filter name
    // or the filename of the source/sink file)
    if (*pstLabel != m_stFilter) {
        IFileSourceFilter *pIFileSource;
        IFileSinkFilter *pIFileSink;
        BOOL bSource, bSink, bGotLabel = FALSE;
        LPOLESTR poszName;
        AM_MEDIA_TYPE mtNotUsed;

        bSource = SUCCEEDED(m_IFilter->QueryInterface(IID_IFileSourceFilter, (void **) &pIFileSource));
        bSink   = SUCCEEDED(m_IFilter->QueryInterface(IID_IFileSinkFilter, (void **) &pIFileSink));

        ASSERT( bSource || !pIFileSource );
        ASSERT( bSink   || !pIFileSink   );

        // If we have a source but no sink attempt to get the source filename
        if( bSource && !bSink ){
            if (SUCCEEDED(pIFileSource->GetCurFile(&poszName, &mtNotUsed)) &&
                poszName){
                *pstLabel = (LPCWSTR) poszName;
                CoTaskMemFree(poszName);
                bGotLabel = TRUE;
            }
        } else if( bSink && !bSource ){
            // Else if we have a sink but no ssource attempt to get the sink filename
                if (SUCCEEDED(pIFileSink->GetCurFile(&poszName, &mtNotUsed)) &&
                    poszName){
                *pstLabel = (LPCWSTR) poszName;
                CoTaskMemFree(poszName);
                bGotLabel = TRUE;
            }
        }

        if( pIFileSource ) pIFileSource->Release();
        if( pIFileSink   ) pIFileSink  ->Release();

        if (!bGotLabel) {
            *pstLabel = m_stFilter;
        }
    }
}


//
// Destructor
//
CBox::~CBox() {

    //
    // Remove all Sockets from out box
    //
    while ( NULL != m_lstSockets.GetHeadPosition() ) {
        RemoveSocket( m_lstSockets.GetHeadPosition(), TRUE );
    }

    HideDialog();

    TRACE("~CBox: %x\n", this);

}


//
// Refresh
//
// re-calculate the sockets we need if the pins have changed
HRESULT CBox::Refresh(void) {

    // update box's label (properties may have changed it)
    GetLabelFromFilter(&m_stLabel);

    try {

        UpdateSockets();
    }
    catch (CHRESULTException chr) {
        return chr.Reason();
    }

    return NOERROR;
}


//
// CBox::operator==
//
BOOL CBox::operator==(const CBox& box) const {

    ASSERT_VALID(&box);
    ASSERT_VALID(this);

    // need to make a meaningful descision about socket list
    // equality.

    return (  (m_rcBound       == box.m_rcBound)
            &&(m_IFilter       == (IUnknown *)box.m_IFilter)
            &&(m_stLabel       == box.m_stLabel)
            &&(m_lInputTabPos  == box.m_lInputTabPos)
            &&(m_lOutputTabPos == box.m_lOutputTabPos)
            &&(m_pDoc          == box.m_pDoc)
           );
}


//
// AddToGraph
//
// Adds this filter to the graph
HRESULT CBox::AddToGraph(void) {

    ASSERT(m_pDoc);
    ASSERT(pIFilter());

    TRACE("Adding filter (@: %x)\n", pIFilter());

    // Add the filter. Use it's own name (not our label) as its name
#ifdef _UNICODE
    HRESULT hr = m_pDoc->IGraph()->AddFilter(pIFilter(), (LPCTSTR) m_stFilter);
#else
    WCHAR wszName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR) m_stFilter, -1, wszName, MAX_PATH);

    HRESULT hr = m_pDoc->IGraph()->AddFilter(pIFilter(), wszName);
#endif

    if (FAILED(hr)) {
        TRACE("Failed to add filter (@: %x)\n", pIFilter());
        return hr;
    }

    return NOERROR;
}


//
// RemoveFromGraph
//
// Removes filter from graph
HRESULT CBox::RemoveFromGraph(void) {

    TRACE("Removing Filter (@: %x)\n", pIFilter());

    ASSERT(m_pDoc);
    ASSERT(pIFilter());

    return m_pDoc->IGraph()->RemoveFilter(pIFilter());
}


//
// CalcTabPos
//
// Decide how many socket positions to have on box edge
void CBox::CalcTabPos(void) {

    PIN_INFO   pi;              // Information about each pin
    IPin      *pPin;            // Holds next pin obtained
    CPinEnum  NextInput(pIFilter(), CPinEnum::Input);   // Pin enumerator

    int iMaxOutputLabel = 0;  // biggest size of output pin names
    int iMaxInputLabel = 0;   // biggest size of input pin names

    m_iTotalInput = m_iTotalOutput = 0;
    m_lInputTabPos = m_lOutputTabPos = 0;

    while (0 != (pPin = NextInput())) {
        m_iTotalInput++;

        if (!FAILED(pPin->QueryPinInfo(&pi))) {
            iMaxInputLabel = max(iMaxInputLabel, (int) wcslen(pi.achName));
            QueryPinInfoReleaseFilter(pi);
        }

        pPin->Release();
    }

    CPinEnum  NextOutput(pIFilter(), CPinEnum::Output); // Pin enumerator
    while (0 != (pPin = NextOutput())) {
        m_iTotalOutput++;

        if (!FAILED(pPin->QueryPinInfo(&pi))) {
            iMaxOutputLabel = max(iMaxOutputLabel, (int) wcslen(pi.achName));
            QueryPinInfoReleaseFilter(pi);
        }

        pPin->Release();
    }

    m_lInputTabPos = m_iTotalInput;
    m_lOutputTabPos = m_iTotalOutput;

    // looks better if there are an even no of pin positions....
    if (m_lInputTabPos % 2 == 1)
        m_lInputTabPos++;

    if (m_lOutputTabPos % 2 == 1)
        m_lOutputTabPos++;

    // set the box size appropriately
    // inflate the rectangle by the differnce between the old height
    // and width and the new dimentions.

    // X should be at least 100 and be able to hold the name of the box
    // and the names of all pins.
    //
    // Note + 20 and + 30 are gaps, so that the labels don't glue to the
    // border.
    //
    int iNewXSize = max ((iMaxOutputLabel + iMaxInputLabel) * 6 + 20, 100);
    iNewXSize = max (iNewXSize, 10*m_stLabel.GetLength() + 30);

    int IncreaseXBy = iNewXSize - m_rcBound.Width();
    int IncreaseYBy = 60 + 20 * max(m_lInputTabPos, m_lOutputTabPos) - m_rcBound.Height();

    CPoint NewBottomRight(m_rcBound.BottomRight().x + IncreaseXBy,
                          m_rcBound.BottomRight().y + IncreaseYBy);

    m_rcBound.SetRect( m_rcBound.TopLeft().x
                     , m_rcBound.TopLeft().y
                     , NewBottomRight.x
                     , NewBottomRight.y
                     );
}


//
// UpdateSockets
//
// Updates the set of sockets to match the pins on this filter
void CBox::UpdateSockets(void) {

    CalcTabPos();

    //
    // Pins might be removed from the filter due to some other deletions.
    // The sockets associated to pins that disappeared must also be removed.
    //
    // We can only determine which pins are still present by enumerating
    // all and comparing them with our sockets. Because of efficiency we
    // don't want to enumerate all pins for each socket we need to verify.
    //
    // We therefore delete all sockets that represent unconnected pins.
    // Note that there might still be a link associated to the socket and
    // those links are removed as well (since they are obsolete).
    //
    // In the second phase we enumerate all pins and if they don't have
    // already a socket, add their socket to the box.
    //

    //
    // Remove all sockets with unconnected pins.
    //
    POSITION posSocket = m_lstSockets.GetHeadPosition();

    while (posSocket) {
        //
        // Remember the current item, then get the next one
        // then delete the current one.
        // We need to do it this way, because we have to get
        // the next item before we delete the current one.
        //
        POSITION posTemp = posSocket;

        m_lstSockets.GetNext(posSocket);
        RemoveSocket(posTemp); // will only be removed if unconnected pin
    }

    //
    // Now we enumerate all pins of the filter and add sockets for
    // those pins which don't have sockets in this box.
    //
    // Note that pin's of new sockets might be connected, but we
    // are not going to add the links till all boxes have been updated.
    //

    CPinEnum    Next(pIFilter());
    IPin        *pPin;
    int         nInputNow = 0, nOutputNow = 0;

    while (0 != (pPin = Next())) {

        HRESULT hr;
        PIN_INFO pi;
        hr = pPin->QueryPinInfo(&pi);

        if (FAILED(hr)) {
            pPin->Release();
            throw CHRESULTException(hr);
        }
        QueryPinInfoReleaseFilter(pi);

        //
        // We need to increment the input or ouput pin counter even
        // if we don't add the socket.
        //
        if (pi.dir == PINDIR_INPUT) {
            nInputNow++;
        }
        else {
            nOutputNow++;
        }

        //
        // If the pin has already a socket, update its tab.
        // (the box might have changed in size).
        //
        // If there is no socket, then add a new socket.
        //
        if (m_lstSockets.IsIn(pPin)) {
            //
            // Update the position of the pins on the filter.
            //
            CBoxSocket * pSocket = m_lstSockets.GetSocket(pPin);

            if (pi.dir == PINDIR_INPUT) {
                pSocket->m_tabpos.SetPos(nInputNow, 1 + m_lInputTabPos);
            }
            else {
                pSocket->m_tabpos.SetPos(nOutputNow, 1 + m_lOutputTabPos);
            }
        }
        else {
            //
            // we need a new socket
            //
            char achName[100];
            WideCharToMultiByte(CP_ACP, 0,
                                pi.achName, -1,
                                achName, sizeof(achName),
                                NULL, NULL);
        
            if (pi.dir == PINDIR_INPUT) {
                AddSocket(achName,
                          CBoxTabPos::LEFT_EDGE,
                          nInputNow,
                          1 + m_lInputTabPos,
                          pPin);
            }
            else {
                AddSocket(achName,
                          CBoxTabPos::RIGHT_EDGE,
                          nOutputNow,
                          1 + m_lOutputTabPos,
                          pPin);
            }
        }

        pPin->Release();
    }
}


//
// CalcRelativeY
//
// the Y position a box has relative to its upstream connections
void CBox::CalcRelativeY(void) {

    CSocketEnum NextInput(this, CSocketEnum::Input);
    CBoxSocket  *psock;

    m_RelativeY = 0.0f;

    while (0 !=(psock = NextInput())) {

        // !!! still broken
        CBoxSocket *pPeer;
        if (psock->IsConnected() && (pPeer = psock->Peer()) != NULL) {
            m_RelativeY += (pPeer->pBox()->Y() / m_iTotalInput);

            // adjust slightly based on which output pin the connection
            // attaches to on the other side, to avoid crossings
            CSocketEnum NextOutput(pPeer->pBox(), CSocketEnum::Output);
            int         socketNum = 0;
            CBoxSocket *psock2;
            while (0 != (psock2 = NextOutput())) {
                if (psock2 == pPeer) {
                    m_RelativeY += 0.01f * socketNum;
                }
                socketNum++;
            }
        }
    }
}


#ifdef _DEBUG

void CBox::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(pIFilter());
    ASSERT(m_pDoc);

    ASSERT(m_rcBound.Width() > 0);
    ASSERT(m_rcBound.Height() > 0);
}

void CBox::Dump(CDumpContext& dc) const {

    CPropObject::Dump(dc);

    dc << TEXT("x = ") << X() << TEXT(", y = ") << Y() << TEXT("\n");

    dc << TEXT("Name: ") << m_stLabel << TEXT("\n");
    dc << TEXT("IFilter :") << pIFilter() << TEXT("\n");
    dc << m_lstSockets;
}

void CBox::MyDump(CDumpContext& dc) const
{
    dc << TEXT("*** Box ***\n");
    dc << TEXT("    Location: ") << (void *) this << TEXT("\n");
    dc << TEXT("    Name    : ") << m_stLabel << TEXT("\n");
    dc << TEXT("    IBaseFilter : ") << (void *) pIFilter() << TEXT("\n");
    dc << TEXT("    ----- Sockets / Pins -----\n");

    POSITION pos = m_lstSockets.GetHeadPosition();
    while (pos) {
        CBoxSocket * pSocket = m_lstSockets.GetNext(pos);
        pSocket->MyDump(dc);
    }
    dc << TEXT("    ----- (end) ---------------\n");
}

void CBoxSocket::MyDump(CDumpContext& dc) const
{
    dc << TEXT("        Socket at ") << (void *) this    << TEXT("\n");
    dc << TEXT("           - Pin  ") << (void *) pIPin() << TEXT("\n");
    dc << TEXT("           - Link ") << (void *) m_plink << TEXT("\n");
    dc << TEXT("           - Box  ") << (void *) m_pbox  << TEXT("\n");
}

#endif // _DEBUG

//
// RemoveSocket
//
// Remove the socket from the boxes list of sockets.
// Only sockets which have an unconnected pin are allowed to be
// removed. We will also remove any existing link.
//
// If parameter <bForceIt> is true, any connection of the socket's pin
// will be disconnected.
//
// returns:
//  S_OK - Socket was removed
//  S_FALSE - Pin of socket was still connected therefore no removal.
//
HRESULT CBox::RemoveSocket(POSITION posSocket, BOOL bForceIt)
{
    CBoxSocket *pSocket = m_lstSockets.GetAt(posSocket);

    //
    // Test whether the socket's pin is unconnected.
    //
    IPin *pTempPin;
    pSocket->pIPin()->ConnectedTo(&pTempPin);

    if (NULL != pTempPin) {
        //
        // Pin is still connected.
        //

        if (!bForceIt) {
            // we are not allowed to disconnect it.
            pTempPin->Release();

            return(S_FALSE);
        }

        POSITION posTemp = pDoc()->m_lstLinks.Find(pSocket->m_plink);
        if (posTemp != NULL) {
            //
            // We need to check for posTemp != NULL here because
            // if we get called during DeleteContents, all links might
            // have been deleted - no matter of successfully disconnected
            // or not.
            //
            pDoc()->m_lstLinks.RemoveAt(posTemp);

            pSocket->m_plink->Disconnect();

            delete pSocket->m_plink;
            pSocket->m_plink = NULL;
        }

        pTempPin->Release();
    }

    //
    // Remove any links
    //
    if (pSocket->m_plink) {
        //
        // Need to remove the link from the CBoxNetDoc's <m_lstLinks> list.
        //
        POSITION posDelete = pDoc()->m_lstLinks.Find(pSocket->m_plink);
        pDoc()->m_lstLinks.RemoveAt(posDelete);

        // The destructor sets the head and tail socket's pointers to the link
        // to NULL.

        delete pSocket->m_plink;  // no disconnect needed
    }

    //
    // Remove the socket from m_lstSockets and delete it
    //
    m_lstSockets.RemoveAt(posSocket);
    delete pSocket;

    return(S_OK);
}

//
// AddSocket
//
void CBox::AddSocket(CString stLabel,
                     CBoxTabPos::EEdge eEdge,
                     unsigned uiVal,
                     unsigned uiValMax,
                     IPin *pPin) {

    CBoxSocket * pSocket;
    pSocket = new CBoxSocket(this, stLabel, eEdge, uiVal, uiValMax, pPin);

    m_lstSockets.AddTail(pSocket);
}


//
// ShowDialog
//
// Show our own dialog, and pass the request on to our sockets
void CBox::ShowDialog(void) {

    CPropObject::ShowDialog();

    CSocketEnum Next(this);
    CBoxSocket  *psock;
    while (0 != (psock = Next())) {

        psock->ShowDialog();
    }
}


//
// HideDialog
//
// Hide our dialog and pass the request to our sockets
void CBox::HideDialog(void) {

    CPropObject::HideDialog();

    CSocketEnum Next(this);
    CBoxSocket  *psock;
    while (0 != (psock = Next())) {

        psock->HideDialog();
    }
}


// *
// * CBoxList
// *

// A CList, with the ability to query the list for partiular _filters_


//
// IsIn
//
// Is this filter in this list?
BOOL CBoxList::IsIn(IBaseFilter *pFilter) const {

    if (GetBox(pFilter) != NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


//
// GetBox
//
// Return the box that manages this filter. NULL if not present.
CBox *CBoxList::GetBox(IBaseFilter *pFilter) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = GetNext(pos);

        if (CQCOMInt<IBaseFilter>(pFilter) == (IUnknown *)CQCOMInt<IBaseFilter>(pbox->pIFilter())) {
            return pbox;
        }
    }

    return NULL;
}


//
// GetBox
//
// Return the box managing the filter with the supplied clsid
CBox *CBoxList::GetBox(CLSID clsid) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = GetNext(pos);
        CQCOMInt<IPersist> IPer(IID_IPersist, pbox->pIFilter());

        CLSID clsidThis;
        IPer->GetClassID(&clsidThis);

        if (clsidThis == clsid) {
            return pbox;
        }
    }

    return NULL;
}


BOOL CBoxList::RemoveBox( IBaseFilter* pFilter, CBox** ppBox )
{
    POSITION posNext;
    CBox* pCurrentBox;
    POSITION posCurrent;

    // Prevent the caller from accessing random memory.
    *ppBox = NULL;

    posNext = GetHeadPosition();

    while( NULL != posNext ) {
        posCurrent = posNext;

        pCurrentBox = GetNext( posNext );
    
        if( IsEqualObject( pCurrentBox->pIFilter(), pFilter ) ) {
            RemoveAt( posCurrent );
            *ppBox = pCurrentBox;
            return TRUE;
        } 
    }

    return FALSE;
}

#ifdef _DEBUG
//
// Dump
//
void CBoxList::Dump( CDumpContext& dc ) const {

    CDeleteList<CBox *, CBox *>::Dump(dc);

}
#endif // _DEBUG

// *
// * CSocketEnum
// *

//
// CSocketEnum::Constructor
//
CSocketEnum::CSocketEnum(CBox *pbox, DirType Type)
    : m_Type(Type),
      m_pbox(pbox) {

    ASSERT(pbox);

    m_pos =  m_pbox->m_lstSockets.GetHeadPosition();

    if (m_Type == Input)
        m_EnumDir = ::PINDIR_INPUT;
    else if (m_Type == Output)
        m_EnumDir = ::PINDIR_OUTPUT;
}


//
// operator()
//
// return the next socket of the requested sense, NULL if no more.
CBoxSocket *CSocketEnum::operator() (void) {

    CBoxSocket *psock;

    do {
        if (m_pos != NULL) {
            psock = m_pbox->m_lstSockets.GetNext(m_pos);
        }
        else {  // no more sockets
            return NULL;
        }

        ASSERT(psock);

    } while (   (m_Type != All)
             && (psock->GetDirection() != m_EnumDir)
            );

    return psock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
	    // NOTE - the ClassWizard will add and remove mapping macros here.
	    //    DO NOT EDIT what you see in these blocks of generated code !
        ON_WM_MDIACTIVATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
    : m_pwndSeekBar(NULL)
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	if( !CMDIChildWnd::PreCreateWindow(cs) )
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

void CChildFrame::OnMDIActivate( BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd )
{
    CMDIChildWnd::OnMDIActivate(bActivate, pActivateWnd, pDeactivateWnd);

    if (pActivateWnd != pDeactivateWnd)
    {
        CMainFrame *pMainFrame = (CMainFrame*)AfxGetApp()->m_pMainWnd;

        pMainFrame->SetSeekBar(bActivate? m_pwndSeekBar : NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__FA06256A_3DA1_4DF7_ACB9_7C1DACE4D837__INCLUDED_)
#define AFX_CHILDFRM_H__FA06256A_3DA1_4DF7_ACB9_7C1DACE4D837__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CSeekDialog;

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:
    CSeekDialog* m_pwndSeekBar;

// Operations
public:
    void SetSeekBar(CSeekDialog* pwndSeekBar) {m_pwndSeekBar = pwndSeekBar; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
        afx_msg void OnMDIActivate( BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd );

		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__FA06256A_3DA1_4DF7_ACB9_7C1DACE4D837__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\box.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// box.h : declares CBoxTabPos, CBoxSocket, CBox
//

// forward declarations
class CBox;
class CBoxLink;
class CBoxNetDoc;

extern void AttemptFileOpen(IBaseFilter *m_pFilter);


/////////////////////////////////////////////////////////////////////////////
// CBoxTabPos
//
// A value of this class represents the position of a box tab along the edge
// of a box.  (A box tab is the graphical representation of a box network
// socket.)  The position is represented as a fraction of the length of the
// edge, so that resizing the box will retain the tab's relative position.
//
// To use CBoxTabPos:
//   -- <m_fLeftRight> is set to TRUE if the tab is on the left or right edge
//      of the box, FALSE if the tab is on the top or the bottom edge.
//   -- <m_fLeftTop> is set to TRUE if the tab is on the left or top edge
//      of the box, FALSE if the tab is on the right or bottom edge.
//   -- SetPos(uiVal, uiValMax) sets the position of the tab to be the fraction
//      (uiVal/uiValMax) of the way along the edge.
//   -- GetPos(uiValMax) returns a value <uiVal> such that the tab is
//      (uiVal/uiValMax) of the way along the edge.
//   -- Package() packages a CBoxTabPos into a form acceptable to the CArchive
//      << and >> operators.
// Internally, a CBoxTabPos is represented as two flags plus a CBTP_BITS-bit
// number that represents the tab position along the inside edge of the box,
// scaled to be in the range 0 to 1<<CBTP_BITS, (inclusive -- to allow 1.0
// to be representable).
//
// A simple way to create a CBoxTabPos is via a constructor, e.g.
//      CBoxTabPos pos(CBoxTabPos::TOP_EDGE, 2, 3); // 2/3rds across top edge
//

class CBoxTabPos
{

protected:
    // private constants
    enum {CBTP_BITS = 13};      // no. bits of precision in <m_ulPos>

public:
    // identify a box edge
    enum EEdge
    {
        BOTTOM_EDGE = 0, // m_fLeftRight=FALSE, m_fLeftTop=FALSE
        TOP_EDGE    = 1, // m_fLeftRight=FALSE, m_fLeftTop=TRUE
        RIGHT_EDGE  = 2, // m_fLeftRight=TRUE,  m_fLeftTop=FALSE
        LEFT_EDGE   = 3 // m_fLeftRight=TRUE,  m_fLeftTop=TRUE
    };

public:
    // which side of box is tab on?
    BOOL        m_fLeftRight:1; // tab is on left or right edge of box
    BOOL        m_fLeftTop:1;   // tab is on left or top edge of box

protected:
    // how far along the edge is the tab?
    unsigned    m_ulPos:CBTP_BITS+1; // position along edge (0 == top/left end)

public:
    // construction
    CBoxTabPos() {};
    CBoxTabPos(EEdge eEdge, unsigned uiVal, unsigned uiValMax)
        { m_fLeftRight = fnorm(eEdge & 2);
          m_fLeftTop = fnorm(eEdge & 1);
          SetPos(uiVal, uiValMax); }

public:
    // operations
    void SetPos(unsigned uiVal, unsigned uiValMax)
        { m_ulPos = (unsigned) (((long) uiVal << CBTP_BITS) / uiValMax); }
    unsigned GetPos(unsigned uiValMax)
        { return (int) (((long) m_ulPos * uiValMax) >> CBTP_BITS); }

public:
    // convert object to a WORD reference (for easier serialization)
    WORD & Package() { return (WORD &) *this; }

#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const {
        dc << "Left: " <<  m_fLeftTop  << "m_ulPos: " << m_ulPos << "\n";
    }

#endif // _DEBUG
};


/////////////////////////////////////////////////////////////////////////////
// CBoxSocket
//
// Logically, a socket is a place on a CBox that you can connect a link to.
// (A link connects a socket on one box to a socket on another box.)
//
//
// A CBoxSocket object contains a pointer <m_pbox> back to the parent box,
// and a pointer <m_plink> to the link that connects the socket to another
// socket (or NULL if the socket is not currently linked).  <m_stLabel> is
// a string label, and <m_tabpos> indicates where on the box the tab
// (the visual reprentation of the socket) and the label should be placed.
//

class CBoxSocket : public CPropObject {

public:
    // pointer back to parent box, pointer to connected link (if any)
    CBox	*m_pbox;             // box that contains socket
    CBoxLink	*m_plink;            // link connected to the socket (or NULL)

    CBox *pBox(void) const { return m_pbox; };

public:
    // socket user interface
    CString     m_stLabel;          // socket label

    CString	Label(void) const { return m_stLabel; }
    void	Label(CString st) { m_stLabel = st; }

    CBoxTabPos  m_tabpos;           // socket tab position along an edge

    // -- Quartz --


    IPin	*pIPin(void) const { return m_IPin; }	// NB not addref'd
    IUnknown	*pUnknown(void) const { return m_IPin; }	// NB not addref'd
    CBoxSocket	*Peer(void);
    BOOL	IsConnected(void);
    PIN_DIRECTION	GetDirection(void);

private:

    CQCOMInt<IPin>	m_IPin;		// The pin this socket minds.

    friend class CBox;

public:
    // construction
    CBoxSocket(const CBoxSocket& sock, CBox *pbox);
    CBoxSocket( CBox *pbox
              , CString stLabel
              , CBoxTabPos::EEdge eEdge
              , unsigned uiVal
              , unsigned uiValMax
              , IPin *pPin);
    ~CBoxSocket();

public:

    #ifdef _DEBUG
    
    // diagnostics
    virtual void Dump(CDumpContext& dc) const
    {
        CPropObject::Dump(dc);
        dc << m_stLabel << "\n";

        m_tabpos.Dump(dc);
    }

    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;
    
    #endif // _DEBUG

private:
    CBoxSocket(const CBoxSocket&); // the plain copy constructor is not allowed
};


// *
// * CBoxSocketList
// *

// Provides a way of getting a socket via an IPin

class CBoxSocketList : public CDeleteList<CBoxSocket *, CBoxSocket *> {
public:

    CBoxSocket *GetSocket(IPin *pPin) const;
    BOOL	IsIn(IPin *pPin) const { return (GetSocket(pPin) != NULL); }
};


/////////////////////////////////////////////////////////////////////////////
// CBox
//
// A box is a node in a box network.  Boxes contain sockets (CBoxSocket
// objects); sockets of different boxes may be connected using a CBoxLink.
//
// A CBox object contains a list <m_lstSockets> of CBoxSocket objects,
// a bounding rectangle <m_rcBound> which locates the box in its container,
// and a string label.
//
// A box also contains a flag <m_fSelected> indicating whether or not the
// box is selected.  This implies that box selection is an attribute of a
// document (containing boxes), not an attribute of a view onto such a
// document.
//
// A box manages a single Quartz Filter.

class CBox : public CPropObject {

    // -- box user interface --
    CRect       m_rcBound;          // box bounding rectangle

#define ZOOM(x) ((x) * s_Zoom / 100)    
#define UNZOOM(x) ((x) * 100 / s_Zoom)
    
public:
    static int s_Zoom;

    static void SetZoom(int iZoom);
    
    CRect       GetRect() const { return CRect(ZOOM(m_rcBound.left), ZOOM(m_rcBound.top),
                                   ZOOM(m_rcBound.right), ZOOM(m_rcBound.bottom)); }

    CPoint	Location(void) const { return CPoint(ZOOM(m_rcBound.left), ZOOM(m_rcBound.top)); }
    void	Location(CPoint pt) { X(pt.x); Y(pt.y); }
    int		X(void) const { return ZOOM(m_rcBound.left); }
    int		Y(void) const { return ZOOM(m_rcBound.top); }

    void	X(int x) { m_rcBound.SetRect(UNZOOM(x), m_rcBound.top, m_rcBound.Width() + UNZOOM(x), m_rcBound.bottom); }
    void	Y(int y) { m_rcBound.SetRect(m_rcBound.left, UNZOOM(y), m_rcBound.right, m_rcBound.Height() + UNZOOM(y)); }

    void        Move(CSize siz) { m_rcBound.OffsetRect(UNZOOM(siz.cx), UNZOOM(siz.cy)); }
    int		Width(void) const { return ZOOM(m_rcBound.Width()); }
    int		Height(void) const { return ZOOM(m_rcBound.Height()); }

    CString     m_stLabel;          // box label
    CString     m_stFilter;         // filter name

    void	Label(CString st) { m_stLabel = st; }
    CString	Label(void) const { return m_stLabel; }

    void	SetSelected(BOOL fSelected) { m_fSelected = fSelected; }
    BOOL	IsSelected(void) { return m_fSelected; }

    // CPropObject overrides - distribute requests to our sockets
    virtual void ShowDialog();
    virtual void HideDialog();

    BOOL        HasClock() { return m_fHasClock; }
    BOOL        HasSelectedClock() { return m_fClockSelected; }

private:
    BOOL        m_fSelected;        // box is selected?
    BOOL        m_fHasClock;
    BOOL        m_fClockSelected; // this filters clock is the current one


    // -- Automatic layout helpers --
public:
    void	CalcRelativeY(void);	// y position relative to input peers
    float	RelativeY(void) const { return m_RelativeY; }

private:

    float	m_RelativeY;


    // -- Quartz --
public:

    CBoxNetDoc	*pDoc(void) const {ASSERT(m_pDoc); return m_pDoc;}
    IBaseFilter	*pIFilter(void) const { return m_IFilter; } 	// NB not addref'd
    IUnknown	*pUnknown(void) const { return m_IFilter; }	// NB not addref'd

    HRESULT	Refresh(void);

    HRESULT	AddToGraph(void);
    HRESULT	RemoveFromGraph(void);

private:

    CQCOMInt<IBaseFilter>	m_IFilter;	    // While this box exists the filter is instantiated
    LONG		m_lInputTabPos;
    LONG		m_lOutputTabPos;
    int			m_iTotalInput;
    int			m_iTotalOutput;
    CBoxNetDoc		*m_pDoc;

    void CalcTabPos(void);
    void UpdateSockets(void);


    // -- construction and destruction --
public:

    CBox(const CBox& box);    // copy constructor
    CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc);
    CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc, CString *pName, CPoint point = CPoint(-1, -1));
    ~CBox();


    // -- operations --
public:

    void AddSocket(CString stLabel, CBoxTabPos::EEdge eEdge,
        unsigned uiVal, unsigned uiValMax, IPin *pPin);
    HRESULT RemoveSocket(POSITION, BOOL bForceIt = FALSE);

    BOOL operator==(const CBox& box) const;
    BOOL operator!=(const CBox& box) const { return !(*this == box); }

    // return the socket managing this pin
    CBoxSocket *GetSocket(IPin *pPin) { return m_lstSockets.GetSocket(pPin); }

    void GetLabelFromFilter( CString *pstLabel );


    // -- Diagnostics --
public:
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;
#endif // _DEBUG

private:
    // sockets to hold connections to other boxes
    CBoxSocketList   m_lstSockets;       // list of CBoxSocket objects

    friend class CSocketEnum;	// iterates each socket in turn
    friend class CBoxNetDoc;    // to update m_fClockSelected
};



// *
// * CBoxList
// *

// A list where you can find elements by IBaseFilter
class CBoxList : public CDeleteList<CBox *, CBox *> {

public:

    CBoxList(BOOL bDestructDelete = TRUE) : CDeleteList<CBox *, CBox *>(bDestructDelete) {}
    CBoxList(BOOL bDestructDelete, int nBlockSize) : CDeleteList<CBox *, CBox *>(bDestructDelete, nBlockSize) {}

    BOOL IsIn(IBaseFilter *pFilter) const;	// is one of the boxes in this list managing
    					// this filter?
    CBox *GetBox(IBaseFilter *pFilter) const;
    CBox *GetBox(CLSID clsid) const;

    BOOL RemoveBox( IBaseFilter* pFilter, CBox** ppBox );

#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
#endif // _DEBUG

};


// *
// * CSocketEnum
// *

// Returns each socket on this box, one by one. returns NULL
// when there are no more sockets.
// Can return a specific direction (input or output)
class CSocketEnum {
public:

    enum DirType {Input, Output, All};

    CSocketEnum(CBox *pbox, DirType Type = All);
    ~CSocketEnum() {};

    CBoxSocket *operator() (void);

private:

    CBox	*m_pbox;
    POSITION	m_pos;
    DirType	m_Type;
    PIN_DIRECTION	m_EnumDir;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\boxdraw.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// boxdraw.h : declares CBoxDraw
//

/////////////////////////////////////////////////////////////////////////////
// CBoxDraw
//
// A CBoxDraw object maintains resources etc. used to draw and hit-test
// boxes and links.  Note that CBoxDraw is not a view of a box or link --
// it is a collection of pens, brushes, bitmaps, and functions to draw
// boxes and links.
//
// This application maintains a single, global CBoxDraw object, <gpboxdraw>.
//

class CBoxDraw
{

protected:
    // private constants (see definition in .cpp file for more information)
    static const COLORREF   m_crBkgnd;
    static const CSize      m_sizLabelMargins;
    static const int        m_iHotZone;
    static const CString    m_stBoxFontFace;
    static const int        m_iBoxLabelHeight;
    static const int        m_iBoxTabLabelHeight;
    static const COLORREF   m_crLinkNoHilite;
    static const COLORREF   m_crLinkHilite;
    static const int        m_iHiliteBendsRadius;

public:
    // constants returned by hit-test functions
    enum EHit
    {
        HT_MISS,                    // didn't hit anything
        HT_TAB,                     // hit a box tab
        HT_EDGE,                    // hit the edge of the box
        HT_TABLABEL,                // hit a box tab label
        HT_BOXLABEL,                // hit the box label
        HT_BOXFILE,                 // hit the box filename
        HT_BOX,                     // hit elsewhere on the box
        HT_LINKLINE,                // hit a link line segment
    };

protected:
    // <m_abmEdges> and <m_abmTabs> are two bitmaps (element 0 for
    // unhighlighted, element 1 for highlighted state) that each
    // contain 3x3 tiles used to draw boxes (see DrawCompositeFrame())
    CBitmap         m_abmEdges[2];  // composite bm. for drawing box edges
    CBitmap         m_abmTabs[2];   // composite bm. for drawing box tabs
    CBitmap         m_abmClocks[2]; // clock icon to show IReferenceClock filters
    SIZE            m_sizEdgesTile; // size of one of the tiles
    SIZE            m_sizTabsTile;  // size of one of the tiles
    SIZE            m_sizClock;     // size of the clock bitmap

protected:
    // fonts used to draw box labels and box tab labels
    CFont           m_fontBoxLabel; // font for box label
    CFont           m_fontTabLabel; // font for box tabs

protected:
    // brushes and pens used to draw links (element 0 for unhighlighted,
    // element 1 for highlighted state)
    CBrush          m_abrLink[2];   // brushes used to draw links
    CPen            m_apenLink[2];  // pens used to draw links

public:
    // construction and destruction
    CBoxDraw();
    ~CBoxDraw() { Exit(); };
    void Init();
    void RecreateFonts();
    void Exit();

public:
    // general functions
    COLORREF GetBackgroundColor()
        { return m_crBkgnd; }

public:
    // functions for box drawing and hit testing
    void GetInsideRect(const CBox *pbox, CRect *prc)
        { *prc = pbox->GetRect();
          prc->InflateRect(-m_sizTabsTile.cx, -m_sizTabsTile.cy); }

    void GetFrameRect(CBox *pbox, CRect *prc)
        { GetInsideRect(pbox, prc);
          prc->InflateRect(m_sizEdgesTile.cx, m_sizEdgesTile.cy); }

    void GetOrInvalBoundRect(CBox *pbox, CRect *prc, BOOL fLinks=FALSE,
        CScrollView *pScroll=NULL);

    void DrawFrame(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

    void DrawBoxLabel(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

//    void DrawBoxFile(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

    void DrawTabLabel(CBox *pbox, CBoxSocket *psock, CRect *prc,
        CDC *pdc, BOOL fDraw);

    void DrawTab(CBoxSocket *psock, CRect *prc, CDC *pdc,
        BOOL fDraw, BOOL fHilite);

    void InvalidateBoundRect(CBox *pbox, CWnd *pwnd)
        { pwnd->InvalidateRect(&pbox->GetRect(), TRUE); }

    CPoint GetTabCenter(CBoxSocket *psock);

    CBoxTabPos BoxTabPosFromPoint(CBox *pbox, CPoint pt, LPINT piError);

    CPoint BoxTabPosToPoint(const CBox *pbox, CBoxTabPos tabpos);

    void DrawBox(CBox *pbox, CDC *pdc,  CBoxSocket *psockHilite=NULL,
        CSize *psizGhostOffset=NULL);

    EHit HitTestBox(CBox *pbox, CPoint pt, CBoxTabPos *ptabpos,
        CBoxSocket **ppsock);

public:
    // functions for link drawing and hit testing

    void GetOrInvalLinkRect(CBoxLink *plink, CRect *prc, CScrollView *pScroll=NULL);

    void SelectLinkBrushAndPen(CDC *pdc, BOOL fHilite);

    void DrawArrow(CDC *pdc, CPoint ptTail, CPoint ptHead, BOOL fGhost=FALSE,
        BOOL fArrowhead=TRUE, BOOL fHilite=FALSE);

    void DrawLink(CBoxLink *plink, CDC *pdc, BOOL fHilite=FALSE, CSize *psizGhostOffset=NULL);

    EHit HitTestLink(CBoxLink *plink, CPoint pt, CPoint *pptProject);
};


/////////////////////////////////////////////////////////////////////////////
// Global (shared) CBoxDraw object

extern CBoxDraw * gpboxdraw;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\cmd.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// cmd.h : declares CCmd and the CCmdXXX classes based on it
//


/////////////////////////////////////////////////////////////////////////////
// CCmd
//
// CCmd is a virtual class that implements an interface to commands performed
// on a CBoxNetDoc.
//
// A CCmd represents a command given to a CBoxNetDoc.  To perform a command,
// allocate a CCmdXXX structure and submit it to CBoxNetDoc::CmdDo(), which
// will call the Do() memeber function.  The Undo() and Redo() member functions
// get called when the user performs an Undo or Redo action, respectively.
// Repeat() should create a duplicate of the command, to perform a Repeat
// action; if this is not possible, return FALSE from CanRepeat().
// The destructor gets called when there is no chance the command will be
// undone or redone; at this time, <fRedo> will be TRUE if the command is on
// the redo stack (so e.g. the CBox in a CCmdNewBox command should be freed)
// or FALSE if the command is on the undo stack (so e.g. the CBox in a
// CCmdNewBox command should not be freed since it is currently in use by
// the document).
//
// CanUndo() returns TRUE iff Undo() is implemented.  CanRepeat() returns
// TRUE iff Repeat() can be called at that time (e.g. some commands depend
// on there being something selected at that time).
//
// Some subclasses of CCmd implement a static CanDo() method which returns
// TRUE if a command of that class can be created and Do() can be called at
// that time.
//

class CCmd : public CObject {
public:
    BOOL       m_fRedo;            // command is sitting in the Redo stack

public:

    CCmd(void) : m_fRedo(FALSE) {;}
    virtual ~CCmd() {;}
    virtual unsigned GetLabel() = 0;

    // Perform the command on this document
    virtual void Do(CBoxNetDoc *pdoc) = 0;

    // If CanUndo() then Undo & redo can be called
    virtual BOOL CanUndo(CBoxNetDoc *pdoc)	{ return FALSE; }
    virtual void Undo(CBoxNetDoc *pdoc)		{;}
    virtual void Redo(CBoxNetDoc *pdoc)		{;}

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc)	{ return FALSE; }
    virtual CCmd *Repeat(CBoxNetDoc *pdoc)	{ return NULL; }
};


//
// --- CCmdAddFilter ---
//
class CCmdAddFilter : public CCmd {
protected:
    CBox        *m_pbox;        // box being created
    CBoxNetDoc  *m_pdoc;	// document to add it to
    BOOL	m_fAdded;	// TRUE iff filter added to graph

    CQCOMInt<IMoniker> m_pMoniker; // keep moniker so we can repeat
    CString	m_stLabel;	// keep label for repeat

public:
    virtual unsigned GetLabel(void)	{ return IDS_CMD_ADDFILTER; }
    CCmdAddFilter(IMoniker *pMon, CBoxNetDoc *pdoc, CPoint point = CPoint(-1, -1));
    virtual ~CCmdAddFilter();

    virtual void Do(CBoxNetDoc *pdoc);

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual BOOL CanUndo(CBoxNetDoc *pdoc)	{ return TRUE; }
    virtual void Undo(CBoxNetDoc *pdoc);
    virtual void Redo(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc) { return TRUE; }
    virtual CCmd *Repeat(CBoxNetDoc *pdoc);
};


//
// --- CCmdDeleteSelection ---
//
class CCmdDeleteSelection : public CCmd {

public:
    virtual unsigned GetLabel(void) { return IDS_CMD_DELETE; }

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual void Do(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc);
    virtual CCmd * Repeat(CBoxNetDoc *pdoc);

private:

    void DeleteFilters(CBoxNetDoc *pdoc);
    void DeleteLinks(CBoxNetDoc *pdoc);
};


//
// --- CCmdMoveBoxes ---
//
class CCmdMoveBoxes : public CCmd {
protected:
    CSize           m_sizOffset;        // how much selection is offset by
    CBoxList        m_lstBoxes;         // list containing each CBox to move

public:

    virtual unsigned GetLabel();
    CCmdMoveBoxes(CSize sizOffset);
    virtual ~CCmdMoveBoxes();

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual void Do(CBoxNetDoc *pdoc);

    virtual BOOL CanUndo(CBoxNetDoc *pdoc) { return TRUE; }
    virtual void Undo(CBoxNetDoc *pdoc);
    virtual void Redo(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc);
    virtual CCmd * Repeat(CBoxNetDoc *pdoc);
};


//
// --- CCmdConnect ---
//
class CCmdConnect : public CCmd {
protected:
    CBoxLink *      m_plink;            // link being created

public:
    virtual unsigned GetLabel(void) { return IDS_CMD_CONNECT; }
    CCmdConnect(CBoxSocket *psockTail, CBoxSocket *psockHead);

    virtual void Do(CBoxNetDoc *pdoc);
};


//
// --- CCmdDisconnectAll ---
//
class CCmdDisconnectAll : public CCmd {

public:

    CCmdDisconnectAll();
    virtual ~CCmdDisconnectAll();

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual unsigned GetLabel(void) { return IDS_CMD_DISCONNECTALL; }
    virtual void Do(CBoxNetDoc *pdoc);

    virtual void Redo(CBoxNetDoc *pdoc);
};


//
// --- CCmdRender ---
//
class CCmdRender : public CCmd {

public:

    static BOOL		CanDo( CBoxNetDoc *pdoc );
    virtual unsigned	GetLabel() { return IDS_CMD_RENDER; }
    virtual void	Do(CBoxNetDoc *pdoc);

};


//
// --- CCmdRenderFile ---
//
class CCmdRenderFile : public CCmd {

public:

    CCmdRenderFile(CString FileName) : m_FileName(FileName) {}

    static BOOL		CanDo(void) { return TRUE; }
    virtual unsigned	GetLabel() { return IDS_CMD_RENDERFILE; }

    virtual void	Do(CBoxNetDoc *pdoc);

private:

    CString m_FileName;
};

class CCmdAddFilterToCache : public CCmd
{
public:
    unsigned GetLabel();

    static BOOL CanDo( CBoxNetDoc *pdoc );
    void Do( CBoxNetDoc *pdoc );

private:
    HRESULT IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter );

};

class CCmdReconnect : public CCmd
{
public:
    unsigned CCmdReconnect::GetLabel();
    static BOOL CanDo( CBoxNetDoc* pDoc );
    void Do( CBoxNetDoc* pDoc );

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\cmd.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// cmd.cpp : defines CCmd and the CCmdXXX classes based on it
//
// See cmd.h for a description of CCmd, the abstract class upon which
// all CCmdXXX classes are defined.
//

#include "stdafx.h"
#include "ReConfig.h"
#include "GEErrors.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static void MonGetName(IMoniker *pMon, CString *pStr)
{
    *pStr = "";
    IPropertyBag *pPropBag;
    HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {
        VARIANT var;
        var.vt = VT_BSTR;
        hr = pPropBag->Read(L"FriendlyName", &var, 0);
        if(SUCCEEDED(hr))
        {
            *pStr = var.bstrVal;
            SysFreeString(var.bstrVal);
        }

        pPropBag->Release();
    }
}



//
// --- CCmdAddFilter ---
//
// Add a filter to the document.
// provide either a CLSID and the command will create
// the necessary UI element.


//
// Constructor
//
// CoCreate the filter and create its UI element
CCmdAddFilter::CCmdAddFilter(IMoniker *pMon, CBoxNetDoc *pdoc, CPoint point)
   :  m_pdoc(pdoc)
    , m_fAdded(FALSE)
    , m_pMoniker(pMon)
{
    {
        IBaseFilter *pFilter;
        HRESULT hr = pMon->BindToObject(0, 0, IID_IBaseFilter, (void **)&pFilter);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }

        CString szDevName;
        MonGetName(pMon, &szDevName);
        
        m_pbox = new CBox(pFilter, pdoc, &szDevName, point);
        pFilter->Release();
        if(m_pbox == 0) {       // !!! redundant?
            throw CHRESULTException(E_OUTOFMEMORY);
        }
    }
            
    
    m_pMoniker = pMon;          // addref automatic

    m_stLabel = m_pbox->Label();
}

//
// CanDo
//
// We can only add a filter if the filter graph is stopped
BOOL CCmdAddFilter::CanDo(CBoxNetDoc *pdoc)
{
    ASSERT(pdoc);

    return(pdoc->IsStopped());
}

//
// Do
//
// Add the box to the document, and add the filter to the graph
void CCmdAddFilter::Do(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    pdoc->DeselectAll();

    // select the box being added
    m_pbox->SetSelected(TRUE);

    HRESULT hr = m_pbox->AddToGraph();
    if (FAILED(hr)) {
        DisplayQuartzError( IDS_CANT_ADD_FILTER, hr );
	m_fAdded = FALSE;
	return;
    }
    // pins may have changed
    hr = m_pbox->Refresh();

    m_pbox->ShowDialog();	// show any property dialog

    // add the box to the document and update the view
    pdoc->m_lstBoxes.AddHead(m_pbox);
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOX, m_pbox);

    m_fAdded = TRUE;

}


//
// Undo
//
void CCmdAddFilter::Undo(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    if (!m_fAdded) {
        return;		// the box was never added
    }

    // remove the box from the document and update the view
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOX, m_pbox);

    pdoc->m_lstBoxes.RemoveHead();

    m_pbox->RemoveFromGraph();
    m_pbox->HideDialog();	// hide any property dialog
}


//
// Redo
//
void CCmdAddFilter::Redo(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    Do(pdoc);

}


//
// Repeat
//
// Construct an AddFilter command that adds the same filter
// to this document.
CCmd *CCmdAddFilter::Repeat(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    return new CCmdAddFilter(m_pMoniker, pdoc);
}


//
// Destructor
//
// delete m_pbox we are on the redo stack or if it was not added.
CCmdAddFilter::~CCmdAddFilter() {

    TRACE("~CCmdAddFilter() m_fRedo=%d\n", m_fRedo);

    if (m_fRedo) {	// on redo stack

        delete m_pbox;
    }
    else if (!m_fAdded) {	// on undo stack, but filter was not added

        delete m_pbox;
    }
}


//
// --- CCmdDeleteSelection ---
//


//
// CanDo
//
// Only possible if boxes are selected and the graph is stopped
BOOL CCmdDeleteSelection::CanDo(CBoxNetDoc *pdoc) {

    return ( !pdoc->IsSelectionEmpty() && pdoc->IsStopped() );
}


//
// Do
//
// 2 phases - Delete links, so that the neccessary connections are broken
//	    - Delete the filters. These are now unconnected, so safe to remove from the graph
void CCmdDeleteSelection::Do(CBoxNetDoc *pdoc) {

    DeleteLinks(pdoc);
    DeleteFilters(pdoc);

    //
    // Redraw the whole graph
    //
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);
}


//
// DeleteLinks
//
// Remove the selected links from the document & disconnect them
//
void CCmdDeleteSelection::DeleteLinks(CBoxNetDoc *pdoc) {

    POSITION posNext = pdoc->m_lstLinks.GetHeadPosition();

    while (posNext != NULL) {

        POSITION posCurrent = posNext;
        CBoxLink *plink = (CBoxLink *) pdoc->m_lstLinks.GetNext(posNext);
	    if (plink->IsSelected()) {
	
    	    pdoc->m_lstLinks.RemoveAt(posCurrent);

            plink->Disconnect();

            delete plink;

            //
            // There might be links which where removed in the
            // Disconnect operation. We need to start from the beginning.
            //
            posNext = pdoc->m_lstLinks.GetHeadPosition();
	    }
    }
}


//
// DeleteFilters
//
// Remove the selected filters from the document & filtergraph
void CCmdDeleteSelection::DeleteFilters(CBoxNetDoc *pdoc) {

    POSITION posNext = pdoc->m_lstBoxes.GetHeadPosition();

    while (posNext != NULL) {

        POSITION posCurrent = posNext;
        CBox *pbox = pdoc->m_lstBoxes.GetNext(posNext);
        if (pbox->IsSelected()) {

	        pdoc->m_lstBoxes.RemoveAt(posCurrent);

	        pbox->RemoveFromGraph();
	        pbox->HideDialog();	// hide any property dialog on display

            delete pbox;
        }
    }
}


//
// Repeat
//
// Return a new DeleteSelection command
CCmd *CCmdDeleteSelection::Repeat(CBoxNetDoc *pdoc) {

    return (new CCmdDeleteSelection());
}


//
// CanRepeat
//
// If there is a selection this command is repeatable
BOOL CCmdDeleteSelection::CanRepeat(CBoxNetDoc *pdoc) {

    return CanDo(pdoc);
}


//
// --- CCmdMoveBoxes ---
//
// CCmdMoveBoxes(sizOffset) constructs a command to move the currently
// selected  boxes by <sizOffset> pixels.
//
// Member variables:
//  CSize           m_sizOffset;        // how much selection is offset by
//  CObList         m_lstBoxes;         // list containing each CBox to move
//
// <m_sizOffset> is the number of pixels the selection is to be offset by
// (in the x- and y-direction).  <m_lstBoxes> contains the list of boxes
// that will be moved.
//


BOOL CCmdMoveBoxes::CanDo(CBoxNetDoc *pdoc) {

    // can only move boxes if one or more boxes are selected
    return !pdoc->IsBoxSelectionEmpty();
}


unsigned CCmdMoveBoxes::GetLabel() {

    if (m_lstBoxes.GetCount() == 1)
        return IDS_CMD_MOVEBOX;             // singular form
    else
        return IDS_CMD_MOVEBOXES;           // plural form
}


CCmdMoveBoxes::CCmdMoveBoxes(CSize sizOffset)
    : m_lstBoxes(FALSE)		// don't want the boxes deleted with the command
    , m_sizOffset(sizOffset) {

}


void CCmdMoveBoxes::Do(CBoxNetDoc *pdoc) {

    // make a list of pointers to boxes that will be moved
    pdoc->GetBoxSelection(&m_lstBoxes);

    // move the boxes and update all views
    pdoc->MoveBoxSelection(m_sizOffset);
}


void CCmdMoveBoxes::Undo(CBoxNetDoc *pdoc) {

    // restore the original selection
    pdoc->SetBoxSelection(&m_lstBoxes);

    // move the boxes back to where they were and update all views
    pdoc->MoveBoxSelection(NegateSize(m_sizOffset));
}


void CCmdMoveBoxes::Redo(CBoxNetDoc *pdoc) {

    // restore the original selection
    pdoc->SetBoxSelection(&m_lstBoxes);

    // move the boxes and update all views
    pdoc->MoveBoxSelection(m_sizOffset);
}


CCmd * CCmdMoveBoxes::Repeat(CBoxNetDoc *pdoc) {

    return new CCmdMoveBoxes(m_sizOffset);
}


BOOL CCmdMoveBoxes::CanRepeat(CBoxNetDoc *pdoc) {

    return CanDo(pdoc);
}


CCmdMoveBoxes::~CCmdMoveBoxes() {

    TRACE("~CCmdMoveBoxes (%d,%d)\n", m_sizOffset.cx, m_sizOffset.cy);
}


//
// --- CCmdConnect ---
//
// Connect the two sockets. Construct the link with the arrow
// in the correct sense (connections always are output->input)
//
// If we connect intelligently the graph & doc will be updated, so
// we must delete this link.


//
// Constructor
//
// Construct the link with the correct direction sense
CCmdConnect::CCmdConnect(CBoxSocket *psock1, CBoxSocket *psock2)
{

    PIN_DIRECTION dir = psock1->GetDirection();

    if (dir == PINDIR_OUTPUT) {
        ASSERT((psock2->GetDirection()) == PINDIR_INPUT);

        m_plink = new CBoxLink(psock1, psock2);
    }
    else {
        ASSERT((psock1->GetDirection()) == PINDIR_INPUT);
        ASSERT((psock2->GetDirection()) == PINDIR_OUTPUT);

        m_plink = new CBoxLink(psock2, psock1);
    }
}


//
// Do
//
void CCmdConnect::Do(CBoxNetDoc *pdoc) {

    pdoc->BeginWaitCursor();

    // m_plink is our pointer to a _temporary_ link. Connect calls
    // DirectConnect and IntelligentConnect which, if sucessful, call
    // UpdateFilter. This calls GetLinksInGraph which will create
    // the permanent link
    HRESULT hr = m_plink->Connect();

    // We need to null these values out to avoid the link's destructor
    // nulling the connecting filters' pointers to the permanent link
    m_plink->m_psockHead = NULL;
    m_plink->m_psockTail = NULL;

    // And remove the temporary link
    delete m_plink;
    m_plink = NULL;

    if (FAILED(hr)) {

        DisplayQuartzError( IDS_CANTCONNECT, hr );

        // update all views, as link will dissapear
        pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);

    }

    pdoc->EndWaitCursor();

}


//
// --- DisconnectAll ---
//
// Remove all connections from this graph


//
// Constructor
//
CCmdDisconnectAll::CCmdDisconnectAll()
{}


//
// Destructor
//
CCmdDisconnectAll::~CCmdDisconnectAll() {
    TRACE("~CCmdDisconnectAll() m_fRedo=%d\n", m_fRedo);
}


//
// CanDo
//
// This is only possible if there are links and we are stopped.
BOOL CCmdDisconnectAll::CanDo(CBoxNetDoc *pdoc) {

    return (  (pdoc->m_lstLinks.GetCount() > 0)
            && (pdoc->IsStopped())
           );
}


//
// Do
//
// Remove all the links from the document
void CCmdDisconnectAll::Do(CBoxNetDoc *pdoc) {

    ASSERT(pdoc->IsStopped());

    while (pdoc->m_lstLinks.GetCount() > 0) {
        CBoxLink *plink = pdoc->m_lstLinks.RemoveHead();
        plink->Disconnect();
        delete plink;
    }

    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);
}


//
// Redo
//
void CCmdDisconnectAll::Redo(CBoxNetDoc *pdoc) {
    Do(pdoc);
}


//
// --- CmdRender ---
//
// render this pin. Add whatever the filtergraph decides it needs to the document


//
// CanDo
//
BOOL CCmdRender::CanDo(CBoxNetDoc *pdoc) {

    return (   (pdoc->SelectedSocket()->GetDirection() == PINDIR_OUTPUT)
    	    && !(pdoc->SelectedSocket()->IsConnected())
            && (pdoc->IsStopped())
	   );
}


//
// Do
//
void CCmdRender::Do(CBoxNetDoc *pdoc) {

    pdoc->BeginWaitCursor();

    CBoxSocket *psock = pdoc->SelectedSocket();

    HRESULT hr = pdoc->IGraph()->Render(psock->pIPin());

    if (FAILED(hr)) {
        DisplayQuartzError( IDS_CANT_RENDER, hr );
    	pdoc->RestoreWaitCursor();
    }
    else {
        pdoc->UpdateFilters();
    }

    pdoc->EndWaitCursor();
}

//
// --- CCmdRenderFile ---
//
// Construct the graph to render this file

//
// Do
//
void CCmdRenderFile::Do(CBoxNetDoc *pdoc) {


    pdoc->BeginWaitCursor();

    HRESULT hr = pdoc->IGraph()->RenderFile( CMultiByteStr(m_FileName), NULL);
                                              // use default play list
    if (FAILED(hr)) {
        pdoc->EndWaitCursor();

        DisplayQuartzError( IDS_CANT_RENDER_FILE, hr );
        return;
    } else if( hr != NOERROR )
        DisplayQuartzError( hr );

    pdoc->UpdateFilters();

    pdoc->EndWaitCursor();
}

/******************************************************************************

CCmdAddFilterToCache

    This command adds a filter to the filter cache.  For more information on
the filter cache, see the IGraphConfig documentation in the Direct Show SDK.

******************************************************************************/
unsigned CCmdAddFilterToCache::GetLabel()
{
    return IDS_CMD_ADD_FILTER_TO_CACHE;
}

BOOL CCmdAddFilterToCache::CanDo( CBoxNetDoc *pdoc )
{
    return !pdoc->IsBoxSelectionEmpty();
}

void CCmdAddFilterToCache::Do( CBoxNetDoc *pdoc )
{
    CBox *pCurrentBox;

    IGraphConfig* pGraphConfig;

    HRESULT hr = pdoc->IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }

    POSITION posNext = pdoc->m_lstBoxes.GetHeadPosition();
    POSITION posCurrent;

    while( posNext != NULL ) {
        posCurrent = posNext;
        pCurrentBox = pdoc->m_lstBoxes.GetNext( posNext );

        if( pCurrentBox->IsSelected() ) {
            hr = pGraphConfig->AddFilterToCache( pCurrentBox->pIFilter() );
            if( FAILED( hr ) ) {
                DisplayQuartzError( hr );
            }
        }
    }

    pdoc->UpdateFilters();

    pGraphConfig->Release();
}

/******************************************************************************

CCmdReconnect

    This command reconnects an output pin.  It works even if the filter graph
is running or paused.

******************************************************************************/
unsigned CCmdReconnect::GetLabel()
{
    return IDS_CMD_RECONNECT;
}

BOOL CCmdReconnect::CanDo( CBoxNetDoc* pDoc )
{
    if( pDoc->AsyncReconnectInProgress() ) {
        return FALSE;
    }

    CBoxSocket* pSelectedSocket = pDoc->SelectedSocket();
    if( NULL == pSelectedSocket ) {
        return FALSE;
    }

    if( pSelectedSocket->GetDirection() != PINDIR_OUTPUT ) {
        return FALSE;
    }

    if( !pSelectedSocket->IsConnected() ) {
        return FALSE;
    }

    CComPtr<IGraphConfig> pGraphConfig;

    HRESULT hr = pDoc->IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return FALSE;
    }

    IPin* pSelectedPin = pSelectedSocket->pIPin();
    CComPtr<IPinFlowControl> pOutputPin;
    
    hr = pSelectedPin->QueryInterface( IID_IPinFlowControl, (void**)&pOutputPin );
    if( FAILED( hr ) ) {
        return FALSE;
    }

    return TRUE;
}

void CCmdReconnect::Do( CBoxNetDoc* pDoc )
{
    pDoc->BeginWaitCursor();    

    CBoxSocket* pSelectedSocket = pDoc->SelectedSocket();
    if( NULL == pSelectedSocket ) {
        pDoc->EndWaitCursor();
        DisplayQuartzError( E_POINTER );  // TBD - Define GE_E_SELECTED_SOCKET_DOES_NOT_EXIST.
        return;
    }

    IPin* pSelectedPin = pSelectedSocket->pIPin();

    // A socket should always be assocaited with a valid pin.
    ASSERT( NULL != pSelectedPin );    

    HRESULT hr = pDoc->StartReconnect( pDoc->IGraph(), pSelectedPin );
    if( GE_S_RECONNECT_PENDING == hr ) {
        // AfxMessageBox() returns 0 if an error occurs.
        if( 0 == AfxMessageBox( IDS_RECONNECT_PENDING ) ) {
            TRACE( TEXT("WARNING: CBoxNetDoc::StartReconnect() returned GE_S_RECONNECT_PENDING but the user could not be notified because AfxMessageBox() failed.") );
        }
    } else if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
    }

    pDoc->EndWaitCursor();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\enum.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// enum.cpp
//
// A set of wrappers for COM enumerators.

#include "stdafx.h"

// *
// * CFilterEnum
// *

//
// CFilterEnum::Constructor
//
CFilterEnum::CFilterEnum(IFilterGraph *pGraph) {

    ASSERT(pGraph);

    HRESULT hr = pGraph->EnumFilters(&m_pEnum);
    if (FAILED(hr))
        throw CHRESULTException(hr);

}


//
// CFilterEnum::Destructor
//
CFilterEnum::~CFilterEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
// Use to get next filter
// !!!Does this return AddRef()'d pointers?
IBaseFilter *CFilterEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    IBaseFilter	*aFilter[1];

    HRESULT hr = m_pEnum->Next(1, aFilter, &ulActual);
    if (SUCCEEDED(hr) && (ulActual == 0) )	// no more filters
        return NULL;
    else if (FAILED(hr) || (ulActual != 1) )	// some unexpected problem occured
        throw CE_FAIL();

    return aFilter[0];
}


// *
// * CPinEnum
// *

// Enumerates a filters pins.

//
// Constructor
//
// Set the type of pins to provide - PINDIR_INPUT, PINDIR_OUTPUT or all
CPinEnum::CPinEnum(IBaseFilter *pFilter, DirType Type)
    : m_Type(Type) {

    if (Type == Input) {

        m_EnumDir = ::PINDIR_INPUT;
    }
    else if (Type == Output) {

        m_EnumDir = ::PINDIR_OUTPUT;
    }

    ASSERT(pFilter);

    HRESULT hr = pFilter->EnumPins(&m_pEnum);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }
}


//
// CPinEnum::Destructor
//
CPinEnum::~CPinEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
// return the next pin, of the requested type. return NULL if no more pins.
IPin *CPinEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    IPin	*aPin[1];
    PIN_DIRECTION pd;

    for (;;) {

        HRESULT hr = m_pEnum->Next(1, aPin, &ulActual);
        if (SUCCEEDED(hr) && (ulActual == 0) ) {	// no more filters
            return NULL;
        }
        else if (FAILED(hr) || (ulActual != 1) ) {	// some unexpected problem occured
            throw CE_FAIL();
        }

        hr = aPin[0]->QueryDirection(&pd);
        if (FAILED(hr)) {
	    aPin[0]->Release();
            throw CHRESULTException(hr);
        }

        // if m_Type == All return the first pin we find
        // otherwise return the first of the correct sense

        if (m_Type == All || pd == m_EnumDir) {
            return aPin[0];
        } else {
            aPin[0]->Release();
        }
    }
}


// *
// * CRegFilterEnum
// *

//
// Constructor
//
// Query the supplied mapper for an enumerator for the
// requested filters.
CRegFilterEnum::CRegFilterEnum(IFilterMapper	*pMapper,
                   		DWORD	dwMerit,		// See IFilterMapper->EnumMatchingFilters
                   		BOOL	bInputNeeded,	// for the meanings of these parameters.
                   		CLSID	clsInMaj,	// the defaults will give you all
                   		CLSID	clsInSub,	// filters
                   		BOOL	bRender,
                   		BOOL	bOutputNeeded,
                   		CLSID	clsOutMaj,
                   		CLSID	clsOutSub) {

    HRESULT hr = pMapper->EnumMatchingFilters(&m_pEnum,
                                              dwMerit,
                                              bInputNeeded,
                                              clsInMaj,
                                              clsInSub,
                                              bRender,
                                              bOutputNeeded,
                                              clsOutMaj,
                                              clsOutSub);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }
}


//
// Destructor
//
CRegFilterEnum::~CRegFilterEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
CRegFilter *CRegFilterEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    REGFILTER	*arf[1];

    HRESULT hr = m_pEnum->Next(1, arf, &ulActual);
    if (SUCCEEDED(hr) && (ulActual == 0)) {
        return NULL;
    }
    else if (FAILED(hr) || (ulActual != 1)) {
        throw CE_FAIL();
    }

    // transfer from TaskMem to 'new' mem

    CRegFilter *prf = new CRegFilter(arf[0]);
    if (prf == NULL) {
        throw CE_OUTOFMEMORY();
    }

    CoTaskMemFree(arf[0]);

    return prf;
}


// *
// * CRegFilter
// *


//
// Constructor
//
CRegFilter::CRegFilter(REGFILTER *prf)
    : m_Name(prf->Name),
      m_clsid(prf->Clsid) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\congraph.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// congraph.h

#ifndef __CONN_GRAPH__
#define __CONN_GRAPH__

class CConGraph : public CDialog
{
public:
    ~CConGraph();
    CConGraph(IMoniker **ppmk, IRunningObjectTable *pirot, CWnd * pParent = NULL );

protected:

    BOOL OnInitDialog();
    void OnDestroy();
    void DoDataExchange(CDataExchange* pDX);

    void ClearList();
    void OnRefreshList();

    virtual void OnOK();


    DECLARE_MESSAGE_MAP()

private:
    CListBox m_ListBox;

    IMoniker **m_ppmk;
    IRunningObjectTable *m_pirot;
};

#endif // __CONN_GRAPH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\congraph.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "congraph.h"

BEGIN_MESSAGE_MAP(CConGraph, CDialog)
    ON_COMMAND(IDC_Refresh, OnRefreshList)
    ON_WM_DESTROY()
END_MESSAGE_MAP()

//
// Constructor
//
CConGraph::CConGraph(IMoniker **ppmk, IRunningObjectTable *pirot, CWnd * pParent):
    CDialog(IDD_CONNECTTOGRAPH, pParent)
{
    m_ppmk = ppmk;
    *ppmk = 0;
    m_pirot = pirot;
}

CConGraph::~CConGraph()
{
}

void CConGraph::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFontPropPage)
        DDX_Control(pDX, IDC_LIST1, m_ListBox);
    //}}AFX_DATA_MAP
}

void CConGraph::ClearList()
{
    int i = m_ListBox.GetCount();
    while (i--) {
        IMoniker *pmkr = (IMoniker *) m_ListBox.GetItemData(i);

        pmkr->Release();
    }

    m_ListBox.ResetContent();
}

void CConGraph::OnRefreshList()
{
    ClearList();

    LPBINDCTX lpbc;

    CreateBindCtx(0, &lpbc);

    IEnumMoniker *pEnum;
    if (SUCCEEDED(m_pirot->EnumRunning(&pEnum))) {
        while (1) {
            IMoniker *pmkr;
            DWORD dwFetched = 0;
            pEnum->Next(1,&pmkr,&dwFetched);
            if (dwFetched != 1) {
                break;
            }

            // !!! need a bind context?
            WCHAR *lpwszName;
            if (SUCCEEDED(pmkr->GetDisplayName(lpbc, NULL, &lpwszName))) {
                TCHAR szName[MAX_PATH];
                WideCharToMultiByte(CP_ACP, 0, lpwszName, -1,
                                    szName, sizeof(szName), 0, 0);
                CoTaskMemFree(lpwszName);

//                if (0 == strncmp(szTestString, szName, lstrlenA(szTestString))) {
                    // !!! need to make sure we're not looking at GraphEdit's graph!

                DWORD dw, dwPID;
                if (2 == sscanf(szName, "!FilterGraph %x  pid %x", &dw, &dwPID) && dwPID != GetCurrentProcessId()) {
                    wsprintf(szName, "pid 0x%x (%d)  IFilterGraph = %08x", dwPID, dwPID, dw);
                    int item = m_ListBox.AddString(szName);
                    m_ListBox.SetItemData(item, (DWORD_PTR) pmkr);
                    pmkr->AddRef();  // hold moniker for later
                }
            }
            pmkr->Release();
        }
        pEnum->Release();
    }
    lpbc->Release();
}

void CConGraph::OnDestroy()
{
    ClearList();
}
BOOL CConGraph::OnInitDialog()
{
    CDialog::OnInitDialog();

    OnRefreshList();

    m_ListBox.SetFocus();

    return(0); // we set the focus our selves
}

void CConGraph::OnOK()
{
    // get the string in the edit box
    int curSel = m_ListBox.GetCurSel();

    if (curSel != LB_ERR) {
        *m_ppmk = (IMoniker *) m_ListBox.GetItemData(curSel);
        (*m_ppmk)->AddRef();
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\dcf.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <streams.h>
#include "DCF.h"
#include "FLB.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CDisplayCachedFilters, CDialog)
	//{{AFX_MSG_MAP(CDisplayCachedFilters)
	ON_LBN_ERRSPACE(IDC_CACHED_FILTERS, OnErrSpaceCachedFilters)
	ON_BN_CLICKED(ID_REMOVE_FILTER, OnRemoveFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDisplayCachedFilters::CDisplayCachedFilters
    (
    IGraphConfig* pFilterCache,
    HRESULT* phr,
    CWnd* pParent /*=NULL*/
    )
	: CDialog(CDisplayCachedFilters::IDD, pParent),
    m_pFilterCache(NULL),
    m_plbCachedFiltersList(NULL)
{
	//{{AFX_DATA_INIT(CDisplayCachedFilters)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    // This dialog box will not work correctly if a NULL pointer is passed in.
    ASSERT( NULL != pFilterCache );

    try
    {   
        m_plbCachedFiltersList = new CFilterListBox( phr );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        m_plbCachedFiltersList = NULL;

        pOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }  
 
    if( FAILED( *phr ) )
    {
        delete m_plbCachedFiltersList;
        m_plbCachedFiltersList = NULL;
        return;
    }

    m_pFilterCache = pFilterCache;
    m_pFilterCache->AddRef();
}

CDisplayCachedFilters::~CDisplayCachedFilters()
{
    delete m_plbCachedFiltersList;
    if( NULL != m_pFilterCache )
    {
        m_pFilterCache->Release();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayCachedFilters message handlers

void CDisplayCachedFilters::OnErrSpaceCachedFilters() 
{
    DisplayQuartzError( E_OUTOFMEMORY );

    EndDialog( IDABORT );
}

BOOL CDisplayCachedFilters::OnInitDialog() 
{
    CDialog::OnInitDialog();

    HRESULT hr = AddCachedFilterNamesToListBox();
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        EndDialog( IDABORT );
        return TRUE;
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDisplayCachedFilters::DoDataExchange(CDataExchange* pDX) 
{
    // This function exepects m_plbCachedFiltersList to be allocated.
    ASSERT( NULL != m_plbCachedFiltersList );

	CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDisplayCachedFilters)
	DDX_Control(pDX, IDC_CACHED_FILTERS, *m_plbCachedFiltersList);
	//}}AFX_DATA_MAP
}

void CDisplayCachedFilters::OnRemoveFilter() 
{
    IBaseFilter* pSelectedFilter;

    HRESULT hr = m_plbCachedFiltersList->GetSelectedFilter( &pSelectedFilter );
    if( FAILED( hr ) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    }

    hr = m_plbCachedFiltersList->RemoveSelectedFilter();
    if( FAILED( hr ) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    } 

    hr = m_pFilterCache->RemoveFilterFromCache( pSelectedFilter );
    if( FAILED( hr ) || (S_FALSE == hr) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    }
    pSelectedFilter->Release(); // Release the filter cache's reference.    
}

HRESULT CDisplayCachedFilters::AddCachedFilterNamesToListBox( void )
{
    HRESULT hr;
    
    IBaseFilter* pCurrentFilter;
    IEnumFilters* pFilterCacheEnum;
    
    hr = m_pFilterCache->EnumCacheFilter( &pFilterCacheEnum );
    if( FAILED( hr ) ) {
        return hr;
    }

    HRESULT hrEnum;

    do
    {
        hrEnum = pFilterCacheEnum->Next( 1, &pCurrentFilter, NULL );
        if( FAILED( hrEnum ) ) {
            pFilterCacheEnum->Release();
            return hrEnum;
        }
        
        if( S_OK == hrEnum ) {
            // This is a sanity check used to makesure the filter cache
            // is in a valid state.
            ASSERT( S_OK == IsCached( m_pFilterCache, pCurrentFilter ) );

            hr = m_plbCachedFiltersList->AddFilter( pCurrentFilter );
    
            pCurrentFilter->Release();
            pCurrentFilter = NULL;

            if( FAILED( hr ) )
            {
                pFilterCacheEnum->Release();
                return hr;
            }
        }
    } while( S_OK == hrEnum );

    pFilterCacheEnum->Release();

    return S_OK;
}

#ifdef _DEBUG
HRESULT CDisplayCachedFilters::IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter )
{
    // This function does not handle NULL parameters.
    ASSERT( (NULL != pFilterCache) && (NULL != pFilter) );

    bool fFoundFilterInCache;
    IBaseFilter* pCurrentFilter;
    IEnumFilters* pCachedFiltersEnum;

    #ifdef _DEBUG
    DWORD dwNumFiltersCompared = 0;
    #endif // _DEBUG

    HRESULT hr = pFilterCache->EnumCacheFilter( &pCachedFiltersEnum );
    if( FAILED( hr ) ) {
        return hr;   
    }

    fFoundFilterInCache = false;

    do
    {
        hr = pCachedFiltersEnum->Next( 1, &pCurrentFilter, NULL );
        switch( hr )
        {
        case S_OK:
            if( ::IsEqualObject( pCurrentFilter, pFilter ) ) {
                fFoundFilterInCache = true;
            } else {
                fFoundFilterInCache = false;
            }
            
            #ifdef _DEBUG
            {
                dwNumFiltersCompared++;

                HRESULT hrDebug = TestTheFilterCachesIEnumFiltersInterface( pCachedFiltersEnum, pCurrentFilter, dwNumFiltersCompared );
    
                // Since this code in TestTheFilterCachesIEnumFiltersInterface() is only used to debug
                // the system, it does not affect the operation of this function.  Therefore, all failures
                // can be safely ignored (however, they SHOULD be investigated.
                ASSERT( SUCCEEDED( hrDebug ) || (VFW_E_ENUM_OUT_OF_SYNC == hrDebug) );
            }
            #endif // _DEBUG

            pCurrentFilter->Release();

            break;

        case S_FALSE:
            break;

        case VFW_E_ENUM_OUT_OF_SYNC:
            hr = pCachedFiltersEnum->Reset();

            #ifdef _DEBUG
            dwNumFiltersCompared = 0;
            #endif // _DEBUG

            break;

        default:
            // IEnumXXXX interface can only return two success codes,
            // S_OK and S_FALSE.
            ASSERT( FAILED( hr ) );
        }
            
    } while( SUCCEEDED( hr ) && (hr != S_FALSE) && !fFoundFilterInCache );

    pCachedFiltersEnum->Release();

    if( FAILED( hr ) ) {
        return hr;
    }
    
    if( fFoundFilterInCache ) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

HRESULT CDisplayCachedFilters::TestTheFilterCachesIEnumFiltersInterface( IEnumFilters* pCachedFiltersEnum, IBaseFilter* pCurrentFilter, DWORD dwNumFiltersExamended )
{
    IEnumFilters* pCloanedCachedFiltersEnum = NULL;
    IEnumFilters* pAnotherCloanedCachedFiltersEnum = NULL;
    IEnumFilters* pQueriedCachedFiltersInterface = NULL;

    HRESULT hr = pCachedFiltersEnum->QueryInterface( IID_IEnumFilters, (void**)&pQueriedCachedFiltersInterface );
    if( FAILED( hr ) )
    {
        return hr;
    }

    pQueriedCachedFiltersInterface->Release();
    pQueriedCachedFiltersInterface = NULL;

    hr = pCachedFiltersEnum->Clone( &pCloanedCachedFiltersEnum );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = pCloanedCachedFiltersEnum->Clone( &pAnotherCloanedCachedFiltersEnum );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        return hr;
    }    

    hr = pCloanedCachedFiltersEnum->Reset();
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }    

    if( (dwNumFiltersExamended - 1) > 0 )
    {
        hr = pCloanedCachedFiltersEnum->Skip( dwNumFiltersExamended - 1 );
        if( FAILED( hr ) )
        {
            pCloanedCachedFiltersEnum->Release();
            pAnotherCloanedCachedFiltersEnum->Release();
            return hr;
        }
    }

    DWORD dwNumFiltersRetrieved;
    IBaseFilter* aCurrentFilter[1];

    hr = pCloanedCachedFiltersEnum->Next( 1, aCurrentFilter, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should not be S_FALSE because the cache contains at least
    // dwNumFiltersExamended filtes.
    ASSERT( S_FALSE != hr );

    // IEnumFilters::Next() should return exactly one filter because 
    // that is all we asked for.
    ASSERT( 1 == dwNumFiltersRetrieved );    

    // The preceding code should get the same filter as the current filter.    
    ASSERT( ::IsEqualObject( pCurrentFilter, aCurrentFilter[0] ) );

    aCurrentFilter[0]->Release();
    aCurrentFilter[0] = NULL;

    const DWORD HUGE_NUMBER = 0x7FFFFFFF;

    hr = pCloanedCachedFiltersEnum->Skip( HUGE_NUMBER );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should be S_FALSE because the usually does not contain
    // HUGE_NUMBER of filters.  Ignore this ASSERT if you have at least
    // HUGE_NUMBER + dwNumFiltersExamended of filters in the cache.
    ASSERT( S_FALSE == hr );

    hr = pCloanedCachedFiltersEnum->Reset();
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }  

    IBaseFilter** ppCachedFilters;

    try
    {
        ppCachedFilters = new IBaseFilter*[dwNumFiltersExamended];
    }
    catch( CMemoryException* peOutOfMemory )
    {
        peOutOfMemory->Delete();

        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return E_OUTOFMEMORY;
    }

    hr = pCloanedCachedFiltersEnum->Next( dwNumFiltersExamended, ppCachedFilters, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        delete [] ppCachedFilters;
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should not be S_FALSE because the cache contains at least
    // dwNumFiltersExamended filtes.
    ASSERT( S_FALSE != hr );

    // IEnumFilters::Next() should return exactly dwNumFiltersExamended filters because 
    // that is all we asked for.
    ASSERT( dwNumFiltersExamended == dwNumFiltersRetrieved );
    
    // The last filter in the array should be the same as the current filter.
    ASSERT( ::IsEqualObject( pCurrentFilter, ppCachedFilters[dwNumFiltersExamended-1] ) );

    for( DWORD dwCurrentFilter = 0; dwCurrentFilter < dwNumFiltersRetrieved; dwCurrentFilter++ )
    {
        ppCachedFilters[dwCurrentFilter]->Release();
        ppCachedFilters[dwCurrentFilter] = NULL;
    }

    delete [] ppCachedFilters;
    ppCachedFilters = NULL;

    hr = pCloanedCachedFiltersEnum->Next( 1, aCurrentFilter, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    DWORD dwAnotherNumFiltersRetrieved;
    IBaseFilter* aAnotherCurrentFilter[1];
    aAnotherCurrentFilter[0] = NULL;

    HRESULT hrAnother = pAnotherCloanedCachedFiltersEnum->Next( 1, aAnotherCurrentFilter, &dwAnotherNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        aCurrentFilter[0]->Release();
        return hr;
    }

    pCloanedCachedFiltersEnum->Release();
    pAnotherCloanedCachedFiltersEnum->Release();

    // Ensure the returned values are legal.
    ASSERT( (1 == dwAnotherNumFiltersRetrieved) || (0 == dwAnotherNumFiltersRetrieved) );
    ASSERT( (1 == dwNumFiltersRetrieved) || (0 == dwNumFiltersRetrieved) );
    ASSERT( ((hr == S_OK) && (1 == dwNumFiltersRetrieved)) ||
            ((hr == S_FALSE) && (0 == dwNumFiltersRetrieved)) );
    ASSERT( ((hrAnother == S_OK) && (1 == dwAnotherNumFiltersRetrieved)) ||
            ((hrAnother == S_FALSE) && (0 == dwAnotherNumFiltersRetrieved)) );

    // Since both enums should be in the exact same state, then every thing should be
    // equal.    
    ASSERT( hr == hrAnother );
    ASSERT( dwNumFiltersRetrieved == dwAnotherNumFiltersRetrieved );

    if( (1 == dwNumFiltersRetrieved) && (1 == dwAnotherNumFiltersRetrieved) )
    {
        ASSERT( ::IsEqualObject( aCurrentFilter[0], aAnotherCurrentFilter[0] ) );
    }

    if( S_OK == hr )
    {
        aCurrentFilter[0]->Release();
    }

    if( S_OK == hr )
    {
        aAnotherCurrentFilter[0]->Release();
    }

    return S_OK;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\dcf.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if !defined(AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_)
#define AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CDisplayCachedFilters dialog

#define DCF_OUT_OF_MEMORY       -1;

class CFilterListBox;

class CDisplayCachedFilters : public CDialog
{
// Construction
public:
    CDisplayCachedFilters::CDisplayCachedFilters
        (
        IGraphConfig* pFilterCache,
        HRESULT* phr,
        CWnd* pParent = NULL
        );
    ~CDisplayCachedFilters();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDisplayCachedFilters)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CDisplayCachedFilters)
    virtual BOOL OnInitDialog();
    virtual void OnErrSpaceCachedFilters();
    afx_msg void OnRemoveFilter();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    HRESULT AddCachedFilterNamesToListBox( void );

    #ifdef _DEBUG
    static HRESULT IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter );
    static HRESULT TestTheFilterCachesIEnumFiltersInterface( IEnumFilters* pCachedFiltersEnum, IBaseFilter* pCurrentFilter, DWORD dwNumFiltersExamended );
    #endif // _DEBUG

    IGraphConfig* m_pFilterCache;
    CFilterListBox* m_plbCachedFiltersList;

// Dialog Data
    //{{AFX_DATA(CDisplayCachedFilters)
    enum { IDD = IDD_CACHED_FILTERS };
    //}}AFX_DATA
};

#endif // !defined(AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\enum.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// Filter enumerator
//

// Rather than throwing exceptions I could make the class fail silently...
class CFilterEnum {

public:

    CFilterEnum(IFilterGraph *pGraph);
    ~CFilterEnum();

    // returns the next filter, or NULL if there are no more.
    IBaseFilter * operator() (void);

private:

    IEnumFilters	*m_pEnum;
};


//
// Pin Enumerator.
//
// Can enumerate all pins, or just one direction (input or output)
class CPinEnum {

public:

    enum DirType {Input, Output, All};

    CPinEnum(IBaseFilter *pFilter, DirType Type = All);
    ~CPinEnum();

    // the returned interface is addref'd
    IPin *operator() (void);

private:

    PIN_DIRECTION m_EnumDir;
    DirType	m_Type;

    IEnumPins	*m_pEnum;
};


//
// CRegFilter
//
// The object you are passed back from operator() in
// CRegFilterEnum
class CRegFilter {
public:

    CRegFilter(REGFILTER *);	// copies what it needs from the
    				// supplied regfilter *


    CString Name(void) { return m_Name; }
    CLSID   Clsid(void) { return m_clsid; }

private:

    CString m_Name;
    CLSID   m_clsid;
};


//
// CRegFilterEnum
//
// Enumerates registered filters supplied by the mapper
class CRegFilterEnum {
public:

    CRegFilterEnum(IFilterMapper	*pMapper,
                   DWORD	dwMerit		= 0,		// See IFilterMapper->EnumMatchingFilters
                   BOOL		bInputNeeded	= FALSE,	// for the meanings of these parameters.
                   CLSID	clsInMaj	= CLSID_NULL,	// the defaults will give you all
                   CLSID	clsInSub	= CLSID_NULL,	// filters
                   BOOL		bRender		= FALSE,
                   BOOL		bOututNeeded	= FALSE,
                   CLSID	clsOutMaj	= CLSID_NULL,
                   CLSID	clsOutSub	= CLSID_NULL);
    ~CRegFilterEnum();

    // returns a pointer to a regfilter, that the caller
    // is responsible for freeing with delete
    CRegFilter *operator() (void);

private:

    IEnumRegFilters *m_pEnum;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\filtervw.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
class CFilterView : public CDialog
{
public:
    static void DelFilterView();
    static CFilterView * GetFilterView(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );

protected:
    ~CFilterView();
    CFilterView(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );


    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );

    afx_msg void OnInsert();
#ifdef FILTER_FAVORITES
    afx_msg void OnAddToFav();
#endif
    afx_msg void OnItemExpanding(NMHDR* pnmh, LRESULT* pResult);
#ifdef COLORCODED_FILTERS
    afx_msg void OnCustomDraw(NMHDR* pnmh, LRESULT* pResult);
#endif
    
    BOOL OnInitDialog();
    void RedoList();
    void DoOneCategory(
        const TCHAR *szCatDesc,
        HWND hWndTree,
        const GUID *pCatGuid,
        ICreateDevEnum *pCreateDevEnum);
    
    int m_iIcon;

    // can't get count without enumerating everything. so use list.
    CDeleteList<CQCOMInt<IMoniker>*, CQCOMInt<IMoniker>* > m_lMoniker;

    CBoxNetDoc * m_pBoxNet;
    HIMAGELIST m_hImgList;

    static CFilterView * m_pThis;
    static WNDPROC m_pfnOldDialogProc;
    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);

    BOOL m_bHadInitDialog;         // Received OnInitDialog message?
    CSize m_LastDialogSize;        // Last known size of our dialog box
    CSize m_MinDialogSize;         // Minimum size of the dialog box

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\flb.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if !defined(AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_)
#define AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// This error is returned if no filters are currently selected in the list box.
//#define GE_E_NO_FILTERS_ARE_SELECTED        MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0xFFFF )

class CFilterNameDictionary;

class CFilterListBox : public CListBox
{
public:
    CFilterListBox( HRESULT* phr );
    ~CFilterListBox();

    HRESULT AddFilter( IBaseFilter* pFilter );
    HRESULT GetSelectedFilter( IBaseFilter** ppSelectedFilter );
    HRESULT RemoveSelectedFilter( void );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFilterListBox)
    //}}AFX_VIRTUAL

private:
    HRESULT GetSelectedFilter( IBaseFilter** ppSelectedFilter, int* pnSelectedFilterIndex );

    CFilterNameDictionary* m_pfndFilterDictionary;
    CList<IBaseFilter*, IBaseFilter*>* m_pListedFilters;

    //{{AFX_MSG(CFilterListBox)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

#endif // !defined(AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\filtervw.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// Dialog to display all filters
//

#include "stdafx.h"
#include "filtervw.h"

#define SHOWTYPES 1
#ifdef SHOWTYPES

#include <malloc.h>
#include <assert.h>
#include <streams.h>
#include <aviriff.h>
#ifdef COLORCODED_FILTERS
#include <dmodshow.h>
#endif
#endif
#include <initguid.h>
#include <dmoreg.h>

BEGIN_MESSAGE_MAP(CFilterView, CDialog)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_FILTER_TREE, OnItemExpanding)
#ifdef COLORCODED_FILTERS
    ON_NOTIFY(NM_CUSTOMDRAW, IDC_FILTER_TREE, OnCustomDraw)
#endif
    ON_COMMAND(ID_ADDFILTER, OnInsert)
#ifdef FILTER_FAVORITES
    ON_COMMAND(ID_ADDTOFAV, OnAddToFav)
#endif
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
END_MESSAGE_MAP()

CFilterView* CFilterView::m_pThis = 0;
WNDPROC CFilterView::m_pfnOldDialogProc;

// list of categories in registry ActiveMovie might care about
static const TCHAR szRegCategoryPath[] = "ActiveMovie Filter Categories";

struct _EXTRA_CATEGORY {
    const GUID  * pclsid;
    const TCHAR * pszCat;
};

//
// Extra categories that we'd like to enumerate from GraphEdt...
//
// Please use this for categories that you'd like to see in GraphEdt but that don't
// need to be enumerated for default runtime graph building.
//
static const _EXTRA_CATEGORY g_AppEnumeratedCategories[] = 
{
        { &DMOCATEGORY_AUDIO_EFFECT,         TEXT("DMO Audio Effects") },
        { &DMOCATEGORY_AUDIO_CAPTURE_EFFECT, TEXT("DMO Audio Capture Effects") },
        { &DMOCATEGORY_VIDEO_EFFECT,         TEXT("DMO Video Effects") },
        // NULL entry needed to flag end
        { NULL,                              TEXT("") }
};


//
// Constructor
//
CFilterView::CFilterView(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)

 :
   m_pBoxNet(pBoxNet)
 , m_hImgList(NULL)
 , m_bHadInitDialog( FALSE )
{
    //
    // There can only be one filter view dialog at a time. Thus
    // the initialisation in the constructor is ok (even desired).
    //
    ASSERT( m_pThis == 0 );
    m_pThis = this;
    m_pfnOldDialogProc = NULL;
    Create(IDD_FILTER_VIEW, pParent);
    ShowWindow( SW_SHOW );
}

CFilterView::~CFilterView()
{
    // Windows will automatically delete m_hImgList when the dialog
    // box is destroyed.
    m_pThis = 0;
}

CFilterView * CFilterView::GetFilterView(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)
{
    if (!m_pThis)
    {
        m_pThis = new CFilterView(pBoxNet, pParent);
    }
    else
    {
    	if (pBoxNet->m_fRegistryChanged) {
    	    pBoxNet->m_fRegistryChanged = FALSE;
    	    m_pThis->RedoList();
	}
        m_pThis->ShowWindow( SW_RESTORE );
    }
    return m_pThis;

}

void CFilterView::DelFilterView()
{
    if (m_pThis)
    {
        CMDIFrameWnd *pMainFrame = (CMDIFrameWnd*)AfxGetApp()->m_pMainWnd;
        CMDIChildWnd *pMDIChildWnd = pMainFrame->MDIGetActive();
        
        if (pMDIChildWnd == NULL)
        {
            // No other MDI child windows
            delete m_pThis;
            m_pThis = 0;
        }
    }
}

static LONG
TreeView_GetSelectedItemData(HWND hwndTV)
{
    HTREEITEM       hItem;
    TV_ITEM         tvItem;

    if(!(hItem = TreeView_GetSelection(hwndTV)))
        return -1;

    tvItem.mask = TVIF_PARAM;
    tvItem.hItem = hItem;
    TreeView_GetItem(hwndTV, &tvItem);

    return (LONG) tvItem.lParam;
}

void CFilterView::OnInsert()
{
    BOOL fAnySuccess = FALSE;
    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);
    LONG iItem = TreeView_GetSelectedItemData(hWndTree);
    if(iItem >= 0)
    {
        POSITION pos = m_lMoniker.GetHeadPosition();
        while(pos != 0 && iItem-- > 0)
        {
            m_lMoniker.GetNext(pos);
        }
        if(pos)
        {

            IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd

            try {
                CBoxNetDoc *pDoc = NULL;
                CMDIFrameWnd *pMainFrame = (CMDIFrameWnd*)AfxGetApp()->m_pMainWnd;
                CMDIChildWnd *pMDIChildWnd = pMainFrame->MDIGetActive();

                if (pMDIChildWnd) {
                    pDoc = (CBoxNetDoc *) pMDIChildWnd->GetActiveDocument();
                }

                if (pDoc) {
                    pDoc->CmdDo(new CCmdAddFilter( pMon, pDoc));
                    fAnySuccess = TRUE;
                }
            }
            catch (CHRESULTException hre) {
                // Give accurate information on each failed insertion
                DisplayQuartzError( IDS_CANTCREATEFILTER, hre.Reason() );
            }
        }
    }

    //
    // Change the text of the IDCANCEL button to "close" if we added at
    // least one filter.
    //
    if (fAnySuccess) {
        CString stClose;
        stClose.LoadString(IDS_CLOSE);

        ::SetDlgItemText(m_hWnd, IDCANCEL, stClose);
    }
}

#ifdef FILTER_FAVORITES

extern const TCHAR *g_szRegFav;

HRESULT AddFavToReg(const TCHAR *szFilter, const TCHAR *szMonikerName)
{
    HKEY hk;
    LONG lResult = RegCreateKeyEx(
        HKEY_CURRENT_USER,
        g_szRegFav,
        0,                      // reserved
        0,                      // class string
        0,                      // options
        KEY_WRITE,
        0,                      // security
        &hk,
        0);                     // disposition
    if(lResult == ERROR_SUCCESS)
    {
        lResult = RegSetValueEx(
            hk,
            szFilter,
            0,                  // reserved
            REG_SZ,
            (BYTE *)szMonikerName,
            sizeof(TCHAR) * (lstrlen(szMonikerName) + 1));

        RegCloseKey(hk);
    }

    return S_OK;
}

void CFilterView::OnAddToFav()
{
    BOOL fAnySuccess = FALSE;
    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);
    LONG iItem = TreeView_GetSelectedItemData(hWndTree);
    if(iItem >= 0)
    {
        POSITION pos = m_lMoniker.GetHeadPosition();
        while(pos != 0 && iItem-- > 0)
        {
            m_lMoniker.GetNext(pos);
        }
        if(pos)
        {

            IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd

            WCHAR *wszDisplayName;
            HRESULT hr= pMon->GetDisplayName(0, 0, &wszDisplayName);
            if(SUCCEEDED(hr))
            {

                CComVariant var;

                IPropertyBag *pPropBag;
                hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    hr = pPropBag->Read(L"FriendlyName", &var, 0);
                    if(FAILED(hr )) {
                        printf("failed to get FriendlyName: %08x\n", hr);
                    }

                    pPropBag->Release();
                }

                if(SUCCEEDED(hr))
                {
                    CString szFilterName(var.bstrVal);
                    CString szDisplayName(wszDisplayName);

                    AddFavToReg(szFilterName, szDisplayName);
                }


                CoTaskMemFree(wszDisplayName);
            }


            if(FAILED(hr)) {
                DisplayQuartzError( IDS_CANTCREATEFILTER, CHRESULTException(hr).Reason() );
            }
        }
    }
}

#endif


BOOL CFilterView::OnInitDialog()
{
    BOOL fResult = CDialog::OnInitDialog();

    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);

    // Subclass the tree view so we can handle double clicks.
    m_pfnOldDialogProc = (WNDPROC)
        ::SetWindowLongPtr(hWndTree, GWLP_WNDPROC, (LONG_PTR) DialogProc);

    //
    // Create the image list for the list view
    //
    m_hImgList = ImageList_Create(
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        ILC_COLOR, 1, 1);

    ASSERT(m_hImgList);

    HICON hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_FILTER));
    m_iIcon = ImageList_AddIcon(m_hImgList, hIcon);

//     ::SendMessage(hWndTree, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM) m_hImgList);

    RedoList();

    return( fResult );
}

#ifdef SHOWTYPES

#define CNV_GUID(clsid) GuidToEnglish((clsid), (char *)_alloca(1024))

struct NamedGuid
{
    const GUID *pguid;
    const char *psz;
};

static const NamedGuid rgng[] =
{
    {&AMPROPSETID_Pin, "AMPROPSETID_Pin"},
    {&AM_INTERFACESETID_Standard, "AM_INTERFACESETID_Standard"},
    {&AM_KSCATEGORY_AUDIO, "AM_KSCATEGORY_AUDIO"},
    {&AM_KSCATEGORY_CAPTURE, "AM_KSCATEGORY_CAPTURE"},
    {&AM_KSCATEGORY_CROSSBAR, "AM_KSCATEGORY_CROSSBAR"},
    {&AM_KSCATEGORY_DATACOMPRESSOR, "AM_KSCATEGORY_DATACOMPRESSOR"},
    {&AM_KSCATEGORY_RENDER, "AM_KSCATEGORY_RENDER"},
    {&AM_KSCATEGORY_TVAUDIO, "AM_KSCATEGORY_TVAUDIO"},
    {&AM_KSCATEGORY_TVTUNER, "AM_KSCATEGORY_TVTUNER"},
    {&AM_KSCATEGORY_VIDEO, "AM_KSCATEGORY_VIDEO"},
    {&AM_KSPROPSETID_AC3, "AM_KSPROPSETID_AC3"},
    {&AM_KSPROPSETID_CopyProt, "AM_KSPROPSETID_CopyProt"},
    {&AM_KSPROPSETID_DvdSubPic, "AM_KSPROPSETID_DvdSubPic"},
    {&AM_KSPROPSETID_TSRateChange, "AM_KSPROPSETID_TSRateChange"},
    {&CLSID_ACMWrapper, "CLSID_ACMWrapper"},
    {&CLSID_AVICo, "CLSID_AVICo"},
    {&CLSID_AVIDec, "CLSID_AVIDec"},
    {&CLSID_AVIDoc, "CLSID_AVIDoc"},
    {&CLSID_AVIDraw, "CLSID_AVIDraw"},
    {&CLSID_AVIMIDIRender, "CLSID_AVIMIDIRender"},
    {&CLSID_ActiveMovieCategories, "CLSID_ActiveMovieCategories"},
    {&CLSID_AnalogVideoDecoderPropertyPage, "CLSID_AnalogVideoDecoderPropertyPage"},
    {&CLSID_WMAsfReader, "CLSID_WMAsfReader"},
    {&CLSID_WMAsfWriter, "CLSID_WMAsfWriter"},
    {&CLSID_AsyncReader, "CLSID_AsyncReader"},
    {&CLSID_AudioCompressorCategory, "CLSID_AudioCompressorCategory"},
    {&CLSID_AudioInputDeviceCategory, "CLSID_AudioInputDeviceCategory"},
    {&CLSID_AudioProperties, "CLSID_AudioProperties"},
    {&CLSID_AudioRecord, "CLSID_AudioRecord"},
    {&CLSID_AudioRender, "CLSID_AudioRender"},
    {&CLSID_AudioRendererCategory, "CLSID_AudioRendererCategory"},
    {&CLSID_AviDest, "CLSID_AviDest"},
    {&CLSID_AviMuxProptyPage, "CLSID_AviMuxProptyPage"},
    {&CLSID_AviMuxProptyPage1, "CLSID_AviMuxProptyPage1"},
    {&CLSID_AviReader, "CLSID_AviReader"},
    {&CLSID_AviSplitter, "CLSID_AviSplitter"},
    {&CLSID_CAcmCoClassManager, "CLSID_CAcmCoClassManager"},
    {&CLSID_CDeviceMoniker, "CLSID_CDeviceMoniker"},
    {&CLSID_CIcmCoClassManager, "CLSID_CIcmCoClassManager"},
    {&CLSID_CMidiOutClassManager, "CLSID_CMidiOutClassManager"},
    {&CLSID_CMpegAudioCodec, "CLSID_CMpegAudioCodec"},
    {&CLSID_CMpegVideoCodec, "CLSID_CMpegVideoCodec"},
    {&CLSID_CQzFilterClassManager, "CLSID_CQzFilterClassManager"},
    {&CLSID_CVidCapClassManager, "CLSID_CVidCapClassManager"},
    {&CLSID_CWaveOutClassManager, "CLSID_CWaveOutClassManager"},
    {&CLSID_CWaveinClassManager, "CLSID_CWaveinClassManager"},
    {&CLSID_CameraControlPropertyPage, "CLSID_CameraControlPropertyPage"},
    {&CLSID_CaptureGraphBuilder, "CLSID_CaptureGraphBuilder"},
    {&CLSID_CaptureProperties, "CLSID_CaptureProperties"},
    {&CLSID_Colour, "CLSID_Colour"},
    {&CLSID_CrossbarFilterPropertyPage, "CLSID_CrossbarFilterPropertyPage"},
    {&CLSID_DSoundRender, "CLSID_DSoundRender"},
    {&CLSID_DVDHWDecodersCategory, "CLSID_DVDHWDecodersCategory"},
    {&CLSID_DVDNavigator, "CLSID_DVDNavigator"},
    {&CLSID_DVDecPropertiesPage, "CLSID_DVDecPropertiesPage"},
    {&CLSID_DVEncPropertiesPage, "CLSID_DVEncPropertiesPage"},
    {&CLSID_DVMux, "CLSID_DVMux"},
    {&CLSID_DVMuxPropertyPage, "CLSID_DVMuxPropertyPage"},
    {&CLSID_DVSplitter, "CLSID_DVSplitter"},
    {&CLSID_DVVideoCodec, "CLSID_DVVideoCodec"},
    {&CLSID_DVVideoEnc, "CLSID_DVVideoEnc"},
    {&CLSID_DirectDraw, "CLSID_DirectDraw"},
    {&CLSID_DirectDrawClipper, "CLSID_DirectDrawClipper"},
    {&CLSID_DirectDrawProperties, "CLSID_DirectDrawProperties"},
    {&CLSID_Dither, "CLSID_Dither"},
    {&CLSID_DvdGraphBuilder, "CLSID_DvdGraphBuilder"},
    {&CLSID_FGControl, "CLSID_FGControl"},
    {&CLSID_FileSource, "CLSID_FileSource"},
    {&CLSID_FileWriter, "CLSID_FileWriter"},
    {&CLSID_FilterGraph, "CLSID_FilterGraph"},
    {&CLSID_FilterGraphNoThread, "CLSID_FilterGraphNoThread"},
    {&CLSID_FilterMapper, "CLSID_FilterMapper"},
    {&CLSID_FilterMapper2, "CLSID_FilterMapper2"},
    {&CLSID_InfTee, "CLSID_InfTee"},
    {&CLSID_LegacyAmFilterCategory, "CLSID_LegacyAmFilterCategory"},
    {&CLSID_Line21Decoder, "CLSID_Line21Decoder"},
    {&CLSID_MOVReader, "CLSID_MOVReader"},
    {&CLSID_MPEG1Doc, "CLSID_MPEG1Doc"},
    {&CLSID_MPEG1PacketPlayer, "CLSID_MPEG1PacketPlayer"},
    {&CLSID_MPEG1Splitter, "CLSID_MPEG1Splitter"},
    {&CLSID_MediaPropertyBag, "CLSID_MediaPropertyBag"},
    {&CLSID_MemoryAllocator, "CLSID_MemoryAllocator"},
    {&CLSID_MidiRendererCategory, "CLSID_MidiRendererCategory"},
    {&CLSID_ModexProperties, "CLSID_ModexProperties"},
    {&CLSID_ModexRenderer, "CLSID_ModexRenderer"},
    {&CLSID_OverlayMixer, "CLSID_OverlayMixer"},
    {&CLSID_PerformanceProperties, "CLSID_PerformanceProperties"},
    {&CLSID_PersistMonikerPID, "CLSID_PersistMonikerPID"},
    {&CLSID_ProtoFilterGraph, "CLSID_ProtoFilterGraph"},
    {&CLSID_QualityProperties, "CLSID_QualityProperties"},
    {&CLSID_SeekingPassThru, "CLSID_SeekingPassThru"},
    {&CLSID_SmartTee, "CLSID_SmartTee"},
    {&CLSID_SystemClock, "CLSID_SystemClock"},
    {&CLSID_SystemDeviceEnum, "CLSID_SystemDeviceEnum"},
    {&CLSID_TVAudioFilterPropertyPage, "CLSID_TVAudioFilterPropertyPage"},
    {&CLSID_TVTunerFilterPropertyPage, "CLSID_TVTunerFilterPropertyPage"},
    {&CLSID_TextRender, "CLSID_TextRender"},
    {&CLSID_URLReader, "CLSID_URLReader"},
    {&CLSID_VBISurfaces, "CLSID_VBISurfaces"},
    {&CLSID_VPObject, "CLSID_VPObject"},
    {&CLSID_VPVBIObject, "CLSID_VPVBIObject"},
    {&CLSID_VfwCapture, "CLSID_VfwCapture"},
    {&CLSID_VideoCompressorCategory, "CLSID_VideoCompressorCategory"},
    {&CLSID_VideoInputDeviceCategory, "CLSID_VideoInputDeviceCategory"},
    {&CLSID_VideoProcAmpPropertyPage, "CLSID_VideoProcAmpPropertyPage"},
    {&CLSID_VideoRenderer, "CLSID_VideoRenderer"},
    {&CLSID_VideoStreamConfigPropertyPage, "CLSID_VideoStreamConfigPropertyPage"},
    {&FORMAT_AnalogVideo, "FORMAT_AnalogVideo"},
    {&FORMAT_DVD_LPCMAudio, "FORMAT_DVD_LPCMAudio"},
    {&FORMAT_DolbyAC3, "FORMAT_DolbyAC3"},
    {&FORMAT_DvInfo, "FORMAT_DvInfo"},
    {&FORMAT_MPEG2Audio, "FORMAT_MPEG2Audio"},
    {&FORMAT_MPEG2Video, "FORMAT_MPEG2Video"},
    {&FORMAT_MPEG2_VIDEO, "FORMAT_MPEG2_VIDEO"},
    {&FORMAT_MPEGStreams, "FORMAT_MPEGStreams"},
    {&FORMAT_MPEGVideo, "FORMAT_MPEGVideo"},
    {&FORMAT_None, "FORMAT_None"},
    {&FORMAT_VIDEOINFO2, "FORMAT_VIDEOINFO2"},
    {&FORMAT_VideoInfo, "FORMAT_VideoInfo"},
    {&FORMAT_VideoInfo2, "FORMAT_VideoInfo2"},
    {&FORMAT_WaveFormatEx, "FORMAT_WaveFormatEx"},
    {&IID_IAMDirectSound, "IID_IAMDirectSound"},
    {&IID_IAMLine21Decoder, "IID_IAMLine21Decoder"},
    {&IID_IBaseVideoMixer, "IID_IBaseVideoMixer"},
    {&IID_IDDVideoPortContainer, "IID_IDDVideoPortContainer"},
    {&IID_IDirectDraw, "IID_IDirectDraw"},
    {&IID_IDirectDraw2, "IID_IDirectDraw2"},
    {&IID_IDirectDrawClipper, "IID_IDirectDrawClipper"},
    {&IID_IDirectDrawColorControl, "IID_IDirectDrawColorControl"},
    {&IID_IDirectDrawKernel, "IID_IDirectDrawKernel"},
    {&IID_IDirectDrawPalette, "IID_IDirectDrawPalette"},
    {&IID_IDirectDrawSurface, "IID_IDirectDrawSurface"},
    {&IID_IDirectDrawSurface2, "IID_IDirectDrawSurface2"},
    {&IID_IDirectDrawSurface3, "IID_IDirectDrawSurface3"},
    {&IID_IDirectDrawSurfaceKernel, "IID_IDirectDrawSurfaceKernel"},
    {&IID_IDirectDrawVideo, "IID_IDirectDrawVideo"},
    {&IID_IFullScreenVideo, "IID_IFullScreenVideo"},
    {&IID_IFullScreenVideoEx, "IID_IFullScreenVideoEx"},
    {&IID_IKsDataTypeHandler, "IID_IKsDataTypeHandler"},
    {&IID_IKsInterfaceHandler, "IID_IKsInterfaceHandler"},
    {&IID_IKsPin, "IID_IKsPin"},
    {&IID_IMixerPinConfig, "IID_IMixerPinConfig"},
    {&IID_IMixerPinConfig2, "IID_IMixerPinConfig2"},
    {&IID_IMpegAudioDecoder, "IID_IMpegAudioDecoder"},
    {&IID_IQualProp, "IID_IQualProp"},
    {&IID_IVPConfig, "IID_IVPConfig"},
    {&IID_IVPControl, "IID_IVPControl"},
    {&IID_IVPNotify, "IID_IVPNotify"},
    {&IID_IVPNotify2, "IID_IVPNotify2"},
    {&IID_IVPObject, "IID_IVPObject"},
    {&IID_IVPVBIConfig, "IID_IVPVBIConfig"},
    {&IID_IVPVBINotify, "IID_IVPVBINotify"},
    {&IID_IVPVBIObject, "IID_IVPVBIObject"},
    {&LOOK_DOWNSTREAM_ONLY, "LOOK_DOWNSTREAM_ONLY"},
    {&LOOK_UPSTREAM_ONLY, "LOOK_UPSTREAM_ONLY"},
    {&MEDIASUBTYPE_AIFF, "MEDIASUBTYPE_AIFF"},
    {&MEDIASUBTYPE_AU, "MEDIASUBTYPE_AU"},
    {&MEDIASUBTYPE_AnalogVideo_NTSC_M, "MEDIASUBTYPE_AnalogVideo_NTSC_M"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_B, "MEDIASUBTYPE_AnalogVideo_PAL_B"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_D, "MEDIASUBTYPE_AnalogVideo_PAL_D"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_G, "MEDIASUBTYPE_AnalogVideo_PAL_G"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_H, "MEDIASUBTYPE_AnalogVideo_PAL_H"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_I, "MEDIASUBTYPE_AnalogVideo_PAL_I"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_M, "MEDIASUBTYPE_AnalogVideo_PAL_M"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_N, "MEDIASUBTYPE_AnalogVideo_PAL_N"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_B, "MEDIASUBTYPE_AnalogVideo_SECAM_B"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_D, "MEDIASUBTYPE_AnalogVideo_SECAM_D"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_G, "MEDIASUBTYPE_AnalogVideo_SECAM_G"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_H, "MEDIASUBTYPE_AnalogVideo_SECAM_H"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_K, "MEDIASUBTYPE_AnalogVideo_SECAM_K"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_K1, "MEDIASUBTYPE_AnalogVideo_SECAM_K1"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_L, "MEDIASUBTYPE_AnalogVideo_SECAM_L"},
    {&MEDIASUBTYPE_Asf, "MEDIASUBTYPE_Asf"},
    {&MEDIASUBTYPE_Avi, "MEDIASUBTYPE_Avi"},
    {&MEDIASUBTYPE_CFCC, "MEDIASUBTYPE_CFCC"},
    {&MEDIASUBTYPE_CLJR, "MEDIASUBTYPE_CLJR"},
    {&MEDIASUBTYPE_CPLA, "MEDIASUBTYPE_CPLA"},
    {&MEDIASUBTYPE_DOLBY_AC3, "MEDIASUBTYPE_DOLBY_AC3"},
    {&MEDIASUBTYPE_DVCS, "MEDIASUBTYPE_DVCS"},
    {&MEDIASUBTYPE_DVD_LPCM_AUDIO, "MEDIASUBTYPE_DVD_LPCM_AUDIO"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_DSI, "MEDIASUBTYPE_DVD_NAVIGATION_DSI"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_PCI, "MEDIASUBTYPE_DVD_NAVIGATION_PCI"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER, "MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER"},
    {&MEDIASUBTYPE_DVD_SUBPICTURE, "MEDIASUBTYPE_DVD_SUBPICTURE"},
    {&MEDIASUBTYPE_DVSD, "MEDIASUBTYPE_DVSD"},
    {&MEDIASUBTYPE_DssAudio, "MEDIASUBTYPE_DssAudio"},
    {&MEDIASUBTYPE_DssVideo, "MEDIASUBTYPE_DssVideo"},
    {&MEDIASUBTYPE_IF09, "MEDIASUBTYPE_IF09"},
    {&MEDIASUBTYPE_IJPG, "MEDIASUBTYPE_IJPG"},
    {&MEDIASUBTYPE_Line21_BytePair, "MEDIASUBTYPE_Line21_BytePair"},
    {&MEDIASUBTYPE_Line21_GOPPacket, "MEDIASUBTYPE_Line21_GOPPacket"},
    {&MEDIASUBTYPE_Line21_VBIRawData, "MEDIASUBTYPE_Line21_VBIRawData"},
    {&MEDIASUBTYPE_MDVF, "MEDIASUBTYPE_MDVF"},
    {&MEDIASUBTYPE_MJPG, "MEDIASUBTYPE_MJPG"},
    {&MEDIASUBTYPE_MPEG1Audio, "MEDIASUBTYPE_MPEG1Audio"},
    {&MEDIASUBTYPE_MPEG1AudioPayload, "MEDIASUBTYPE_MPEG1AudioPayload"},
    {&MEDIASUBTYPE_MPEG1Packet, "MEDIASUBTYPE_MPEG1Packet"},
    {&MEDIASUBTYPE_MPEG1Payload, "MEDIASUBTYPE_MPEG1Payload"},
    {&MEDIASUBTYPE_MPEG1System, "MEDIASUBTYPE_MPEG1System"},
    {&MEDIASUBTYPE_MPEG1Video, "MEDIASUBTYPE_MPEG1Video"},
    {&MEDIASUBTYPE_MPEG1VideoCD, "MEDIASUBTYPE_MPEG1VideoCD"},
    {&MEDIASUBTYPE_MPEG2_AUDIO, "MEDIASUBTYPE_MPEG2_AUDIO"},
    {&MEDIASUBTYPE_MPEG2_PROGRAM, "MEDIASUBTYPE_MPEG2_PROGRAM"},
    {&MEDIASUBTYPE_MPEG2_TRANSPORT, "MEDIASUBTYPE_MPEG2_TRANSPORT"},
    {&MEDIASUBTYPE_MPEG2_VIDEO, "MEDIASUBTYPE_MPEG2_VIDEO"},
    {&MEDIASUBTYPE_None, "MEDIASUBTYPE_None"},
    {&MEDIASUBTYPE_Overlay, "MEDIASUBTYPE_Overlay"},
    {&MEDIASUBTYPE_PCM, "MEDIASUBTYPE_PCM"},
    {&MEDIASUBTYPE_PCMAudio_Obsolete, "MEDIASUBTYPE_PCMAudio_Obsolete"},
    {&MEDIASUBTYPE_Plum, "MEDIASUBTYPE_Plum"},
    {&MEDIASUBTYPE_QTJpeg, "MEDIASUBTYPE_QTJpeg"},
    {&MEDIASUBTYPE_QTMovie, "MEDIASUBTYPE_QTMovie"},
    {&MEDIASUBTYPE_QTRle, "MEDIASUBTYPE_QTRle"},
    {&MEDIASUBTYPE_QTRpza, "MEDIASUBTYPE_QTRpza"},
    {&MEDIASUBTYPE_QTSmc, "MEDIASUBTYPE_QTSmc"},
    {&MEDIASUBTYPE_RGB1, "MEDIASUBTYPE_RGB1"},
    {&MEDIASUBTYPE_RGB24, "MEDIASUBTYPE_RGB24"},
    {&MEDIASUBTYPE_RGB32, "MEDIASUBTYPE_RGB32"},
    {&MEDIASUBTYPE_RGB4, "MEDIASUBTYPE_RGB4"},
    {&MEDIASUBTYPE_RGB555, "MEDIASUBTYPE_RGB555"},
    {&MEDIASUBTYPE_RGB565, "MEDIASUBTYPE_RGB565"},
    {&MEDIASUBTYPE_RGB8, "MEDIASUBTYPE_RGB8"},
    {&MEDIASUBTYPE_TVMJ, "MEDIASUBTYPE_TVMJ"},
    {&MEDIASUBTYPE_UYVY, "MEDIASUBTYPE_UYVY"},
    {&MEDIASUBTYPE_VPVBI, "MEDIASUBTYPE_VPVBI"},
    {&MEDIASUBTYPE_VPVideo, "MEDIASUBTYPE_VPVideo"},
    {&MEDIASUBTYPE_WAKE, "MEDIASUBTYPE_WAKE"},
    {&MEDIASUBTYPE_WAVE, "MEDIASUBTYPE_WAVE"},
    {&MEDIASUBTYPE_Y211, "MEDIASUBTYPE_Y211"},
    {&MEDIASUBTYPE_Y411, "MEDIASUBTYPE_Y411"},
    {&MEDIASUBTYPE_Y41P, "MEDIASUBTYPE_Y41P"},
    {&MEDIASUBTYPE_YUY2, "MEDIASUBTYPE_YUY2"},
    {&MEDIASUBTYPE_YV12, "MEDIASUBTYPE_YV12"},
    {&MEDIASUBTYPE_YVU9, "MEDIASUBTYPE_YVU9"},
    {&MEDIASUBTYPE_YVYU, "MEDIASUBTYPE_YVYU"},
    {&MEDIASUBTYPE_dvhd, "MEDIASUBTYPE_dvhd"},
    {&MEDIASUBTYPE_dvsd, "MEDIASUBTYPE_dvsd"},
    {&MEDIASUBTYPE_dvsl, "MEDIASUBTYPE_dvsl"},
    {&MEDIATYPE_AUXLine21Data, "MEDIATYPE_AUXLine21Data"},
    {&MEDIATYPE_AnalogAudio, "MEDIATYPE_AnalogAudio"},
    {&MEDIATYPE_AnalogVideo, "MEDIATYPE_AnalogVideo"},
    {&MEDIATYPE_Audio, "MEDIATYPE_Audio"},
    {&MEDIATYPE_DVD_ENCRYPTED_PACK, "MEDIATYPE_DVD_ENCRYPTED_PACK"},
    {&MEDIATYPE_DVD_NAVIGATION, "MEDIATYPE_DVD_NAVIGATION"},
    {&MEDIATYPE_File, "MEDIATYPE_File"},
    {&MEDIATYPE_Interleaved, "MEDIATYPE_Interleaved"},
    {&MEDIATYPE_LMRT, "MEDIATYPE_LMRT"},
    {&MEDIATYPE_MPEG1SystemStream, "MEDIATYPE_MPEG1SystemStream"},
    {&MEDIATYPE_MPEG2_PES, "MEDIATYPE_MPEG2_PES"},
    {&MEDIATYPE_Midi, "MEDIATYPE_Midi"},
    {&MEDIATYPE_ScriptCommand, "MEDIATYPE_ScriptCommand"},
    {&MEDIATYPE_Stream, "MEDIATYPE_Stream"},
    {&MEDIATYPE_Text, "MEDIATYPE_Text"},
    {&MEDIATYPE_Timecode, "MEDIATYPE_Timecode"},
    {&MEDIATYPE_URL_STREAM, "MEDIATYPE_URL_STREAM"},
    {&MEDIATYPE_Video, "MEDIATYPE_Video"},
    {&PIN_CATEGORY_ANALOGVIDEOIN, "PIN_CATEGORY_ANALOGVIDEOIN"},
    {&PIN_CATEGORY_CAPTURE, "PIN_CATEGORY_CAPTURE"},
    {&PIN_CATEGORY_CC, "PIN_CATEGORY_CC"},
    {&PIN_CATEGORY_EDS, "PIN_CATEGORY_EDS"},
    {&PIN_CATEGORY_NABTS, "PIN_CATEGORY_NABTS"},
    {&PIN_CATEGORY_PREVIEW, "PIN_CATEGORY_PREVIEW"},
    {&PIN_CATEGORY_STILL, "PIN_CATEGORY_STILL"},
    {&PIN_CATEGORY_TELETEXT, "PIN_CATEGORY_TELETEXT"},
    {&PIN_CATEGORY_TIMECODE, "PIN_CATEGORY_TIMECODE"},
    {&PIN_CATEGORY_VBI, "PIN_CATEGORY_VBI"},
    {&PIN_CATEGORY_VIDEOPORT, "PIN_CATEGORY_VIDEOPORT"},
    {&PIN_CATEGORY_VIDEOPORT_VBI, "PIN_CATEGORY_VIDEOPORT_VBI"},
    {&TIME_FORMAT_BYTE, "TIME_FORMAT_BYTE"},
    {&TIME_FORMAT_FIELD, "TIME_FORMAT_FIELD"},
    {&TIME_FORMAT_FRAME, "TIME_FORMAT_FRAME"},
    {&TIME_FORMAT_MEDIA_TIME, "TIME_FORMAT_MEDIA_TIME"},
    {&TIME_FORMAT_NONE, "TIME_FORMAT_NONE"},
    {&TIME_FORMAT_SAMPLE, "TIME_FORMAT_SAMPLE"},
};

char * GuidToEnglish(const CLSID *const pclsid, char *buf)
{
    WCHAR szGuid[39];
    StringFromGUID2(pclsid ? *pclsid : GUID_NULL, szGuid, 39);

    if(pclsid == 0)
    {
        wsprintf(buf, "%S", szGuid);
        return buf;
    }

    for(int i = 0; i < NUMELMS(rgng); i++)
    {
        if(*pclsid == *(rgng[i].pguid))
        {
            wsprintf(buf, "%s %S", rgng[i].psz, szGuid);
            return buf;
        }
    }
    if(FOURCCMap(pclsid->Data1) == *pclsid)
    {
        if(pclsid->Data1 > 0xffff)
        {
            wsprintf(buf, "fourcc (%08x) %c%c%c%c %S",
                     pclsid->Data1,
                     ((char *)pclsid)[0],
                     ((char *)pclsid)[1],
                     ((char *)pclsid)[2],
                     ((char *)pclsid)[3],
                     szGuid);
        }
        else
        {
            wsprintf(buf, "fourcc (%08x) %S",
                     pclsid->Data1,
                     szGuid);
        }
        return buf;
    }
    else
    {
        wsprintf(buf, "(%S)", szGuid);
        return buf;
    }

}

#include "fil_data.h"
#include "fil_data_i.c"
void DoFilterInfo(HWND hWndTree, HTREEITEM hti, IMoniker *pMon, IAMFilterData *pafd)
{

    HRESULT hr;
    LONG lRc;

    IPropertyBag *pPropBag;
    hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {

        VARIANT varFilData;
        varFilData.vt = VT_UI1 | VT_ARRAY;
        varFilData.parray = 0; // docs say zero this

        BYTE *pbFilterData = 0; // 0 if not read
        DWORD dwcbFilterDAta = 0; // 0 if not read
        hr = pPropBag->Read(L"FilterData", &varFilData, 0);
        if(SUCCEEDED(hr))
        {
            ASSERT(varFilData.vt == (VT_UI1 | VT_ARRAY));
            dwcbFilterDAta = varFilData.parray->rgsabound[0].cElements;

            HRESULT hrTmp = SafeArrayAccessData(varFilData.parray, (void **)&pbFilterData);
            ASSERT(hrTmp == S_OK);

            // used to determine whether to free varFilData
            ASSERT(pbFilterData);
        }
        else
        {
            ASSERT(dwcbFilterDAta == 0 && pbFilterData == 0);
        }


        if(SUCCEEDED(hr))
        {

            BYTE *pb;
            hr = pafd->ParseFilterData(pbFilterData, dwcbFilterDAta, &pb);
            if(SUCCEEDED(hr))
            {
                REGFILTER2 *pFil = ((REGFILTER2 **)pb)[0];

                if(pbFilterData)
                {
                    HRESULT hrTmp = SafeArrayUnaccessData(varFilData.parray);
                    ASSERT(hrTmp == S_OK);

                    hrTmp = VariantClear(&varFilData);
                    ASSERT(hrTmp == S_OK);
                }
                ASSERT(pFil->dwVersion == 2);

                char szTxt[1024];
                wsprintf(szTxt, "Merit: %08x", pFil->dwMerit);

                TV_INSERTSTRUCT tvis;
                tvis.hParent = hti;
                tvis.hInsertAfter = TVI_SORT;
                tvis.item.pszText = szTxt;
                tvis.item.lParam = -1;
                tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

                //TreeView_InsertItem(hWndTree, &tvis);
                HTREEITEM htiMerit = (HTREEITEM)::SendMessage(
                    hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));


                wsprintf(szTxt, "Version: %d", pFil->dwVersion);

                HTREEITEM htiVersion = (HTREEITEM)::SendMessage(
                    hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                WCHAR *wszName;
                if(pMon->GetDisplayName(0, 0, &wszName) == S_OK)
                {

                    wsprintf(szTxt, "DisplayName: %S", wszName);

                    HTREEITEM htiVersion = (HTREEITEM)::SendMessage(
                        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    CoTaskMemFree(wszName);
                }

                //
                // Display the filter's filename
                //
                //            
                // Read filter's CLSID from property bag.  This CLSID string will be
                // used to find the filter's filename in the registry.
                VARIANT varFilterClsid;
                varFilterClsid.vt = VT_BSTR;

                hr = pPropBag->Read(L"CLSID", &varFilterClsid, 0);
                if(SUCCEEDED(hr))
                {
                    TCHAR szKey[512];

                    // Convert BSTR to string and free variant storage
                    CString strQuery(varFilterClsid.bstrVal);
                    SysFreeString(varFilterClsid.bstrVal);

                    // Create key name for reading filename registry
                    wsprintf(szKey, TEXT("Software\\Classes\\CLSID\\%s\\InprocServer32\0"),
                             strQuery);

                    // Variables needed for registry query
                    HKEY hkeyFilter=0;
                    DWORD dwSize=MAX_PATH;
                    BYTE szFilename[MAX_PATH];
                    int rc=0;

                    // Open the CLSID key that contains information about the filter
                    rc = RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hkeyFilter);
                    if (rc == ERROR_SUCCESS)
                    {
                        rc = RegQueryValueEx(hkeyFilter, NULL,  // Read (Default) value
                                             NULL, NULL, szFilename, &dwSize);

                        if (rc == ERROR_SUCCESS)
                        {
                            // Add filename string to tree node
                            wsprintf(szTxt, "Filename: %s", szFilename);

                            HTREEITEM htiFilename = (HTREEITEM)::SendMessage(
                                hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
                        }

                        rc = RegCloseKey(hkeyFilter);
                    }
                }
       

                for(UINT iPin = 0; iPin < pFil->cPins; iPin++)
                {
                    wsprintf(szTxt, "pin %02d:", iPin);

                    tvis.hParent = hti;

                    HTREEITEM htiPin = (HTREEITEM)::SendMessage(
                        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    tvis.hParent = htiPin;

                    wsprintf(szTxt, "bRendered: %d ", !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_RENDERER));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bOutput: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_OUTPUT));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bMany: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_MANY));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bZero: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_ZERO));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    WCHAR szGuid[39];
                    StringFromGUID2(pFil->rgPins2[iPin].clsPinCategory ? *pFil->rgPins2[iPin].clsPinCategory : GUID_NULL, szGuid, 39);
                    wsprintf(szTxt, "ClsPinCategory: %S ", szGuid );
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    for(UINT iType = 0; iType < pFil->rgPins2[iPin].nMediaTypes; iType++)
                    {
                        tvis.hParent = htiPin;
                        wsprintf(szTxt, "type %02d", iType);
                        HTREEITEM htiType = (HTREEITEM)::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        tvis.hParent = htiType;

                        wsprintf(szTxt, "major type: %s", CNV_GUID(pFil->rgPins2[iPin].lpMediaType[iType].clsMajorType));
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        wsprintf(szTxt, "subtype: %s", CNV_GUID(pFil->rgPins2[iPin].lpMediaType[iType].clsMinorType));
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    }

                    for(UINT iMed = 0; iMed < pFil->rgPins2[iPin].nMediums; iMed++)
                    {
                        tvis.hParent = htiPin;
                        wsprintf(szTxt, "Medium %02d", iMed);
                        HTREEITEM htiType = (HTREEITEM)::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        tvis.hParent = htiType;
                        WCHAR szGuid[39];

                        StringFromGUID2(pFil->rgPins2[iPin].lpMedium[iMed].clsMedium, szGuid, 39);
                        wsprintf(szTxt, "medium clsid: %S", szGuid);
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        wsprintf(szTxt, "Data1 Data2: %08x %08x", pFil->rgPins2[iPin].lpMedium[iMed].dw1, pFil->rgPins2[iPin].lpMedium[iMed].dw2);
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    }
                }

                CoTaskMemFree((BYTE *)pFil);
                lRc = ERROR_SUCCESS;
            }
        }

        pPropBag->Release();
    }
}

#endif // SHOWTYPES

void CFilterView::DoOneCategory(
    const TCHAR *szCatDesc,
    HWND hWndTree,
    const GUID *pCatGuid,
    ICreateDevEnum *pCreateDevEnum)
{

    // !!! leaked.
    CLSID *pclsid = new CLSID;
    *pclsid = *pCatGuid;

    // enumerator returns S_FALSE if the category is empty
    TV_INSERTSTRUCT tvis;
    tvis.hParent = TVI_ROOT;
    tvis.hInsertAfter = TVI_SORT ;
    tvis.item.pszText = (char *)szCatDesc; // !!! can be wide
    tvis.item.lParam = (DWORD_PTR)pclsid;
    tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

    //TreeView_InsertItem(hWndTree, &tvis);
    HTREEITEM htiParent = (HTREEITEM)::SendMessage(
        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

    {

        TV_INSERTSTRUCT tvis;
        tvis.hParent = htiParent;
        tvis.hInsertAfter = TVI_SORT;
        tvis.item.pszText = "dummy";
        tvis.item.lParam = 0;
        tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

        //TreeView_InsertItem(hWndTree, &tvis);
        HTREEITEM htx = (HTREEITEM)::SendMessage((hWndTree), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
    }

    return;
}

void CFilterView::RedoList()
{
    CBoxNetDoc *pDoc = NULL;
    CMDIFrameWnd *pMainFrame = (CMDIFrameWnd*)AfxGetApp()->m_pMainWnd;
    CMDIChildWnd *pMDIChildWnd = pMainFrame->MDIGetActive();

    if (pMDIChildWnd) {
        pDoc = (CBoxNetDoc *) pMDIChildWnd->GetActiveDocument();
    }

    if (!pDoc) {
        return;
    }

    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);

    m_lMoniker.DeleteRemoveAll();

    //
    // Add all filters to the list view
    //
    //TreeView_DeleteAllItems(hWndTree);
    ::SendMessage((hWndTree), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);

    //
    //
    //
    ICreateDevEnum *pCreateDevEnum;

    HRESULT hr;

    // !!! try getting mapper from graph instead of fresh....
    IFilterMapper3 *pMapper = NULL;

    // if we can, get the pCreateDevEnum from the graph, which may be remote
    pDoc->IGraph()->QueryInterface(IID_IFilterMapper3, (void **) &pMapper);

    if (pMapper) {
        hr = pMapper->GetICreateDevEnum(&pCreateDevEnum);
        pMapper->Release();
    } else {
        hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum, (void**)&pCreateDevEnum);
    }


    if(SUCCEEDED(hr))
    {
        IEnumMoniker *pEmCat = 0;
        hr = pCreateDevEnum->CreateClassEnumerator(
            CLSID_ActiveMovieCategories,
            &pEmCat,
            0);

        if(hr == S_OK)
        {
            IMoniker *pMCat;
            ULONG cFetched;
            while(hr = pEmCat->Next(1, &pMCat, &cFetched),
                  hr == S_OK)
            {
                IPropertyBag *pPropBag;
                hr = pMCat->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    VARIANT varCatClsid;
                    varCatClsid.vt = VT_BSTR;
                    hr = pPropBag->Read(L"CLSID", &varCatClsid, 0);
                    if(SUCCEEDED(hr))
                    {
                        CLSID clsidCat;
                        if(CLSIDFromString(varCatClsid.bstrVal, &clsidCat) == S_OK)
                        {
                            // use the guid if we can't get the name
                            WCHAR *wszTmpName;

                            VARIANT varCatName;
                            varCatName.vt = VT_BSTR;
                            hr = pPropBag->Read(L"FriendlyName", &varCatName, 0);
                            if(SUCCEEDED(hr))
                            {
                                wszTmpName = varCatName.bstrVal;
                            }
                            else
                            {
                                wszTmpName = varCatClsid.bstrVal;
                            }

                            TCHAR szCatDesc[MAX_PATH];

                            WideCharToMultiByte(
                                CP_ACP, 0, wszTmpName, -1,
                                szCatDesc, sizeof(szCatDesc), 0, 0);

                            if(SUCCEEDED(hr))
                            {
                                SysFreeString(varCatName.bstrVal);
                            }

                            DoOneCategory(
                                szCatDesc,
                                hWndTree,
                                &clsidCat,
                                pCreateDevEnum);

                        }

                        SysFreeString(varCatClsid.bstrVal);
                    }

                    pPropBag->Release();
                }
                else
                {
                    break;
                }

                pMCat->Release();
            } // for loop

            pEmCat->Release();
        }
        
        if( SUCCEEDED( hr ) )
        {
            // show any custom categories we'd like to see from GraphEdt...
            for( int i = 0; g_AppEnumeratedCategories[i].pclsid; i ++ )
            {    
                 DoOneCategory(
                     g_AppEnumeratedCategories[i].pszCat,
                     hWndTree,
                     g_AppEnumeratedCategories[i].pclsid,
                     pCreateDevEnum);
            }
        }

        pCreateDevEnum->Release();
    }
    
    // For resizing... All of our controls will be created by now so it is safe to
    // process OnSize messages.
    m_bHadInitDialog = TRUE;

    // Save our current size.
    CRect rcDialog;
    GetClientRect( &rcDialog );
    m_LastDialogSize = rcDialog.Size();

    // Work out that minimum size == dialog box with no list view object
    CRect rcTreeView;
    CWnd *pwndTreeView = GetDlgItem( IDC_FILTER_TREE );

    ASSERT( pwndTreeView );
    GetWindowRect( &rcDialog );
    pwndTreeView->GetWindowRect( &rcTreeView );

    m_MinDialogSize.cx = rcDialog.Width() - rcTreeView.Width();
    m_MinDialogSize.cy = rcDialog.Height() - rcTreeView.Height();
}

void CFilterView::OnSize( UINT nType, int cx, int cy )
{
    if( SIZE_RESTORED == nType ){
        if( m_bHadInitDialog ){
            CRect rcCancelButton, rcInsertButton, rcDialog, rcTreeView;

            CWnd *pwndCancelButton = GetDlgItem( IDCANCEL );
            CWnd *pwndInsertButton = GetDlgItem( ID_ADDFILTER );
            CWnd *pwndTreeView = GetDlgItem( IDC_FILTER_TREE );

            ASSERT( pwndCancelButton );
            ASSERT( pwndInsertButton );
            ASSERT( pwndTreeView );

            GetClientRect( &rcDialog );
            pwndCancelButton->GetWindowRect( &rcCancelButton );
            pwndInsertButton->GetWindowRect( &rcInsertButton );
            pwndTreeView->GetWindowRect( &rcTreeView );

            ScreenToClient( &rcCancelButton );
            ScreenToClient( &rcInsertButton );
            ScreenToClient( &rcTreeView );

            int iXInc = cx - m_LastDialogSize.cx;
            int iYInc = cy - m_LastDialogSize.cy;

            rcCancelButton.left += iXInc;
            rcCancelButton.right += iXInc;
            rcInsertButton.left += iXInc;
            rcInsertButton.right += iXInc;
            rcTreeView.right += iXInc;
            rcTreeView.bottom += iYInc;

            pwndCancelButton->MoveWindow( rcCancelButton );
            pwndInsertButton->MoveWindow( rcInsertButton );
            pwndTreeView->MoveWindow( rcTreeView );
        }

        m_LastDialogSize = CSize( cx, cy );
    }
}

void CFilterView::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
{
    if( m_bHadInitDialog )
        lpMMI->ptMinTrackSize = *((POINT*)&m_MinDialogSize);
}

//
// DialogProc
//
INT_PTR CFilterView::DialogProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(m_pThis);

    if (msg == WM_LBUTTONDBLCLK) {
        //
        // The double click has selected the filter we want to insert.
        // Do the same as if we had pressed the insert button
        //
        m_pThis->OnInsert();
        return( 0 );
    }


    return ::CallWindowProc(m_pfnOldDialogProc, hWnd, msg, wParam, lParam);
}

#ifdef COLORCODED_FILTERS
void CFilterView::OnCustomDraw (LPNMHDR lpn, LRESULT *pl)
{
    *pl = CDRF_DODEFAULT;
    LPNMLVCUSTOMDRAW lpCD = (LPNMLVCUSTOMDRAW)lpn;

    switch (lpCD->nmcd.dwDrawStage)
    {

      case CDDS_PREPAINT :
          *pl =  CDRF_NOTIFYITEMDRAW;
          return;

      case CDDS_ITEMPREPAINT:
      {
          LV_DISPINFO *pnmv = (LV_DISPINFO *) lpn;
          int iItem = (int)( pnmv->item.lParam );

          POSITION pos = m_lMoniker.GetHeadPosition();
          while(pos != 0 && iItem-- > 0)
          {
              m_lMoniker.GetNext(pos);
          }
          if(pos)
          {

              IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd
              if(pMon)
              {
                  IPropertyBag *pPropBag;
                  HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                  if(SUCCEEDED(hr))
                  {
                      VARIANT var;
                      var.vt = VT_BSTR;
                      hr = pPropBag->Read(L"CLSID", &var, 0);
                      if(SUCCEEDED(hr))
                      {
                        CLSID clsidFil;
                        if(CLSIDFromString(var.bstrVal, &clsidFil) == S_OK)
                        {
                            static CLSID CLSID_Proxy = {
                                0x17CCA71B, 0xECD7, 0x11D0,
                                {0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96}
                            } ;

                            if(clsidFil == CLSID_Proxy) {
                                lpCD->clrText = RGB(255,128,128);
                            }

                        }
                          SysFreeString(var.bstrVal);

                      }
                      pPropBag->Release();

                      // dmo's don't have a CLSID value!???

                      WCHAR *wszName;
                      if(pMon->GetDisplayName(0, 0, &wszName) == S_OK)
                      {
                          if(wszName[0] == L'@' &&
                             wszName[1] == L'd' &&
                             wszName[2] == L'e' &&
                             wszName[3] == L'v' &&
                             wszName[4] == L'i' &&
                             wszName[5] == L'c' &&
                             wszName[6] == L'e' &&
                             wszName[7] == L':' &&
                             wszName[8] == L'd' &&
                             wszName[9] == L'm' &&
                             wszName[10] == L'o')
                          {

                              lpCD->clrText = RGB(0,128,0);
                          }
                          CoTaskMemFree(wszName);
                      }

                  }
              }

          }
      }
    }
}
#endif // COLORCODED_FILTERS

void CFilterView::OnItemExpanding (NMHDR* pnmh, LRESULT* pResult)
{
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*) pnmh;

    if(pnmtv->itemNew.state & TVIS_EXPANDEDONCE) {
        return;
    }
    CBoxNetDoc *pDoc = NULL;
    CMDIFrameWnd *pMainFrame = (CMDIFrameWnd*)AfxGetApp()->m_pMainWnd;
    CMDIChildWnd *pMDIChildWnd = pMainFrame->MDIGetActive();

    if (pMDIChildWnd) {
        pDoc = (CBoxNetDoc *) pMDIChildWnd->GetActiveDocument();
    }

    if (!pDoc) {
        return;
    }

    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);


    HTREEITEM htiParent = pnmtv->itemNew.hItem;

    HTREEITEM htiOwner = (HTREEITEM)::SendMessage((hWndTree), TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)htiParent);
    if(htiOwner != 0) {
        return;
    }

    // remove dummy node
    HTREEITEM htiChild = (HTREEITEM)::SendMessage((hWndTree), TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)htiParent);
    ::SendMessage((hWndTree), TVM_DELETEITEM, 0, (LPARAM)htiChild);

    CLSID *pCatGuid = (CLSID *)pnmtv->itemNew.lParam;

    // !!! try getting mapper from graph instead of fresh....
    IFilterMapper3 *pMapper = NULL;

    // if we can, get the pCreateDevEnum from the graph, which may be remote
    pDoc->IGraph()->QueryInterface(IID_IFilterMapper3, (void **) &pMapper);

    HRESULT hr;

    ICreateDevEnum *pCreateDevEnum;
    if (pMapper) {
        hr = pMapper->GetICreateDevEnum(&pCreateDevEnum);
        pMapper->Release();
    } else {
        hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum, (void**)&pCreateDevEnum);
    }
    if(SUCCEEDED(hr))
    {

        IEnumMoniker *pEm;
        hr = pCreateDevEnum->CreateClassEnumerator(
            *pCatGuid,
            &pEm,
            0);
        if(SUCCEEDED(hr))
        {
            // remember hr is S_FALSE if pEm is null because there
            // would've been zero elements.
            //
            if(htiParent != 0 && pEm)
            {
                ULONG cFetched;
                IMoniker *pM;
                while(hr = pEm->Next(1, &pM, &cFetched),
                      hr == S_OK)
                {
                    IPropertyBag *pPropBag;
                    hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                    if(SUCCEEDED(hr))
                    {
                        VARIANT var;
                        var.vt = VT_BSTR;
                        hr = pPropBag->Read(L"FriendlyName", &var, 0);
                        if(SUCCEEDED(hr))
                        {
                            TCHAR szString[MAX_PATH];
                            WideCharToMultiByte(
                                CP_ACP, 0, var.bstrVal, -1,
                                szString, sizeof(szString), 0, 0);

                            TV_INSERTSTRUCT tvis;
                            tvis.hParent = htiParent;
                            tvis.hInsertAfter = TVI_SORT;
                            tvis.item.pszText = szString; // !!! can be wide
                            tvis.item.lParam = m_lMoniker.GetCount(); // use POS?
                            tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

                            //TreeView_InsertItem(hWndTree, &tvis);
                            HTREEITEM htx = (HTREEITEM)::SendMessage((hWndTree), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
                            m_lMoniker.AddTail(new CQCOMInt<IMoniker>(pM));

#ifdef SHOWTYPES
                            // !!! aggregation broken -- cannot qi
                            // graph or mapper for IAMFilterData
                            IAMFilterData *pfd;
                            hr = CoCreateInstance(
                                CLSID_FilterMapper,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IAMFilterData,
                                (void **)&pfd);
                            if(SUCCEEDED(hr))
                            {
                                DoFilterInfo(hWndTree, htx, pM, pfd);
                                pfd->Release();
                            }
#endif

                            SysFreeString(var.bstrVal);
                        }
                        pPropBag->Release();
                    }

                    pM->Release();
                }

            }
            if(pEm) {
                pEm->Release();
            }
        }
        pCreateDevEnum->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\geerrors.h ===
#ifndef GraphEditErrors_h
#define GraphEditErrors_h

#define GE_S_RECONNECT_PENDING          MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ITF, 0xFFFF )

#endif // GraphEditErrors_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\flb.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "FND.h"
#include "FLB.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CFilterListBox, CListBox)
    //{{AFX_MSG_MAP(CFilterListBox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CFilterListBox::CFilterListBox( HRESULT* phr )
    : m_pfndFilterDictionary(NULL),
      m_pListedFilters(NULL)
{
    try
    {
        m_pListedFilters = new CList<IBaseFilter*, IBaseFilter*>;
        m_pfndFilterDictionary = new CFilterNameDictionary( phr );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        delete m_pListedFilters;
        delete m_pfndFilterDictionary;
        m_pListedFilters = NULL;
        m_pfndFilterDictionary = NULL;

        pOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }
}

CFilterListBox::~CFilterListBox()
{
    IBaseFilter* pCurrentFilter;

    if( NULL != m_pListedFilters )
    {
        while( !m_pListedFilters->IsEmpty() )
        {
            pCurrentFilter = m_pListedFilters->GetHead();
            pCurrentFilter->Release();
            m_pListedFilters->RemoveAt( m_pListedFilters->GetHeadPosition() );
        }
    }

    delete m_pListedFilters;
    delete m_pfndFilterDictionary;
}

HRESULT CFilterListBox::AddFilter( IBaseFilter* pFilter )
{
    // This function assumes pFilter is a valid pointer.
    ASSERT( NULL != pFilter );

    WCHAR szCurrentFilterName[MAX_FILTER_NAME];

    HRESULT hr = m_pfndFilterDictionary->GetFilterName( pFilter, szCurrentFilterName );
    if( FAILED( hr ) )
    {
        return hr;
    }

    #ifdef _UNICODE
    int nNewItemIndex = AddString( szCurrentFilterName );
    #else // multibyte or ANSI.
    TCHAR szMultiByteFilterName[1024];

    // The filter's name must always fit in the szMultiByteFilterName buffer.
    ASSERT( sizeof(szCurrentFilterName) <= sizeof(szMultiByteFilterName) );

    int nNumBytesWritten = ::WideCharToMultiByte( CP_ACP,
                                                  0,
                                                  szCurrentFilterName,
                                                  -1, // WideCharToMultiByte() automatically calculates the 
                                                      // length of fiCurrentFilter.achName if this parameter equals -1.
                                                  szMultiByteFilterName,
                                                  sizeof(szMultiByteFilterName), 
                                                  NULL,
                                                  NULL ); 

    // An error occured if data was written off the end of the buffer.
    ASSERT( nNumBytesWritten <= sizeof(szMultiByteFilterName) );

    // ::WideCharToMultiByte() returns 0 if an error occurs.
    if( 0 == nNumBytesWritten ) {
        DWORD dwLastWin32Error = ::GetLastError();
        return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, dwLastWin32Error );
    }

    int nNewItemIndex = AddString( szMultiByteFilterName );
    #endif // _UNICODE

    if( (LB_ERR == nNewItemIndex) || (LB_ERRSPACE == nNewItemIndex) ) {
        return E_FAIL;
    }

    int nReturnValue = SetItemDataPtr( nNewItemIndex, pFilter );
    if( LB_ERR == nReturnValue )
    {
        nReturnValue = DeleteString( nNewItemIndex );

        // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
        // invalid item index.  See the MFC 4.2 documentation for more information.
        ASSERT( LB_ERR != nReturnValue );
        return E_FAIL;
    }

    try
    {
        m_pListedFilters->AddHead( pFilter );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        nReturnValue = DeleteString( nNewItemIndex );

        // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
        // invalid item index.  See the MFC 4.2 documentation for more information.
        ASSERT( LB_ERR != nReturnValue );

        pOutOfMemory->Delete();
        return E_OUTOFMEMORY;
    }

    pFilter->AddRef();

    return S_OK;
}

HRESULT CFilterListBox::GetSelectedFilter( IBaseFilter** ppSelectedFilter )
{
    return GetSelectedFilter( ppSelectedFilter, NULL );
}

HRESULT CFilterListBox::GetSelectedFilter( IBaseFilter** ppSelectedFilter, int* pnSelectedFilterIndex )
{
    // This function assumes ppSelectedFilter is a valid pointer.
    ASSERT( NULL != ppSelectedFilter );

    *ppSelectedFilter = NULL;

    int nSelectedFilterIndex = GetCurSel();

    // CListBox::GetCurSel() returns LB_ERR if no items are selected.
    if( LB_ERR == nSelectedFilterIndex )
    {
        return E_FAIL; // GE_E_NO_FILTERS_ARE_SELECTED;
    }

    void* pSelectedFilter = GetItemDataPtr( nSelectedFilterIndex );

    // CListBox::GetItemDatePtr() returns LB_ERR if an error occurs.
    if( LB_ERR == (INT_PTR)pSelectedFilter )
    {
        return E_FAIL;
    }

    *ppSelectedFilter = (IBaseFilter*)pSelectedFilter;

    if( NULL != pnSelectedFilterIndex )
    {
        *pnSelectedFilterIndex = nSelectedFilterIndex;
    }

    return S_OK;
}

HRESULT CFilterListBox::RemoveSelectedFilter( void )
{
    int nSelectedFilterIndex;
    IBaseFilter* pSelectedFilter;

    HRESULT hr = GetSelectedFilter( &pSelectedFilter, &nSelectedFilterIndex );
    if( FAILED( hr ) )
    {
        return hr;
    }

    int nReturnValue = DeleteString( nSelectedFilterIndex );
    // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
    // invalid item index.  See the MFC 4.2 documentation for more information.
    ASSERT( LB_ERR != nReturnValue );

    POSITION posSelectedFilter = m_pListedFilters->Find( pSelectedFilter );

    // CList::Find() only returns NULL if it cannot find the filter.
    // It should always find the filter since all filters added to
    // the list box are also added to the m_pListedFilters list.
    // See CFilterListBox::AddFilter() for more information.
    ASSERT( NULL != posSelectedFilter );

    m_pListedFilters->RemoveAt( posSelectedFilter );

    pSelectedFilter->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\fnd.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <streams.h>
#include "FND.h"

template<> inline UINT AFXAPI HashKey<CLSID&>( CLSID& clsidKey )
{
	return ((UINT) *((BYTE*)&clsidKey));
}

CFilterNameDictionary::CFilterNameDictionary( HRESULT* phr )
{
    try
    {
        m_pFilterNames = new CMap<CLSID, CLSID&, WCHAR*, WCHAR*>;
    }
    catch( CMemoryException* eOutOfMemory )
    {
        m_pFilterNames = NULL;
        eOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }
    
    HRESULT hr = BuildFilterNameTable();
    if( FAILED( hr ) )
    {
        DestroyFilterNameTable();
        *phr = hr;
        return;
    }
}

CFilterNameDictionary::~CFilterNameDictionary()
{
    DestroyFilterNameTable();
}

void CFilterNameDictionary::DestroyFilterNameTable( void )
{
    CLSID clsidCurrent;
    WCHAR* pszCurrentName;

    if( NULL != m_pFilterNames )
    {
        if( !m_pFilterNames->IsEmpty() )
        {
            POSITION posCurrent = m_pFilterNames->GetStartPosition();

            while( posCurrent != NULL )
            {
                m_pFilterNames->GetNextAssoc( posCurrent, clsidCurrent, pszCurrentName );
                delete [] pszCurrentName;
            }
        }

        m_pFilterNames->RemoveAll();

        delete m_pFilterNames;
        m_pFilterNames = NULL;
    }
}

HRESULT CFilterNameDictionary::GetFilterName( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] ) 
{
    HRESULT hr = GetNameFromFilter( pFilter, szFilterName );
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }

    hr = GetNameFromFilterNameTable( pFilter, szFilterName );
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }
    
    hr = GetNameFromInterfacePointer( pFilter, szFilterName ); 
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CFilterNameDictionary::GetNameFromFilter( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    FILTER_INFO fiFilterInfo;

    HRESULT hr = pFilter->QueryFilterInfo( &fiFilterInfo );
    if( FAILED( hr ) ) {
        return hr;
    }

    if( NULL != fiFilterInfo.pGraph ) {
        fiFilterInfo.pGraph->Release();
        fiFilterInfo.pGraph = NULL;
    }

    // Check so see if the filter's name is empty.
    if( '\0' == fiFilterInfo.achName[0] )
    {
        return E_FAIL;         
    }   

    ::lstrcpynW( szFilterName, fiFilterInfo.achName, MAX_FILTER_NAME );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    return S_OK;
}

HRESULT CFilterNameDictionary::GetNameFromFilterNameTable( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    CLSID clsidFilter;

    HRESULT hr = GetFilterCLSID( pFilter, &clsidFilter );
    if( FAILED( hr ) )
    {
        return hr;
    }

    WCHAR* pszFilterNameInTable;

    if( !m_pFilterNames->Lookup( clsidFilter, pszFilterNameInTable ) )
    {
        return E_FAIL;
    }

    ::lstrcpynW( szFilterName, pszFilterNameInTable, MAX_FILTER_NAME );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    return S_OK;
}

HRESULT CFilterNameDictionary::GetNameFromInterfacePointer( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    IUnknown* pUnknown;

    HRESULT hr = pFilter->QueryInterface( IID_IUnknown, (void**)&pUnknown );
    if( FAILED( hr ) )
    {
        return hr;  
    }

    _snwprintf( szFilterName, MAX_FILTER_NAME, L"Filter's IUnkown Pointer: 0x%p", pUnknown );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    pUnknown->Release();

    return S_OK;
}

HRESULT CFilterNameDictionary::BuildFilterNameTable( void )
{
    // This is the lowest possible merit.
    const DWORD MERIT_ANY_FILTER = 0x00000000;

    IFilterMapper2* pFilterMapper2;

    HRESULT hr = CoCreateInstance( CLSID_FilterMapper2,
                                   NULL, // This object will NOT be agregated.
                                   CLSCTX_INPROC_SERVER,  
                                   IID_IFilterMapper2,
                                   (void**)&pFilterMapper2 );
    if( FAILED( hr ) )
    {
        return hr;
    }

    IEnumMoniker* pAllRegisteredFilters;

    hr = pFilterMapper2->EnumMatchingFilters( &pAllRegisteredFilters,
                                              0, // No Flags
                                              FALSE, // No exact match
                                              MERIT_ANY_FILTER, 
                                              FALSE, // We do not care if the filter has any input pins.
                                              0,  
                                              NULL, // Since we don't care if the filter has an input pin, we accept any type.
                                              NULL, // We can use any input medium
                                              NULL, // We want pins from any category.
                                              FALSE, // The filter does not have to render the input.
                                              FALSE, // The filter does not need an output pin.
                                              0,
                                              NULL, // Since we don't care if the filter has an output pin, we accept any type.
                                              NULL, // We can use any output medium
                                              NULL ); // We want pins from any category.
    pFilterMapper2->Release();

    if( FAILED( hr ) )
    {
        return hr;
    }

    HRESULT hrEnum;
    CLSID clsidCurrentFilter;
    IMoniker* aCurrentFilterMoniker[1];

    do
    {
        hrEnum = pAllRegisteredFilters->Next( 1, &aCurrentFilterMoniker[0], NULL );
        if( FAILED( hrEnum ) )
        {
            pAllRegisteredFilters->Release();
            return hrEnum;
        }

        // IEnumMoniker::Next() returns S_OK if it successfully obtained the next moniker.
        if( S_OK == hrEnum )
        {
            WCHAR* pszFilterName;

            try
            {
                pszFilterName = new WCHAR[MAX_FILTER_NAME];
            }
            catch( CMemoryException* eOutOfMemory )
            {
                eOutOfMemory->Delete();
                aCurrentFilterMoniker[0]->Release();            
                pAllRegisteredFilters->Release();
                return E_OUTOFMEMORY;
            }

            hr = GetFiltersNameAndCLSID( aCurrentFilterMoniker[0],
                                         &clsidCurrentFilter,
                                         pszFilterName,
                                         MAX_FILTER_NAME );

            aCurrentFilterMoniker[0]->Release();            
    
            // GetFiltersNameAndCLSID() may fail because the filter can not be created.
            if( FAILED( hr ) )
            {
                delete [] pszFilterName;
                pszFilterName = NULL;
                continue;
            }

            hr = AddNameToTable( clsidCurrentFilter, pszFilterName );
            if( S_FALSE == hr )
            {
                delete [] pszFilterName;
                pszFilterName = NULL;
            }
            else if( FAILED( hr ) )
            {
                pAllRegisteredFilters->Release();
                delete [] pszFilterName;
                return hr;
            }
        }
    } while( S_OK == hrEnum );

    pAllRegisteredFilters->Release();
    
    return S_OK;
}


HRESULT CFilterNameDictionary::GetFiltersNameAndCLSID
    (
    IMoniker* pFiltersMoniker,
    CLSID* pclsidFilter,
    WCHAR* pszFiltersName,
    DWORD dwMaxFilterNameLength
    )
{
    CComPtr<IBindCtx> pBindContext;

    HRESULT hr = ::CreateBindCtx( 0, &pBindContext );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // Get the filter's name.
    CComPtr<IPropertyBag> pFilterPropertyBag;

    hr = pFiltersMoniker->BindToStorage( pBindContext,
                                         NULL,
                                         IID_IPropertyBag,
                                         (void**)&pFilterPropertyBag );
    if( FAILED( hr ) )
    {
        return hr;
    }

    VARIANT varFilterName;

    ::VariantInit( &varFilterName );
    varFilterName.vt = VT_BSTR;
    varFilterName.bstrVal = ::SysAllocString(NULL);

    hr = pFilterPropertyBag->Read( L"FriendlyName", &varFilterName, NULL );

    if( FAILED( hr ) )
    {
        ::VariantClear( &varFilterName );
        return hr;
    }

    VARIANT varFilterCLSID;

    ::VariantInit( &varFilterCLSID );
    varFilterCLSID.vt = VT_BSTR;
    varFilterCLSID.bstrVal = ::SysAllocString(NULL);

    hr = pFilterPropertyBag->Read( L"CLSID", &varFilterCLSID, NULL );

    if( FAILED( hr ) )
    {
        ::VariantClear( &varFilterName );
        ::VariantClear( &varFilterCLSID ); 
        return hr;
    }

    CLSID clsidFilter;

    hr = CLSIDFromString( varFilterCLSID.bstrVal, &clsidFilter );

    ::VariantClear( &varFilterCLSID ); 

    if( FAILED( hr ) ) {
        ::VariantClear( &varFilterName );
        return hr;
    }

    // The SysStringLen() length returned by SysStringLen() does not include the null
    // terminating character.
    DWORD dwFilterNameLength = ::SysStringLen( varFilterName.bstrVal ) + 1;
    
    // If this ASSERT fires, then the filter's name will be truncated.
    ASSERT( dwFilterNameLength < MAX_FILTER_NAME );

    ::lstrcpynW( pszFiltersName, varFilterName.bstrVal, min( dwFilterNameLength, dwMaxFilterNameLength ) );

    *pclsidFilter = clsidFilter;

    ::VariantClear( &varFilterName );

    return S_OK;
}

HRESULT CFilterNameDictionary::AddNameToTable( CLSID& clsid, WCHAR* pszName )
{
    WCHAR* pszStoredName; 
   
    // There should never be two names with the same CLSID.
    if( m_pFilterNames->Lookup( clsid, pszStoredName ) )
    {
        DbgLog(( LOG_TRACE, 0, "WARNING: Found two names with the same CLSID: %40ls  %40ls", pszStoredName, pszName ));
        return S_FALSE;
    }

    try
    {
        m_pFilterNames->SetAt( clsid, pszName );
    }
    catch( CMemoryException* eOutOfMemory )
    {
        eOutOfMemory->Delete();
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CFilterNameDictionary::GetFilterCLSID( IBaseFilter* pFilter, CLSID* pFilterCLSID )
{
    IPersist* pFilterID;

    HRESULT hr = pFilter->QueryInterface( IID_IPersist, (void**)&pFilterID );

    if( FAILED( hr ) )
    {
        return hr;
    }

    CLSID clsidFilter;

    hr = pFilterID->GetClassID( &clsidFilter );

    pFilterID->Release();

    if( FAILED( hr ) )
    {
        return hr;
    }

    *pFilterCLSID = clsidFilter;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\fnd.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef CFilterNameDictionary_h
#define CFilterNameDictionary_h

class CFilterNameDictionary
{
public:
    CFilterNameDictionary( HRESULT* phr );
    ~CFilterNameDictionary();

    HRESULT GetFilterName( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );

private:
    HRESULT GetNameFromFilter( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );
    HRESULT GetNameFromFilterNameTable( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );
    HRESULT GetNameFromInterfacePointer( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );

    static HRESULT GetFiltersNameAndCLSID
        (
        IMoniker* pFiltersMoniker,
        CLSID* pclsidFilter,
        WCHAR* pszFiltersName,
        DWORD dwMaxFilterNameLength
        );

    HRESULT BuildFilterNameTable( void );
    HRESULT AddNameToTable( CLSID& clsid, WCHAR* pszName );
    void DestroyFilterNameTable( void );

    static HRESULT GetFilterCLSID( IBaseFilter* pFilter, CLSID* pFilterCLSID );

    CMap<CLSID, CLSID&, WCHAR*, WCHAR*>* m_pFilterNames;

};

#endif // CFilterNameDictionary_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\grftmpl.h ===
// Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
//
// CGraphDocTemplate
//

// A CSingleDocTemplate derived class that provides the custom
// behaviour required for renderfile.

class CGraphDocTemplate : public CMultiDocTemplate {

public:

    CGraphDocTemplate( UINT nIDResource
                     , CRuntimeClass* pDocClass
                     , CRuntimeClass* pFrameClass
                     , CRuntimeClass* pViewClass)
	: CMultiDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass) {}

    ~CGraphDocTemplate() {}

    int GetCount() { return m_docList.GetCount(); }


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\graphedt.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// boxnet.cpp : defines CAboutDlg, CGraphEdit
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// the one and only CGraphEdit object
//
CGraphEdit theApp;

//
// CAboutDlg dialog used for App About
//
class CAboutDlg : public CDialog {

public:
    // construction
    CAboutDlg();
    virtual BOOL OnInitDialog();
};

//
// Constructor
//
CAboutDlg::CAboutDlg() : CDialog(IDD_ABOUTBOX)
{}

//
// OnInitDialog
//
// Obtains the version information from the binary file. Note that if
// we fail we just return. The template for the about dialog has a
// "Version not available" as default.
//
BOOL CAboutDlg::OnInitDialog()
{
    //
    // first call base method so we can return on errors
    //
    BOOL Result = CDialog::OnInitDialog();

    //
    // Find the version of this binary
    //
    TCHAR achFileName[128];
    if ( !GetModuleFileName(AfxGetInstanceHandle() , achFileName, sizeof(achFileName)) )
        return(Result);

    DWORD dwTemp;
    DWORD dwVerSize = GetFileVersionInfoSize( achFileName, &dwTemp );
    if ( !dwVerSize)
        return(Result);

    HLOCAL hTemp = LocalAlloc( LHND, dwVerSize );
    if (!hTemp)
        return(Result);

    LPVOID lpvVerBuffer = LocalLock( hTemp );
    if (!lpvVerBuffer) {
        LocalFree( hTemp );
        return(Result);
    }

    if ( !GetFileVersionInfo( achFileName, 0L, dwVerSize, lpvVerBuffer ) ) {
        LocalUnlock( hTemp );
        LocalFree( hTemp );
        return( Result );
    }

    // "040904E4" is the code page for US English (Andrew believes).
    LPVOID lpvValue;
    UINT uLen;
    if (VerQueryValue( lpvVerBuffer,
                   TEXT("\\StringFileInfo\\040904E4\\ProductVersion"),
                   (LPVOID *) &lpvValue, &uLen)) {

        //
        // Get creation date of executable (date of build)
        //
        CFileStatus fsFileStatus;
        if (CFile::GetStatus( achFileName, fsFileStatus)) {
            // put build date into string in YYMMDD format
            char szBuildDate[20];
            CTime * pTime = &fsFileStatus.m_mtime;

            sprintf(szBuildDate, " - Build: %2.2u%2.2u%2.2u",
                    pTime->GetYear() % 100, pTime->GetMonth(), pTime->GetDay());
                    strcat((LPSTR) lpvValue, szBuildDate);
        }

        SetDlgItemText(IDS_VERSION, (LPSTR)lpvValue);
    }

    LocalUnlock(hTemp);
    LocalFree(hTemp);

    return(Result);
}

// *
// * CGraphEdit
// *

//
// Constructor
//
CGraphEdit::CGraphEdit()
{
    // place all significant initialization in InitInstance
    m_pMultiGraphHostUnknown = NULL;
    m_pDocTemplate = NULL;
}



//
// InitInstance
//
BOOL CGraphEdit::InitInstance() {
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    SetDialogBkColor();        // set dialog background color to gray
    LoadStdProfileSettings(8);  // Load standard INI file options (including MRU)

    
    // get MFCANS32 to wrap the Quartz interfaces also
    //HRESULT hr = Ole2AnsiSetFlags(  OLE2ANSI_WRAPCUSTOM
    //                              | OLE2ANSI_AGGREGATION
    //                             , NULL);
    //if (FAILED(hr)) {
    //    return FALSE;
    //}

    // Initialize OLE 2.0 libraries
    if (!AfxOleInit()) {
        return FALSE;
    }
	
    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    m_pDocTemplate = new CGraphDocTemplate( IDR_GRAPH
                                        , RUNTIME_CLASS(CBoxNetDoc)
		                        , RUNTIME_CLASS(CChildFrame)
		                        , RUNTIME_CLASS(CBoxNetView));
    AddDocTemplate(m_pDocTemplate); // m_pDocTemplate is freed by MFC on app shutdown

    // enable file manager drag/drop and DDE Execute open
    EnableShellOpen();
    RegisterShellFileTypes();

    // initialize box drawing code
    try {
        gpboxdraw = new CBoxDraw;
        gpboxdraw->Init();
    }
    catch(CException *e) {
        delete gpboxdraw, gpboxdraw = NULL;
 	e->Delete();
	return FALSE;
    }

    CMultiGraphHost* pMultiGraphHost = new CMultiGraphHost(this);
    if (!pMultiGraphHost)
    {
        return FALSE;
    }
    HRESULT hr = pMultiGraphHost->QueryInterface(IID_IMultiGraphHost, (void**) &m_pMultiGraphHostUnknown);
    if (FAILED(hr))
    {
        delete pMultiGraphHost;
        return FALSE;
    }


    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_GRAPH))
	    return FALSE;
    m_pMainWnd = pMainFrame;

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // SDI graphedt used -E for running embedded (OLE/DDE). Use -dde or
    // -embedded for the same effect (I think :)

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
	    return FALSE;

    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();

    return TRUE;
}


//
// ExitInstance
//
int CGraphEdit::ExitInstance() {

    if (gpboxdraw != NULL) {
        delete gpboxdraw, gpboxdraw = NULL;
    }
    if (m_pMultiGraphHostUnknown)
    {
        m_pMultiGraphHostUnknown->Release();
        m_pMultiGraphHostUnknown = NULL;
    }
    AfxOleTerm();

    return CWinApp::ExitInstance();
}

//
// CGraphEdit generated message map
//
BEGIN_MESSAGE_MAP(CGraphEdit, CWinApp)
	//{{AFX_MSG_MAP(CGraphEdit)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
        ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()


//
// CGraphEdit callback functions
//

//
// OnAppAbout
//
// Display the modal about dialog
void CGraphEdit::OnAppAbout() {

    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\graphedt.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// graphedt.h : declares CGraphEdit
//

/////////////////////////////////////////////////////////////////////////////
// CGraphEdit
//


class CGraphEdit : public CWinApp
{

public:
    // construction, initialization, termination
    CGraphEdit();
    virtual BOOL InitInstance();
    virtual int ExitInstance();

    CGraphDocTemplate* m_pDocTemplate;
    IUnknown* m_pMultiGraphHostUnknown;


protected:
    // message callback functions
    //{{AFX_MSG(CGraphEdit)
    afx_msg void OnAppAbout();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// application-global macros

// GBL(x) accesses member <x> of the global CGraphEdit
#define GBL(x) (((CGraphEdit *) AfxGetApp())->x)

// MFGBL(x) accesses member <x> of the global CMainFrame
#define MFGBL(x) (((CMainFrame *) GBL(m_pMainWnd))->x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\gstats.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
class CGraphStats : public CDialog
{
public:
    static void DelGraphStats();
    static CGraphStats * GetGraphStats(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );

protected:
    ~CGraphStats();
    CGraphStats(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );


    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );

    BOOL OnInitDialog();
    void RedoList();
    void ResetStats();

    CBoxNetDoc * m_pBoxNet;

    static CGraphStats * m_pThis;

    void DoDataExchange(CDataExchange* pDX);
    CListBox m_ListBox;

    BOOL m_bHadInitDialog;         // Received OnInitDialog message?

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\guids.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif


#include <MultiGraphHost.h> // GUID_MultiGraphHostService

DEFINE_GUID(IID_IMultiGraphHost,0xde178e3c,0xebe0,0x4e77,0xab,0xc3,0x13,0xc9,0xd2,0xc5,0xd6,0x36);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\grftmpl.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// CGraphDocTemplate
//

#include "stdafx.h"

// A CMultiDocTemplate derived class that provides the custom
// behaviour required for renderfile.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\gstats.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// Dialog to display all filters
//

#include "stdafx.h"
#include "gstats.h"

BEGIN_MESSAGE_MAP(CGraphStats, CDialog)
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
    ON_COMMAND(IDC_Refresh, RedoList)
    ON_COMMAND(IDC_RESET, ResetStats)
END_MESSAGE_MAP()

CGraphStats* CGraphStats::m_pThis = 0;
//
// Constructor
//
CGraphStats::CGraphStats(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)

 : 
   m_pBoxNet(pBoxNet)
 , m_bHadInitDialog( FALSE )
{
    //
    // There can only be one filter view dialog at a time. Thus
    // the initialisation in the constructor is ok (even desired).
    //
    ASSERT( m_pThis == 0 );
    m_pThis = this;
    Create(IDD_STATS, pParent);
    ShowWindow( SW_SHOW );
}

CGraphStats::~CGraphStats()
{
    // Windows will automatically delete m_hImgList when the dialog
    // box is destroyed.
    m_pThis = 0;
}

CGraphStats * CGraphStats::GetGraphStats(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)
{
    if (!m_pThis) 
    {
        m_pThis = new CGraphStats(pBoxNet, pParent);
    }
    else
    {
        m_pThis->RedoList();
        m_pThis->ShowWindow( SW_RESTORE );
    }
    return m_pThis;

}

void CGraphStats::DelGraphStats()
{
    if (m_pThis)
    {
        delete m_pThis;
        m_pThis = 0;
    }
}

BOOL CGraphStats::OnInitDialog()
{
    BOOL fResult = CDialog::OnInitDialog();

    RedoList();

    return( fResult );
}


void CGraphStats::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);    

    //{{AFX_DATA_MAP(CGraphStats)
        DDX_Control(pDX, IDC_LIST1, m_ListBox);
    //}}AFX_DATA_MAP
}


void CGraphStats::RedoList()
{
    IAMStats *pStats;

    if (FAILED(m_pBoxNet->IGraph()->QueryInterface(IID_IAMStats, (void **) &pStats)))
        return;

    m_ListBox.ResetContent();

    int tabs[] = {250, 300, 350, 400, 450, 500 };

    m_ListBox.SetTabStops(sizeof(tabs) / sizeof(tabs[0]), tabs);

    m_ListBox.AddString("Statistic\t   Count\t   Last\t   Average\t   StdDev\t   Min\t   Max");
    m_ListBox.AddString("---------\t   -----\t   ----\t   -------\t   ------\t   ---\t   ---");
    LONG lStats;
    if (SUCCEEDED(pStats->get_Count(&lStats))) {
        for (long lIndex = 0; lIndex < lStats; lIndex++) {
            BSTR szName;
            long lCount;
            double dLast;
            double dAverage;
            double dStdDev;
            double dMin;
            double dMax;

            if (FAILED(pStats->GetValueByIndex(lIndex, &szName, &lCount, &dLast,
                                               &dAverage, &dStdDev, &dMin, &dMax)))
                break;


            char achTemp[256];
#define FRAC(d)  ((int) (1000 * (d - (int) d)))
            wsprintf(achTemp, "%ls\t%5d\t%5d.%03d\t%5d.%03d\t%5d.%03d\t%5d.%03d\t%5d.%03d",
                     szName, lCount, (int) dLast, FRAC(dLast), (int) dAverage, FRAC(dAverage),
                     (int) dStdDev, FRAC(dStdDev), (int) dMin, FRAC(dMin), (int) dMax, FRAC(dMax));
            m_ListBox.AddString(achTemp);

            SysFreeString(szName);
        }
    }
    
    pStats->Release();
}

void CGraphStats::ResetStats()
{
    IAMStats *pStats;

    if (FAILED(m_pBoxNet->IGraph()->QueryInterface(IID_IAMStats, (void **) &pStats)))
        return;

    pStats->Reset();
    pStats->Release();

    RedoList();
}

void CGraphStats::OnSize( UINT nType, int cx, int cy )
{
    if( SIZE_RESTORED == nType ){
        if( m_bHadInitDialog ){
        }
    }
}

void CGraphStats::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
{
    if( m_bHadInitDialog ) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\mainfrm.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// mainfrm.h : declares CMainFrame
//

class CSeekDialog : public CDialogBar
{
    BOOL m_bDirty;

public:
    CSeekDialog( );
    ~CSeekDialog( );

   // overrides

   // Generated message map functions
   //{{AFX_MSG(CSeekDialog)
   virtual void OnCancel( );
   virtual void OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
   virtual void OnTimer( UINT nTimer );
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

public:

   BOOL DidPositionChange( );
   double GetPosition( );
   void SetPosition( double pos, REFERENCE_TIME StartTime, REFERENCE_TIME StopTime, REFERENCE_TIME CurrentTime );
   BOOL IsSeekingRandom( );
   CString Format(REFERENCE_TIME t);

   REFERENCE_TIME m_nLastMin;
   REFERENCE_TIME m_nLastMax;
   REFERENCE_TIME m_nLastCurrent;
   REFERENCE_TIME m_nLastSlider;
   UINT            m_nLastSliderPos; // Updated only when user is moving the slider thumb and has not released it.
   WORD m_nMax;
   WORD m_nPageSize;
};

class CMainFrame : public CMDIFrameWnd
{
    DECLARE_DYNCREATE(CMainFrame)

protected:
    // control bar embedded members
    CStatusBar      m_wndStatusBar;
    CToolBar        m_wndToolBar;
    CSeekDialog*    m_pCurrentSeekBar;
    DWORD           m_nLastSeekBarID;
    BOOL            m_bShowSeekBar;

public:
    // construction and destruction
    CMainFrame();
    virtual ~CMainFrame();

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    // operations
    virtual void SetStatus(unsigned idString);
    virtual void GetMessageString( UINT nID, CString& rMessage ) const;
    virtual void SetSeekBar(CSeekDialog* pwndSeekBar);
    virtual void CreateSeekBar(CSeekDialog& wndSeekBar, WORD nMax, WORD nPageSize);

protected:
    // generated message map
    //{{AFX_MSG(CMainFrame)
    afx_msg BOOL OnViewBar(UINT nID);
    afx_msg void OnUpdateSeekBarMenu(CCmdUI* pCmdUI);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnCloseWindow();
    afx_msg void OnUpdateCloseWindow(CCmdUI* pCmdUI);
    afx_msg void OnCloseAllWindows();
    afx_msg void OnUpdateCloseAllWindows(CCmdUI* pCmdUI);
    afx_msg void OnCloseAllDocuments();
    afx_msg void OnUpdateCloseAllDocuments(CCmdUI* pCmdUI);
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    afx_msg void MyOnHelpIndex();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\gutil.cpp ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
// util.cpp
//
// Defines utility functions not specific to this application.
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/* NormalizeRect(prc)
 *
 * Swap the left and right edges of <prc>, and the top and bottom edges,
 * as required in order to make <prc->left> be less than <prc->right>
 * and <prc->top> to be less than <prc->bottom>.
 */
void FAR PASCAL
NormalizeRect(CRect *prc)
{
    if (prc->left > prc->right)
        iswap(&prc->left, &prc->right);
    if (prc->top > prc->bottom)
        iswap(&prc->top, &prc->bottom);
}


/* InvertFrame(pdc, prcOuter, prcInner)
 *
 * Invert the color of the pixels in <pdc> that are contained in <*prcOuter>
 * but that are not contained in <*prcInner>.
 */
void FAR PASCAL
InvertFrame(CDC *pdc, CRect *prcOuter, CRect *prcInner)
{
    pdc->PatBlt(prcOuter->left, prcOuter->top,
        prcOuter->Width(), prcInner->top - prcOuter->top, DSTINVERT);
    pdc->PatBlt(prcOuter->left, prcInner->bottom,
        prcOuter->Width(), prcOuter->bottom - prcInner->bottom, DSTINVERT);
    pdc->PatBlt(prcOuter->left, prcInner->top,
        prcInner->left - prcOuter->left, prcInner->Height(), DSTINVERT);
    pdc->PatBlt(prcInner->right, prcInner->top,
        prcOuter->right - prcInner->right, prcInner->Height(), DSTINVERT);
}


//
// --- Quartz Stuff ---
//

//
// CIPin
//


BOOL EqualPins(IPin *pFirst, IPin *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    LPUNKNOWN pUnknown1;     // Retrieve the IUnknown interface
    LPUNKNOWN pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    ASSERT(pFirst);
    ASSERT(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}

//
// operator ==
//
// Test for equality. Pins are equal if they are on the same filter and have the
// same name. (case insensitive)
BOOL CIPin::operator== (CIPin& pin) {

    return EqualPins((*this), pin);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\propguid.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// propguid.h
//

// CLSID_MediaTypePropertyPage
// {fd501045-8ebe-11ce-8183-00aa00577da1}
DEFINE_GUID(CLSID_MediaTypePropertyPage,
0xfd501045, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);

// CLSID_FileSourcePropertyPage
// {29e07010-bd27-11ce-ab59-00aa00577da1}
DEFINE_GUID(CLSID_FileSourcePropertyPage,
0x29e07010, 0xbd27, 0x11ce, 0xab, 0x59, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);

// CLSID_FileSinkPropertyPage
// {E0B9CDA0-96E3-11cf-B9FA-00AA00A3F1A6}
DEFINE_GUID(CLSID_FileSinkPropertyPage,
0xe0b9cda0, 0x96e3, 0x11cf, 0xb9, 0xfa, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\mainfrm.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// mainfrm.h : defines CMainFrame
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


//IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)
IMPLEMENT_DYNCREATE(CMainFrame, CMDIFrameWnd)

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars


// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
    // same order as in the bitmap 'toolbar.bmp'
    ID_FILE_NEW,
    ID_FILE_OPEN,
    ID_FILE_SAVE,
        ID_SEPARATOR,
    ID_FILE_PRINT,
        ID_SEPARATOR,
    ID_EDIT_CUT,
    ID_EDIT_COPY,
    ID_EDIT_PASTE,
        ID_SEPARATOR,
    ID_QUARTZ_RUN,
    ID_QUARTZ_PAUSE,
    ID_QUARTZ_STOP,
        ID_SEPARATOR,
    ID_APP_ABOUT,
};


// indicators
static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction


CMainFrame::CMainFrame()
    : m_bShowSeekBar(true)
    , m_nLastSeekBarID(0)
    , m_pCurrentSeekBar(NULL)
{
}


CMainFrame::~CMainFrame()
{
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics


#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// operations


/* SetStatus(idString)
 *
 * Set the status bar text to the string resource <idString>.
 */
void CMainFrame::SetStatus(unsigned idString)
{
    CString     str;

    try
    {
        str.LoadString(idString);
        m_wndStatusBar.SetPaneText(0, str);
    }
    catch (CException *e)
    {
        m_wndStatusBar.SetPaneText(0, "Warning: almost out of memory!", TRUE);
	e->Delete();
    }
}

void CMainFrame::GetMessageString( UINT nID, CString& rMessage ) const
{
    // The text displayed in the status bar when Edit..Redo is highlighted
    // depends on whether we are allowing a redo or a repeat.
    if( nID == ID_EDIT_REDO ){
        
        CBoxNetDoc *pDoc = NULL;
        
        CMDIChildWnd* pMDIChildWnd =this->MDIGetActive();

        if (pMDIChildWnd){
            pDoc = (CBoxNetDoc *) pMDIChildWnd->GetActiveDocument();
        }

        if( pDoc && pDoc->CanRedo() )
            rMessage.LoadString( ID_EDIT_REDO );
        else
            rMessage.LoadString( ID_EDIT_REPEAT );
    } else
        CMDIFrameWnd::GetMessageString( nID, rMessage );
}

     

/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
    ON_COMMAND_EX(IDW_SEEKBAR, OnViewBar)
    ON_COMMAND(ID_WINDOW_CLOSE, OnCloseWindow)
    ON_UPDATE_COMMAND_UI(ID_WINDOW_CLOSE, OnUpdateCloseWindow)
    ON_COMMAND(ID_WINDOW_CLOSEALL, OnCloseAllWindows)
    ON_UPDATE_COMMAND_UI(ID_WINDOW_CLOSEALL, OnUpdateCloseAllWindows)
    ON_COMMAND(ID_FILE_CLOSEALL, OnCloseAllDocuments)
    ON_UPDATE_COMMAND_UI(ID_FILE_CLOSEALL, OnUpdateCloseAllDocuments)
    ON_UPDATE_COMMAND_UI(IDW_SEEKBAR, OnUpdateSeekBarMenu)
    //}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP_INDEX, CMainFrame::MyOnHelpIndex)
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// message callback functions


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{

    EnableDocking(CBRS_FLOAT_MULTI);

    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
        !m_wndToolBar.SetButtons(buttons,
          sizeof(buttons)/sizeof(UINT)))
    {
        TRACE("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE("Failed to create status bar\n");
        return -1;      // fail to create
    }

    DragAcceptFiles();

    return 0;
}

afx_msg void CMainFrame::MyOnHelpIndex()
{
    // get path to graphedt.exe and keep just the directory name
    TCHAR szHelpPath[MAX_PATH];
    GetModuleFileName(0, szHelpPath, MAX_PATH);
    *_tcsrchr(szHelpPath, TEXT('\\')) = 0;

    // note: if you change the name of the help file, change
    // IDS_CANT_LOAD_HELP in graphedt.rc to match
    
    HINSTANCE h = ShellExecute(NULL, // hwnd
                               NULL, // verb (usually defaults to "open")
                               TEXT("graphedit.chm"),
                               NULL, // arguments
                               szHelpPath,
                               SW_SHOWNORMAL);

    if(h <= (HINSTANCE)32)
    {
        // docs say ShellExecute doesn't set the last error (but the
        // complicated -Ex version does), so just report some generic
        // rather than trying to decode the SE_ errors

        CString strMessage;
        strMessage.LoadString( IDS_CANT_LOAD_HELP );
        AfxMessageBox( strMessage );
    }
}

void CMainFrame::CreateSeekBar(CSeekDialog& wndSeekBar, WORD nMax, WORD nPageSize)
{
    HWND hWndSlider;

    wndSeekBar.Create(this, IDD_SEEKBAR, CBRS_TOP, IDW_SEEKBAR + m_nLastSeekBarID++);
    hWndSlider = ::GetDlgItem(wndSeekBar. m_hWnd, IDC_SEEKSLIDER);
    wndSeekBar.ShowWindow(m_bShowSeekBar? SW_SHOWNORMAL : SW_HIDE);
    wndSeekBar.EnableDocking(0);
    ::SendMessage(hWndSlider, TBM_SETRANGE, 0, MAKELONG( 0, nMax ));
    ::SendMessage(hWndSlider, TBM_SETPAGESIZE, 0, nPageSize);
    wndSeekBar.m_nMax = nMax;
    wndSeekBar.m_nPageSize = nPageSize;
    
    return;
}

void CMainFrame::SetSeekBar(CSeekDialog* pwndSeekBar)
{
    if (m_pCurrentSeekBar)
    {
        m_pCurrentSeekBar->ShowWindow(SW_HIDE);
    }
    m_pCurrentSeekBar = pwndSeekBar;
    if (m_pCurrentSeekBar)
    {
        m_pCurrentSeekBar->ShowWindow(m_bShowSeekBar? SW_SHOWNORMAL : SW_HIDE);
    }

    RecalcLayout();
}

BOOL CMainFrame::OnViewBar(UINT nID)
{
    if (nID != IDW_SEEKBAR)
    {
        // not for us. Should not happen
        return FALSE;
    }
    if (m_pCurrentSeekBar == NULL)
    {
        // no seek bar currently
        m_bShowSeekBar = !m_bShowSeekBar;
	return TRUE;
    }

    // toggle visible state
    
    m_bShowSeekBar = !m_bShowSeekBar;
    m_pCurrentSeekBar->ShowWindow(m_bShowSeekBar? SW_SHOWNORMAL : SW_HIDE);
    RecalcLayout();

    return TRUE;
}

void CMainFrame::OnUpdateSeekBarMenu(CCmdUI* pCmdUI)
{
    if (pCmdUI->m_nID != IDW_SEEKBAR)
    {
        // not for us. Should not happen
	pCmdUI->ContinueRouting();
        return;
    }
    pCmdUI->SetCheck(m_bShowSeekBar? 1 : 0);
}

void CMainFrame::OnCloseWindow()
{
    if (!MDIGetActive())
    {
        return;
    }
    MDIGetActive()->SendMessage(WM_CLOSE, 0, 0);
}

void CMainFrame::OnUpdateCloseWindow(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(MDIGetActive()? 1 : 0);
}

void CMainFrame::OnCloseAllWindows()
{
    CMDIChildWnd* p = MDIGetActive();
    CMDIChildWnd* pLast = NULL;

    while (p && p != pLast)
    {
        p->SendMessage(WM_CLOSE, 0, 0);
        pLast = p;
        p = MDIGetActive();
    }
}

void CMainFrame::OnUpdateCloseAllWindows(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(MDIGetActive()? 1 : 0);
}


void CMainFrame::OnCloseAllDocuments()
{
    CGraphDocTemplate* pDocTemplate = GBL(m_pDocTemplate);
    CBoxNetDoc* pDoc = NULL;
    int nCount = pDocTemplate->GetCount();
    int nLastCount = 0;

    while (nCount > 0 && nCount != nLastCount)
    {
        nLastCount = nCount;
        POSITION pos = pDocTemplate->GetFirstDocPosition();
        pDoc = (CBoxNetDoc*) pDocTemplate->GetNextDoc(pos);
        pDoc->Close();
        nCount = pDocTemplate->GetCount();
    }
}

void CMainFrame::OnUpdateCloseAllDocuments(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GBL(m_pDocTemplate)->GetCount() != 0);
}

BEGIN_MESSAGE_MAP(CSeekDialog, CDialogBar)
   //{{AFX_MSG_MAP(CSeekDialog)
    ON_WM_HSCROLL()
    ON_WM_TIMER()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSeekDialog::CSeekDialog()
: CDialogBar( )
{
    m_bDirty = FALSE;
    m_nLastCurrent = m_nLastMin = m_nLastMax = m_nLastSlider = ~0;
}

CSeekDialog::~CSeekDialog( )
{
}

void CSeekDialog::OnCancel( )
{
    ShowWindow( FALSE );
}

BOOL CSeekDialog::DidPositionChange( )
{
    if( m_bDirty )
    {
        m_bDirty = false;
        return true;
    }
    return false;
}

double CSeekDialog::GetPosition( )
{
    HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
    if( !h )
    {
        return 0.0;
    }

    LRESULT Pos = ::SendMessage( h, TBM_GETPOS, 0, 0 );
    return double( Pos ) / m_nMax;
}

CString CSeekDialog::Format(REFERENCE_TIME t)
{
    CString s;

    t /= 10000;   // Convert to msec

    int sec = (int) (t/1000);
    int msec = (int) (t - 1000*sec);
    int hr = sec/3600;
    int min = (sec - hr*3600)/60;
    sec = sec - hr*3600 - min*60;

    s.Format("%02d:%02d:%02d.%03d", hr, min, sec, msec);

    return s;
}

void CSeekDialog::SetPosition( double pos, REFERENCE_TIME StartTime, REFERENCE_TIME StopTime, REFERENCE_TIME CurrentTime  )
{
    HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
    if( !h )
    {
        long e = GetLastError( );
    }
    else
    {
        if (pos > 1.0) 
        {
            pos = 1.0;
        }
        ::SendMessage( h, TBM_SETSEL, (WPARAM)(BOOL) TRUE, (LPARAM)MAKELONG( 0, pos * m_nMax ) );
    }

    CString s;

    h = ::GetDlgItem( m_hWnd, IDC_MIN );
    if( !h )
    {
        long e = GetLastError( );
    }
    else
    {
        if (StartTime != m_nLastMin)
        {
            s = Format(StartTime);
            ::SendMessage( h, WM_SETTEXT, 0, (LPARAM) (const char*) s);
            m_nLastMin = StartTime;
        }
    }
    h = ::GetDlgItem( m_hWnd, IDC_MAX );
    if( !h )
    {
        long e = GetLastError( );
    }
    else
    {
        if (StopTime != m_nLastMax)
        {
            s = Format(StopTime);
            ::SendMessage( h, WM_SETTEXT, 0, (LPARAM) (const char*) s);
            m_nLastMax = StopTime;
        }
    }
    h = ::GetDlgItem( m_hWnd, IDC_CURRENT );
    if( !h )
    {
        long e = GetLastError( );
    }
    else
    {
        if (CurrentTime != m_nLastCurrent)
        {
            s = "Viewing: ";
            s += Format(CurrentTime);
            ::SendMessage( h, WM_SETTEXT, 0, (LPARAM) (const char*) s);
            m_nLastCurrent = CurrentTime;
        }
    }
    if (m_nLastSlider != ~0)
    {
        h = ::GetDlgItem( m_hWnd, IDC_SLIDER );
        if( !h )
        {
            long e = GetLastError( );
        }
        else
        {
            if (m_nLastMax > m_nLastMin)
            {
                REFERENCE_TIME SliderTime = (REFERENCE_TIME) (m_nLastMin + (m_nLastMax - m_nLastMin) * ((double) m_nLastSliderPos/m_nMax));
                if (SliderTime != m_nLastSlider)
                {
                    CString s = "Seek To: ";
                    s += Format(SliderTime);
                    ::SendMessage( h, WM_SETTEXT, 0, (LPARAM) (const char*) s);
                    m_nLastSlider = SliderTime;
                }
            }
        }
    }
}



void CSeekDialog::OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar )
{
    if (nSBCode != SB_THUMBTRACK)
    {
        m_bDirty = true;
    }
    HWND h = ::GetDlgItem( m_hWnd, IDC_SLIDER );
    if( !h )
    {
        long e = GetLastError( );
    }
    else if (nSBCode == SB_THUMBTRACK)
    {
        if (m_nLastMax > m_nLastMin)
        {
            REFERENCE_TIME SliderTime = (REFERENCE_TIME) (m_nLastMin + (m_nLastMax - m_nLastMin) * ((double) nPos/m_nMax));
            if (SliderTime != m_nLastSlider)
            {
                CString s = "Seek To: ";
                s += Format(SliderTime);
                ::SendMessage( h, WM_SETTEXT, 0, (LPARAM) (const char*) s);
                m_nLastSlider = SliderTime;
            }
            m_nLastSliderPos = nPos;
        }
    }
    else
    {
        ::SendMessage( h, WM_SETTEXT, 0, (LPARAM) "");
        m_nLastSlider = ~0;
    }
}


void CSeekDialog::OnTimer( UINT TimerID )
{
    static long counter = 0;
    counter++;
    if( counter < 30 )
    {
        return;
    }

    counter = 0;
    if( IsDlgButtonChecked( IDC_RANDOM ) )
    {
        long Pos = rand( ) % m_nMax;
        HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
        ::SendMessage( h, TBM_SETPOS, TRUE, Pos );
        m_bDirty = true;
    }
}

BOOL CSeekDialog::IsSeekingRandom( )
{
    return ::IsDlgButtonChecked( m_hWnd, IDC_RANDOM );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\propobj.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// propobj.cpp
//

// Implementation of CPropObject. See propobj.h


#include "stdafx.h"

// *
// * CPropObject
// *

IMPLEMENT_DYNAMIC(CPropObject, CObject)

//
// Constructor
//
CPropObject::CPropObject()
    : m_pDlg(NULL) {
}


//
// Destructor
//
CPropObject::~CPropObject() {

    DestroyPropertyDialog();

}


#ifdef _DEBUG
//
// AssertValid
//
void CPropObject::AssertValid(void) const {

    CObject::AssertValid();

}

//
// Dump
//
// Output this object to the supplied dump context
void CPropObject::Dump(CDumpContext& dc) const {

    CObject::Dump(dc);

    if (m_pDlg != NULL) {
        dc << CString("Dialog exists");
    }
    else {
        dc << CString("No dialog exists");
    }
}
#endif // _DEBUG


//
// CanDisplayProperties
//
// returns true if this object has at least one of IPin,
// IFileSourceFilter, ISpecifyPropertyPages, and IFileSinkFilter
//
// !!! this function tends to throw a lot of exceptions. I think using
// CQCOMInt may be inapropriate, or perhaps needs a 'do you support
// this?' function.
BOOL CPropObject::CanDisplayProperties(void) {

    try {

        CQCOMInt<ISpecifyPropertyPages> Interface(IID_ISpecifyPropertyPages, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    // we can display a page for each filters pin
    try {

        CQCOMInt<IBaseFilter> IFilt(IID_IBaseFilter, pUnknown());
        CPinEnum Next(IFilt);

        IPin *pPin;
	if (0 != (pPin = Next())) { // at least one pin
	    pPin->Release();
	    return TRUE;
	}
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IFileSourceFilter> Interface(IID_IFileSourceFilter, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IFileSourceFilter> Interface(IID_IFileSinkFilter, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IPin> Interface(IID_IPin, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    return FALSE;
}


//
// CreatePropertyDialog
//
// create & display the property dialog
// if called when the dialog exists, it shows the existing dialog
void CPropObject::CreatePropertyDialog(CWnd *pParent) {

    try {

        if (m_pDlg->GetSafeHwnd() == NULL) {

            CString szCaption = Label();
	    szCaption += CString(" Properties");

            delete m_pDlg;
            m_pDlg = new CVfWPropertySheet(pUnknown(), szCaption, pParent);

        }

    }
    catch (CHRESULTException) {

        AfxMessageBox(IDS_CANTDISPLAYPROPERTIES);
    }

    ShowDialog();

}


//
// DestroyPropertyDialog
//
// hide and destroy the property dialog
// Nul-op if the dialog does not exist
void CPropObject::DestroyPropertyDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {
        m_pDlg->DestroyWindow();
    }

    delete m_pDlg;
    m_pDlg = NULL;
}


//
// ShowDialog
//
// show the dialog in screen. nul-op if already on screen
void CPropObject::ShowDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {

        m_pDlg->ShowWindow(SW_SHOW);
	m_pDlg->SetForegroundWindow();
    }
}


//
// HideDialog
//
// hide the dialog. nul-op if already hidden
void CPropObject::HideDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {

        m_pDlg->ShowWindow(SW_HIDE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\link.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// link.h : declares CBoxLink
//

// forward declaration
class CBoxNetDoc;

/////////////////////////////////////////////////////////////////////////////
// CBoxLink -- defines a link between two box sockets

class CBoxLink : public CPropObject {

public:
    // pointers to the box sockets that this link connects
    CBoxSocket     *m_psockHead;        // head end of the link
    CBoxSocket     *m_psockTail;        // tail end of the link
    CBoxNetDoc 	   *m_pDoc;		// The document we belong to

public:
    // CBoxLink user interface

    void	    SetSelected(BOOL fSelected) { m_fSelected = fSelected; }
    BOOL	    IsSelected(void) { return m_fSelected; }

public:
    // CPropObject Overrides

    // As I always have an IPin I can always display properties
    virtual BOOL CanDisplayProperties(void) { return TRUE; }

    virtual CString Label(void) const { return CString("Link"); }

    // return Iunknown from one of our pins. it doesnt matter which.
    virtual IUnknown *pUnknown(void) const { ASSERT(m_psockHead); return m_psockHead->pUnknown(); }

private:

    BOOL	m_fSelected;	// Is this link selected?

    // construction and destruction
public:
    CBoxLink(CBoxSocket *psockTail, CBoxSocket *psockHead, BOOL fConnected = FALSE);
    ~CBoxLink();

public:

    #ifdef _DEBUG

    // diagnostics
    void Dump(CDumpContext& dc) const {
        CPropObject::Dump(dc);
    }
    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;

    #endif  _DEBUG

public:

    // -- Quartz --

    HRESULT Connect(void);
    HRESULT IntelligentConnect(void);
    HRESULT DirectConnect(void);
    HRESULT Disconnect(BOOL fRefresh = TRUE);

    BOOL    m_fConnected;
};


// *
// * CLinkList
// *
// A list of CBoxLinks
class CLinkList : public CDeleteList<CBoxLink *, CBoxLink *> {

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\link.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
// link.cpp : defines CBoxLinkBend, CBoxLink
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


void CBoxLink::MyDump(CDumpContext& dc) const
{
    dc << TEXT("*** Link ***\n");
    dc << TEXT("   Location:    ") << (void *) this << TEXT("\n");
    dc << TEXT("   Head Socket: ") << (void *) m_psockHead << TEXT("\n");
    dc << TEXT("   Tail Socket: ") << (void *) m_psockTail << TEXT("\n");
}


#endif



//
// CBoxLink::Constructor
//
// set fConnected (default FALSE) to true if constructing a
// link for an already connected pair of sockets.
CBoxLink::CBoxLink(CBoxSocket *psockTail, CBoxSocket *psockHead, BOOL fConnected)
    : m_psockTail(psockTail)
    , m_psockHead(psockHead)
    , m_fConnected(fConnected)
    , m_fSelected(  (psockTail->m_pbox->IsSelected())
                  ||(psockHead->m_pbox->IsSelected()))	// if either box is selected, then so is the link
    , m_pDoc(psockTail->m_pbox->pDoc()) {

    ASSERT(m_psockTail);
    ASSERT(m_psockHead);

    if (fConnected) {
        m_psockTail->m_plink = this;
        m_psockHead->m_plink = this;
    }

    ASSERT(m_pDoc);
	
    ASSERT(m_pDoc == psockHead->m_pbox->pDoc());
}


//
// CBoxLink::Destructor
//
// The link has a head and tail socket. We remove any references
// from the sockets to the link during deletion.
//
CBoxLink::~CBoxLink() {
    HideDialog();

    if (m_psockHead)
        m_psockHead->m_plink = NULL;

    if (m_psockTail)
        m_psockTail->m_plink = NULL;
}


//
// Connect
//
// Ask the filter graph to connect the filters at each end of this link
// Returns S_OK if directly connected
//         S_FALSE if indirectly (intelligently) connected
//         E_XXX in error cases.
HRESULT CBoxLink::Connect() {

    ASSERT_VALID(this);

    HRESULT hr = S_OK;

    if (!m_fConnected) {


	hr = DirectConnect();
	if (SUCCEEDED(hr)) {
	    return S_OK;
	}

        if (m_pDoc->m_fConnectSmart) {
            hr = IntelligentConnect();
            if (SUCCEEDED(hr)) {
                return S_FALSE;
            }
        }
    }

    return hr;	// may have been set to failure code by IntelligentConnect
}


//
// DirectConnect
//
// Connect this link to its sockets. Fail if a direct connection
// is not possible
HRESULT CBoxLink::DirectConnect(void) {

    ASSERT_VALID(this);

    if (!m_fConnected) {

        HRESULT hr;

	hr = m_pDoc->IGraph()->ConnectDirect(m_psockTail->pIPin(),	// i/p
					     m_psockHead->pIPin(),      // o/p
                                             NULL);
        if (FAILED(hr)) {
	    return hr;
	}

        // Even a direct connect can add extra connections from the deferred list.

#ifdef JoergsOldVersion
	m_psockHead->m_pbox->Refresh(); // refresh the box after a connection
	m_psockTail->m_pbox->Refresh(); // refresh the box after a connection

        // make the newly-connected sockets point to the link object
        m_psockTail->m_plink = this;
        m_psockHead->m_plink = this;
#endif
        m_pDoc->UpdateFilters();

        ASSERT(SUCCEEDED(hr));
	m_fConnected = TRUE;
    }

    return NOERROR;
}


//
// IntelligentConnect
//
// Ask the filter graph to connect the filters at each end of
// this link, using 'Intelligent connection'. If this suceeds you
// should delete this link, as the doc has had anything it needs added to it.
HRESULT CBoxLink::IntelligentConnect(void) {

    ASSERT_VALID(this);

    if (!m_fConnected) {

        TRACE("Trying intelligent connect\n");

        HRESULT hr = m_pDoc->IGraph()->Connect(m_psockTail->pIPin(),		// i/p
  				       m_psockHead->pIPin());
        if (FAILED(hr)) {
	    m_fConnected = FALSE;
	    TRACE("Error Connecting Filters\n");
	    return hr;
	}

        ASSERT(SUCCEEDED(hr));
	m_fConnected = FALSE;	// we have connected this link, but
				// it is about to be replaced by the stuff
				// the filtergraph added, so it is now 'hanging'

	m_pDoc->UpdateFilters();
    }

    return S_OK;
}


//
// Disconnect
//
// Ask the filter graph to disconnect the filters at each end of this link
//
// Only refreshes the boxes if fRefresh is TRUE.
//
HRESULT CBoxLink::Disconnect(BOOL fRefresh)
{

    ASSERT_VALID(this);

    HRESULT hr;

    //
    // m_psockHead & m_psockTail are both NULL or both non-NULL.
    //
    if (NULL == m_psockTail) {
        ASSERT(!m_psockHead);
        return(S_OK);
    }
    ASSERT(m_psockHead);

    hr = m_pDoc->IGraph()->Disconnect(m_psockTail->pIPin());
    ASSERT(SUCCEEDED(hr));

    hr = m_pDoc->IGraph()->Disconnect(m_psockHead->pIPin());
    ASSERT(SUCCEEDED(hr));

    m_psockHead->m_plink = NULL;
    m_psockTail->m_plink = NULL;

    if (fRefresh) {
        m_psockHead->m_pbox->Refresh(); // refresh the sockets after disconnect
        m_psockTail->m_pbox->Refresh(); // refresh the sockets after disconnect
    }

    m_psockHead = NULL;
    m_psockTail = NULL;

    m_fConnected = FALSE;

    return NOERROR;
}


#ifdef _DEBUG
void CBoxLink::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(m_pDoc);
    ASSERT(m_psockTail);
    ASSERT(m_psockHead);

    if (m_fConnected) {
        ASSERT(m_psockHead->m_plink == this);
	ASSERT(m_psockTail->m_plink == this);
    }
    else {
        ASSERT(m_psockHead->m_plink == NULL);
	ASSERT(m_psockTail->m_plink == NULL);
    }
}
#endif // _DEBUG

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\gutil.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// gutil.h
//
// Defines utility functions not specific to this application.
//

/////////////////////////////////////////////////////////////////////////////
// Utility integer and boolean functions:
//
// imin(i, j) returns the minimum of i and j.
// imax(i, j) returns the maximum of i and j.
// iabs(i) returns the absolute value of i.
// ibound(i, iLower, iUpper) returns i restricted to the range [iLower,iUpper].
// ioutbound(i, iLower, iUpper) returns 0 if i is in the range [iLower,iUpper],
//      or the amount by which i is outside that range otherwise.
// isnap(i, iGrid) returns multiple of iGrid nearest to i
// iswap(pi, pj) swaps <*pi> with <*pj>
// fnorm(f) "normalizes" BOOL value f, i.e. turns nonzero values into 1.
//

inline int imin(int i1 , int i2)
{
    if (i1 < i2)
        return i1;
    else
        return i2;
}

inline int imax(int i1 , int i2)
{
    if (i1 > i2)
        return i1;
    else
        return i2;
}

inline int iabs(int i)
{
    if (i < 0)
        return -i;
    else
        return i;
}

inline int ibound(int i, int iLower, int iUpper)
{
    if (i < iLower)
        i = iLower;
    else
    if (i > iUpper)
        i = iUpper;

    return i;
}

inline int ioutbound(int i, int iLower, int iUpper)
{
    if (i < iLower)
        return iLower - i;
    else
    if (i > iUpper)
        return i - iUpper;
    else
        return 0;
}

inline int isnap(int i, int iGrid)
{
    BOOL fNeg = (i < 0);                    // "%" isn't reliable for i < 0
    int j = (fNeg ? -i : i) + iGrid / 2;    // add half of <iGrid>
    int k = j - j % iGrid;                  // round down
    return (fNeg ? -k : k);
}

inline void iswap(long *pi, long *pj)
{
    long        iTmp;

    iTmp = *pi;
    *pi = *pj;
    *pj = iTmp;
}

inline BOOL fnorm(BOOL f)
{
    if (f)
        return 1;
    else
        return 0;
}


/////////////////////////////////////////////////////////////////////////////
// other utility functions
//


CSize inline PASCAL NegateSize(CSize siz)
{
    return CSize(-siz.cx, -siz.cy);
}


void FAR PASCAL NormalizeRect(CRect *prc);
void FAR PASCAL InvertFrame(CDC *pdc, CRect *prcOuter, CRect *prcInner);


//
// CDeleteList
//
// A CList that will optionally delete the objects it is
// storing in its destructor. Construct with parameter TRUE (the default)
// if you want objects deleted, use FALSE otherwise.
// Also provides a member to do delete & remove each item on the list
template<class TYPE, class ARG_TYPE>
class CDeleteList : public CList<TYPE, ARG_TYPE> {

public:

    CDeleteList(BOOL DestructDelete = TRUE) : m_DestructDelete(DestructDelete) {}
    CDeleteList(BOOL DestructDelete, int nBlockSize) : CList<TYPE, ARG_TYPE>(nBlockSize),
                                                       m_DestructDelete(DestructDelete) {}


    ~CDeleteList() {

        if (m_DestructDelete) {
            FreeAll();
        }
    }

    void DeleteRemoveAll(void) {  FreeAll(); }

protected:

    BOOL m_DestructDelete;

    void FreeAll(void) {

        while(GetCount() > 0) {
            delete RemoveHead();
        }
    }
};


//
// CFreeList
//
// A CObject version of a CDeleteList. Deletes its stored objects
// on destruction
class CFreeList : public CDeleteList<CObject *, CObject *> {

};


//
// CMaxList
//
// A CFreeList that is restricted to at most m_cObjMax objects.
// It deletes any surplus _at the next call_ that adds something.
// therefore the list can be temporarily longer.
class CMaxList : public CFreeList {
public:

    CMaxList(int nBlockSize = 3) : m_cObjMax(nBlockSize) {}

    POSITION AddHead(CObject* pobj) {
        RestrictLength();
        return CFreeList::AddHead(pobj);
    }

    POSITION AddTail(CObject* pobj) {
        RestrictLength();
        return CFreeList::AddTail(pobj);
    }

    void AddHead(CObList* pNewList) {
        RestrictLength();
        CFreeList::AddHead(pNewList);
    }

    void AddTail(CObList* pNewList) {
        RestrictLength();
        CFreeList::AddTail(pNewList);
    }

    POSITION InsertBefore(POSITION pos, CObject* pobj) {
        RestrictLength();
        return CFreeList::InsertBefore(pos, pobj);
    }

    POSITION InsertAfter(POSITION pos, CObject* pobj) {
        RestrictLength();
        return CFreeList::InsertAfter(pos, pobj);
    }

private:

    const int   m_cObjMax;      // max. number of objects in list

    void RestrictLength(void) {

        while (GetCount() >= m_cObjMax) {

            TRACE(TEXT("restrict length\n"));
            delete RemoveTail();
        }
    }

};


//
// --- Quartz Utilities ---
//
typedef HRESULT STDAPICALLTYPE OLECOCREATEPROC(REFCLSID,LPUNKNOWN,DWORD,REFIID,LPVOID *);

//
// CQCOMInt
//
// CCOMInt style class that uses the _real_, UNICODE, version of CoCreateInstance
// so that I can hack around MFCANS32 (wonderful tool that it is)
template<class I>
class CQCOMInt {

public:

    // -- Constructors --

    // CoCreate
    CQCOMInt<I>( REFIID    riid					// get this interface
               , REFCLSID  rclsid				// get the interface
    								// from this object
	       , LPUNKNOWN pUnkOuter    = NULL			// controlling unknown
               , DWORD     dwClsContext = CLSCTX_INPROC_SERVER	// CoCreate options
               							// default is suitable
               							// for dll servers
               ) {

        //
        // Library will be FreeLibrary'ed in the destructor. We don't unload
        // before to avoid unnecessary load / unloads of the library.
        //
	m_hLibrary = LoadLibrary("OLE32.dll");

	OLECOCREATEPROC *CoCreate = (OLECOCREATEPROC *) GetProcAddress(m_hLibrary, "CoCreateInstance");

        HRESULT hr = CoCreate( rclsid
	                     , pUnkOuter
                             , dwClsContext
                             , riid
                             , (void **) &m_pInt
                             );
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }

    // QueryInterface
    CQCOMInt<I>( REFIID   riid	// get this interface
              , IUnknown *punk	// from this interface
              ) {
	m_hLibrary = 0;
        HRESULT hr = punk->QueryInterface(riid, (void **) &m_pInt);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }

    // copy
    CQCOMInt<I>(const CQCOMInt<I> &com) {
	m_hLibrary = 0;
         m_pInt = com;
         (*this)->AddRef();

    }

    // existing pointer.
    CQCOMInt<I>(I *pInt) {
	m_hLibrary = 0;
        if (pInt == NULL) {
            throw CHRESULTException(E_NOINTERFACE);
        }

        m_pInt = pInt;

	(*this)->AddRef();
    }


    // assignment operator
    virtual CQCOMInt<I>& operator = (const CQCOMInt<I> &com) {

        if (this != &com) { 	// not i = i

	    (*this)->Release();
            m_pInt = com;
            (*this)->AddRef();
	}

        return *this;
    }


    // destructor
    virtual ~CQCOMInt<I>() {
        m_pInt->Release();

	if (m_hLibrary)
            FreeLibrary(m_hLibrary);
    }


    // -- comparison operators --
    virtual BOOL operator == (IUnknown *punk) const {

        CQCOMInt<IUnknown> IUnk1(IID_IUnknown, punk);
        CQCOMInt<IUnknown> IUnk2(IID_IUnknown, *this);

        return ( ((IUnknown *)IUnk1) == ((IUnknown *)IUnk2) );
    }

    virtual BOOL operator != (IUnknown *punk) const {

        return !(*this == punk);
    }


    // cast to interface pointer
    virtual operator I *() const { return m_pInt; }


    // dereference
    virtual I *operator->() { return m_pInt; }

    virtual I &operator*() { return *m_pInt; }

private:

    I *m_pInt;

    HINSTANCE m_hLibrary;    // remember the handle to the library for FreeLibrary

    // array dereferencing seems to make no sense.
    I &operator[] (int i) { throw CHRESULTException(); return *m_pInt; }
};


//
// CIPin
//
// Wrapper for the IPin interface
class CIPin : public CQCOMInt<IPin> {

public:

    CIPin(IPin *pIPin) : CQCOMInt<IPin>(pIPin) {}
    virtual ~CIPin() {}

    BOOL  operator == (CIPin& pin);	// tests the names to be equal.
    BOOL  operator != (CIPin& pin) { return !(pin == *this); }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\qerror.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// qerror.h

void DisplayQuartzError( HRESULT hr );
void DisplayQuartzError( UINT nID, HRESULT hr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\propsht.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// propsht.cpp
//

#include "stdafx.h"

//
// Define the GUIDs for the property pages and their interfaces
//
#include <initguid.h>
#include <propguid.h>

BEGIN_MESSAGE_MAP(CVfWPropertySheet, CPropertySheet)

    ON_WM_CREATE()

    ON_COMMAND(IDOK, OnOK)
    ON_COMMAND(IDCANCEL, OnCancel)
    ON_COMMAND(IDC_APPLY, OnApply)
    ON_COMMAND(IDC_PROP_HELP, OnHelp)

END_MESSAGE_MAP()

//
// Constructor
//
// Through the IUnknown pointer passed to us we might be able to
// get:
//
//   IBaseFilter, IPin, IFileSourceFilter, IFileSinkFilter or ISpecifyPropertyPages
//
// each of these has at least one IPropertyPage interface for us.
// (the ones for IBaseFilter, IPin, IFileSinkFilter and IFileSourceFilter
// are provided by proppage.dll )
//
CVfWPropertySheet::CVfWPropertySheet(IUnknown *pUnknown, CString szCaption, CWnd * wnd)
  : m_butOK(NULL)
  , m_fButtonsCreated(FALSE)
  , m_butApply(NULL)
  , m_butCancel(NULL)
  , m_butHelp(NULL)
  , m_fAnyChanges(FALSE)
  , CPropertySheet(szCaption, wnd)
{
    UINT iPages = 0;

    try {
        //
        // Create the four buttons
        //
        m_butOK     = new CButton();
        m_butCancel = new CButton();
        m_butApply  = new CButton();
        m_butHelp   = new CButton();

        //
        // First check whether this is a connected pin to make sure 
        // that we search both pins for SpecificPages
        //
        try {
            CQCOMInt<IPin> pPin(IID_IPin, pUnknown);

            IPin * pConnected = NULL;
            HRESULT hr = pPin->ConnectedTo( &pConnected );
            if( SUCCEEDED( hr ) )
            {
                // handle the connected pin first
                iPages += AddSpecificPages(pConnected);
                pConnected->Release();
            }                
        }
        catch (CHRESULTException) {
            // do nothing
        }

        iPages += AddSpecificPages(pUnknown);
        iPages += AddFilePage(pUnknown);
        iPages += AddPinPages(pUnknown);

        if (0 == iPages) {
            throw CE_FAIL();
        }


        // compute dimensions large enough to hold largest
        // proppage. tell all proppages.
        // 
        SIZE sizeMax = {0, 0};
        CPropertyPage *ppTmp;
        for(int iPage = 0; iPage < GetPageCount() && (ppTmp = GetPage(iPage)); iPage++)
        {
            CPropertySite *pcps = (CPropertySite *)ppTmp;
            SIZE size = pcps->GetSize();
            sizeMax.cx = max(sizeMax.cx, size.cx);
            sizeMax.cy = max(sizeMax.cy, size.cy);
        }
        for(iPage = 0; iPage < GetPageCount() && (ppTmp = GetPage(iPage)); iPage++)
        {
            CPropertySite *pcps = (CPropertySite *)ppTmp;
            pcps->InitialiseSize(sizeMax);
        }



        // create the property sheet but leave it invisible as we
        // will have to add the buttons to it
        if (!Create(wnd, WS_SYSMENU | WS_POPUP | WS_CAPTION | DS_MODALFRAME)) {
            throw CE_FAIL();
        }

		ASSERT( GetActivePage() );
		ASSERT( GetActivePage()->m_hWnd );

        CRect rcBoxSize(0, 0, 50, 14);
        GetActivePage()->MapDialogRect(&rcBoxSize);

        CString szTemp;

        szTemp.LoadString(IDS_OK);
        m_butOK->Create(szTemp,
                        BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                        | WS_TABSTOP | WS_GROUP,
                        rcBoxSize, this, IDOK);

        szTemp.LoadString(IDS_CLOSE);
        m_butCancel->Create(szTemp,
                            BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                            | WS_TABSTOP | WS_GROUP,
                            rcBoxSize, this, IDCANCEL);

        szTemp.LoadString(IDS_APPLY);
        m_butApply->Create(szTemp,
                           BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                           | WS_TABSTOP | WS_GROUP | WS_DISABLED,
                           rcBoxSize, this, IDC_APPLY);

        szTemp.LoadString(IDS_HELP);
        m_butHelp->Create(szTemp,
                          BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                          | WS_TABSTOP | WS_GROUP | WS_DISABLED,
                          rcBoxSize, this, IDC_PROP_HELP);


        //
        // Position the buttons on the property sheet
        //
        // The buttons are in the order Ok, Cancel, Apply and Help.
        //
        // The y-coordinate is 2 dialog units + the buttons size from the
        // bottom of the client area.
        //
        // On the x-coordinate there is a gap of 4 dialog units before each
        // button. Thus the x-ths button has a gap of
        //
        //    x * iSpacing + (x-1) * ButtonWidth
        //
        // between itself and the lefthand corner.
        //
        CRect rc, rcClient;
        GetWindowRect(&rc);
        GetClientRect(&rcClient);

        CRect rcSpacing(4, 2, 0, 0);
        GetActivePage()->MapDialogRect(&rcSpacing);
        const int iXSpacing = rcSpacing.left;
        const int iYSpacing = rcSpacing.top;

        // Make sure that the property page is wide enough for the buttons
		int iRight = rcClient.left + ( rcBoxSize.Width() + iXSpacing) * 4;

        if( rcClient.right < iRight )
            rc.right += rcClient.left + (iRight - rcClient.right);

        // increase the property sheet so there is space for our
        // buttons
        rc.bottom += rcBoxSize.Height() + iYSpacing * 2;

		MoveWindow( &rc );

        // to position the buttons we need the client rect (window - title)
        GetClientRect( &rc );

        m_butOK->MoveWindow( iXSpacing,
                                rc.Height() - rcBoxSize.Height() - iYSpacing,
                                rcBoxSize.Width(),
                                rcBoxSize.Height(),
                                SWP_SHOWWINDOW );

        m_butCancel->MoveWindow( 2 * iXSpacing + rcBoxSize.Width(),
                                 rc.Height() - rcBoxSize.Height() - iYSpacing,
                                 rcBoxSize.Width(),
                                 rcBoxSize.Height());

        m_butApply->MoveWindow( 3* iXSpacing + 2 * rcBoxSize.Width(),
                                rc.Height() - rcBoxSize.Height() - iYSpacing,
                                rcBoxSize.Width(),
                                rcBoxSize.Height());

        m_butHelp->MoveWindow( 4* iXSpacing + 3 * rcBoxSize.Width(),
                               rc.Height() - rcBoxSize.Height() - iYSpacing,
                               rcBoxSize.Width(),
                               rcBoxSize.Height());

        m_fButtonsCreated = TRUE;

        GetActiveSite()->UpdateButtons();

        ShowWindow( SW_SHOW );

    }
    catch (CHRESULTException) {
        Cleanup();
        throw;
    }

}


//
// Destructor
//
// Call Cleanup again - might have been missed.
//
CVfWPropertySheet::~CVfWPropertySheet()
{
    Cleanup();
}


//
// AddSpecificPages
//
// Given an IUnknown pointer we try to obtain a ISpecifyPropertyPages inter-
// face.
//
// If successful, a CPropertySite object is created for each IPropertyPage
// interface we obtain and added to the property pages of CPropertySheet.
//
UINT CVfWPropertySheet::AddSpecificPages(IUnknown *pUnknown)
{
    UINT iPages = 0;

    CAUUID cauuid;

    try {
        HRESULT hr;

        CQCOMInt<ISpecifyPropertyPages> IPages(IID_ISpecifyPropertyPages, pUnknown);

        hr = IPages->GetPages(&cauuid);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet (only place we get called from)
        return(0);  // no pages created
    }

    //
    // Get the array of GUIDs for the property pages this object supports.
    //
    // Try to create as many as possible.
    //

    for (UINT count = 0; count < cauuid.cElems; count++) {

        try {
            CPropertySite* pPropSite;

            try {
                pPropSite = new CPropertySite( this, &cauuid.pElems[count] );
            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                continue;
            }

            // AddRef the site now else something in Initialise
            // might cause the site to delete itself
            pPropSite->AddRef();

            if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
                pPropSite->CleanUp();
                pPropSite->Release();
                continue;
            }

            try {
                AddPage(pPropSite);
            } catch( CMemoryException* pOutOfMemory ) {
                pPropSite->CleanUp();
                pPropSite->Release();
                pOutOfMemory->Delete();
                continue;
            }

            iPages++;
        }
        catch (CHRESULTException) {
            // continue with next iteration
        }
    }
    
    // Free the memory allocated in ISpecifyPropertyPages::GetPages().
    ::CoTaskMemFree( cauuid.pElems );

    return(iPages);
}


//
// AddFilePage
//
// Queries IUnknown on whether it supports IFileSourceFilter. If this is
// the case add a file property page (from proppage.dll)
//
UINT CVfWPropertySheet::AddFilePage(IUnknown * pUnknown)
{
    UINT iPage = 0;

    try {
        CQCOMInt<IFileSourceFilter> IFileSource(IID_IFileSourceFilter, pUnknown);


        CPropertySite * pPropSite =
            new CPropertySite(this, &CLSID_FileSourcePropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        pPropSite->AddRef();

        if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPage++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    try {
        CQCOMInt<IFileSinkFilter> IFileSink(IID_IFileSinkFilter, pUnknown);


        CPropertySite * pPropSite =
            new CPropertySite(this, &CLSID_FileSinkPropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        pPropSite->AddRef();

        if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPage++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    return(iPage);
}

//
// AddPinPages
//
// Try to obtain IBaseFilter or IPin from IUnknown.
//
// For IBaseFilter, enumerate all pins and add for each a media type property
// page (provided by proppage.dll)
//
// For IPin, provide just one media type property page.
//
UINT CVfWPropertySheet::AddPinPages(IUnknown * pUnknown)
{
    UINT iPages = 0;
    IPin *pPin = NULL;

    //
    // First try to obtain the IBaseFilter interface
    //
    try {
        CQCOMInt<IBaseFilter> pFilter(IID_IBaseFilter, pUnknown);

        for (CPinEnum Next(pFilter); 0 != (pPin = Next()); iPages++) {

            CPropertySite *pPropSite =
                new CPropertySite(this, &CLSID_MediaTypePropertyPage);

            if (pPropSite == NULL) {
                throw CE_OUTOFMEMORY();
            }

            pPropSite->AddRef();
            if (FAILED(pPropSite->Initialise(1, (IUnknown **) &pPin))) {
                pPropSite->CleanUp();
                pPropSite->Release();
                throw CE_FAIL();
            }

            AddPage(pPropSite);
            iPages++;

            pPin->Release();
            pPin = NULL;
        }
    }
    catch (CHRESULTException) {
        if (pPin) {
            pPin->Release();
            pPin = NULL;
        }
    }

    //
    // Now try for IPin
    //
    try {
        CQCOMInt<IPin> pPin(IID_IPin, pUnknown);

        CPropertySite *pPropSite =
            new CPropertySite(this, &CLSID_MediaTypePropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        IPin * pIPin;   // temporary pointer to get proper (IUnknown **)

        pIPin = (IPin *) pPin;

        pPropSite->AddRef();
        if (FAILED(pPropSite->Initialise(1, (IUnknown **) &pIPin))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPages++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    return(iPages);
}

//
// OnCreate
//
int CVfWPropertySheet::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CPropertySheet::OnCreate(lpCreateStruct) != 0) {
        return -1;
    }

	// DO NOT add buttons here! Changes made to the window's size are
	// reset after this call

    return 0;
}

//
// Cleanup
//
// Cleanup deletes all created buttons and removes all CPropertySites from
// the CPropertySheet.
//
// This method can be run multiple times.
//
void CVfWPropertySheet::Cleanup()
{
    //
    // Delete all page sites. Note, we don't use delete, since the page
    // sites will be deleted automatically through the Release method
    // of their IUnknown interface.
    //
    while (GetPageCount() > 0) {
        CPropertySite * pPropSite = (CPropertySite *) GetPage(0);

        //
        // NOTE NOTE NOTE
        //
        // Suspected MFC bug.
        //
        // Intended code:
        //
        //   RemovePage(0);
        //
        // This asserts for every iteration. I believe that in mfc\src\dlgprop.cpp
        // in CPropertySheet::RemovePage(int), the following change is necessary:
        //    ASSERT(m_nCurPage != nPage); -> ASSERT(m_hWnd == NULL || m_nCurPage != nPage);
        //
        // Until this is fixed I am deleting the page by myself. This uses
        // the knowlegde that CPropertySheet is storing its CPropertyPages
        // in the pointer array m_pages.
        //
        //
        // <start hack>
        m_pages.RemoveAt(0);      // replace with "RemovePage(0);" once bug is fixed.
        // <end hack>

        pPropSite->CleanUp();
        pPropSite->Release();
    }

    //
    // Delete the buttons
    //
    delete m_butOK, m_butOK = NULL;
    delete m_butCancel, m_butCancel = NULL;
    delete m_butApply, m_butApply = NULL;
    delete m_butHelp, m_butHelp = NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// Button handlers
//
//////////////////////////////////////////////////////////////////////////

//
// OnOK
//
// We need to call IPropertyPage::Apply for the property page of each
// CPropertySite. If all return with S_OK we can close our property sheet.
// Otherwise we cannot close the sheet, since some changes might not been
// applied.
//
void CVfWPropertySheet::OnOK()
{
    UINT iPages = GetPageCount();
    BOOL fCanQuit = TRUE;

    //
    // Apply this site first, so we can stay on it if the data is not
    // valid.
    //
    GetActiveSite()->OnSiteApply();
    if (GetActiveSite()->IsPageDirty()) {
        //
        // Data on current page is not valid.
        // The page stays active.
        //

        return;
    }

    //
    // Apply each property page and verify that none remains dirty
    // after the apply.
    // If a page remains dirty we know that the data validation failed.
    //
    for (UINT count = 0; count < iPages; count++) {

        ((CPropertySite *) GetPage(count))->OnSiteApply();
        if (((CPropertySite *) GetPage(count))->IsPageDirty()) {
            fCanQuit = FALSE;
        }
    }

    if (fCanQuit) {
        //
        // All pages have been applied. We can destroy our pages by calling
        // the OnCancel method.
        //
        OnCancel();

        return;
    }
}

//
// OnCancel
//
// Just close the sheet. All changes since the last Apply() will not
// propagate to the objects.
//
void CVfWPropertySheet::OnCancel()
{
    //
    //
    //

    // don't use EndDialog, which is for modal dialog boxes
    DestroyWindow();

    // Do cleanup here, because in an OnDestroy method, we cannot
    // remove all property pages, since the last one requires
    // m_hWnd of CPropertySheet to be NULL.
    Cleanup();
}

//
// OnApply
//
// Only apply changes of present visible property page to object.
//
void CVfWPropertySheet::OnApply()
{
    //
    // Apply the changes
    //
    GetActiveSite()->OnSiteApply();

    //
    // Are there any pages left which are dirty? Set the m_fAnyChanges
    // flag accordingly.
    //
    m_fAnyChanges = FALSE;

    UINT iPages = GetPageCount();
    for (UINT count = 0; count < iPages; count++) {
        if ( ((CPropertySite *) GetPage(count))->IsPageDirty() ) {
            m_fAnyChanges = TRUE;
        }
    }
}

//
// OnHelp
//
// Delegate the call to CPropertySite::OnHelp
//
void CVfWPropertySheet::OnHelp()
{
    GetActiveSite()->OnHelp();
}


//
// UpdateButtons
//
void CVfWPropertySheet::UpdateButtons(HRESULT hrIsDirty, BOOL fSupportHelp)
{
    ASSERT(m_butApply && m_butCancel && m_butHelp);

    if (!m_fButtonsCreated) {
        return;
    }

    //
    // We can use this method to obtain notifications of dirty pages.
    //
    if (hrIsDirty == S_OK) {
        m_fAnyChanges = TRUE;
    }

    //
    // Update Apply button
    //
    if (hrIsDirty == S_OK) {
        // we have a dirty page - enable apply button
        m_butApply->EnableWindow();
    }
    else {
        m_butApply->EnableWindow(FALSE);
    }

    //
    // Update Cancel/Close button
    //
    CString szLabel;

    if (m_fAnyChanges) {
        szLabel.LoadString(IDS_CANCEL);
    }
    else {
        szLabel.LoadString(IDS_CLOSE);
    }

    m_butCancel->SetWindowText(szLabel);

    //
    // Update Help button
    //
    if (fSupportHelp) {
        m_butHelp->EnableWindow();
    }
    else {
        m_butHelp->EnableWindow(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\propsite.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// Implementation of the CPropertySite class
//

#include "stdafx.h"

//
// CPropertySite Message Map
//

BEGIN_MESSAGE_MAP(CPropertySite, CPropertyPage)

    ON_WM_CREATE()
    ON_WM_DESTROY()

END_MESSAGE_MAP()


//
// Constructor
//
CPropertySite::CPropertySite
  (
    CVfWPropertySheet *pPropSheet,    // The class providing the frame dialog
    const CLSID *clsid         // CLSID of object providing IPropertyPage
  )
  : m_hrDirtyPage(S_FALSE)
  , m_fHelp(FALSE)
  , m_pPropSheet(pPropSheet)
  , m_pIPropPage(IID_IPropertyPage, *clsid)
  , m_cRef(0)
  , m_fShowHelp(FALSE)
  , m_fPageIsActive(FALSE)
  , m_CLSID(clsid)
  , CPropertyPage()
{
      ASSERT(pPropSheet);

      m_PropPageInfo.pszTitle = NULL;
      m_PropPageInfo.pszDocString = NULL;
      m_PropPageInfo.pszHelpFile = NULL;
}

// size in pixels
void CPropertySite::InitialiseSize(SIZE size)
{
    DLGTEMPLATE *pdt = (DLGTEMPLATE *)m_pbDlgTemplate;

    pdt->style           = WS_CHILD | WS_VISIBLE | WS_DISABLED | WS_CAPTION;
    pdt->dwExtendedStyle = 0L;
    pdt->cdit            = 0;
    pdt->x               = 0;
    pdt->y               = 0;

    // even though we're using a system font, this doesn't work. don't
    // know why. The CPropertyPage does change the font to match the
    // property sheet, so perhaps that's why. The property sheet
    // hasn't been created yet, so not sure how to go about finding
    // out its font
    
//      DWORD dwBaseUnits;
//      SIZE sizeBaseUnit;
//      dwBaseUnits = GetDialogBaseUnits();
//      sizeBaseUnit.cx = LOWORD(dwBaseUnits);
//      sizeBaseUnit.cy = HIWORD(dwBaseUnits);

//      pdt->cx              = (short)(size.cx * 4 / sizeBaseUnit.cx);
//      pdt->cy              = (short)(size.cy * 8 / sizeBaseUnit.cy);
    
    pdt->cx              = (short)size.cx * 2 /3 ;
    pdt->cy              = (short)size.cy * 2 /3;


      // Add menu array, class array, dlg title
    WORD* pw = (WORD*)(pdt + 1);
    *pw++ = 0;                // Menu array 
    *pw++ = 0;                // Class array
    *pw++ = 0;                // Dlgtitle

    // check we didn't go over the end of m_pbDlgTemplate.
    ASSERT((BYTE*)pw <= ((BYTE*)m_pbDlgTemplate + sizeof(m_pbDlgTemplate)));

    m_psp.pResource = pdt;
    m_psp.dwFlags |= PSP_DLGINDIRECT;
    
}

//
// Initialise
//
// Performs initialisation for IPropertyPage which can fail.
// Not in constructor, since constructor should not fail.
//
// Arguments as for IPropertyPage::SetObjects.
//
HRESULT CPropertySite::Initialise(ULONG cObjects, IUnknown **pUnknown)
{
    HRESULT hr;

    //
    // Pointer should be AddRef'ed in IPropertyPage::SetPageSite and
    // any existing pointer should be released.
    //
    hr = m_pIPropPage->SetPageSite( (IPropertyPageSite *) this );
    if (FAILED(hr)) {
        return(hr);
    }

    hr = m_pIPropPage->SetObjects(cObjects, pUnknown);
    if (FAILED(hr)) {
        return(hr);
    }

    hr = m_pIPropPage->GetPageInfo(&m_PropPageInfo);
    if (FAILED(hr)) {
        return(hr);
    }

    //
    // Set flag for help button
    //
    m_fHelp = (m_PropPageInfo.pszHelpFile != NULL);

    //
    // Set the caption of the dialog to the information found in
    // m_PropPageInfo. (the tab string)
    //
    WideCharToMultiByte( CP_ACP, 0, (LPCWSTR) m_PropPageInfo.pszTitle, -1,
                         m_strCaption.GetBufferSetLength(300), 300, NULL, NULL);

#ifndef USE_MSVC20
    m_psp.pszTitle = m_strCaption;
    m_psp.dwFlags |= PSP_USETITLE;
#endif

    return(hr);
}

//
// CleanUp
//
// This method notifies the IPropertyPage to release all pointers to us.
// This cannot be done in the destructor since the destructor will not
// be called unless we are released by the IPropertyPage.
//
HRESULT CPropertySite::CleanUp()
{
    m_pIPropPage->SetObjects(0,NULL);
    m_pIPropPage->SetPageSite(NULL);

    return( NOERROR );
}

//
// Destructor
//
CPropertySite::~CPropertySite()
{
    //
    // Have we displayed a help file?
    //
    if (m_fShowHelp) {
        ::WinHelp(GetSafeHwnd(), NULL, HELP_QUIT, 0);
    }

    //
    // Need to CoTaskMemFree all strings in the page info structure
    //
    if (m_PropPageInfo.pszTitle) {
        CoTaskMemFree(m_PropPageInfo.pszTitle);
    }

    if (m_PropPageInfo.pszDocString){
        CoTaskMemFree(m_PropPageInfo.pszDocString);
    }

    if (m_PropPageInfo.pszHelpFile) {
        CoTaskMemFree(m_PropPageInfo.pszHelpFile);
    }

    ASSERT(m_cRef == 0);
}

//
// OnSiteApply
//
// Called from CVfWPropertySheet when the apply button has been pressed.
//
void CPropertySite::OnSiteApply()
{
    //
    // Call the property page's apply function
    //
    m_pIPropPage->Apply();

    //
    // Update our m_hrDirtyPage flag
    //
    m_hrDirtyPage = m_pIPropPage->IsPageDirty();

    m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
}

//
// OnHelp
//
// Called from CVfWPropertySheet when the help button has been pressed.
// First see if the IPropertyPage objects wants to handle the help
// itself, otherwise provide help with the help file specified in
// PROPERTYPAGEINFO.
//
void CPropertySite::OnHelp()
{
    TCHAR pszHelpPath[200];

    HelpDirFromCLSID( m_CLSID, pszHelpPath, sizeof(pszHelpPath));

    //
    // Let IPropertyPage deal with help first.
    //

    OLECHAR * polecHelpPath;

#ifndef UNICODE
    WCHAR cHelpPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszHelpPath, -1, cHelpPath, MAX_PATH);

    polecHelpPath = cHelpPath;
#else
    polecHelpPath = pszHelpPath;
#endif

    if (!FAILED(m_pIPropPage->Help( polecHelpPath ))) {
        m_fShowHelp = TRUE;

        return;
    }

    //
    // We have to provide help
    //

    //
    // Need to convert from OLECHAR (WCHAR) to TCHAR for WinHelp
    //
    TCHAR * ptchHelpFile;

#ifdef UNICODE
    ptchHelpFile = m_PropPageInfo.pszHelpFile;
#else
    char cHelpFile[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, m_PropPageInfo.pszHelpFile, -1, cHelpFile, MAX_PATH, NULL, NULL);

    ptchHelpFile = cHelpFile;
#endif

    m_fShowHelp = m_fShowHelp ||
        ::WinHelp(GetSafeHwnd(), ptchHelpFile, HELP_CONTEXT, 0);
}

//
// IsPageDirty
//
// Updates the m_hrDirtyPage variable and returns its new value
//
BOOL CPropertySite::IsPageDirty()
{
    m_hrDirtyPage = m_pIPropPage->IsPageDirty();

    return((m_hrDirtyPage == S_OK) ? TRUE : FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//
//////////////////////////////////////////////////////////////////////////

//
// AddRef
//
ULONG CPropertySite::AddRef()
{
    return ++m_cRef;
}

//
// Release
//
ULONG CPropertySite::Release()
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef == 0) {
        delete this;

        // don't return m_cRef, because the object doesn't exist anymore
        return((ULONG) 0);
    }

    return(m_cRef);
}

//
// QueryInterface
//
// We only support IUnknown and IPropertyPageSite
//
HRESULT CPropertySite::QueryInterface(REFIID riid, void ** ppv)
{
    if ((riid != IID_IUnknown) && (riid != IID_IPropertyPageSite)) {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    *ppv = (void *) this;

    //
    // We have to addref ourself
    //
    AddRef();

    return(NOERROR);
}

//////////////////////////////////////////////////////////////////////////
//
// IPropertyPageSite methods
//
//////////////////////////////////////////////////////////////////////////

//
// OnStatusChange
//
HRESULT CPropertySite::OnStatusChange(DWORD flags)
{
    HRESULT hr;
    BOOL bDirty = FALSE, bHandled = FALSE;

    // atl sends us VALIDATE OR'd with DIRTY
    if( PROPPAGESTATUS_VALIDATE & flags )
    {
        m_pIPropPage->Apply();
        bDirty = TRUE;
        bHandled = TRUE;
    }
            
    if( PROPPAGESTATUS_DIRTY & flags || bDirty )
    {
        //
        // Update the Site's flags for apply and cancel button
        // and call the property sheets OnStatusChange function
        //
        hr = m_pIPropPage->IsPageDirty();
        if (FAILED(hr)) {
            return(hr);
        }

        m_hrDirtyPage = m_pIPropPage->IsPageDirty();
        m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
        bHandled = TRUE;
    }
    
    return( bHandled ? S_OK : E_INVALIDARG );
}

//
// GetLocaleID
//
HRESULT CPropertySite::GetLocaleID(LCID *pLocaleID)
{
    if (pLocaleID == NULL) {
        return(E_POINTER);
    }

    *pLocaleID = GetThreadLocale();

    return(S_OK);
}

//
// GetPageContainer
//
// Function must fail by definition of IPropertyPageSite
//
HRESULT CPropertySite::GetPageContainer(IUnknown **ppUnknown)
{
    return(E_NOTIMPL);
}

//
// TranslateAccelerator
//
// We don't process the message, therefore we return S_FALSE.
//
HRESULT CPropertySite::TranslateAccelerator(LPMSG pMsg)
{
    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
// CPropertySite overrides
//
//////////////////////////////////////////////////////////////////////////

//
// OnSetActive
//
// Gets called from CVfWPropertySheet when our PropertyPage gains the focus.
// We call CPropertyPage::OnSetActive which will create a window for the
// page if not previously created.
//
// return:
//   Non-zero if the page was successfully set active.
//
BOOL CPropertySite::OnSetActive()
{
    if (!CPropertyPage::OnSetActive()) {
        return(FALSE);
    }

    if (!m_fPageIsActive) {
        if (FAILED(m_pIPropPage->Activate(GetSafeHwnd(), &m_rcRect, FALSE))) {
            return (FALSE);
        }
        if (FAILED(m_pIPropPage->Show(SW_SHOW))) {
            return (FALSE);
        }
    }

    m_fPageIsActive = TRUE;

    //
    // Also need to update the buttons
    //
    m_pPropSheet->UpdateButtons( m_hrDirtyPage, m_fHelp);

    return(TRUE);
}

//
// OnKillActive
//
// Called whenever our page loses the focus. At this point data verification
// should be made.
//
// return:
//   TRUE  - it is ok to lose focus
//   FALSE - keep the focus on our page
//
BOOL CPropertySite::OnKillActive()
{
    if (m_fPageIsActive) {
        HRESULT hr = m_pIPropPage->Deactivate();

        if (S_OK != hr) {
            return (FALSE);
        }
    }

    m_fPageIsActive = FALSE;

    return(CPropertyPage::OnKillActive());
}

//
// OnCreate
//
int CPropertySite::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    int iReturn = CPropertyPage::OnCreate(lpCreateStruct);
    if ( iReturn != 0) {
        return(iReturn);
    }

    GetClientRect(&m_rcRect);

    //
    // Leave space for a border
    //
    m_rcRect.InflateRect(-3, -2);

    return(0);
}

//
// OnDestroy
//
void CPropertySite::OnDestroy()
{
    CPropertyPage::OnDestroy();
}

//
// PreTranslateMessage
//
// Give IPropertyPage a chance to use the message. If not it has to pass
// it on to IPropertyPageSite (our interface), from where
// CPropertyPage::PreTranslateMessage is called.
//
// Conversions between HRESULT and BOOL and HRESULT have to be made.
//
// We expect as return value from IPropertyPage::TranslateAccelerator
//    S_OK - Message has been used.
//    S_FALSE - Message has not been used.
//    FAILED(hr) - Message has not been used.
//
// If the message has been used we return TRUE, otherwise FALSE.
// (our return value will determine whether this messages should still be
//  dispatched after we are finished with it).
//
BOOL CPropertySite::PreTranslateMessage(MSG *pMsg)
{
    if ( S_OK == m_pIPropPage->TranslateAccelerator(pMsg) ) {
        return(TRUE);
    }
    else {
        return( CPropertyPage::PreTranslateMessage(pMsg) );
    }
}


//
// HelpDirFromCLSID
//
// Get the help directory from the registry. First we look under
// "CLSID\<clsid>\HelpDir" if this is not given we will get the
// entry under "CLSID\<clsid>\InProcServer32" and remove the
// server file name.
//
// (this code is based on an example in MSDN, July 1995 - search for
// HelpDirFromCLSID in Title and Text)
//
// Note that dwPathSize should be given in Bytes.
//
void CPropertySite::HelpDirFromCLSID
 (
    const CLSID* clsID,
    LPTSTR pszPath,
    DWORD dwPathSize
 )

{
    TCHAR       szCLSID[80];
    TCHAR       szKey[512];
    HKEY        hKey;
    DWORD       dwLength;      // size of szCLSID in bytes and later
                               // temporary storage for dwPathSize
    long lReturn;

    //
    // Initialise pszPath
    //
    if (NULL==pszPath)
        return;

    *pszPath=0;

    //
    // Convert CLSID into a string
    //
    dwLength = sizeof(szCLSID) / sizeof(TCHAR);

#ifdef UNICODE
    StringFromGUID2(*clsID, szCLSID, dwLength);

#else
    WCHAR wszCLSID[128];
    StringFromGUID2(*clsID, wszCLSID, 128);

    WideCharToMultiByte(CP_ACP, 0, wszCLSID, -1, szCLSID, dwLength, NULL, NULL);
#endif

    //
    // Get handle to the HelpDir key.
    //
    wsprintf(szKey, TEXT("CLSID\\%s\\HelpDir"), szCLSID);

    lReturn = RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == lReturn) {

        //
        // Get the value from the HelpDir key.
        //
        dwLength = dwPathSize;
        lReturn = RegQueryValueEx(hKey, NULL, NULL, NULL,
                                  (LPBYTE) pszPath, &dwLength);

        RegCloseKey(hKey);

        if (ERROR_SUCCESS == lReturn) {
            return;
        }
    }

    //
    // Failure - need to get the path from the InProcServer32 entry
    //
    // Get handle to the Inproc key.
    //
    wsprintf(szKey, TEXT("CLSID\\%s\\InprocServer32"), szCLSID);

    lReturn = RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS != lReturn) {
        // we failed to get any path - return an emtpy string
        pszPath[0] = 0;
        return;
    }

    //
    // Get value of Inproc key.
    //
    dwLength = dwPathSize;
    lReturn = RegQueryValueEx(hKey, NULL, NULL, NULL,
                              (LPBYTE) pszPath, &dwLength);

    RegCloseKey(hKey);

    if (ERROR_SUCCESS != lReturn) {
        // we failed to get any path - return an empty string
        pszPath[0] = 0;
        return;
    }

    //
    // We need to strip of the server filename from the path.
    //
    // The filename extends from the end to the first '\\' or ':' or
    // the beginning of the string. We can therefore just
    // go to the end of the pszPath and then step backwards as long
    // as we are not in the beginning of pszPath or the char in front of us
    // is not a ':' or a '\\'.
    //

    //
    // Find end of pszPath (ie find the terminating '\0')
    //
    TCHAR * pNewEnd = pszPath;

    while (0 != *pNewEnd) {
        pNewEnd++;
    }

    //
    // Now go backwards as long as we are not at the beginning of the
    // string or we don't have a '\\' or ':' before us.
    //
    while ((pszPath != pNewEnd) &&
           (*(pNewEnd - 1) != TEXT(':')) &&
           (*(pNewEnd - 1) != TEXT('\\')) ) {
        pNewEnd--;
    }

    //
    // pNewEnd now points to the new end of the string the path without the
    // filename.
    //
    *pNewEnd = 0;

    return;
}

//
// UpdateButtons
//
// Called from the property sheet to notify us to call the sheet's
// UpdateButtons method with our parameters.
//
void CPropertySite::UpdateButtons()
{
    m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\propsite.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
#ifndef _PROPSITE_H_
#define _PROPSITE_H_

//
// CPropertySite
//
// This class implements the individual property sites for each
// IPropertyPage we have got. Ie. it manages the OLE control property page
// object for the overall property pages frame.
//
// The IPropertyPage talks through this class' IPropertySite interface
// to the PropertySheet, the overall frame of all property pages.
//
// The base class of CPropertySite is CPropertyPage. This class is a
// MFC class and should not be confused with the IPropertyPage interface.
//
//      IPropertyPage = Interface of some objects whose property page we
//                      want to display.
//
//      CPropertyPage = MFC class which helps us to implement the wrapper
//                      around the IPropertyPage interface.
//
// Note that the property page of IPropertyPage is implemented at a different
// location and will differ for each object. We only know that it supports
// the IPropertyPage interface through which we communicate with these objects.
//

class CPropertySite : public CPropertyPage, public IPropertyPageSite {

public:

    //
    // IPropertySite interface
    //
    STDMETHODIMP OnStatusChange(DWORD flags);
    STDMETHODIMP GetLocaleID(LCID *pLocaleID);
    STDMETHODIMP GetPageContainer(IUnknown **ppUnknown);
    STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

    //
    // IUnknown interface
    //
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // CPropertyPage overides
    //
    BOOL OnSetActive();     // This property page gains the focus.
    BOOL OnKillActive();    // This property page loses focus.
                            // Validate all data and return FALSE if an
                            // error occurs.
                            // Note, this does not commit the data!!

    int OnCreate(LPCREATESTRUCT);
    void OnDestroy();

    // Allow the size to be retrieved.
    SIZE GetSize( ){ return m_PropPageInfo.size; }

    //
    // OnOK and OnCancel are methods specified by CPropertyPage.
    // For modal property pages/sheets they get called from CPropertySheet.
    // Since we work with a modeless property sheet, they are of no use
    // for us. All OK and Cancel operations are managed by CPropertySheet
    //
    void OnOK() {}
    void OnCancel() {}

    //
    // CPropertySite methods
    //
    CPropertySite(CVfWPropertySheet *, const CLSID *);
    ~CPropertySite();

    HRESULT Initialise(ULONG, IUnknown **);       // must be called immeadetly after construction
    void InitialiseSize(SIZE size); // must be called before creating page
    
    void UpdateButtons();
    HRESULT CleanUp();

    void OnHelp();      // Called after the help button has been pressed.
    void OnSiteApply();     // Called after the apply button has been pressed.
    BOOL IsPageDirty();
    BOOL PreTranslateMessage(MSG *); // Called from CVfWPropertySheet.

protected:

    void HelpDirFromCLSID(const CLSID* clsID, LPTSTR pszPath, DWORD dwPathSize);

    CVfWPropertySheet * m_pPropSheet;  // pointer to the overall frame of all
                                // property sheets.

    //
    // Intelligent pointer to IPropertyPage. Creates the property page
    // object from a CLSID and Releases it on destruction.
    //
    CQCOMInt<IPropertyPage> m_pIPropPage;


    PROPPAGEINFO m_PropPageInfo; // Information on the property page we wrap

    //
    // m_hrDirtyPage indicates whether the page is dirty or clean
    //  -> (IPropertyPage::IsPageDirty == S_FALSE).
    // The state of this flag also specifies the appearance of the Apply
    // button. (S_FALSE = disabled, S_OK = enabled)
    //
    HRESULT m_hrDirtyPage;

    //
    // m_fHelp indicates whether the help button should be enabled.
    // This will be determined from the value of pszHelpFile in the
    // PROPPAGEINFO structure obtained from IPropertyPage::GetPageInfo
    //
    BOOL m_fHelp;

    //
    // Reference counter for IUnknown
    //
    ULONG m_cRef;

    // Rectangle of our site
    CRect m_rcRect;

    BOOL m_fShowHelp;     // True if we called WinHelp for this page

    // Flag whether this page is active - used to avoid duplicate calls
    // to IPropertyPage::Activate() (MFC calls OnSetActive twice).
    BOOL m_fPageIsActive;

    const CLSID* m_CLSID;

    // holds DLGTEMPLATE so we don't have to allocate it. dword
    // aligned.
    DWORD m_pbDlgTemplate[30];  

    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\propobj.h ===
// Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
//
// propobj.h
//

class CVfWPropertySheet;

//
// CPropObject
//
// A CObject derived class for objects that can display
// property page dialogs. classes such as CBoxLink, CBox &
// CBoxSocket are derived from this.
class CPropObject : public CObject {
protected:

    CPropObject();
    virtual ~CPropObject();

public:

#ifdef _DEBUG
    // -- CObject Derived diagnostics --
    virtual void AssertValid(void) const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // -- Property Dialog support --

    // true if a property dialog can be created for display
    virtual BOOL CanDisplayProperties(void);

    // create & display the property dialog
    // if called when the dialog exists, it shows the existing dialog
    // if pParent is null then the apps main window is the parent
    virtual void CreatePropertyDialog(CWnd *pParent = NULL);

    // hide and destroy the property dialog
    // Nul-op if the dialog does not exist
    virtual void DestroyPropertyDialog(void);

    // show the dialog in screen. nul-op if already on screen
    virtual void ShowDialog(void);

    // hide the dialog. nul-op if already hidden
    virtual void HideDialog(void);

public:
    // -- required helper functions --
    // these should be defined in a superclass, but they are not...

    virtual CString Label(void) const = 0;
    virtual IUnknown *pUnknown(void) const = 0;

    DECLARE_DYNAMIC(CPropObject)

private:

    CVfWPropertySheet *m_pDlg;	// the property sheet for all property pages
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\qerror.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// qerror.cpp

#include "stdafx.h"


void DisplayQuartzError( HRESULT hr )
{
    /* Message example
     *  <Error returned by AMGetErrorText>
     *
     */
    TCHAR szQMessage[MAX_ERROR_TEXT_LEN];

    if( AMGetErrorText( hr, szQMessage, MAX_ERROR_TEXT_LEN) > 0 ){
        AfxMessageBox( szQMessage );
    }

}

void DisplayQuartzError( UINT nID, HRESULT hr )
{
    /* Message example
     *  Unable to stop graph
     *
     *  Unspecified error (0x80004005)
     */
    CString strMessage;
    CString strCode;
    CString strCodeMessage;
    TCHAR szQMessage[MAX_ERROR_TEXT_LEN];

    strMessage.LoadString( nID );
    strCode.FormatMessage( IDS_RETURN_CODE, hr );

    if( AMGetErrorText( hr, szQMessage, MAX_ERROR_TEXT_LEN) > 0 ){
        strCodeMessage = szQMessage + CString(" ");
    }

    strMessage += "\n\n" + strCodeMessage + strCode;

    AfxMessageBox( strMessage );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\propsht.h ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef _PROPSHT_H_
#define _PROPSHT_H_

//
// CVfWPropertySheet
//
// Modification of CPropertySheet to allow for OK, Cancel, Apply and Help
// buttons for modeless property sheets.
//
class CPropertySite;

class CVfWPropertySheet : public CPropertySheet {

public:
    // Pass IUnknown of the object we want the property sheet for.
    // CString holds the title of the property sheet and
    // CWnd indicates the parent window (NULL = the application window).
    CVfWPropertySheet(IUnknown *, CString, CWnd * = NULL);
    virtual ~CVfWPropertySheet();

    // CPropertySheet methods
    INT_PTR DoModal() { ASSERT(!TEXT("No modal mode supported")); return 0; }

    // CVfWPropertySheet methods
    void UpdateButtons(HRESULT hrIsDirty, BOOL fSupportHelp);

protected:

    // OK, Cancel, Apply and Help buttons
    CButton *m_butOK;
    CButton *m_butCancel;
    CButton *m_butApply;
    CButton *m_butHelp;

    // Flags on the state of all property pages.
    BOOL m_fAnyChanges;      // TRUE = some property page is dirty

    // Message handlers for the buttons
    void OnOK();
    void OnCancel();
    void OnApply();
    void OnHelp();

    // Helper methods to obtain property pages from IUnknown passed in
    // constructor.
    UINT AddSpecificPages(IUnknown *);
    UINT AddFilePage(IUnknown *);
    UINT AddPinPages(IUnknown *);

    // Return the active site
    CPropertySite * GetActiveSite() {
        return((CPropertySite *) GetActivePage());
    }

    // Free all memory of buttons and property sites.
    void Cleanup();

    // Add our own buttons
    afx_msg int OnCreate(LPCREATESTRUCT);
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fButtonsCreated;    // flag to indicate whether we can enable/disable
                               // the buttons yet.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\stdafx.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h
//
// Include file for standard system include files, or project specific include
// files that are used frequently, but are changed infrequently.
//

#include <afxwin.h>             // MFC core and standard components
#include <afxext.h>             // MFC extensions (including VB)
#include <afxole.h>             // MFC OLE2

#include <objbase.h>
#include <afxtempl.h>

#include <atlbase.h>

#include <strmif.h>
#include <windowsx.h>
#include <control.h>
#include <evcode.h>
#include <uuids.h>
#include <vfwmsgs.h>
#include <errors.h>

#include <hrExcept.h>           // Exception classes
#include <comint.h>             // COM interface helper
#include <multistr.h>           // MultiByteToWideChar Helper

#include <olectl.h>

// #include <dvrds.h>              // DVR/TS stuff
// #include <dvrdspriv.h>

#include "resource.h"

#include "grftmpl.h"
#include "mainfrm.h"
#include "childfrm.h"
#include "gutil.h"              // general utilities, list classes etc
#include "enum.h"               // IEnumXXX wrappers

#include "propobj.h"            // Objects which support property browsing
#include "propsht.h"        // Property Sheet class
#include "propsite.h"       // Property Site class
#include "box.h"                // filter & box objects
#include "link.h"               // connection/link objects
#include "cmd.h"
#include "bnetdoc.h"
#include "boxdraw.h"
#include "bnetvw.h"

#include "graphedt.h"


#include "qerror.h"         // Error handling

#include <MultiGraphHost.h>
#include "sp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\reconfig.h ===
#ifndef Reconfigure_h
#define Reconfigure_h

#include <streams.h>

class CBoxNetDoc;

HRESULT PreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    );
HRESULT IfPossiblePreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    );

class CGraphConfigCallback : public CUnknown,
                             public IGraphConfigCallback
{
public:
    CGraphConfigCallback( const TCHAR* pName, LPUNKNOWN pUnk );

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void** ppv );

private:
};

class CPrintGraphAsHTMLCallback : public CGraphConfigCallback 
{
public:
    CPrintGraphAsHTMLCallback();

    void SafePrintGraphAsHTML( HANDLE hFile );
    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );

    struct PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL 
    {
        CBoxNetDoc* pDocument;
        HANDLE hFileHandle;
    };
};

class CUpdateFiltersCallback : public CGraphConfigCallback
{
public:
    CUpdateFiltersCallback();

    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );
};

class CEnumerateFilterCacheCallback : public CGraphConfigCallback
{
public:
    CEnumerateFilterCacheCallback();

    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );
};

#endif // Reconfigure_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\rndrurl.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// rndrurl.h

#ifndef __RENDER_URL__
#define __RENDER_URL__

#define URL_LIST_SIZE 6

typedef char URLSTRING[INTERNET_MAX_URL_LENGTH];
class CRenderURL : public CDialog
{
public:
    ~CRenderURL();
    CRenderURL(char *szFileName, int cb, CWnd * pParent = NULL );

protected:

    BOOL OnInitDialog();
    void DoDataExchange(CDataExchange* pDX);

    virtual void OnOK();


    DECLARE_MESSAGE_MAP()

private:
    CComboBox m_ComboBox;
    int m_iURLListLength;
    int m_iCurrentSel;
    char *m_psz;
    int m_cb;
    URLSTRING m_rgszURL[URL_LIST_SIZE];
};

#endif // __RENDER_URL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by graphedt.rc
//
#define IDR_MAINFRAME                   2
#define IDR_GRAPH                       3
#define ID_REMOVE_FILTER                4
#define IDS_STAT_DRAGLINKEND            11
#define IDS_STAT_DROPLINKEND            12
#define IDS_STAT_MOVEBOX                15
#define IDS_STAT_BOXTABEMPTY            17
#define IDS_STAT_SELECTRECT             19
#define IDD_ABOUTBOX                    100
#define IDC_APPLY                       101
#define ID_PROPBUTTONS                  102
#define IDB_EDGES                       103
#define IDC_PROP_HELP                   104
#define IDC_TRUNCATE                    105
#define IDB_TABS                        106
#define IDB_EDGES_HILITE                107
#define IDB_TABS_HILITE                 108
#define IDI_FILTER                      109
#define IDC_LIST1                       110
#define IDC_Refresh                     111
#define IDR_PINMENU                     112
#define IDR_FILTERMENU                  113
#define IDR_LINKMENU                    114
#define IDC_BUTTON4                     115
#define IDI_DOC                         116
#define IDS_VERSION                     118
#define ID__SELECTCLOCK                 119
#define IDB_CLOCK                       120
#define IDB_CLOCK_SELECT                121
#define IDS_MISSING_FILE_IN_GRAPH       122
#define IDC_FILTER_TREE                 123
#define IDD_FILTER_VIEW                 124
#define ID_ADDFILTER                    125
#define IDD_CONNECTTOGRAPH              126
#define IDS_FILENOTFOUND                127
#define IDS_ACCESSDENIED                128
#define IDS_NOTSTORAGEOBJECT            129
#define IDS_TOOMANYOPENFILES            130
#define IDS_INSUFFICIENTMEMORY          131
#define IDS_INVALIDNAME                 132
#define IDS_GENERAL_FILE_OPEN           133
#define IDS_FILE_ALREADY_OPEN           134
#define IDS_READ_ONLY                   135
#define IDS_PAUSE_TIMEOUT               136
#define IDS_DEVICE_NOT_READY            137
#define IDD_RENDER_URL                  138
#define IDC_URL_LIST                    139
#define IDC_CACHED_FILTERS              140
#define IDD_CACHED_FILTERS              141
#define IDD_STATS                       142
#define IDC_RESET                       143
#define IDD_TRUNCATE                    144
#define IDS_FAILED_TO_LOAD_GRAPH        145
#define IDD_SEEKBAR                     146
#define IDC_SEEKSLIDER                  147
#define IDC_RANDOM                      150
#define IDS_CMD_RECONNECT               151
#define ID_RECONNECT                    152
#define IDS_ASYNC_RECONNECT_SUCCEEDED   153
#define IDS_ASYNC_RECONNECT_FAILED      154
#define IDS_RECONNECT_PENDING           155
#define IDB_BITMAP1                     156
#define IDB_BITMAP2                     157
#define IDC_MIN                         157
#define IDC_MAX                         158
#define IDC_CURRENT                     159
#define IDC_SLIDER                      160
#define IDW_SEEKBAR                     500
#define IDS_CMD_MOVEBOX                 1000
#define IDS_CMD_MOVEBOXES               1001
#define IDS_CMD_ADDFILTER               1002
#define IDS_CMD_DELETE                  1003
#define IDS_CMD_CONNECT                 1005
#define IDS_CMD_ADD_FILTER_TO_CACHE     1006
#define stc32                           0x045f
#define IDS_MENU_UNDO                   2000
#define IDS_MENU_REDO                   2001
#define IDS_MENU_REPEAT                 2002
#define IDS_MEDIA_FILES                 2003
#define IDS_TEXT_FILES                  2004
#define IDS_SOURCE_DIALOG_TITLE         2005
#define IDS_SINK_DIALOG_TITLE           2006
#define IDS_UNCATEGORIZED_FILTERS       2007
#define ID_CANCEL_MODES                 32769
#define ID_FILE_RENDER                  32770
#define ID_FILE_SET_LOG                 32771
#define ID_EDIT_DELETE                  32778
#define ID_QUARTZ_DISCONNECT            32783
#define ID_QUARTZ_PAUSE                 32785
#define ID_QUARTZ_RUN                   32786
#define IDM_RENDER_PIN                  32787
#define ID_RENDER                       32789
#define ID_AUTOARRANGE                  32800
#define ID_WINDOW_REFRESH               32801
#define ID__PROPERTIES                  32803
#define IDM_SAVE_PERF_LOG               32805
#define ID_QUARTZ_STOP                  32807
#define ID_USE_CLOCK                    32808
#define ID_NEW_PERF_LOG                 32809
#define ID_CONNECT_SMART                32810
#define ID_SELECT_CLOCK                 32811
#define ID_INSERT_FILTER                32812
#define ID_FILE_SAVE_AS_HTML            32813
#define ID_URL_RENDER                   32814
#define ID_FILE_SAVE_AS_XML             32815
#define ID_WINDOW_ZOOM33                32816
#define ID_WINDOW_ZOOM50                32817
#define ID_WINDOW_ZOOM100               32818
#define ID_WINDOW_ZOOM200               32819
#define ID_CONNECT_TO_GRAPH             32820
#define ID_GRAPH_STATS                  32821
#define ID_GRAPH_ADDFILTERTOCACHE       32822
#define ID_GRAPH_ENUMCACHEDFILTERS      32823
#define ID_WINDOW_CLOSE                 32829
#define ID_WINDOW_CLOSEALL              32830
#define ID_WINDOW                       32832
#define ID_WINDOW_HIDE                  32833
#define ID_WINDOW_UNHIDE                32834
#define ID_GRAPH_EFFICIENTSEEKINGRANGE  32835
#define ID_OPTIONS_ENABLE_EFFICIENT_SEEKING 32836
#define ID_GRAPH_SEEK_BAR               32837
#define ID_FILE_CLOSEALL                32839
#define ID_GRAPH_FLOATINGSEEKTIMELINE   32840
#define IDS_CANTCONNECT                 61216
#define IDS_CANTINITQUARTZ              61217
#define IDS_CANTCREATEFILTER            61218
#define IDS_CANT_RENDER                 61219
#define IDS_CANT_RENDER_FILE            61220
#define IDS_CANT_ADD_SOURCE_FILE        61221
#define IDS_CANTCREATESOMEFILTER        61222
#define IDS_CANTPLAY                    61224
#define IDS_CANTPAUSE                   61225
#define IDS_CANTSTOP                    61226
#define IDS_CANTDISPLAYPROPERTIES       61227
#define IDS_CMD_DISCONNECTALL           61228
#define IDS_CMD_RENDER                  61229
#define IDS_CMD_RENDERFILE              61231
#define IDS_PINS_FAILED_TO_RENDER       61232
#define IDS_SAVE_PERF_LOG               61233
#define IDS_BAD_PERF_LOG                61234
#define IDS_EC_ERROR_ABORT              61235
#define IDS_IS_GRAPH_PLAYING            61236
#define IDS_NOINTERFACE                 61237
#define IDS_CLOSE                       61238
#define IDS_CANCEL                      61239
#define IDS_NO_DUMP_PROC                61240
#define IDS_DUMP_PROC                   61241
#define IDS_MEASURE_DLL                 61242
#define IDS_CANTSETCLOCK                61243
#define IDS_CONTROL_PROC                61244
#define IDS_NO_CONTROL_PROC             61245
#define IDS_CANT_ADD_FILTER             61246
#define IDS_CANTCONNECTINPUTS           61247
#define IDS_CANTCONNECTOUTPUTS          61248
#define IDS_OK                          61249
#define IDS_APPLY                       61250
#define IDS_HELP                        61251
#define IDS_NO_REFCLOCK                 61252
#define IDS_FAILED_SETSYNC              61253
#define IDS_FAILED_FILTER_FILE_LOAD     61254
#define IDS_FILE_SAVE_FAILED            61255
#define IDS_NO_TERMINATE_PROC           61256
#define IDS_TERMINATE_PROC              61257
#define IDS_RETURN_CODE                 61259
#define IDS_SAVE_HTML_EXT               61260
#define IDS_SAVE_HTML_FILTER            61261
#define IDS_SAVE_HTML_FILE_ERR          61262
#define IDS_SAVE_HTML_GRAPH_ERR         61263
#define IDS_SAVE_HTML_ERR               61264
#define IDS_SAVE_XML_EXT                61265
#define IDS_SAVE_XML_FILTER             61266
#define IDS_SAVE_XML_FILE_ERR           61267
#define IDS_SAVE_XML_GRAPH_ERR          61268
#define IDS_SAVE_XML_ERR                61269
#define IDS_CANT_CREATE_DIALOG          61270
#define IDS_GRAPHSPY_NOT_ENABLED        61273
#define IDS_CANT_LOAD_HELP              61274

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        160
#define _APS_NEXT_COMMAND_VALUE         32841
#define _APS_NEXT_CONTROL_VALUE         158
#define _APS_NEXT_SYMED_VALUE           156
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\reconfig.cpp ===
#include "stdafx.h"
#include "ReConfig.h"

/******************************************************************************
    Internal Constants
******************************************************************************/
static const DWORD RECONFIGURE_NO_FLAGS = 0;
static const HANDLE RECONFIGURE_NO_ABORT_EVENT = NULL;

/******************************************************************************
    Internal Declarations
******************************************************************************/
static HRESULT Reconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin );

template<class T> T* _CreateInstance( void )
{
    try
    {
        T* pNewObject = new T;
        pNewObject->AddRef();
        return pNewObject;
    } 
    catch( CMemoryException* pOutOfMemory )
    {
        pOutOfMemory->Delete();
        return NULL;
    }
}

/******************************************************************************
    Reconfigure Helper Functions
******************************************************************************/

/******************************************************************************

PreventStateChangesWhileOperationExecutes

    PreventStateChangesWhileOperationExecutes() ensures that other threads do 
not change the filter graph's state while IGraphConfigCallback::Reconfigure() 
executes.  If the current version of Direct Show does not support Dynamic Graph
Building, then this function fails.

Parameters:
- pGraphBuilder [in]
    The filter graph which WILL be locked.  Other threads cannot modify the
filter graph's state while it's locked.

- pCallback [in]
    The callback which will be called to preform a user defined operation.

- pReconfigureParameter [in]
    The pvConext parameters IGraphConfigCallback::Reconfigure() receives when
it's called.

Return Value:
    An HRESULT. S_OK if no error occur.  Otherwise, an error HRESULT.

******************************************************************************/
extern HRESULT PreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    )
{
    // The user should pass a valid IGraphBuilder object and a
    // valid IGraphConfigCallback object.
    ASSERT( (NULL != pGraphBuilder) && (NULL != pCallback) );

    IGraphConfig* pGraphConfig;

    // Does Direct Show supports Dynamic Graph Building?
    HRESULT hr = pGraphBuilder->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return hr; 
    }

    hr = pGraphConfig->Reconfigure( pCallback,
                                    (void*)pReconfigureParameter,
                                    RECONFIGURE_NO_FLAGS,
                                    RECONFIGURE_NO_ABORT_EVENT );
    pGraphConfig->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
} 

/******************************************************************************

IfPossiblePreventStateChangesWhileOperationExecutes

    If the current version of Direct Show supports Dynamic Graph Building, 
IfPossiblePreventStateChangesWhileOperationExecutes() ensures that other 
threads do not change the filter graph's state while 
IGraphConfigCallback::Reconfigure() executes.  If the current version of Direct
Show does not support Dynamic Graph Building, then the filter graph state 
should not change unless this thread changes it.  

Parameters:
- pGraphBuilder [in]
    The filter graph which MAY be locked.  Other threads cannot modify the
filter graph's state while it's locked.

- pCallback [in]
    The callback which will be called to preform a user defined operation.

- pReconfigureParameter [in]
    The pvConext parameters IGraphConfigCallback::Reconfigure() receives when
it's called.

Return Value:
    An HRESULT. S_OK if no error occur.  Otherwise, an error HRESULT.

******************************************************************************/
extern HRESULT IfPossiblePreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    )
{
    // The user should pass a valid IGraphBuilder object and a
    // valid IGraphConfigCallback object.
    ASSERT( (NULL != pGraphBuilder) && (NULL != pCallback) );

    IGraphConfig* pGraphConfig;

    // Does Direct Show supports Dynamic Graph Building?
    HRESULT hr = pGraphBuilder->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( SUCCEEDED( hr ) ) {
        // Dynamic Graph Building supported.
        hr = pGraphConfig->Reconfigure( pCallback,
                                        pReconfigureParameter,
                                        RECONFIGURE_NO_FLAGS,
                                        RECONFIGURE_NO_ABORT_EVENT );
        pGraphConfig->Release();
    
        if( FAILED( hr ) ) {
            return hr;
        }

    } else if( E_NOINTERFACE == hr ) {
        // Dynamic Graph Building is not supported.
        hr = pCallback->Reconfigure( pReconfigureParameter, RECONFIGURE_NO_FLAGS );
        if( FAILED( hr ) ) {
            return hr;
        }
       
    } else {
        return hr;
    }

    return S_OK;
}

/******************************************************************************
    CReconfigure Public Methods
******************************************************************************/

CGraphConfigCallback::CGraphConfigCallback( const TCHAR* pName, LPUNKNOWN pUnk ) :
    CUnknown( pName, pUnk )
{
}

STDMETHODIMP CGraphConfigCallback::NonDelegatingQueryInterface( REFIID riid, void** ppv )
{
    if( IID_IGraphConfigCallback == riid ) {
        return GetInterface( this, ppv );
    } else {
        return CUnknown::NonDelegatingQueryInterface( riid, ppv );
    }
}

/******************************************************************************
    CPrintGraphAsHTMLCallback Public Methods
******************************************************************************/
CPrintGraphAsHTMLCallback::CPrintGraphAsHTMLCallback() :
    CGraphConfigCallback( NAME("CPrintGraphAsHTMLCallback"), NULL )
{
}

STDMETHODIMP CPrintGraphAsHTMLCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL* pParameters = (PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL*)pvContext;
       
    CBoxNetDoc* pDoc = pParameters->pDocument;

    pDoc->PrintGraphAsHTML( pParameters->hFileHandle );

    return S_OK;
}

IGraphConfigCallback* CPrintGraphAsHTMLCallback::CreateInstance( void )
{
    return _CreateInstance<CPrintGraphAsHTMLCallback>();
}

/******************************************************************************
    CUpdateFiltersCallback Public Methods
******************************************************************************/
CUpdateFiltersCallback::CUpdateFiltersCallback() :
    CGraphConfigCallback( NAME("CUpdateFiltersCallback"), NULL )
{
}

STDMETHODIMP CUpdateFiltersCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    CBoxNetDoc* pDoc = (CBoxNetDoc*)pvContext;

    pDoc->UpdateFiltersInternal();

    return S_OK;
}

IGraphConfigCallback* CUpdateFiltersCallback::CreateInstance( void )
{
    return _CreateInstance<CUpdateFiltersCallback>();
}

/******************************************************************************
    CEnumerateFilterCacheCallback Public Methods
******************************************************************************/
CEnumerateFilterCacheCallback::CEnumerateFilterCacheCallback() :
    CGraphConfigCallback( NAME("CEnumerateFilterCacheCallback"), NULL )
{
}

STDMETHODIMP CEnumerateFilterCacheCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    CBoxNetDoc* pDoc = (CBoxNetDoc*)pvContext;

    pDoc->OnGraphEnumCachedFiltersInternal();

    return S_OK;
}

IGraphConfigCallback* CEnumerateFilterCacheCallback::CreateInstance( void )
{
    return _CreateInstance<CEnumerateFilterCacheCallback>();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\rndrurl.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <wininet.h>
#include "rndrurl.h"

char gszPersistPath[]="Software\\Microsoft\\ActiveMovie\\GraphEdit\\URLPersistList";

BEGIN_MESSAGE_MAP(CRenderURL, CDialog)
END_MESSAGE_MAP()

//
// Constructor
//
CRenderURL::CRenderURL(char *szURLName, int cb, CWnd * pParent): 
    CDialog(IDD_RENDER_URL, pParent) 
{
    m_iCurrentSel=0;
    m_iURLListLength=0;
    m_psz=szURLName;
    m_psz[0]='\0';
    m_cb = cb;
}

CRenderURL::~CRenderURL()
{
}

void CRenderURL::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);    

    //{{AFX_DATA_MAP(CFontPropPage)
        DDX_Control(pDX, IDC_URL_LIST, m_ComboBox);
    //}}AFX_DATA_MAP
}

BOOL CRenderURL::OnInitDialog()
{
    CDialog::OnInitDialog();

    //pre-allocate storage for the list box for efficiency
    m_ComboBox.InitStorage(URL_LIST_SIZE, INTERNET_MAX_URL_LENGTH);

    //set the max number of chars that will go in the edit box
    m_ComboBox.LimitText(sizeof(URLSTRING));

    // retrieve the persisted URL names from the registry
    HKEY hkey=NULL;
    DWORD dwaction=0;
    DWORD dwresult = RegCreateKeyEx(HKEY_CURRENT_USER, gszPersistPath,
    			0,
    			NULL, //class of the object type
    			REG_OPTION_NON_VOLATILE,
    			KEY_QUERY_VALUE,
    			NULL, // security attributes
    			&hkey,
    			&dwaction) ;
    if ( dwresult != ERROR_SUCCESS ) {
       AfxMessageBox("Failed to open/create registry key");
    }

    int i;
    for (i=0; i < URL_LIST_SIZE; ++i) {
        char szFile[10];
        char szFileNum[10];
        long lError;
        wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));
        DWORD cb=INTERNET_MAX_URL_LENGTH;
        lError = RegQueryValueEx(hkey, szFile, NULL, NULL, reinterpret_cast<BYTE *>(m_rgszURL[i]), &cb);
        // We never have a break in the sequence of URL names, if there are fewer
        // names than URL_LIST_SIZE we must be done
        if (lError != ERROR_SUCCESS)
            break;
    }

    RegCloseKey(hkey);

    m_iURLListLength=i;

    // fill the list of the combo box with the persisted URLs, fill the most recent
    // as the first entry in the list
    for (i=m_iURLListLength-1; i >=0; --i)  {
        int iPos=m_ComboBox.InsertString(m_iURLListLength-1-i, m_rgszURL[i]);
        ASSERT(iPos == m_iURLListLength-1-i);
    }

    // show the most recent URL in the edit box set the initial focus on the
    // combo box

    if (m_iURLListLength)
        m_ComboBox.SetWindowText(m_rgszURL[m_iURLListLength-1]);

    m_ComboBox.SetFocus();

    return(0); // we set the focus our selves
}

void CRenderURL::OnOK()
{
    // get the string in the edit box
    m_ComboBox.GetWindowText(m_psz, m_cb);
    if (strlen(m_psz) == 0)
        return;

    //if this string is in the combo box list, then there is nothing new to
    // persist
    if (m_ComboBox.FindStringExact(0, m_psz) != CB_ERR) {         
        CDialog::OnOK();
        return;
    }

    // otherwise save this URL path in the registry URL list
    HKEY hkey=NULL;
    DWORD dwaction=0;
    DWORD dwresult = RegCreateKeyEx(HKEY_CURRENT_USER, gszPersistPath,
    			0,
    			NULL, //class of the object type
    			REG_OPTION_NON_VOLATILE,
    			KEY_SET_VALUE,
    			NULL, // security attributes
    			&hkey,
    			&dwaction) ;
    if ( dwresult != ERROR_SUCCESS ) {
       AfxMessageBox("Failed to open/create registry key");
       return;
    }

    // if we have a full list, we will follow MRU and throw away the oldest added
    // URL
    int iList = (m_iURLListLength == URL_LIST_SIZE) ? m_iURLListLength-1 : m_iURLListLength;
    char szFile[10];
    char szFileNum[10];
    long lError;
    for (int i=0; i < iList; ++i) {
        wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));

        // if we have a full list, we will follow MRU and throw away the oldest added
        // URL
        if (m_iURLListLength == URL_LIST_SIZE)            
            lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
                reinterpret_cast<BYTE *>(m_rgszURL[i+1]), sizeof(m_rgszURL[i+1]));
        else 
            lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
                reinterpret_cast<BYTE *>(m_rgszURL[i]), sizeof(m_rgszURL[i]));

        if (lError != ERROR_SUCCESS) {
            AfxMessageBox("Failed to write to a registry key");
            RegCloseKey(hkey);
            return;
        }
    }

    // add the new URL to the list
    wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));
    lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
            reinterpret_cast<BYTE *>(m_psz), m_cb);

    RegCloseKey(hkey);

    if (lError != ERROR_SUCCESS) {
        AfxMessageBox("Failed to write to a registry key");
        return;
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\sp.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// sp.cpp : defines CMultiGraphHost and CMultiGraphHost
//

#include "stdafx.h"


STDMETHODIMP CMultiGraphHost::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (!ppv)
    {
        hr = E_POINTER;
    }
    else if (IsEqualGUID(IID_IMultiGraphHost, riid))
    {
        *ppv = (IMultiGraphHost*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else if (IsEqualGUID(IID_IUnknown, riid))
    {
        *ppv = (IUnknown*) (IMultiGraphHost*) this;
        ((IUnknown *) *ppv)->AddRef();

        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppv = NULL;
    }
    return hr;

} 

STDMETHODIMP_(ULONG) CMultiGraphHost::AddRef()
{
    LONG nNewRef = ::InterlockedIncrement((PLONG) &m_nRefCount);

    return nNewRef <= 0? 0 : (ULONG) nNewRef;
}


STDMETHODIMP_(ULONG) CMultiGraphHost::Release()
{
    LONG nNewRef = ::InterlockedDecrement((PLONG) &m_nRefCount);

    if (nNewRef == 0)
    {
        delete this;
    }

    return nNewRef <= 0? 0 : (ULONG) nNewRef;
} 

STDMETHODIMP CMultiGraphHost::CreateGraph(IGraphBuilder** ppGraph)
{
    if (!ppGraph)
    {
        return E_POINTER;
    }

    *ppGraph = NULL;

    // No nice way of doing this short of copying CMultiDocTemplate::OpenDocumentFile
    // to get the real document created. The following will serve for our purposes
    // although it's not really thread safe.

    CPtrArray docArray;
    CGraphDocTemplate* pDocTemplate = m_pApp->m_pDocTemplate;
    docArray.SetSize(pDocTemplate->GetCount());
    POSITION pos = pDocTemplate->GetFirstDocPosition();
    int nCount = 0;
    
    while (pos)
    {
        docArray[nCount++] = (void*) pDocTemplate->GetNextDoc(pos);
    }

    AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_FILE_NEW, 0);

    pos = pDocTemplate->GetFirstDocPosition();
    int i = 0;
    CBoxNetDoc* pNew = NULL;
    
    while (pos)
    {
        CBoxNetDoc* pDoc = (CBoxNetDoc*) pDocTemplate->GetNextDoc(pos);
        if (!pDoc->IsNew())
        {
            continue;
        }
        for (i = 0; i < nCount; i++)
        {
            if (docArray[i] == (void*) pDoc)
            {
                break;
            }
        }
        if (i == nCount)
        {
            if (pNew)
            {
                // 2 new docs on the list
                return E_FAIL; // doesn't delete the doc we created - too bad
            }
            pNew = pDoc;;
        }
    }
    if (!pNew)
    {
        return E_FAIL; // should not happen
    }
    pNew->IGraph()->AddRef();
    *ppGraph = pNew->IGraph();
    return S_OK;
}

CBoxNetDoc* CMultiGraphHost::FindDoc(IGraphBuilder* pGraph)
{
    if (!pGraph)
    {
        return NULL;
    }

    CGraphDocTemplate* pDocTemplate = m_pApp->m_pDocTemplate;
    POSITION pos = pDocTemplate->GetFirstDocPosition();
    CBoxNetDoc* pNew = NULL;
    
    while (pos)
    {
        CBoxNetDoc* pDoc = (CBoxNetDoc*) pDocTemplate->GetNextDoc(pos);
        if (pDoc->m_pGraph && pDoc->IGraph() == pGraph)
        {
            return pDoc;
        }
    }
    return NULL;
}

STDMETHODIMP CMultiGraphHost::RefreshView(IGraphBuilder* pGraph, BOOL bGraphModified)
{
    CBoxNetDoc* pDoc = FindDoc(pGraph);

    if (!pDoc)
    {
        return E_FAIL;
    }
    HRESULT hr = pDoc->UpdateFilters();
    pDoc->SetModifiedFlag(bGraphModified);
    return hr;
}

STDMETHODIMP CMultiGraphHost::LiveSourceReader(BOOL bAdd, IGraphBuilder* pGraph)
{
    CBoxNetDoc* pDoc = FindDoc(pGraph);

    if (!pDoc)
    {
        return E_FAIL;
    }
    pDoc->LiveSourceReader(bAdd);
    if (bAdd)
    {
        // Tell the filter to pause till we seek when the graph is played/paused.
    }
    return S_OK;
}

STDMETHODIMP CMultiGraphHost::FindFilter(CLSID clsid, DWORD* pNumFilters, IBaseFilter*** pppFilter, LPWSTR** pppFilterNames)
{
    if (!pNumFilters || !pppFilter)
    {
        return E_POINTER;
    }

    *pNumFilters = 0;
    *pppFilter = NULL;

    CPtrArray filterArray;
    CStringArray strArray;

    filterArray.SetSize(10);
    strArray.SetSize(10);
    int nCount = 0;

    CGraphDocTemplate* pDocTemplate = m_pApp->m_pDocTemplate;
    POSITION pos = pDocTemplate->GetFirstDocPosition();
    HRESULT hr;
    
    while (pos)
    {
        CBoxNetDoc* pDoc = (CBoxNetDoc*) pDocTemplate->GetNextDoc(pos);
        IFilterGraph* pFG;
        hr = pDoc->IGraph()->QueryInterface(IID_IFilterGraph, (void**) &pFG);
        if (FAILED(hr))
        {
            return hr;
        }

        IEnumFilters* pEnum;

        hr = pFG->EnumFilters(&pEnum);
        if (FAILED(hr))
        {
            pFG->Release();
            return hr;
        }
        do
        {
            ULONG n;
            IBaseFilter* pFilter;
            IPersist* pPersist;

            hr = pEnum->Next(1, &pFilter, &n);
            if (FAILED(hr)) 
            {
                for (int i = 0; i < nCount; i++)
                {
                    ((IBaseFilter*) filterArray[i])->Release();
                }
                pFG->Release();
                pEnum->Release();
                return hr;
            }

            // IEnumFilters::Next() returns S_OK if it has not finished enumerating the
            // filters in the filter graph.
            if (hr == S_FALSE)
            {
                break;
            }
            hr = pFilter->QueryInterface(IID_IPersist, (void**) &pPersist);
            if (FAILED(hr))
            {
                for (int i = 0; i < nCount; i++)
                {
                    ((IBaseFilter*) filterArray[i])->Release();
                }
                pFG->Release();
                pFilter->Release();
                pEnum->Release();
                return hr;
            }
            CLSID c;
            hr = pPersist->GetClassID(&c);
            pPersist->Release();
            if (FAILED(hr))
            {
                for (int i = 0; i < nCount; i++)
                {
                    ((IBaseFilter*) filterArray[i])->Release();
                }
                pFG->Release();
                pFilter->Release();
                pEnum->Release();
                return hr;
            }
            if (IsEqualGUID(clsid, c))
            {
                filterArray[nCount++] = pFilter;
                strArray[nCount++] = pDoc->GetTitle();
            }
            else
            {
                pFilter->Release();
            }
        }
        while (1);
        pFG->Release();
        pEnum->Release();
    }

    LPWSTR* ppNames = NULL;
    IBaseFilter** pp = NULL; 
    HRESULT hrFail = E_OUTOFMEMORY;

    if (nCount)
    {
        pp = (IBaseFilter**) CoTaskMemAlloc(nCount * sizeof(IBaseFilter*));
        if (pppFilterNames)
        {
            ppNames = (LPWSTR*) CoTaskMemAlloc(nCount * sizeof(LPWSTR));
        }
        if (!pp || (pppFilterNames && !ppNames))
        {
            goto Cleanup;
        }
        for (int i = 0; i < nCount; i++)
        {
            pp[i] = (IBaseFilter*) filterArray[i];
            if (ppNames)
            {
                ppNames[i] = NULL;
            }
        }
        if (ppNames)
        {
            HRESULT hr;
            FILTER_INFO fi;

            for (int i = 0; i < nCount; i++)
            {
                hr = ((IBaseFilter*) filterArray[i])->QueryFilterInfo(&fi);
                if (FAILED(hr))
                {
                    hrFail = hr;
                    goto Cleanup;
                }
                if (fi.pGraph)
                {
                    fi.pGraph->Release();
                }
                DWORD nLen = wcslen(fi.achName) + strArray[i].GetLength() + 9;
                ppNames[i] = (LPWSTR) CoTaskMemAlloc(nLen * sizeof(WCHAR));
                if (!ppNames[i])
                {
                    goto Cleanup;
                }
                wsprintfW(ppNames[i], L"\"%ls\" in \"%s\"", fi.achName, strArray[i]);
            }
            *pppFilterNames = ppNames;
        }
        *pNumFilters = nCount;
        *pppFilter = pp;

    }
    return S_OK;

Cleanup:
    for (int i = 0; i < nCount; i++)
    {
        ((IBaseFilter*) filterArray[i])->Release();
        if (ppNames && ppNames[i])
        {
            CoTaskMemFree(ppNames[i]);
        }
    }
    if (ppNames)
    {
        CoTaskMemFree(ppNames);
    }
    if (pp)
    {
        CoTaskMemFree(pp);
    }
    return hrFail;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\graphedt\graphedt\sp.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// sp.h: declares CFloatingTimelineSeekProvider and CMultiGraphHost
//


class CMultiGraphHost : public IMultiGraphHost
{
    LONG m_nRefCount;
    CGraphEdit* m_pApp;

public:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP CreateGraph(IGraphBuilder** ppGraph);
    STDMETHODIMP RefreshView(IGraphBuilder* pGraph, BOOL bGraphModified);
    STDMETHODIMP LiveSourceReader(BOOL bAdd, IGraphBuilder* pGraph);
    STDMETHODIMP FindFilter(CLSID clsid, DWORD* pNumFilters, IBaseFilter*** pppFilter, LPWSTR** pppFilterNames);
    

    CMultiGraphHost(CGraphEdit* pApp)
    {
        m_pApp = pApp;
        m_nRefCount = 0;
    }

    virtual ~CMultiGraphHost() {};

    CBoxNetDoc* FindDoc(IGraphBuilder* pGraph);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\dvrstats.cpp ===
#include "precomp.h"
#include "ui.h"
#include "controls.h"
#include "mp2demux.h"
#include "dvrdspriv.h"
#include "shared.h"
#include "statswin.h"
#include "dvrstats.h"

static
TCHAR *
CreatePinName (
    IN  int             iPinIndex,
    IN  PIN_DIRECTION   PinDirection,
    IN  int             iBufferLen,
    OUT TCHAR *         pchBuffer
    )
{
    int i ;

    assert (pchBuffer) ;
    assert (iBufferLen >= 16) ;

    if (PinDirection == PINDIR_INPUT) {
        //  input
        i = _sntprintf (
                pchBuffer,
                iBufferLen,
                TEXT ("DVR In - %d"),
                iPinIndex
                ) ;
    }
    else {
        //  output
        i = _sntprintf (
                pchBuffer,
                iBufferLen,
                TEXT ("DVR Out - %d"),
                iPinIndex
                ) ;
    }

    //  make sure it's capped off
    pchBuffer [i] = TEXT ('\0') ;

    return pchBuffer ;
}

TCHAR *
CreateOutputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    )
{
    return CreatePinName (
                iPinIndex,
                PINDIR_OUTPUT,
                iBufferLen,
                pchBuffer
                ) ;
}

TCHAR *
CreateInputPinName (
    IN  int     iPinIndex,
    IN  int     iBufferLen,
    OUT TCHAR * pchBuffer
    )
{
    return CreatePinName (
                iPinIndex,
                PINDIR_INPUT,
                iBufferLen,
                pchBuffer
                ) ;
}

static
enum {
    DVR_RECEIVER_STATS_STREAM_INDEX,
    DVR_RECEIVER_STATS_SAMPLES,
    DVR_RECEIVER_STATS_BYTES,
    DVR_RECEIVER_STATS_DISCONTINUITIES,
    DVR_RECEIVER_STATS_SYNCPOINTS,
    DVR_RECEIVER_STATS_LAST_PTS_DSHOW,
    DVR_RECEIVER_STATS_LAST_PTS_HMS,
    DVR_RECEIVER_STATS_WRITE_FAILURES,
    DVR_RECEIVER_STATS_BITRATE,

    //  always last
    DVR_RECEIVER_STATS_COUNTERS
} ;
//  keep in sync
static
COL_DETAIL
g_DVRReceiveStatsCol [] = {
    { __T("Pin"),               70 },
    { __T("Samples"),           60 },
    { __T("Bytes"),             60 },
    { __T("Disc."),             40 },
    { __T("Syncpoints"),        70 },
    { __T("PTS (dshow)"),       80 },
    { __T("PTS (hh:mm)"),       80 },
    { __T("Failures"),          70 },
    { __T("Mbps"),              50 },
} ;

CDVRReceiverSideStats::CDVRReceiverSideStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : m_pIDVRReceiverStats    (NULL),
        m_dwMillisLast          (0),
        m_pullBytesLast         (NULL),
        CLVStatsWin             (hInstance,
                                 hwndFrame,
                                 DVR_RECEIVER_STATS_COUNTERS,
                                 g_DVRReceiveStatsCol,
                                 0,
                                 pdw
                                 )
{
    HRESULT hr ;
    int     i ;
    TCHAR   ach [64] ;

    if ((* pdw) == NOERROR) {
        hr = CoCreateInstance (
                CLSID_DVRReceiverSideStats,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDVRReceiverStats,
                (void **) & m_pIDVRReceiverStats
                ) ;
        if (FAILED (hr)) {
            (* pdw) = ERROR_GEN_FAILURE ;
            goto cleanup ;
        }
    }

    hr = m_pIDVRReceiverStats -> GetStatsMaxStreams (& m_iMaxStatsStreams) ;
    if (SUCCEEDED (hr)) {
        m_pullBytesLast = new ULONGLONG [m_iMaxStatsStreams] ;
        if (m_pullBytesLast) {
            ZeroMemory (m_pullBytesLast, m_iMaxStatsStreams * sizeof ULONGLONG) ;
        }
        else {
            (* pdw) = ERROR_NOT_ENOUGH_MEMORY ;
            goto cleanup ;
        }
    }
    else {
        (* pdw) = ERROR_GEN_FAILURE ;
        goto cleanup ;
    }

    for (i = 0; i < m_iMaxStatsStreams; i++) {
        (* pdw) = InsertRow_ (i) ;
        if ((* pdw) == NOERROR) {
            CellDisplayText_ (i, DVR_RECEIVER_STATS_STREAM_INDEX, CreateInputPinName (i, 64, ach)) ;
        }
        else {
            goto cleanup ;
        }
    }

    cleanup :

    return ;
}

CDVRReceiverSideStats::~CDVRReceiverSideStats (
    )
{
    RELEASE_AND_CLEAR (m_pIDVRReceiverStats) ;
}

void
CDVRReceiverSideStats::Refresh (
    )
{
    int             i ;
    HRESULT         hr ;
    ULONGLONG       ullMediaSamplesIn ;
    ULONGLONG       ullTotalBytes ;
    ULONGLONG       ullDiscontinuities ;
    ULONGLONG       ullSyncPoints ;
    REFERENCE_TIME  rtLast ;
    DWORD           deltaBits ;
    DWORD           MillisNow ;
    DWORD           deltaMillis ;
    static TCHAR    ach [32] ;
    double          dMbps ;
    int             iHours ;
    int             iMinutes ;
    int             iSeconds ;
    int             iMillis ;
    ULONGLONG       ullWriteFailures ;

    assert (m_pIDVRReceiverStats) ;

    MillisNow       = GetTickCount () ;
    deltaMillis     = (m_dwMillisLast > 0 ? MillisNow - m_dwMillisLast : 0) ;
    m_dwMillisLast  = MillisNow ;

    for (i = 0; i < m_iMaxStatsStreams; i++) {
        hr = m_pIDVRReceiverStats -> GetStreamStats (
                    i,
                    & ullMediaSamplesIn,
                    & ullTotalBytes,
                    & ullDiscontinuities,
                    & ullSyncPoints,
                    & rtLast,
                    & ullWriteFailures
                    ) ;
        if (SUCCEEDED (hr) &&
            ullMediaSamplesIn > 0) {

            iMillis    = DShowTimeToMillis (rtLast) ;
            iSeconds   = iMillis / 1000 ; iMillis -= (iSeconds * 1000) ;
            iMinutes   = iSeconds / 60 ;  iSeconds -= (iMinutes * 60) ;
            iHours     = iMinutes / 60 ;  iMinutes -= (iHours * 60) ;

            CellDisplayValue_ (i, DVR_RECEIVER_STATS_SAMPLES,           ullMediaSamplesIn) ;
            CellDisplayValue_ (i, DVR_RECEIVER_STATS_BYTES,             ullTotalBytes) ;
            CellDisplayValue_ (i, DVR_RECEIVER_STATS_DISCONTINUITIES,   ullDiscontinuities) ;
            CellDisplayValue_ (i, DVR_RECEIVER_STATS_SYNCPOINTS,        ullSyncPoints) ;
            CellDisplayValue_ (i, DVR_RECEIVER_STATS_LAST_PTS_DSHOW,    rtLast) ;
            CellDisplayValue_ (i, DVR_RECEIVER_STATS_WRITE_FAILURES,    ullWriteFailures) ;

            _sntprintf (ach, 32, __T("%02d:%02d:%02d:%03d"), iHours, iMinutes, iSeconds, iMillis) ;
            CellDisplayText_ (i, DVR_RECEIVER_STATS_LAST_PTS_HMS,       ach) ;

            if (deltaMillis > 0) {
                deltaBits = (DWORD) (ullTotalBytes - m_pullBytesLast [i]) * 8 ;
                dMbps = (((double) deltaBits) / ((double) deltaMillis) * 1000.0) / 1000000.0 ;
            }
            else {
                dMbps = 0.0 ;
            }

            m_pullBytesLast [i] = ullTotalBytes ;

            _stprintf (ach, __T("%3.1f"), dMbps) ;
            CellDisplayText_ (i, DVR_RECEIVER_STATS_BITRATE, ach) ;
        }
        else {
            break ;
        }
    }
}

void
CDVRReceiverSideStats::Reset (
    )
{
    m_pIDVRReceiverStats -> Reset () ;
    ZeroMemory (m_pullBytesLast, m_iMaxStatsStreams * sizeof ULONGLONG) ;
    return ;
}

CDVRReceiverSideStats *
CDVRReceiverSideStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CDVRReceiverSideStats * pDVRReceiverStats ;
    DWORD                   dwRet ;

    pDVRReceiverStats = new CDVRReceiverSideStats (
                                    hInstance,
                                    hwndFrame,
                                    & dwRet
                                    ) ;
    if (!pDVRReceiverStats ||
        dwRet != NOERROR) {

        DELETE_RESET (pDVRReceiverStats) ;
    }

    return pDVRReceiverStats ;
}

//  ============================================================================
//  ============================================================================

static
enum {
    DVR_SENDER_STATS_STREAM_INDEX,
    DVR_SENDER_STATS_SAMPLES,
    DVR_SENDER_STATS_BYTES,
    DVR_SENDER_STATS_DISCONTINUITIES,
    DVR_SENDER_STATS_SYNCPOINTS,
    DVR_SENDER_STATS_TIMESTAMPS,
    DVR_SENDER_STATS_LAST_PTS_NORM_HMS,
    DVR_SENDER_STATS_LAST_PTS_NONNORM_HMS,
    DVR_SENDER_STATS_LAST_PTS_NORM_DSHOW,
    DVR_SENDER_STATS_LAST_PTS_NONNORM_DSHOW,
    DVR_SENDER_STATS_REFCLOCK_PTS_REF_OBSERVED,
    DVR_SENDER_STATS_REFCLOCK_PTS_REF_MEAN,
    DVR_SENDER_STATS_REFCLOCK_PTS_REF_STD_DEV,
    DVR_SENDER_STATS_REFCLOCK_PTS_REF_VARIANCE,
    DVR_SENDER_STATS_BITRATE,
    DVR_SENDER_STATS_QUEUE,

    //  always last
    DVR_SENDER_STATS_COUNTERS
} ;
//  keep in sync
static
COL_DETAIL
g_DVRSendStatsCol [] = {
    { __T("Pin"),               70 },
    { __T("Samples"),           60 },
    { __T("Bytes"),             60 },
    { __T("Disc."),             40 },
    { __T("Syncpoints"),        70 },
    { __T("Timestamps"),        70 },
    { __T("0_PTS (hms)"),       80 },
    { __T("PTS (hms)"),         80 },
    { __T("0_PTS"),             80 },
    { __T("PTS"),               80 },
    { __T("buffer millis"),     80 },
    { __T("mean"),              60 },
    { __T("std. dev"),          80 },
    { __T("variance"),          80 },
    { __T("Mbps"),              50 },
    { __T("Queue"),             50 },
} ;

CDVRSenderSideStats::CDVRSenderSideStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : m_pIDVRSenderStats      (NULL),
        m_dwMillisLast          (0),
        m_pullBytesLast         (NULL),
        m_rtNormalizer          (-1),
        CLVStatsWin             (hInstance,
                                 hwndFrame,
                                 DVR_SENDER_STATS_COUNTERS,
                                 g_DVRSendStatsCol,
                                 0,
                                 pdw
                                 )
{
    CSenderStreamContext *  pStreamContext ;
    HRESULT                 hr ;
    int                     i ;
    TCHAR                   ach [64] ;

    if ((* pdw) == NOERROR) {
        hr = CoCreateInstance (
                CLSID_DVRSenderSideStats,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDVRSenderStats,
                (void **) & m_pIDVRSenderStats
                ) ;
        if (FAILED (hr)) {
            (* pdw) = ERROR_GEN_FAILURE ;
            goto cleanup ;
        }
    }

    hr = m_pIDVRSenderStats -> GetStatsMaxStreams (& m_iMaxStatsStreams) ;
    if (SUCCEEDED (hr)) {
        m_pullBytesLast = new ULONGLONG [m_iMaxStatsStreams] ;
        if (m_pullBytesLast) {
            ZeroMemory (m_pullBytesLast, m_iMaxStatsStreams * sizeof ULONGLONG) ;
        }
        else {
            (* pdw) = ERROR_NOT_ENOUGH_MEMORY ;
            goto cleanup ;
        }
    }
    else {
        (* pdw) = ERROR_GEN_FAILURE ;
        goto cleanup ;
    }

    for (i = 0; i < m_iMaxStatsStreams; i++) {
        pStreamContext = new CSenderStreamContext (i) ;
        (* pdw) = InsertRow_ (i) ;
        if ((* pdw) == NOERROR) {
            SetRowsetValue_ (i, (DWORD_PTR) pStreamContext) ;
            CellDisplayText_ (i, DVR_RECEIVER_STATS_STREAM_INDEX, CreateOutputPinName (i, 64, ach)) ;
        }
        else {
            goto cleanup ;
        }
    }

    cleanup :

    return ;
}

CDVRSenderSideStats::~CDVRSenderSideStats (
    )
{
    RELEASE_AND_CLEAR (m_pIDVRSenderStats) ;
}

void
CDVRSenderSideStats::SetProximityValues_ (
    )
{
    int                     i ;
    REFERENCE_TIME          rtNormalizer ;
    REFERENCE_TIME          rtRefClockTimeStart ;
    CSenderStreamContext *  pStreamContext ;
    ULONGLONG               ullReadFailures ;

    assert (m_pIDVRSenderStats) ;
    m_pIDVRSenderStats -> GetGlobalStats (& rtNormalizer, & rtRefClockTimeStart, & ullReadFailures) ;

    for (i = 0; i < m_iMaxStatsStreams; i++) {

        pStreamContext = reinterpret_cast <CSenderStreamContext *> (GetRowsetValue_ (i)) ;
        assert (pStreamContext) ;

        pStreamContext -> SetProximityVal (rtRefClockTimeStart) ;
    }
}

void
CDVRSenderSideStats::Refresh (
    )
{
    int                     i ;
    HRESULT                 hr ;
    ULONGLONG               ullMediaSamplesIn ;
    ULONGLONG               ullTotalBytes ;
    ULONGLONG               ullDiscontinuities ;
    ULONGLONG               ullSyncPoints ;
    REFERENCE_TIME          rtLastNormalized ;
    REFERENCE_TIME          rtNormalizer ;
    REFERENCE_TIME          rtRefClockOnLastPTS ;
    REFERENCE_TIME          rtRefClockTimeStart ;
    DWORD                   deltaBits ;
    DWORD                   MillisNow ;
    DWORD                   deltaMillis ;
    static TCHAR            ach [32] ;
    double                  dMbps ;
    double                  dQueuePercentage ;
    LONG                    lMediaSamplesOutstanding ;
    LONG                    lPoolSize ;
    int                     iHours ;
    int                     iMinutes ;
    int                     iSeconds ;
    int                     iMillis ;
    CSenderStreamContext *  pStreamContext ;
    int                     iStdDeviation ;
    int                     iVariance ;
    ULONGLONG               ullReadFailures ;

    assert (m_pIDVRSenderStats) ;

    MillisNow       = GetTickCount () ;
    deltaMillis     = (m_dwMillisLast > 0 ? MillisNow - m_dwMillisLast : 0) ;
    m_dwMillisLast  = MillisNow ;

    hr = m_pIDVRSenderStats -> GetGlobalStats (& rtNormalizer, & rtRefClockTimeStart, & ullReadFailures) ;
    if (FAILED (hr)) {
        return ;
    }

    if (m_rtNormalizer != rtNormalizer) {
        SetProximityValues_ () ;
        m_rtNormalizer = rtNormalizer ;
    }

    for (i = 0; i < m_iMaxStatsStreams; i++) {
        hr = m_pIDVRSenderStats -> GetStreamStats (
                    i,
                    & ullMediaSamplesIn,
                    & ullTotalBytes,
                    & ullDiscontinuities,
                    & ullSyncPoints,
                    & rtLastNormalized,
                    & rtRefClockOnLastPTS,
                    & lMediaSamplesOutstanding,
                    & lPoolSize
                    ) ;
        if (SUCCEEDED (hr) &&
            ullMediaSamplesIn > 0) {

            pStreamContext = reinterpret_cast <CSenderStreamContext *> (GetRowsetValue_ (i)) ;
            assert (pStreamContext) ;

            CellDisplayValue_ (i, DVR_SENDER_STATS_SAMPLES,                     ullMediaSamplesIn) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_BYTES,                       ullTotalBytes) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_DISCONTINUITIES,             ullDiscontinuities) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_SYNCPOINTS,                  ullSyncPoints) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_TIMESTAMPS,                  ullSyncPoints) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_LAST_PTS_NORM_DSHOW,         rtLastNormalized) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_LAST_PTS_NONNORM_DSHOW,      rtLastNormalized + rtNormalizer) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_REFCLOCK_PTS_REF_OBSERVED,   DShowTimeToMillis (rtLastNormalized - pStreamContext -> Proximize (rtRefClockOnLastPTS))) ;

            pStreamContext -> Tuple (rtLastNormalized, rtRefClockOnLastPTS) ;

            CellDisplayValue_ (i, DVR_SENDER_STATS_REFCLOCK_PTS_REF_MEAN,       pStreamContext -> Mean ()) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_REFCLOCK_PTS_REF_STD_DEV,    pStreamContext -> StandardDeviation ()) ;
            CellDisplayValue_ (i, DVR_SENDER_STATS_REFCLOCK_PTS_REF_VARIANCE,   pStreamContext -> Variance ()) ;

            iMillis    = DShowTimeToMillis (rtLastNormalized) ;
            iSeconds   = iMillis / 1000 ; iMillis -= (iSeconds * 1000) ;
            iMinutes   = iSeconds / 60 ;  iSeconds -= (iMinutes * 60) ;
            iHours     = iMinutes / 60 ;  iMinutes -= (iHours * 60) ;
            _sntprintf (ach, 32, __T("%02d:%02d:%02d:%03d"), iHours, iMinutes, iSeconds, iMillis) ;
            CellDisplayText_ (i, DVR_SENDER_STATS_LAST_PTS_NORM_HMS, ach) ;

            iMillis    = DShowTimeToMillis (rtLastNormalized + rtNormalizer) ;
            iSeconds   = iMillis / 1000 ; iMillis -= (iSeconds * 1000) ;
            iMinutes   = iSeconds / 60 ;  iSeconds -= (iMinutes * 60) ;
            iHours     = iMinutes / 60 ;  iMinutes -= (iHours * 60) ;
            _sntprintf (ach, 32, __T("%02d:%02d:%02d:%03d"), iHours, iMinutes, iSeconds, iMillis) ;
            CellDisplayText_ (i, DVR_SENDER_STATS_LAST_PTS_NONNORM_HMS, ach) ;

            if (deltaMillis > 0) {
                deltaBits = (DWORD) (ullTotalBytes - m_pullBytesLast [i]) * 8 ;
                dMbps = (((double) deltaBits) / ((double) deltaMillis) * 1000.0) / 1000000.0 ;
            }
            else {
                dMbps = 0.0 ;
            }

            m_pullBytesLast [i] = ullTotalBytes ;

            _stprintf (ach, __T("%3.1f"), dMbps) ;
            CellDisplayText_ (i, DVR_SENDER_STATS_BITRATE, ach) ;

            if (lPoolSize > 0) {
                dQueuePercentage = ((double) lMediaSamplesOutstanding / (double) lPoolSize) * 100.0 ;
            }
            else {
                dQueuePercentage = 0 ;
            }

            _stprintf (ach, __T("%2.1f"), dQueuePercentage) ;
            CellDisplayText_ (i, DVR_SENDER_STATS_QUEUE, ach) ;
        }
        else {
            break ;
        }
    }
}

void
CDVRSenderSideStats::Reset (
    )
{
    m_pIDVRSenderStats -> Reset () ;
    ZeroMemory (m_pullBytesLast, m_iMaxStatsStreams * sizeof ULONGLONG) ;
    return ;
}

//  ============================================================================
//  ============================================================================

CDVRSenderSideTimeStats::CDVRSenderSideTimeStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : CDVRSenderSideStats (hInstance,
                             hwndFrame,
                             pdw)
{
    if ((* pdw) == NOERROR) {
        CollapseCol_ (DVR_SENDER_STATS_BYTES) ;
        CollapseCol_ (DVR_SENDER_STATS_DISCONTINUITIES) ;
        CollapseCol_ (DVR_SENDER_STATS_SYNCPOINTS) ;
        CollapseCol_ (DVR_SENDER_STATS_BITRATE) ;
        CollapseCol_ (DVR_SENDER_STATS_QUEUE) ;

        //  don't care about these either
        CollapseCol_ (DVR_SENDER_STATS_LAST_PTS_NORM_DSHOW) ;
        CollapseCol_ (DVR_SENDER_STATS_LAST_PTS_NONNORM_DSHOW) ;

    }
}

CDVRSenderSideTimeStats *
CDVRSenderSideTimeStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CDVRSenderSideTimeStats *   pDVRSenderStatsTime ;
    DWORD                       dwRet ;

    pDVRSenderStatsTime = new CDVRSenderSideTimeStats (
                                    hInstance,
                                    hwndFrame,
                                    & dwRet
                                    ) ;
    if (!pDVRSenderStatsTime ||
        dwRet != NOERROR) {

        DELETE_RESET (pDVRSenderStatsTime) ;
    }

    return pDVRSenderStatsTime ;
}

//  ============================================================================
//  ============================================================================

CDVRSenderSideSampleStats::CDVRSenderSideSampleStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : CDVRSenderSideStats (hInstance,
                             hwndFrame,
                             pdw)
{
    if ((* pdw) == NOERROR) {
        CollapseCol_ (DVR_SENDER_STATS_TIMESTAMPS) ;
        CollapseCol_ (DVR_SENDER_STATS_LAST_PTS_NORM_DSHOW) ;
        CollapseCol_ (DVR_SENDER_STATS_LAST_PTS_NORM_HMS) ;
        CollapseCol_ (DVR_SENDER_STATS_LAST_PTS_NONNORM_DSHOW) ;
        CollapseCol_ (DVR_SENDER_STATS_LAST_PTS_NONNORM_HMS) ;
        CollapseCol_ (DVR_SENDER_STATS_REFCLOCK_PTS_REF_MEAN) ;
        CollapseCol_ (DVR_SENDER_STATS_REFCLOCK_PTS_REF_STD_DEV) ;
        CollapseCol_ (DVR_SENDER_STATS_REFCLOCK_PTS_REF_VARIANCE) ;
        CollapseCol_ (DVR_SENDER_STATS_REFCLOCK_PTS_REF_OBSERVED) ;
    }
}

CDVRSenderSideSampleStats *
CDVRSenderSideSampleStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CDVRSenderSideSampleStats * pDVRSenderStatsSample ;
    DWORD                       dwRet ;

    pDVRSenderStatsSample = new CDVRSenderSideSampleStats (
                                    hInstance,
                                    hwndFrame,
                                    & dwRet
                                    ) ;
    if (!pDVRSenderStatsSample ||
        dwRet != NOERROR) {

        DELETE_RESET (pDVRSenderStatsSample) ;
    }

    return pDVRSenderStatsSample ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\main.h ===
#define STATS_CATEGORY_MENU_TITLE           __T("&Category")

#define STATS_MENU_TITLE                    __T("&Stats")

#define OPTIONS_MENU_TITLE                  __T("&Options")
#define     CMD_ALWAYS_ON_TOP_STRING            __T("Always On &Top")
#define     CMD_STATS_ON                        __T("Stats &On")

#define REFRESH_RATE_MENU_TITLE             __T("&Refresh Rate")
#define     CMD_REFRESH_100_MILLIS              __T("100 millisecond")
#define     CMD_REFRESH_200_MILLIS              __T("200 millisecond")
#define     CMD_REFRESH_500_MILLIS              __T("500 millisecond")
#define     CMD_REFRESH_1000_MILLIS             __T("1 second")
#define     CMD_REFRESH_5000_MILLIS             __T("5 second")

#define ACTIONS_MENU_TITLE                  __T("&Actions")
#define     CMD_PAUSE_REFRESH                   __T("&Pause")
#define     CMD_RESET_STATS                     __T("&Reset")

#define CMD_ABOUT_STRING                    __T("A&bout")

#define STATS_CATEGORY_MENU_INDEX                   0
#define STATS_MENU_INDEX                    1
#define OPTIONS_MENU_INDEX                  2
#define ACTIONS_MENU_INDEX                  3
#define REFRESH_RATE_MENU_INDEX             4

#define STATS_APP_MENU_BASELINE                         1000
#define IDM_OPTIONS_ALWAYS_ON_TOP                       (STATS_APP_MENU_BASELINE + 1)
#define IDM_OPTIONS_STATS_ON                            (STATS_APP_MENU_BASELINE + 2)
#define IDM_REFRESH_RATE_100_MILLIS                     (STATS_APP_MENU_BASELINE + 3)
#define IDM_REFRESH_RATE_200_MILLIS                     (STATS_APP_MENU_BASELINE + 4)
#define IDM_REFRESH_RATE_500_MILLIS                     (STATS_APP_MENU_BASELINE + 5)
#define IDM_REFRESH_RATE_1000_MILLIS                    (STATS_APP_MENU_BASELINE + 6)
#define IDM_REFRESH_RATE_5000_MILLIS                    (STATS_APP_MENU_BASELINE + 7)
#define IDM_PAUSE_REFRESH                               (STATS_APP_MENU_BASELINE + 8)
#define IDM_RESET_STATS                                 (STATS_APP_MENU_BASELINE + 9)
#define IDM_ABOUT                                       (STATS_APP_MENU_BASELINE + 10)

#define STATS_CATEGORY_MENU_BASELINE                    2000
#define STATS_CATEGORY_MENU_IDM(stats_category_index)   (stats_category_index + STATS_CATEGORY_MENU_BASELINE)
#define RECOVER_STATS_CATEGORY_INDEX(IDM)               (IDM - STATS_CATEGORY_MENU_BASELINE)

#define STATS_MENU_BASELINE                             3000
#define STATS_MENU_IDM(stats_index)                     (stats_index + STATS_MENU_BASELINE)
#define RECOVER_STATS_INDEX(IDM)                        (IDM - STATS_MENU_BASELINE)

#define REG_ROOT_STATS                      __T("SOFTWARE\\Microsoft\\StatsApp")
#define REG_REFRESH_RATE_NAME               __T("RefreshRate")
#define REG_STATS_CATEGORY_NAME             __T("StatsCategory")
#define REG_VISIBLE_STATS_NAME              __T("VisibleStats")
#define REG_ALWAYS_ON_TOP_NAME              __T("AlwaysOnTop")
#define REG_WINDOW_TOPX_NAME                __T("WindowX")
#define REG_WINDOW_TOPY_NAME                __T("WindowY")
#define REG_WINDOW_WIDTH_NAME               __T("WindowWidth")
#define REG_WINDOW_HEIGHT_NAME              __T("WindowHeight")

#define DEF_REFRESH_RATE                    100
#define DEF_STATS_CATEGORY                  0
#define DEF_VISIBLE_STATS_TYPE              0
#define DEF_ALWAYS_ON_TOP                   FALSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\dvrstats.h ===
#ifndef __dvrstats_h
#define __dvrstats_h

__inline
int
DShowTimeToMillis (
    IN  REFERENCE_TIME  rt
    )
{
    return (int) ((rt / 1000) / 10) ;
}

template <class T, DWORD dwMaxWindowSize>
class CMovingAverage
/*++
    Keeps a moving average of a window size dwMaxWindowSize.  Can also be used
    to compute the variance and standard deviation over the values stored in
    the moving average.

    xxxx
    Update this eventually to dynamically set the window size (up to the max)
    based on a jitter threshold, so if the standard deviation exceeds the
    threshold, extend the current max window size to smooth the curve.
--*/
{
    DWORD       m_dwCurIndex ;
    T           m_rValues [dwMaxWindowSize] ;
    DWORD       m_dwCurWindowSize ;
    T           m_tTotalValue ;

    public :

        CMovingAverage (
            )
        {
            Reset () ;
        }

        void
        Reset (
            )
        {
            m_dwCurWindowSize = 0 ;
            m_tTotalValue = 0 ;
            m_dwCurIndex = 0 ;
        }

        HRESULT
        AddValue (
            IN  T   tValue
            )
        {
            if (m_dwCurWindowSize == dwMaxWindowSize) {
                m_tTotalValue -= m_rValues [m_dwCurIndex] ;
            }
            else {
                m_dwCurWindowSize++ ;
            }

            m_rValues [m_dwCurIndex] = tValue ;
            m_tTotalValue += m_rValues [m_dwCurIndex] ;
            m_dwCurIndex = ++m_dwCurIndex % dwMaxWindowSize ;

            return S_OK ;
        }

        T
        GetTotal (
            )
        {
            return m_tTotalValue ;
        }

        T
        GetMeanValue (
            )
        {
            assert (m_dwCurWindowSize > 0) ;
            return m_tTotalValue / (T) m_dwCurWindowSize ;
        }

        HRESULT
        GetStandardDeviation (
            OUT T * pT
            )
        {
            HRESULT hr ;

            assert (pT) ;

            hr = GetVariance (pT) ;
            if (SUCCEEDED (hr)) {
                assert (* pT >= 0) ;
                * pT = (T) sqrt (* pT) ;
            }

            return hr ;
        }

        HRESULT
        GetVariance (
            OUT T * pT
            )
        {
            T       tMeanValue ;
            T       tNewTotal ;
            DWORD   i ;

            assert (pT) ;
            assert (m_dwCurWindowSize > 0) ;

            * pT = 0 ;
            tMeanValue = GetMeanValue () ;

            for (i = 0; i < m_dwCurWindowSize; i++) {
                tNewTotal = * pT + (m_rValues [i] - tMeanValue) * (m_rValues [i] - tMeanValue) ;
                if (tNewTotal < * pT) {
                    //  overflow
                    return E_FAIL ;
                }

                * pT = tNewTotal ;
            }

            * pT /= (T) m_dwCurWindowSize ;

            return S_OK ;
        }
} ;

//  ============================================================================

class CDVRReceiverSideStats :
    public CLVStatsWin
{
    IDVRReceiverStats * m_pIDVRReceiverStats ;
    DWORD               m_dwMillisLast ;
    int                 m_iMaxStatsStreams ;
    ULONGLONG *         m_pullBytesLast ;

    public :

        CDVRReceiverSideStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        virtual
        ~CDVRReceiverSideStats (
            ) ;

        virtual void Refresh () ;
        virtual void Reset () ;
        virtual DWORD   Enable (BOOL * pf)  { assert (m_pIDVRReceiverStats) ; return m_pIDVRReceiverStats -> Enable (pf) ; }

        static
        CDVRReceiverSideStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

//  ============================================================================


class CDVRSenderSideStats :
    public CLVStatsWin
{
    class CSenderStreamContext
    {
        int                         m_iFlow ;
        CMovingAverage <int, 50>    m_PTSDrift ;
        REFERENCE_TIME              m_rtProximityVal ;   //  "normalizes" clock values since last start

        public :

            CSenderStreamContext (
                int iFlow
                ) : m_iFlow             (iFlow),
                    m_rtProximityVal    (0I64) {}

            int Flow ()     { return m_iFlow ; }

            void Tuple (REFERENCE_TIME rtPTS, REFERENCE_TIME rtClock)   { m_PTSDrift.AddValue (DShowTimeToMillis (rtPTS - Proximize (rtClock))) ; }
            int StandardDeviation ()                                    { int i ; m_PTSDrift.GetStandardDeviation (& i) ; return i ; }
            int Variance ()                                             { int i ; m_PTSDrift.GetVariance (& i) ; return i ; }
            int Mean ()                                                 { return m_PTSDrift.GetMeanValue () ; }

            void SetProximityVal (REFERENCE_TIME rt)                    { m_rtProximityVal = rt ; m_PTSDrift.Reset () ; }
            REFERENCE_TIME Proximize (REFERENCE_TIME rt)                { return rt - m_rtProximityVal ; }
    } ;

    IDVRSenderStats *   m_pIDVRSenderStats ;
    DWORD               m_dwMillisLast ;
    int                 m_iMaxStatsStreams ;
    ULONGLONG *         m_pullBytesLast ;
    REFERENCE_TIME      m_rtNormalizer ;

    void
    SetProximityValues_ (
        ) ;

    public :

        CDVRSenderSideStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        virtual
        ~CDVRSenderSideStats (
            ) ;

        virtual void Refresh () ;
        virtual void Reset () ;
        virtual DWORD   Enable (BOOL * pf)  { assert (m_pIDVRSenderStats) ; return m_pIDVRSenderStats -> Enable (pf) ; }
} ;

class CDVRSenderSideTimeStats :
    public CDVRSenderSideStats
{
    public :

        CDVRSenderSideTimeStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        static
        CDVRSenderSideTimeStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

class CDVRSenderSideSampleStats :
    public CDVRSenderSideStats
{
    public :

        CDVRSenderSideSampleStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        static
        CDVRSenderSideSampleStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

#endif  //  __dvrstats_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\controls.cpp ===
#include "precomp.h"
#include "controls.h"

/*++
        C C o n t r o l B a s e
--*/

CControlBase::CControlBase (
    HWND    hwnd,
    DWORD   id
    )
{
    assert (hwnd) ;

    m_hwnd = GetDlgItem (hwnd, id) ;
    m_id = id ;
}

CControlBase::CControlBase (
    HWND    hwnd
    ) : m_hwnd  (hwnd),
        m_id    (0) {}

HWND
CControlBase::GetHwnd (
    )
{
    return m_hwnd ;
}

DWORD
CControlBase::GetId (
    )
{
    return m_id ;
}

/*++
        C E d i t C o n t r o l
--*/

CEditControl::CEditControl (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
    assert (hwnd) ;
}

void
CEditControl::SetText (
    TCHAR * szText
    )
{
    assert (szText) ;
    SetWindowText (m_hwnd, szText) ;
}

void
CEditControl::SetTextW (
    WCHAR * szText
    )
{
    assert (szText) ;
    SetWindowTextW (m_hwnd, szText) ;
}

void
CEditControl::SetText (
    INT val
    )
{
    TCHAR achbuffer [32] ;
    SetText (_itot (val, (TCHAR *) achbuffer, 10)) ;
}

int
CEditControl::GetText (
    INT *   val
    )
{
    WCHAR   achbuffer [32] ;

    assert (val) ;
    * val = 0 ;

    if (GetText (achbuffer, 31)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CEditControl::GetText (
    TCHAR *  ach,
    int     MaxChars
    )
{
    assert (ach) ;
    return GetWindowText (m_hwnd, ach, MaxChars) ;
}

int
CEditControl::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    assert (ach) ;
    return GetWindowTextW (m_hwnd, ach, MaxChars) ;
}


int CEditControl::ResetContent ()
{
    return SendMessage (m_hwnd, WM_CLEAR, 0, 0) ;
}

/*++
        C L i s t b o x
--*/

CListbox::CListbox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id),
        m_SelectedArrayIndex (0),
        m_cInSelectedArray (0)
{
}

int
CListbox::Append (
    TCHAR * sz
    )
{
    assert (sz) ;
    return SendMessage (m_hwnd, LB_ADDSTRING, 0, (LPARAM) sz) ;
}

int
CListbox::Insert (
    TCHAR * sz,
    int     index
    )
{
    assert (sz) ;
    return SendMessage (m_hwnd, LB_INSERTSTRING, (WPARAM) index, (LPARAM) sz) ;
}

int
CListbox::ShowDirectory (
    TCHAR * szDir
    )
{
    int retval ;

    assert (szDir) ;

    ResetContent () ;

    retval = SendMessage (m_hwnd, LB_DIR, (WPARAM) DDL_DIRECTORY, (LPARAM) _tcscat (szDir, __T("\\*.*"))) ;

    szDir [_tcslen (szDir) - 4] = __T('\0') ;

    return retval ;
}

int
CListbox::ShowCurrentDirectory (
    )
{
    TCHAR   achBuffer [MAX_PATH] ;

    if (GetCurrentDirectory (MAX_PATH, achBuffer) == 0) {
        return 0 ;
    }

    return ShowDirectory (achBuffer) ;
}

int
CListbox::OnDoubleClick (
    )
{
    TCHAR    achbuffer [MAX_PATH] ;
    TCHAR    achcurrent [MAX_PATH] ;
    TCHAR *  pszDir ;

    if (SendMessage (m_hwnd, LB_GETTEXT, SendMessage (m_hwnd, LB_GETCARETINDEX, 0, 0), (LPARAM) achbuffer) == LB_ERR) {
        return 0 ;
    }

    //  do nothing if it doesn't look like a subdirectory
    if (achbuffer [0] != __T('[')   ||
        achbuffer [_tcslen (achbuffer) - 1] != __T(']')) {

        return 0 ;
    }

    pszDir = & achbuffer [0] ;

    //  skip over opening bracket
    pszDir++ ;

    //  and nuke the closing bracket
    achbuffer [_tcslen (achbuffer) - 1] = __T('\0') ;

    //  current directory ?
    if (_tcsicmp (pszDir, __T(".")) == 0) {
        return 0 ;
    }

    //  backing up ?
    if (_tcsicmp (pszDir, __T("..")) == 0) {
        SetCurrentDirectory (__T("..")) ;
        return ShowCurrentDirectory () ;
    }

    //  append to the current directory
    if (GetCurrentDirectory (MAX_PATH, achcurrent) == 0) {
        return 0 ;
    }

    _tcscat (achcurrent, __T("\\")) ;
    _tcscat (achcurrent, pszDir) ;

    SetCurrentDirectory (achcurrent) ;

    return ShowCurrentDirectory () ;
}

int
CListbox::ResetContent (
    )
{
    return SendMessage (m_hwnd, LB_RESETCONTENT, 0, 0) ;
}

int
CListbox::ResetSelectionArray (
    )
{
    m_SelectedArrayIndex = 0 ;

    m_cInSelectedArray = SendMessage (m_hwnd, LB_GETSELITEMS, (WPARAM) SELECT_ARRAY_MAX, (LPARAM) & m_SelectedArray) ;
    if (m_cInSelectedArray == LB_ERR) {
        m_cInSelectedArray = 0 ;
        return LB_ERR ;
    }

    return m_cInSelectedArray ;
}

int
CListbox::GetNextSelected (
    TCHAR * achbuffer,
    int     max
    )
{
    assert (achbuffer) ;

    achbuffer [0] = __T('\0') ;

    //  off the end of the array ?
    if (m_SelectedArrayIndex >= m_cInSelectedArray) {
        return LB_ERR ;
    }

    //  too long ?
    if (SendMessage (m_hwnd, LB_GETTEXTLEN, (WPARAM) m_SelectedArray [m_SelectedArrayIndex], 0) >= max - 1) {
        return LB_ERR ;
    }

    return SendMessage (m_hwnd, LB_GETTEXT, (WPARAM) m_SelectedArray [m_SelectedArrayIndex++], (LPARAM) achbuffer) ;
}

int
CListbox::GetNextSelectedW (
    WCHAR * achbuffer,
    int     max
    )
{
    assert (achbuffer) ;

    achbuffer [0] = L'\0' ;

    //  off the end of the array ?
    if (m_SelectedArrayIndex >= m_cInSelectedArray) {
        return LB_ERR ;
    }

    //  too long ?
    if (SendMessage (m_hwnd, LB_GETTEXTLEN, (WPARAM) m_SelectedArray [m_SelectedArrayIndex], 0) >= max - 1) {
        return LB_ERR ;
    }

    return SendMessageW (m_hwnd, LB_GETTEXT, (WPARAM) m_SelectedArray [m_SelectedArrayIndex++], (LPARAM) achbuffer) ;
}

/*++
        C C o m b o b o x
--*/

CCombobox::CCombobox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
}

int
CCombobox::Append (
    TCHAR *  sz
    )
{
    return SendMessage (m_hwnd, CB_ADDSTRING, 0, (LPARAM) sz) ;
}

int
CCombobox::Append (
    INT val
    )
{
    TCHAR   achbuffer [32] ;        //  no numbers are longer

    return Append (_itot (val, achbuffer, 10)) ;
}

int
CCombobox::Insert (
    TCHAR * sz,
    int     index)
{
    return SendMessage (m_hwnd, CB_INSERTSTRING, (WPARAM) index, (LPARAM) sz) ;
}

int
CCombobox::Insert (
    INT val,
    int index
    )
{
    TCHAR   achbuffer [32] ;        //  no numbers are longer

    return Insert (_itot (val, achbuffer, 10), index) ;
}


int
CCombobox::GetText (
    TCHAR * ach,
    int     MaxChars
    )
{
    int index ;
    int count ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        //  might be that it's not a dropdown list - in which case we get;
        //  try to get just the edit control's text; if that fails, return
        //  a failure, otherwise we're ok
        count = GetWindowText (m_hwnd, ach, MaxChars) ;
        if (count == 0) {
            return CB_ERR ;
        }

        return count ;
    }

    if (SendMessage (m_hwnd, CB_GETLBTEXTLEN, (WPARAM) index, 0) + 1 > MaxChars) {
        return CB_ERR ;
    }

    return SendMessage (m_hwnd, CB_GETLBTEXT, (WPARAM) index, (LPARAM) ach) ;
}

int
CCombobox::GetText (
    int * val
    )
{
    TCHAR   achbuffer [32] ;

    assert (val) ;
    * val = 0 ;

    if (GetText (achbuffer, 32)) {
        (* val) = _ttoi (achbuffer) ;
    }

    return (* val) ;
}


int
CCombobox::Focus (
    int index
    )
{
    return SendMessage (m_hwnd, CB_SETCURSEL, (WPARAM) index, 0) ;
}

int
CCombobox::ResetContent (
    )
{
    return SendMessage (m_hwnd, CB_RESETCONTENT, 0, 0) ;
}

int
CCombobox::SetItemData (
    DWORD   val,
    int     index
    )
{
    return SendMessage (m_hwnd, CB_SETITEMDATA, (WPARAM) index, (LPARAM) val) ;
}

int
CCombobox::GetCurrentItemIndex (
    )
{
    return SendMessage (m_hwnd, CB_GETCURSEL, 0, 0) ;
}

int
CCombobox::GetItemData (
    DWORD * pval,
    int     index
    )
{
    int i ;

    assert (pval) ;

    i = SendMessage (m_hwnd, CB_GETITEMDATA, (WPARAM) index, 0) ;
    if (i == CB_ERR) {
        return CB_ERR ;
    }

    * pval = i ;
    return i ;
}

int
CCombobox::GetCurrentItemData (
    DWORD * pval
    )
{
    int index ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        return CB_ERR ;
    }

    return GetItemData (pval, index) ;
}

int
CCombobox::Find (
    TCHAR * sz
    )
{
    assert (sz) ;
    return SendMessage (m_hwnd, CB_FINDSTRING, (WPARAM) -1, (LPARAM) sz) ;
}

int
CCombobox::FindW (
    WCHAR * sz
    )
{
    assert (sz) ;
    return SendMessageW (m_hwnd, CB_FINDSTRING, (WPARAM) -1, (LPARAM) sz) ;
}


/*++
        C L i s t v i e w
--*/

CListview::CListview (
    HWND hwnd,
    DWORD id
    ) : CControlBase (hwnd, id),
        m_cColumns (0)
{
}

CListview::CListview (
    HWND hwnd
    ) : CControlBase (hwnd),
        m_cColumns (0)
{
}

int
CListview::ResetContent (
    )
{
    return SendMessage (m_hwnd, LVM_DELETEALLITEMS, 0, 0) ;
}

BOOL
CListview::SetData (
    DWORD_PTR   dwData,
    int         iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.lParam   = (LPARAM) dwData ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::SetText (
    TCHAR * sz,
    int     iRow,
    int     iCol
    )
{
    LVITEM  lvItem = {0} ;

    assert (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = sz ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowIcon (
    int iIcon
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_IMAGE ;
    lvItem.iImage   = iIcon ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowValue (
    DWORD dw
    )
{
    return InsertRowValue (
                        0,
                        dw
                        ) ;
}

int
CListview::InsertRowValue (
    int     row,
    DWORD   dw
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = row ;          //  forms the 0-based index to last
    lvItem.lParam   = (LPARAM) dw ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::AppendRowValue (
    DWORD dw
    )
{
    return InsertRowValue (
                    GetItemCount (),
                    dw
                    ) ;
}

int
CListview::InsertRowText (
    TCHAR * sz,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    assert (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = sz ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::DeleteRow (
    int iRow
    )
{
    return ListView_DeleteItem (m_hwnd, iRow) ;
}

int
CListview::GetSelectedCount (
    )
{
    return ListView_GetSelectedCount (m_hwnd) ;
}

int
CListview::GetSelectedRow (
    int iStartRow
    )
{
    return ListView_GetNextItem (m_hwnd, iStartRow, LVNI_SELECTED) ;
}

DWORD_PTR
CListview::GetData (
    int iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = m_cColumns ;

    return ListView_GetItem (m_hwnd, & lvItem) ? lvItem.lParam : NULL ;
}

DWORD CListview::GetData (
    )
{
    int iRow ;

    iRow = ListView_GetNextItem (m_hwnd, -1, LVNI_SELECTED) ;

    if (iRow == -1) {
        return NULL ;
    }

    return GetData (iRow) ;
}

int
CListview::InsertColumn (
    TCHAR * szColumnName,
    int ColumnWidth,
    int iCol
    )
{
    LVCOLUMN    lvColumn = {0} ;
    int         r ;

    assert (szColumnName) ;

    lvColumn.mask       = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt        = LVCFMT_LEFT;
    lvColumn.cx         = ColumnWidth ;
    lvColumn.pszText    = szColumnName ;

    r = ListView_InsertColumn (m_hwnd, iCol, & lvColumn) ;

    if (r != -1) {
        m_cColumns++ ;
    }

    return r ;
}

HIMAGELIST
CListview::SetImageList_ (
    HIMAGELIST  imgList,
    int         List
    )
{
    return ListView_SetImageList (m_hwnd, imgList, List) ;
}

HIMAGELIST
CListview::SetImageList_SmallIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_SMALL) ;
}

HIMAGELIST
CListview::SetImageList_NormalIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_NORMAL) ;
}

HIMAGELIST
CListview::SetImageList_State (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_STATE) ;
}

BOOL
CListview::SetState (
    int Index,
    int Row
    )
{
    //  setting or clearing ?
    if (Index > 0) {
        ListView_SetItemState (
                m_hwnd,
                Row,
                INDEXTOSTATEIMAGEMASK(Index),
                LVIS_STATEIMAGEMASK
                ) ;
    }
    else {
        ListView_SetItemState (m_hwnd, Row, 0, LVIS_STATEIMAGEMASK) ;
        ListView_RedrawItems (m_hwnd, Row, Row) ;
    }

    return TRUE ;
}

int
CListview::GetItemCount (
    )
{
    return SendMessage (m_hwnd, LVM_GETITEMCOUNT, 0, 0) ;
}

void
CListview::ResetContent (
    int Row                 //  0-based
    )
{
    int iRowCount = GetItemCount () ;
    int i ;

    if (iRowCount == 0) {
        return ;
    }

    //  1-based
    for (i = Row + 1; i <= iRowCount; i++) {
        //  repeate the same row each time
        DeleteRow (Row) ;
    }
}

void
CListview::SetColWidth (
    int iCol,
    int iWidth
    )
{
    ListView_SetColumnWidth (m_hwnd, iCol, iWidth) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\main.cpp ===
#include "precomp.h"
#include "main.h"
#include "ui.h"
#include "controls.h"
#include "shared.h"
#include "resource.h"
#include <initguid.h>
#include "mp2demux.h"
#include "dvrdspriv.h"
#include "statswin.h"
#include "mp2stats.h"
#include "dvrstats.h"
#include "stats.h"

#define DEF_WINDOW_HEIGHT               260
#define DEF_WINDOW_WIDTH                290

#define STATSAPP_TIMER                  1

#define DMSTAT_APPNAME                  __T("STATSAPP")

#define WERE_DISABLED_MSG_CAPTION       __T("Stats Enabled")
#define WERE_DISABLED_MSG               __T("Statistical information was not enabled.  The module used to collect\n") \
                                        __T("   statistics most likely needs to be reloaded to log statistics.\n")

#define ABOUT_MSG_CAPTION               __T("Stats Info Application")
#define ABOUT_MSG_COPYRIGHT             __T("Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.")

#define STATS_LOAD_FAILED_MSG           __T("Stats Load Failure")
#define STATS_LOAD_FAILED_MSG_CAPTION   __T("Failed to load the selected statistical module.")

#define NO_STATS_MODULE_LOADED          __T("No Statistical Data Loaded")

#define REG_CLOSE_RESET(hkey)           if ((hkey) != NULL) { RegCloseKey (hkey) ; (hkey) = NULL ; }

static  HINSTANCE                   g_hInstance ;
static  HMENU                       g_hmenuBar ;
static  HMENU                       g_hmenuCategory ;
static  HMENU                       g_hmenuStats ;
static  HMENU                       g_hmenuOptions ;
static  HMENU                       g_hmenuRefreshRate ;
static  HMENU                       g_hmenuActions ;
static  HWND                        g_MainWindow ;
static  int                         g_StatsCategory ;
static  UINT                        g_Timer ;
static  DWORD                       g_RefreshRate ;
static  int                         g_TopX ;
static  int                         g_TopY ;
static  int                         g_Width ;
static  int                         g_Height ;
static  HKEY                        g_hkeyStatsRoot ;
static  int                         g_VisibleStats ;
static  BOOL                        g_fAlwaysOnTop ;
static  BOOL                        g_fPause ;
static  BOOL                        g_fStatsOn ;
static  TCHAR *                     g_szApp ;

static  void        Uninitialize            () ;
        int         PASCAL WinMain          (HINSTANCE, HINSTANCE, LPSTR, int) ;
static  BOOL        InitApplication         (HINSTANCE) ;
static  BOOL        InitInstance            (HINSTANCE, int) ;
static  BOOL        GenerateMenu            (HWND) ;
static  void        PurgeMenu               (HMENU) ;
static  void        SelectivelyDisplayMenu  (HMENU) ;
        LRESULT     CALLBACK WndProc        (HWND, UINT, WPARAM, LPARAM) ;
static  BOOL        SetVisibleStats         (int) ;
static  void        ToggleAlwaysOnTop       (BOOL) ;
static  DWORD       SetStatsCategory        (int) ;
static  VOID        CALLBACK Refresh        (HWND, UINT, UINT, DWORD) ;
static  BOOL        SetRefreshRate          (DWORD) ;
static  void        RegRestoreSettings      () ;
static  LONG        RegGetValIfExist        (HKEY,TCHAR *,DWORD *) ;
static  void        WindowResized           () ;
static  void        ResetStats              () ;
static  void        About                   () ;
static  CStatsWin * CurStats                () ;
static  void        SizeStatsToClientArea   (HWND) ;
static  void        HideAllStats            () ;

extern
"C"
int
WINAPI
_tWinMain (
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    int         nCmdShow
    )
{
    MSG     msg;

    g_hInstance = hInstance ;

    if (!hPrevInstance) {
        if (!InitApplication (hInstance)) {
	        goto fail ;
        }
    }

    if (!InitInstance (hInstance, nCmdShow)) {
        goto fail ;
    }

    while (GetMessage (& msg, NULL, 0, 0)) {
	    TranslateMessage (& msg);
	    DispatchMessage (& msg);
    }

    Uninitialize () ;

    fail :

    return (msg.wParam);
}

static
void
Uninitialize (
    )
{
    int i, k ;

    KillTimer (g_MainWindow, STATSAPP_TIMER) ;

    if (g_hmenuCategory)    { DestroyMenu (g_hmenuCategory) ; }
    if (g_hmenuStats)       { DestroyMenu (g_hmenuStats) ; }
    if (g_hmenuOptions)     { DestroyMenu (g_hmenuOptions) ; }
    if (g_hmenuBar)         { DestroyMenu (g_hmenuBar) ; }
    if (g_hmenuRefreshRate) { DestroyMenu (g_hmenuRefreshRate) ; }
    if (g_hmenuActions)     { DestroyMenu (g_hmenuActions) ; }

    REG_CLOSE_RESET (g_hkeyStatsRoot) ;

    for (i = 0; i < g_AllStatsCount; i++) {
        for (k = 0; k < g_pAllStats [i].iCount; k++) {
            delete g_pAllStats [i].pStats [k].pStatsWin ;
        }
    }
}

static
BOOL
InitApplication (
    IN  HINSTANCE hInstance
    )
{
    WNDCLASS  wc;

	wc.style	        = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc	    = (WNDPROC) WndProc;
	wc.cbClsExtra	    = 0;
	wc.cbWndExtra	    = 0;
	wc.hInstance	    = hInstance;
	//wc.hIcon	        = LoadIcon (hInstance, NULL);
	wc.hIcon	        = LoadIcon (hInstance, MAKEINTRESOURCE(IDI_DMSTAT));
	wc.hCursor	        = LoadCursor (NULL, IDC_ARROW);
	wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW+1);
	wc.lpszMenuName     = NULL ;
	wc.lpszClassName    = DMSTAT_APPNAME;

	return RegisterClass (& wc);
}

static
BOOL
InitInstance(
    IN  HINSTANCE   hInstance,
    IN  int         nCmdShow
    )
{
    HRESULT hr ;

    hr = CoInitializeEx (
            NULL,
            COINIT_MULTITHREADED
            ) ;
    if (FAILED (hr)) {
        return FALSE ;
    }

    RegRestoreSettings () ;

    g_MainWindow = CreateWindow (
                DMSTAT_APPNAME,
                NULL,
                WS_MINIMIZEBOX | WS_SYSMENU | WS_CAPTION | WS_BORDER | WS_SIZEBOX,
                g_TopX, g_TopY,
                g_Width, g_Height,
                NULL,
                NULL,
                hInstance,
                NULL
                );

    if (!g_MainWindow) {
        return FALSE;
    }

    ShowWindow      (g_MainWindow, nCmdShow) ;
    UpdateWindow    (g_MainWindow) ;

    SetStatsCategory    (g_StatsCategory) ;
    SetRefreshRate      (g_RefreshRate) ;
    SetVisibleStats     (g_VisibleStats) ;
    ToggleAlwaysOnTop   (g_fAlwaysOnTop) ;

    g_fStatsOn          = TRUE ;
    g_fPause            = FALSE ;

    return TRUE ;
}

static
LONG
RegGetValIfExist (
    IN  HKEY    hkeyRoot,
    IN  TCHAR * szValName,
    OUT DWORD * pdw
    )
{
    DWORD   dw ;
    LONG    l ;
    DWORD   size ;
    DWORD   type ;

    assert (hkeyRoot) ;
    assert (szValName) ;
    assert (pdw) ;

    size = sizeof dw ;
    type = REG_DWORD ;

    l = RegQueryValueEx (
            hkeyRoot,
            szValName,
            NULL,
            & type,
            (LPBYTE) & dw,
            & size
            ) ;

    //  only set the passed in parameter's value if we opened the value ok
    if (l == ERROR_SUCCESS) {
        assert (type == REG_DWORD) ;
        * pdw = dw ;
    }
    else  {
        l = RegSetValueEx (
                    hkeyRoot,
                    szValName,
                    NULL,
                    REG_DWORD,
                    (const BYTE *) pdw,
                    sizeof (* pdw)
                    ) ;
    }

    return l ;
}

static
void
RegRestoreSettings (
    )
{
    DWORD   dw ;

    REG_CLOSE_RESET (g_hkeyStatsRoot) ;

    RegCreateKeyEx (
        HKEY_CURRENT_USER,
        REG_ROOT_STATS,
        NULL,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        & g_hkeyStatsRoot,
        & dw
        ) ;

    g_RefreshRate = DEF_REFRESH_RATE ;
    RegGetValIfExist (
        g_hkeyStatsRoot,
        REG_REFRESH_RATE_NAME,
        & g_RefreshRate
        ) ;

    g_StatsCategory = DEF_STATS_CATEGORY ;
    RegGetValIfExist (
        g_hkeyStatsRoot,
        REG_STATS_CATEGORY_NAME,
        (DWORD *) & g_StatsCategory
        ) ;
    g_StatsCategory = Min <int> (g_AllStatsCount, g_StatsCategory) ;

    g_VisibleStats = DEF_VISIBLE_STATS_TYPE ;
    RegGetValIfExist (
        g_hkeyStatsRoot,
        REG_VISIBLE_STATS_NAME,
        (DWORD *) & g_VisibleStats
        ) ;
    g_VisibleStats = Min <int> (g_pAllStats [g_StatsCategory].iCount, g_VisibleStats) ;
    g_pAllStats [g_StatsCategory].iLastVisible = g_VisibleStats ;

    dw = (DEF_ALWAYS_ON_TOP ? 1 : 0) ;
    RegGetValIfExist (
        g_hkeyStatsRoot,
        REG_ALWAYS_ON_TOP_NAME,
        (DWORD *) & dw
        ) ;
    g_fAlwaysOnTop = (dw != 0) ;

    g_TopX = CW_USEDEFAULT ;
    RegGetValIfExist (
        g_hkeyStatsRoot,
        REG_WINDOW_TOPX_NAME,
        (DWORD *) & g_TopX
        ) ;

    g_TopY = CW_USEDEFAULT ;
    RegGetValIfExist (
        g_hkeyStatsRoot,
        REG_WINDOW_TOPY_NAME,
        (DWORD *) & g_TopY
        ) ;

    g_Width = DEF_WINDOW_WIDTH ;
    RegGetValIfExist (
        g_hkeyStatsRoot,
        REG_WINDOW_WIDTH_NAME,
        (DWORD *) & g_Width
        ) ;

    g_Height = DEF_WINDOW_HEIGHT ;
    RegGetValIfExist (
        g_hkeyStatsRoot,
        REG_WINDOW_HEIGHT_NAME,
        (DWORD *) & g_Height
        ) ;
}

static
CStatsWin *
CurStats (
    )
{
    assert (g_StatsCategory == TRANSPORT_STREAM ? g_VisibleStats < TS_STATS_COUNT : g_VisibleStats < PS_STATS_COUNT) ;
    return g_pAllStats [g_StatsCategory].pStats [g_VisibleStats].pStatsWin ;
}

static
BOOL
SetRefreshRate (
    IN  DWORD   dwRefreshRate
    )
{
    if (g_Timer != 0) {
        KillTimer (
            g_MainWindow,
            STATSAPP_TIMER
            ) ;
    }

    g_Timer = SetTimer (
                g_MainWindow,
                STATSAPP_TIMER,
                dwRefreshRate,
                Refresh
                ) ;

    if (g_Timer != 0) {
        g_RefreshRate = dwRefreshRate ;
        RegSetValueEx (g_hkeyStatsRoot, REG_REFRESH_RATE_NAME, NULL, REG_DWORD, (const BYTE *) & dwRefreshRate, sizeof dwRefreshRate) ;
        return TRUE ;
    }
    else {
        return FALSE ;
    }
}

static
VOID
CALLBACK
Refresh (
    IN  HWND    window,
    IN  UINT    msg,
    IN  UINT    id,
    IN  DWORD   time
    )
{
    if (CurStats () &&
        !g_fPause) {

        CurStats () -> Refresh () ;
    }
}

static
BOOL
GenerateMenu (
    IN  HWND hwnd
    )
{
    int i ;

    g_hmenuCategory     = CreateMenu () ;
    g_hmenuStats        = CreateMenu () ;
    g_hmenuOptions      = CreateMenu () ;
    g_hmenuRefreshRate  = CreateMenu () ;
    g_hmenuBar          = CreateMenu () ;
    g_hmenuActions      = CreateMenu () ;

    if (g_hmenuCategory     &&
        g_hmenuStats        &&
        g_hmenuOptions      &&
        g_hmenuRefreshRate  &&
        g_hmenuActions      &&
        g_hmenuBar) {

        //  ====================================================================

        for (i = 0; i < g_AllStatsCount; i++) {
            AppendMenu (g_hmenuCategory, MF_STRING, STATS_CATEGORY_MENU_IDM (i),  g_pAllStats [i].szTitle) ;
        }

        InsertMenu (
            g_hmenuBar,
            STATS_CATEGORY_MENU_INDEX,
            MF_STRING | MF_POPUP | MF_BYPOSITION,
            (DWORD) g_hmenuCategory,
            STATS_CATEGORY_MENU_TITLE
            ) ;

        //  ====================================================================

        InsertMenu (
            g_hmenuBar,
            STATS_MENU_INDEX,
            MF_STRING | MF_POPUP | MF_BYPOSITION,
            (DWORD) g_hmenuStats,
            STATS_MENU_TITLE
            ) ;

        //  ====================================================================

        AppendMenu (g_hmenuRefreshRate, MF_STRING, IDM_REFRESH_RATE_100_MILLIS, CMD_REFRESH_100_MILLIS) ;
        AppendMenu (g_hmenuRefreshRate, MF_STRING, IDM_REFRESH_RATE_200_MILLIS, CMD_REFRESH_200_MILLIS) ;
        AppendMenu (g_hmenuRefreshRate, MF_STRING, IDM_REFRESH_RATE_500_MILLIS, CMD_REFRESH_500_MILLIS) ;
        AppendMenu (g_hmenuRefreshRate, MF_STRING, IDM_REFRESH_RATE_1000_MILLIS, CMD_REFRESH_1000_MILLIS) ;
        AppendMenu (g_hmenuRefreshRate, MF_STRING, IDM_REFRESH_RATE_5000_MILLIS, CMD_REFRESH_5000_MILLIS) ;

        //  ====================================================================

        AppendMenu (g_hmenuOptions, MF_STRING, IDM_OPTIONS_ALWAYS_ON_TOP, CMD_ALWAYS_ON_TOP_STRING) ;
        AppendMenu (g_hmenuOptions, MF_STRING, IDM_OPTIONS_STATS_ON, CMD_STATS_ON) ;

        InsertMenu (
            g_hmenuOptions,
            -1,
            MF_STRING | MF_POPUP | MF_BYPOSITION,
            (DWORD) g_hmenuRefreshRate,
            REFRESH_RATE_MENU_TITLE
            ) ;

        InsertMenu (
            g_hmenuBar,
            OPTIONS_MENU_INDEX,
            MF_STRING | MF_POPUP | MF_BYPOSITION,
            (DWORD) g_hmenuOptions,
            OPTIONS_MENU_TITLE
            ) ;

        //  ====================================================================

        AppendMenu (g_hmenuActions, MF_STRING, IDM_PAUSE_REFRESH, CMD_PAUSE_REFRESH) ;
        AppendMenu (g_hmenuActions, MF_STRING, IDM_RESET_STATS, CMD_RESET_STATS) ;

        InsertMenu (
            g_hmenuBar,
            ACTIONS_MENU_INDEX,
            MF_STRING | MF_POPUP | MF_BYPOSITION,
            (DWORD) g_hmenuActions,
            ACTIONS_MENU_TITLE
            ) ;

        //  ====================================================================

        InsertMenu (
            g_hmenuBar,
            IDM_ABOUT,
            MF_BYCOMMAND | MF_STRING,
            IDM_ABOUT,
            CMD_ABOUT_STRING
            ) ;

        return (SetMenu (hwnd, g_hmenuBar) != NULL) ;
    }
    else {
        return FALSE ;
    }
}

CListview *
GetChildListview (
    IN  HWND hwnd
    )
{
    HWND    hwndLV ;

    hwndLV = CreateWindow (
                WC_LISTVIEW,
                __T(""),
                WS_CHILD | LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_NOSORTHEADER,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                hwnd,
                NULL,
                g_hInstance,
                NULL
                ) ;

    if (hwndLV) {
        return new CListview (hwndLV) ;
    }
    else {
        return NULL ;
    }
}

static
void
WindowResized (
    )
{
    RECT    rc ;
    DWORD   dw ;

    GetWindowRect (g_MainWindow, & rc);

    dw = rc.left ;
    RegSetValueEx (g_hkeyStatsRoot, REG_WINDOW_TOPX_NAME, NULL, REG_DWORD, (const BYTE *) & dw, sizeof dw) ;

    dw = rc.top ;
    RegSetValueEx (g_hkeyStatsRoot, REG_WINDOW_TOPY_NAME, NULL, REG_DWORD, (const BYTE *) & dw, sizeof dw) ;

    dw = rc.right - rc.left ;
    RegSetValueEx (g_hkeyStatsRoot, REG_WINDOW_WIDTH_NAME, NULL, REG_DWORD, (const BYTE *) & dw, sizeof dw) ;

    dw = rc.bottom - rc.top ;
    RegSetValueEx (g_hkeyStatsRoot, REG_WINDOW_HEIGHT_NAME, NULL, REG_DWORD, (const BYTE *) & dw, sizeof dw) ;
}

static
void
SizeStatsToClientArea (
    IN  HWND    hwnd
    )
{
    RECT    rc ;

    if (CurStats ()) {
        GetClientRect (hwnd, & rc);

        CurStats () -> Resize (
            rc.left, rc.top,
            rc.right, rc.bottom
            ) ;
    }
}

static
void
PurgeMenu (
    IN  HMENU hmenu
    )
{
	int cmenuItems = GetMenuItemCount (hmenu) ;

    while (cmenuItems && cmenuItems != -1) {
        DeleteMenu (hmenu, 0, MF_BYPOSITION) ;
		cmenuItems = GetMenuItemCount (hmenu) ;
    }
}

static
void
SelectivelyDisplayMenu (
    IN  HMENU   hmenu
    )
{
    int         i ;

    if (hmenu == g_hmenuCategory) {
        for (i = 0; i < g_AllStatsCount; i++) {
            CheckMenuItem (g_hmenuCategory, STATS_CATEGORY_MENU_IDM (i), MF_BYCOMMAND | (g_StatsCategory == i ? MF_CHECKED : MF_UNCHECKED)) ;
        }
    }
    else if (hmenu == g_hmenuStats) {
        PurgeMenu (g_hmenuStats) ;

        for (i = 0; i < g_pAllStats [g_StatsCategory].iCount; i++) {
            AppendMenu (g_hmenuStats, MF_STRING, STATS_MENU_IDM (i), g_pAllStats [g_StatsCategory].pStats[i].szMenuName) ;
            CheckMenuItem (g_hmenuStats, STATS_MENU_IDM (i), MF_BYCOMMAND | (g_VisibleStats == i ? MF_CHECKED : MF_UNCHECKED)) ;
        }
    }
    else if (hmenu == g_hmenuOptions) {
        CheckMenuItem (g_hmenuOptions, IDM_OPTIONS_ALWAYS_ON_TOP, MF_BYCOMMAND | (((GetWindowLong (g_MainWindow, GWL_EXSTYLE) & WS_EX_TOPMOST) == WS_EX_TOPMOST) ? MF_CHECKED : MF_UNCHECKED)) ;
        CheckMenuItem (g_hmenuOptions, IDM_OPTIONS_STATS_ON, MF_BYCOMMAND | (g_fStatsOn ? MF_CHECKED : MF_UNCHECKED)) ;
    }
    else if (hmenu == g_hmenuRefreshRate) {
        CheckMenuItem (g_hmenuRefreshRate, IDM_REFRESH_RATE_100_MILLIS, MF_BYCOMMAND | (g_RefreshRate == 100 ? MF_CHECKED : MF_UNCHECKED)) ;
        CheckMenuItem (g_hmenuRefreshRate, IDM_REFRESH_RATE_200_MILLIS, MF_BYCOMMAND | (g_RefreshRate == 200 ? MF_CHECKED : MF_UNCHECKED)) ;
        CheckMenuItem (g_hmenuRefreshRate, IDM_REFRESH_RATE_500_MILLIS, MF_BYCOMMAND | (g_RefreshRate == 500 ? MF_CHECKED : MF_UNCHECKED)) ;
        CheckMenuItem (g_hmenuRefreshRate, IDM_REFRESH_RATE_1000_MILLIS, MF_BYCOMMAND | (g_RefreshRate == 1000 ? MF_CHECKED : MF_UNCHECKED)) ;
        CheckMenuItem (g_hmenuRefreshRate, IDM_REFRESH_RATE_5000_MILLIS, MF_BYCOMMAND | (g_RefreshRate == 5000 ? MF_CHECKED : MF_UNCHECKED)) ;
    }
    else if (hmenu = g_hmenuActions) {
        CheckMenuItem (g_hmenuActions, IDM_PAUSE_REFRESH, MF_BYCOMMAND | (g_fPause == TRUE ? MF_CHECKED : MF_UNCHECKED)) ;
    }
}

static
BOOL
SetVisibleStats (
    IN  int iIndex
    )
{
    BOOL    fSuccess ;
    DWORD   dw ;
    BOOL    fEnable ;

    if (!g_pAllStats [g_StatsCategory].pStats [iIndex].pStatsWin) {
        g_pAllStats [g_StatsCategory].pStats [iIndex].pStatsWin = g_pAllStats [g_StatsCategory].pStats [iIndex].pfnCreate (g_hInstance, g_MainWindow) ;
    }

    if (g_pAllStats [g_StatsCategory].pStats [iIndex].pStatsWin) {
        g_VisibleStats = iIndex ;

        dw = g_VisibleStats ;
        RegSetValueEx (g_hkeyStatsRoot, REG_VISIBLE_STATS_NAME, NULL, REG_DWORD, (const BYTE *) & dw, sizeof dw) ;

        HideAllStats () ;

        SizeStatsToClientArea (g_MainWindow) ;
        CurStats () -> SetVisible (TRUE) ;
        g_pAllStats [g_StatsCategory].iLastVisible = g_VisibleStats ;

        assert (CurStats ()) ;

        fEnable = TRUE ;
        dw = CurStats () -> Enable (& fEnable) ;
        if (dw == NOERROR &&
            !fEnable) {

            MessageBox (NULL, WERE_DISABLED_MSG, WERE_DISABLED_MSG_CAPTION, MB_OK | MB_ICONINFORMATION) ;
        }

        fSuccess = (dw == NOERROR ? TRUE : FALSE) ;
    }
    else {
        MessageBox (NULL, STATS_LOAD_FAILED_MSG, STATS_LOAD_FAILED_MSG_CAPTION, MB_OK | MB_ICONINFORMATION) ;
        fSuccess = FALSE ;
    }

    return fSuccess ;
}

static
void
HideAllStats (
    )
{
    int i, k ;

    for (i = 0; i < g_AllStatsCount; i++) {
        for (k = 0; k < g_pAllStats [i].iCount; k++) {
            if (g_pAllStats [i].pStats [k].pStatsWin) {
                g_pAllStats [i].pStats [k].pStatsWin -> SetVisible (FALSE) ;
            }
        }
    }
}

static
void
ToggleAlwaysOnTop (
    IN  BOOL    f
    )
{
    DWORD   dw ;

    SetWindowPos (
        g_MainWindow,
        (f == TRUE ? HWND_NOTOPMOST : HWND_TOPMOST),
        0,0,
        0,0,
        SWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOMOVE
        ) ;

    g_fAlwaysOnTop = f ;

    dw = (g_fAlwaysOnTop == TRUE ? 1 : 0) ;
    RegSetValueEx (g_hkeyStatsRoot, REG_ALWAYS_ON_TOP_NAME, NULL, REG_DWORD, (const BYTE *) & dw, sizeof dw) ;
}

static
DWORD
SetStatsCategory (
    IN  int NewStatsCategory
    )
{
    BOOL    r ;
    DWORD   dw ;
    BOOL    fEnable ;

    g_StatsCategory = NewStatsCategory ;
    r = SetVisibleStats (g_pAllStats [g_StatsCategory].iLastVisible) ;
    if (r) {
        dw = g_StatsCategory ;
        RegSetValueEx (g_hkeyStatsRoot, REG_STATS_CATEGORY_NAME, NULL, REG_DWORD, (const BYTE *) & dw, sizeof dw) ;

        SetWindowText (g_MainWindow, g_pAllStats [g_StatsCategory].szTitle) ;
    }
    else {
        SetWindowText (g_MainWindow, NO_STATS_MODULE_LOADED) ;

        dw = ERROR_GEN_FAILURE ;
    }

    return dw ;
}

static
void
About (
    )
{
    MessageBox (NULL, ABOUT_MSG_COPYRIGHT, ABOUT_MSG_CAPTION, MB_OK | MB_TOPMOST) ;
}

static
void
ResetStats (
    )
{
    if (CurStats ()) {
        CurStats () -> Reset () ;
    }
}

LRESULT
CALLBACK
WndProc(
    IN  HWND    hwnd,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    int wmId, wmEvent ;

    switch (message) {

        case WM_INITMENUPOPUP :
            if (HIWORD(lParam) == FALSE) {
                SelectivelyDisplayMenu   ((HMENU) wParam) ;
            }
            break ;

        case WM_COMMAND:

    	    wmId	 = LOWORD(wParam) ;
    	    wmEvent = HIWORD(wParam) ;

        	switch (wmId) {

                case IDM_OPTIONS_ALWAYS_ON_TOP :
                    ToggleAlwaysOnTop (g_fAlwaysOnTop != TRUE) ;
                    break ;

                case IDM_REFRESH_RATE_100_MILLIS :
                    SetRefreshRate (100) ;
                    break ;

                case IDM_REFRESH_RATE_200_MILLIS :
                    SetRefreshRate (200) ;
                    break ;

                case IDM_REFRESH_RATE_500_MILLIS :
                    SetRefreshRate (500) ;
                    break ;

                case IDM_REFRESH_RATE_1000_MILLIS :
                    SetRefreshRate (1000) ;
                    break ;

                case IDM_REFRESH_RATE_5000_MILLIS :
                    SetRefreshRate (5000) ;
                    break ;

                case IDM_OPTIONS_STATS_ON :
                    break ;

                case IDM_PAUSE_REFRESH :
                    g_fPause = (g_fPause != TRUE) ;
                    break ;

                case IDM_RESET_STATS :
                    ResetStats () ;
                    break ;

                case IDM_ABOUT :
                    About () ;
                    break ;

        	    default :
                    if (STATS_MENU_IDM (0) <= wmId &&
                        wmId <= STATS_MENU_IDM (g_pAllStats [g_StatsCategory].iCount - 1)) {

                        if (g_VisibleStats != RECOVER_STATS_INDEX (wmId)) {
                            SetVisibleStats (RECOVER_STATS_INDEX (wmId)) ;
                        }
                    }
                    else if (STATS_CATEGORY_MENU_IDM (0) <= wmId &&
                             wmId <= STATS_CATEGORY_MENU_IDM (g_AllStatsCount - 1)) {

                        if (g_StatsCategory != RECOVER_STATS_CATEGORY_INDEX (wmId)) {
                            SetStatsCategory (RECOVER_STATS_CATEGORY_INDEX (wmId)) ;
                        }
                    }
                    break ;
            }

        	return (DefWindowProc(hwnd, message, wParam, lParam));

    	    break ;

        case WM_CREATE :

            InitCommonControls () ;

            if (!GenerateMenu (hwnd)) {

                //MessageBox (NULL, __T("Initialization failed"), NULL, MB_OK) ;
                //SendMessage (hwnd, WM_DESTROY, 0, 0) ;
                ExitProcess (EXIT_FAILURE) ;
            }
            break;

        case WM_SIZE :
            if (!IsIconic (g_MainWindow)) {
                SizeStatsToClientArea   (g_MainWindow) ;
                WindowResized           () ;
            }
            break ;

        case WM_MOVE :
            if (IsIconic (g_MainWindow) == FALSE) {
                WindowResized () ;
            }
            break ;

        case WM_DESTROY :
	        PostQuitMessage (0) ;
	        break ;

        default :
	        return (DefWindowProc(hwnd, message, wParam, lParam)) ;
   }
   return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\controls.h ===
#ifndef sender__controls_h
#define sender__controls_h

class CControlBase
{
    protected :

        HWND    m_hwnd ;
        DWORD   m_id ;

    public :

        CControlBase (
            HWND    hwnd,
            DWORD   id
            ) ;

        CControlBase (
            HWND    hwnd
            ) ;

        HWND
        GetHwnd (
            ) ;

        DWORD
        GetId (
            ) ;

        virtual
        int
        ResetContent (
            ) = 0 ;
} ;

class CListbox :
    public CControlBase
{
    enum {
        SELECT_ARRAY_MAX = 100
    } ;

    DWORD   m_SelectedArray [SELECT_ARRAY_MAX] ;
    int     m_SelectedArrayIndex ;
    int     m_cInSelectedArray ;

    public :

        CListbox (
            HWND    hwnd,
            DWORD   id
            ) ;

        int
        Append (
            TCHAR *
            ) ;

        int
        Insert (
            TCHAR *,
            int index = 0
            ) ;

        int
        ShowDirectory (
            TCHAR *
            ) ;

        int
        ShowCurrentDirectory (
            ) ;

        int
        OnDoubleClick (
            ) ;

        int
        ResetContent (
            ) ;

        int
        ResetSelectionArray (
            ) ;

        int
        GetNextSelected (
            TCHAR *,
            int
            ) ;

        int
        GetNextSelectedW (
            WCHAR *,
            int
            ) ;
} ;

class CEditControl :
    public CControlBase
{
    public :

        CEditControl (
            HWND    hwnd,
            DWORD   id
            ) ;

        void
        SetText (
            TCHAR *
            ) ;

        void
        SetText (
            INT val
            ) ;

        void
        SetTextW (
            WCHAR *
            ) ;

        int
        GetText (
            TCHAR *,
            int MaxChars
            ) ;

        int
        GetText (
            INT *   val
            ) ;

        int
        GetTextW (
            WCHAR *,
            int MaxChars
            ) ;

        int
        ResetContent (
            ) ;
} ;

class CCombobox :
    public CControlBase
{
    public :

        CCombobox (
            HWND    hwnd,
            DWORD   id) ;

        int
        Append (
            TCHAR *
            ) ;

        int
        Append (
            INT val
            ) ;

        int
        Insert (
            TCHAR *,
            int index = 0
            ) ;

        int
        Insert (
            INT val,
            int index = 0
            ) ;

        int
        GetText (
            TCHAR *,
            int MaxChars
            ) ;

        int
        GetText (
            int *
            ) ;

        int
        ResetContent (
            ) ;

        int
        Focus (
            int index = 0
            ) ;

        int
        SetItemData (
            DWORD val,
            int index
            ) ;

        int
        GetCurrentItemData (
            DWORD *
            ) ;

        int
        GetItemData (
            DWORD *,
            int index
            ) ;

        int
        GetCurrentItemIndex (
            ) ;

        int
        Find (
            TCHAR *
            ) ;

        int
        FindW (
            WCHAR *
            ) ;
} ;

class CListview :
    public CControlBase
{
    int m_cColumns ;

    HIMAGELIST
    SetImageList_ (
        HIMAGELIST,
        int
        ) ;

    public :

        CListview (
            HWND hwnd,
            DWORD id
            ) ;

        CListview (
            HWND hwnd
            ) ;

        int
        ResetContent (
            ) ;

        //  reset from row (inclusive) down
        void
        ResetContent (
            int Row         //  0-based
            ) ;

        HIMAGELIST
        SetImageList_SmallIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_NormalIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_State (
            HIMAGELIST
            ) ;

        int
        GetItemCount (
            ) ;

        BOOL
        SetState (
            int Index,      //  1-based; if 0, clears
            int Row
            ) ;

        int
        InsertColumn (
            TCHAR *,
            int ColumnWidth,
            int iCol = 0
            ) ;

        int
        InsertRowIcon (
            int
            ) ;

        int
        InsertRowText (
            TCHAR *,
            int iCol = 1
            ) ;

        int
        InsertRowValue (
            DWORD
            ) ;

        int
        InsertRowValue (
            int     row,
            DWORD   value
            ) ;

        int
        AppendRowValue (
            DWORD
            ) ;

        BOOL
        DeleteRow (
            int
            ) ;

        BOOL
        SetData (
            DWORD_PTR   dwData,
            int         iRow
            ) ;

        BOOL
        SetText (
            TCHAR *,
            int iRow,
            int iCol
            ) ;

        int
        GetSelectedCount (
            ) ;

        int
        GetSelectedRow (
            int iStartRow = -1
            ) ;

        DWORD_PTR
        GetData (
            int iRow
            ) ;

        DWORD
        GetData (
            ) ;

        void
        SetColWidth (
            int iCol,
            int iWidth
            ) ;
} ;


#endif  // sender__controls_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\mp2stats.cpp ===
#include "precomp.h"
#include "ui.h"
#include "controls.h"
#include "mp2demux.h"
#include "dvrdspriv.h"
#include "shared.h"
#include "statswin.h"
#include "mp2stats.h"

static
__inline
LONGLONG
PTSToDShow (
    IN  ULONGLONG   ullPTS
    )
{
    return (ullPTS * 1000) / 9 ;
}

//  ============================================================================

static
enum {
    MPEG2_VIDEO_GOP_HEADERS,
    MPEG2_VIDEO_I_FRAMES,
    MPEG2_VIDEO_P_FRAMES,
    MPEG2_VIDEO_B_FRAMES,

    //  always last
    MPEG2_VIDEO_STATS_COUNT,
} ;

static
TCHAR *
g_Mpeg2VideoStats [] = {
    __T("GOP Headers"),
    __T("I-Frames"),
    __T("P-Frames"),
    __T("B-Frames")
} ;

CMpeg2VideoStreamStats::CMpeg2VideoStreamStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : m_pMpeg2VideoStats  (NULL),
        CSimpleCounters     (hInstance,
                             hwndFrame,
                             MPEG2_VIDEO_STATS_COUNT,
                             g_Mpeg2VideoStats,
                             pdw
                             )
{
    HRESULT hr ;

    if ((* pdw) == NOERROR) {
        hr = CoCreateInstance (
                CLSID_DVRMpeg2VideoStreamAnalysisStats,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IDVRMpeg2VideoStreamStats,
                (void **) & m_pMpeg2VideoStats
                ) ;
        if (FAILED (hr)) {
            (* pdw) = ERROR_GEN_FAILURE ;
        }
    }
}

CMpeg2VideoStreamStats::~CMpeg2VideoStreamStats (
    )
{
    RELEASE_AND_CLEAR (m_pMpeg2VideoStats) ;
}

void
CMpeg2VideoStreamStats::Refresh (
    )
{
    ULONGLONG   ullGOPHeaders ;
    ULONGLONG   ullIFrames ;
    ULONGLONG   ullPFrames ;
    ULONGLONG   ullBFrames ;

    assert (m_pMpeg2VideoStats) ;
    m_pMpeg2VideoStats -> GetFrameCounts (
        & ullIFrames,
        & ullPFrames,
        & ullBFrames
        ) ;

    m_pMpeg2VideoStats -> GetGOPHeaderCount (
        & ullGOPHeaders
        ) ;

    SetVal_ (MPEG2_VIDEO_GOP_HEADERS,   ullGOPHeaders) ;
    SetVal_ (MPEG2_VIDEO_I_FRAMES,      ullIFrames) ;
    SetVal_ (MPEG2_VIDEO_P_FRAMES,      ullPFrames) ;
    SetVal_ (MPEG2_VIDEO_B_FRAMES,      ullBFrames) ;
}

DWORD
CMpeg2VideoStreamStats::Enable (
    IN OUT  BOOL * pf
    )
{
    HRESULT hr ;

    hr = m_pMpeg2VideoStats -> Enable (pf) ;
    return (SUCCEEDED (hr) ? NOERROR : ERROR_GEN_FAILURE) ;
}

CMpeg2VideoStreamStats *
CMpeg2VideoStreamStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CMpeg2VideoStreamStats *    pVideoStreamStats ;
    DWORD                       dwRet ;

    pVideoStreamStats = new CMpeg2VideoStreamStats (
                                    hInstance,
                                    hwndFrame,
                                    & dwRet
                                    ) ;
    if (!pVideoStreamStats ||
        dwRet != NOERROR) {

        DELETE_RESET (pVideoStreamStats) ;
    }

    return pVideoStreamStats ;
}

//  ============================================================================

static
enum {
    TIME_STATS_DEMUX_IS_REF,
    TIME_STATS_SLOPE_OBSERVED,
    TIME_STATS_SLOPE_USED,
    TIME_STATS_CARRY,
    TIME_STATS_ADJUSTMENTS_UP,
    TIME_STATS_ADJUSTMENTS_DOWN,
    TIME_STATS_DEGRADATIONS,
    TIME_STATS_PTS_REF_DELTA,
    TIME_STATS_TIME_DISCONTINUITIES,
    TIME_STATS_BASE_PCR,
    TIME_STATS_LAST_PCR,
    TIME_STATS_BASE_PCR_DSHOW,
    TIME_STATS_LAST_PCR_DSHOW,
    TIME_STATS_VIDEO_PTS_BASE,
    TIME_STATS_LAST_VIDEO_PTS,
    TIME_STATS_VIDEO_PTS_COUNT,
    TIME_STATS_INVALID_VIDEO_PTS_COUNT,
    TIME_STATS_AUDIO_PTS_BASE,
    TIME_STATS_LAST_AUDIO_PTS,
    TIME_STATS_AUDIO_PTS_COUNT,
    TIME_STATS_INVALID_AUDIO_PTS_COUNT,
    TIME_STATS_OUT_OF_BOUNDS_PTS,
    TIME_STATS_AV_DIFF_MILLIS,                  //  millis between a/v timestamps

    //  always last
    TIME_STATS_COUNT
} ;

static
TCHAR *
g_TimerStats [] = {
    __T("Demux == IReferenceClock"),
    __T("Observed"),
    __T("Used"),
    __T("Carry"),
    __T("Adjustments (+)"),
    __T("Adjustments (-)"),
    __T("Degradations"),
    __T("PTS - IRef Delta"),
    __T("Time Discontinuities"),
    __T("Base PCR"),
    __T("Last PCR"),
    __T("Base PCR (dshow)"),
    __T("Last PCR (dshow)"),
    __T("Video PTS Base (dshow)"),
    __T("Last video PTS (dshow)"),
    __T("video PTS count"),
    __T("invalid video PTS count"),
    __T("Audio PTS Base (dshow)"),
    __T("Last audio PTS (dshow)"),
    __T("audio PTS count"),
    __T("invalid audio PTS count"),
    __T("out-of-bounds PTSs"),
    __T("A/V Difference (millis)"),
} ;

CMpeg2TimeStats::CMpeg2TimeStats (
    IN  HINSTANCE               hInstance,
    IN  HWND                    hwndFrame,
    OUT DWORD *                 pdw
    ) : m_pMpeg2TimeStats   (NULL),
        m_dwReset           (0),
        m_pbReset           (NULL),
        CSimpleCounters     (hInstance,
                             hwndFrame,
                             TIME_STATS_COUNT,
                             g_TimerStats,
                             pdw
                             ) {}

void
CMpeg2TimeStats::Refresh (
    )
{
    static  TCHAR   achbuffer [64] ;

    assert (m_pMpeg2TimeStats) ;

    _stprintf (achbuffer, __T("%s"), m_pMpeg2TimeStats -> ClockSlave.fDemuxIsIRefClock ? __T("YES") : __T("NO")) ;
    SetVal_ (TIME_STATS_DEMUX_IS_REF, achbuffer) ;

    _stprintf (achbuffer, __T("%2.10f"), m_pMpeg2TimeStats -> ClockSlave.dPerPCRObservedSlope) ;
    SetVal_ (TIME_STATS_SLOPE_OBSERVED, achbuffer) ;

    _stprintf (achbuffer, __T("%2.10f"), m_pMpeg2TimeStats -> ClockSlave.dIRefClockUsedSlope) ;
    SetVal_ (TIME_STATS_SLOPE_USED, achbuffer) ;

    _stprintf (achbuffer, __T("%2.10f"), m_pMpeg2TimeStats -> ClockSlave.dCarry) ;
    SetVal_ (TIME_STATS_CARRY, achbuffer) ;

    SetVal_ (TIME_STATS_ADJUSTMENTS_UP,             m_pMpeg2TimeStats -> ClockSlave.llUpwardAdjustments) ;
    SetVal_ (TIME_STATS_ADJUSTMENTS_DOWN,           m_pMpeg2TimeStats -> ClockSlave.llDownwardAdjustments) ;
    SetVal_ (TIME_STATS_DEGRADATIONS,               m_pMpeg2TimeStats -> ClockSlave.llAllowableErrorDegradations) ;
    SetVal_ (TIME_STATS_PTS_REF_DELTA,              m_pMpeg2TimeStats -> TimeStamp.rtPES_PTSToGraphClockDelta) ;
    SetVal_ (TIME_STATS_TIME_DISCONTINUITIES,       m_pMpeg2TimeStats -> cTimeDiscontinuities) ;
    SetVal_ (TIME_STATS_BASE_PCR,                   m_pMpeg2TimeStats -> TimeStamp.llBasePCR) ;
    SetVal_ (TIME_STATS_LAST_PCR,                   m_pMpeg2TimeStats -> TimeStamp.llLastPCR) ;
    SetVal_ (TIME_STATS_BASE_PCR_DSHOW,             PTSToDShow (m_pMpeg2TimeStats -> TimeStamp.llBasePCR / 300)) ;
    SetVal_ (TIME_STATS_LAST_PCR_DSHOW,             PTSToDShow (m_pMpeg2TimeStats -> TimeStamp.llLastPCR / 300)) ;
    SetVal_ (TIME_STATS_VIDEO_PTS_BASE,             m_pMpeg2TimeStats -> TimeStamp.rtVideoStreamPTSBase) ;
    SetVal_ (TIME_STATS_LAST_VIDEO_PTS,             m_pMpeg2TimeStats -> TimeStamp.rtVideoPESPTS) ;
    SetVal_ (TIME_STATS_VIDEO_PTS_COUNT,            m_pMpeg2TimeStats -> TimeStamp.cVideoPESPTS) ;
    SetVal_ (TIME_STATS_INVALID_VIDEO_PTS_COUNT,    m_pMpeg2TimeStats -> TimeStamp.cVideoInvalidPESPTS) ;
    SetVal_ (TIME_STATS_AUDIO_PTS_BASE,             m_pMpeg2TimeStats -> TimeStamp.rtAudioStreamPTSBase) ;
    SetVal_ (TIME_STATS_LAST_AUDIO_PTS,             m_pMpeg2TimeStats -> TimeStamp.rtAudioPESPTS) ;
    SetVal_ (TIME_STATS_AUDIO_PTS_COUNT,            m_pMpeg2TimeStats -> TimeStamp.cAudioPESPTS) ;
    SetVal_ (TIME_STATS_INVALID_AUDIO_PTS_COUNT,    m_pMpeg2TimeStats -> TimeStamp.cAudioInvalidPESPTS) ;
    SetVal_ (TIME_STATS_OUT_OF_BOUNDS_PTS,          m_pMpeg2TimeStats -> TimeStamp.cPTS_PCROutOfBoundsDelta) ;
    SetVal_ (TIME_STATS_AV_DIFF_MILLIS,             (m_pMpeg2TimeStats -> TimeStamp.rtVideoPESPTS - m_pMpeg2TimeStats -> TimeStamp.rtAudioPESPTS) / 10000) ;
}

void
CMpeg2TimeStats::Reset (
    )
{
    BOOL    f ;

    assert (m_pbReset) ;
    assert (m_pMpeg2TimeStats) ;

    f = m_pMpeg2TimeStats -> ClockSlave.fDemuxIsIRefClock ;

    ZeroMemory (m_pbReset, m_dwReset) ;

    m_pMpeg2TimeStats -> ClockSlave.fDemuxIsIRefClock = f ;
}

//  ============================================================================

static
enum {
    GLOBAL_MPEG2_STATS_PACKETS,
    GLOBAL_MPEG2_STATS_PES_PACKETS,
    GLOBAL_MPEG2_STATS_MPEG2_ERRORS,
    GLOBAL_MPEG2_STATS_NEW_PAYLOADS,
    GLOBAL_MPEG2_STATS_DISCONTINUITIES,
    GLOBAL_MPEG2_STATS_SYNCPOINTS,
    GLOBAL_MPEG2_STATS_MAPPED_PACKETS,
    GLOBAL_MPEG2_STATS_DROPPED_PACKETS,
    GLOBAL_MPEG2_STATS_ABORTED_MEDIA_SAMPLES,
    GLOBAL_MPEG2_STATS_ABORTED_BYTES,
    GLOBAL_MPEG2_STATS_INPUT_MEDIA_SAMPLES,
    GLOBAL_MPEG2_STATS_OUTPUT_MEDIA_SAMPLES,
    GLOBAL_MPEG2_STATS_TOTAL_BYTES,
    GLOBAL_MPEG2_STATS_MBPS,

    //  always last
    GLOBAL_MPEG2_STATS_COUNT
} ;
//  ---------------------------------------------
//  maintain 1-1 correspondence between these two
//  ---------------------------------------------
static
TCHAR *
g_GlobalMpeg2Stats [] = {
    __T("Packets"),
    __T("PES Packets"),
    __T("Mpeg2 Errors"),
    __T("New Payloads"),
    __T("Discontinuities"),
    __T("Sync Points"),
    __T("Mapped Packets"),
    __T("Dropped Packets"),
    __T("Aborted Media Samples"),
    __T("Aborted Bytes"),
    __T("Media Samples Received"),
    __T("Media Samples Sent"),
    __T("Total Bytes"),
    __T("Mbps"),
} ;

CMpeg2GlobalStats::CMpeg2GlobalStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : m_pMpeg2GlobalStats (NULL),
        m_ullLastTotalBytes (0),
        m_dwMillisLast      (0),
        m_dwReset           (0),
        m_pbReset           (NULL),
        CSimpleCounters     (hInstance,
                             hwndFrame,
                             GLOBAL_MPEG2_STATS_COUNT,
                             g_GlobalMpeg2Stats,
                             pdw
                             ) {}

void
CMpeg2GlobalStats::Refresh (
    )
{
    DWORD       dwMillisNow ;
    ULONGLONG   ullCurTotalBytes ;
    DWORD       dwDeltaMillis ;
    DWORD       dwDeltaBits ;
    double      dMbps ;
    static TCHAR    achMbps [32] ;

    assert (m_pMpeg2GlobalStats) ;

    dwMillisNow         = GetTickCount () ;
    ullCurTotalBytes    = GetTotalBytes_ () ;
    m_ullLastTotalBytes = Min <ULONGLONG> (m_ullLastTotalBytes, ullCurTotalBytes) ;

    dwDeltaMillis   = (m_dwMillisLast > 0 ? dwMillisNow - m_dwMillisLast : 0) ;
    dwDeltaBits     = (DWORD) ((ullCurTotalBytes - m_ullLastTotalBytes) * 8) ;

    m_ullLastTotalBytes = ullCurTotalBytes ;
    m_dwMillisLast      = dwMillisNow ;

    if (dwDeltaMillis > 0) {
        dMbps = (((double) dwDeltaBits) / ((double) dwDeltaMillis) * 1000.0) / 1000000.0 ;
    }
    else {
        dMbps = 0.0 ;
    }
    _stprintf (achMbps, __T("%3.1f"), dMbps) ;

    SetVal_ (GLOBAL_MPEG2_STATS_PACKETS,                m_pMpeg2GlobalStats -> cGlobalPackets) ;
    SetVal_ (GLOBAL_MPEG2_STATS_PES_PACKETS,            m_pMpeg2GlobalStats -> cGlobalPESPackets) ;
    SetVal_ (GLOBAL_MPEG2_STATS_MPEG2_ERRORS,           m_pMpeg2GlobalStats -> cGlobalMPEG2Errors) ;
    SetVal_ (GLOBAL_MPEG2_STATS_NEW_PAYLOADS,           m_pMpeg2GlobalStats -> cGlobalNewPayloads) ;
    SetVal_ (GLOBAL_MPEG2_STATS_DISCONTINUITIES,        m_pMpeg2GlobalStats -> cGlobalDiscontinuities) ;
    SetVal_ (GLOBAL_MPEG2_STATS_SYNCPOINTS,             m_pMpeg2GlobalStats -> cGlobalSyncPoints) ;
    SetVal_ (GLOBAL_MPEG2_STATS_MAPPED_PACKETS,         m_pMpeg2GlobalStats -> cGlobalMappedPackets) ;
    SetVal_ (GLOBAL_MPEG2_STATS_DROPPED_PACKETS,        m_pMpeg2GlobalStats -> cGlobalDroppedPackets) ;
    SetVal_ (GLOBAL_MPEG2_STATS_ABORTED_MEDIA_SAMPLES,  m_pMpeg2GlobalStats -> cGlobalAbortedMediaSamples) ;
    SetVal_ (GLOBAL_MPEG2_STATS_ABORTED_BYTES,          m_pMpeg2GlobalStats -> cGlobalAbortedBytes) ;
    SetVal_ (GLOBAL_MPEG2_STATS_INPUT_MEDIA_SAMPLES,    m_pMpeg2GlobalStats -> cGlobalInputMediaSamples) ;
    SetVal_ (GLOBAL_MPEG2_STATS_OUTPUT_MEDIA_SAMPLES,   m_pMpeg2GlobalStats -> cGlobalOutputMediaSamples) ;
    SetVal_ (GLOBAL_MPEG2_STATS_TOTAL_BYTES,            ullCurTotalBytes) ;
    SetVal_ (GLOBAL_MPEG2_STATS_MBPS,                   achMbps) ;
}

void
CMpeg2GlobalStats::Reset (
    )
{
    BOOL    f ;

    assert (m_pbReset) ;
    assert (m_pMpeg2GlobalStats) ;

    f = m_pMpeg2GlobalStats -> TimeStats.ClockSlave.fDemuxIsIRefClock ;

    ZeroMemory (m_pbReset, m_dwReset) ;

    m_pMpeg2GlobalStats -> TimeStats.ClockSlave.fDemuxIsIRefClock = f ;

    m_dwMillisLast = 0 ;
}

//  ============================================================================

CMpeg2TransportGlobalStats::CMpeg2TransportGlobalStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : CMpeg2GlobalStats   (hInstance,
                             hwndFrame,
                             pdw
                             )
{
    if ((* pdw) != NOERROR) {
        goto cleanup ;
    }

    (* pdw) = m_Mpeg2TransportStatsCOM.Init () ;

    m_pMpeg2GlobalStats = reinterpret_cast <MPEG2_STATS_GLOBAL *> (m_Mpeg2TransportStatsCOM.GetShared ()) ;
    m_pbReset           = m_Mpeg2TransportStatsCOM.GetShared () ;
    m_dwReset           = m_Mpeg2TransportStatsCOM.GetSize () ;

    cleanup :

    return ;
}

ULONGLONG
CMpeg2TransportGlobalStats::GetTotalBytes_ (
    )
{
    assert (m_pMpeg2GlobalStats) ;
    return m_pMpeg2GlobalStats -> cGlobalPackets * TRANSPORT_PACKET_LEN ;
}

CMpeg2TransportGlobalStats *
CMpeg2TransportGlobalStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CMpeg2TransportGlobalStats *    pGlobalTransportStats ;
    DWORD                           dwRet ;

    pGlobalTransportStats = new CMpeg2TransportGlobalStats (
                            hInstance,
                            hwndFrame,
                            & dwRet
                            ) ;
    if (!pGlobalTransportStats ||
        dwRet != NOERROR) {

        DELETE_RESET (pGlobalTransportStats) ;
    }

    return pGlobalTransportStats ;
}

//  ============================================================================

CMpeg2ProgramGlobalStats::CMpeg2ProgramGlobalStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : CMpeg2GlobalStats   (hInstance,
                             hwndFrame,
                             pdw
                             )
{
    if ((* pdw) != NOERROR) {
        goto cleanup ;
    }

    (* pdw) = m_Mpeg2ProgramStatsCOM.Init () ;

    m_pMpeg2GlobalStats = reinterpret_cast <MPEG2_STATS_GLOBAL *> (m_Mpeg2ProgramStatsCOM.GetShared ()) ;
    m_pbReset           = m_Mpeg2ProgramStatsCOM.GetShared () ;
    m_dwReset           = m_Mpeg2ProgramStatsCOM.GetSize () ;

    m_pMpeg2ProgramStats = reinterpret_cast <MPEG2_PROGRAM_STATS *> (m_Mpeg2ProgramStatsCOM.GetShared ()) ;


    cleanup :

    return ;
}

ULONGLONG
CMpeg2ProgramGlobalStats::GetTotalBytes_ (
    )
{
    assert (m_pMpeg2ProgramStats) ;
    return m_pMpeg2ProgramStats -> cBytesProcessed ;
}

CMpeg2ProgramGlobalStats *
CMpeg2ProgramGlobalStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CMpeg2ProgramGlobalStats *  pGlobalProgramStats ;
    DWORD                       dwRet ;

    pGlobalProgramStats = new CMpeg2ProgramGlobalStats (
                            hInstance,
                            hwndFrame,
                            & dwRet
                            ) ;
    if (!pGlobalProgramStats ||
        dwRet != NOERROR) {

        DELETE_RESET (pGlobalProgramStats) ;
    }

    return pGlobalProgramStats ;
}

//  ============================================================================

CMpeg2TransportTimeStats::CMpeg2TransportTimeStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : CMpeg2TimeStats (hInstance,
                         hwndFrame,
                         pdw
                         )
{
    MPEG2_STATS_GLOBAL *    pGlobalStats ;

    if ((* pdw) != NOERROR) {
        goto cleanup ;
    }

    (* pdw) = m_Mpeg2TransportStatsCOM.Init () ;
    if ((* pdw) == NOERROR) {
        m_pMpeg2TimeStats = & (((MPEG2_STATS_GLOBAL *) m_Mpeg2TransportStatsCOM.GetShared ()) -> TimeStats) ;

        m_pbReset   = m_Mpeg2TransportStatsCOM.GetShared () ;
        m_dwReset   = m_Mpeg2TransportStatsCOM.GetSize () ;
    }

    cleanup :

    return ;
}

CMpeg2TransportTimeStats *
CMpeg2TransportTimeStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CMpeg2TransportTimeStats *  pTimeTransportStats ;
    DWORD                       dwRet ;

    pTimeTransportStats = new CMpeg2TransportTimeStats (
                                hInstance,
                                hwndFrame,
                                & dwRet
                                ) ;
    if (!pTimeTransportStats ||
        dwRet != NOERROR) {

        DELETE_RESET (pTimeTransportStats) ;
    }

    return pTimeTransportStats ;
}

//  ============================================================================

CMpeg2ProgramTimeStats::CMpeg2ProgramTimeStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : CMpeg2TimeStats (hInstance,
                         hwndFrame,
                         pdw
                         )
{
    MPEG2_STATS_GLOBAL *    pGlobalStats ;

    if ((* pdw) != NOERROR) {
        goto cleanup ;
    }

    (* pdw) = m_Mpeg2ProgramStatsCOM.Init () ;
    if ((* pdw) == NOERROR) {
        m_pMpeg2TimeStats = & (((MPEG2_STATS_GLOBAL *) m_Mpeg2ProgramStatsCOM.GetShared ()) -> TimeStats) ;

        m_pbReset   = m_Mpeg2ProgramStatsCOM.GetShared () ;
        m_dwReset   = m_Mpeg2ProgramStatsCOM.GetSize () ;
    }

    cleanup :

    return ;
}

CMpeg2ProgramTimeStats *
CMpeg2ProgramTimeStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CMpeg2ProgramTimeStats *    pTimeProgramStats ;
    DWORD                       dwRet ;

    pTimeProgramStats = new CMpeg2ProgramTimeStats (
                                hInstance,
                                hwndFrame,
                                & dwRet
                                ) ;
    if (!pTimeProgramStats ||
        dwRet != NOERROR) {

        DELETE_RESET (pTimeProgramStats) ;
    }

    return pTimeProgramStats ;
}

//  ============================================================================

static
enum {
    PER_PID_STATS_PID,
    PER_PID_STATS_PACKETS,
    PER_PID_STATS_MPEG2_ERRORS,
    PER_PID_STATS_NEW_PAYLOADS,
    PER_PID_STATS_DISCONTINUITIES,
    PER_PID_STATS_MAPPED_PACKETS,
    PER_PID_STATS_DROPPED_PACKETS,
    PER_PID_STATS_BITRATE,

    //  always last
    PER_PID_STATS_COUNTERS
} ;
//  keep in sync
static
COL_DETAIL
g_PerPIDColumns [] = {
    { __T("PID"),             60 },
    { __T("Packets"),         80 },
    { __T("MPEG-2 Errors"),   100 },
    { __T("Payloads"),        80 },
    { __T("Discontinuities"), 100 },
    { __T("Mapped"),          80 },
    { __T("Dropped"),         80 },
    { __T("Mbps"),            60 },
} ;

CMpeg2TransportPIDStats::CMpeg2TransportPIDStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : m_pMpeg2TransportStats  (NULL),
        m_dwMillisLast          (0),
        CLVStatsWin             (hInstance,
                                 hwndFrame,
                                 PER_PID_STATS_COUNTERS,
                                 g_PerPIDColumns,
                                 0,
                                 pdw
                                 )
{
    if ((* pdw) != NOERROR) {
        goto cleanup ;
    }

    (* pdw) = m_Mpeg2TransportStatsCOM.Init () ;
    if ((* pdw) == NOERROR) {
        m_pMpeg2TransportStats = (MPEG2_TRANSPORT_STATS *) m_Mpeg2TransportStatsCOM.GetShared () ;
    }

    cleanup :

    return ;
}

CMpeg2TransportPIDStats::~CMpeg2TransportPIDStats (
    )
{
    PurgeTable_ () ;
}

void
CMpeg2TransportPIDStats::PurgeTable_ (
    )
{
    PER_STREAM_CONTEXT *    pPerStreamContext ;

    while (GetRowCount_ () > 0) {
        pPerStreamContext = (PER_STREAM_CONTEXT *) GetRowsetValue_ (0) ;
        delete pPerStreamContext ;

        DeleteRow_ (0) ;
    }
}

void
CMpeg2TransportPIDStats::Refresh (
    )
{
    static TCHAR            ach [64] ;
    int                     LVRows ;
    int                     pid ;
    BOOL                    r ;
    DWORD                   deltaBits ;
    DWORD                   deltaMillis ;
    DWORD                   MillisNow ;
    PER_STREAM_CONTEXT *    pPerStreamContext ;
    int                     row ;
    double                  dMbps ;
    DWORD                   dw ;

    assert (m_pMpeg2TransportStats) ;

    MillisNow       = GetTickCount () ;
    deltaMillis     = (m_dwMillisLast > 0 ? MillisNow - m_dwMillisLast : 0) ;
    m_dwMillisLast  = MillisNow ;

    LVRows = GetRowCount_ () ;
    for (pid = 0, row = 0; pid < DISTINCT_PID_COUNT; pid++) {

        if (m_pMpeg2TransportStats -> PID [pid].cPIDPackets > 0) {

            if ((LVRows > row && ((PER_STREAM_CONTEXT *) GetRowsetValue_ (row)) -> Stream != (DWORD) pid) ||
                LVRows == row) {

                //  new PID

                pPerStreamContext = new PER_STREAM_CONTEXT ;
                if (pPerStreamContext == NULL) {
                    return ;
                }

                pPerStreamContext -> Stream = pid ;
                memset ((void *) & pPerStreamContext -> LastCount, 0xff, sizeof pPerStreamContext -> LastCount) ;

                dw = InsertRow_ (row) ;
                if (dw != NOERROR) {
                    delete pPerStreamContext ;
                    return ;
                }

                dw = SetRowsetValue_ (row, (DWORD_PTR) pPerStreamContext) ;
                if (dw != NOERROR) {
                    return ;
                }

                LVRows++ ;

                _stprintf (ach, __T("0x%x"), pid) ;
                r = CellDisplayText_ (row, PER_PID_STATS_PID, ach) ;
            }
            else {
                //  existing PID
                pPerStreamContext = (PER_STREAM_CONTEXT *) GetRowsetValue_ (row) ;
            }

            CellDisplayValue_ (row, PER_PID_STATS_PACKETS,            m_pMpeg2TransportStats -> PID [pid].cPIDPackets) ;
            CellDisplayValue_ (row, PER_PID_STATS_MPEG2_ERRORS,       m_pMpeg2TransportStats -> PID [pid].cPIDMPEG2Errors) ;
            CellDisplayValue_ (row, PER_PID_STATS_NEW_PAYLOADS,       m_pMpeg2TransportStats -> PID [pid].cPIDNewPayloads) ;
            CellDisplayValue_ (row, PER_PID_STATS_DISCONTINUITIES,    m_pMpeg2TransportStats -> PID [pid].cPIDDiscontinuities) ;
            CellDisplayValue_ (row, PER_PID_STATS_MAPPED_PACKETS,     m_pMpeg2TransportStats -> PID [pid].cPIDMappedPackets) ;
            CellDisplayValue_ (row, PER_PID_STATS_DROPPED_PACKETS,    m_pMpeg2TransportStats -> PID [pid].cPIDDroppedPackets) ;

            pPerStreamContext -> LastCount = Min <LONGLONG> (pPerStreamContext -> LastCount, m_pMpeg2TransportStats -> PID [pid].cPIDPackets) ;

            if (deltaMillis > 0) {
                deltaBits = (DWORD) (m_pMpeg2TransportStats -> PID [pid].cPIDPackets - pPerStreamContext -> LastCount) * TS_PACKET_LEN * 8 ;
                dMbps = (((double) deltaBits) / ((double) deltaMillis) * 1000.0) / 1000000.0 ;
            }
            else {
                dMbps = 0.0 ;
            }

            pPerStreamContext -> LastCount = m_pMpeg2TransportStats -> PID [pid].cPIDPackets ;

            _stprintf (ach, __T("%3.1f"), dMbps) ;
            r = CellDisplayText_ (row, PER_PID_STATS_BITRATE, ach) ;

            row++ ;
        }
    }
}

void
CMpeg2TransportPIDStats::Reset (
    )
{
    BOOL    f ;

    assert (m_pMpeg2TransportStats) ;

    f = m_pMpeg2TransportStats -> GlobalStats.TimeStats.ClockSlave.fDemuxIsIRefClock ;

    ZeroMemory (m_Mpeg2TransportStatsCOM.GetShared (), m_Mpeg2TransportStatsCOM.GetSize ()) ;

    m_pMpeg2TransportStats -> GlobalStats.TimeStats.ClockSlave.fDemuxIsIRefClock = f ;

    PurgeTable_ () ;
    m_dwMillisLast = 0 ;
}

CMpeg2TransportPIDStats *
CMpeg2TransportPIDStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CMpeg2TransportPIDStats *   pMpeg2TransportPIDStats ;
    DWORD                       dwRet ;

    pMpeg2TransportPIDStats = new CMpeg2TransportPIDStats (
                                hInstance,
                                hwndFrame,
                                & dwRet
                                ) ;
    if (!pMpeg2TransportPIDStats ||
        dwRet != NOERROR) {

        DELETE_RESET (pMpeg2TransportPIDStats) ;
    }

    return pMpeg2TransportPIDStats ;
}

//  ============================================================================

static
enum {
    PER_STREAM_STATS_STREAM_ID,
    PER_STREAM_STATS_PACKETS,
    PER_STREAM_STATS_MAPPED_PACKETS,
    PER_STREAM_STATS_DROPPED_PACKETS,
    PER_STREAM_STATS_BYTES_PROCESSED,
    PER_STREAM_STATS_BITRATE,

    //  always last
    PER_STREAM_STATS_COUNTERS
} ;
//  keep in sync
static
COL_DETAIL
g_PerStreamColumns [] = {
    { __T("stream_id"),       70 },
    { __T("Packets"),         80 },
    { __T("Mapped"),          80 },
    { __T("Dropped"),         80 },
    { __T("Bytes"),           80 },
    { __T("Mbps"),            50 },
} ;

CMpeg2ProgramStreamIdStats::CMpeg2ProgramStreamIdStats (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    OUT DWORD *     pdw
    ) : m_pMpeg2ProgramStats    (NULL),
        m_dwMillisLast          (0),
        CLVStatsWin             (hInstance,
                                 hwndFrame,
                                 PER_STREAM_STATS_COUNTERS,
                                 g_PerStreamColumns,
                                 0,
                                 pdw
                                 )
{
    if ((* pdw) != NOERROR) {
        goto cleanup ;
    }

    (* pdw) = m_Mpeg2ProgramStatsCOM.Init () ;
    if ((* pdw) == NOERROR) {
        m_pMpeg2ProgramStats = (MPEG2_PROGRAM_STATS *) m_Mpeg2ProgramStatsCOM.GetShared () ;
    }

    cleanup :

    return ;
}

CMpeg2ProgramStreamIdStats::~CMpeg2ProgramStreamIdStats (
    )
{
    PurgeTable_ () ;
}

void
CMpeg2ProgramStreamIdStats::PurgeTable_ (
    )
{
    PER_STREAM_CONTEXT *    pPerStreamContext ;

    while (GetRowCount_ () > 0) {
        pPerStreamContext = (PER_STREAM_CONTEXT *) GetRowsetValue_ (0) ;
        delete pPerStreamContext ;

        DeleteRow_ (0) ;
    }
}

void
CMpeg2ProgramStreamIdStats::Refresh (
    )
{
    static TCHAR            ach [64] ;
    PER_STREAM_CONTEXT *    pPerStreamContext ;
    int                     LVRows ;
    int                     stream_id ;
    BOOL                    r ;
    int                     row ;
    double                  dMbps ;
    DWORD                   deltaBits ;
    DWORD                   MillisNow ;
    DWORD                   deltaMillis ;
    DWORD                   dw ;

    MillisNow       = GetTickCount () ;
    deltaMillis     = (m_dwMillisLast > 0 ? MillisNow - m_dwMillisLast : 0) ;
    m_dwMillisLast  = MillisNow ;

    LVRows = GetRowCount_ () ;
    for (stream_id = 0, row = 0; stream_id < DISTINCT_STREAM_ID_COUNT; stream_id++) {

        if (m_pMpeg2ProgramStats -> StreamId [stream_id].cStreamIdPackets > 0) {

            if ((LVRows > row && ((PER_STREAM_CONTEXT *) GetRowsetValue_ (row)) -> Stream != (DWORD) stream_id) ||
                LVRows == row) {

                //  new stream_id

                //  create new stream
                pPerStreamContext = new PER_STREAM_CONTEXT ;
                if (pPerStreamContext == NULL) {
                    return ;
                }

                pPerStreamContext -> Stream = stream_id ;
                memset ((void *) & pPerStreamContext -> LastCount, 0xff, sizeof pPerStreamContext -> LastCount) ;

                dw = InsertRow_ (row) ;
                if (dw != NOERROR) {
                    delete pPerStreamContext ;
                    return ;
                }

                dw = SetRowsetValue_ (row, (DWORD_PTR) pPerStreamContext) ;
                if (dw != NOERROR) {
                    return ;
                }

                LVRows++ ;

                _stprintf (ach, __T("0x%x"), stream_id) ;
                r = CellDisplayText_ (row, PER_STREAM_STATS_STREAM_ID, ach) ;
            }
            else {
                //  existing stream_id
                pPerStreamContext = (PER_STREAM_CONTEXT *) GetRowsetValue_ (row) ;
            }

            CellDisplayValue_ (row, PER_STREAM_STATS_PACKETS,            m_pMpeg2ProgramStats -> StreamId [stream_id].cStreamIdPackets) ;
            CellDisplayValue_ (row, PER_STREAM_STATS_MAPPED_PACKETS,     m_pMpeg2ProgramStats -> StreamId [stream_id].cStreamIdMapped) ;
            CellDisplayValue_ (row, PER_STREAM_STATS_DROPPED_PACKETS,    m_pMpeg2ProgramStats -> StreamId [stream_id].cStreamIdDropped) ;
            CellDisplayValue_ (row, PER_STREAM_STATS_BYTES_PROCESSED,    m_pMpeg2ProgramStats -> StreamId [stream_id].cBytesProcessed) ;

            pPerStreamContext -> LastCount = Min <LONGLONG> (pPerStreamContext -> LastCount, m_pMpeg2ProgramStats -> StreamId [stream_id].cBytesProcessed) ;

            if (deltaMillis > 0) {
                deltaBits = (DWORD) (m_pMpeg2ProgramStats -> StreamId [stream_id].cBytesProcessed - pPerStreamContext -> LastCount) * 8 ;
                dMbps = (((double) deltaBits) / ((double) deltaMillis) * 1000.0) / 1000000.0 ;
            }
            else {
                dMbps = 0.0 ;
            }

            pPerStreamContext -> LastCount = m_pMpeg2ProgramStats -> StreamId [stream_id].cBytesProcessed ;

            _stprintf (ach, __T("%3.1f"), dMbps) ;
            r = CellDisplayText_ (row, PER_STREAM_STATS_BITRATE, ach) ;

            row++ ;
        }
    }
}

void
CMpeg2ProgramStreamIdStats::Reset (
    )
{
    BOOL    f ;

    assert (m_pMpeg2ProgramStats) ;

    f = m_pMpeg2ProgramStats -> GlobalStats.TimeStats.ClockSlave.fDemuxIsIRefClock ;

    ZeroMemory (m_Mpeg2ProgramStatsCOM.GetShared (), m_Mpeg2ProgramStatsCOM.GetSize ()) ;

    m_pMpeg2ProgramStats -> GlobalStats.TimeStats.ClockSlave.fDemuxIsIRefClock = f ;

    PurgeTable_ () ;
    m_dwMillisLast = 0 ;
}

CMpeg2ProgramStreamIdStats *
CMpeg2ProgramStreamIdStats::CreateInstance (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    )
{
    CMpeg2ProgramStreamIdStats *   pMpeg2ProgramStreamIdStats ;
    DWORD                       dwRet ;

    pMpeg2ProgramStreamIdStats = new CMpeg2ProgramStreamIdStats (
                                hInstance,
                                hwndFrame,
                                & dwRet
                                ) ;
    if (!pMpeg2ProgramStreamIdStats ||
        dwRet != NOERROR) {

        DELETE_RESET (pMpeg2ProgramStreamIdStats) ;
    }

    return pMpeg2ProgramStreamIdStats ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\mp2stats.h ===
#ifndef __mp2stats_h
#define __mp2stats_h

//  ============================================================================

class CMpeg2VideoStreamStats :
    public CSimpleCounters
{
    IDVRMpeg2VideoStreamStats * m_pMpeg2VideoStats ;

    public :

        CMpeg2VideoStreamStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        ~CMpeg2VideoStreamStats (
            ) ;

        virtual void    Refresh () ;
        virtual DWORD   Enable  (BOOL * pf) ;

        static
        CMpeg2VideoStreamStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

//  ============================================================================

class CMpeg2TimeStats :
    public CSimpleCounters
{
    protected :

        MPEG2_TIME_STATS *  m_pMpeg2TimeStats ;
        BYTE *              m_pbReset ;
        DWORD               m_dwReset ;

    public :

        CMpeg2TimeStats (
            IN  HINSTANCE               hInstance,
            IN  HWND                    hwndFrame,
            OUT DWORD *                 pdw
            ) ;

        virtual void Refresh () ;
        virtual void Reset () ;
} ;

//  ============================================================================

class CMpeg2GlobalStats :
    public CSimpleCounters
{
    protected :

        MPEG2_STATS_GLOBAL *        m_pMpeg2GlobalStats ;
        ULONGLONG                   m_ullLastTotalBytes ;
        DWORD                       m_dwMillisLast ;
        BYTE *                      m_pbReset ;
        DWORD                       m_dwReset ;

        virtual ULONGLONG GetTotalBytes_ () = 0 ;

    public :

        CMpeg2GlobalStats (
            IN  HINSTANCE               hInstance,
            IN  HWND                    hwndFrame,
            OUT DWORD *                 pdw
            ) ;

        virtual void Refresh () ;
        virtual void Reset () ;
} ;

//  ============================================================================

class CMpeg2TransportStatsCOM
{
    IMpeg2TransportStatsRaw *   m_pIMpeg2TransportStats ;
    BYTE *                      m_pbShared ;
    DWORD                       m_dwSize ;

    public :

        CMpeg2TransportStatsCOM (
            ) : m_pIMpeg2TransportStats (NULL),
                m_pbShared              (NULL) {}

        virtual
        ~CMpeg2TransportStatsCOM (
            )
        {
            RELEASE_AND_CLEAR (m_pIMpeg2TransportStats) ;
        }

        DWORD Init ()
        {
            DWORD   dw ;
            HRESULT hr ;

            hr = CoCreateInstance (
                    CLSID_Mpeg2Stats,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMpeg2TransportStatsRaw,
                    (void **) (& m_pIMpeg2TransportStats)
                    ) ;
            if (SUCCEEDED (hr)) {
                assert (m_pIMpeg2TransportStats) ;

                hr = m_pIMpeg2TransportStats -> GetSharedMemory (
                        & m_pbShared,
                        & m_dwSize
                        ) ;

                if (SUCCEEDED (hr)) {
                    dw = NOERROR ;
                }
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        } ;

        BYTE *  GetShared ()        { return m_pbShared ; }
        DWORD   GetSize ()          { return m_dwSize ; }

        DWORD
        Enable (
            BOOL * pf
            )
        {
            HRESULT hr ;

            if (m_pIMpeg2TransportStats) {
                hr = m_pIMpeg2TransportStats -> Enable (pf) ;
            }
            else {
                hr = E_FAIL ;
            }

            return (SUCCEEDED (hr) ? NOERROR : ERROR_GEN_FAILURE) ;
        }
} ;

//  ============================================================================

class CMpeg2ProgramStatsCOM
{
    IMpeg2ProgramStatsRaw * m_pIMpeg2ProgramStats ;
    BYTE *                  m_pbShared ;
    DWORD                   m_dwSize ;

    public :

        CMpeg2ProgramStatsCOM (
            ) : m_pIMpeg2ProgramStats   (NULL),
                m_pbShared              (NULL) {}

        virtual
        ~CMpeg2ProgramStatsCOM (
            )
        {
            RELEASE_AND_CLEAR (m_pIMpeg2ProgramStats) ;
        }

        DWORD Init ()
        {
            HRESULT hr ;
            DWORD   dw ;

            hr = CoCreateInstance (
                    CLSID_Mpeg2Stats,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMpeg2ProgramStatsRaw,
                    (void **) (& m_pIMpeg2ProgramStats)
                    ) ;
            if (SUCCEEDED (hr)) {
                assert (m_pIMpeg2ProgramStats) ;

                hr = m_pIMpeg2ProgramStats -> GetSharedMemory (
                        & m_pbShared,
                        & m_dwSize
                        ) ;

                if (SUCCEEDED (hr)) {
                    dw = NOERROR ;
                }
            }
            else {
                dw = ERROR_GEN_FAILURE ;
            }

            return dw ;
        }

        BYTE *  GetShared ()        { return m_pbShared ; }
        DWORD   GetSize ()          { return m_dwSize ; }

        DWORD
        Enable (
            BOOL * pf
            )
        {
            HRESULT hr ;

            if (m_pIMpeg2ProgramStats) {
                hr = m_pIMpeg2ProgramStats -> Enable (pf) ;
            }
            else {
                hr = E_FAIL ;
            }

            return (SUCCEEDED (hr) ? NOERROR : ERROR_GEN_FAILURE) ;
        }
} ;

//  ============================================================================

class CMpeg2TransportGlobalStats :
    public CMpeg2GlobalStats
{
    enum {
        TRANSPORT_PACKET_LEN    = 188
    } ;

    CMpeg2TransportStatsCOM m_Mpeg2TransportStatsCOM ;

    protected :

        virtual ULONGLONG GetTotalBytes_ () ;

    public :

        CMpeg2TransportGlobalStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        virtual DWORD   Enable (BOOL * pf)  { return m_Mpeg2TransportStatsCOM.Enable (pf) ; }

        static
        CMpeg2TransportGlobalStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

//  ============================================================================

class CMpeg2ProgramGlobalStats :
    public CMpeg2GlobalStats
{
    MPEG2_PROGRAM_STATS *   m_pMpeg2ProgramStats ;
    CMpeg2ProgramStatsCOM   m_Mpeg2ProgramStatsCOM ;

    protected :

        virtual ULONGLONG GetTotalBytes_ () ;

    public :

        CMpeg2ProgramGlobalStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        virtual DWORD   Enable (BOOL * pf)  { return m_Mpeg2ProgramStatsCOM.Enable (pf) ; }

        static
        CMpeg2ProgramGlobalStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

//  ============================================================================

class CMpeg2TransportTimeStats :
    public CMpeg2TimeStats
{
    CMpeg2TransportStatsCOM m_Mpeg2TransportStatsCOM ;

    public :

        CMpeg2TransportTimeStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        virtual DWORD   Enable (BOOL * pf)  { return m_Mpeg2TransportStatsCOM.Enable (pf) ; }

        static
        CMpeg2TransportTimeStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

//  ============================================================================

class CMpeg2ProgramTimeStats :
    public CMpeg2TimeStats
{
    CMpeg2ProgramStatsCOM   m_Mpeg2ProgramStatsCOM ;

    public :

        CMpeg2ProgramTimeStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        virtual DWORD   Enable (BOOL * pf)  { return m_Mpeg2ProgramStatsCOM.Enable (pf) ; }

        static
        CMpeg2ProgramTimeStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

//  ============================================================================

class CMpeg2TransportPIDStats :
    public CLVStatsWin
{
    enum {
        TS_PACKET_LEN   = 188
    } ;

    struct PER_STREAM_CONTEXT {
        DWORD       Stream ;
        ULONGLONG   LastCount ;
    } ;

    CMpeg2TransportStatsCOM     m_Mpeg2TransportStatsCOM ;
    MPEG2_TRANSPORT_STATS *     m_pMpeg2TransportStats ;
    DWORD                       m_dwMillisLast ;

    void
    PurgeTable_ (
        ) ;

    public :

        CMpeg2TransportPIDStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        virtual
        ~CMpeg2TransportPIDStats (
            ) ;

        virtual void Refresh () ;
        virtual void Reset () ;
        virtual DWORD   Enable (BOOL * pf)  { return m_Mpeg2TransportStatsCOM.Enable (pf) ; }

        static
        CMpeg2TransportPIDStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

//  ============================================================================

class CMpeg2ProgramStreamIdStats :
    public CLVStatsWin
{
    struct PER_STREAM_CONTEXT {
        DWORD       Stream ;
        ULONGLONG   LastCount ;
    } ;

    CMpeg2ProgramStatsCOM   m_Mpeg2ProgramStatsCOM ;
    MPEG2_PROGRAM_STATS *   m_pMpeg2ProgramStats ;
    DWORD                   m_dwMillisLast ;

    void
    PurgeTable_ (
        ) ;

    public :

        CMpeg2ProgramStreamIdStats (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            OUT DWORD *     pdw
            ) ;

        virtual
        ~CMpeg2ProgramStreamIdStats (
            ) ;

        virtual void Refresh () ;
        virtual void Reset () ;
        virtual DWORD   Enable (BOOL * pf)  { return m_Mpeg2ProgramStatsCOM.Enable (pf) ; }

        static
        CMpeg2ProgramStreamIdStats *
        CreateInstance (
            IN  HINSTANCE,
            IN  HWND
            ) ;
} ;

#endif  //  __mp2stats_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\precomp.h ===
#include <windows.h>
#include <stdlib.h>
#include <winsock2.h>
#include <commctrl.h>
#include <assert.h>
#include <stdio.h>
#include <limits.h>
#include <tchar.h>
#include <math.h>

#define GOTO_EQ(val,comp,label)     if ((val) == (comp)) goto label
#define GOTO_NE(val,comp,label)     if ((val) != (comp)) goto label
#define RELEASE_AND_CLEAR(punk)     if (punk) { (punk) -> Release () ; (punk) = NULL ; }
#define DELETE_RESET(p)             if (p) { delete (p) ; (p) = NULL ; }

template <class T> T Min (T a, T b)     { return (a <= b ? a : b) ; }
template <class T> T Max (T a, T b)     { return (a > b ? a : b) ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\stats.h ===
#ifndef __stats_h
#define __stats_h

/*++
    Statistical information.

    Only 1 pane can be shown at a single time.  Stats can be grouped per
    category.  Selecting a category, then narrows the scope.

    To create a new category, create an array of STATS_LIST objects.  To
    modify a category's list, update its STATS_LIST.  Once the category's
    STATS_LIST has been created, add the category to the STATS_LIST_INFO
    array, g_pAllStats.
--*/

struct STATS_LIST {
    TCHAR *             szMenuName ;
    CStatsWin *         pStatsWin ;
    PFN_CREATE_STATSWIN pfnCreate ;
} ;

//  ---------------------------
//  DVR stats

static
STATS_LIST
g_DVRStats [] = {
    {
        __T("&In"),
        NULL,
        (PFN_CREATE_STATSWIN) CDVRReceiverSideStats::CreateInstance
    },
    {
        __T("Out (&samples)"),
        NULL,
        (PFN_CREATE_STATSWIN) CDVRSenderSideSampleStats::CreateInstance
    },
    {
        __T("Out (&time)"),
        NULL,
        (PFN_CREATE_STATSWIN) CDVRSenderSideTimeStats::CreateInstance
    },
} ;

//  ---------------------------
//  transport stats

static
STATS_LIST
g_Mpeg2TransportStats [] = {
    {
        __T("&Global"),
        NULL,
        (PFN_CREATE_STATSWIN) CMpeg2TransportGlobalStats::CreateInstance
    },
    {
        __T("&Time"),
        NULL,
        (PFN_CREATE_STATSWIN) CMpeg2TransportTimeStats::CreateInstance
    },
    {
        __T("&PID"),
        NULL,
        (PFN_CREATE_STATSWIN) CMpeg2TransportPIDStats::CreateInstance
    },
} ;

//  ---------------------------
//  program stats

static
STATS_LIST
g_Mpeg2ProgramStats [] = {
    {
        __T("&Global"),
        NULL,
        (PFN_CREATE_STATSWIN) CMpeg2ProgramGlobalStats::CreateInstance
    },
    {
        __T("&Time"),
        NULL,
        (PFN_CREATE_STATSWIN) CMpeg2ProgramTimeStats::CreateInstance
    },
    {
        __T("&stream_id"),
        NULL,
        (PFN_CREATE_STATSWIN) CMpeg2ProgramStreamIdStats::CreateInstance
    },
} ;

//  ---------------------------
//  analysis stats

static
STATS_LIST
g_DVRAnalysisStats [] = {
    {
        __T("&Mpeg-2 video"),
        NULL,
        (PFN_CREATE_STATSWIN) CMpeg2VideoStreamStats::CreateInstance
    },
} ;


//  ---------------------------

struct STATS_LIST_INFO {
    STATS_LIST *    pStats ;
    TCHAR *         szTitle ;
    int             iLastVisible ;
    int             iCount ;
} ;

/*
static enum STATS_CATEGORY {
    TRANSPORT_STREAM,
    PROGRAM_STREAM,
    DVR_ANALYSIS,

    //  always last
    STATS_CATEGORY_COUNT
} ;
//  ---------------------------
//  maintain 1-1 correspondence
//  ---------------------------
*/
STATS_LIST_INFO
g_pAllStats [] = {
    {
        g_Mpeg2TransportStats,
        __T("Mpeg-2 Transport Stream Statistics"),
        0,
        //TS_STATS_COUNT
        sizeof g_Mpeg2TransportStats / sizeof STATS_LIST
    },
    {
        g_Mpeg2ProgramStats,
        __T("Mpeg-2 Program Stream Statistics"),
        0,
        sizeof g_Mpeg2ProgramStats / sizeof STATS_LIST
    },
    {
        g_DVRAnalysisStats,
        __T("DVR Analysis"),
        0,
        sizeof g_DVRAnalysisStats / sizeof STATS_LIST
    },
    {
        g_DVRStats,
        __T("Timeshift/DVR"),
        0,
        sizeof g_DVRStats / sizeof STATS_LIST
    },
} ;

int g_AllStatsCount = sizeof g_pAllStats / sizeof STATS_LIST_INFO ;

#endif  //  __stats_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dmstat.rc
//
#define IDI_DMSTAT                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\ui.h ===
/*
typedef struct {
    TCHAR * title ;
    DWORD   width ;
} COL_DETAIL ;

#define LV_COL(title, width)  { title, width }

#define LABEL_COL                   0
#define COUNTER_VALUE_COL           1

typedef struct {
    TCHAR * szLabel ;
    int     iRow ;          //  set when we insert into the listview
} STATS_TABLE_DETAIL ;
*/

//  ============================================================================
//  time stats rows
/*
    REFERENCE_TIME  rtPES_PTSToGraphClockDelta ;        //  difference between the graph clock and the PES PTS (scaled)
    LONGLONG        llBasePCR ;                         //  base PCR -- timeline origin; stats value not scaled
    LONGLONG        llLastPCR ;                         //  last PCR (used)
    ULONGLONG       cPCR ;                              //  PCR count
    REFERENCE_TIME  rtAudioStreamPTSBase ;              //  baseline time for audio
    REFERENCE_TIME  rtAudioPESPTS ;                     //  last audio PES PTS
    ULONGLONG       cAudioPESPTS ;                      //  audio PES PTS count
    ULONGLONG       cAudioInvalidPESPTS ;               //  invalid PTS wrt to the PCR stream
    REFERENCE_TIME  rtVideoStreamPTSBase ;              //  baseline time for video
    REFERENCE_TIME  rtVideoPESPTS ;                     //  last video PES PTS
    ULONGLONG       cVideoPESPTS ;                      //  video PES PTS count
    ULONGLONG       cVideoInvalidPESPTS ;               //  invalid PTS wrt to the PCR stream
    ULONGLONG       cPTS_PCROutOfBoundsDelta ;          //  count of PTS-PCR delta too big
*/

/*
static enum {
    TIME_STATS_DEMUX_IS_REF,
    TIME_STATS_SLOPE_OBSERVED,
    TIME_STATS_SLOPE_USED,
    TIME_STATS_CARRY,
    TIME_STATS_ADJUSTMENTS_UP,
    TIME_STATS_ADJUSTMENTS_DOWN,
    TIME_STATS_DEGRADATIONS,
    TIME_STATS_PTS_REF_DELTA,
    TIME_STATS_TIME_DISCONTINUITIES,
    TIME_STATS_BASE_PCR,
    TIME_STATS_LAST_PCR,
    TIME_STATS_BASE_PCR_DSHOW,
    TIME_STATS_LAST_PCR_DSHOW,
    TIME_STATS_VIDEO_PTS_BASE,
    TIME_STATS_LAST_VIDEO_PTS,
    TIME_STATS_VIDEO_PTS_COUNT,
    TIME_STATS_INVALID_VIDEO_PTS_COUNT,
    TIME_STATS_AUDIO_PTS_BASE,
    TIME_STATS_LAST_AUDIO_PTS,
    TIME_STATS_AUDIO_PTS_COUNT,
    TIME_STATS_INVALID_AUDIO_PTS_COUNT,
    TIME_STATS_OUT_OF_BOUNDS_PTS,
    TIME_STATS_AV_DIFF_MILLIS,                  //  millis between a/v timestamps
    TIME_STATS_ROW_COUNT
} ;

static STATS_TABLE_DETAIL
g_TimerStats [] = {
    { __T("Demux == IReferenceClock"),  0 },
    { __T("Observed"),                  0 },
    { __T("Used"),                      0 },
    { __T("Carry"),                     0 },
    { __T("Adjustments (+)"),           0 },
    { __T("Adjustments (-)"),           0 },
    { __T("Degradations"),              0 },
    { __T("PTS - IRef Delta"),          0 },
    { __T("Time Discontinuities"),      0 },
    { __T("Base PCR"),                  0 },
    { __T("Last PCR"),                  0 },
    { __T("Base PCR (dshow)"),          0 },
    { __T("Last PCR (dshow)"),          0 },
    { __T("Video PTS Base (dshow)"),    0 },
    { __T("Last video PTS (dshow)"),    0 },
    { __T("video PTS count"),           0 },
    { __T("invalid video PTS count"),   0 },
    { __T("Audio PTS Base (dshow)"),    0 },
    { __T("Last audio PTS (dshow)"),    0 },
    { __T("audio PTS count"),           0 },
    { __T("invalid audio PTS count"),   0 },
    { __T("out-of-bounds PTSs"),        0 },
    { __T("A/V Difference (millis)"),   0 },
} ;
*/
//  ============================================================================
//  program stats rows
/*
    ULONGLONG                       cPackHeaders ;          //  pack headers seen
    ULONGLONG                       cSystemHeaders ;        //  system headers seen
    ULONGLONG                       cProgramStreamMaps ;    //  PS PMTs seen
    ULONGLONG                       cDirectoryPESPackets ;  //  PS Directories seen
    ULONGLONG                       cBytesProcessed ;       //  total bytes processed
*/
/*
static enum {
    PROGRAM_STATS_PACK_HEADERS,
    PROGRAM_STATS_SYSTEM_HEADERS,
    PROGRAM_STATS_PROGRAM_STREAM_MAPS,
    PROGRAM_STATS_DIRECTORY_PES_PACKETS,
    PROGRAM_STATS_BYTES_PROCESSED,
    PROGRAM_STATS_ROW_COUNT
} ;

static STATS_TABLE_DETAIL
g_ProgramStats [] = {
    { __T("Pack Headers"),          0 },
    { __T("System Headers"),        0 },
    { __T("PS PMTs"),               0 },
    { __T("Directory PES"),         0 },
    { __T("Bytes Demultiplexed"),   0 },
} ;
*/
//  ============================================================================
//  transport stats rows

/*
    ULONGLONG                   cPSIPackets ;               //  mapped packets that carry PSI
*/
/*
static enum {
    TRANSPORT_STATS_PSI_PACKETS,
    TRANSPORT_STATS_SYNC_BYTE_SEEKS,
    TRANSPORT_STATS_SPANNED_PACKETS,
    TRANSPORT_STATS_ROW_COUNT
} ;

static STATS_TABLE_DETAIL
g_TransportStats [] = {
    { __T("PSI Packets"),       0 },
    { __T("sync_byte seeks"),   0 },
    { __T("spanned packets"),   0 },
} ;
*/
//  ============================================================================
//  per PID stats
/*
static enum {
    PER_PID_STATS_PID,
    PER_PID_STATS_PACKETS,
    PER_PID_STATS_MPEG2_ERRORS,
    PER_PID_STATS_NEW_PAYLOADS,
    PER_PID_STATS_DISCONTINUITIES,
    PER_PID_STATS_MAPPED_PACKETS,
    PER_PID_STATS_DROPPED_PACKETS,
    PER_PID_STATS_BITRATE,
    PER_PID_STATS_COUNTERS            //  always last
} ;

static COL_DETAIL
g_PerPIDColumns [] = {
    { __T("PID"),             60 },
    { __T("Packets"),         80 },
    { __T("MPEG-2 Errors"),   100 },
    { __T("Payloads"),        80 },
    { __T("Discontinuities"), 100 },
    { __T("Mapped"),          80 },
    { __T("Dropped"),         80 },
    { __T("Mbps"),            60 },
} ;
*/
//  ============================================================================
//  per stream_id stats
/*
static enum {
    PER_STREAM_STATS_STREAM_ID,
    PER_STREAM_STATS_PACKETS,
    PER_STREAM_STATS_MAPPED_PACKETS,
    PER_STREAM_STATS_DROPPED_PACKETS,
    PER_STREAM_STATS_BYTES_PROCESSED,
    PER_STREAM_STATS_BITRATE,
    PER_STREAM_STATS_COUNTERS
} ;

static COL_DETAIL
g_PerStreamColumns [] = {
    { __T("stream_id"),       70 },
    { __T("Packets"),         80 },
    { __T("Mapped"),          80 },
    { __T("Dropped"),         80 },
    { __T("Bytes"),           80 },
    { __T("Mbps"),            50 },
} ;
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\statswin.h ===
#ifndef __statswin_h
#define __statswin_h

class CStatsWin ;
class CLVStatsWin ;
class CSimpleCounters ;
class CMpeg2VideoStreamStats ;

class CMpeg2GlobalStats ;
class CMpeg2ProgramGlobalStats ;
class CMpeg2TransportGlobalStats ;

typedef struct {
    TCHAR * title ;
    DWORD   width ;
} COL_DETAIL ;

typedef struct {
    TCHAR * szLabel ;
    int     iRow ;          //  set when we insert into the listview
} STATS_TABLE_DETAIL ;

typedef CStatsWin * (* PFN_CREATE_STATSWIN) (IN HINSTANCE, IN HWND) ;

//  ============================================================================

class CStatsWin
{
    DWORD_PTR   m_dwpContext ;
    HWND        m_hwndFrame ;
    HINSTANCE   m_hInstance ;

    protected :

        void        SetContext_ (IN DWORD_PTR  dwpContext)  { m_dwpContext = dwpContext ; }
        DWORD_PTR   GetContext_ ()                          { return m_dwpContext ; }

        HWND            GetFrame_ ()    { return m_hwndFrame ; }
        HINSTANCE       GetInstance_ () { return m_hInstance ; }
        virtual HWND    GetControl_ ()  = 0 ;


    public :

        CStatsWin (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame
            ) ;

        virtual
        ~CStatsWin (
            ) ;

        virtual DWORD   Init ()             { return S_OK ; }
        virtual void    Reset ()            {}
        virtual void    SetVisible (BOOL f) { ShowWindow (GetControl_ (), (f ? SW_SHOW : SW_HIDE)) ; }

        virtual DWORD   Enable (BOOL * pf)  = 0 ;
        virtual void    Refresh () = 0 ;
        virtual void    Resize (LONG left, LONG top, LONG right, LONG bottom) = 0 ;
} ;

//  ============================================================================

class CLVStatsWin :
    public CStatsWin
{
    int         m_iColCount ;
    CListview * m_pLV ;

    int
    AppendTableColumn_ (
        IN  TCHAR * szColName,
        IN  int     iColWidth
        ) ;

    int
    AppendTableRow_ (
        ) ;

    protected :

        CListview * GetLV_ ()           { return m_pLV ; }
        virtual HWND GetControl_ () ;

        int GetRowCount_ ()             { return m_pLV -> GetItemCount () ; }

        DWORD
        CellDisplayText_ (
            IN  int     iRow,
            IN  int     iCol,
            IN  TCHAR * sz
            ) ;

        DWORD
        CellDisplayValue_ (
            IN  int         iRow,
            IN  int         iCol,
            IN  ULONGLONG   ullVal
            ) ;

        DWORD
        CellDisplayValue_ (
            IN  int iRow,
            IN  int iCol,
            IN  int iVal
            ) ;

        DWORD
        CellDisplayValue_ (
            IN  int         iRow,
            IN  int         iCol,
            IN  LONGLONG    llVal
            ) ;

        DWORD
        InsertRow_ (
            IN  int     iRow
            ) ;

        DWORD
        DeleteRow_ (
            IN  int iRow
            ) ;

        DWORD
        SetRowsetValue_ (
            IN  int         iRow,
            IN  DWORD_PTR   dwp
            ) ;

        DWORD_PTR
        GetRowsetValue_ (
            IN  int iRow
            ) ;

        void
        SetColWidth_ (
            IN  int iCol,
            IN  int iWidth
            ) ;

        void
        CollapseCol_ (
            IN  int iCol
            )
        {
            SetColWidth_ (iCol, 0) ;
        }

    public :

        CLVStatsWin (
            IN  HINSTANCE       hInstance,
            IN  HWND            hwndFrame,
            IN  int             iColCount,
            IN  COL_DETAIL *    pColDetail,
            IN  int             iRowCount,
            OUT DWORD *         pdw
            ) ;

        virtual
        ~CLVStatsWin (
            ) ;

        virtual void Resize (LONG left, LONG top, LONG right, LONG bottom) ;
} ;

//  ============================================================================

class CSimpleCounters :
    public CLVStatsWin
{
    enum {
        SIMPLE_COUNTER_LABEL_COL    = 0,
        SIMPLE_COUNTER_VALUE_COL    = 1
    } ;

    protected :

        DWORD
        SetVal_ (
            IN  int         iRow,
            IN  LONGLONG    llVal
            ) ;

        DWORD
        SetVal_ (
            IN  int     iRow,
            IN  TCHAR * sz
            ) ;

    public :

        CSimpleCounters (
            IN  HINSTANCE   hInstance,
            IN  HWND        hwndFrame,
            IN  int         cLabels,
            IN  TCHAR **    ppszLabels,
            OUT DWORD *     pdw
            ) ;
} ;

#endif  //  __statswin_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\shared.h ===
#define DISTINCT_PID_COUNT          (1 << 13)
#define DISTINCT_STREAM_ID_COUNT    (1 << 8)

#define REG_MPEG2_DEMUX                     __T ("SOFTWARE\\Microsoft\\MPEG2Demultiplexer")
#define REG_TRANSPORT_SUBKEY                __T ("Transport")
#define REG_PROGRAM_SUBKEY                  __T ("Program")
#define REG_MPEG2_TRANSPORT_DEMUX           REG_MPEG2_DEMUX __T("\\") REG_TRANSPORT_SUBKEY
#define REG_MPEG2_PROGRAM_DEMUX             REG_MPEG2_DEMUX __T("\\") REG_PROGRAM_SUBKEY
#define REG_STATS_LEVEL                     __T ("Stats")

//  supported stats levels
#define REG_STATS_LEVEL_OFF                 0
#define REG_STATS_LEVEL_ON                  1

//  this should match what's in MPEG2_STATS_GLOBAL.ullVersion; if they don't match,
//  statistical information will be erroneous
#define MPEG2_STATS_VERSION_MAJOR           1
#define MPEG2_STATS_VERSION_MINOR           1

#define MPEG2_STATS_VERSION(major,minor)    ((((ULONGLONG) (major)) << 32) | (minor))
#define MPEG2_STATS_GET_MAJOR_VERSION(ull)  ((DWORD) ((ull) >> 32))
#define MPEG2_STATS_GET_MINOR_VERSION(ull)  ((DWORD) (ull))

/*++
    registry value that controls stats:

    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MPEG2Demultiplexer\Transport\Stats

    0       no stats
    != 0    stats

--*/

//  stats version; used by an application to ensure a good matchup
#define MPEG2_STATS_SIGNATURE               0xCA5EBABE

//  names of the file mapping object
#define MPEG2_TRANSPORT_STATS_NAME          TEXT ("MPEG2_TRANSPORT_DEMULTIPLEXER_STATS")
#define MPEG2_PROGRAM_STATS_NAME            TEXT ("MPEG2_PROGRAM_DEMULTIPLEXER_STATS")

//  ----------------------------------------------------------------------------
//  global

/*++
    fDemuxIsIRefClock
        TRUE if the demux is the graph clock

    dPerPCRObservedSlope
        each time we process a PCR we compute the PCR/QPC slope; this is that
        value

    dIRefClockUsedSlope
        this value should slowly converge on the above

    llUpwardAdjustments
        number of upward adjustments made as dIRefClockUsedSlope converges on
        dPerPCRObservedSlope; triggered when dIRefClockUsedSlope is >
        dPerPCRObservedSlope + allowable error

    llDownwardAdjustments
        number of downward adjustments made as dIRefClockUsedSlope converges
        on dPerPCRObservedSlope; triggered when dIRefClockUsedSlope is <
        dPerPCRObservedSlope - allowable error

    llAllowableErrorDegradations
        number of times no correction was made and the allowable error was
        degraded
--*/
struct MPEG2_CLOCK_SLAVE_STATS {
    BOOL        fDemuxIsIRefClock ;             //  TRUE: demux is the graph clock
    double      dPerPCRObservedSlope ;          //  per PCR measured PCR/QPC slope
    double      dIRefClockUsedSlope ;           //  PCR/QPC slope that is being used to generate the clock
    double      dCarry ;                        //  ::GetTime () carry value
    LONGLONG    llUpwardAdjustments ;           //  upward adjustments
    LONGLONG    llDownwardAdjustments ;         //  downward adjustments
    LONGLONG    llAllowableErrorDegradations ;  //  no correction results in a degradation
} ;

/*++

    rtPES_PTSToGraphClockDelta
        difference between the PTSs recovered from the PES headers and the current
        graph clock; this value is expect to remain relatively constant and not
        gradually converge or diverge; the values are scaled appropriately
--*/
struct MPEG2_TIMESTAMP_STATS {
    //REFERENCE_TIME  rtPES_PTSToGraphClockDelta ;        //  difference between the graph clock and the PES PTS (scaled)
    LONGLONG        rtPES_PTSToGraphClockDelta ;        //  difference between the graph clock and the PES PTS (scaled)
    LONGLONG        llBasePCR ;                         //  base PCR -- timeline origin; stats value not scaled
    LONGLONG        llLastPCR ;                         //  last PCR (used)
    ULONGLONG       cPCR ;                              //  PCR count
    //REFERENCE_TIME  rtAudioStreamPTSBase ;              //  baseline time for audio
    LONGLONG        rtAudioStreamPTSBase ;              //  baseline time for audio
    //REFERENCE_TIME  rtAudioPESPTS ;                     //  last audio PES PTS
    LONGLONG        rtAudioPESPTS ;                     //  last audio PES PTS
    ULONGLONG       cAudioPESPTS ;                      //  audio PES PTS count
    ULONGLONG       cAudioInvalidPESPTS ;               //  invalid PTS wrt to the PCR stream
    //REFERENCE_TIME  rtVideoStreamPTSBase ;              //  baseline time for video
    LONGLONG        rtVideoStreamPTSBase ;              //  baseline time for video
    //REFERENCE_TIME  rtVideoPESPTS ;                     //  last video PES PTS
    LONGLONG        rtVideoPESPTS ;                     //  last video PES PTS
    ULONGLONG       cVideoPESPTS ;                      //  video PES PTS count
    ULONGLONG       cVideoInvalidPESPTS ;               //  invalid PTS wrt to the PCR stream
    ULONGLONG       cPTS_PCROutOfBoundsDelta ;          //  count of PTS-PCR delta too big
} ;

/*++

--*/
struct MPEG2_TRANSPORT_PSI_STATS {
    ULONGLONG   cNewPATSectionsProcessed ;
    ULONGLONG   cNewPMTSectionsProcessed ;
    ULONGLONG   cPrograms ;
} ;

/*++
    cTimeDiscontinuities
        incremented whenever a time stamp or PCR value, carried in a mapped PID,
        exceeds the previously received value by more than is allowable in the
        h.222.0 specification; this counter is incremented by the objects that
        ensure timestamp streams increase monotonically
--*/
struct MPEG2_TIME_STATS {
    ULONGLONG               cTimeDiscontinuities ;          //  # of out-of-tolerance clock values
    MPEG2_CLOCK_SLAVE_STATS ClockSlave ;
    MPEG2_TIMESTAMP_STATS   TimeStamp ;
} ;

/*++
    how each counter should be tallied:

    cGlobalPackets
        incremented for all packets, regardless of PID, existence of mapping, errors, etc...
        call this category [1]

    cGlobalMPEG2Errors
        incremented for all category [1] packets that have the transport_error_indicator bit set

    cGlobalNewPayloads
        incremented for all category [1] packets that have the payload_unit_start_indicator bit set

    cGlobalDiscontinuities
        incremented for all category [1] packets that have discontinuities

    cGlobalMappedPackets
        incremented for all packets that are mapped; should be <= cGlobalPackets; call
        this category [2]

    cGlobalDroppedPackets
        incremented whenever a category [2] packet is dropped for whatever reason - errors,
        waiting for a payload_unit_start_indicator bit, etc...; NOTE: this number is not incremented
        when a media sample containing a partially reassembled payload, is aborted

    cGlobalPSIPackets
        incremented whenever a category [2] packet is processed (not dropped) that is mapped
        to be carrying PSI

    cGlobalPESPackets
        incremented whenever a category [2] packet is processed (not dropped) that is mapped
        to be carrying PES

    cGlobalAbortedMediaSamples
        incremented whenever a media sample with >= 1 collected packets is aborted due to
        a content error

    cGlobalAbortedBytes
        incremented by the number of bytes carried in each aborted media sample; this counter
        was added so the number of transport packets dropped by this type of error could be
        estimated; such packets are not counted in the cGlobalDroppedPackets

    cGlobalInputMediaSamples
        incremented whenever a media sample is received by the input pin

    cGlobalOutputMediaSamples
        incremented whenever a media sample is queued for transmission downstream
--*/
struct MPEG2_STATS_GLOBAL
{
    ULONGLONG           ullVersion ;                            //  ull for alignment
                                                                //  high DWORD: major
                                                                //  low DWORD: minor
    //  ------------------------------------------------------------------------
    ULONGLONG           cGlobalPackets ;                        //  packets processed
    ULONGLONG           cGlobalPESPackets ;                     //  mapped packets that carry PES
    ULONGLONG           cGlobalMPEG2Errors ;                    //  packet errors
    ULONGLONG           cGlobalNewPayloads ;                    //  payloads
    ULONGLONG           cGlobalDiscontinuities ;                //  packet discontinuities
    ULONGLONG           cGlobalSyncPoints ;                     //  sync points
    ULONGLONG           cGlobalMappedPackets ;                  //  mapped packets processed
    ULONGLONG           cGlobalDroppedPackets ;                 //  mapped packets dropped
    ULONGLONG           cGlobalAbortedMediaSamples ;            //  media samples aborted due to errors
    ULONGLONG           cGlobalAbortedBytes ;                   //  bytes of aborted media sample payloads
    ULONGLONG           cGlobalInputMediaSamples ;              //  media samples received
    ULONGLONG           cGlobalOutputMediaSamples ;             //  media samples queued for transmission
    MPEG2_TIME_STATS    TimeStats ;                             //  all clock and timestamp stats
} ;

//  ----------------------------------------------------------------------------
//  transport specific

/*++
    how each per-PID counter should be tallied:

    cPIDPackets
        incremented whenever a packet of the specified PID is received; call this category [3]

    cPIDMPEG2Errors
        incremented for each category [3] packet with the transport_error_indicator bit set

    cPIDNewPayloads
        incremented for each category [3] packet that has the payload_unit_start_indicator bit set

    cPIDDiscontinuities
        incremented for each category [3] packet that has a discontinuity

    cPIDMappedPackets
        incremented for each packet of the specified PID, for which a mapping exists; call
        this category [4]; increment for _each_ mapping of the PID

    cPIDDroppedPackets
        incremented whenever a category [4] packet is dropped for whatever reason - errors,
        waiting for a payload_unit_start_indicator bit, etc...; increment for _each_ mapping
        of the PID, so if a PID is mapped to 2 pins, this will increment by 2
--*/
struct MPEG2_TRANSPORT_PID_STATS
{
    ULONGLONG   cPIDPackets ;                           //  transport packets seen
    ULONGLONG   cPIDMPEG2Errors ;                       //  transport_error_indicator errors seen
    ULONGLONG   cPIDNewPayloads ;                       //  payload_unit_start_indicator bit set
    ULONGLONG   cPIDDiscontinuities ;                   //  per PID discontinuities
    ULONGLONG   cPIDMappedPackets ;                     //  mapped transport packets processed
    ULONGLONG   cPIDDroppedPackets ;                    //  mapped packets dropped due to errors
} ;

struct MPEG2_TRANSPORT_STATS
{
    MPEG2_STATS_GLOBAL          GlobalStats ;
    ULONGLONG                   cPSIPackets ;               //  mapped packets that carry PSI
    ULONGLONG                   cSyncByteSeeks ;            //  sync_byte seeks - means packets are not packed
    ULONGLONG                   cSpannedPacket ;            //  number of packets we've found that span
    MPEG2_TRANSPORT_PSI_STATS   PSIStats ;
    MPEG2_TRANSPORT_PID_STATS   PID [DISTINCT_PID_COUNT] ;
} ;

//  ----------------------------------------------------------------------------
//  program specific

struct MPEG2_PER_STREAM_PROGRAM_STATS
{
    ULONGLONG   cStreamIdPackets ;
    ULONGLONG   cStreamIdMapped ;
    ULONGLONG   cStreamIdDropped ;
    ULONGLONG   cBytesProcessed ;
} ;

struct MPEG2_PROGRAM_STATS
{
    MPEG2_STATS_GLOBAL              GlobalStats ;
    ULONGLONG                       cPackHeaders ;          //  pack headers seen
    ULONGLONG                       cSystemHeaders ;        //  system headers seen
    ULONGLONG                       cProgramStreamMaps ;    //  PS PMTs seen
    ULONGLONG                       cDirectoryPESPackets ;  //  PS Directories seen
    ULONGLONG                       cBytesProcessed ;       //  total bytes processed
    MPEG2_PER_STREAM_PROGRAM_STATS  StreamId [DISTINCT_STREAM_ID_COUNT] ;
} ;

//      statistics apps need this information                               END
//  ---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\tools\statsapp\statswin.cpp ===
#include "precomp.h"
#include "ui.h"
#include "controls.h"
#include "mp2demux.h"
#include "dvrds.h"
#include "shared.h"
#include "statswin.h"

static
CListview *
GetChildListview (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwnd
    )
{
    HWND    hwndLV ;

    hwndLV = CreateWindow (
                WC_LISTVIEW,
                __T(""),
                WS_CHILD | LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_NOSORTHEADER,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                hwnd,
                NULL,
                hInstance,
                NULL
                ) ;

    if (hwndLV) {
        return new CListview (hwndLV) ;
    }
    else {
        return NULL ;
    }
}

//  ============================================================================

CStatsWin::CStatsWin (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame
    ) : m_hwndFrame (hwndFrame),
        m_hInstance (hInstance)
{
}

CStatsWin::~CStatsWin (
    )
{
}

//  ============================================================================

CLVStatsWin::CLVStatsWin (
    IN  HINSTANCE       hInstance,
    IN  HWND            hwndFrame,
    IN  int             iColCount,
    IN  COL_DETAIL *    pColDetail,
    IN  int             iRowCount,
    OUT DWORD *         pdw
    ) : CStatsWin   (hInstance,
                     hwndFrame
                     ),
        m_iColCount (0),
        m_pLV       (NULL)
{
    int     i ;
    int     iRow ;
    int     iCol ;

    (* pdw) = NOERROR ;

    //  create the listview
    m_pLV = GetChildListview (
                GetInstance_ (),
                GetFrame_ ()
                ) ;
    if (!m_pLV) {
        (* pdw) = GetLastError () ;
        goto cleanup ;
    }

    //  populate with columns
    for (i = 0 ;
         i < iColCount;
         i++) {

        iCol = AppendTableColumn_ (
                    pColDetail [i].title,
                    pColDetail [i].width
                    ) ;
        if (iCol != i) {
            (* pdw) = GetLastError () ;
            goto cleanup ;
        }
    }

    //  set rows
    for (i = 0;
         i < iRowCount;
         i++) {

        iRow = AppendTableRow_ () ;
        if (iRow != i) {
            (* pdw) = GetLastError () ;
            goto cleanup ;
        }
    }

    cleanup :

    return ;
}

CLVStatsWin::~CLVStatsWin (
    )
{
}

HWND
CLVStatsWin::GetControl_ (
    )
{
    assert (m_pLV) ;
    return m_pLV -> GetHwnd () ;
}

int
CLVStatsWin::AppendTableColumn_ (
    IN  TCHAR * szColName,
    IN  int     iColWidth
    )
{
    int     i ;

    assert (m_pLV) ;
    i = m_pLV -> InsertColumn (szColName, iColWidth, m_iColCount) ;
    if (i != -1) {
        m_iColCount++ ;
    }

    return i ;
}

void
CLVStatsWin::Resize (
    LONG left,
    LONG top,
    LONG right,
    LONG bottom
    )
{
    MoveWindow (
        m_pLV -> GetHwnd (),
        left, top,
        right - left,
        bottom - top,
        TRUE
        ) ;
}

DWORD
CLVStatsWin::CellDisplayText_ (
    IN int      iRow,
    IN int      iCol,
    IN TCHAR *  sz
    )
{
    DWORD   dw ;
    int     i ;

    assert (m_pLV) ;
    i = m_pLV -> SetText (sz, iRow, iCol) ;
    if (i != -1) {
        dw = NOERROR ;
    }
    else {
        dw = GetLastError () ;
    }

    return dw ;
}

DWORD
CLVStatsWin::CellDisplayValue_ (
    IN  int         iRow,
    IN  int         iCol,
    IN  ULONGLONG   ullVal
    )
{
    static TCHAR ach [64] ;

    _stprintf (ach, __T("%I64u"), ullVal) ;
    return CellDisplayText_ (iRow, iCol, ach) ;
}

DWORD
CLVStatsWin::CellDisplayValue_ (
    IN  int iRow,
    IN  int iCol,
    IN  int iVal
    )
{
    static TCHAR ach [64] ;

    _stprintf (ach, __T("%d"), iVal) ;
    return CellDisplayText_ (iRow, iCol, ach) ;
}

DWORD
CLVStatsWin::CellDisplayValue_ (
    IN  int         iRow,
    IN  int         iCol,
    IN  LONGLONG    llVal
    )
{
    static TCHAR ach [64] ;

    _stprintf (ach, __T("%I64d"), llVal) ;
    return CellDisplayText_ (iRow, iCol, ach) ;
}

DWORD
CLVStatsWin::SetRowsetValue_ (
    IN  int         iRow,
    IN  DWORD_PTR   dwp
    )
{
    BOOL    f ;
    DWORD   dw ;

    assert (m_pLV) ;
    f = m_pLV -> SetData (dwp, iRow) ;
    if (f) {
        dw = NOERROR ;
    }
    else {
        dw = GetLastError () ;
    }

    return dw ;
}

DWORD_PTR
CLVStatsWin::GetRowsetValue_ (
    IN  int iRow
    )
{
    return m_pLV -> GetData (iRow) ;
}

int
CLVStatsWin::AppendTableRow_ (
    )
{
    assert (m_pLV) ;
    return m_pLV -> AppendRowValue (0) ;
}

DWORD
CLVStatsWin::InsertRow_ (
    IN  int     iRow
    )
{
    int i ;

    i = m_pLV -> InsertRowValue (iRow, 0) ;
    return (i == iRow ? NOERROR : ERROR_GEN_FAILURE) ;
}

DWORD
CLVStatsWin::DeleteRow_ (
    IN  int iRow
    )
{
    m_pLV -> DeleteRow (iRow) ;
    return NOERROR ;
}

void
CLVStatsWin::SetColWidth_ (
    IN  int iCol,
    IN  int iWidth
    )
{
    m_pLV -> SetColWidth (iCol, iWidth) ;
}

//  ============================================================================

static enum {
    SIMPLE_COUNTER_STAT_NAME,
    SIMPLE_COUNTER_STAT_VALUE,

    //  always last
    SIMPLE_COUNTER_STAT_COUNTERS
} ;

static COL_DETAIL
g_SimpleCounterColumns [] = {
    { __T("Counter"),   150 },
    { __T("Value"),     100 },
} ;

CSimpleCounters::CSimpleCounters (
    IN  HINSTANCE   hInstance,
    IN  HWND        hwndFrame,
    IN  int         cLabels,
    IN  TCHAR **    ppszLabels,
    OUT DWORD *     pdw
    ) : CLVStatsWin (hInstance,
                     hwndFrame,
                     SIMPLE_COUNTER_STAT_COUNTERS,
                     g_SimpleCounterColumns,
                     cLabels,
                     pdw
                     )
{
    int iRow ;
    int i ;

    if ((* pdw) == NOERROR) {
        for (i = 0;
             i < cLabels;
             i++) {

            (* pdw) = SetRowsetValue_ (i, i) ;
            if ((* pdw) != NOERROR) {
                break ;
            }

            (* pdw) = CellDisplayText_ (
                            i,
                            SIMPLE_COUNTER_LABEL_COL,
                            ppszLabels [i]
                            ) ;
            if ((* pdw) != NOERROR) {
                break ;
            }
        }
    }
}

DWORD
CSimpleCounters::SetVal_ (
    IN  int     iRow,
    IN  TCHAR * sz
    )
{
    return CellDisplayText_ (
                iRow,
                SIMPLE_COUNTER_VALUE_COL,
                sz
                ) ;
}

DWORD
CSimpleCounters::SetVal_ (
    IN  int         iRow,
    IN  LONGLONG    llVal
    )
{
    static TCHAR achbuffer [64] ;

    _stprintf (achbuffer, __T("%I64d"), llVal) ;
    return SetVal_ (iRow, achbuffer) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\util\dvrutil.cpp ===
/*++

    Copyright (c) 2001 Microsoft Corporation

    Module Name:

        dvrutil.cpp

    Abstract:

        This module the ts/dvr-wide utility code; compiles into a .LIB

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        01-Feb-2001     created

--*/

#include "dvrall.h"
#include "dvranalysis.h"
#include "dvrutil.h"

LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = L'\0';
	MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);

	return buffer;
}

LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = '\0';
	WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len, NULL, FALSE);

	return buffer;
}

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR szValName,
    OUT DWORD * pdw
    )
//  value exists:           retrieves it
//  value does not exist:   sets it
{
    BOOL    r ;
    DWORD   dwCurrent ;

    r = GetRegDWORDVal (
            hkeyRoot,
            szValName,
            & dwCurrent
            ) ;
    if (r) {
        (* pdw) = dwCurrent ;
    }
    else {
        r = SetRegDWORDVal (
                hkeyRoot,
                szValName,
                (* pdw)
                ) ;
    }

    return r ;
}

BOOL
GetRegDWORDValIfExist (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdw
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dwCurrent ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdw) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegDWORDValIfExist (
                hkey,
                pszRegValName,
                pdw
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER, ..
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dwCurrent ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    (KEY_READ | KEY_WRITE),
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        //  retrieve current

        r = GetRegDWORDVal (
                hkey,
                pszRegValName,
                pdwRet
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
GetRegDWORDVal (
    IN  HKEY    hkeyRoot,           //  HKEY_CURRENT_USER
    IN  LPCTSTR pszRegValName,
    OUT DWORD * pdwRet
    )
{
    BOOL    r ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;

    ASSERT (pszRegValName) ;
    ASSERT (pdwRet) ;

    dwSize = sizeof (* pdwRet) ;
    dwType = REG_DWORD ;

    l = RegQueryValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            & dwType,
            (LPBYTE) pdwRet,
            & dwSize
            ) ;
    if (l == ERROR_SUCCESS) {
        r = TRUE ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    )
{
    HKEY    hkey ;
    DWORD   dwDisposition ;
    DWORD   dw ;
    DWORD   dwSize ;
    DWORD   dwType ;
    LONG    l ;
    BOOL    r ;

    ASSERT (pszRegRoot) ;
    ASSERT (pszRegValName) ;

    //  registry root is transport type
    l = RegCreateKeyEx (
                    hkeyRoot,
                    pszRegRoot,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    & hkey,
                    & dwDisposition
                    ) ;
    if (l == ERROR_SUCCESS) {

        r = SetRegDWORDVal (
                hkey,
                pszRegValName,
                dwVal
                ) ;

        RegCloseKey (hkey) ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

BOOL
SetRegDWORDVal (
    IN  HKEY    hkeyRoot,
    IN  LPCTSTR pszRegValName,
    IN  DWORD   dwVal
    )
{
    LONG    l ;

    l = RegSetValueEx (
            hkeyRoot,
            pszRegValName,
            NULL,
            REG_DWORD,
            (const BYTE *) & dwVal,
            sizeof dwVal
            ) ;

    return (l == ERROR_SUCCESS ? TRUE : FALSE) ;
}

BOOL
IsBlankMediaType (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    BOOL    r ;

    r = (pmt -> majortype   == GUID_NULL &&
         pmt -> subtype     == GUID_NULL &&
         pmt -> formattype  == GUID_NULL ? TRUE : FALSE) ;

    return r ;
}

BOOL
IsAMVideo (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (pmt -> majortype == MEDIATYPE_Video ? TRUE : FALSE) ;
}

BOOL
IsWMVideo (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    //  GUIDs are the same
    return IsAMVideo (pmt) ;
}

BOOL
IsAMAudio (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (pmt -> majortype == MEDIATYPE_Audio ? TRUE : FALSE) ;
}

BOOL
IsWMAudio (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    //  GUIDs are the same
    return IsAMAudio (pmt) ;
}

BOOL
IsHackedVideo (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (g_fRegGenericStreams_Video && pmt -> majortype == HACKED_MEDIATYPE_Video) ;
}

BOOL
IsHackedAudio (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (g_fRegGenericStreams_Audio && pmt -> majortype == HACKED_MEDIATYPE_Audio) ;
}

BOOL
IsVideo (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (IsAMVideo (pmt) || IsWMVideo (pmt) || IsHackedVideo (pmt)) ;
}

BOOL
IsAudio (
    IN  const AM_MEDIA_TYPE * pmt
    )
{
    ASSERT (pmt) ;
    return (IsAMAudio (pmt) || IsWMAudio (pmt) || IsHackedAudio (pmt)) ;
}

BOOL
AMMediaIsTimestamped (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    BOOL    r ;

    r = (IsAMVideo (pmt) || IsAMAudio (pmt) ? TRUE : FALSE) ;

    return r ;
}

//  ============================================================================
//  DShowWMSDKHelpers
//  ============================================================================

BOOL g_fRegGenericStreams_Video ;
BOOL g_fRegGenericStreams_Audio ;

//  call FreeMediaType ((AM_MEDIA_TYPE *) pWmt) to free
HRESULT
DShowWMSDKHelpers::TranslateDShowToWM (
    IN  AM_MEDIA_TYPE * pAmt,
    OUT WM_MEDIA_TYPE * pWmt
    )
{
    HRESULT hr ;

    ASSERT (pAmt) ;
    ASSERT (pWmt) ;

    hr = CopyMediaType ((AM_MEDIA_TYPE *) pWmt, pAmt) ;

    if (SUCCEEDED (hr)) {

        if (pWmt -> majortype == MEDIATYPE_Audio &&
            g_fRegGenericStreams_Audio) {
            pWmt -> majortype = HACKED_MEDIATYPE_Audio ;
        }
        else if (pWmt -> majortype == MEDIATYPE_Video &&
                g_fRegGenericStreams_Video) {
            pWmt -> majortype = HACKED_MEDIATYPE_Video ;
        }
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::TranslateWMToDShow (
    IN  WM_MEDIA_TYPE * pWmt,
    OUT AM_MEDIA_TYPE * pAmt
    )
{
    HRESULT hr ;

    ASSERT (pAmt) ;
    ASSERT (pWmt) ;

    hr = CopyMediaType (pAmt, (AM_MEDIA_TYPE *) pWmt) ;

    if (SUCCEEDED (hr)) {

        if (g_fRegGenericStreams_Audio &&
            pAmt -> majortype == HACKED_MEDIATYPE_Audio) {

            pAmt -> majortype = MEDIATYPE_Audio ;
        }
        else if (g_fRegGenericStreams_Video &&
                 pAmt -> majortype == HACKED_MEDIATYPE_Video) {

            pAmt -> majortype = MEDIATYPE_Video ;
        }
    }

    return hr ;
}

BOOL
DShowWMSDKHelpers::IsWMVideoStream (
    IN  REFGUID guidStreamType
    )
{
    BOOL    r ;

    if (g_fRegGenericStreams_Video) {
        r = (guidStreamType == HACKED_MEDIATYPE_Video ? TRUE : FALSE) ;
    }
    else {
        r = (guidStreamType == MEDIATYPE_Video ? TRUE : FALSE) ;
    }

    return r ;
}

BOOL
DShowWMSDKHelpers::IsWMAudioStream (
    IN  REFGUID guidStreamType
    )
{
    BOOL    r ;

    if (g_fRegGenericStreams_Audio) {
        r = (guidStreamType == HACKED_MEDIATYPE_Audio ? TRUE : FALSE) ;
    }
    else {
        r = (guidStreamType == MEDIATYPE_Audio ? TRUE : FALSE) ;
    }

    return r ;
}

HRESULT
DShowWMSDKHelpers::FormatBlockSetValidForWMSDK_ (
    IN  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT         hr ;
    WAVEFORMATEX *  pWaveFormatEx ;

    //  default to PASS unless we can explicitely set it to FAIL
    hr = S_OK ;

    //  ========================================================================
    //  WAVEFORMATEX format block

    if (pmt -> formattype == FORMAT_WaveFormatEx) {
        //  WAVEFORMATEX struct; we know how to validate
        if (pmt -> pbFormat &&
            pmt -> cbFormat >= sizeof WAVEFORMATEX) {

            pWaveFormatEx = reinterpret_cast <WAVEFORMATEX *> (pmt -> pbFormat) ;

            //  bitrate = 0 error
            if (pWaveFormatEx -> nAvgBytesPerSec == 0) {
                //  probably for compressed data, so it's not known; but
                //   the WMSDK expects this value to compute wrt the other
                //   members
                pWaveFormatEx -> nAvgBytesPerSec = pWaveFormatEx -> nSamplesPerSec *
                                                   pWaveFormatEx -> nChannels *
                                                   pWaveFormatEx -> wBitsPerSample /
                                                   8 ;
            }

            hr = S_OK ;
        }
        else {
            //  invalid size
            hr = E_FAIL ;
        }
    }

    //  ========================================================================
    //  generic streams are checked by the WMSDK layer at runtime for correct
    //    size as specified with the .lSampleSize vs. .bFixedSizeSamples
    //    AM_MEDIA_TYPE members; if the .bFixedSizeSamples member is set, the
    //    runtime size of the INSSBuffer is checked against the size specified
    //    here in the .lSampleSize member; the INSSBuffer is failed if the size
    //    doesn't match; these checks are not performed if the .bFixedSizeSamples
    //    member is not set;
    //  our fixup is as follows
    //    1. if it's audio & we're going to map to a generic stream (per the
    //          g_fRegGenericStreams_Audio flag), we clear .bFixedSizeSamples
    //    2. if it's video & we're going to map to a generic stream (per the
    //          g_fRegGenericStreams_Video flag), we clear .bFixedSizeSamples
    //

    //  check is made for either hacked or non-hacked majortypes in case we are
    //   called after we whack them
    if ((g_fRegGenericStreams_Video && (pmt -> majortype == MEDIATYPE_Video || pmt -> majortype == HACKED_MEDIATYPE_Video)) ||
        (g_fRegGenericStreams_Audio && (pmt -> majortype == MEDIATYPE_Audio || pmt -> majortype == HACKED_MEDIATYPE_Audio))) {

        if (pmt -> lSampleSize == 0 && pmt -> bFixedSizeSamples) {
            //  this is the check I'd like to only make
            pmt -> bFixedSizeSamples = FALSE ;
        }
        else if (pmt -> bFixedSizeSamples) {
            //  but for now, we'll clear always
            pmt -> bFixedSizeSamples = FALSE ;
        }
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::MediaTypeSetValidForWMSDK (
    IN OUT  AM_MEDIA_TYPE * pmt
    )
{
    HRESULT hr ;

    //  make sure the AM_MEDIA_TYPE members all make sense wrt one another;
    //   we look for specific media types; if there's a media type we don't
    //   know about, we'll OK it i.e. we default to pass

    if (pmt -> subtype == MEDIASUBTYPE_MPEG2_VIDEO) {
        //  mpeg-2 video is compressed
        pmt -> bTemporalCompression = TRUE ;

        //  .bFixedSizeSamples may/may not be true; we cannot tell here,
        //    though if we're the ones upstream, it'll be FALSE, but .. we
        //    cannot be sure.
    }

    hr = FormatBlockSetValidForWMSDK_ (pmt) ;

    return hr ;
}

WORD
DShowWMSDKHelpers::PinIndexToWMStreamNumber (
    IN  LONG    lIndex
    )
{
    ASSERT (lIndex < MAX_PIN_BANK_SIZE) ;
    ASSERT (lIndex + 1 < WMSDK_MAX_VALID_STREAM_NUM) ;

    return (WORD) lIndex + 1 ;
}

WORD
DShowWMSDKHelpers::PinIndexToWMInputStream (
    IN  LONG    lIndex
    )
{
    //  pin indeces are 0-based; so are input streams
    return (WORD) lIndex ;
}


LONG
DShowWMSDKHelpers::WMStreamNumberToPinIndex (
    IN  WORD    wStreamNumber
    )
{
    //  pin indeces are 0-based
    //  WM stream numbers valid values are [1,WMSDK_MAX_VALID_STREAM_NUM], so we 1-base everything

    ASSERT (WMSDK_MIN_VALID_STREAM_NUM <= wStreamNumber) ;
    ASSERT (wStreamNumber <= WMSDK_MAX_VALID_STREAM_NUM) ;
    ASSERT (wStreamNumber - 1 < MAX_PIN_BANK_SIZE) ;

    return (wStreamNumber - 1) ;
}

CDVRAttributeTranslator *
DShowWMSDKHelpers::GetAttributeTranslator (
    IN  AM_MEDIA_TYPE *     pmtConnection,
    IN  CDVRPolicy *        pPolicy,
    IN  int                 iFlowId
    )
{
    CDVRAttributeTranslator *   pRet ;

    if (pmtConnection -> majortype  == MEDIATYPE_Video &&
        pmtConnection -> subtype    == MEDIASUBTYPE_MPEG2_VIDEO) {

        pRet = new CDVRMpeg2AttributeTranslator (pPolicy, iFlowId) ;
    }
    else {
        pRet = new CDVRAttributeTranslator (pPolicy, iFlowId) ;
    }

    return pRet ;
}

HRESULT
DShowWMSDKHelpers::MaybeAddFormatSpecificExtensions (
    IN  IWMStreamConfig2 *  pIWMStreamConfig2,
    IN  AM_MEDIA_TYPE *     pmt
    )
{
    HRESULT hr ;

    ASSERT (pIWMStreamConfig2) ;
    ASSERT (pmt) ;

    if (pmt -> majortype    == MEDIATYPE_Video &&
        pmt -> subtype      == MEDIASUBTYPE_MPEG2_VIDEO) {

        //  mpeg-2 has PTSs inlined
        hr = pIWMStreamConfig2 -> AddDataUnitExtension (INSSBuffer3Prop_Mpeg2ElementaryStream, sizeof LONGLONG, NULL, 0) ;
    }
    else {
        hr = S_OK ;
    }

    return hr ;
}

BOOL
DShowWMSDKHelpers::INSSBuffer3PropPresent (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  REFGUID         rguid
    )
{
    HRESULT hr ;
    DWORD   dwLen ;

    ASSERT (pINSSBuffer3) ;

    hr = pINSSBuffer3 -> GetProperty (
            rguid,
            NULL,
            & dwLen
            ) ;

    return (SUCCEEDED (hr) && dwLen > 0 ? TRUE : FALSE) ;
}

HRESULT
DShowWMSDKHelpers::RecoverNewMediaType (
    IN  INSSBuffer3 *       pINSSBuffer3,
    OUT AM_MEDIA_TYPE **    ppmtNew         //  DeleteMediaType on this to free
    )
{
    HRESULT hr ;
    BYTE *  pbBuffer ;
    DWORD   dwLen ;

    ASSERT (pINSSBuffer3) ;
    ASSERT (ppmtNew) ;
    ASSERT (DShowWMSDKHelpers::INSSBuffer3PropPresent (pINSSBuffer3, INSSBuffer3Prop_DShowNewMediaType)) ;

    pbBuffer = NULL ;

    hr = pINSSBuffer3 -> GetProperty (
            INSSBuffer3Prop_DShowNewMediaType,
            NULL,
            & dwLen
            ) ;
    if (SUCCEEDED (hr)) {
        ASSERT (dwLen > 0) ;

        //  get the media type out
        pbBuffer = new BYTE [dwLen] ;
        if (pbBuffer) {
            //  recover
            hr = pINSSBuffer3 -> GetProperty (
                    INSSBuffer3Prop_DShowNewMediaType,
                    pbBuffer,
                    & dwLen
                    ) ;
            if (SUCCEEDED (hr)) {
                (* ppmtNew) = reinterpret_cast <AM_MEDIA_TYPE *> (CoTaskMemAlloc (sizeof AM_MEDIA_TYPE)) ;
                if (* ppmtNew) {
                    //  copy the media type itself
                    CopyMemory (
                        * ppmtNew,
                        pbBuffer,
                        sizeof AM_MEDIA_TYPE
                        ) ;

                    //  is there a format block
                    if ((* ppmtNew) -> cbFormat > 0) {
                        //  ignore the .pbFormat member - it's not valid
                        (* ppmtNew) -> pbFormat = reinterpret_cast <BYTE *> (CoTaskMemAlloc ((* ppmtNew) -> cbFormat)) ;
                        if ((* ppmtNew) -> pbFormat) {
                            //  copy the format block
                            CopyMemory (
                                (* ppmtNew) -> pbFormat,
                                pbBuffer + sizeof AM_MEDIA_TYPE,        //  format block follows contiguously when copied in..
                                (* ppmtNew) -> cbFormat
                                ) ;

                            //  success
                            hr = S_OK ;
                        }
                        else {
                            hr = E_OUTOFMEMORY ;

                            //  free what we've allocated
                            CoTaskMemFree (* ppmtNew) ;
                        }
                    }
                    else {
                        //  no format block
                        (* ppmtNew) -> pbFormat = NULL ;

                        //  success
                        hr = S_OK ;
                    }
                }
                else {
                    hr = E_OUTOFMEMORY ;
                }
            }

            //  done with the buffer regardless
            delete [] pbBuffer ;
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::InlineNewMediaType (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  AM_MEDIA_TYPE * pmtNew
    )
{
    HRESULT hr ;
    BYTE *  pbBuffer ;
    DWORD   dwLen ;

    ASSERT (pINSSBuffer3) ;
    ASSERT (pmtNew) ;

    pbBuffer    = NULL ;
    dwLen       = 0 ;

    if (pmtNew -> pbFormat == NULL) {
        if (pmtNew -> cbFormat == 0) {
            //  looks valid; set it
            pbBuffer = reinterpret_cast <BYTE *> (pmtNew) ;
            dwLen = sizeof AM_MEDIA_TYPE ;
        }
        else {
            hr = E_INVALIDARG ;
        }
    }
    else {
        //  need to form into contiguous buffer
        dwLen = sizeof AM_MEDIA_TYPE + pmtNew -> cbFormat ;
        pbBuffer = new BYTE [dwLen] ;
        if (pbBuffer) {
            //  copy the media type
            CopyMemory (
                pbBuffer,
                pmtNew,
                sizeof AM_MEDIA_TYPE
                ) ;

            //  set to follow; note this value will not make sense on the way
            //   back out
            reinterpret_cast <AM_MEDIA_TYPE *> (pbBuffer) -> pbFormat = pbBuffer + sizeof AM_MEDIA_TYPE ;

            //  and the format block
            CopyMemory (
                reinterpret_cast <AM_MEDIA_TYPE *> (pbBuffer) -> pbFormat,
                pmtNew -> pbFormat,
                pmtNew -> cbFormat
                ) ;
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }

    //  we're set
    if (SUCCEEDED (hr)) {
        ASSERT (pbBuffer) ;
        ASSERT (dwLen > 0) ;

        hr = pINSSBuffer3 -> SetProperty (
                INSSBuffer3Prop_DShowNewMediaType,
                reinterpret_cast <LPVOID> (pbBuffer),
                dwLen
                ) ;
    }

    //  done with pbBuffer
    if (pbBuffer != pmtNew -> pbFormat) {
        delete [] pbBuffer ;
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::SetDShowAttributes (
    IN  IMediaSample *  pIMS,
    IN  INSSBuffer3 *   pINSSBuffer3
    )
{
    AM_SAMPLE2_PROPERTIES       Sample2Properties ;
    INSSBUFFER3PROP_DSHOWATTRIB DShowAttrib ;
    HRESULT                     hr ;
    IMediaSample2 *             pIMS2 ;

    hr = pIMS -> QueryInterface (IID_IMediaSample2, (void **) & pIMS2) ;
    if (SUCCEEDED (hr)) {
        hr = pIMS2 -> GetProperties (
                        sizeof Sample2Properties,
                        reinterpret_cast <BYTE *> (& Sample2Properties)
                        ) ;
        if (SUCCEEDED (hr)) {

            //  time members
            hr = pIMS -> GetTime (& DShowAttrib.rtStart, & DShowAttrib.rtStop) ;
            if (hr != VFW_E_SAMPLE_TIME_NOT_SET) {
                //  might need to clear the stop time
                DShowAttrib.rtStop = (hr == VFW_S_NO_STOP_TIME ? -1 : DShowAttrib.rtStop) ;
            }
            else {
                //  clear them both
                DShowAttrib.rtStart = -1 ;
                DShowAttrib.rtStop = -1 ;

            }

            //  time is taken care of
            hr = S_OK ;

            //  set the other two
            DShowAttrib.dwTypeSpecificFlags = Sample2Properties.dwTypeSpecificFlags ;
            DShowAttrib.dwStreamId          = Sample2Properties.dwStreamId ;

            //  set it on the INSSBuffer3
            hr = pINSSBuffer3 -> SetProperty (
                                    INSSBuffer3Prop_DShowAttributes,
                                    & DShowAttrib,
                                    sizeof DShowAttrib
                                    ) ;
        }

        pIMS2 -> Release () ;
    }

    return hr ;
}

HRESULT
DShowWMSDKHelpers::RecoverDShowAttributes (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  IMediaSample *  pIMS
    )
{
    AM_SAMPLE2_PROPERTIES       Sample2Properties ;
    INSSBUFFER3PROP_DSHOWATTRIB DShowAttrib ;
    HRESULT                     hr ;
    IMediaSample2 *             pIMS2 ;
    DWORD                       dwSize ;

    ASSERT (pINSSBuffer3) ;
    ASSERT (pIMS) ;
    ASSERT (DShowWMSDKHelpers::INSSBuffer3PropPresent (pINSSBuffer3, INSSBuffer3Prop_DShowAttributes)) ;

    dwSize = sizeof DShowAttrib ;
    hr = pINSSBuffer3 -> GetProperty (
            INSSBuffer3Prop_DShowAttributes,
            & DShowAttrib,
            & dwSize
            ) ;
    if (SUCCEEDED (hr)) {
        //  set the various properties now
        if (DShowAttrib.rtStart != -1) {
            //  if there's a time associated, set it
            hr = pIMS -> SetTime (
                            & DShowAttrib.rtStart,
                            (DShowAttrib.rtStop != -1 ? & DShowAttrib.rtStop : NULL)
                            ) ;
        }

        if (SUCCEEDED (hr)) {
            //  typespecific flags & stream id; gotta get the sample properties
            hr = pIMS -> QueryInterface (IID_IMediaSample2, (void **) & pIMS2) ;
            if (SUCCEEDED (hr)) {

                hr = pIMS2 -> GetProperties (
                        sizeof Sample2Properties,
                        reinterpret_cast <BYTE *> (& Sample2Properties)
                        ) ;
                if (SUCCEEDED (hr)) {
                    Sample2Properties.dwTypeSpecificFlags   = DShowAttrib.dwTypeSpecificFlags ;
                    Sample2Properties.dwStreamId            = DShowAttrib.dwStreamId ;

                    hr = pIMS2 -> SetProperties (
                                    sizeof Sample2Properties,
                                    reinterpret_cast <const BYTE *> (& Sample2Properties)
                                    ) ;
                }

                pIMS2 -> Release () ;
            }
        }
    }

    return hr ;
}

//  ----------------------------------------------------------------------------
//      CMediaSampleWrapper
//  ----------------------------------------------------------------------------

//  shamelessly stolen from amfilter.h & amfilter.cpp

CMediaSampleWrapper::CMediaSampleWrapper() :
    m_pBuffer(NULL),                // Initialise the buffer
    m_cbBuffer(0),                  // And it's length
    m_lActual(0),                   // By default, actual = length
    m_pMediaType(NULL),             // No media type change
    m_dwFlags(0),                   // Nothing set
    m_cRef(0),                      // 0 ref count
    m_dwTypeSpecificFlags(0),       // Type specific flags
    m_dwStreamId(AM_STREAM_MEDIA),  // Stream id
    m_pIMSCore (NULL)
{
//@@BEGIN_MSINTERNAL
#ifdef DXMPERF
    PERFLOG_CTOR( L"CMediaSampleWrapper", (IMediaSample *) this );
#endif // DXMPERF
//@@END_MSINTERNAL
}

/* Destructor deletes the media type memory */

CMediaSampleWrapper::~CMediaSampleWrapper()
{
//@@BEGIN_MSINTERNAL
#ifdef DXMPERF
    PERFLOG_DTOR( L"CMediaSampleWrapper", (IMediaSample *) this );
#endif // DXMPERF
//@@END_MSINTERNAL

    if (m_pMediaType) {
    DeleteMediaType(m_pMediaType);
    }
}

/* Override this to publicise our interfaces */

STDMETHODIMP
CMediaSampleWrapper::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IMediaSample ||
        riid == IID_IMediaSample2 ||
        riid == IID_IUnknown) {
        return GetInterface((IMediaSample *) this, ppv);
    } else {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CMediaSampleWrapper::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// --  CMediaSampleWrapper lifetimes --
//
// On final release of this sample buffer it is not deleted but
// returned to the freelist of the owning memory allocator
//
// The allocator may be waiting for the last buffer to be placed on the free
// list in order to decommit all the memory, so the ReleaseBuffer() call may
// result in this sample being deleted. We also need to hold a refcount on
// the allocator to stop that going away until we have finished with this.
// However, we cannot release the allocator before the ReleaseBuffer, as the
// release may cause us to be deleted. Similarly we can't do it afterwards.
//
// Thus we must leave it to the allocator to hold an addref on our behalf.
// When he issues us in GetBuffer, he addref's himself. When ReleaseBuffer
// is called, he releases himself, possibly causing us and him to be deleted.

void
CMediaSampleWrapper::Reset_ (
    )
{
    RELEASE_AND_CLEAR (m_pIMSCore) ;
}

HRESULT
CMediaSampleWrapper::Init (
    IN  IUnknown *  pIMS,
    IN  BYTE *      pbPayload,
    IN  LONG        lPayloadLength
    )
{
    ASSERT (!m_pIMSCore) ;

    m_pIMSCore = pIMS ;
    m_pIMSCore -> AddRef () ;

    return Init (pbPayload, lPayloadLength) ;
}

HRESULT
CMediaSampleWrapper::Init (
    IN  BYTE *  pbPayload,
    IN  LONG    lPayloadLength
    )
{
    m_lActual = m_cbBuffer = lPayloadLength ;
    m_pBuffer = pbPayload ;

    return S_OK ;
}

STDMETHODIMP_(ULONG)
CMediaSampleWrapper::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
        this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        /* Free all resources */
        if (m_dwFlags & Sample_TypeChanged) {
            SetMediaType(NULL);
        }
        ASSERT(m_pMediaType == NULL);
        m_dwFlags = 0;
        m_dwTypeSpecificFlags = 0;
        m_dwStreamId = AM_STREAM_MEDIA;

        /* This may cause us to be deleted */
        // Our refcount is reliably 0 thus no-one will mess with us
        Reset_ () ;
        Recycle_ () ;
    }
    return (ULONG)lRef;
}


// set the buffer pointer and length. Used by allocators that
// want variable sized pointers or pointers into already-read data.
// This is only available through a CMediaSampleWrapper* not an IMediaSample*
// and so cannot be changed by clients.
HRESULT
CMediaSampleWrapper::SetPointer(BYTE * ptr, LONG cBytes)
{
    m_pBuffer = ptr;            // new buffer area (could be null)
    m_cbBuffer = cBytes;        // length of buffer
    m_lActual = cBytes;         // length of data in buffer (assume full)

    return S_OK;
}


// get me a read/write pointer to this buffer's memory. I will actually
// want to use sizeUsed bytes.
STDMETHODIMP
CMediaSampleWrapper::GetPointer(BYTE ** ppBuffer)
{
    ValidateReadWritePtr(ppBuffer,sizeof(BYTE *));

    // creator must have set pointer either during
    // constructor or by SetPointer
    ASSERT(m_pBuffer);

    *ppBuffer = m_pBuffer;
    return NOERROR;
}


// return the size in bytes of this buffer
STDMETHODIMP_(LONG)
CMediaSampleWrapper::GetSize(void)
{
    return m_cbBuffer;
}


// get the stream time at which this sample should start and finish.
STDMETHODIMP
CMediaSampleWrapper::GetTime(
    REFERENCE_TIME * pTimeStart,     // put time here
    REFERENCE_TIME * pTimeEnd
)
{
    ValidateReadWritePtr(pTimeStart,sizeof(REFERENCE_TIME));
    ValidateReadWritePtr(pTimeEnd,sizeof(REFERENCE_TIME));

    if (!(m_dwFlags & Sample_StopValid)) {
        if (!(m_dwFlags & Sample_TimeValid)) {
            return VFW_E_SAMPLE_TIME_NOT_SET;
        } else {
            *pTimeStart = m_Start;

            //  Make sure old stuff works
            *pTimeEnd = m_Start + 1;
            return VFW_S_NO_STOP_TIME;
        }
    }

    *pTimeStart = m_Start;
    *pTimeEnd = m_End;
    return NOERROR;
}


// Set the stream time at which this sample should start and finish.
// NULL pointers means the time is reset
STDMETHODIMP
CMediaSampleWrapper::SetTime(
    REFERENCE_TIME * pTimeStart,
    REFERENCE_TIME * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~(Sample_TimeValid | Sample_StopValid);
    } else {
        if (pTimeEnd == NULL) {
            m_Start = *pTimeStart;
            m_dwFlags |= Sample_TimeValid;
            m_dwFlags &= ~Sample_StopValid;
        } else {
            ValidateReadPtr(pTimeStart,sizeof(REFERENCE_TIME));
            ValidateReadPtr(pTimeEnd,sizeof(REFERENCE_TIME));
            ASSERT(*pTimeEnd >= *pTimeStart);

            m_Start = *pTimeStart;
            m_End = *pTimeEnd;
            m_dwFlags |= Sample_TimeValid | Sample_StopValid;
        }
    }
    return NOERROR;
}


// get the media times (eg bytes) for this sample
STDMETHODIMP
CMediaSampleWrapper::GetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    ValidateReadWritePtr(pTimeStart,sizeof(LONGLONG));
    ValidateReadWritePtr(pTimeEnd,sizeof(LONGLONG));

    if (!(m_dwFlags & Sample_MediaTimeValid)) {
        return VFW_E_MEDIA_TIME_NOT_SET;
    }

    *pTimeStart = m_MediaStart;
    *pTimeEnd = (m_MediaStart + m_MediaEnd);
    return NOERROR;
}


// Set the media times for this sample
STDMETHODIMP
CMediaSampleWrapper::SetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~Sample_MediaTimeValid;
    } else {
        ValidateReadPtr(pTimeStart,sizeof(LONGLONG));
        ValidateReadPtr(pTimeEnd,sizeof(LONGLONG));
        ASSERT(*pTimeEnd >= *pTimeStart);

        m_MediaStart = *pTimeStart;
        m_MediaEnd = (LONG)(*pTimeEnd - *pTimeStart);
        m_dwFlags |= Sample_MediaTimeValid;
    }
    return NOERROR;
}


STDMETHODIMP
CMediaSampleWrapper::IsSyncPoint(void)
{
    if (m_dwFlags & Sample_SyncPoint) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}


STDMETHODIMP
CMediaSampleWrapper::SetSyncPoint(BOOL bIsSyncPoint)
{
    if (bIsSyncPoint) {
        m_dwFlags |= Sample_SyncPoint;
    } else {
        m_dwFlags &= ~Sample_SyncPoint;
    }
    return NOERROR;
}

// returns S_OK if there is a discontinuity in the data (this same is
// not a continuation of the previous stream of data
// - there has been a seek).
STDMETHODIMP
CMediaSampleWrapper::IsDiscontinuity(void)
{
    if (m_dwFlags & Sample_Discontinuity) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

// set the discontinuity property - TRUE if this sample is not a
// continuation, but a new sample after a seek.
STDMETHODIMP
CMediaSampleWrapper::SetDiscontinuity(BOOL bDiscont)
{
    // should be TRUE or FALSE
    if (bDiscont) {
        m_dwFlags |= Sample_Discontinuity;
    } else {
        m_dwFlags &= ~Sample_Discontinuity;
    }
    return S_OK;
}

STDMETHODIMP
CMediaSampleWrapper::IsPreroll(void)
{
    if (m_dwFlags & Sample_Preroll) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}


STDMETHODIMP
CMediaSampleWrapper::SetPreroll(BOOL bIsPreroll)
{
    if (bIsPreroll) {
        m_dwFlags |= Sample_Preroll;
    } else {
        m_dwFlags &= ~Sample_Preroll;
    }
    return NOERROR;
}

STDMETHODIMP_(LONG)
CMediaSampleWrapper::GetActualDataLength(void)
{
    return m_lActual;
}


STDMETHODIMP
CMediaSampleWrapper::SetActualDataLength(LONG lActual)
{
    if (lActual > m_cbBuffer) {
        ASSERT(lActual <= GetSize());
        return VFW_E_BUFFER_OVERFLOW;
    }
    m_lActual = lActual;
    return NOERROR;
}


/* These allow for limited format changes in band */

STDMETHODIMP
CMediaSampleWrapper::GetMediaType(AM_MEDIA_TYPE **ppMediaType)
{
    ValidateReadWritePtr(ppMediaType,sizeof(AM_MEDIA_TYPE *));
    ASSERT(ppMediaType);

    /* Do we have a new media type for them */

    if (!(m_dwFlags & Sample_TypeChanged)) {
        ASSERT(m_pMediaType == NULL);
        *ppMediaType = NULL;
        return S_FALSE;
    }

    ASSERT(m_pMediaType);

    /* Create a copy of our media type */

    *ppMediaType = CreateMediaType(m_pMediaType);
    if (*ppMediaType == NULL) {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}


/* Mark this sample as having a different format type */

STDMETHODIMP
CMediaSampleWrapper::SetMediaType(AM_MEDIA_TYPE *pMediaType)
{
    /* Delete the current media type */

    if (m_pMediaType) {
        DeleteMediaType(m_pMediaType);
        m_pMediaType = NULL;
    }

    /* Mechanism for resetting the format type */

    if (pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
        return NOERROR;
    }

    ASSERT(pMediaType);
    ValidateReadPtr(pMediaType,sizeof(AM_MEDIA_TYPE));

    /* Take a copy of the media type */

    m_pMediaType = CreateMediaType(pMediaType);
    if (m_pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
        return E_OUTOFMEMORY;
    }

    m_dwFlags |= Sample_TypeChanged;
    return NOERROR;
}

// Set and get properties (IMediaSample2)
STDMETHODIMP CMediaSampleWrapper::GetProperties(
    DWORD cbProperties,
    BYTE * pbProperties
)
{
    if (0 != cbProperties) {
        CheckPointer(pbProperties, E_POINTER);
        //  Return generic stuff up to the length
        AM_SAMPLE2_PROPERTIES Props;
        Props.cbData     = min(cbProperties, sizeof(Props));
        Props.dwSampleFlags = m_dwFlags & ~Sample_MediaTimeValid;
        Props.dwTypeSpecificFlags = m_dwTypeSpecificFlags;
        Props.pbBuffer   = m_pBuffer;
        Props.cbBuffer   = m_cbBuffer;
        Props.lActual    = m_lActual;
        Props.tStart     = m_Start;
        Props.tStop      = m_End;
        Props.dwStreamId = m_dwStreamId;
        if (m_dwFlags & AM_SAMPLE_TYPECHANGED) {
            Props.pMediaType = m_pMediaType;
        } else {
            Props.pMediaType = NULL;
        }
        CopyMemory(pbProperties, &Props, Props.cbData);
    }
    return S_OK;
}

HRESULT CMediaSampleWrapper::SetProperties(
    DWORD cbProperties,
    const BYTE * pbProperties
)
{

    /*  Generic properties */
    AM_MEDIA_TYPE *pMediaType = NULL;

    if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbData, cbProperties)) {
        CheckPointer(pbProperties, E_POINTER);
        AM_SAMPLE2_PROPERTIES *pProps =
            (AM_SAMPLE2_PROPERTIES *)pbProperties;

        /*  Don't use more data than is actually there */
        if (pProps->cbData < cbProperties) {
            cbProperties = pProps->cbData;
        }
        /*  We only handle IMediaSample2 */
        if (cbProperties > sizeof(*pProps) ||
            pProps->cbData > sizeof(*pProps)) {
            return E_INVALIDARG;
        }
        /*  Do checks first, the assignments (for backout) */
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Check the flags */
            if (pProps->dwSampleFlags &
                    (~Sample_ValidFlags | Sample_MediaTimeValid)) {
                return E_INVALIDARG;
            }
            /*  Check a flag isn't being set for a property
                not being provided
            */
            if ((pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID) &&
                 !(m_dwFlags & AM_SAMPLE_TIMEVALID) &&
                 !DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {
                 return E_INVALIDARG;
            }
        }
        /*  NB - can't SET the pointer or size */
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pbBuffer, cbProperties)) {

            /*  Check pbBuffer */
            if (pProps->pbBuffer != 0 && pProps->pbBuffer != m_pBuffer) {
                return E_INVALIDARG;
            }
        }
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties)) {

            /*  Check cbBuffer */
            if (pProps->cbBuffer != 0 && pProps->cbBuffer != m_cbBuffer) {
                return E_INVALIDARG;
            }
        }
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties) &&
            DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {

            /*  Check lActual */
            if (pProps->cbBuffer < pProps->lActual) {
                return E_INVALIDARG;
            }
        }

        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {

            /*  Check pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                CheckPointer(pProps->pMediaType, E_POINTER);
                pMediaType = CreateMediaType(pProps->pMediaType);
                if (pMediaType == NULL) {
                    return E_OUTOFMEMORY;
                }
            }
        }

        /*  Now do the assignments */
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwStreamId, cbProperties)) {
            m_dwStreamId = pProps->dwStreamId;
        }
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Set the flags */
            m_dwFlags = pProps->dwSampleFlags |
                                (m_dwFlags & Sample_MediaTimeValid);
            m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
        } else {
            if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwTypeSpecificFlags, cbProperties)) {
                m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
            }
        }

        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {
            /*  Set lActual */
            m_lActual = pProps->lActual;
        }

        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {

            /*  Set the times */
            m_End   = pProps->tStop;
        }
        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStart, cbProperties)) {

            /*  Set the times */
            m_Start = pProps->tStart;
        }

        if (DVR_CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {
            /*  Set pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                if (m_pMediaType != NULL) {
                    DeleteMediaType(m_pMediaType);
                }
                m_pMediaType = pMediaType;
            }
        }

        /*  Fix up the type changed flag to correctly reflect the current state
            If, for instance the input contained no type change but the
            output does then if we don't do this we'd lose the
            output media type.
        */
        if (m_pMediaType) {
            m_dwFlags |= Sample_TypeChanged;
        } else {
            m_dwFlags &= ~Sample_TypeChanged;
        }
    }

    return S_OK;
}

//  ----------------------------------------------------------------------------
//  ----------------------------------------------------------------------------

void
CPooledMediaSampleWrapper::Recycle_ (
    )
{
    m_pOwningPool -> Recycle (this) ;
}

//  ============================================================================
//  ============================================================================

CPooledMediaSampleWrapper *
CMediaSampleWrapperPool::Get (
    )
{
    CPooledMediaSampleWrapper * pMSWrapper ;

    pMSWrapper = TCDynamicProdCons <CPooledMediaSampleWrapper>::Get () ;
    if (pMSWrapper) {
        pMSWrapper -> AddRef () ;

        if (m_pDVRSendStatsWriter) {
            m_pDVRSendStatsWriter -> MediaSampleWrapperOut (m_iFlowId, m_lMaxAllocate) ;
        }
    }

    return pMSWrapper ;
}

CPooledMediaSampleWrapper *
CMediaSampleWrapperPool::TryGet (
    )
{
    CPooledMediaSampleWrapper * pMSWrapper ;

    pMSWrapper = TCDynamicProdCons <CPooledMediaSampleWrapper>::TryGet () ;
    if (pMSWrapper) {
        pMSWrapper -> AddRef () ;

        if (m_pDVRSendStatsWriter) {
            m_pDVRSendStatsWriter -> MediaSampleWrapperOut (m_iFlowId, m_lMaxAllocate) ;
        }
    }

    return pMSWrapper ;
}

void
CMediaSampleWrapperPool::Recycle (
    IN  CPooledMediaSampleWrapper * pMSWrapper
    )
{
    if (m_pDVRSendStatsWriter) {
        m_pDVRSendStatsWriter -> MediaSampleWrapperRecycled (m_iFlowId, m_lMaxAllocate) ;
    }

    TCDynamicProdCons <CPooledMediaSampleWrapper>::Recycle (pMSWrapper) ;
}

//  ============================================================================
//  ============================================================================

CINSSBuffer3Attrib::CINSSBuffer3Attrib (
    ) : m_pbAttribute               (NULL),
        m_dwAttributeAllocatedSize  (0),
        m_dwAttributeSize           (0)
{
}

CINSSBuffer3Attrib::~CINSSBuffer3Attrib (
    )
{
    FreeResources_ () ;
}

HRESULT
CINSSBuffer3Attrib::SetAttributeData (
    IN  GUID    guid,
    IN  LPVOID  pvData,
    IN  DWORD   dwSize
    )
{
    if (!pvData &&
        dwSize > 0) {

        return E_POINTER ;
    }

    if (dwSize > m_dwAttributeAllocatedSize ||
        pvData == NULL) {

        FreeResources_ () ;
        m_pbAttribute = new BYTE [dwSize] ;
        if (!m_pbAttribute) {
            return E_OUTOFMEMORY ;
        }

        m_dwAttributeAllocatedSize = dwSize ;
    }

    //  if there's attribute data
    if (dwSize > 0) {
        //  copy it in
        CopyMemory (m_pbAttribute, pvData, dwSize) ;
    }

    //  size always is set
    m_dwAttributeSize = dwSize ;

    //  GUID always gets set
    m_guidAttribute = guid ;

    return S_OK ;
}

HRESULT
CINSSBuffer3Attrib::IsEqual (
    IN  GUID    guid
    )
{
    return (guid == m_guidAttribute ? TRUE : FALSE) ;
}

HRESULT
CINSSBuffer3Attrib::GetAttribute (
    IN      GUID    guid,
    IN OUT  LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    HRESULT hr ;

    if (!pdwDataLen) {
        return E_POINTER ;
    }

    if (IsEqual (guid)) {

        if (pvData) {
            //  caller wants the data
            (* pdwDataLen) = Min <DWORD> ((* pdwDataLen), m_dwAttributeSize) ;
            CopyMemory (pvData, m_pbAttribute, (* pdwDataLen)) ;
        }
        else {
            //  caller just wants to know how big
            (* pdwDataLen) = m_dwAttributeSize ;
        }

        //  success
        hr = S_OK ;
    }
    else {
        //  not the right guid
        hr = NS_E_UNSUPPORTED_PROPERTY ;
    }

    return hr ;
}

//  ============================================================================
//      CINSSBuffer3AttribList
//  ============================================================================

CINSSBuffer3AttribList::CINSSBuffer3AttribList (
    ) : m_pAttribListHead   (NULL)
{
}

CINSSBuffer3AttribList::~CINSSBuffer3AttribList (
    )
{
    Reset () ;
}

CINSSBuffer3Attrib *
CINSSBuffer3AttribList::PopListHead_ (
    )
{
    CINSSBuffer3Attrib *    pCur ;

    pCur = m_pAttribListHead ;
    if (pCur) {
        m_pAttribListHead = m_pAttribListHead -> m_pNext ;
        pCur -> m_pNext = NULL ;
    }

    return pCur ;
}

CINSSBuffer3Attrib *
CINSSBuffer3AttribList::FindInList_ (
    IN  GUID    guid
    )
{
    CINSSBuffer3Attrib *    pCur ;

    for (pCur = m_pAttribListHead;
         pCur && !pCur -> IsEqual (guid);
         pCur = pCur -> m_pNext) ;

    return pCur ;
}

void
CINSSBuffer3AttribList::InsertInList_ (
    IN  CINSSBuffer3Attrib *    pNew
    )
{
    pNew -> m_pNext = m_pAttribListHead ;
    m_pAttribListHead = pNew ;
}

HRESULT
CINSSBuffer3AttribList::AddAttribute (
    IN  GUID    guid,
    IN  LPVOID  pvData,
    IN  DWORD   dwSize
    )
{
    HRESULT                 hr ;
    CINSSBuffer3Attrib *    pNew ;

    pNew = FindInList_ (guid) ;
    if (!pNew) {
        pNew = Get () ;
        if (pNew) {
            hr = pNew -> SetAttributeData (
                    guid,
                    pvData,
                    dwSize
                    ) ;

            if (SUCCEEDED (hr)) {
                InsertInList_ (pNew) ;
            }
            else {
                //  recycle it if anything failed
                Recycle (pNew) ;
            }
        }
        else {
            hr = E_OUTOFMEMORY ;
        }
    }
    else {
        //  duplicates don't make sense
        hr = E_FAIL ;
    }

    return hr ;
}

HRESULT
CINSSBuffer3AttribList::GetAttribute (
    IN      GUID    guid,
    IN OUT  LPVOID  pvData,
    IN OUT  DWORD * pdwDataLen
    )
{
    HRESULT                 hr ;
    CINSSBuffer3Attrib *    pAttrib ;

    pAttrib = FindInList_ (guid) ;
    if (pAttrib) {
        hr = pAttrib -> GetAttribute (
                guid,
                pvData,
                pdwDataLen
                ) ;
    }
    else {
        hr = NS_E_UNSUPPORTED_PROPERTY ;
    }

    return hr ;
}

void
CINSSBuffer3AttribList::Reset (
    )
{
    CINSSBuffer3Attrib *    pCur ;

    for (;;) {
        pCur = PopListHead_ () ;
        if (pCur) {
                Recycle (pCur) ;
        }
        else {
            break ;
        }
    }
}

//  ============================================================================
//      CWMINSSBuffer3Wrapper
//  ============================================================================

CWMINSSBuffer3Wrapper::CWMINSSBuffer3Wrapper (
    ) : m_punkCore              (NULL),
        m_cRef                  (0)
{
}

CWMINSSBuffer3Wrapper::~CWMINSSBuffer3Wrapper (
    )
{
    Reset_ () ;
}

HRESULT
CWMINSSBuffer3Wrapper::Init (
    IN  IUnknown *  punkCore,
    IN  BYTE *      pbBuffer,
    IN  DWORD       dwLength
    )
{
    ASSERT (punkCore) ;
    ASSERT (pbBuffer) ;

    m_punkCore = punkCore ;
    m_punkCore -> AddRef () ;

    m_dwBufferLength = m_dwMaxBufferLength = dwLength ;

    m_pbBuffer = pbBuffer ;

    return S_OK ;
}

void
CWMINSSBuffer3Wrapper::Reset_ (
    )
{
    m_AttribList.Reset () ;
    RELEASE_AND_CLEAR (m_punkCore) ;
}

// IUnknown
STDMETHODIMP
CWMINSSBuffer3Wrapper::QueryInterface (
    REFIID riid,
    void **ppv
    )
{
    if (riid == IID_INSSBuffer) {
        return GetInterface((INSSBuffer *) this, ppv);
    }
    else if (riid == IID_INSSBuffer2) {
        return GetInterface((INSSBuffer2 *) this, ppv);
    }
    else if (riid == IID_INSSBuffer3) {
        return GetInterface((INSSBuffer3 *) this, ppv);
    }
    else if (riid == IID_IUnknown) {
        //  ambiguous, so we pick the first interface we inherit from
        return GetInterface ((INSSBuffer3 *) this, ppv) ;
    }
    else {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CWMINSSBuffer3Wrapper::Release()
{
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    if (lRef == 0) {
        Reset_ () ;
        Recycle_ () ;
    }

    return (ULONG)lRef;
}

STDMETHODIMP_(ULONG)
CWMINSSBuffer3Wrapper::AddRef()
{
    return InterlockedIncrement (& m_cRef) ;
}

// INSSBuffer
STDMETHODIMP
CWMINSSBuffer3Wrapper::GetLength (
    OUT DWORD * pdwLength
    )
{
    if (!pdwLength) {
        return E_POINTER ;
    }

    (* pdwLength) = m_dwBufferLength ;
    return S_OK ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::SetLength (
    IN  DWORD dwLength
    )
{
    HRESULT hr ;

    if (dwLength <= m_dwMaxBufferLength) {
        m_dwBufferLength = dwLength ;
        hr = S_OK ;
    }
    else {
        hr = VFW_E_BUFFER_OVERFLOW ;
    }

    return hr ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::GetMaxLength (
    OUT DWORD * pdwLength
    )
{
    if (!pdwLength) {
        return E_POINTER ;
    }

    (* pdwLength) = m_dwMaxBufferLength ;
    return S_OK ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::GetBufferAndLength (
    OUT BYTE ** ppdwBuffer,
    OUT DWORD * pdwLength
    )
{
    if (!ppdwBuffer ||
        !pdwLength) {
        return E_POINTER ;
    }

    (* ppdwBuffer)  = m_pbBuffer ;
    (* pdwLength)   = m_dwBufferLength ;

    return S_OK ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::GetBuffer (
    IN  BYTE ** ppdwBuffer
    )
{
    if (!ppdwBuffer) {
        return E_POINTER ;
    }

    (* ppdwBuffer)  = m_pbBuffer ;

    return S_OK ;
}

//  INSSBuffer2
STDMETHODIMP
CWMINSSBuffer3Wrapper::GetSampleProperties (
    IN  DWORD   cbProperties,
    OUT BYTE *  pbProperties
    )
{
    return E_NOTIMPL ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::SetSampleProperties (
    IN  DWORD cbProperties,
    IN  BYTE * pbProperties
    )
{
    return E_NOTIMPL ;
}

//  INSSBuffer3Wrapper
STDMETHODIMP
CWMINSSBuffer3Wrapper::SetProperty (
    IN  GUID    guidProperty,
    IN  void *  pvProperty,
    IN  DWORD   dwPropertySize
    )
{
    return m_AttribList.AddAttribute (
                guidProperty,
                pvProperty,
                dwPropertySize
                ) ;
}

STDMETHODIMP
CWMINSSBuffer3Wrapper::GetProperty (
    IN      GUID    guidProperty,
    OUT     void *  pvProperty,
    IN OUT  DWORD * pdwPropertySize
    )
{
    return m_AttribList.GetAttribute (
                guidProperty,
                pvProperty,
                pdwPropertySize
                ) ;
}

//  ============================================================================

void
CPooledWMINSSBuffer3Wrapper::Recycle_ (
    )
{
    m_pOwningPool -> Recycle (this) ;
}

//  ============================================================================
//  ============================================================================

CDVRAttributeTranslator::CDVRAttributeTranslator (
    IN  CDVRPolicy *        pPolicy,
    IN  BOOL                fInlineDShowProps,
    IN  int                 iFlowId
    ) : m_fInlineDShowProps (fInlineDShowProps),
        m_iFlowId           (iFlowId)
{
    ASSERT (pPolicy) ;
    m_fUseContinuityCounter     = pPolicy -> Settings () -> UseContinuityCounter () ;
    m_dwContinuityCounterNext   = 0 ;
}

BOOL
CDVRAttributeTranslator::IsINSSBuffer3PropDiscontinuity_ (
    IN  INSSBuffer3 *   pINSSBuffer3
    )
{
    BOOL    r ;
    HRESULT hr ;
    DWORD   dwCounter ;
    DWORD   dwSize ;

    ASSERT (m_fUseContinuityCounter) ;

    //  default
    r = FALSE ;

    dwSize = sizeof dwCounter ;

    hr = pINSSBuffer3 -> GetProperty (
            INSSBuffer3Prop_ContinuityCounter,
            & dwCounter,
            & dwSize
            ) ;
    if (SUCCEEDED (hr)) {
        r = (dwCounter == m_dwContinuityCounterNext) ;

        m_dwContinuityCounterNext = dwCounter + 1 ;
    }

    return r ;
}

HRESULT
CDVRAttributeTranslator::WriteINSSBuffer3PropContinuity_ (
    IN  INSSBuffer3 *   pINSSBuffer3
    )
{
    HRESULT hr ;

    ASSERT (m_fUseContinuityCounter) ;

    hr = pINSSBuffer3 -> SetProperty (
            INSSBuffer3Prop_ContinuityCounter,
            reinterpret_cast <LPVOID> (& m_dwContinuityCounterNext),
            sizeof m_dwContinuityCounterNext
            ) ;
    if (SUCCEEDED (hr)) {
        m_dwContinuityCounterNext++ ;
    }

    return hr ;
}

HRESULT
CDVRAttributeTranslator::InlineProperties_ (
    IN      IMediaSample *  pIMS,
    IN OUT  INSSBuffer3 *   pINSSBuffer3
    )
{
    AM_MEDIA_TYPE * pmt ;
    HRESULT         hr ;

    ASSERT (pIMS) ;
    ASSERT (pINSSBuffer3) ;

    //  ========================================================================
    //  dshow attributes
    if (m_fInlineDShowProps) {
        hr = DShowWMSDKHelpers::SetDShowAttributes (pIMS, pINSSBuffer3) ;
    }
    else {
        //  don't have the ability to not inline attributes
        hr = E_NOTIMPL ;
    }

    //  ========================================================================
    //  dynamic format change
    if (SUCCEEDED (hr) &&
        pIMS -> GetMediaType (& pmt) == S_OK) {

        ASSERT (pmt) ;
        hr = DShowWMSDKHelpers::InlineNewMediaType (pINSSBuffer3, pmt) ;
        FreeMediaType (* pmt) ;
    }

    //  ========================================================================
    //  continuity counter
    if (m_fUseContinuityCounter) {
        WriteINSSBuffer3PropContinuity_ (pINSSBuffer3) ;
    }

    return hr ;
}

HRESULT
CDVRAttributeTranslator::RecoverInlineProperties_ (
    IN      INSSBuffer *        pINSSBuffer,
    IN OUT  IMediaSample *      pIMS,
    OUT     AM_MEDIA_TYPE **    ppmtNew                 //  dyn format change
    )
{
    AM_SAMPLE2_PROPERTIES   SampleProperties ;
    HRESULT                 hr ;
    INSSBuffer3 *           pINSSBuffer3 ;
    BOOL                    r ;
    IMediaSample2 *         pIMS2 ;

    ASSERT (pINSSBuffer) ;
    ASSERT (pIMS) ;
    ASSERT (ppmtNew) ;

    pINSSBuffer3    = NULL ;
    (* ppmtNew)     = NULL ;

    hr = pINSSBuffer -> QueryInterface (
            IID_INSSBuffer3,
            (void **) & pINSSBuffer3
            ) ;
    if (SUCCEEDED (hr)) {

        //  ====================================================================
        //  recover inlined props, if they're there
        if (DShowWMSDKHelpers::INSSBuffer3PropPresent (pINSSBuffer3, INSSBuffer3Prop_DShowAttributes)) {

            //  recover the dshow attributes
            hr = DShowWMSDKHelpers::RecoverDShowAttributes (
                    pINSSBuffer3,
                    pIMS
                    ) ;
        }
        else {
            //  we're not implemented to NOT recover the attributes via
            //   INSSBuffer3 i.e. recover the times directly from the WMSDK
            hr = E_NOTIMPL ;
        }

        //  ====================================================================
        //  check for a dynamic format change
        if (SUCCEEDED (hr) &&
            DShowWMSDKHelpers::INSSBuffer3PropPresent (pINSSBuffer3, INSSBuffer3Prop_DShowNewMediaType)) {

            //  recover the new media type
            hr = DShowWMSDKHelpers::RecoverNewMediaType (
                    pINSSBuffer3,
                    ppmtNew
                    ) ;

            //  if we successfully recovered a media type, we must tag the
            //   media sample with it
            if (SUCCEEDED (hr) &&
                (* ppmtNew)) {

                //  want to pass back out the pointer to the actual media type,
                //   not a copy
                hr = pIMS -> SetMediaType (* ppmtNew) ;
                if (SUCCEEDED (hr)) {
                    //  free allocated in the RecoverNewMediaType call
                    DeleteMediaType (* ppmtNew) ;
                    (* ppmtNew) = NULL ;

                    //  retrieve a direct pointer to the media type in the
                    //   media sample (vs. making a copy of it)
                    hr = pIMS -> QueryInterface (IID_IMediaSample2, (void **) & pIMS2) ;
                    if (SUCCEEDED (hr)) {
                        hr = pIMS2 -> GetProperties (
                                            sizeof SampleProperties,
                                            reinterpret_cast <BYTE *> (& SampleProperties)
                                            ) ;
                        if (SUCCEEDED (hr)) {
                            (* ppmtNew) = SampleProperties.pMediaType ;
                        }

                        pIMS2 -> Release () ;
                    }
                }
            }
        }
        else {
            //  clear explicitely
            (* ppmtNew) = NULL ;
        }

        //  ====================================================================
        //  check for per-stream discontinuities, if the counter is present
        if (DShowWMSDKHelpers::INSSBuffer3PropPresent (pINSSBuffer3, INSSBuffer3Prop_ContinuityCounter)) {
            r = IsINSSBuffer3PropDiscontinuity_ (pINSSBuffer3) ;
        }
    }

    RELEASE_AND_CLEAR (pINSSBuffer3) ;

    return hr ;
}

HRESULT
CDVRAttributeTranslator::SetAttributesWMSDK (
    IN  IReferenceClock *   pRefClock,
    IN  REFERENCE_TIME *    prtStartTime,
    IN  IMediaSample *      pIMS,
    OUT INSSBuffer3 *       pINSSBuffer3,
    OUT DWORD *             pdwWMSDKFlags,
    OUT QWORD *             pcnsSampleTime
    )
{
    REFERENCE_TIME  rtNow ;
    HRESULT         hr ;

    ASSERT (pIMS) ;
    ASSERT (pINSSBuffer3) ;
    ASSERT (pdwWMSDKFlags) ;
    ASSERT (pcnsSampleTime) ;
    ASSERT (prtStartTime) ;

    pRefClock -> GetTime (& rtNow) ;
    (* pcnsSampleTime) = rtNow ;
    (* pcnsSampleTime) -= (* prtStartTime) ;        //  normalize

    //  flags
    (* pdwWMSDKFlags) = 0 ;
    if (pIMS -> IsDiscontinuity () == S_OK) {
        (* pdwWMSDKFlags) |= WM_SF_DISCONTINUITY ;
    }

    if (pIMS -> IsSyncPoint () == S_OK) {
        (* pdwWMSDKFlags) |= WM_SF_CLEANPOINT ;
    }

    //  inline data
    hr = InlineProperties_ (
            pIMS,
            pINSSBuffer3
            ) ;

    return hr ;
}

HRESULT
CDVRAttributeTranslator::SetAttributesDShow (
    IN      INSSBuffer *        pINSSBuffer,
    IN      QWORD               cnsStreamTimeOfSample,
    IN      QWORD               cnsSampleDuration,
    IN      DWORD               dwFlags,
    IN OUT  IMediaSample *      pIMS,
    OUT     AM_MEDIA_TYPE **    ppmtNew                 //  dyn format change
    )
{
    HRESULT hr ;

    ASSERT (pIMS) ;
    ASSERT (pINSSBuffer) ;

    pIMS -> SetDiscontinuity (dwFlags & WM_SF_DISCONTINUITY) ;
    pIMS -> SetSyncPoint (dwFlags & WM_SF_CLEANPOINT) ;

    hr = RecoverInlineProperties_ (
            pINSSBuffer,
            pIMS,
            ppmtNew
            ) ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRMpeg2AttributeTranslator::InlineAnalysisData_ (
    IN      IReferenceClock *   pRefClock,
    IN      IMediaSample *      pIMS,
    IN OUT  DWORD *             pdwWMSDKFlags,
    IN OUT  QWORD *             pcnsSampleTime,
    OUT     INSSBuffer3 *       pINSSBuffer3
    )
{
    HRESULT hr ;

    hr = m_Mpeg2AnalysisReader.RetrieveFlags (pIMS) ;
    if (SUCCEEDED (hr)) {
        //  frame types are mutually exclusive flags
        if (m_Mpeg2AnalysisReader.IsGOPHeader ()) {
            ;
        }
        else if (m_Mpeg2AnalysisReader.IsBFrame ()) {
            ;
        }
        else if (m_Mpeg2AnalysisReader.IsPFrame ()) {
            ;
        }
    }

    return hr ;
}

HRESULT
CDVRMpeg2AttributeTranslator::InlineMpeg2Attributes_ (
    IN  INSSBuffer3 *   pINSSBuffer3,
    IN  IMediaSample *  pIMS
    )
{
    HRESULT         hr ;
    REFERENCE_TIME  rtStart ;
    REFERENCE_TIME  rtStop ;

    hr = pIMS -> GetTime (& rtStart, & rtStop) ;
    if (hr != VFW_E_SAMPLE_TIME_NOT_SET) {
        hr = pINSSBuffer3 -> SetProperty (
                                INSSBuffer3Prop_Mpeg2ElementaryStream,
                                & rtStart,
                                sizeof rtStart
                                ) ;
    }
    else {
        //  no time set; don't fail the call
        hr = S_OK ;
    }

    return hr ;
}

HRESULT
CDVRMpeg2AttributeTranslator::SetAttributesWMSDK (
    IN  IReferenceClock *   pRefClock,
    IN  REFERENCE_TIME *    prtStartTime,
    IN  IMediaSample *      pIMS,
    OUT INSSBuffer3 *       pINSSBuffer3,
    OUT DWORD *             pdwWMSDKFlags,
    OUT QWORD *             pcnsSampleTime
    )
{
    REFERENCE_TIME  rtNow ;
    HRESULT         hr ;

    ASSERT (pRefClock) ;
    ASSERT (pIMS) ;
    ASSERT (pINSSBuffer3) ;
    ASSERT (pdwWMSDKFlags) ;
    ASSERT (pcnsSampleTime) ;
    ASSERT (prtStartTime) ;

    pRefClock -> GetTime (& rtNow) ;
    (* pcnsSampleTime) = rtNow ;
    (* pcnsSampleTime) -= (* prtStartTime) ;        //  normalize

    //  flags
    (* pdwWMSDKFlags) = 0 ;
    if (pIMS -> IsDiscontinuity () == S_OK) {
        (* pdwWMSDKFlags) |= WM_SF_DISCONTINUITY ;
    }

    if (pIMS -> IsSyncPoint () == S_OK) {
        (* pdwWMSDKFlags) |= WM_SF_CLEANPOINT ;
    }

    InlineAnalysisData_ (
        pRefClock,
        pIMS,
        pdwWMSDKFlags,
        pcnsSampleTime,
        pINSSBuffer3
        ) ;

    //  inline data
    hr = InlineProperties_ (
            pIMS,
            pINSSBuffer3
            ) ;
    if (SUCCEEDED (hr)) {
        hr = InlineMpeg2Attributes_ (
                pINSSBuffer3,
                pIMS
                ) ;
    }

    return hr ;
}

HRESULT
CDVRMpeg2AttributeTranslator::SetAttributesDShow (
    IN      INSSBuffer *        pINSSBuffer,
    IN      QWORD               cnsStreamTimeOfSample,
    IN      QWORD               cnsSampleDuration,
    IN      DWORD               dwFlags,
    IN OUT  IMediaSample *      pIMS,
    OUT     AM_MEDIA_TYPE **    ppmtNew                 //  dyn format change
    )
{
    HRESULT hr ;

    ASSERT (pIMS) ;
    ASSERT (pINSSBuffer) ;

    pIMS -> SetDiscontinuity (dwFlags & WM_SF_DISCONTINUITY) ;
    pIMS -> SetSyncPoint (dwFlags & WM_SF_CLEANPOINT) ;

    hr = RecoverInlineProperties_ (
            pINSSBuffer,
            pIMS,
            ppmtNew
            ) ;

    return hr ;
}

//  ============================================================================
//  ============================================================================

//  BUGBUG: for now based on the type of analysis
CDVRAnalysisFlags *
GetAnalysisTagger (
    IN  REFGUID rguidAnalysis
    )
{
    CDVRAnalysisFlags * pTagger ;

    if (rguidAnalysis == DVRAnalysis_Mpeg2GOP ||
        rguidAnalysis == DVRAnalysis_Mpeg2_BFrame ||
        rguidAnalysis == DVRAnalysis_Mpeg2_PFrame) {

        pTagger = new CDVRMpeg2VideoAnalysisFlags () ;
    }
    else {
        pTagger = NULL ;
    }

    return pTagger ;
}

void
RecycleAnalysisTagger (
    IN  CDVRAnalysisFlags * pTagger
    )
{
    delete pTagger ;
}

//  ----------------------------------------------

HRESULT
CDVRAnalysisFlags::RetrieveFlags (
    IN  IMediaSample *  pIMediaSample
    )
{
    HRESULT                 hr ;
    AM_SAMPLE2_PROPERTIES   SampleProperties ;
    IMediaSample2 *         pIMediaSample2 ;

    ASSERT (pIMediaSample) ;

    hr = pIMediaSample -> QueryInterface (
            IID_IMediaSample2,
            (void **) & pIMediaSample2
            ) ;

    if (SUCCEEDED (hr)) {
        hr = pIMediaSample2 -> GetProperties (
                sizeof SampleProperties,
                reinterpret_cast <BYTE *> (& SampleProperties)
                ) ;
        if (SUCCEEDED (hr)) {
            m_dwFlags = SampleProperties.dwTypeSpecificFlags ;
        }

        pIMediaSample2 -> Release () ;
    }

    return hr ;
}

HRESULT
CDVRAnalysisFlags::Tag (
    IN  IMediaSample *  pIMediaSample,
    IN  BOOL            fOverwrite
    )
{
    HRESULT                 hr ;
    AM_SAMPLE2_PROPERTIES   SampleProperties ;
    IMediaSample2 *         pIMediaSample2 ;

    ASSERT (pIMediaSample) ;

    if (m_dwFlags != 0) {
        hr = pIMediaSample -> QueryInterface (
                IID_IMediaSample2,
                (void **) & pIMediaSample2
                ) ;

        if (SUCCEEDED (hr)) {
            hr = pIMediaSample2 -> GetProperties (
                    sizeof SampleProperties,
                    reinterpret_cast <BYTE *> (& SampleProperties)
                    ) ;
            if (SUCCEEDED (hr)) {
                if (fOverwrite) {
                    SampleProperties.dwTypeSpecificFlags = m_dwFlags ;
                }
                else {
                    SampleProperties.dwTypeSpecificFlags |= m_dwFlags ;
                }

                hr = pIMediaSample2 -> SetProperties (
                        sizeof SampleProperties,
                        reinterpret_cast <const BYTE *> (& SampleProperties)
                        ) ;
            }

            pIMediaSample2 -> Release () ;
        }
    }
    else {
        //  nothing to tag with
        hr = S_OK ;
    }

    return hr ;
}

//  ============================================================================
//  ============================================================================

HRESULT
CDVRMpeg2VideoAnalysisFlags::Mark (
    IN  REFGUID rguid
    )
{
    HRESULT hr ;

    if (rguid == DVRAnalysis_Mpeg2GOP) {
        FlagGOPHeader () ;
        hr = S_OK ;
    }
    else if (rguid == DVRAnalysis_Mpeg2_BFrame) {
        FlagBFrame () ;
        hr = S_OK ;
    }
    else if (rguid == DVRAnalysis_Mpeg2_PFrame) {
        FlagPFrame () ;
        hr = S_OK ;
    }
    else {
        hr = E_FAIL ;
    }

    return hr ;
}

BOOL
CDVRMpeg2VideoAnalysisFlags::IsMarked (
    IN  REFGUID rguid
    )
{
    BOOL    r ;

    if (rguid == DVRAnalysis_Mpeg2GOP) {
        r = IsGOPHeader () ;
    }
    else if (rguid == DVRAnalysis_Mpeg2_BFrame) {
        r = IsBFrame () ;
    }
    else if (rguid == DVRAnalysis_Mpeg2_PFrame) {
        r = IsPFrame () ;
    }
    else {
        r = FALSE ;
    }

    return r ;
}

//  ============================================================================
//  ============================================================================

CDVRThread::CDVRThread()
    : m_EventSend(TRUE)     // must be manual-reset for CheckRequest()
{
    m_hThread = NULL;
}

CDVRThread::~CDVRThread() {
    Close();
}


// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CDVRThread::InitialThreadProc(LPVOID pv)
{
    HRESULT hrCoInit = CDVRThread::CoInitializeHelper();
    if(FAILED(hrCoInit)) {
        DbgLog((LOG_ERROR, 1, TEXT("CoInitializeEx failed.")));
    }

    CDVRThread * pThread = (CDVRThread *) pv;

    HRESULT hr = pThread->ThreadProc();

    if(SUCCEEDED(hrCoInit)) {
        CoUninitialize();
    }

    return hr;
}

BOOL
CDVRThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
	return FALSE;
    }

    m_hThread = CreateThread(
		    NULL,
		    0,
		    CDVRThread::InitialThreadProc,
		    this,
		    0,
		    &threadid);

    if (!m_hThread) {
	return FALSE;
    }

    return TRUE;
}

DWORD
CDVRThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
	return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled
    m_EventComplete.Wait();

    // done - this is the thread's return value
    return m_dwReturnVal;
}

// Wait for a request from the client
DWORD
CDVRThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}

// is there a request?
BOOL
CDVRThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
	return FALSE;
    } else {
	if (pParam) {
	    *pParam = m_dwParam;
	}
	return TRUE;
    }
}

// reply to the request
void
CDVRThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CDVRThread::CoInitializeHelper()
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(0, COINIT_DISABLE_OLE1DDE );
        }
    }
    else
    {
        // caller must load ole32.dll
        DbgBreak("couldn't locate ole32.dll");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\util\dvrpolicy.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        dvrpolicy.cpp

    Abstract:

        This module contains the class implementation for stats.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        24-May-2001     created

--*/

#include "dvrall.h"

//  ============================================================================
//  ============================================================================

CTSDVRSettings::CTSDVRSettings (
    IN  HKEY    hkeyDefaultTopLevel,
    IN  TCHAR * pszDefaultDVRRoot,
    IN  TCHAR * pszInstanceRoot
    ) : m_hkeyDVRRoot       (NULL),
        m_hkeyInstanceRoot  (NULL)
{
    TRACE_CONSTRUCTOR (TEXT ("CTSDVRSettings")) ;

    InitializeCriticalSection (& m_crt) ;

    //  deliberately ignore the return value here -- we've got defaults for
    //   all calls into this object; we pay attention to return value if
    //   an external caller sets us up
    OpenRegKeys_ (
        hkeyDefaultTopLevel,
        pszDefaultDVRRoot,
        pszInstanceRoot
        ) ;

    //  BUGBUG: remove
    g_fRegGenericStreams_Video = REG_VID_USE_GENERIC_STREAMS_DEFAULT ;
    GetRegDWORDValIfExist (m_hkeyDVRRoot, REG_VID_USE_GENERIC_STREAMS_NAME, (DWORD *) & g_fRegGenericStreams_Video) ;

    //  BUGBUG: remove
    g_fRegGenericStreams_Audio = REG_AUD_USE_GENERIC_STREAMS_DEFAULT ;
    GetRegDWORDValIfExist (m_hkeyDVRRoot, REG_AUD_USE_GENERIC_STREAMS_NAME, (DWORD *) & g_fRegGenericStreams_Audio) ;

    return ;
}

CTSDVRSettings::~CTSDVRSettings (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CTSDVRSettings")) ;

    CloseRegKeys_ () ;

    DeleteCriticalSection (& m_crt) ;
}

void
CTSDVRSettings::CloseRegKeys_ (
    )
{
    Lock_ () ;

    if (m_hkeyDVRRoot) {
        RegCloseKey (m_hkeyDVRRoot) ;
        m_hkeyDVRRoot = NULL ;
    }

    if (m_hkeyInstanceRoot) {
        RegCloseKey (m_hkeyInstanceRoot) ;
        m_hkeyInstanceRoot = NULL ;
    }

    Unlock_ () ;
}

HRESULT
CTSDVRSettings::OpenRegKeys_ (
    IN  HKEY    hkeyDefaultTopLevel,
    IN  TCHAR * pszDefaultDVRRoot,
    IN  TCHAR * pszInstanceRoot
    )
{
    LONG    l ;
    DWORD   dwDisposition ;

    Lock_ () ;

    CloseRegKeys_ () ;

    l = RegCreateKeyEx (
            hkeyDefaultTopLevel,
            pszDefaultDVRRoot,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & m_hkeyDVRRoot,
            & dwDisposition
            ) ;
    if (l != ERROR_SUCCESS) { goto cleanup ; }

    l = RegCreateKeyEx (
            m_hkeyDVRRoot,
            pszInstanceRoot,
            NULL,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_READ | KEY_WRITE),
            NULL,
            & m_hkeyInstanceRoot,
            & dwDisposition
            ) ;
    if (l != ERROR_SUCCESS) { goto cleanup ; }

    cleanup :

    if (l != ERROR_SUCCESS) {
        CloseRegKeys_ () ;
    }

    Unlock_ () ;

    return (HRESULT_FROM_WIN32 (l)) ;
}

DWORD
CTSDVRSettings::GetVal_ (
    IN  HKEY    hkeyRoot,
    IN  TCHAR * szValName,
    IN  DWORD   dwDefVal
    )
{
    DWORD dwRet ;

    dwRet = dwDefVal ;

    Lock_ () ;

    if (m_hkeyDVRRoot) {
        GetRegDWORDValIfExist (hkeyRoot, szValName, & dwRet) ;
    }

    Unlock_ () ;

    return dwRet ;
}

BOOL
CTSDVRSettings::GetFlag_ (
    IN  HKEY    hkeyRoot,
    IN  TCHAR * szValName,
    IN  BOOL    fDef
    )
{
    DWORD dwVal ;

    dwVal = (fDef ? TRUE : FALSE) ;

    Lock_ () ;

    if (m_hkeyDVRRoot) {
        GetRegDWORDValIfExist (hkeyRoot, szValName, & dwVal) ;
    }

    Unlock_ () ;

    return (dwVal ? TRUE : FALSE) ;
}

DWORD
CTSDVRSettings::EnableStats (
    IN  BOOL    f
    )
{
    BOOL    r ;

    Lock_ () ;

    if (m_hkeyDVRRoot) {
        r = SetRegDWORDVal (m_hkeyDVRRoot, REG_DVR_STATS_NAME, (f ? DVR_STATS_ENABLED : DVR_STATS_DISABLED)) ;
    }
    else {
        r = FALSE ;
    }

    Unlock_ () ;

    return (r ? NOERROR : ERROR_GEN_FAILURE) ;
}

//  ============================================================================

CDVRPolicy::CDVRPolicy (
    IN  TCHAR *     pszInstRegRoot,
    OUT HRESULT *   phr
    ) : m_lRef          (1),
        m_RegSettings   (HKEY_CURRENT_USER, REG_DVR_ROOT, pszInstRegRoot)
{
    (* phr) = S_OK ;

    return ;
}

CDVRPolicy::~CDVRPolicy (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CDVRPolicy")) ;
}

ULONG
CDVRPolicy::Release (
    )
{
    if (InterlockedDecrement (& m_lRef) == 0) {
        delete this ;
        return 0 ;
    }

    return m_lRef ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\des.h ===
//-----------------------------------------------------------------------------
//
// File:   des.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1999-2001. All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __DES_H__
#define __DES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,unsigned char *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(BYTE *pbOut, BYTE *pbIn, void *key, int op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(BYTE *pbKey, DWORD cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(BYTE *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(BYTE *pbKey, BYTE *pbExpanded_key);


void
RSA32API
desexpand128to192(
    BYTE *pbKey,        // input 128bit or 192bit buffer
    BYTE *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, BYTE *key);

void RSA32API desx(BYTE *pbOut, BYTE *pbIn, void *keyin, int op);


extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\asferr.h ===
///////////////////////////////////////////////////////////////////////////
//
// ASFErr.h - definition of ASF HRESULT codes
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
// This file is generated by the MC tool from ASFErr.mc
//

#ifndef _ASFERR_H
#define _ASFERR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Errors (2000 - 2999)
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ASF_E_BUFFEROVERRUN
//
// MessageText:
//
//  An attempt was made to seek or position past the end of a buffer.%0
//
#define ASF_E_BUFFEROVERRUN              0xC00D07D0L

//
// MessageId: ASF_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The supplied input or output buffer was too small.%0
//
#define ASF_E_BUFFERTOOSMALL             0xC00D07D1L

//
// MessageId: ASF_E_BADLANGUAGEID
//
// MessageText:
//
//  The language ID was not found.%0
//
#define ASF_E_BADLANGUAGEID              0xC00D07D2L

//
// MessageId: ASF_E_NOPAYLOADLENGTH
//
// MessageText:
//
//  The multiple payload packet is missing the payload length.%0
//
#define ASF_E_NOPAYLOADLENGTH            0xC00D07DBL

//
// MessageId: ASF_E_TOOMANYPAYLOADS
//
// MessageText:
//
//  The packet contains too many payloads.%0
//
#define ASF_E_TOOMANYPAYLOADS            0xC00D07DCL

//
// MessageId: ASF_E_PACKETCONTENTTOOLARGE
//
// MessageText:
//
//  ASF_E_PACKETCONTENTTOOLARGE
//
#define ASF_E_PACKETCONTENTTOOLARGE      0xC00D07DEL

//
// MessageId: ASF_E_UNKNOWNPACKETSIZE
//
// MessageText:
//
//  Expecting a fixed packet size but min. and max. are not equal.%0
//
#define ASF_E_UNKNOWNPACKETSIZE          0xC00D07E0L

//
// MessageId: ASF_E_INVALIDHEADER
//
// MessageText:
//
//  ASF_E_INVALIDHEADER
//
#define ASF_E_INVALIDHEADER              0xC00D07E2L

//
// MessageId: ASF_E_NOCLOCKOBJECT
//
// MessageText:
//
//  The object does not have a valid clock object.%0
//
#define ASF_E_NOCLOCKOBJECT              0xC00D07E6L

//
// MessageId: ASF_E_UNKNOWNCLOCKTYPE
//
// MessageText:
//
//  ASF_E_UNKNOWNCLOCKTYPE
//
#define ASF_E_UNKNOWNCLOCKTYPE           0xC00D07EBL

//
// MessageId: ASF_E_OPAQUEPACKET
//
// MessageText:
//
//  An attempt was made to restore or access an opaque packet.%0
//
#define ASF_E_OPAQUEPACKET               0xC00D07EDL

//
// MessageId: ASF_E_WRONGVERSION
//
// MessageText:
//
//  ASF_E_WRONGVERSION
//
#define ASF_E_WRONGVERSION               0xC00D07EEL

//
// MessageId: ASF_E_OVERFLOW
//
// MessageText:
//
//  An attempt was made to store a value which was larger than then destination's maximum value.%0
//
#define ASF_E_OVERFLOW                   0xC00D07EFL

//
// MessageId: ASF_E_NOTFOUND
//
// MessageText:
//
//  The object was not found.%0
//
#define ASF_E_NOTFOUND                   0xC00D07F0L

//
// Someone else is using MessageIds 2033 & 2034, so we skip them
// 
// 2033 = NS_E_NOTHING_TO_DO
// 2034 = NS_E_NO_MULTICAST

//
// MessageId: ASF_E_OBJECTTOOBIG
//
// MessageText:
//
//  The object is too large to be processed in the requested manner.%0
//
#define ASF_E_OBJECTTOOBIG               0xC00D07F3L

//
// MessageId: ASF_E_UNEXPECTEDVALUE
//
// MessageText:
//
//  A value was not set as expected.%0
//
#define ASF_E_UNEXPECTEDVALUE            0xC00D07F4L

//
// MessageId: ASF_E_INVALIDSTATE
//
// MessageText:
//
//  The request is not valid in the object's current state.%0
//
#define ASF_E_INVALIDSTATE               0xC00D07F5L

//
// MessageId: ASF_E_NOLIBRARY
//
// MessageText:
//
//  This object does not have a valid library pointer; it was not properly created or it has been Shutdown().%0
//
#define ASF_E_NOLIBRARY                  0xC00D07F6L

//
// MessageId: ASF_E_ALREADYINITIALIZED
//
// MessageText:
//
//  This object has already been initialized; the setting cannot be changed.%0
//
#define ASF_E_ALREADYINITIALIZED         0xC00D07F7L

//
// MessageId: ASF_E_INVALIDINIT
//
// MessageText:
//
//  This object has not been initialized properly; that operation cannot be performed.%0
//
#define ASF_E_INVALIDINIT                0xC00D07F8L

//
// MessageId: ASF_E_NOHEADEROBJECT
//
// MessageText:
//
//  The ASF Header object could not be found.%0
//
#define ASF_E_NOHEADEROBJECT             0xC00D07F9L

//
// MessageId: ASF_E_NODATAOBJECT
//
// MessageText:
//
//  The ASF Data object could not be found.%0
//
#define ASF_E_NODATAOBJECT               0xC00D07FAL

//
// MessageId: ASF_E_NOINDEXOBJECT
//
// MessageText:
//
//  The ASF Index object could not be found.%0
//
#define ASF_E_NOINDEXOBJECT              0xC00D07FBL

//
// MessageId: ASF_E_NOSTREAMPROPS
//
// MessageText:
//
//  A Stream Properties object with the correct stream number could not be found.%0
//
#define ASF_E_NOSTREAMPROPS              0xC00D07FCL

//
// MessageId: ASF_E_NOFILEPROPS
//
// MessageText:
//
//  The File Properties object could not be found.%0
//
#define ASF_E_NOFILEPROPS                0xC00D07FDL

//
// MessageId: ASF_E_NOLANGUAGELIST
//
// MessageText:
//
//  The Language List object could not be found.%0
//
#define ASF_E_NOLANGUAGELIST             0xC00D07FEL

//
// MessageId: ASF_E_NOINDEXPARAMETERS
//
// MessageText:
//
//  The Index Parameters object could not be found.%0
//
#define ASF_E_NOINDEXPARAMETERS          0xC00D07FFL

//
// MessageId: ASF_E_UNSUPPORTEDERRORCONCEALMENT
//
// MessageText:
//
//  The requested error concealment strategy is not supported by this component.%0
//
#define ASF_E_UNSUPPORTEDERRORCONCEALMENT 0xC00D0800L

//
// MessageId: ASF_E_INVALIDFLAGS
//
// MessageText:
//
//  The flags for this object or set of objects are not properly set.%0
//
#define ASF_E_INVALIDFLAGS               0xC00D0801L

//
// MessageId: ASF_E_BADDATADESCRIPTOR
//
// MessageText:
//
//  One or more data descriptors is not properly set.%0
//
#define ASF_E_BADDATADESCRIPTOR          0xC00D0802L

//
// MessageId: ASF_E_BADINDEXINTERVAL
//
// MessageText:
//
//  The index has an invalid time interval (probably zero).%0
//
#define ASF_E_BADINDEXINTERVAL           0xC00D0803L

//
// MessageId: ASF_E_INVALIDTIME
//
// MessageText:
//
//  The given time value is not valid.%0
//
#define ASF_E_INVALIDTIME                0xC00D0804L

//
// MessageId: ASF_E_INVALIDINDEX
//
// MessageText:
//
//  The given index value is not valid.%0
//
#define ASF_E_INVALIDINDEX               0xC00D0805L

//
// MessageId: ASF_E_STREAMNUMBERINUSE
//
// MessageText:
//
//  The specified stream number is already in use.%0
//
#define ASF_E_STREAMNUMBERINUSE          0xC00D0806L

//
// MessageId: ASF_E_BADMEDIATYPE
//
// MessageText:
//
//  The specified media type does not work with this component.%0
//
#define ASF_E_BADMEDIATYPE               0xC00D0807L

//
// MessageId: ASF_E_WRITEFAILED
//
// MessageText:
//
//  The object could not be written as specified.%0
//
#define ASF_E_WRITEFAILED                0xC00D0808L

//
// MessageId: ASF_E_NOTENOUGHDESCRIPTORS
//
// MessageText:
//
//  The given data unit requires a larger number of descriptors to be fully parsed.%0
//
#define ASF_E_NOTENOUGHDESCRIPTORS       0xC00D0809L

//
// MessageId: ASF_E_INDEXBLOCKUNLOADED
//
// MessageText:
//
//  The index entries for the specified index block have been unloaded from memory and are not available.%0
//
#define ASF_E_INDEXBLOCKUNLOADED         0xC00D080AL

//
// MessageId: ASF_E_NOTENOUGHBANDWIDTH
//
// MessageText:
//
//  The specified bandwidth is not large enough.%0
//
#define ASF_E_NOTENOUGHBANDWIDTH         0xC00D080BL

//
// MessageId: ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE
//
// MessageText:
//
//  The object has exceeded its maximum size.%0
//
#define ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE  0xC00D080CL

//
// MessageId: ASF_E_BADDATAUNIT
//
// MessageText:
//
//  The given data unit is corrupted, badly formatted, or otherwise not valid.%0
//
#define ASF_E_BADDATAUNIT                0xC00D080DL

//
// MessageId: ASF_E_HEADERSIZE
//
// MessageText:
//
//  The ASF header has exceeded the specified maximum size.%0
//
#define ASF_E_HEADERSIZE                 0xC00D080EL


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Success Codes (2000 - 2999)
//

//
// MessageId: ASF_S_OPAQUEPACKET
//
// MessageText:
//
//  ASF_S_OPAQUEPACKET
//
#define ASF_S_OPAQUEPACKET               0x000D07F0L


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Warnings (2000 - 2999)
//


#endif // _ASFERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\key.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

#include <wtypes.h>

extern BYTE abPVK[];
extern BYTE abCert[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\util\dvrstats.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        dvrstats.cpp

    Abstract:

        This module contains the class implementation for stats.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        19-Feb-2001     created

--*/

#include "dvrall.h"
#include "dvranalysis.h"
#include "dvrutil.h"
#include "dvrstats.h"

CWin32SharedMem::CWin32SharedMem (
    IN  TCHAR *     szName,
    IN  DWORD       dwSize,
    OUT HRESULT *   phr
    ) : m_pbShared  (NULL),
        m_dwSize    (0),
        m_hMapping  (NULL)
{
    TRACE_CONSTRUCTOR (TEXT ("CWin32SharedMem")) ;

    (* phr) = Create_ (szName, dwSize) ;
}

CWin32SharedMem::~CWin32SharedMem (
    )
{
    TRACE_DESTRUCTOR (TEXT ("CWin32SharedMem")) ;
    Free_ () ;
}

HRESULT
CWin32SharedMem::Create_ (
    IN  TCHAR * pszName,
    IN  DWORD   dwSize
    )
{
    HRESULT hr ;
    DWORD   dw ;

    Free_ () ;

    ASSERT (m_hMapping  == NULL) ;
    ASSERT (m_dwSize    == 0) ;
    ASSERT (m_pbShared  == NULL) ;
    ASSERT (dwSize      > 0) ;

    m_dwSize = dwSize ;

    hr = S_OK ;

    m_hMapping = CreateFileMapping (
                            INVALID_HANDLE_VALUE,
                            NULL,
                            PAGE_READWRITE,
                            0,
                            m_dwSize,
                            pszName
                            ) ;

    if (m_hMapping == NULL) {
        dw = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    m_pbShared = reinterpret_cast <BYTE *>
                    (MapViewOfFile (
                                m_hMapping,
                                FILE_MAP_READ | FILE_MAP_WRITE,
                                0,
                                0,
                                0
                                )) ;
    if (m_pbShared == NULL) {
        dw = GetLastError () ;
        hr = HRESULT_FROM_WIN32 (dw) ;
        goto cleanup ;
    }

    cleanup :

    if (FAILED (hr)) {
        Free_ () ;
    }

    return hr ;
}

void
CWin32SharedMem::Free_ (
    )
{
    if (m_pbShared != NULL) {
        ASSERT (m_hMapping != NULL) ;
        UnmapViewOfFile (m_pbShared) ;
    }

    if (m_hMapping != NULL) {
        CloseHandle (m_hMapping) ;
    }

    m_hMapping  = NULL ;
    m_pbShared  = NULL ;
    m_dwSize    = 0 ;
}

//  ============================================================================
//  ============================================================================

CMpeg2VideoStreamStatsReader::CMpeg2VideoStreamStatsReader (
    IN  IUnknown *  pIUnknown,
    OUT HRESULT *   phr
    ) : CUnknown    (TEXT ("CMpeg2VideoStreamStatsReader"),
                     pIUnknown
                     ),
        m_pPolicy   (NULL)
{
    m_pPolicy = new CDVRPolicy (REG_DVR_ANALYSIS_LOGIC_MPEG2_VIDEO, phr) ;
    if (!m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = (m_pPolicy ? (* phr) : E_OUTOFMEMORY) ;
        RELEASE_AND_CLEAR (m_pPolicy) ;
        goto cleanup ;
    }

    (* phr) = Initialize (TRUE) ;
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    cleanup :

    return ;
}

CMpeg2VideoStreamStatsReader::~CMpeg2VideoStreamStatsReader (
    )
{
    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRMpeg2VideoStreamStats) {

        ASSERT (m_pMpeg2VideoStreamStats) ;
        return GetInterface (
                    (IDVRMpeg2VideoStreamStats *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

//  class factory
CUnknown *
WINAPI
CMpeg2VideoStreamStatsReader::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   phr
    )
{
    CMpeg2VideoStreamStatsReader *  pMpeg2Video ;

    pMpeg2Video = new CMpeg2VideoStreamStatsReader (
                        pIUnknown,
                        phr
                        ) ;

    if (!pMpeg2Video ||
        FAILED (* phr)) {

        DELETE_RESET (pMpeg2Video) ;
    }

    return pMpeg2Video ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::GetFrameCounts (
    OUT ULONGLONG * pull_I_Frames,
    OUT ULONGLONG * pull_P_Frames,
    OUT ULONGLONG * pull_B_Frames
    )
{
    if (!pull_I_Frames  ||
        !pull_P_Frames  ||
        !pull_B_Frames) {

        return E_POINTER ;
    }

    ASSERT (m_pMpeg2VideoStreamStats) ;

    (* pull_I_Frames)   = m_pMpeg2VideoStreamStats -> ullIFrameCount ;
    (* pull_P_Frames)   = m_pMpeg2VideoStreamStats -> ullPFrameCount ;
    (* pull_B_Frames)   = m_pMpeg2VideoStreamStats -> ullBFrameCount ;

    return S_OK ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::GetGOPHeaderCount (
    OUT ULONGLONG * pull_GOHeaders
    )
{
    if (!pull_GOHeaders) {
        return E_POINTER ;
    }

    ASSERT (m_pMpeg2VideoStreamStats) ;

    (* pull_GOHeaders)  = m_pMpeg2VideoStreamStats -> ullGOPHeaderCount ;

    return S_OK ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::Enable (
    IN OUT  BOOL *  pfEnable
    )
{
    BOOL    fCurrent ;
    BOOL    r ;
    DWORD   dw ;

    if (!pfEnable) {
        return E_POINTER ;
    }

    ASSERT (m_pPolicy) ;

    fCurrent = m_pPolicy -> Settings () -> StatsEnabled () ;
    if (fCurrent != (* pfEnable)) {
        dw = m_pPolicy -> Settings () -> EnableStats (* pfEnable) ;
        r = (dw == NOERROR ? TRUE : FALSE) ;
    }
    else {
        r = TRUE ;
    }

    (* pfEnable) = fCurrent ;

    return (r ? S_OK : E_FAIL) ;
}

STDMETHODIMP
CMpeg2VideoStreamStatsReader::Reset (
    )
{
    return Clear () ;
}

//  ============================================================================
//  ============================================================================

CDVRReceiveStatsReader::CDVRReceiveStatsReader (
    IN  IUnknown *  pIUnknown,
    OUT HRESULT *   phr
    ) : CUnknown    (TEXT ("CDVRReceiveStatsReader"),
                     pIUnknown
                     ),
        m_pPolicy   (NULL)
{
    m_pPolicy = new CDVRPolicy (REG_DVR_STREAM_SINK_ROOT, phr) ;
    if (!m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = (m_pPolicy ? (* phr) : E_OUTOFMEMORY) ;
        RELEASE_AND_CLEAR (m_pPolicy) ;
        goto cleanup ;
    }

    (* phr) = Initialize (TRUE) ;
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    ASSERT (m_pDVRReceiveStats) ;

    cleanup :

    return ;
}

CDVRReceiveStatsReader::~CDVRReceiveStatsReader (
    )
{
    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CDVRReceiveStatsReader::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRReceiverStats) {

        ASSERT (m_pDVRReceiveStats) ;
        return GetInterface (
                    (IDVRReceiverStats *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

//  class factory
CUnknown *
WINAPI
CDVRReceiveStatsReader::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   phr
    )
{
    CDVRReceiveStatsReader *  pDVRReceiveStatsReader ;

    pDVRReceiveStatsReader = new CDVRReceiveStatsReader (
                        pIUnknown,
                        phr
                        ) ;

    if (!pDVRReceiveStatsReader ||
        FAILED (* phr)) {

        DELETE_RESET (pDVRReceiveStatsReader) ;
    }

    return pDVRReceiveStatsReader ;
}

HRESULT
CDVRReceiveStatsReader::GetStatsMaxStreams (
    OUT int *   piMaxStreams
    )
{
    if (!piMaxStreams) {
        return E_POINTER ;
    }

    (* piMaxStreams) = TSDVR_RECEIVE_MAX_STREAM_STATS ;
    return S_OK ;
}

HRESULT
CDVRReceiveStatsReader::GetStreamStats (
    IN  int                 iStreamIndex,   //  0-based
    OUT ULONGLONG *         pullMediaSamplesIn,
    OUT ULONGLONG *         pullTotalBytes,
    OUT ULONGLONG *         pullDiscontinuities,
    OUT ULONGLONG *         pullSyncPoints,
    OUT REFERENCE_TIME *    prtLast,
    OUT ULONGLONG *         pullWriteFailures
    )
{
    if (iStreamIndex < 0 &&
        iStreamIndex >= TSDVR_RECEIVE_MAX_STREAM_STATS) {

        return E_INVALIDARG ;
    }

    if (!pullMediaSamplesIn     ||
        !pullTotalBytes         ||
        !pullDiscontinuities    ||
        !pullSyncPoints         ||
        !prtLast                ||
        !pullWriteFailures) {

        return E_POINTER ;
    }

    ASSERT (m_pDVRReceiveStats) ;

    (* pullMediaSamplesIn)  = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullMediaSamplesIn ;
    (* pullTotalBytes)      = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullTotalBytes ;
    (* pullDiscontinuities) = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullDiscontinuities ;
    (* pullSyncPoints)      = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullSyncPoints ;
    (* prtLast)             = m_pDVRReceiveStats -> StreamStats [iStreamIndex].rtLast ;
    (* pullWriteFailures)   = m_pDVRReceiveStats -> StreamStats [iStreamIndex].ullWriteFailures ;

    return S_OK ;
}

STDMETHODIMP
CDVRReceiveStatsReader::Enable (
    IN OUT  BOOL *  pfEnable
    )
{
    BOOL    fCurrent ;
    BOOL    r ;
    DWORD   dw ;

    if (!pfEnable) {
        return E_POINTER ;
    }

    ASSERT (m_pPolicy) ;

    fCurrent = m_pPolicy -> Settings () -> StatsEnabled () ;
    if (fCurrent != (* pfEnable)) {
        dw = m_pPolicy -> Settings () -> EnableStats (* pfEnable) ;
        r = (dw == NOERROR ? TRUE : FALSE) ;
    }
    else {
        r = TRUE ;
    }

    (* pfEnable) = fCurrent ;

    return (r ? S_OK : E_FAIL) ;
}

STDMETHODIMP
CDVRReceiveStatsReader::Reset (
    )
{
    return Clear () ;
}

//  ============================================================================
//  ============================================================================

CDVRSendStatsReader::CDVRSendStatsReader (
    IN  IUnknown *  pIUnknown,
    OUT HRESULT *   phr
    ) : CUnknown    (TEXT ("CDVRSendStatsReader"),
                     pIUnknown
                     ),
        m_pPolicy   (NULL)
{
    m_pPolicy = new CDVRPolicy (REG_DVR_STREAM_SOURCE_ROOT, phr) ;
    if (!m_pPolicy ||
        FAILED (* phr)) {

        (* phr) = (m_pPolicy ? (* phr) : E_OUTOFMEMORY) ;
        RELEASE_AND_CLEAR (m_pPolicy) ;
        goto cleanup ;
    }

    (* phr) = Initialize (TRUE) ;
    if (FAILED (* phr)) {
        goto cleanup ;
    }

    ASSERT (m_pDVRSenderStats) ;

    cleanup :

    return ;
}

CDVRSendStatsReader::~CDVRSendStatsReader (
    )
{
    RELEASE_AND_CLEAR (m_pPolicy) ;
}

STDMETHODIMP
CDVRSendStatsReader::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    if (riid == IID_IDVRSenderStats) {

        ASSERT (m_pDVRSenderStats) ;
        return GetInterface (
                    (IDVRSenderStats *) this,
                    ppv
                    ) ;
    }

    return CUnknown::NonDelegatingQueryInterface (riid, ppv) ;
}

//  class factory
CUnknown *
WINAPI
CDVRSendStatsReader::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   phr
    )
{
    CDVRSendStatsReader *  pDVRSendStatsReader ;

    pDVRSendStatsReader = new CDVRSendStatsReader (
                        pIUnknown,
                        phr
                        ) ;

    if (!pDVRSendStatsReader ||
        FAILED (* phr)) {

        DELETE_RESET (pDVRSendStatsReader) ;
    }

    return pDVRSendStatsReader ;
}

HRESULT
CDVRSendStatsReader::GetStatsMaxStreams (
    OUT int *   piMaxStreams
    )
{
    if (!piMaxStreams) {
        return E_POINTER ;
    }

    (* piMaxStreams) = TSDVR_SEND_MAX_STREAM_STATS ;
    return S_OK ;
}

HRESULT
CDVRSendStatsReader::GetStreamStats (
    IN  int                 iStreamIndex,   //  0-based
    OUT ULONGLONG *         pullMediaSamplesIn,
    OUT ULONGLONG *         pullTotalBytes,
    OUT ULONGLONG *         pullDiscontinuities,
    OUT ULONGLONG *         pullSyncPoints,
    OUT REFERENCE_TIME *    prtLastNormalized,
    OUT REFERENCE_TIME *    prtRefClockOnLastPTS,
    OUT LONG *              plMediaSamplesOutstanding,
    OUT LONG *              plMediaSamplePoolSize
    )
{
    if (iStreamIndex < 0 &&
        iStreamIndex >= TSDVR_SEND_MAX_STREAM_STATS) {

        return E_INVALIDARG ;
    }

    if (!pullMediaSamplesIn         ||
        !pullTotalBytes             ||
        !pullDiscontinuities        ||
        !pullSyncPoints             ||
        !prtLastNormalized          ||
        !prtRefClockOnLastPTS       ||
        !plMediaSamplesOutstanding  ||
        !plMediaSamplePoolSize) {

        return E_POINTER ;
    }

    ASSERT (m_pDVRSenderStats) ;

    (* pullMediaSamplesIn)          = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullMediaSamplesIn ;
    (* pullTotalBytes)              = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullTotalBytes ;
    (* pullDiscontinuities)         = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullDiscontinuities ;
    (* pullSyncPoints)              = m_pDVRSenderStats -> StreamStats [iStreamIndex].ullSyncPoints ;
    (* prtLastNormalized)           = m_pDVRSenderStats -> StreamStats [iStreamIndex].rtLastNormalized ;
    (* prtRefClockOnLastPTS)        = m_pDVRSenderStats -> StreamStats [iStreamIndex].rtRefClockOnLastPTS ;
    (* plMediaSamplesOutstanding)   = m_pDVRSenderStats -> StreamStats [iStreamIndex].lMediaSamplesOutstanding ;
    (* plMediaSamplePoolSize)       = m_pDVRSenderStats -> StreamStats [iStreamIndex].lPoolSize ;

    return S_OK ;
}

HRESULT
CDVRSendStatsReader::GetGlobalStats (
    OUT REFERENCE_TIME *    prtNormalizer,
    OUT REFERENCE_TIME *    prtRefClockTimeStart,
    OUT ULONGLONG *         pullReadFailures

    )
{
    if (!prtNormalizer          ||
        !prtRefClockTimeStart   ||
        !pullReadFailures) {

        return E_POINTER ;
    }

    (* prtNormalizer)           = m_pDVRSenderStats -> rtNormalizer ;
    (* prtRefClockTimeStart)    = m_pDVRSenderStats -> rtRefClockStart ;
    (* pullReadFailures)        = m_pDVRSenderStats -> ullReadFailures ;

    return S_OK ;
}

STDMETHODIMP
CDVRSendStatsReader::Enable (
    IN OUT  BOOL *  pfEnable
    )
{
    BOOL    fCurrent ;
    BOOL    r ;
    DWORD   dw ;

    if (!pfEnable) {
        return E_POINTER ;
    }

    ASSERT (m_pPolicy) ;

    fCurrent = m_pPolicy -> Settings () -> StatsEnabled () ;
    if (fCurrent != (* pfEnable)) {
        dw = m_pPolicy -> Settings () -> EnableStats (* pfEnable) ;
        r = (dw == NOERROR ? TRUE : FALSE) ;
    }
    else {
        r = TRUE ;
    }

    (* pfEnable) = fCurrent ;

    return (r ? S_OK : E_FAIL) ;
}

STDMETHODIMP
CDVRSendStatsReader::Reset (
    )
{
    return Clear () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\mswmdm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun Mar 18 02:44:26 2001
 */
/* Compiler settings for .\mswmdm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mswmdm_h__
#define __mswmdm_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMDeviceManager_FWD_DEFINED__
#define __IWMDeviceManager_FWD_DEFINED__
typedef interface IWMDeviceManager IWMDeviceManager;
#endif 	/* __IWMDeviceManager_FWD_DEFINED__ */


#ifndef __IWMDeviceManager2_FWD_DEFINED__
#define __IWMDeviceManager2_FWD_DEFINED__
typedef interface IWMDeviceManager2 IWMDeviceManager2;
#endif 	/* __IWMDeviceManager2_FWD_DEFINED__ */


#ifndef __IWMDMStorageGlobals_FWD_DEFINED__
#define __IWMDMStorageGlobals_FWD_DEFINED__
typedef interface IWMDMStorageGlobals IWMDMStorageGlobals;
#endif 	/* __IWMDMStorageGlobals_FWD_DEFINED__ */


#ifndef __IWMDMStorage_FWD_DEFINED__
#define __IWMDMStorage_FWD_DEFINED__
typedef interface IWMDMStorage IWMDMStorage;
#endif 	/* __IWMDMStorage_FWD_DEFINED__ */


#ifndef __IWMDMStorage2_FWD_DEFINED__
#define __IWMDMStorage2_FWD_DEFINED__
typedef interface IWMDMStorage2 IWMDMStorage2;
#endif 	/* __IWMDMStorage2_FWD_DEFINED__ */


#ifndef __IWMDMOperation_FWD_DEFINED__
#define __IWMDMOperation_FWD_DEFINED__
typedef interface IWMDMOperation IWMDMOperation;
#endif 	/* __IWMDMOperation_FWD_DEFINED__ */


#ifndef __IWMDMOperation2_FWD_DEFINED__
#define __IWMDMOperation2_FWD_DEFINED__
typedef interface IWMDMOperation2 IWMDMOperation2;
#endif 	/* __IWMDMOperation2_FWD_DEFINED__ */


#ifndef __IWMDMProgress_FWD_DEFINED__
#define __IWMDMProgress_FWD_DEFINED__
typedef interface IWMDMProgress IWMDMProgress;
#endif 	/* __IWMDMProgress_FWD_DEFINED__ */


#ifndef __IWMDMProgress2_FWD_DEFINED__
#define __IWMDMProgress2_FWD_DEFINED__
typedef interface IWMDMProgress2 IWMDMProgress2;
#endif 	/* __IWMDMProgress2_FWD_DEFINED__ */


#ifndef __IWMDMDevice_FWD_DEFINED__
#define __IWMDMDevice_FWD_DEFINED__
typedef interface IWMDMDevice IWMDMDevice;
#endif 	/* __IWMDMDevice_FWD_DEFINED__ */


#ifndef __IWMDMDevice2_FWD_DEFINED__
#define __IWMDMDevice2_FWD_DEFINED__
typedef interface IWMDMDevice2 IWMDMDevice2;
#endif 	/* __IWMDMDevice2_FWD_DEFINED__ */


#ifndef __IWMDMEnumDevice_FWD_DEFINED__
#define __IWMDMEnumDevice_FWD_DEFINED__
typedef interface IWMDMEnumDevice IWMDMEnumDevice;
#endif 	/* __IWMDMEnumDevice_FWD_DEFINED__ */


#ifndef __IWMDMDeviceControl_FWD_DEFINED__
#define __IWMDMDeviceControl_FWD_DEFINED__
typedef interface IWMDMDeviceControl IWMDMDeviceControl;
#endif 	/* __IWMDMDeviceControl_FWD_DEFINED__ */


#ifndef __IWMDMEnumStorage_FWD_DEFINED__
#define __IWMDMEnumStorage_FWD_DEFINED__
typedef interface IWMDMEnumStorage IWMDMEnumStorage;
#endif 	/* __IWMDMEnumStorage_FWD_DEFINED__ */


#ifndef __IWMDMStorageControl_FWD_DEFINED__
#define __IWMDMStorageControl_FWD_DEFINED__
typedef interface IWMDMStorageControl IWMDMStorageControl;
#endif 	/* __IWMDMStorageControl_FWD_DEFINED__ */


#ifndef __IWMDMStorageControl2_FWD_DEFINED__
#define __IWMDMStorageControl2_FWD_DEFINED__
typedef interface IWMDMStorageControl2 IWMDMStorageControl2;
#endif 	/* __IWMDMStorageControl2_FWD_DEFINED__ */


#ifndef __IWMDMObjectInfo_FWD_DEFINED__
#define __IWMDMObjectInfo_FWD_DEFINED__
typedef interface IWMDMObjectInfo IWMDMObjectInfo;
#endif 	/* __IWMDMObjectInfo_FWD_DEFINED__ */


#ifndef __IWMDMRevoked_FWD_DEFINED__
#define __IWMDMRevoked_FWD_DEFINED__
typedef interface IWMDMRevoked IWMDMRevoked;
#endif 	/* __IWMDMRevoked_FWD_DEFINED__ */


#ifndef __IMDServiceProvider_FWD_DEFINED__
#define __IMDServiceProvider_FWD_DEFINED__
typedef interface IMDServiceProvider IMDServiceProvider;
#endif 	/* __IMDServiceProvider_FWD_DEFINED__ */


#ifndef __IMDServiceProvider2_FWD_DEFINED__
#define __IMDServiceProvider2_FWD_DEFINED__
typedef interface IMDServiceProvider2 IMDServiceProvider2;
#endif 	/* __IMDServiceProvider2_FWD_DEFINED__ */


#ifndef __IMDSPEnumDevice_FWD_DEFINED__
#define __IMDSPEnumDevice_FWD_DEFINED__
typedef interface IMDSPEnumDevice IMDSPEnumDevice;
#endif 	/* __IMDSPEnumDevice_FWD_DEFINED__ */


#ifndef __IMDSPDevice_FWD_DEFINED__
#define __IMDSPDevice_FWD_DEFINED__
typedef interface IMDSPDevice IMDSPDevice;
#endif 	/* __IMDSPDevice_FWD_DEFINED__ */


#ifndef __IMDSPDevice2_FWD_DEFINED__
#define __IMDSPDevice2_FWD_DEFINED__
typedef interface IMDSPDevice2 IMDSPDevice2;
#endif 	/* __IMDSPDevice2_FWD_DEFINED__ */


#ifndef __IMDSPDeviceControl_FWD_DEFINED__
#define __IMDSPDeviceControl_FWD_DEFINED__
typedef interface IMDSPDeviceControl IMDSPDeviceControl;
#endif 	/* __IMDSPDeviceControl_FWD_DEFINED__ */


#ifndef __IMDSPEnumStorage_FWD_DEFINED__
#define __IMDSPEnumStorage_FWD_DEFINED__
typedef interface IMDSPEnumStorage IMDSPEnumStorage;
#endif 	/* __IMDSPEnumStorage_FWD_DEFINED__ */


#ifndef __IMDSPStorage_FWD_DEFINED__
#define __IMDSPStorage_FWD_DEFINED__
typedef interface IMDSPStorage IMDSPStorage;
#endif 	/* __IMDSPStorage_FWD_DEFINED__ */


#ifndef __IMDSPStorage2_FWD_DEFINED__
#define __IMDSPStorage2_FWD_DEFINED__
typedef interface IMDSPStorage2 IMDSPStorage2;
#endif 	/* __IMDSPStorage2_FWD_DEFINED__ */


#ifndef __IMDSPStorageGlobals_FWD_DEFINED__
#define __IMDSPStorageGlobals_FWD_DEFINED__
typedef interface IMDSPStorageGlobals IMDSPStorageGlobals;
#endif 	/* __IMDSPStorageGlobals_FWD_DEFINED__ */


#ifndef __IMDSPObjectInfo_FWD_DEFINED__
#define __IMDSPObjectInfo_FWD_DEFINED__
typedef interface IMDSPObjectInfo IMDSPObjectInfo;
#endif 	/* __IMDSPObjectInfo_FWD_DEFINED__ */


#ifndef __IMDSPObject_FWD_DEFINED__
#define __IMDSPObject_FWD_DEFINED__
typedef interface IMDSPObject IMDSPObject;
#endif 	/* __IMDSPObject_FWD_DEFINED__ */


#ifndef __IMDSPRevoked_FWD_DEFINED__
#define __IMDSPRevoked_FWD_DEFINED__
typedef interface IMDSPRevoked IMDSPRevoked;
#endif 	/* __IMDSPRevoked_FWD_DEFINED__ */


#ifndef __ISCPSecureAuthenticate_FWD_DEFINED__
#define __ISCPSecureAuthenticate_FWD_DEFINED__
typedef interface ISCPSecureAuthenticate ISCPSecureAuthenticate;
#endif 	/* __ISCPSecureAuthenticate_FWD_DEFINED__ */


#ifndef __ISCPSecureQuery_FWD_DEFINED__
#define __ISCPSecureQuery_FWD_DEFINED__
typedef interface ISCPSecureQuery ISCPSecureQuery;
#endif 	/* __ISCPSecureQuery_FWD_DEFINED__ */


#ifndef __ISCPSecureQuery2_FWD_DEFINED__
#define __ISCPSecureQuery2_FWD_DEFINED__
typedef interface ISCPSecureQuery2 ISCPSecureQuery2;
#endif 	/* __ISCPSecureQuery2_FWD_DEFINED__ */


#ifndef __ISCPSecureExchange_FWD_DEFINED__
#define __ISCPSecureExchange_FWD_DEFINED__
typedef interface ISCPSecureExchange ISCPSecureExchange;
#endif 	/* __ISCPSecureExchange_FWD_DEFINED__ */


#ifndef __IComponentAuthenticate_FWD_DEFINED__
#define __IComponentAuthenticate_FWD_DEFINED__
typedef interface IComponentAuthenticate IComponentAuthenticate;
#endif 	/* __IComponentAuthenticate_FWD_DEFINED__ */


#ifndef __MediaDevMgrClassFactory_FWD_DEFINED__
#define __MediaDevMgrClassFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaDevMgrClassFactory MediaDevMgrClassFactory;
#else
typedef struct MediaDevMgrClassFactory MediaDevMgrClassFactory;
#endif /* __cplusplus */

#endif 	/* __MediaDevMgrClassFactory_FWD_DEFINED__ */


#ifndef __MediaDevMgr_FWD_DEFINED__
#define __MediaDevMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaDevMgr MediaDevMgr;
#else
typedef struct MediaDevMgr MediaDevMgr;
#endif /* __cplusplus */

#endif 	/* __MediaDevMgr_FWD_DEFINED__ */


#ifndef __WMDMDevice_FWD_DEFINED__
#define __WMDMDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMDevice WMDMDevice;
#else
typedef struct WMDMDevice WMDMDevice;
#endif /* __cplusplus */

#endif 	/* __WMDMDevice_FWD_DEFINED__ */


#ifndef __WMDMStorage_FWD_DEFINED__
#define __WMDMStorage_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMStorage WMDMStorage;
#else
typedef struct WMDMStorage WMDMStorage;
#endif /* __cplusplus */

#endif 	/* __WMDMStorage_FWD_DEFINED__ */


#ifndef __WMDMStorageGlobal_FWD_DEFINED__
#define __WMDMStorageGlobal_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMStorageGlobal WMDMStorageGlobal;
#else
typedef struct WMDMStorageGlobal WMDMStorageGlobal;
#endif /* __cplusplus */

#endif 	/* __WMDMStorageGlobal_FWD_DEFINED__ */


#ifndef __WMDMDeviceEnum_FWD_DEFINED__
#define __WMDMDeviceEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMDeviceEnum WMDMDeviceEnum;
#else
typedef struct WMDMDeviceEnum WMDMDeviceEnum;
#endif /* __cplusplus */

#endif 	/* __WMDMDeviceEnum_FWD_DEFINED__ */


#ifndef __WMDMStorageEnum_FWD_DEFINED__
#define __WMDMStorageEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMStorageEnum WMDMStorageEnum;
#else
typedef struct WMDMStorageEnum WMDMStorageEnum;
#endif /* __cplusplus */

#endif 	/* __WMDMStorageEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_mswmdm_0000 */
/* [local] */ 

typedef struct  _tWAVEFORMATEX
    {
    WORD wFormatTag;
    WORD nChannels;
    DWORD nSamplesPerSec;
    DWORD nAvgBytesPerSec;
    WORD nBlockAlign;
    WORD wBitsPerSample;
    WORD cbSize;
    }	_WAVEFORMATEX;

typedef struct  _tagBITMAPINFOHEADER
    {
    DWORD biSize;
    LONG biWidth;
    LONG biHeight;
    WORD biPlanes;
    WORD biBitCount;
    DWORD biCompression;
    DWORD biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    DWORD biClrUsed;
    DWORD biClrImportant;
    }	_BITMAPINFOHEADER;

typedef struct  _tagVIDEOINFOHEADER
    {
    RECT rcSource;
    RECT rcTarget;
    DWORD dwBitRate;
    DWORD dwBitErrorRate;
    LONGLONG AvgTimePerFrame;
    _BITMAPINFOHEADER bmiHeader;
    }	_VIDEOINFOHEADER;

typedef struct  _tagWMFILECAPABILITIES
    {
    LPWSTR pwszMimeType;
    DWORD dwReserved;
    }	WMFILECAPABILITIES;

typedef struct  __OPAQUECOMMAND
    {
    GUID guidCommand;
    DWORD dwDataLen;
    /* [size_is] */ BYTE __RPC_FAR *pData;
    BYTE abMAC[ 20 ];
    }	OPAQUECOMMAND;

#define WMDMID_LENGTH  128
typedef struct  __WMDMID
    {
    UINT cbSize;
    DWORD dwVendorID;
    BYTE pID[ 128 ];
    UINT SerialNumberLength;
    }	WMDMID;

typedef struct __WMDMID __RPC_FAR *PWMDMID;

typedef struct  _WMDMDATETIME
    {
    WORD wYear;
    WORD wMonth;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    }	WMDMDATETIME;

typedef struct _WMDMDATETIME __RPC_FAR *PWMDMDATETIME;

typedef struct  __WMDMRIGHTS
    {
    UINT cbSize;
    DWORD dwContentType;
    DWORD fuFlags;
    DWORD fuRights;
    DWORD dwAppSec;
    DWORD dwPlaybackCount;
    WMDMDATETIME ExpirationDate;
    }	WMDMRIGHTS;

typedef struct __WMDMRIGHTS __RPC_FAR *PWMDMRIGHTS;

#define WMDM_MAC_LENGTH 8
// WMDM HRESULTS
#define WMDM_E_BUSY                             0x80045000L
#define WMDM_E_INTERFACEDEAD                    0x80045001L
#define WMDM_E_INVALIDTYPE                      0x80045002L
#define WMDM_E_PROCESSFAILED                    0x80045003L
#define WMDM_E_NOTSUPPORTED                     0x80045004L
#define WMDM_E_NOTCERTIFIED                     0x80045005L
#define WMDM_E_NORIGHTS                         0x80045006L
#define WMDM_E_CALL_OUT_OF_SEQUENCE             0x80045007L
#define WMDM_E_BUFFERTOOSMALL                   0x80045008L
#define WMDM_E_MOREDATA                         0x80045009L
#define WMDM_E_MAC_CHECK_FAILED                 0x8004500AL
#define WMDM_E_USER_CANCELLED                   0x8004500BL
#define WMDM_E_SDMI_TRIGGER                     0x8004500CL
#define WMDM_E_SDMI_NOMORECOPIES                0x8004500DL
#define WMDM_E_REVOKED                          0x8004500EL
// Revocation Flags
#define WMDM_WMDM_REVOKED                       0x00000001
#define WMDM_APP_REVOKED                        0x00000002
#define WMDM_SP_REVOKED                         0x00000004
#define WMDM_SCP_REVOKED                        0x00000008
// GetFormatSupport2 Flags
#define WMDM_GET_FORMAT_SUPPORT_AUDIO           0x00000001
#define WMDM_GET_FORMAT_SUPPORT_VIDEO           0x00000002
#define WMDM_GET_FORMAT_SUPPORT_FILE            0x00000004
// MDMRIGHTS Flags
#define WMDM_RIGHTS_PLAYBACKCOUNT               0x00000001
#define WMDM_RIGHTS_EXPIRATIONDATE              0x00000002
#define WMDM_RIGHTS_GROUPID                     0x00000004
#define WMDM_RIGHTS_FREESERIALIDS               0x00000008
#define WMDM_RIGHTS_NAMEDSERIALIDS              0x00000010
// Device Type Flags
#define WMDM_DEVICE_TYPE_PLAYBACK               0x00000001
#define WMDM_DEVICE_TYPE_RECORD                 0x00000002
#define WMDM_DEVICE_TYPE_DECODE                 0x00000004
#define WMDM_DEVICE_TYPE_ENCODE                 0x00000008
#define WMDM_DEVICE_TYPE_STORAGE                0x00000010
#define WMDM_DEVICE_TYPE_VIRTUAL                0x00000020
#define WMDM_DEVICE_TYPE_SDMI                   0x00000040
#define WMDM_DEVICE_TYPE_NONSDMI                0x00000080
#define WMDM_DEVICE_TYPE_NONREENTRANT           0x00000100
#define WMDM_DEVICE_TYPE_FILELISTRESYNC         0x00000200
// Device Power Source Flags
#define WMDM_POWER_CAP_BATTERY                  0x00000001
#define WMDM_POWER_CAP_EXTERNAL                 0x00000002
#define WMDM_POWER_IS_BATTERY                   0x00000004
#define WMDM_POWER_IS_EXTERNAL                  0x00000008
#define WMDM_POWER_PERCENT_AVAILABLE            0x00000010
// Device Status Flags
#define WMDM_STATUS_READY                       0x00000001
#define WMDM_STATUS_BUSY                        0x00000002
#define WMDM_STATUS_DEVICE_NOTPRESENT           0x00000004
#define WMDM_STATUS_DEVICECONTROL_PLAYING       0x00000008
#define WMDM_STATUS_DEVICECONTROL_RECORDING     0x00000010
#define WMDM_STATUS_DEVICECONTROL_PAUSED        0x00000020
#define WMDM_STATUS_DEVICECONTROL_REMOTE        0x00000040
#define WMDM_STATUS_DEVICECONTROL_STREAM        0x00000080
#define WMDM_STATUS_STORAGE_NOTPRESENT          0x00000100
#define WMDM_STATUS_STORAGE_INITIALIZING        0x00000200
#define WMDM_STATUS_STORAGE_BROKEN              0x00000400
#define WMDM_STATUS_STORAGE_NOTSUPPORTED        0x00000800
#define WMDM_STATUS_STORAGE_UNFORMATTED         0x00001000
#define WMDM_STATUS_STORAGECONTROL_INSERTING    0x00002000
#define WMDM_STATUS_STORAGECONTROL_DELETING     0x00004000
#define WMDM_STATUS_STORAGECONTROL_APPENDING    0x00008000
#define WMDM_STATUS_STORAGECONTROL_MOVING       0x00010000
#define WMDM_STATUS_STORAGECONTROL_READING      0x00020000
// Device Capabilities Flags
#define WMDM_DEVICECAP_CANPLAY                  0x00000001
#define WMDM_DEVICECAP_CANSTREAMPLAY            0x00000002
#define WMDM_DEVICECAP_CANRECORD                0x00000004
#define WMDM_DEVICECAP_CANSTREAMRECORD          0x00000008
#define WMDM_DEVICECAP_CANPAUSE                 0x00000010
#define WMDM_DEVICECAP_CANRESUME                0x00000020
#define WMDM_DEVICECAP_CANSTOP                  0x00000040
#define WMDM_DEVICECAP_CANSEEK                  0x00000080
// WMDM Seek Flags
#define WMDM_SEEK_REMOTECONTROL                 0x00000001
#define WMDM_SEEK_STREAMINGAUDIO                0x00000002
// Storage Attributes Flags
#define WMDM_STORAGE_ATTR_FILESYSTEM            0x00000001
#define WMDM_STORAGE_ATTR_REMOVABLE             0x00000002
#define WMDM_STORAGE_ATTR_NONREMOVABLE          0x00000004
#define WMDM_FILE_ATTR_FOLDER                   0x00000008
#define WMDM_FILE_ATTR_LINK                     0x00000010
#define WMDM_FILE_ATTR_FILE                     0x00000020
#define WMDM_FILE_ATTR_VIDEO                    0x00000040
#define WMDM_STORAGE_ATTR_FOLDERS               0x00000100
#define WMDM_FILE_ATTR_AUDIO                    0x00001000
#define WMDM_FILE_ATTR_DATA                     0x00002000
#define WMDM_FILE_ATTR_CANPLAY                  0x00004000
#define WMDM_FILE_ATTR_CANDELETE                0x00008000
#define WMDM_FILE_ATTR_CANMOVE                  0x00010000
#define WMDM_FILE_ATTR_CANRENAME                0x00020000
#define WMDM_FILE_ATTR_CANREAD                  0x00040000
#define WMDM_FILE_ATTR_MUSIC                    0x00080000
#define WMDM_FILE_CREATE_OVERWRITE              0x00100000
#define WMDM_FILE_ATTR_AUDIOBOOK                0x00200000
#define WMDM_FILE_ATTR_HIDDEN                   0x00400000
#define WMDM_FILE_ATTR_SYSTEM                   0x00800000
#define WMDM_FILE_ATTR_READONLY                 0x01000000
#define WMDM_STORAGE_ATTR_HAS_FOLDERS           0x02000000
#define WMDM_STORAGE_ATTR_HAS_FILES             0x04000000
#define WMDM_STORAGE_IS_DEFAULT                 0x08000000
#define WMDM_STORAGE_CONTAINS_DEFAULT           0x10000000
// Storage Capabilities Flags
#define WMDM_STORAGECAP_FOLDERSINROOT           0x00000001
#define WMDM_STORAGECAP_FILESINROOT             0x00000002
#define WMDM_STORAGECAP_FOLDERSINFOLDERS        0x00000004
#define WMDM_STORAGECAP_FILESINFOLDERS          0x00000008
#define WMDM_STORAGECAP_FOLDERLIMITEXISTS       0x00000010
#define WMDM_STORAGECAP_FILELIMITEXISTS         0x00000020
// WMDM Mode Flags
#define WMDM_MODE_BLOCK                         0x00000001
#define WMDM_MODE_THREAD                        0x00000002
#define WMDM_CONTENT_FILE                       0x00000004
#define WMDM_CONTENT_FOLDER                     0x00000008
#define WMDM_CONTENT_OPERATIONINTERFACE         0x00000010
#define WMDM_MODE_QUERY                         0x00000020
#define WMDM_MODE_PROGRESS                      0x00000040
#define WMDM_MODE_TRANSFER_PROTECTED            0x00000080
#define WMDM_MODE_TRANSFER_UNPROTECTED          0x00000100
#define WMDM_STORAGECONTROL_INSERTBEFORE        0x00000200
#define WMDM_STORAGECONTROL_INSERTAFTER         0x00000400
#define WMDM_STORAGECONTROL_INSERTINTO          0x00000800
#define WMDM_MODE_RECURSIVE                     0x00001000
// WMDM Rights Flags
// NON_SDMI = !SDMI_PROTECTED
// SDMI = SDMI_VALIDATED
#define WMDM_RIGHTS_PLAY_ON_PC                  0x00000001
#define WMDM_RIGHTS_COPY_TO_NON_SDMI_DEVICE     0x00000002
#define WMDM_RIGHTS_COPY_TO_CD                  0x00000008
#define WMDM_RIGHTS_COPY_TO_SDMI_DEVICE         0x00000010
// WMDM Seek Flags
#define WMDM_SEEK_BEGIN                         0x00000001
#define WMDM_SEEK_CURRENT                       0x00000002
#define WMDM_SEEK_END                           0x00000008











extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0000_v0_0_s_ifspec;

#ifndef __IWMDeviceManager_INTERFACE_DEFINED__
#define __IWMDeviceManager_INTERFACE_DEFINED__

/* interface IWMDeviceManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDeviceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A00-33ED-11d3-8470-00C04F79DBC0")
    IWMDeviceManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRevision( 
            /* [out] */ DWORD __RPC_FAR *pdwRevision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceCount( 
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDevices( 
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDeviceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDeviceManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDeviceManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDeviceManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRevision )( 
            IWMDeviceManager __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwRevision);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IWMDeviceManager __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDevices )( 
            IWMDeviceManager __RPC_FAR * This,
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        END_INTERFACE
    } IWMDeviceManagerVtbl;

    interface IWMDeviceManager
    {
        CONST_VTBL struct IWMDeviceManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDeviceManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDeviceManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDeviceManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDeviceManager_GetRevision(This,pdwRevision)	\
    (This)->lpVtbl -> GetRevision(This,pdwRevision)

#define IWMDeviceManager_GetDeviceCount(This,pdwCount)	\
    (This)->lpVtbl -> GetDeviceCount(This,pdwCount)

#define IWMDeviceManager_EnumDevices(This,ppEnumDevice)	\
    (This)->lpVtbl -> EnumDevices(This,ppEnumDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDeviceManager_GetRevision_Proxy( 
    IWMDeviceManager __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwRevision);


void __RPC_STUB IWMDeviceManager_GetRevision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDeviceManager_GetDeviceCount_Proxy( 
    IWMDeviceManager __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IWMDeviceManager_GetDeviceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDeviceManager_EnumDevices_Proxy( 
    IWMDeviceManager __RPC_FAR * This,
    /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);


void __RPC_STUB IWMDeviceManager_EnumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDeviceManager_INTERFACE_DEFINED__ */


#ifndef __IWMDeviceManager2_INTERFACE_DEFINED__
#define __IWMDeviceManager2_INTERFACE_DEFINED__

/* interface IWMDeviceManager2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDeviceManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("923E5249-8731-4c5b-9B1C-B8B60B6E46AF")
    IWMDeviceManager2 : public IWMDeviceManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceFromPnPName( 
            /* [string][in] */ LPCWSTR pwszPnPName,
            /* [out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDeviceManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDeviceManager2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDeviceManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRevision )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwRevision);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDevices )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceFromPnPName )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pwszPnPName,
            /* [out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        END_INTERFACE
    } IWMDeviceManager2Vtbl;

    interface IWMDeviceManager2
    {
        CONST_VTBL struct IWMDeviceManager2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDeviceManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDeviceManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDeviceManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDeviceManager2_GetRevision(This,pdwRevision)	\
    (This)->lpVtbl -> GetRevision(This,pdwRevision)

#define IWMDeviceManager2_GetDeviceCount(This,pdwCount)	\
    (This)->lpVtbl -> GetDeviceCount(This,pdwCount)

#define IWMDeviceManager2_EnumDevices(This,ppEnumDevice)	\
    (This)->lpVtbl -> EnumDevices(This,ppEnumDevice)


#define IWMDeviceManager2_GetDeviceFromPnPName(This,pwszPnPName,ppDevice)	\
    (This)->lpVtbl -> GetDeviceFromPnPName(This,pwszPnPName,ppDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDeviceManager2_GetDeviceFromPnPName_Proxy( 
    IWMDeviceManager2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pwszPnPName,
    /* [out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IWMDeviceManager2_GetDeviceFromPnPName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDeviceManager2_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorageGlobals_INTERFACE_DEFINED__
#define __IWMDMStorageGlobals_INTERFACE_DEFINED__

/* interface IWMDMStorageGlobals */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorageGlobals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A07-33ED-11d3-8470-00C04F79DBC0")
    IWMDMStorageGlobals : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialNumber( 
            /* [out] */ PWMDMID pSerialNum,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalSize( 
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalFree( 
            /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
            /* [out] */ DWORD __RPC_FAR *pdwFreeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalBad( 
            /* [out] */ DWORD __RPC_FAR *pdwBadLow,
            /* [out] */ DWORD __RPC_FAR *pdwBadHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorageGlobalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorageGlobals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorageGlobals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNum,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalSize )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalFree )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
            /* [out] */ DWORD __RPC_FAR *pdwFreeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalBad )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBadLow,
            /* [out] */ DWORD __RPC_FAR *pdwBadHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        END_INTERFACE
    } IWMDMStorageGlobalsVtbl;

    interface IWMDMStorageGlobals
    {
        CONST_VTBL struct IWMDMStorageGlobalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorageGlobals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorageGlobals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorageGlobals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorageGlobals_GetCapabilities(This,pdwCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities)

#define IWMDMStorageGlobals_GetSerialNumber(This,pSerialNum,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNum,abMac)

#define IWMDMStorageGlobals_GetTotalSize(This,pdwTotalSizeLow,pdwTotalSizeHigh)	\
    (This)->lpVtbl -> GetTotalSize(This,pdwTotalSizeLow,pdwTotalSizeHigh)

#define IWMDMStorageGlobals_GetTotalFree(This,pdwFreeLow,pdwFreeHigh)	\
    (This)->lpVtbl -> GetTotalFree(This,pdwFreeLow,pdwFreeHigh)

#define IWMDMStorageGlobals_GetTotalBad(This,pdwBadLow,pdwBadHigh)	\
    (This)->lpVtbl -> GetTotalBad(This,pdwBadLow,pdwBadHigh)

#define IWMDMStorageGlobals_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IWMDMStorageGlobals_Initialize(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Initialize(This,fuMode,pProgress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetCapabilities_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilities);


void __RPC_STUB IWMDMStorageGlobals_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetSerialNumber_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ PWMDMID pSerialNum,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IWMDMStorageGlobals_GetSerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetTotalSize_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
    /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh);


void __RPC_STUB IWMDMStorageGlobals_GetTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetTotalFree_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
    /* [out] */ DWORD __RPC_FAR *pdwFreeHigh);


void __RPC_STUB IWMDMStorageGlobals_GetTotalFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetTotalBad_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBadLow,
    /* [out] */ DWORD __RPC_FAR *pdwBadHigh);


void __RPC_STUB IWMDMStorageGlobals_GetTotalBad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetStatus_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IWMDMStorageGlobals_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_Initialize_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IWMDMStorageGlobals_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorageGlobals_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorage_INTERFACE_DEFINED__
#define __IWMDMStorage_INTERFACE_DEFINED__

/* interface IWMDMStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A06-33ED-11d3-8470-00C04F79DBC0")
    IWMDMStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttributes( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorageGlobals( 
            /* [out] */ IWMDMStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDate( 
            /* [out] */ PWMDMDATETIME pDateTimeUTC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRights( 
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStorage( 
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *pEnumStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendOpaqueCommand( 
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes )( 
            IWMDMStorage __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageGlobals )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ IWMDMStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMDMStorage __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ PWMDMDATETIME pDateTimeUTC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            IWMDMStorage __RPC_FAR * This,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *pEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        END_INTERFACE
    } IWMDMStorageVtbl;

    interface IWMDMStorage
    {
        CONST_VTBL struct IWMDMStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorage_SetAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetAttributes(This,dwAttributes,pFormat)

#define IWMDMStorage_GetStorageGlobals(This,ppStorageGlobals)	\
    (This)->lpVtbl -> GetStorageGlobals(This,ppStorageGlobals)

#define IWMDMStorage_GetAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttributes,pFormat)

#define IWMDMStorage_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IWMDMStorage_GetDate(This,pDateTimeUTC)	\
    (This)->lpVtbl -> GetDate(This,pDateTimeUTC)

#define IWMDMStorage_GetSize(This,pdwSizeLow,pdwSizeHigh)	\
    (This)->lpVtbl -> GetSize(This,pdwSizeLow,pdwSizeHigh)

#define IWMDMStorage_GetRights(This,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,ppRights,pnRightsCount,abMac)

#define IWMDMStorage_EnumStorage(This,pEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,pEnumStorage)

#define IWMDMStorage_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorage_SetAttributes_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMStorage_SetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetStorageGlobals_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ IWMDMStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);


void __RPC_STUB IWMDMStorage_GetStorageGlobals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetAttributes_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMStorage_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetName_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMStorage_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetDate_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ PWMDMDATETIME pDateTimeUTC);


void __RPC_STUB IWMDMStorage_GetDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetSize_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
    /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);


void __RPC_STUB IWMDMStorage_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetRights_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
    /* [out] */ UINT __RPC_FAR *pnRightsCount,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IWMDMStorage_GetRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_EnumStorage_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *pEnumStorage);


void __RPC_STUB IWMDMStorage_EnumStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_SendOpaqueCommand_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);


void __RPC_STUB IWMDMStorage_SendOpaqueCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorage_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorage2_INTERFACE_DEFINED__
#define __IWMDMStorage2_INTERFACE_DEFINED__

/* interface IWMDMStorage2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ED5A144-5CD5-4683-9EFF-72CBDB2D9533")
    IWMDMStorage2 : public IWMDMStorage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttributes2( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes2( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorage2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorage2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageGlobals )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ IWMDMStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ PWMDMDATETIME pDateTimeUTC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *pEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorage )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes2 )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes2 )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        END_INTERFACE
    } IWMDMStorage2Vtbl;

    interface IWMDMStorage2
    {
        CONST_VTBL struct IWMDMStorage2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorage2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorage2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorage2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorage2_SetAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetAttributes(This,dwAttributes,pFormat)

#define IWMDMStorage2_GetStorageGlobals(This,ppStorageGlobals)	\
    (This)->lpVtbl -> GetStorageGlobals(This,ppStorageGlobals)

#define IWMDMStorage2_GetAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttributes,pFormat)

#define IWMDMStorage2_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IWMDMStorage2_GetDate(This,pDateTimeUTC)	\
    (This)->lpVtbl -> GetDate(This,pDateTimeUTC)

#define IWMDMStorage2_GetSize(This,pdwSizeLow,pdwSizeHigh)	\
    (This)->lpVtbl -> GetSize(This,pdwSizeLow,pdwSizeHigh)

#define IWMDMStorage2_GetRights(This,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,ppRights,pnRightsCount,abMac)

#define IWMDMStorage2_EnumStorage(This,pEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,pEnumStorage)

#define IWMDMStorage2_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)


#define IWMDMStorage2_GetStorage(This,pszStorageName,ppStorage)	\
    (This)->lpVtbl -> GetStorage(This,pszStorageName,ppStorage)

#define IWMDMStorage2_SetAttributes2(This,dwAttributes,dwAttributesEx,pFormat,pVideoFormat)	\
    (This)->lpVtbl -> SetAttributes2(This,dwAttributes,dwAttributesEx,pFormat,pVideoFormat)

#define IWMDMStorage2_GetAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)	\
    (This)->lpVtbl -> GetAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorage2_GetStorage_Proxy( 
    IWMDMStorage2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszStorageName,
    /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage);


void __RPC_STUB IWMDMStorage2_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage2_SetAttributes2_Proxy( 
    IWMDMStorage2 __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ DWORD dwAttributesEx,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
    /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IWMDMStorage2_SetAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage2_GetAttributes2_Proxy( 
    IWMDMStorage2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IWMDMStorage2_GetAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorage2_INTERFACE_DEFINED__ */


#ifndef __IWMDMOperation_INTERFACE_DEFINED__
#define __IWMDMOperation_INTERFACE_DEFINED__

/* interface IWMDMOperation */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0B-33ED-11d3-8470-00C04F79DBC0")
    IWMDMOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginRead( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginWrite( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectName( 
            /* [size_is][string][in] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAttributes( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectAttributes( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectTotalSize( 
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectTotalSize( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TransferObjectData( 
            /* [size_is][out][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( 
            /* [in] */ HRESULT __RPC_FAR *phCompletionCode,
            /* [in] */ IUnknown __RPC_FAR *pNewObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMOperation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMOperation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginRead )( 
            IWMDMOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginWrite )( 
            IWMDMOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectName )( 
            IWMDMOperation __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectName )( 
            IWMDMOperation __RPC_FAR * This,
            /* [size_is][string][in] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAttributes )( 
            IWMDMOperation __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectAttributes )( 
            IWMDMOperation __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectTotalSize )( 
            IWMDMOperation __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectTotalSize )( 
            IWMDMOperation __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransferObjectData )( 
            IWMDMOperation __RPC_FAR * This,
            /* [size_is][out][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IWMDMOperation __RPC_FAR * This,
            /* [in] */ HRESULT __RPC_FAR *phCompletionCode,
            /* [in] */ IUnknown __RPC_FAR *pNewObject);
        
        END_INTERFACE
    } IWMDMOperationVtbl;

    interface IWMDMOperation
    {
        CONST_VTBL struct IWMDMOperationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMOperation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMOperation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMOperation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMOperation_BeginRead(This)	\
    (This)->lpVtbl -> BeginRead(This)

#define IWMDMOperation_BeginWrite(This)	\
    (This)->lpVtbl -> BeginWrite(This)

#define IWMDMOperation_GetObjectName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetObjectName(This,pwszName,nMaxChars)

#define IWMDMOperation_SetObjectName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> SetObjectName(This,pwszName,nMaxChars)

#define IWMDMOperation_GetObjectAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetObjectAttributes(This,pdwAttributes,pFormat)

#define IWMDMOperation_SetObjectAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetObjectAttributes(This,dwAttributes,pFormat)

#define IWMDMOperation_GetObjectTotalSize(This,pdwSize,pdwSizeHigh)	\
    (This)->lpVtbl -> GetObjectTotalSize(This,pdwSize,pdwSizeHigh)

#define IWMDMOperation_SetObjectTotalSize(This,dwSize,dwSizeHigh)	\
    (This)->lpVtbl -> SetObjectTotalSize(This,dwSize,dwSizeHigh)

#define IWMDMOperation_TransferObjectData(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> TransferObjectData(This,pData,pdwSize,abMac)

#define IWMDMOperation_End(This,phCompletionCode,pNewObject)	\
    (This)->lpVtbl -> End(This,phCompletionCode,pNewObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMOperation_BeginRead_Proxy( 
    IWMDMOperation __RPC_FAR * This);


void __RPC_STUB IWMDMOperation_BeginRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_BeginWrite_Proxy( 
    IWMDMOperation __RPC_FAR * This);


void __RPC_STUB IWMDMOperation_BeginWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_GetObjectName_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMOperation_GetObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_SetObjectName_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [size_is][string][in] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMOperation_SetObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_GetObjectAttributes_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMOperation_GetObjectAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_SetObjectAttributes_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMOperation_SetObjectAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_GetObjectTotalSize_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSize,
    /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);


void __RPC_STUB IWMDMOperation_GetObjectTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_SetObjectTotalSize_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwSizeHigh);


void __RPC_STUB IWMDMOperation_SetObjectTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_TransferObjectData_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [size_is][out][in] */ BYTE __RPC_FAR *pData,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IWMDMOperation_TransferObjectData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_End_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [in] */ HRESULT __RPC_FAR *phCompletionCode,
    /* [in] */ IUnknown __RPC_FAR *pNewObject);


void __RPC_STUB IWMDMOperation_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMOperation_INTERFACE_DEFINED__ */


#ifndef __IWMDMOperation2_INTERFACE_DEFINED__
#define __IWMDMOperation2_INTERFACE_DEFINED__

/* interface IWMDMOperation2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMOperation2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33445B48-7DF7-425c-AD8F-0FC6D82F9F75")
    IWMDMOperation2 : public IWMDMOperation
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetObjectAttributes2( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAttributes2( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMOperation2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMOperation2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMOperation2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginRead )( 
            IWMDMOperation2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginWrite )( 
            IWMDMOperation2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectName )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectName )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [size_is][string][in] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAttributes )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectAttributes )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectTotalSize )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectTotalSize )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransferObjectData )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [size_is][out][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ HRESULT __RPC_FAR *phCompletionCode,
            /* [in] */ IUnknown __RPC_FAR *pNewObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectAttributes2 )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAttributes2 )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        END_INTERFACE
    } IWMDMOperation2Vtbl;

    interface IWMDMOperation2
    {
        CONST_VTBL struct IWMDMOperation2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMOperation2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMOperation2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMOperation2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMOperation2_BeginRead(This)	\
    (This)->lpVtbl -> BeginRead(This)

#define IWMDMOperation2_BeginWrite(This)	\
    (This)->lpVtbl -> BeginWrite(This)

#define IWMDMOperation2_GetObjectName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetObjectName(This,pwszName,nMaxChars)

#define IWMDMOperation2_SetObjectName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> SetObjectName(This,pwszName,nMaxChars)

#define IWMDMOperation2_GetObjectAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetObjectAttributes(This,pdwAttributes,pFormat)

#define IWMDMOperation2_SetObjectAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetObjectAttributes(This,dwAttributes,pFormat)

#define IWMDMOperation2_GetObjectTotalSize(This,pdwSize,pdwSizeHigh)	\
    (This)->lpVtbl -> GetObjectTotalSize(This,pdwSize,pdwSizeHigh)

#define IWMDMOperation2_SetObjectTotalSize(This,dwSize,dwSizeHigh)	\
    (This)->lpVtbl -> SetObjectTotalSize(This,dwSize,dwSizeHigh)

#define IWMDMOperation2_TransferObjectData(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> TransferObjectData(This,pData,pdwSize,abMac)

#define IWMDMOperation2_End(This,phCompletionCode,pNewObject)	\
    (This)->lpVtbl -> End(This,phCompletionCode,pNewObject)


#define IWMDMOperation2_SetObjectAttributes2(This,dwAttributes,dwAttributesEx,pFormat,pVideoFormat)	\
    (This)->lpVtbl -> SetObjectAttributes2(This,dwAttributes,dwAttributesEx,pFormat,pVideoFormat)

#define IWMDMOperation2_GetObjectAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)	\
    (This)->lpVtbl -> GetObjectAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMOperation2_SetObjectAttributes2_Proxy( 
    IWMDMOperation2 __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ DWORD dwAttributesEx,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
    /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IWMDMOperation2_SetObjectAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation2_GetObjectAttributes2_Proxy( 
    IWMDMOperation2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IWMDMOperation2_GetObjectAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMOperation2_INTERFACE_DEFINED__ */


#ifndef __IWMDMProgress_INTERFACE_DEFINED__
#define __IWMDMProgress_INTERFACE_DEFINED__

/* interface IWMDMProgress */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0C-33ED-11d3-8470-00C04F79DBC0")
    IWMDMProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin( 
            /* [in] */ DWORD dwEstimatedTicks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Progress( 
            /* [in] */ DWORD dwTranspiredTicks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMProgress __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMProgress __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMProgress __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Begin )( 
            IWMDMProgress __RPC_FAR * This,
            /* [in] */ DWORD dwEstimatedTicks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Progress )( 
            IWMDMProgress __RPC_FAR * This,
            /* [in] */ DWORD dwTranspiredTicks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IWMDMProgress __RPC_FAR * This);
        
        END_INTERFACE
    } IWMDMProgressVtbl;

    interface IWMDMProgress
    {
        CONST_VTBL struct IWMDMProgressVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMProgress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMProgress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMProgress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMProgress_Begin(This,dwEstimatedTicks)	\
    (This)->lpVtbl -> Begin(This,dwEstimatedTicks)

#define IWMDMProgress_Progress(This,dwTranspiredTicks)	\
    (This)->lpVtbl -> Progress(This,dwTranspiredTicks)

#define IWMDMProgress_End(This)	\
    (This)->lpVtbl -> End(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMProgress_Begin_Proxy( 
    IWMDMProgress __RPC_FAR * This,
    /* [in] */ DWORD dwEstimatedTicks);


void __RPC_STUB IWMDMProgress_Begin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMProgress_Progress_Proxy( 
    IWMDMProgress __RPC_FAR * This,
    /* [in] */ DWORD dwTranspiredTicks);


void __RPC_STUB IWMDMProgress_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMProgress_End_Proxy( 
    IWMDMProgress __RPC_FAR * This);


void __RPC_STUB IWMDMProgress_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMProgress_INTERFACE_DEFINED__ */


#ifndef __IWMDMProgress2_INTERFACE_DEFINED__
#define __IWMDMProgress2_INTERFACE_DEFINED__

/* interface IWMDMProgress2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMProgress2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3A43F550-B383-4e92-B04A-E6BBC660FEFC")
    IWMDMProgress2 : public IWMDMProgress
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE End2( 
            /* [in] */ HRESULT hrCompletionCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMProgress2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMProgress2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMProgress2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMProgress2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Begin )( 
            IWMDMProgress2 __RPC_FAR * This,
            /* [in] */ DWORD dwEstimatedTicks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Progress )( 
            IWMDMProgress2 __RPC_FAR * This,
            /* [in] */ DWORD dwTranspiredTicks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IWMDMProgress2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End2 )( 
            IWMDMProgress2 __RPC_FAR * This,
            /* [in] */ HRESULT hrCompletionCode);
        
        END_INTERFACE
    } IWMDMProgress2Vtbl;

    interface IWMDMProgress2
    {
        CONST_VTBL struct IWMDMProgress2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMProgress2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMProgress2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMProgress2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMProgress2_Begin(This,dwEstimatedTicks)	\
    (This)->lpVtbl -> Begin(This,dwEstimatedTicks)

#define IWMDMProgress2_Progress(This,dwTranspiredTicks)	\
    (This)->lpVtbl -> Progress(This,dwTranspiredTicks)

#define IWMDMProgress2_End(This)	\
    (This)->lpVtbl -> End(This)


#define IWMDMProgress2_End2(This,hrCompletionCode)	\
    (This)->lpVtbl -> End2(This,hrCompletionCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMProgress2_End2_Proxy( 
    IWMDMProgress2 __RPC_FAR * This,
    /* [in] */ HRESULT hrCompletionCode);


void __RPC_STUB IWMDMProgress2_End2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMProgress2_INTERFACE_DEFINED__ */


#ifndef __IWMDMDevice_INTERFACE_DEFINED__
#define __IWMDMDevice_INTERFACE_DEFINED__

/* interface IWMDMDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A02-33ED-11d3-8470-00C04F79DBC0")
    IWMDMDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManufacturer( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ DWORD __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ DWORD __RPC_FAR *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialNumber( 
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPowerSource( 
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceIcon( 
            /* [out] */ ULONG __RPC_FAR *hIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStorage( 
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormatSupport( 
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendOpaqueCommand( 
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMDMDevice __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManufacturer )( 
            IWMDMDevice __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPowerSource )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIcon )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *hIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport )( 
            IWMDMDevice __RPC_FAR * This,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        END_INTERFACE
    } IWMDMDeviceVtbl;

    interface IWMDMDevice
    {
        CONST_VTBL struct IWMDMDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMDevice_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IWMDMDevice_GetManufacturer(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetManufacturer(This,pwszName,nMaxChars)

#define IWMDMDevice_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMDMDevice_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#define IWMDMDevice_GetSerialNumber(This,pSerialNumber,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNumber,abMac)

#define IWMDMDevice_GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)	\
    (This)->lpVtbl -> GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)

#define IWMDMDevice_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IWMDMDevice_GetDeviceIcon(This,hIcon)	\
    (This)->lpVtbl -> GetDeviceIcon(This,hIcon)

#define IWMDMDevice_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IWMDMDevice_GetFormatSupport(This,ppFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport(This,ppFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)

#define IWMDMDevice_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMDevice_GetName_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMDevice_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetManufacturer_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMDevice_GetManufacturer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetVersion_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwVersion);


void __RPC_STUB IWMDMDevice_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetType_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwType);


void __RPC_STUB IWMDMDevice_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetSerialNumber_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ PWMDMID pSerialNumber,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IWMDMDevice_GetSerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetPowerSource_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
    /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);


void __RPC_STUB IWMDMDevice_GetPowerSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetStatus_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IWMDMDevice_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetDeviceIcon_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *hIcon);


void __RPC_STUB IWMDMDevice_GetDeviceIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_EnumStorage_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IWMDMDevice_EnumStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetFormatSupport_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppFormatEx,
    /* [out] */ UINT __RPC_FAR *pnFormatCount,
    /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
    /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);


void __RPC_STUB IWMDMDevice_GetFormatSupport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_SendOpaqueCommand_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);


void __RPC_STUB IWMDMDevice_SendOpaqueCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMDevice_INTERFACE_DEFINED__ */


#ifndef __IWMDMDevice2_INTERFACE_DEFINED__
#define __IWMDMDevice2_INTERFACE_DEFINED__

/* interface IWMDMDevice2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMDevice2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E34F3D37-9D67-4fc1-9252-62D28B2F8B55")
    IWMDMDevice2 : public IWMDMDevice
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormatSupport2( 
            /* [in] */ DWORD dwFlags,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
            /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
            /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
            /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpecifyPropertyPages( 
            /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
            /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
            /* [ref][out] */ ULONG __RPC_FAR *pcUnks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPnPName( 
            /* [size_is][out] */ LPWSTR pwszPnPName,
            /* [in] */ UINT nMaxChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMDevice2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMDevice2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMDevice2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManufacturer )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPowerSource )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIcon )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *hIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorage )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport2 )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
            /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
            /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
            /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpecifyPropertyPages )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
            /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
            /* [ref][out] */ ULONG __RPC_FAR *pcUnks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPnPName )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [size_is][out] */ LPWSTR pwszPnPName,
            /* [in] */ UINT nMaxChars);
        
        END_INTERFACE
    } IWMDMDevice2Vtbl;

    interface IWMDMDevice2
    {
        CONST_VTBL struct IWMDMDevice2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMDevice2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMDevice2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMDevice2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMDevice2_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IWMDMDevice2_GetManufacturer(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetManufacturer(This,pwszName,nMaxChars)

#define IWMDMDevice2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMDMDevice2_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#define IWMDMDevice2_GetSerialNumber(This,pSerialNumber,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNumber,abMac)

#define IWMDMDevice2_GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)	\
    (This)->lpVtbl -> GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)

#define IWMDMDevice2_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IWMDMDevice2_GetDeviceIcon(This,hIcon)	\
    (This)->lpVtbl -> GetDeviceIcon(This,hIcon)

#define IWMDMDevice2_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IWMDMDevice2_GetFormatSupport(This,ppFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport(This,ppFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)

#define IWMDMDevice2_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)


#define IWMDMDevice2_GetStorage(This,pszStorageName,ppStorage)	\
    (This)->lpVtbl -> GetStorage(This,pszStorageName,ppStorage)

#define IWMDMDevice2_GetFormatSupport2(This,dwFlags,ppAudioFormatEx,pnAudioFormatCount,ppVideoFormatEx,pnVideoFormatCount,ppFileType,pnFileTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport2(This,dwFlags,ppAudioFormatEx,pnAudioFormatCount,ppVideoFormatEx,pnVideoFormatCount,ppFileType,pnFileTypeCount)

#define IWMDMDevice2_GetSpecifyPropertyPages(This,ppSpecifyPropPages,pppUnknowns,pcUnks)	\
    (This)->lpVtbl -> GetSpecifyPropertyPages(This,ppSpecifyPropPages,pppUnknowns,pcUnks)

#define IWMDMDevice2_GetPnPName(This,pwszPnPName,nMaxChars)	\
    (This)->lpVtbl -> GetPnPName(This,pwszPnPName,nMaxChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMDevice2_GetStorage_Proxy( 
    IWMDMDevice2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszStorageName,
    /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage);


void __RPC_STUB IWMDMDevice2_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice2_GetFormatSupport2_Proxy( 
    IWMDMDevice2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
    /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
    /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
    /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
    /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
    /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount);


void __RPC_STUB IWMDMDevice2_GetFormatSupport2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice2_GetSpecifyPropertyPages_Proxy( 
    IWMDMDevice2 __RPC_FAR * This,
    /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
    /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
    /* [ref][out] */ ULONG __RPC_FAR *pcUnks);


void __RPC_STUB IWMDMDevice2_GetSpecifyPropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice2_GetPnPName_Proxy( 
    IWMDMDevice2 __RPC_FAR * This,
    /* [size_is][out] */ LPWSTR pwszPnPName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMDevice2_GetPnPName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMDevice2_INTERFACE_DEFINED__ */


#ifndef __IWMDMEnumDevice_INTERFACE_DEFINED__
#define __IWMDMEnumDevice_INTERFACE_DEFINED__

/* interface IWMDMEnumDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMEnumDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A01-33ED-11d3-8470-00C04F79DBC0")
    IWMDMEnumDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMEnumDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMEnumDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMEnumDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMEnumDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWMDMEnumDevice __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IWMDMEnumDevice __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IWMDMEnumDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWMDMEnumDevice __RPC_FAR * This,
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        END_INTERFACE
    } IWMDMEnumDeviceVtbl;

    interface IWMDMEnumDevice
    {
        CONST_VTBL struct IWMDMEnumDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMEnumDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMEnumDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMEnumDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMEnumDevice_Next(This,celt,ppDevice,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppDevice,pceltFetched)

#define IWMDMEnumDevice_Skip(This,celt,pceltFetched)	\
    (This)->lpVtbl -> Skip(This,celt,pceltFetched)

#define IWMDMEnumDevice_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMDMEnumDevice_Clone(This,ppEnumDevice)	\
    (This)->lpVtbl -> Clone(This,ppEnumDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMEnumDevice_Next_Proxy( 
    IWMDMEnumDevice __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IWMDMEnumDevice_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumDevice_Skip_Proxy( 
    IWMDMEnumDevice __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IWMDMEnumDevice_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumDevice_Reset_Proxy( 
    IWMDMEnumDevice __RPC_FAR * This);


void __RPC_STUB IWMDMEnumDevice_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumDevice_Clone_Proxy( 
    IWMDMEnumDevice __RPC_FAR * This,
    /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);


void __RPC_STUB IWMDMEnumDevice_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMEnumDevice_INTERFACE_DEFINED__ */


#ifndef __IWMDMDeviceControl_INTERFACE_DEFINED__
#define __IWMDMDeviceControl_INTERFACE_DEFINED__

/* interface IWMDMDeviceControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMDeviceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A04-33ED-11d3-8470-00C04F79DBC0")
    IWMDMDeviceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Record( 
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ UINT fuMode,
            /* [in] */ int nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMDeviceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Record )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ int nOffset);
        
        END_INTERFACE
    } IWMDMDeviceControlVtbl;

    interface IWMDMDeviceControl
    {
        CONST_VTBL struct IWMDMDeviceControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMDeviceControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMDeviceControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMDeviceControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMDeviceControl_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IWMDMDeviceControl_GetCapabilities(This,pdwCapabilitiesMask)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilitiesMask)

#define IWMDMDeviceControl_Play(This)	\
    (This)->lpVtbl -> Play(This)

#define IWMDMDeviceControl_Record(This,pFormat)	\
    (This)->lpVtbl -> Record(This,pFormat)

#define IWMDMDeviceControl_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWMDMDeviceControl_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IWMDMDeviceControl_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWMDMDeviceControl_Seek(This,fuMode,nOffset)	\
    (This)->lpVtbl -> Seek(This,fuMode,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_GetStatus_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IWMDMDeviceControl_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_GetCapabilities_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask);


void __RPC_STUB IWMDMDeviceControl_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Play_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This);


void __RPC_STUB IWMDMDeviceControl_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Record_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMDeviceControl_Record_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Pause_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This);


void __RPC_STUB IWMDMDeviceControl_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Resume_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This);


void __RPC_STUB IWMDMDeviceControl_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Stop_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This);


void __RPC_STUB IWMDMDeviceControl_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Seek_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ int nOffset);


void __RPC_STUB IWMDMDeviceControl_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMDeviceControl_INTERFACE_DEFINED__ */


#ifndef __IWMDMEnumStorage_INTERFACE_DEFINED__
#define __IWMDMEnumStorage_INTERFACE_DEFINED__

/* interface IWMDMEnumStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMEnumStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A05-33ED-11d3-8470-00C04F79DBC0")
    IWMDMEnumStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMEnumStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMEnumStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMEnumStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMEnumStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWMDMEnumStorage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IWMDMEnumStorage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IWMDMEnumStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWMDMEnumStorage __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        END_INTERFACE
    } IWMDMEnumStorageVtbl;

    interface IWMDMEnumStorage
    {
        CONST_VTBL struct IWMDMEnumStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMEnumStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMEnumStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMEnumStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMEnumStorage_Next(This,celt,ppStorage,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppStorage,pceltFetched)

#define IWMDMEnumStorage_Skip(This,celt,pceltFetched)	\
    (This)->lpVtbl -> Skip(This,celt,pceltFetched)

#define IWMDMEnumStorage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMDMEnumStorage_Clone(This,ppEnumStorage)	\
    (This)->lpVtbl -> Clone(This,ppEnumStorage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMEnumStorage_Next_Proxy( 
    IWMDMEnumStorage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IWMDMEnumStorage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumStorage_Skip_Proxy( 
    IWMDMEnumStorage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IWMDMEnumStorage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumStorage_Reset_Proxy( 
    IWMDMEnumStorage __RPC_FAR * This);


void __RPC_STUB IWMDMEnumStorage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumStorage_Clone_Proxy( 
    IWMDMEnumStorage __RPC_FAR * This,
    /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IWMDMEnumStorage_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMEnumStorage_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorageControl_INTERFACE_DEFINED__
#define __IWMDMStorageControl_INTERFACE_DEFINED__

/* interface IWMDMStorageControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorageControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A08-33ED-11d3-8470-00C04F79DBC0")
    IWMDMStorageControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Insert( 
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rename( 
            /* [in] */ UINT fuMode,
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMStorage __RPC_FAR *pTargetObject,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorageControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorageControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorageControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Insert )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rename )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMStorage __RPC_FAR *pTargetObject,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        END_INTERFACE
    } IWMDMStorageControlVtbl;

    interface IWMDMStorageControl
    {
        CONST_VTBL struct IWMDMStorageControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorageControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorageControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorageControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorageControl_Insert(This,fuMode,pwszFile,pOperation,pProgress,ppNewObject)	\
    (This)->lpVtbl -> Insert(This,fuMode,pwszFile,pOperation,pProgress,ppNewObject)

#define IWMDMStorageControl_Delete(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Delete(This,fuMode,pProgress)

#define IWMDMStorageControl_Rename(This,fuMode,pwszNewName,pProgress)	\
    (This)->lpVtbl -> Rename(This,fuMode,pwszNewName,pProgress)

#define IWMDMStorageControl_Read(This,fuMode,pwszFile,pProgress,pOperation)	\
    (This)->lpVtbl -> Read(This,fuMode,pwszFile,pProgress,pOperation)

#define IWMDMStorageControl_Move(This,fuMode,pTargetObject,pProgress)	\
    (This)->lpVtbl -> Move(This,fuMode,pTargetObject,pProgress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Insert_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [unique][in] */ LPWSTR pwszFile,
    /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
    /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);


void __RPC_STUB IWMDMStorageControl_Insert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Delete_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IWMDMStorageControl_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Rename_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ LPWSTR pwszNewName,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IWMDMStorageControl_Rename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Read_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [unique][in] */ LPWSTR pwszFile,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
    /* [in] */ IWMDMOperation __RPC_FAR *pOperation);


void __RPC_STUB IWMDMStorageControl_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Move_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMStorage __RPC_FAR *pTargetObject,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IWMDMStorageControl_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorageControl_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorageControl2_INTERFACE_DEFINED__
#define __IWMDMStorageControl2_INTERFACE_DEFINED__

/* interface IWMDMStorageControl2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorageControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("972C2E88-BD6C-4125-8E09-84F837E637B6")
    IWMDMStorageControl2 : public IWMDMStorageControl
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Insert2( 
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFileSource,
            /* [unique][in] */ LPWSTR pwszFileDest,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IUnknown __RPC_FAR *pUnknown,
            /* [unique][out][in] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorageControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorageControl2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorageControl2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Insert )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rename )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMStorage __RPC_FAR *pTargetObject,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Insert2 )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFileSource,
            /* [unique][in] */ LPWSTR pwszFileDest,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IUnknown __RPC_FAR *pUnknown,
            /* [unique][out][in] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);
        
        END_INTERFACE
    } IWMDMStorageControl2Vtbl;

    interface IWMDMStorageControl2
    {
        CONST_VTBL struct IWMDMStorageControl2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorageControl2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorageControl2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorageControl2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorageControl2_Insert(This,fuMode,pwszFile,pOperation,pProgress,ppNewObject)	\
    (This)->lpVtbl -> Insert(This,fuMode,pwszFile,pOperation,pProgress,ppNewObject)

#define IWMDMStorageControl2_Delete(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Delete(This,fuMode,pProgress)

#define IWMDMStorageControl2_Rename(This,fuMode,pwszNewName,pProgress)	\
    (This)->lpVtbl -> Rename(This,fuMode,pwszNewName,pProgress)

#define IWMDMStorageControl2_Read(This,fuMode,pwszFile,pProgress,pOperation)	\
    (This)->lpVtbl -> Read(This,fuMode,pwszFile,pProgress,pOperation)

#define IWMDMStorageControl2_Move(This,fuMode,pTargetObject,pProgress)	\
    (This)->lpVtbl -> Move(This,fuMode,pTargetObject,pProgress)


#define IWMDMStorageControl2_Insert2(This,fuMode,pwszFileSource,pwszFileDest,pOperation,pProgress,pUnknown,ppNewObject)	\
    (This)->lpVtbl -> Insert2(This,fuMode,pwszFileSource,pwszFileDest,pOperation,pProgress,pUnknown,ppNewObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorageControl2_Insert2_Proxy( 
    IWMDMStorageControl2 __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [unique][in] */ LPWSTR pwszFileSource,
    /* [unique][in] */ LPWSTR pwszFileDest,
    /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
    /* [in] */ IUnknown __RPC_FAR *pUnknown,
    /* [unique][out][in] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);


void __RPC_STUB IWMDMStorageControl2_Insert2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorageControl2_INTERFACE_DEFINED__ */


#ifndef __IWMDMObjectInfo_INTERFACE_DEFINED__
#define __IWMDMObjectInfo_INTERFACE_DEFINED__

/* interface IWMDMObjectInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMObjectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A09-33ED-11d3-8470-00C04F79DBC0")
    IWMDMObjectInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPlayLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayOffset( 
            /* [out] */ DWORD __RPC_FAR *pdwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayOffset( 
            /* [in] */ DWORD dwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPlayPosition( 
            /* [out] */ DWORD __RPC_FAR *pdwLastPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLongestPlayPosition( 
            /* [out] */ DWORD __RPC_FAR *pdwLongestPos) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMObjectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMObjectInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMObjectInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayLength )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayLength )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayOffset )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayOffset )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [in] */ DWORD dwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalLength )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastPlayPosition )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLastPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLongestPlayPosition )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLongestPos);
        
        END_INTERFACE
    } IWMDMObjectInfoVtbl;

    interface IWMDMObjectInfo
    {
        CONST_VTBL struct IWMDMObjectInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMObjectInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMObjectInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMObjectInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMObjectInfo_GetPlayLength(This,pdwLength)	\
    (This)->lpVtbl -> GetPlayLength(This,pdwLength)

#define IWMDMObjectInfo_SetPlayLength(This,dwLength)	\
    (This)->lpVtbl -> SetPlayLength(This,dwLength)

#define IWMDMObjectInfo_GetPlayOffset(This,pdwOffset)	\
    (This)->lpVtbl -> GetPlayOffset(This,pdwOffset)

#define IWMDMObjectInfo_SetPlayOffset(This,dwOffset)	\
    (This)->lpVtbl -> SetPlayOffset(This,dwOffset)

#define IWMDMObjectInfo_GetTotalLength(This,pdwLength)	\
    (This)->lpVtbl -> GetTotalLength(This,pdwLength)

#define IWMDMObjectInfo_GetLastPlayPosition(This,pdwLastPos)	\
    (This)->lpVtbl -> GetLastPlayPosition(This,pdwLastPos)

#define IWMDMObjectInfo_GetLongestPlayPosition(This,pdwLongestPos)	\
    (This)->lpVtbl -> GetLongestPlayPosition(This,pdwLongestPos)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetPlayLength_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IWMDMObjectInfo_GetPlayLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_SetPlayLength_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB IWMDMObjectInfo_SetPlayLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetPlayOffset_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwOffset);


void __RPC_STUB IWMDMObjectInfo_GetPlayOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_SetPlayOffset_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOffset);


void __RPC_STUB IWMDMObjectInfo_SetPlayOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetTotalLength_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IWMDMObjectInfo_GetTotalLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetLastPlayPosition_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLastPos);


void __RPC_STUB IWMDMObjectInfo_GetLastPlayPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetLongestPlayPosition_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLongestPos);


void __RPC_STUB IWMDMObjectInfo_GetLongestPlayPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMObjectInfo_INTERFACE_DEFINED__ */


#ifndef __IWMDMRevoked_INTERFACE_DEFINED__
#define __IWMDMRevoked_INTERFACE_DEFINED__

/* interface IWMDMRevoked */
/* [ref][uuid][object] */ 


EXTERN_C const IID IID_IWMDMRevoked;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EBECCEDB-88EE-4e55-B6A4-8D9F07D696AA")
    IWMDMRevoked : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRevocationURL( 
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen,
            /* [out] */ DWORD __RPC_FAR *pdwRevokedBitFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMRevokedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMRevoked __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMRevoked __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMRevoked __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRevocationURL )( 
            IWMDMRevoked __RPC_FAR * This,
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen,
            /* [out] */ DWORD __RPC_FAR *pdwRevokedBitFlag);
        
        END_INTERFACE
    } IWMDMRevokedVtbl;

    interface IWMDMRevoked
    {
        CONST_VTBL struct IWMDMRevokedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMRevoked_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMRevoked_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMRevoked_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMRevoked_GetRevocationURL(This,ppwszRevocationURL,pdwBufferLen,pdwRevokedBitFlag)	\
    (This)->lpVtbl -> GetRevocationURL(This,ppwszRevocationURL,pdwBufferLen,pdwRevokedBitFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMRevoked_GetRevocationURL_Proxy( 
    IWMDMRevoked __RPC_FAR * This,
    /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
    /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen,
    /* [out] */ DWORD __RPC_FAR *pdwRevokedBitFlag);


void __RPC_STUB IWMDMRevoked_GetRevocationURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMRevoked_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mswmdm_0229 */
/* [local] */ 

// Open Mode Flags
#define MDSP_READ                               0x00000001
#define MDSP_WRITE                              0x00000002
// Seek Flags
#define MDSP_SEEK_BOF                           0x00000001
#define MDSP_SEEK_CUR                           0x00000002
#define MDSP_SEEK_EOF                           0x00000004











extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0229_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0229_v0_0_s_ifspec;

#ifndef __IMDServiceProvider_INTERFACE_DEFINED__
#define __IMDServiceProvider_INTERFACE_DEFINED__

/* interface IMDServiceProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A10-33ED-11d3-8470-00C04F79DBC0")
    IMDServiceProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceCount( 
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDevices( 
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDServiceProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDServiceProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDServiceProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IMDServiceProvider __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDevices )( 
            IMDServiceProvider __RPC_FAR * This,
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        END_INTERFACE
    } IMDServiceProviderVtbl;

    interface IMDServiceProvider
    {
        CONST_VTBL struct IMDServiceProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDServiceProvider_GetDeviceCount(This,pdwCount)	\
    (This)->lpVtbl -> GetDeviceCount(This,pdwCount)

#define IMDServiceProvider_EnumDevices(This,ppEnumDevice)	\
    (This)->lpVtbl -> EnumDevices(This,ppEnumDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDServiceProvider_GetDeviceCount_Proxy( 
    IMDServiceProvider __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IMDServiceProvider_GetDeviceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDServiceProvider_EnumDevices_Proxy( 
    IMDServiceProvider __RPC_FAR * This,
    /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);


void __RPC_STUB IMDServiceProvider_EnumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDServiceProvider_INTERFACE_DEFINED__ */


#ifndef __IMDServiceProvider2_INTERFACE_DEFINED__
#define __IMDServiceProvider2_INTERFACE_DEFINED__

/* interface IMDServiceProvider2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDServiceProvider2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2FA24B7-CDA3-4694-9862-413AE1A34819")
    IMDServiceProvider2 : public IMDServiceProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceFromPnPName( 
            /* [string][in] */ LPCWSTR pwszPnPName,
            /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDServiceProvider2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDServiceProvider2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDServiceProvider2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDServiceProvider2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IMDServiceProvider2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDevices )( 
            IMDServiceProvider2 __RPC_FAR * This,
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceFromPnPName )( 
            IMDServiceProvider2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pwszPnPName,
            /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        END_INTERFACE
    } IMDServiceProvider2Vtbl;

    interface IMDServiceProvider2
    {
        CONST_VTBL struct IMDServiceProvider2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDServiceProvider2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDServiceProvider2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDServiceProvider2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDServiceProvider2_GetDeviceCount(This,pdwCount)	\
    (This)->lpVtbl -> GetDeviceCount(This,pdwCount)

#define IMDServiceProvider2_EnumDevices(This,ppEnumDevice)	\
    (This)->lpVtbl -> EnumDevices(This,ppEnumDevice)


#define IMDServiceProvider2_GetDeviceFromPnPName(This,pwszPnPName,ppDevice)	\
    (This)->lpVtbl -> GetDeviceFromPnPName(This,pwszPnPName,ppDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDServiceProvider2_GetDeviceFromPnPName_Proxy( 
    IMDServiceProvider2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pwszPnPName,
    /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IMDServiceProvider2_GetDeviceFromPnPName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDServiceProvider2_INTERFACE_DEFINED__ */


#ifndef __IMDSPEnumDevice_INTERFACE_DEFINED__
#define __IMDSPEnumDevice_INTERFACE_DEFINED__

/* interface IMDSPEnumDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPEnumDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A11-33ED-11d3-8470-00C04F79DBC0")
    IMDSPEnumDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPEnumDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPEnumDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPEnumDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPEnumDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IMDSPEnumDevice __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IMDSPEnumDevice __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IMDSPEnumDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IMDSPEnumDevice __RPC_FAR * This,
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        END_INTERFACE
    } IMDSPEnumDeviceVtbl;

    interface IMDSPEnumDevice
    {
        CONST_VTBL struct IMDSPEnumDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPEnumDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPEnumDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPEnumDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPEnumDevice_Next(This,celt,ppDevice,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppDevice,pceltFetched)

#define IMDSPEnumDevice_Skip(This,celt,pceltFetched)	\
    (This)->lpVtbl -> Skip(This,celt,pceltFetched)

#define IMDSPEnumDevice_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMDSPEnumDevice_Clone(This,ppEnumDevice)	\
    (This)->lpVtbl -> Clone(This,ppEnumDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPEnumDevice_Next_Proxy( 
    IMDSPEnumDevice __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IMDSPEnumDevice_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumDevice_Skip_Proxy( 
    IMDSPEnumDevice __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IMDSPEnumDevice_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumDevice_Reset_Proxy( 
    IMDSPEnumDevice __RPC_FAR * This);


void __RPC_STUB IMDSPEnumDevice_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumDevice_Clone_Proxy( 
    IMDSPEnumDevice __RPC_FAR * This,
    /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);


void __RPC_STUB IMDSPEnumDevice_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPEnumDevice_INTERFACE_DEFINED__ */


#ifndef __IMDSPDevice_INTERFACE_DEFINED__
#define __IMDSPDevice_INTERFACE_DEFINED__

/* interface IMDSPDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A12-33ED-11d3-8470-00C04F79DBC0")
    IMDSPDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManufacturer( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ DWORD __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ DWORD __RPC_FAR *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialNumber( 
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPowerSource( 
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceIcon( 
            /* [out] */ ULONG __RPC_FAR *hIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStorage( 
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormatSupport( 
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *pFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendOpaqueCommand( 
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IMDSPDevice __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManufacturer )( 
            IMDSPDevice __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPowerSource )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIcon )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *hIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport )( 
            IMDSPDevice __RPC_FAR * This,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *pFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        END_INTERFACE
    } IMDSPDeviceVtbl;

    interface IMDSPDevice
    {
        CONST_VTBL struct IMDSPDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPDevice_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IMDSPDevice_GetManufacturer(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetManufacturer(This,pwszName,nMaxChars)

#define IMDSPDevice_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IMDSPDevice_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#define IMDSPDevice_GetSerialNumber(This,pSerialNumber,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNumber,abMac)

#define IMDSPDevice_GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)	\
    (This)->lpVtbl -> GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)

#define IMDSPDevice_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IMDSPDevice_GetDeviceIcon(This,hIcon)	\
    (This)->lpVtbl -> GetDeviceIcon(This,hIcon)

#define IMDSPDevice_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IMDSPDevice_GetFormatSupport(This,pFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport(This,pFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)

#define IMDSPDevice_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPDevice_GetName_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IMDSPDevice_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetManufacturer_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IMDSPDevice_GetManufacturer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetVersion_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwVersion);


void __RPC_STUB IMDSPDevice_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetType_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwType);


void __RPC_STUB IMDSPDevice_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetSerialNumber_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ PWMDMID pSerialNumber,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPDevice_GetSerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetPowerSource_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
    /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);


void __RPC_STUB IMDSPDevice_GetPowerSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetStatus_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IMDSPDevice_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetDeviceIcon_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *hIcon);


void __RPC_STUB IMDSPDevice_GetDeviceIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_EnumStorage_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IMDSPDevice_EnumStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetFormatSupport_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *pFormatEx,
    /* [out] */ UINT __RPC_FAR *pnFormatCount,
    /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
    /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);


void __RPC_STUB IMDSPDevice_GetFormatSupport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_SendOpaqueCommand_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);


void __RPC_STUB IMDSPDevice_SendOpaqueCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPDevice_INTERFACE_DEFINED__ */


#ifndef __IMDSPDevice2_INTERFACE_DEFINED__
#define __IMDSPDevice2_INTERFACE_DEFINED__

/* interface IMDSPDevice2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPDevice2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("420D16AD-C97D-4e00-82AA-00E9F4335DDD")
    IMDSPDevice2 : public IMDSPDevice
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormatSupport2( 
            /* [in] */ DWORD dwFlags,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
            /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
            /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
            /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpecifyPropertyPages( 
            /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
            /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
            /* [ref][out] */ ULONG __RPC_FAR *pcUnks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPnPName( 
            /* [size_is][out] */ LPWSTR pwszPnPName,
            /* [in] */ UINT nMaxChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPDevice2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPDevice2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPDevice2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManufacturer )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPowerSource )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIcon )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *hIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *pFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorage )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport2 )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
            /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
            /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
            /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpecifyPropertyPages )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
            /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
            /* [ref][out] */ ULONG __RPC_FAR *pcUnks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPnPName )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [size_is][out] */ LPWSTR pwszPnPName,
            /* [in] */ UINT nMaxChars);
        
        END_INTERFACE
    } IMDSPDevice2Vtbl;

    interface IMDSPDevice2
    {
        CONST_VTBL struct IMDSPDevice2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPDevice2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPDevice2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPDevice2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPDevice2_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IMDSPDevice2_GetManufacturer(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetManufacturer(This,pwszName,nMaxChars)

#define IMDSPDevice2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IMDSPDevice2_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#define IMDSPDevice2_GetSerialNumber(This,pSerialNumber,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNumber,abMac)

#define IMDSPDevice2_GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)	\
    (This)->lpVtbl -> GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)

#define IMDSPDevice2_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IMDSPDevice2_GetDeviceIcon(This,hIcon)	\
    (This)->lpVtbl -> GetDeviceIcon(This,hIcon)

#define IMDSPDevice2_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IMDSPDevice2_GetFormatSupport(This,pFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport(This,pFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)

#define IMDSPDevice2_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)


#define IMDSPDevice2_GetStorage(This,pszStorageName,ppStorage)	\
    (This)->lpVtbl -> GetStorage(This,pszStorageName,ppStorage)

#define IMDSPDevice2_GetFormatSupport2(This,dwFlags,ppAudioFormatEx,pnAudioFormatCount,ppVideoFormatEx,pnVideoFormatCount,ppFileType,pnFileTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport2(This,dwFlags,ppAudioFormatEx,pnAudioFormatCount,ppVideoFormatEx,pnVideoFormatCount,ppFileType,pnFileTypeCount)

#define IMDSPDevice2_GetSpecifyPropertyPages(This,ppSpecifyPropPages,pppUnknowns,pcUnks)	\
    (This)->lpVtbl -> GetSpecifyPropertyPages(This,ppSpecifyPropPages,pppUnknowns,pcUnks)

#define IMDSPDevice2_GetPnPName(This,pwszPnPName,nMaxChars)	\
    (This)->lpVtbl -> GetPnPName(This,pwszPnPName,nMaxChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPDevice2_GetStorage_Proxy( 
    IMDSPDevice2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszStorageName,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage);


void __RPC_STUB IMDSPDevice2_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice2_GetFormatSupport2_Proxy( 
    IMDSPDevice2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
    /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
    /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
    /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
    /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
    /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount);


void __RPC_STUB IMDSPDevice2_GetFormatSupport2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice2_GetSpecifyPropertyPages_Proxy( 
    IMDSPDevice2 __RPC_FAR * This,
    /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
    /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
    /* [ref][out] */ ULONG __RPC_FAR *pcUnks);


void __RPC_STUB IMDSPDevice2_GetSpecifyPropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice2_GetPnPName_Proxy( 
    IMDSPDevice2 __RPC_FAR * This,
    /* [size_is][out] */ LPWSTR pwszPnPName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IMDSPDevice2_GetPnPName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPDevice2_INTERFACE_DEFINED__ */


#ifndef __IMDSPDeviceControl_INTERFACE_DEFINED__
#define __IMDSPDeviceControl_INTERFACE_DEFINED__

/* interface IMDSPDeviceControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPDeviceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A14-33ED-11d3-8470-00C04F79DBC0")
    IMDSPDeviceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDCStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Record( 
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ UINT fuMode,
            /* [in] */ int nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPDeviceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDCStatus )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Record )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ int nOffset);
        
        END_INTERFACE
    } IMDSPDeviceControlVtbl;

    interface IMDSPDeviceControl
    {
        CONST_VTBL struct IMDSPDeviceControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPDeviceControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPDeviceControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPDeviceControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPDeviceControl_GetDCStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetDCStatus(This,pdwStatus)

#define IMDSPDeviceControl_GetCapabilities(This,pdwCapabilitiesMask)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilitiesMask)

#define IMDSPDeviceControl_Play(This)	\
    (This)->lpVtbl -> Play(This)

#define IMDSPDeviceControl_Record(This,pFormat)	\
    (This)->lpVtbl -> Record(This,pFormat)

#define IMDSPDeviceControl_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMDSPDeviceControl_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IMDSPDeviceControl_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMDSPDeviceControl_Seek(This,fuMode,nOffset)	\
    (This)->lpVtbl -> Seek(This,fuMode,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_GetDCStatus_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IMDSPDeviceControl_GetDCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_GetCapabilities_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask);


void __RPC_STUB IMDSPDeviceControl_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Play_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This);


void __RPC_STUB IMDSPDeviceControl_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Record_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IMDSPDeviceControl_Record_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Pause_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This);


void __RPC_STUB IMDSPDeviceControl_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Resume_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This);


void __RPC_STUB IMDSPDeviceControl_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Stop_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This);


void __RPC_STUB IMDSPDeviceControl_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Seek_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ int nOffset);


void __RPC_STUB IMDSPDeviceControl_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPDeviceControl_INTERFACE_DEFINED__ */


#ifndef __IMDSPEnumStorage_INTERFACE_DEFINED__
#define __IMDSPEnumStorage_INTERFACE_DEFINED__

/* interface IMDSPEnumStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPEnumStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A15-33ED-11d3-8470-00C04F79DBC0")
    IMDSPEnumStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPEnumStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPEnumStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPEnumStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPEnumStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IMDSPEnumStorage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IMDSPEnumStorage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IMDSPEnumStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IMDSPEnumStorage __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        END_INTERFACE
    } IMDSPEnumStorageVtbl;

    interface IMDSPEnumStorage
    {
        CONST_VTBL struct IMDSPEnumStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPEnumStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPEnumStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPEnumStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPEnumStorage_Next(This,celt,ppStorage,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppStorage,pceltFetched)

#define IMDSPEnumStorage_Skip(This,celt,pceltFetched)	\
    (This)->lpVtbl -> Skip(This,celt,pceltFetched)

#define IMDSPEnumStorage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMDSPEnumStorage_Clone(This,ppEnumStorage)	\
    (This)->lpVtbl -> Clone(This,ppEnumStorage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPEnumStorage_Next_Proxy( 
    IMDSPEnumStorage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IMDSPEnumStorage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumStorage_Skip_Proxy( 
    IMDSPEnumStorage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IMDSPEnumStorage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumStorage_Reset_Proxy( 
    IMDSPEnumStorage __RPC_FAR * This);


void __RPC_STUB IMDSPEnumStorage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumStorage_Clone_Proxy( 
    IMDSPEnumStorage __RPC_FAR * This,
    /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IMDSPEnumStorage_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPEnumStorage_INTERFACE_DEFINED__ */


#ifndef __IMDSPStorage_INTERFACE_DEFINED__
#define __IMDSPStorage_INTERFACE_DEFINED__

/* interface IMDSPStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A16-33ED-11d3-8470-00C04F79DBC0")
    IMDSPStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttributes( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorageGlobals( 
            /* [out] */ IMDSPStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDate( 
            /* [out] */ PWMDMDATETIME pDateTimeUTC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRights( 
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStorage( 
            /* [in] */ DWORD dwAttributes,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ LPWSTR pwszName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStorage( 
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendOpaqueCommand( 
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes )( 
            IMDSPStorage __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageGlobals )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ IMDSPStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IMDSPStorage __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ PWMDMDATETIME pDateTimeUTC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            IMDSPStorage __RPC_FAR * This,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStorage )( 
            IMDSPStorage __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ LPWSTR pwszName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        END_INTERFACE
    } IMDSPStorageVtbl;

    interface IMDSPStorage
    {
        CONST_VTBL struct IMDSPStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPStorage_SetAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetAttributes(This,dwAttributes,pFormat)

#define IMDSPStorage_GetStorageGlobals(This,ppStorageGlobals)	\
    (This)->lpVtbl -> GetStorageGlobals(This,ppStorageGlobals)

#define IMDSPStorage_GetAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttributes,pFormat)

#define IMDSPStorage_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IMDSPStorage_GetDate(This,pDateTimeUTC)	\
    (This)->lpVtbl -> GetDate(This,pDateTimeUTC)

#define IMDSPStorage_GetSize(This,pdwSizeLow,pdwSizeHigh)	\
    (This)->lpVtbl -> GetSize(This,pdwSizeLow,pdwSizeHigh)

#define IMDSPStorage_GetRights(This,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,ppRights,pnRightsCount,abMac)

#define IMDSPStorage_CreateStorage(This,dwAttributes,pFormat,pwszName,ppNewStorage)	\
    (This)->lpVtbl -> CreateStorage(This,dwAttributes,pFormat,pwszName,ppNewStorage)

#define IMDSPStorage_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IMDSPStorage_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPStorage_SetAttributes_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IMDSPStorage_SetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetStorageGlobals_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ IMDSPStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);


void __RPC_STUB IMDSPStorage_GetStorageGlobals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetAttributes_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IMDSPStorage_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetName_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IMDSPStorage_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetDate_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ PWMDMDATETIME pDateTimeUTC);


void __RPC_STUB IMDSPStorage_GetDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetSize_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
    /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);


void __RPC_STUB IMDSPStorage_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetRights_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
    /* [out] */ UINT __RPC_FAR *pnRightsCount,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPStorage_GetRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_CreateStorage_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
    /* [in] */ LPWSTR pwszName,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);


void __RPC_STUB IMDSPStorage_CreateStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_EnumStorage_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IMDSPStorage_EnumStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_SendOpaqueCommand_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);


void __RPC_STUB IMDSPStorage_SendOpaqueCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPStorage_INTERFACE_DEFINED__ */


#ifndef __IMDSPStorage2_INTERFACE_DEFINED__
#define __IMDSPStorage2_INTERFACE_DEFINED__

/* interface IMDSPStorage2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPStorage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A5E07A5-6454-4451-9C36-1C6AE7E2B1D6")
    IMDSPStorage2 : public IMDSPStorage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStorage2( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [unique][in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat,
            /* [in] */ LPWSTR pwszName,
            /* [in] */ ULONGLONG qwFileSize,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttributes2( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes2( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPStorage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPStorage2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPStorage2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageGlobals )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ IMDSPStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ PWMDMDATETIME pDateTimeUTC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStorage )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ LPWSTR pwszName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorage )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStorage2 )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [unique][in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat,
            /* [in] */ LPWSTR pwszName,
            /* [in] */ ULONGLONG qwFileSize,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes2 )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes2 )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        END_INTERFACE
    } IMDSPStorage2Vtbl;

    interface IMDSPStorage2
    {
        CONST_VTBL struct IMDSPStorage2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPStorage2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPStorage2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPStorage2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPStorage2_SetAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetAttributes(This,dwAttributes,pFormat)

#define IMDSPStorage2_GetStorageGlobals(This,ppStorageGlobals)	\
    (This)->lpVtbl -> GetStorageGlobals(This,ppStorageGlobals)

#define IMDSPStorage2_GetAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttributes,pFormat)

#define IMDSPStorage2_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IMDSPStorage2_GetDate(This,pDateTimeUTC)	\
    (This)->lpVtbl -> GetDate(This,pDateTimeUTC)

#define IMDSPStorage2_GetSize(This,pdwSizeLow,pdwSizeHigh)	\
    (This)->lpVtbl -> GetSize(This,pdwSizeLow,pdwSizeHigh)

#define IMDSPStorage2_GetRights(This,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,ppRights,pnRightsCount,abMac)

#define IMDSPStorage2_CreateStorage(This,dwAttributes,pFormat,pwszName,ppNewStorage)	\
    (This)->lpVtbl -> CreateStorage(This,dwAttributes,pFormat,pwszName,ppNewStorage)

#define IMDSPStorage2_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IMDSPStorage2_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)


#define IMDSPStorage2_GetStorage(This,pszStorageName,ppStorage)	\
    (This)->lpVtbl -> GetStorage(This,pszStorageName,ppStorage)

#define IMDSPStorage2_CreateStorage2(This,dwAttributes,dwAttributesEx,pAudioFormat,pVideoFormat,pwszName,qwFileSize,ppNewStorage)	\
    (This)->lpVtbl -> CreateStorage2(This,dwAttributes,dwAttributesEx,pAudioFormat,pVideoFormat,pwszName,qwFileSize,ppNewStorage)

#define IMDSPStorage2_SetAttributes2(This,dwAttributes,dwAttributesEx,pAudioFormat,pVideoFormat)	\
    (This)->lpVtbl -> SetAttributes2(This,dwAttributes,dwAttributesEx,pAudioFormat,pVideoFormat)

#define IMDSPStorage2_GetAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)	\
    (This)->lpVtbl -> GetAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPStorage2_GetStorage_Proxy( 
    IMDSPStorage2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszStorageName,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage);


void __RPC_STUB IMDSPStorage2_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage2_CreateStorage2_Proxy( 
    IMDSPStorage2 __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ DWORD dwAttributesEx,
    /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [unique][in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat,
    /* [in] */ LPWSTR pwszName,
    /* [in] */ ULONGLONG qwFileSize,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);


void __RPC_STUB IMDSPStorage2_CreateStorage2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage2_SetAttributes2_Proxy( 
    IMDSPStorage2 __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ DWORD dwAttributesEx,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IMDSPStorage2_SetAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage2_GetAttributes2_Proxy( 
    IMDSPStorage2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IMDSPStorage2_GetAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPStorage2_INTERFACE_DEFINED__ */


#ifndef __IMDSPStorageGlobals_INTERFACE_DEFINED__
#define __IMDSPStorageGlobals_INTERFACE_DEFINED__

/* interface IMDSPStorageGlobals */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPStorageGlobals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A17-33ED-11d3-8470-00C04F79DBC0")
    IMDSPStorageGlobals : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialNumber( 
            /* [out] */ PWMDMID pSerialNum,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalSize( 
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalFree( 
            /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
            /* [out] */ DWORD __RPC_FAR *pdwFreeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalBad( 
            /* [out] */ DWORD __RPC_FAR *pdwBadLow,
            /* [out] */ DWORD __RPC_FAR *pdwBadHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevice( 
            /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootStorage( 
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppRoot) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPStorageGlobalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPStorageGlobals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPStorageGlobals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNum,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalSize )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalFree )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
            /* [out] */ DWORD __RPC_FAR *pdwFreeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalBad )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBadLow,
            /* [out] */ DWORD __RPC_FAR *pdwBadHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDevice )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootStorage )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppRoot);
        
        END_INTERFACE
    } IMDSPStorageGlobalsVtbl;

    interface IMDSPStorageGlobals
    {
        CONST_VTBL struct IMDSPStorageGlobalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPStorageGlobals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPStorageGlobals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPStorageGlobals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPStorageGlobals_GetCapabilities(This,pdwCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities)

#define IMDSPStorageGlobals_GetSerialNumber(This,pSerialNum,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNum,abMac)

#define IMDSPStorageGlobals_GetTotalSize(This,pdwTotalSizeLow,pdwTotalSizeHigh)	\
    (This)->lpVtbl -> GetTotalSize(This,pdwTotalSizeLow,pdwTotalSizeHigh)

#define IMDSPStorageGlobals_GetTotalFree(This,pdwFreeLow,pdwFreeHigh)	\
    (This)->lpVtbl -> GetTotalFree(This,pdwFreeLow,pdwFreeHigh)

#define IMDSPStorageGlobals_GetTotalBad(This,pdwBadLow,pdwBadHigh)	\
    (This)->lpVtbl -> GetTotalBad(This,pdwBadLow,pdwBadHigh)

#define IMDSPStorageGlobals_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IMDSPStorageGlobals_Initialize(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Initialize(This,fuMode,pProgress)

#define IMDSPStorageGlobals_GetDevice(This,ppDevice)	\
    (This)->lpVtbl -> GetDevice(This,ppDevice)

#define IMDSPStorageGlobals_GetRootStorage(This,ppRoot)	\
    (This)->lpVtbl -> GetRootStorage(This,ppRoot)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetCapabilities_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilities);


void __RPC_STUB IMDSPStorageGlobals_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetSerialNumber_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ PWMDMID pSerialNum,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPStorageGlobals_GetSerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetTotalSize_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
    /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh);


void __RPC_STUB IMDSPStorageGlobals_GetTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetTotalFree_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
    /* [out] */ DWORD __RPC_FAR *pdwFreeHigh);


void __RPC_STUB IMDSPStorageGlobals_GetTotalFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetTotalBad_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBadLow,
    /* [out] */ DWORD __RPC_FAR *pdwBadHigh);


void __RPC_STUB IMDSPStorageGlobals_GetTotalBad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetStatus_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IMDSPStorageGlobals_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_Initialize_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IMDSPStorageGlobals_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetDevice_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IMDSPStorageGlobals_GetDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetRootStorage_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppRoot);


void __RPC_STUB IMDSPStorageGlobals_GetRootStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPStorageGlobals_INTERFACE_DEFINED__ */


#ifndef __IMDSPObjectInfo_INTERFACE_DEFINED__
#define __IMDSPObjectInfo_INTERFACE_DEFINED__

/* interface IMDSPObjectInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPObjectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A19-33ED-11d3-8470-00C04F79DBC0")
    IMDSPObjectInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPlayLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayOffset( 
            /* [out] */ DWORD __RPC_FAR *pdwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayOffset( 
            /* [in] */ DWORD dwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPlayPosition( 
            /* [out] */ DWORD __RPC_FAR *pdwLastPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLongestPlayPosition( 
            /* [out] */ DWORD __RPC_FAR *pdwLongestPos) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPObjectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPObjectInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPObjectInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayLength )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayLength )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayOffset )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayOffset )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [in] */ DWORD dwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalLength )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastPlayPosition )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLastPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLongestPlayPosition )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLongestPos);
        
        END_INTERFACE
    } IMDSPObjectInfoVtbl;

    interface IMDSPObjectInfo
    {
        CONST_VTBL struct IMDSPObjectInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPObjectInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPObjectInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPObjectInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPObjectInfo_GetPlayLength(This,pdwLength)	\
    (This)->lpVtbl -> GetPlayLength(This,pdwLength)

#define IMDSPObjectInfo_SetPlayLength(This,dwLength)	\
    (This)->lpVtbl -> SetPlayLength(This,dwLength)

#define IMDSPObjectInfo_GetPlayOffset(This,pdwOffset)	\
    (This)->lpVtbl -> GetPlayOffset(This,pdwOffset)

#define IMDSPObjectInfo_SetPlayOffset(This,dwOffset)	\
    (This)->lpVtbl -> SetPlayOffset(This,dwOffset)

#define IMDSPObjectInfo_GetTotalLength(This,pdwLength)	\
    (This)->lpVtbl -> GetTotalLength(This,pdwLength)

#define IMDSPObjectInfo_GetLastPlayPosition(This,pdwLastPos)	\
    (This)->lpVtbl -> GetLastPlayPosition(This,pdwLastPos)

#define IMDSPObjectInfo_GetLongestPlayPosition(This,pdwLongestPos)	\
    (This)->lpVtbl -> GetLongestPlayPosition(This,pdwLongestPos)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetPlayLength_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IMDSPObjectInfo_GetPlayLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_SetPlayLength_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB IMDSPObjectInfo_SetPlayLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetPlayOffset_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwOffset);


void __RPC_STUB IMDSPObjectInfo_GetPlayOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_SetPlayOffset_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOffset);


void __RPC_STUB IMDSPObjectInfo_SetPlayOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetTotalLength_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IMDSPObjectInfo_GetTotalLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetLastPlayPosition_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLastPos);


void __RPC_STUB IMDSPObjectInfo_GetLastPlayPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetLongestPlayPosition_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLongestPos);


void __RPC_STUB IMDSPObjectInfo_GetLongestPlayPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPObjectInfo_INTERFACE_DEFINED__ */


#ifndef __IMDSPObject_INTERFACE_DEFINED__
#define __IMDSPObject_INTERFACE_DEFINED__

/* interface IMDSPObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A18-33ED-11d3-8470-00C04F79DBC0")
    IMDSPObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ UINT fuMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [size_is][out] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ UINT fuFlags,
            /* [in] */ DWORD dwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rename( 
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IMDSPStorage __RPC_FAR *pTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ UINT fuMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IMDSPObject __RPC_FAR * This,
            /* [size_is][out] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IMDSPObject __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [in] */ DWORD dwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rename )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IMDSPStorage __RPC_FAR *pTarget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IMDSPObject __RPC_FAR * This);
        
        END_INTERFACE
    } IMDSPObjectVtbl;

    interface IMDSPObject
    {
        CONST_VTBL struct IMDSPObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPObject_Open(This,fuMode)	\
    (This)->lpVtbl -> Open(This,fuMode)

#define IMDSPObject_Read(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> Read(This,pData,pdwSize,abMac)

#define IMDSPObject_Write(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> Write(This,pData,pdwSize,abMac)

#define IMDSPObject_Delete(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Delete(This,fuMode,pProgress)

#define IMDSPObject_Seek(This,fuFlags,dwOffset)	\
    (This)->lpVtbl -> Seek(This,fuFlags,dwOffset)

#define IMDSPObject_Rename(This,pwszNewName,pProgress)	\
    (This)->lpVtbl -> Rename(This,pwszNewName,pProgress)

#define IMDSPObject_Move(This,fuMode,pProgress,pTarget)	\
    (This)->lpVtbl -> Move(This,fuMode,pProgress,pTarget)

#define IMDSPObject_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPObject_Open_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ UINT fuMode);


void __RPC_STUB IMDSPObject_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Read_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [size_is][out] */ BYTE __RPC_FAR *pData,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPObject_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Write_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPObject_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Delete_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IMDSPObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Seek_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ UINT fuFlags,
    /* [in] */ DWORD dwOffset);


void __RPC_STUB IMDSPObject_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Rename_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ LPWSTR pwszNewName,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IMDSPObject_Rename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Move_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
    /* [in] */ IMDSPStorage __RPC_FAR *pTarget);


void __RPC_STUB IMDSPObject_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Close_Proxy( 
    IMDSPObject __RPC_FAR * This);


void __RPC_STUB IMDSPObject_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPObject_INTERFACE_DEFINED__ */


#ifndef __IMDSPRevoked_INTERFACE_DEFINED__
#define __IMDSPRevoked_INTERFACE_DEFINED__

/* interface IMDSPRevoked */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPRevoked;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4E8F2D4-3F31-464d-B53D-4FC335998184")
    IMDSPRevoked : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRevocationURL( 
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPRevokedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPRevoked __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPRevoked __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPRevoked __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRevocationURL )( 
            IMDSPRevoked __RPC_FAR * This,
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen);
        
        END_INTERFACE
    } IMDSPRevokedVtbl;

    interface IMDSPRevoked
    {
        CONST_VTBL struct IMDSPRevokedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPRevoked_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPRevoked_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPRevoked_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPRevoked_GetRevocationURL(This,ppwszRevocationURL,pdwBufferLen)	\
    (This)->lpVtbl -> GetRevocationURL(This,ppwszRevocationURL,pdwBufferLen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPRevoked_GetRevocationURL_Proxy( 
    IMDSPRevoked __RPC_FAR * This,
    /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
    /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen);


void __RPC_STUB IMDSPRevoked_GetRevocationURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPRevoked_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mswmdm_0242 */
/* [local] */ 

// SCP Data Flags
#define WMDM_SCP_EXAMINE_EXTENSION                 0x00000001L
#define WMDM_SCP_EXAMINE_DATA                      0x00000002L
#define WMDM_SCP_DECIDE_DATA                       0x00000008L
#define WMDM_SCP_PROTECTED_OUTPUT                  0x00000010L
#define WMDM_SCP_UNPROTECTED_OUTPUT                0x00000020L
#define WMDM_SCP_RIGHTS_DATA                       0x00000040L
// SCP Transfer Flags
#define WMDM_SCP_TRANSFER_OBJECTDATA               0x00000020L
#define WMDM_SCP_NO_MORE_CHANGES                   0x00000040L





extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0242_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0242_v0_0_s_ifspec;

#ifndef __ISCPSecureAuthenticate_INTERFACE_DEFINED__
#define __ISCPSecureAuthenticate_INTERFACE_DEFINED__

/* interface ISCPSecureAuthenticate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISCPSecureAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0F-33ED-11d3-8470-00C04F79DBC0")
    ISCPSecureAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSecureQuery( 
            /* [out] */ ISCPSecureQuery __RPC_FAR *__RPC_FAR *ppSecureQuery) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCPSecureAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCPSecureAuthenticate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCPSecureAuthenticate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCPSecureAuthenticate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureQuery )( 
            ISCPSecureAuthenticate __RPC_FAR * This,
            /* [out] */ ISCPSecureQuery __RPC_FAR *__RPC_FAR *ppSecureQuery);
        
        END_INTERFACE
    } ISCPSecureAuthenticateVtbl;

    interface ISCPSecureAuthenticate
    {
        CONST_VTBL struct ISCPSecureAuthenticateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCPSecureAuthenticate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCPSecureAuthenticate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCPSecureAuthenticate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCPSecureAuthenticate_GetSecureQuery(This,ppSecureQuery)	\
    (This)->lpVtbl -> GetSecureQuery(This,ppSecureQuery)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCPSecureAuthenticate_GetSecureQuery_Proxy( 
    ISCPSecureAuthenticate __RPC_FAR * This,
    /* [out] */ ISCPSecureQuery __RPC_FAR *__RPC_FAR *ppSecureQuery);


void __RPC_STUB ISCPSecureAuthenticate_GetSecureQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCPSecureAuthenticate_INTERFACE_DEFINED__ */


#ifndef __ISCPSecureQuery_INTERFACE_DEFINED__
#define __ISCPSecureQuery_INTERFACE_DEFINED__

/* interface ISCPSecureQuery */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISCPSecureQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0D-33ED-11d3-8470-00C04F79DBC0")
    ISCPSecureQuery : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDataDemands( 
            /* [out] */ UINT __RPC_FAR *pfuFlags,
            /* [out] */ DWORD __RPC_FAR *pdwMinRightsData,
            /* [out] */ DWORD __RPC_FAR *pdwMinExamineData,
            /* [out] */ DWORD __RPC_FAR *pdwMinDecideData,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExamineData( 
            /* [in] */ UINT fuFlags,
            /* [unique][string][in] */ LPWSTR pwszExtension,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeDecision( 
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRights( 
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStgGlobals,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCPSecureQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCPSecureQuery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCPSecureQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataDemands )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pfuFlags,
            /* [out] */ DWORD __RPC_FAR *pdwMinRightsData,
            /* [out] */ DWORD __RPC_FAR *pdwMinExamineData,
            /* [out] */ DWORD __RPC_FAR *pdwMinDecideData,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExamineData )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [unique][string][in] */ LPWSTR pwszExtension,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeDecision )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStgGlobals,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        END_INTERFACE
    } ISCPSecureQueryVtbl;

    interface ISCPSecureQuery
    {
        CONST_VTBL struct ISCPSecureQueryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCPSecureQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCPSecureQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCPSecureQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCPSecureQuery_GetDataDemands(This,pfuFlags,pdwMinRightsData,pdwMinExamineData,pdwMinDecideData,abMac)	\
    (This)->lpVtbl -> GetDataDemands(This,pfuFlags,pdwMinRightsData,pdwMinExamineData,pdwMinDecideData,abMac)

#define ISCPSecureQuery_ExamineData(This,fuFlags,pwszExtension,pData,dwSize,abMac)	\
    (This)->lpVtbl -> ExamineData(This,fuFlags,pwszExtension,pData,dwSize,abMac)

#define ISCPSecureQuery_MakeDecision(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,ppExchange,abMac)	\
    (This)->lpVtbl -> MakeDecision(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,ppExchange,abMac)

#define ISCPSecureQuery_GetRights(This,pData,dwSize,pbSPSessionKey,dwSessionKeyLen,pStgGlobals,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,pData,dwSize,pbSPSessionKey,dwSessionKeyLen,pStgGlobals,ppRights,pnRightsCount,abMac)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCPSecureQuery_GetDataDemands_Proxy( 
    ISCPSecureQuery __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pfuFlags,
    /* [out] */ DWORD __RPC_FAR *pdwMinRightsData,
    /* [out] */ DWORD __RPC_FAR *pdwMinExamineData,
    /* [out] */ DWORD __RPC_FAR *pdwMinDecideData,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery_GetDataDemands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureQuery_ExamineData_Proxy( 
    ISCPSecureQuery __RPC_FAR * This,
    /* [in] */ UINT fuFlags,
    /* [unique][string][in] */ LPWSTR pwszExtension,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery_ExamineData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureQuery_MakeDecision_Proxy( 
    ISCPSecureQuery __RPC_FAR * This,
    /* [in] */ UINT fuFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAppSec,
    /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
    /* [in] */ DWORD dwSessionKeyLen,
    /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
    /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery_MakeDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureQuery_GetRights_Proxy( 
    ISCPSecureQuery __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
    /* [in] */ DWORD dwSessionKeyLen,
    /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStgGlobals,
    /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
    /* [out] */ UINT __RPC_FAR *pnRightsCount,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery_GetRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCPSecureQuery_INTERFACE_DEFINED__ */


#ifndef __ISCPSecureQuery2_INTERFACE_DEFINED__
#define __ISCPSecureQuery2_INTERFACE_DEFINED__

/* interface ISCPSecureQuery2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISCPSecureQuery2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EBE17E25-4FD7-4632-AF46-6D93D4FCC72E")
    ISCPSecureQuery2 : public ISCPSecureQuery
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MakeDecision2( 
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [size_is][in] */ BYTE __RPC_FAR *pAppCertApp,
            /* [in] */ DWORD dwAppCertAppLen,
            /* [size_is][in] */ BYTE __RPC_FAR *pAppCertSP,
            /* [in] */ DWORD dwAppCertSPLen,
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *pszRevocationURL,
            /* [ref][out][in] */ DWORD __RPC_FAR *pdwRevocationURLLen,
            /* [out] */ DWORD __RPC_FAR *pdwRevocationBitFlag,
            /* [unique][out][in] */ ULONGLONG __RPC_FAR *pqwFileSize,
            /* [in] */ IUnknown __RPC_FAR *pUnknown,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCPSecureQuery2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCPSecureQuery2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCPSecureQuery2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataDemands )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pfuFlags,
            /* [out] */ DWORD __RPC_FAR *pdwMinRightsData,
            /* [out] */ DWORD __RPC_FAR *pdwMinExamineData,
            /* [out] */ DWORD __RPC_FAR *pdwMinDecideData,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExamineData )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [unique][string][in] */ LPWSTR pwszExtension,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeDecision )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStgGlobals,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeDecision2 )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [size_is][in] */ BYTE __RPC_FAR *pAppCertApp,
            /* [in] */ DWORD dwAppCertAppLen,
            /* [size_is][in] */ BYTE __RPC_FAR *pAppCertSP,
            /* [in] */ DWORD dwAppCertSPLen,
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *pszRevocationURL,
            /* [ref][out][in] */ DWORD __RPC_FAR *pdwRevocationURLLen,
            /* [out] */ DWORD __RPC_FAR *pdwRevocationBitFlag,
            /* [unique][out][in] */ ULONGLONG __RPC_FAR *pqwFileSize,
            /* [in] */ IUnknown __RPC_FAR *pUnknown,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        END_INTERFACE
    } ISCPSecureQuery2Vtbl;

    interface ISCPSecureQuery2
    {
        CONST_VTBL struct ISCPSecureQuery2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCPSecureQuery2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCPSecureQuery2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCPSecureQuery2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCPSecureQuery2_GetDataDemands(This,pfuFlags,pdwMinRightsData,pdwMinExamineData,pdwMinDecideData,abMac)	\
    (This)->lpVtbl -> GetDataDemands(This,pfuFlags,pdwMinRightsData,pdwMinExamineData,pdwMinDecideData,abMac)

#define ISCPSecureQuery2_ExamineData(This,fuFlags,pwszExtension,pData,dwSize,abMac)	\
    (This)->lpVtbl -> ExamineData(This,fuFlags,pwszExtension,pData,dwSize,abMac)

#define ISCPSecureQuery2_MakeDecision(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,ppExchange,abMac)	\
    (This)->lpVtbl -> MakeDecision(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,ppExchange,abMac)

#define ISCPSecureQuery2_GetRights(This,pData,dwSize,pbSPSessionKey,dwSessionKeyLen,pStgGlobals,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,pData,dwSize,pbSPSessionKey,dwSessionKeyLen,pStgGlobals,ppRights,pnRightsCount,abMac)


#define ISCPSecureQuery2_MakeDecision2(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,pAppCertApp,dwAppCertAppLen,pAppCertSP,dwAppCertSPLen,pszRevocationURL,pdwRevocationURLLen,pdwRevocationBitFlag,pqwFileSize,pUnknown,ppExchange,abMac)	\
    (This)->lpVtbl -> MakeDecision2(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,pAppCertApp,dwAppCertAppLen,pAppCertSP,dwAppCertSPLen,pszRevocationURL,pdwRevocationURLLen,pdwRevocationBitFlag,pqwFileSize,pUnknown,ppExchange,abMac)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCPSecureQuery2_MakeDecision2_Proxy( 
    ISCPSecureQuery2 __RPC_FAR * This,
    /* [in] */ UINT fuFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAppSec,
    /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
    /* [in] */ DWORD dwSessionKeyLen,
    /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
    /* [size_is][in] */ BYTE __RPC_FAR *pAppCertApp,
    /* [in] */ DWORD dwAppCertAppLen,
    /* [size_is][in] */ BYTE __RPC_FAR *pAppCertSP,
    /* [in] */ DWORD dwAppCertSPLen,
    /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *pszRevocationURL,
    /* [ref][out][in] */ DWORD __RPC_FAR *pdwRevocationURLLen,
    /* [out] */ DWORD __RPC_FAR *pdwRevocationBitFlag,
    /* [unique][out][in] */ ULONGLONG __RPC_FAR *pqwFileSize,
    /* [in] */ IUnknown __RPC_FAR *pUnknown,
    /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery2_MakeDecision2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCPSecureQuery2_INTERFACE_DEFINED__ */


#ifndef __ISCPSecureExchange_INTERFACE_DEFINED__
#define __ISCPSecureExchange_INTERFACE_DEFINED__

/* interface ISCPSecureExchange */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISCPSecureExchange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0E-33ED-11d3-8470-00C04F79DBC0")
    ISCPSecureExchange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TransferContainerData( 
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out] */ UINT __RPC_FAR *pfuReadyFlags,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectData( 
            /* [size_is][out] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TransferComplete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCPSecureExchangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCPSecureExchange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCPSecureExchange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCPSecureExchange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransferContainerData )( 
            ISCPSecureExchange __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out] */ UINT __RPC_FAR *pfuReadyFlags,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ObjectData )( 
            ISCPSecureExchange __RPC_FAR * This,
            /* [size_is][out] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransferComplete )( 
            ISCPSecureExchange __RPC_FAR * This);
        
        END_INTERFACE
    } ISCPSecureExchangeVtbl;

    interface ISCPSecureExchange
    {
        CONST_VTBL struct ISCPSecureExchangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCPSecureExchange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCPSecureExchange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCPSecureExchange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCPSecureExchange_TransferContainerData(This,pData,dwSize,pfuReadyFlags,abMac)	\
    (This)->lpVtbl -> TransferContainerData(This,pData,dwSize,pfuReadyFlags,abMac)

#define ISCPSecureExchange_ObjectData(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> ObjectData(This,pData,pdwSize,abMac)

#define ISCPSecureExchange_TransferComplete(This)	\
    (This)->lpVtbl -> TransferComplete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCPSecureExchange_TransferContainerData_Proxy( 
    ISCPSecureExchange __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [out] */ UINT __RPC_FAR *pfuReadyFlags,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureExchange_TransferContainerData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureExchange_ObjectData_Proxy( 
    ISCPSecureExchange __RPC_FAR * This,
    /* [size_is][out] */ BYTE __RPC_FAR *pData,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureExchange_ObjectData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureExchange_TransferComplete_Proxy( 
    ISCPSecureExchange __RPC_FAR * This);


void __RPC_STUB ISCPSecureExchange_TransferComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCPSecureExchange_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mswmdm_0246 */
/* [local] */ 

#define SAC_MAC_LEN 8


extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0246_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0246_v0_0_s_ifspec;

#ifndef __IComponentAuthenticate_INTERFACE_DEFINED__
#define __IComponentAuthenticate_INTERFACE_DEFINED__

/* interface IComponentAuthenticate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IComponentAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9889C00-6D2B-11d3-8496-00C04F79DBC0")
    IComponentAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SACAuth( 
            /* [in] */ DWORD dwProtocolID,
            /* [in] */ DWORD dwPass,
            /* [size_is][in] */ BYTE __RPC_FAR *pbDataIn,
            /* [in] */ DWORD dwDataInLen,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwDataOutLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SACGetProtocols( 
            /* [size_is][size_is][out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwProtocols,
            /* [out] */ DWORD __RPC_FAR *pdwProtocolCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentAuthenticate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentAuthenticate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentAuthenticate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SACAuth )( 
            IComponentAuthenticate __RPC_FAR * This,
            /* [in] */ DWORD dwProtocolID,
            /* [in] */ DWORD dwPass,
            /* [size_is][in] */ BYTE __RPC_FAR *pbDataIn,
            /* [in] */ DWORD dwDataInLen,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwDataOutLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SACGetProtocols )( 
            IComponentAuthenticate __RPC_FAR * This,
            /* [size_is][size_is][out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwProtocols,
            /* [out] */ DWORD __RPC_FAR *pdwProtocolCount);
        
        END_INTERFACE
    } IComponentAuthenticateVtbl;

    interface IComponentAuthenticate
    {
        CONST_VTBL struct IComponentAuthenticateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentAuthenticate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentAuthenticate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentAuthenticate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentAuthenticate_SACAuth(This,dwProtocolID,dwPass,pbDataIn,dwDataInLen,ppbDataOut,pdwDataOutLen)	\
    (This)->lpVtbl -> SACAuth(This,dwProtocolID,dwPass,pbDataIn,dwDataInLen,ppbDataOut,pdwDataOutLen)

#define IComponentAuthenticate_SACGetProtocols(This,ppdwProtocols,pdwProtocolCount)	\
    (This)->lpVtbl -> SACGetProtocols(This,ppdwProtocols,pdwProtocolCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComponentAuthenticate_SACAuth_Proxy( 
    IComponentAuthenticate __RPC_FAR * This,
    /* [in] */ DWORD dwProtocolID,
    /* [in] */ DWORD dwPass,
    /* [size_is][in] */ BYTE __RPC_FAR *pbDataIn,
    /* [in] */ DWORD dwDataInLen,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwDataOutLen);


void __RPC_STUB IComponentAuthenticate_SACAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComponentAuthenticate_SACGetProtocols_Proxy( 
    IComponentAuthenticate __RPC_FAR * This,
    /* [size_is][size_is][out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwProtocols,
    /* [out] */ DWORD __RPC_FAR *pdwProtocolCount);


void __RPC_STUB IComponentAuthenticate_SACGetProtocols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentAuthenticate_INTERFACE_DEFINED__ */



#ifndef __MSWMDMLib_LIBRARY_DEFINED__
#define __MSWMDMLib_LIBRARY_DEFINED__

/* library MSWMDMLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_MSWMDMLib;

EXTERN_C const CLSID CLSID_MediaDevMgrClassFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("50040C1D-BDBF-4924-B873-F14D6C5BFD66")
MediaDevMgrClassFactory;
#endif

EXTERN_C const CLSID CLSID_MediaDevMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("25BAAD81-3560-11D3-8471-00C04F79DBC0")
MediaDevMgr;
#endif

EXTERN_C const CLSID CLSID_WMDMDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("807B3CDF-357A-11d3-8471-00C04F79DBC0")
WMDMDevice;
#endif

EXTERN_C const CLSID CLSID_WMDMStorage;

#ifdef __cplusplus

class DECLSPEC_UUID("807B3CE0-357A-11d3-8471-00C04F79DBC0")
WMDMStorage;
#endif

EXTERN_C const CLSID CLSID_WMDMStorageGlobal;

#ifdef __cplusplus

class DECLSPEC_UUID("807B3CE1-357A-11d3-8471-00C04F79DBC0")
WMDMStorageGlobal;
#endif

EXTERN_C const CLSID CLSID_WMDMDeviceEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("430E35AF-3971-11D3-8474-00C04F79DBC0")
WMDMDeviceEnum;
#endif

EXTERN_C const CLSID CLSID_WMDMStorageEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("EB401A3B-3AF7-11d3-8474-00C04F79DBC0")
WMDMStorageEnum;
#endif
#endif /* __MSWMDMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\drmexternals.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun Mar 18 02:44:39 2001
 */
/* Compiler settings for .\drmexternals.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __drmexternals_h__
#define __drmexternals_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDRMStatusCallback_FWD_DEFINED__
#define __IDRMStatusCallback_FWD_DEFINED__
typedef interface IDRMStatusCallback IDRMStatusCallback;
#endif 	/* __IDRMStatusCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_drmexternals_0000 */
/* [local] */ 

static const WCHAR *g_wszWMDRM_ASFV1                = L"ASFV1";
static const WCHAR *g_wszWMDRM_ASFV2                = L"ASFV2";
static const WCHAR *g_wszWMDRM_RIGHT_PLAYBACK                = L"Play";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_CD              = L"Print.redbook";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_SDMI_DEVICE     = L"Transfer.SDMI";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE = L"Transfer.NONSDMI";
static const WCHAR *g_wszWMDRM_RIGHT_BACKUP                  = L"Backup";
static const WCHAR *g_wszWMDRM_ActionAllowed                = L"ActionAllowed.";
static const WCHAR *g_wszWMDRM_LicenseState                 = L"LicenseStateData.";
static const WCHAR *g_wszWMDRM_DRMHeader                    = L"DRMHeader.";
static const WCHAR *g_wszWMDRM_IsDRM                             = L"IsDRM";
static const WCHAR *g_wszWMDRM_IsDRMCached                       = L"IsDRMCached";
static const WCHAR *g_wszWMDRM_ActionAllowed_Playback            = L"ActionAllowed.Play";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToCD            = L"ActionAllowed.Print.redbook";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToSDMIDevice    = L"ActionAllowed.Transfer.SDMI";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToNonSDMIDevice = L"ActionAllowed.Transfer.NONSDMI";
static const WCHAR *g_wszWMDRM_ActionAllowed_Backup              = L"ActionAllowed.Backup";
static const WCHAR *g_wszWMDRM_LicenseState_Playback             = L"LicenseStateData.Play";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToCD             = L"LicenseStateData.Print.redbook";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToSDMIDevice     = L"LicenseStateData.Transfer.SDMI";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToNonSDMIDevice  = L"LicenseStateData.Transfer.NONSDMI";
typedef 
enum DRM_LICENSE_STATE_CATEGORY
    {	WM_DRM_LICENSE_STATE_NORIGHT	= 0,
	WM_DRM_LICENSE_STATE_UNLIM	= WM_DRM_LICENSE_STATE_NORIGHT + 1,
	WM_DRM_LICENSE_STATE_COUNT	= WM_DRM_LICENSE_STATE_UNLIM + 1,
	WM_DRM_LICENSE_STATE_FROM	= WM_DRM_LICENSE_STATE_COUNT + 1,
	WM_DRM_LICENSE_STATE_UNTIL	= WM_DRM_LICENSE_STATE_FROM + 1,
	WM_DRM_LICENSE_STATE_FROM_UNTIL	= WM_DRM_LICENSE_STATE_UNTIL + 1,
	WM_DRM_LICENSE_STATE_COUNT_FROM	= WM_DRM_LICENSE_STATE_FROM_UNTIL + 1,
	WM_DRM_LICENSE_STATE_COUNT_UNTIL	= WM_DRM_LICENSE_STATE_COUNT_FROM + 1,
	WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL	= WM_DRM_LICENSE_STATE_COUNT_UNTIL + 1,
	WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE	= WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL + 1
    }	DRM_LICENSE_STATE_CATEGORY;

typedef struct  _DRM_LICENSE_STATE_DATA
    {
    DWORD dwStreamId;
    DRM_LICENSE_STATE_CATEGORY dwCategory;
    DWORD dwNumCounts;
    DWORD dwCount[ 4 ];
    DWORD dwNumDates;
    FILETIME datetime[ 4 ];
    DWORD dwVague;
    }	DRM_LICENSE_STATE_DATA;

typedef 
enum DRM_HTTP_STATUS
    {	HTTP_NOTINITIATED	= 0,
	HTTP_CONNECTING	= HTTP_NOTINITIATED + 1,
	HTTP_REQUESTING	= HTTP_CONNECTING + 1,
	HTTP_RECEIVING	= HTTP_REQUESTING + 1,
	HTTP_COMPLETED	= HTTP_RECEIVING + 1
    }	DRM_HTTP_STATUS;

typedef 
enum DRM_INDIVIDUALIZATION_STATUS
    {	INDI_UNDEFINED	= 0,
	INDI_BEGIN	= 0x1,
	INDI_SUCCEED	= 0x2,
	INDI_FAIL	= 0x4,
	INDI_CANCEL	= 0x8,
	INDI_DOWNLOAD	= 0x10,
	INDI_INSTALL	= 0x20
    }	DRM_INDIVIDUALIZATION_STATUS;

typedef struct  _WMIndividualizeStatus
    {
    HRESULT hr;
    DRM_INDIVIDUALIZATION_STATUS enIndiStatus;
    LPSTR pszIndiRespUrl;
    DWORD dwHTTPRequest;
    DRM_HTTP_STATUS enHTTPStatus;
    DWORD dwHTTPReadProgress;
    DWORD dwHTTPReadTotal;
    }	WM_INDIVIDUALIZE_STATUS;

typedef struct  _WMGetLicenseData
    {
    DWORD dwSize;
    HRESULT hr;
    WCHAR __RPC_FAR *wszURL;
    WCHAR __RPC_FAR *wszLocalFilename;
    BYTE __RPC_FAR *pbPostData;
    DWORD dwPostDataSize;
    }	WM_GET_LICENSE_DATA;

typedef 
enum MSDRM_STATUS
    {	DRM_ERROR	= 0,
	DRM_INFORMATION	= 1,
	DRM_BACKUPRESTORE_BEGIN	= 2,
	DRM_BACKUPRESTORE_END	= 3,
	DRM_BACKUPRESTORE_CONNECTING	= 4,
	DRM_BACKUPRESTORE_DISCONNECTING	= 5,
	DRM_ERROR_WITHURL	= 6,
	DRM_RESTRICTED_LICENSE	= 7,
	DRM_NEEDS_INDIVIDUALIZATION	= 8
    }	MSDRM_STATUS;

typedef 
enum DRM_ATTR_DATATYPE
    {	DRM_TYPE_DWORD	= 0,
	DRM_TYPE_STRING	= 1,
	DRM_TYPE_BINARY	= 2,
	DRM_TYPE_BOOL	= 3,
	DRM_TYPE_QWORD	= 4,
	DRM_TYPE_WORD	= 5,
	DRM_TYPE_GUID	= 6
    }	DRM_ATTR_DATATYPE;


#define DRM_BACKUP_OVERWRITE         ((DWORD) 0x00000001)
#define DRM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)


extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_v0_0_s_ifspec;

#ifndef __IDRMStatusCallback_INTERFACE_DEFINED__
#define __IDRMStatusCallback_INTERFACE_DEFINED__

/* interface IDRMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDRMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08548704-75B1-4982-9B26-FB385DEE741D")
    IDRMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ MSDRM_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ DRM_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDRMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDRMStatusCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDRMStatusCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDRMStatusCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IDRMStatusCallback __RPC_FAR * This,
            /* [in] */ MSDRM_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ DRM_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IDRMStatusCallbackVtbl;

    interface IDRMStatusCallback
    {
        CONST_VTBL struct IDRMStatusCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDRMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDRMStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDRMStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDRMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDRMStatusCallback_OnStatus_Proxy( 
    IDRMStatusCallback __RPC_FAR * This,
    /* [in] */ MSDRM_STATUS Status,
    /* [in] */ HRESULT hr,
    /* [in] */ DRM_ATTR_DATATYPE dwType,
    /* [in] */ BYTE __RPC_FAR *pValue,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IDRMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDRMStatusCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_drmexternals_0108 */
/* [local] */ 

#define DRM_ENCRYPT_CONTENT_ASFv1  0x1001
#define DRM_ENCRYPT_CONTENT_ASFv2  0x1002
typedef struct  _DRMBUF
    {
    unsigned long len;
    char __RPC_FAR *buf;
    }	DRMBUF;

typedef struct _DRMBUF __RPC_FAR *PDRMBUF;



extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0108_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\scserver.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

#ifndef _CSECURECHANNELSERVER_H_2AD99357_6FD2_11d3_8497_00C04F79DBC0
#define _CSECURECHANNELSERVER_H_2AD99357_6FD2_11d3_8497_00C04F79DBC0

#include "wtypes.h"

#ifdef USE_X509
#include "rsa.h"
#endif

#include "des.h"

#ifdef USE_X509
#include "x509cert.h"
#endif

#include "sac.h"

class CSecureChannelServer
{
public:
	   CSecureChannelServer();
       ~CSecureChannelServer();
       HRESULT SetCertificate(DWORD dwFlags,
		                      BYTE *pbAppCert, 
                              DWORD dwCertLen, 
                              BYTE *pbAppPVK,
                              DWORD dwPVKLen);
       HRESULT SACAuth(DWORD dwProtocolID,
                       DWORD dwPass,
                       BYTE *pbDataIn,
                       DWORD dwDataInLen,
                       BYTE **ppbDataOut,
                       DWORD *pdwDataOutLen);
       HRESULT SACGetProtocols(DWORD **ppdwProtocols,
                               DWORD *pdwProtocolCount);
       HRESULT EncryptParam(BYTE *pbData,
                            DWORD dwDataLen);
       HRESULT DecryptParam(BYTE *pbData,
                           DWORD dwDataLen);
       HRESULT MACInit(HMAC *phMAC);
       HRESULT MACUpdate(HMAC hMAC,
                         BYTE *pbData,
                         DWORD dwDataLen);
       HRESULT MACFinal(HMAC hMAC,
                        BYTE abData[SAC_MAC_LEN]); 
	   HRESULT GetAppSec(DWORD *pdwLocalAppSec, DWORD *pdwRemoteAppSec);
	   HRESULT SetSessionKey(BYTE *pbSPSessionKey);
	   HRESULT GetSessionKey(BYTE *pbSPSessionKey);
       HRESULT GetRemoteAppCert(BYTE *pbAppCert, DWORD* pdwCertLen);
	   BOOL fIsAuthenticated();
private:
	   BOOL m_fAuthenticated;
       BYTE *m_pbAppCert;
       DWORD m_dwCertLen;
	   BYTE *m_pbRemoteCert;
	   DWORD m_dwRemoteCertLen;
       BYTE *m_pbAppPVK;
       DWORD m_dwPVKLen; 
       BYTE *m_pbSessionKey;
       DWORD m_dwSessionKeyLen;
       BYTE m_abCallerChallenge[4];
       BYTE m_abIssuedChallenge[4];
	   BOOL m_TableInit;
	   DESTable m_DesTable;
#ifdef USE_X509
       CX509Cert m_CertObj;
#endif
	   DWORD m_dwCertFlags;
	   MACINFO aMacInfo[20];
	   BYTE m_abMacKey[64];
	   BOOL m_fMacKeyInit;
       CRITICAL_SECTION m_CS;      
       HRESULT Protocol1(DWORD dwPass,
                         BYTE *pbDataIn,
                         DWORD dwDataInLen,
                         BYTE **ppbDataOut,
                         DWORD *pdwDataOutLen);

       HRESULT Protocol2(DWORD dwPass,
                         BYTE *pbDataIn,
                         DWORD dwDataInLen,
                         BYTE **ppbDataOut,
                         DWORD *pdwDataOutLen);
};

#endif // _CSECURECHANNELSERVER_H_2AD99357-6FD2-11d3-8497-00C04F79DBC0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\sac.h ===
#ifndef __SAC_H__
#define __SAC_H__

typedef DWORD HMAC;

#define RSA_KEY_LEN 64
#define SAC_SESSION_KEYLEN 8

#define SAC_PROTOCOL_WMDM 1
#define SAC_PROTOCOL_V1 2

#define SAC_CERT_X509 1
#define SAC_CERT_V1 2

typedef struct __MACINFO
{
	BOOL fUsed;
	BYTE abMacState[36];
} MACINFO;

#endif //__SAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\scclient.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

#ifndef _CSECURECHANNELCLIENT_H_2AD99356_6FD2_11d3_8497_00C04F79DBC0
#define _CSECURECHANNELCLIENT_H_2AD99356_6FD2_11d3_8497_00C04F79DBC0

#include "wtypes.h"

#ifdef USE_X509
#include "rsa.h"
#endif

#include "des.h"

#ifdef USE_X509
#include "x509cert.h"
#endif

#include "sac.h"

class CSecureChannelClient
{
public:
       CSecureChannelClient();
       ~CSecureChannelClient();
       HRESULT SetCertificate(DWORD dwFlags,
		                      BYTE *pbAppCert, 
                              DWORD dwCertLen, 
                              BYTE *pbAppPVK,
                              DWORD dwPVKLen);
       void SetInterface(IComponentAuthenticate *pComponentAuth);
       HRESULT Authenticate(DWORD dwProtocolID);
       HRESULT EncryptParam(BYTE *pbData,
                            DWORD dwDataLen);
       HRESULT DecryptParam(BYTE *pbData,
                           DWORD dwDataLen);
       HRESULT MACInit(HMAC *phMAC);
       HRESULT MACUpdate(HMAC hMAC,
                         BYTE *pbData,
                         DWORD dwDataLen);
       HRESULT MACFinal(HMAC hMAC,
                        BYTE abData[SAC_MAC_LEN]);
	   HRESULT GetAppSec(DWORD *pdwLocalAppSec, DWORD *pdwRemoteAppSec);
	   HRESULT SetSessionKey(BYTE *pbSPSessionKey);
	   HRESULT GetSessionKey(BYTE *pbSPSessionKey);
       HRESULT GetRemoteAppCert(BYTE *pbAppCert, DWORD* pdwCertLen);
	   BOOL fIsAuthenticated();
private:
       BOOL m_fAuthenticated;
       BYTE *m_pbAppCert;
       DWORD m_dwCertLen;
	   BYTE *m_pbRemoteCert;
	   DWORD m_dwRemoteCertLen;
       BYTE *m_pbAppPVK;
       DWORD m_dwPVKLen; 
       BYTE *m_pbSessionKey;
       DWORD m_dwSessionKeyLen;
	   BOOL m_TableInit;
	   DESTable m_DesTable;
       IComponentAuthenticate *m_pAuth;
	   DWORD m_dwCertFlags;
#ifdef USE_X509
       CX509Cert m_CertObj;
#endif
	   MACINFO aMacInfo[20];
	   BYTE m_abMacKey[64];
	   BOOL m_fMacKeyInit;
       CRITICAL_SECTION m_CS;
       HRESULT Protocol1();
	   HRESULT Protocol2();
};

#endif // _CSECURECHANNELCLIENT_H_2AD99356-6FD2-11d3-8497-00C04F79DBC0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\sha.h ===
//-----------------------------------------------------------------------------
//
// File:   sha.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1999-2001. All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

typedef struct {
    DWORD       FinishFlag;
    BYTE        HashVal[A_SHA_DIGEST_LEN];
    DWORD state[5];                             /* state (ABCDE) */
    DWORD count[2];                             /* number of bytes, msb first */
    unsigned char buffer[64];                   /* input buffer */
} A_SHA_CTX;

void RSA32API A_SHAInit(A_SHA_CTX *);
void RSA32API A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
// versions that don't internally byteswap (NoSwap version), for apps like
// the RNG that don't need hash compatibility - perf increase helps.
//

void RSA32API A_SHAUpdateNS(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinalNS(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\nserror.h ===
/*++

  Microsoft Windows Media Technology
  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.

Module Name:

    nserror.mc

Abstract:

    Definitions for Windows Media events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the nserror.h file

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 LEGACY RANGES

     0  -  199 = General NetShow errors

   200  -  399 = NetShow error events

   400  -  599 = NetShow monitor events

   600  -  799 = NetShow IMmsAutoServer errors

  1000  - 1199 = NetShow MCMADM errors


 NEW RANGES

  2000 -  2999 = ASF (defined in ASFERR.MC)

  3000 -  3999 = Windows Media SDK

  4000 -  4999 = Windows Media Player

  5000 -  5999 = Windows Media Server

  6000 -  6999 = Windows Media HTTP/RTSP result codes (defined in NETERROR.MC)

  7000 -  7999 = Windows Media Tools

  8000 -  8999 = Windows Media Content Discovery

  9000 -  9999 = Windows Media Real Time Collaboration

 10000 - 10999 = Windows Media Digital Rights Management

 11000 - 11999 = Windows Media Setup

 12000 - 12999 = Windows Media Networking

 13000 - 13999 = Windows Media Client Media Services

**************************** READ ME ******************************************

--*/

#ifndef _NSERROR_H
#define _NSERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Success Events
//
/////////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS_WIN32                0x7
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: NS_S_CALLPENDING
//
// MessageText:
//
//  The requested operation is pending completion.%0
//
#define NS_S_CALLPENDING                 0x000D0000L

//
// MessageId: NS_S_CALLABORTED
//
// MessageText:
//
//  The requested operation was aborted by the client.%0
//
#define NS_S_CALLABORTED                 0x000D0001L

//
// MessageId: NS_S_STREAM_TRUNCATED
//
// MessageText:
//
//  The stream was purposefully stopped before completion.%0
//
#define NS_S_STREAM_TRUNCATED            0x000D0002L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Warning Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_W_SERVER_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The maximum filebitrate value specified is greater than the server's configured maximum bandwidth.%0
//
#define NS_W_SERVER_BANDWIDTH_LIMIT      0x800D0003L

//
// MessageId: NS_W_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The maximum bandwidth value specified is less than the maximum filebitrate.%0
//
#define NS_W_FILE_BANDWIDTH_LIMIT        0x800D0004L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection established with the Windows Media server. The operation failed.%0
//
#define NS_E_NOCONNECTION                0xC00D0005L

//
// MessageId: NS_E_CANNOTCONNECT
//
// MessageText:
//
//  Unable to establish a connection to the server.%0
//
#define NS_E_CANNOTCONNECT               0xC00D0006L

//
// MessageId: NS_E_CANNOTDESTROYTITLE
//
// MessageText:
//
//  Unable to destroy the title.%0
//
#define NS_E_CANNOTDESTROYTITLE          0xC00D0007L

//
// MessageId: NS_E_CANNOTRENAMETITLE
//
// MessageText:
//
//  Unable to rename the title.%0
//
#define NS_E_CANNOTRENAMETITLE           0xC00D0008L

//
// MessageId: NS_E_CANNOTOFFLINEDISK
//
// MessageText:
//
//  Unable to offline disk.%0
//
#define NS_E_CANNOTOFFLINEDISK           0xC00D0009L

//
// MessageId: NS_E_CANNOTONLINEDISK
//
// MessageText:
//
//  Unable to online disk.%0
//
#define NS_E_CANNOTONLINEDISK            0xC00D000AL

//
// MessageId: NS_E_NOREGISTEREDWALKER
//
// MessageText:
//
//  There is no file parser registered for this type of file.%0
//
#define NS_E_NOREGISTEREDWALKER          0xC00D000BL

//
// MessageId: NS_E_NOFUNNEL
//
// MessageText:
//
//  There is no data connection established.%0
//
#define NS_E_NOFUNNEL                    0xC00D000CL

//
// MessageId: NS_E_NO_LOCALPLAY
//
// MessageText:
//
//  Failed to load the local play DLL.%0
//
#define NS_E_NO_LOCALPLAY                0xC00D000DL

//
// MessageId: NS_E_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.%0
//
#define NS_E_NETWORK_BUSY                0xC00D000EL

//
// MessageId: NS_E_TOO_MANY_SESS
//
// MessageText:
//
//  The server session limit was exceeded.%0
//
#define NS_E_TOO_MANY_SESS               0xC00D000FL

//
// MessageId: NS_E_ALREADY_CONNECTED
//
// MessageText:
//
//  The network connection already exists.%0
//
#define NS_E_ALREADY_CONNECTED           0xC00D0010L

//
// MessageId: NS_E_INVALID_INDEX
//
// MessageText:
//
//  Index %1 is invalid.%0
//
#define NS_E_INVALID_INDEX               0xC00D0011L

//
// MessageId: NS_E_PROTOCOL_MISMATCH
//
// MessageText:
//
//  There is no protocol or protocol version supported by both the client and the server.%0
//
#define NS_E_PROTOCOL_MISMATCH           0xC00D0012L

//
// MessageId: NS_E_TIMEOUT
//
// MessageText:
//
//  The server, a computer set up to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.%0
//
#define NS_E_TIMEOUT                     0xC00D0013L

//
// MessageId: NS_E_NET_WRITE
//
// MessageText:
//
//  Error writing to the network.%0
//
#define NS_E_NET_WRITE                   0xC00D0014L

//
// MessageId: NS_E_NET_READ
//
// MessageText:
//
//  Error reading from the network.%0
//
#define NS_E_NET_READ                    0xC00D0015L

//
// MessageId: NS_E_DISK_WRITE
//
// MessageText:
//
//  Error writing to a disk.%0
//
#define NS_E_DISK_WRITE                  0xC00D0016L

//
// MessageId: NS_E_DISK_READ
//
// MessageText:
//
//  Error reading from a disk.%0
//
#define NS_E_DISK_READ                   0xC00D0017L

//
// MessageId: NS_E_FILE_WRITE
//
// MessageText:
//
//  Error writing to a file.%0
//
#define NS_E_FILE_WRITE                  0xC00D0018L

//
// MessageId: NS_E_FILE_READ
//
// MessageText:
//
//  Error reading from a file.%0
//
#define NS_E_FILE_READ                   0xC00D0019L

//
// MessageId: NS_E_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.%0
//
#define NS_E_FILE_NOT_FOUND              0xC00D001AL

//
// MessageId: NS_E_FILE_EXISTS
//
// MessageText:
//
//  The file already exists.%0
//
#define NS_E_FILE_EXISTS                 0xC00D001BL

//
// MessageId: NS_E_INVALID_NAME
//
// MessageText:
//
//  The file name, directory name, or volume label syntax is incorrect.%0
//
#define NS_E_INVALID_NAME                0xC00D001CL

//
// MessageId: NS_E_FILE_OPEN_FAILED
//
// MessageText:
//
//  Failed to open a file.%0
//
#define NS_E_FILE_OPEN_FAILED            0xC00D001DL

//
// MessageId: NS_E_FILE_ALLOCATION_FAILED
//
// MessageText:
//
//  Unable to allocate a file.%0
//
#define NS_E_FILE_ALLOCATION_FAILED      0xC00D001EL

//
// MessageId: NS_E_FILE_INIT_FAILED
//
// MessageText:
//
//  Unable to initialize a file.%0
//
#define NS_E_FILE_INIT_FAILED            0xC00D001FL

//
// MessageId: NS_E_FILE_PLAY_FAILED
//
// MessageText:
//
//  Unable to play a file.%0
//
#define NS_E_FILE_PLAY_FAILED            0xC00D0020L

//
// MessageId: NS_E_SET_DISK_UID_FAILED
//
// MessageText:
//
//  Could not set the disk UID.%0
//
#define NS_E_SET_DISK_UID_FAILED         0xC00D0021L

//
// MessageId: NS_E_INDUCED
//
// MessageText:
//
//  An error was induced for testing purposes.%0
//
#define NS_E_INDUCED                     0xC00D0022L

//
// MessageId: NS_E_CCLINK_DOWN
//
// MessageText:
//
//  Two Content Servers failed to communicate.%0
//
#define NS_E_CCLINK_DOWN                 0xC00D0023L

//
// MessageId: NS_E_INTERNAL
//
// MessageText:
//
//  An unknown error occurred.%0
//
#define NS_E_INTERNAL                    0xC00D0024L

//
// MessageId: NS_E_BUSY
//
// MessageText:
//
//  The requested resource is in use.%0
//
#define NS_E_BUSY                        0xC00D0025L

//
// MessageId: NS_E_UNRECOGNIZED_STREAM_TYPE
//
// MessageText:
//
//  The specified protocol is not recognized. Be sure that the file name and syntax, such as slashes, are correct for the protocol.%0
//
#define NS_E_UNRECOGNIZED_STREAM_TYPE    0xC00D0026L

//
// MessageId: NS_E_NETWORK_SERVICE_FAILURE
//
// MessageText:
//
//  The network service provider failed.%0
//
#define NS_E_NETWORK_SERVICE_FAILURE     0xC00D0027L

//
// MessageId: NS_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
//  An attempt to acquire a network resource failed.%0
//
#define NS_E_NETWORK_RESOURCE_FAILURE    0xC00D0028L

//
// MessageId: NS_E_CONNECTION_FAILURE
//
// MessageText:
//
//  The network connection has failed.%0
//
#define NS_E_CONNECTION_FAILURE          0xC00D0029L

//
// MessageId: NS_E_SHUTDOWN
//
// MessageText:
//
//  The session is being terminated locally.%0
//
#define NS_E_SHUTDOWN                    0xC00D002AL

//
// MessageId: NS_E_INVALID_REQUEST
//
// MessageText:
//
//  The request is invalid in the current state.%0
//
#define NS_E_INVALID_REQUEST             0xC00D002BL

//
// MessageId: NS_E_INSUFFICIENT_BANDWIDTH
//
// MessageText:
//
//  There is insufficient bandwidth available to fulfill the request.%0
//
#define NS_E_INSUFFICIENT_BANDWIDTH      0xC00D002CL

//
// MessageId: NS_E_NOT_REBUILDING
//
// MessageText:
//
//  The disk is not rebuilding.%0
//
#define NS_E_NOT_REBUILDING              0xC00D002DL

//
// MessageId: NS_E_LATE_OPERATION
//
// MessageText:
//
//  An operation requested for a particular time could not be carried out on schedule.%0
//
#define NS_E_LATE_OPERATION              0xC00D002EL

//
// MessageId: NS_E_INVALID_DATA
//
// MessageText:
//
//  Invalid or corrupt data was encountered.%0
//
#define NS_E_INVALID_DATA                0xC00D002FL

//
// MessageId: NS_E_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
//  The bandwidth required to stream a file is higher than the maximum file bandwidth allowed on the server.%0
//
#define NS_E_FILE_BANDWIDTH_LIMIT        0xC00D0030L

//
// MessageId: NS_E_OPEN_FILE_LIMIT
//
// MessageText:
//
//  The client cannot have any more files open simultaneously.%0
//
#define NS_E_OPEN_FILE_LIMIT             0xC00D0031L

//
// MessageId: NS_E_BAD_CONTROL_DATA
//
// MessageText:
//
//  The server received invalid data from the client on the control connection.%0
//
#define NS_E_BAD_CONTROL_DATA            0xC00D0032L

//
// MessageId: NS_E_NO_STREAM
//
// MessageText:
//
//  There is no stream available.%0
//
#define NS_E_NO_STREAM                   0xC00D0033L

//
// MessageId: NS_E_STREAM_END
//
// MessageText:
//
//  There is no more data in the stream.%0
//
#define NS_E_STREAM_END                  0xC00D0034L

//
// MessageId: NS_E_SERVER_NOT_FOUND
//
// MessageText:
//
//  The specified server could not be found.%0
//
#define NS_E_SERVER_NOT_FOUND            0xC00D0035L

//
// MessageId: NS_E_DUPLICATE_NAME
//
// MessageText:
//
//  The specified name is already in use.
//
#define NS_E_DUPLICATE_NAME              0xC00D0036L

//
// MessageId: NS_E_DUPLICATE_ADDRESS
//
// MessageText:
//
//  The specified address is already in use.
//
#define NS_E_DUPLICATE_ADDRESS           0xC00D0037L

//
// MessageId: NS_E_BAD_MULTICAST_ADDRESS
//
// MessageText:
//
//  The specified address is not a valid multicast address.
//
#define NS_E_BAD_MULTICAST_ADDRESS       0xC00D0038L

//
// MessageId: NS_E_BAD_ADAPTER_ADDRESS
//
// MessageText:
//
//  The specified adapter address is invalid.
//
#define NS_E_BAD_ADAPTER_ADDRESS         0xC00D0039L

//
// MessageId: NS_E_BAD_DELIVERY_MODE
//
// MessageText:
//
//  The specified delivery mode is invalid.
//
#define NS_E_BAD_DELIVERY_MODE           0xC00D003AL

//
// MessageId: NS_E_INVALID_CHANNEL
//
// MessageText:
//
//  The specified station does not exist.
//
#define NS_E_INVALID_CHANNEL             0xC00D003BL

//
// MessageId: NS_E_INVALID_STREAM
//
// MessageText:
//
//  The specified stream does not exist.
//
#define NS_E_INVALID_STREAM              0xC00D003CL

//
// MessageId: NS_E_INVALID_ARCHIVE
//
// MessageText:
//
//  The specified archive could not be opened.
//
#define NS_E_INVALID_ARCHIVE             0xC00D003DL

//
// MessageId: NS_E_NOTITLES
//
// MessageText:
//
//  The system cannot find any titles on the server.%0
//
#define NS_E_NOTITLES                    0xC00D003EL

//
// MessageId: NS_E_INVALID_CLIENT
//
// MessageText:
//
//  The system cannot find the client specified.%0
//
#define NS_E_INVALID_CLIENT              0xC00D003FL

//
// MessageId: NS_E_INVALID_BLACKHOLE_ADDRESS
//
// MessageText:
//
//  The Blackhole Address is not initialized.%0
//
#define NS_E_INVALID_BLACKHOLE_ADDRESS   0xC00D0040L

//
// MessageId: NS_E_INCOMPATIBLE_FORMAT
//
// MessageText:
//
//  The station does not support the stream format.
//
#define NS_E_INCOMPATIBLE_FORMAT         0xC00D0041L

//
// MessageId: NS_E_INVALID_KEY
//
// MessageText:
//
//  The specified key is not valid.
//
#define NS_E_INVALID_KEY                 0xC00D0042L

//
// MessageId: NS_E_INVALID_PORT
//
// MessageText:
//
//  The specified port is not valid.
//
#define NS_E_INVALID_PORT                0xC00D0043L

//
// MessageId: NS_E_INVALID_TTL
//
// MessageText:
//
//  The specified TTL is not valid.
//
#define NS_E_INVALID_TTL                 0xC00D0044L

//
// MessageId: NS_E_STRIDE_REFUSED
//
// MessageText:
//
//  The request to fast forward or rewind could not be fulfilled.
//
#define NS_E_STRIDE_REFUSED              0xC00D0045L

//
// IMmsAutoServer Errors
//
//
// MessageId: NS_E_MMSAUTOSERVER_CANTFINDWALKER
//
// MessageText:
//
//  Unable to load the appropriate file parser.%0
//
#define NS_E_MMSAUTOSERVER_CANTFINDWALKER 0xC00D0046L

//
// MessageId: NS_E_MAX_BITRATE
//
// MessageText:
//
//  Cannot exceed the maximum bandwidth limit.%0
//
#define NS_E_MAX_BITRATE                 0xC00D0047L

//
// MessageId: NS_E_LOGFILEPERIOD
//
// MessageText:
//
//  Invalid value for LogFilePeriod.%0
//
#define NS_E_LOGFILEPERIOD               0xC00D0048L

//
// MessageId: NS_E_MAX_CLIENTS
//
// MessageText:
//
//  Cannot exceed the maximum client limit.%0
//  
//
#define NS_E_MAX_CLIENTS                 0xC00D0049L

//
// MessageId: NS_E_LOG_FILE_SIZE
//
// MessageText:
//
//  Log File Size too small.%0
//  
//
#define NS_E_LOG_FILE_SIZE               0xC00D004AL

//
// MessageId: NS_E_MAX_FILERATE
//
// MessageText:
//
//  Cannot exceed the maximum file rate.%0
//
#define NS_E_MAX_FILERATE                0xC00D004BL

//
// File Walker Errors
//
//
// MessageId: NS_E_WALKER_UNKNOWN
//
// MessageText:
//
//  Unknown file type.%0
//
#define NS_E_WALKER_UNKNOWN              0xC00D004CL

//
// MessageId: NS_E_WALKER_SERVER
//
// MessageText:
//
//  The specified file, %1, cannot be loaded onto the specified server, %2.%0
//
#define NS_E_WALKER_SERVER               0xC00D004DL

//
// MessageId: NS_E_WALKER_USAGE
//
// MessageText:
//
//  There was a usage error with file parser.%0
//
#define NS_E_WALKER_USAGE                0xC00D004EL


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
/////////////////////////////////////////////////////////////////////////


 // Tiger Events

 // %1 is the tiger name

//
// MessageId: NS_I_TIGER_START
//
// MessageText:
//
//  The Title Server %1 is running.%0
//
#define NS_I_TIGER_START                 0x400D004FL

//
// MessageId: NS_E_TIGER_FAIL
//
// MessageText:
//
//  The Title Server %1 has failed.%0
//
#define NS_E_TIGER_FAIL                  0xC00D0050L


 // Cub Events

 // %1 is the cub ID
 // %2 is the cub name

//
// MessageId: NS_I_CUB_START
//
// MessageText:
//
//  Content Server %1 (%2) is starting.%0
//
#define NS_I_CUB_START                   0x400D0051L

//
// MessageId: NS_I_CUB_RUNNING
//
// MessageText:
//
//  Content Server %1 (%2) is running.%0
//
#define NS_I_CUB_RUNNING                 0x400D0052L

//
// MessageId: NS_E_CUB_FAIL
//
// MessageText:
//
//  Content Server %1 (%2) has failed.%0
//
#define NS_E_CUB_FAIL                    0xC00D0053L


 // Disk Events

 // %1 is the tiger disk ID
 // %2 is the device name
 // %3 is the cub ID
//
// MessageId: NS_I_DISK_START
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, is running.%0
//
#define NS_I_DISK_START                  0x400D0054L

//
// MessageId: NS_E_DISK_FAIL
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, has failed.%0
//
#define NS_E_DISK_FAIL                   0xC00D0055L

//
// MessageId: NS_I_DISK_REBUILD_STARTED
//
// MessageText:
//
//  Started rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_STARTED        0x400D0056L

//
// MessageId: NS_I_DISK_REBUILD_FINISHED
//
// MessageText:
//
//  Finished rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_FINISHED       0x400D0057L

//
// MessageId: NS_I_DISK_REBUILD_ABORTED
//
// MessageText:
//
//  Aborted rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_ABORTED        0x400D0058L


 // Admin Events

//
// MessageId: NS_I_LIMIT_FUNNELS
//
// MessageText:
//
//  A NetShow administrator at network location %1 set the data stream limit to %2 streams.%0
//
#define NS_I_LIMIT_FUNNELS               0x400D0059L

//
// MessageId: NS_I_START_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 started disk %2.%0
//
#define NS_I_START_DISK                  0x400D005AL

//
// MessageId: NS_I_STOP_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 stopped disk %2.%0
//
#define NS_I_STOP_DISK                   0x400D005BL

//
// MessageId: NS_I_STOP_CUB
//
// MessageText:
//
//  A NetShow administrator at network location %1 stopped Content Server %2.%0
//
#define NS_I_STOP_CUB                    0x400D005CL

//
// MessageId: NS_I_KILL_VIEWER
//
// MessageText:
//
//  A NetShow administrator at network location %1 disconnected viewer %2 from the system.%0
//
#define NS_I_KILL_VIEWER                 0x400D005DL

//
// MessageId: NS_I_REBUILD_DISK
//
// MessageText:
//
//  A NetShow administrator at network location %1 started rebuilding disk %2.%0
//
#define NS_I_REBUILD_DISK                0x400D005EL

//
// MessageId: NS_W_UNKNOWN_EVENT
//
// MessageText:
//
//  Unknown %1 event encountered.%0
//
#define NS_W_UNKNOWN_EVENT               0x800D005FL


 // Alerts

//
// MessageId: NS_E_MAX_FUNNELS_ALERT
//
// MessageText:
//
//  The NetShow data stream limit of %1 streams was reached.%0
//
#define NS_E_MAX_FUNNELS_ALERT           0xC00D0060L

//
// MessageId: NS_E_ALLOCATE_FILE_FAIL
//
// MessageText:
//
//  The NetShow Video Server was unable to allocate a %1 block file named %2.%0
//
#define NS_E_ALLOCATE_FILE_FAIL          0xC00D0061L

//
// MessageId: NS_E_PAGING_ERROR
//
// MessageText:
//
//  A Content Server was unable to page a block.%0
//
#define NS_E_PAGING_ERROR                0xC00D0062L

//
// MessageId: NS_E_BAD_BLOCK0_VERSION
//
// MessageText:
//
//  Disk %1 has unrecognized control block version %2.%0
//
#define NS_E_BAD_BLOCK0_VERSION          0xC00D0063L

//
// MessageId: NS_E_BAD_DISK_UID
//
// MessageText:
//
//  Disk %1 has incorrect uid %2.%0
//
#define NS_E_BAD_DISK_UID                0xC00D0064L

//
// MessageId: NS_E_BAD_FSMAJOR_VERSION
//
// MessageText:
//
//  Disk %1 has unsupported file system major version %2.%0
//
#define NS_E_BAD_FSMAJOR_VERSION         0xC00D0065L

//
// MessageId: NS_E_BAD_STAMPNUMBER
//
// MessageText:
//
//  Disk %1 has bad stamp number in control block.%0
//
#define NS_E_BAD_STAMPNUMBER             0xC00D0066L

//
// MessageId: NS_E_PARTIALLY_REBUILT_DISK
//
// MessageText:
//
//  Disk %1 is partially reconstructed.%0
//
#define NS_E_PARTIALLY_REBUILT_DISK      0xC00D0067L

//
// MessageId: NS_E_ENACTPLAN_GIVEUP
//
// MessageText:
//
//  EnactPlan gives up.%0
//
#define NS_E_ENACTPLAN_GIVEUP            0xC00D0068L


 // MCMADM warnings/errors

//
// MessageId: MCMADM_I_NO_EVENTS
//
// MessageText:
//
//  Event initialization failed, there will be no MCM events.%0
//
#define MCMADM_I_NO_EVENTS               0x400D0069L

//
// MessageId: MCMADM_E_REGKEY_NOT_FOUND
//
// MessageText:
//
//  The key was not found in the registry.%0
//
#define MCMADM_E_REGKEY_NOT_FOUND        0xC00D006AL

//
// MessageId: NS_E_NO_FORMATS
//
// MessageText:
//
//  No stream formats were found in an NSC file.%0
//
#define NS_E_NO_FORMATS                  0xC00D006BL

//
// MessageId: NS_E_NO_REFERENCES
//
// MessageText:
//
//  No reference URLs were found in an ASX file.%0
//
#define NS_E_NO_REFERENCES               0xC00D006CL

//
// MessageId: NS_E_WAVE_OPEN
//
// MessageText:
//
//  Error opening wave device, the device might be in use.%0
//
#define NS_E_WAVE_OPEN                   0xC00D006DL

//
// MessageId: NS_I_LOGGING_FAILED
//
// MessageText:
//
//  The logging operation failed.
//
#define NS_I_LOGGING_FAILED              0x400D006EL

//
// MessageId: NS_E_CANNOTCONNECTEVENTS
//
// MessageText:
//
//  Unable to establish a connection to the NetShow event monitor service.%0
//
#define NS_E_CANNOTCONNECTEVENTS         0xC00D006FL

//
// MessageId: NS_I_LIMIT_BANDWIDTH
//
// MessageText:
//
//  A NetShow administrator at network location %1 set the maximum bandwidth limit to %2 bps.%0
//
#define NS_I_LIMIT_BANDWIDTH             0x400D0070L

//
// MessageId: NS_E_NO_DEVICE
//
// MessageText:
//
//  No device driver is present on the system.%0
//
#define NS_E_NO_DEVICE                   0xC00D0071L

//
// MessageId: NS_E_NO_SPECIFIED_DEVICE
//
// MessageText:
//
//  No specified device driver is present.%0
//
#define NS_E_NO_SPECIFIED_DEVICE         0xC00D0072L


// NOTENOTE!!!
//
// Due to legacy problems these error codes live inside the ASF error code range
//
//
// MessageId: NS_E_NOTHING_TO_DO
//
// MessageText:
//
//  NS_E_NOTHING_TO_DO
//
#define NS_E_NOTHING_TO_DO               0xC00D07F1L

//
// MessageId: NS_E_NO_MULTICAST
//
// MessageText:
//
//  Not receiving data from the server.%0
//
#define NS_E_NO_MULTICAST                0xC00D07F2L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
// IdRange = 200..399
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_MONITOR_GIVEUP
//
// MessageText:
//
//  Netshow Events Monitor is not operational and has been disconnected.%0
//
#define NS_E_MONITOR_GIVEUP              0xC00D00C8L

//
// MessageId: NS_E_REMIRRORED_DISK
//
// MessageText:
//
//  Disk %1 is remirrored.%0
//
#define NS_E_REMIRRORED_DISK             0xC00D00C9L

//
// MessageId: NS_E_INSUFFICIENT_DATA
//
// MessageText:
//
//  Insufficient data found.%0
//
#define NS_E_INSUFFICIENT_DATA           0xC00D00CAL

//
// MessageId: NS_E_ASSERT
//
// MessageText:
//
//  %1 failed in file %2 line %3.%0
//
#define NS_E_ASSERT                      0xC00D00CBL

//
// MessageId: NS_E_BAD_ADAPTER_NAME
//
// MessageText:
//
//  The specified adapter name is invalid.%0
//
#define NS_E_BAD_ADAPTER_NAME            0xC00D00CCL

//
// MessageId: NS_E_NOT_LICENSED
//
// MessageText:
//
//  The application is not licensed for this feature.%0
//
#define NS_E_NOT_LICENSED                0xC00D00CDL

//
// MessageId: NS_E_NO_SERVER_CONTACT
//
// MessageText:
//
//  Unable to contact the server.%0
//
#define NS_E_NO_SERVER_CONTACT           0xC00D00CEL

//
// MessageId: NS_E_TOO_MANY_TITLES
//
// MessageText:
//
//  Maximum number of titles exceeded.%0
//
#define NS_E_TOO_MANY_TITLES             0xC00D00CFL

//
// MessageId: NS_E_TITLE_SIZE_EXCEEDED
//
// MessageText:
//
//  Maximum size of a title exceeded.%0
//
#define NS_E_TITLE_SIZE_EXCEEDED         0xC00D00D0L

//
// MessageId: NS_E_UDP_DISABLED
//
// MessageText:
//
//  UDP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_UDP_DISABLED                0xC00D00D1L

//
// MessageId: NS_E_TCP_DISABLED
//
// MessageText:
//
//  TCP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_TCP_DISABLED                0xC00D00D2L

//
// MessageId: NS_E_HTTP_DISABLED
//
// MessageText:
//
//  HTTP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_HTTP_DISABLED               0xC00D00D3L

//
// MessageId: NS_E_LICENSE_EXPIRED
//
// MessageText:
//
//  The product license has expired.%0
//
#define NS_E_LICENSE_EXPIRED             0xC00D00D4L

//
// MessageId: NS_E_TITLE_BITRATE
//
// MessageText:
//
//  Source file exceeds the per title maximum bitrate. See NetShow Theater documentation for more information.%0
//
#define NS_E_TITLE_BITRATE               0xC00D00D5L

//
// MessageId: NS_E_EMPTY_PROGRAM_NAME
//
// MessageText:
//
//  The program name cannot be empty.%0
//
#define NS_E_EMPTY_PROGRAM_NAME          0xC00D00D6L

//
// MessageId: NS_E_MISSING_CHANNEL
//
// MessageText:
//
//  Station %1 does not exist.%0
//
#define NS_E_MISSING_CHANNEL             0xC00D00D7L

//
// MessageId: NS_E_NO_CHANNELS
//
// MessageText:
//
//  You need to define at least one station before this operation can complete.%0
//
#define NS_E_NO_CHANNELS                 0xC00D00D8L


/////////////////////////////////////////////////////////////////////
// This error message is to replace previous NS_E_INVALID_INDEX which 
// takes an index value for the error message string.  For some application
// obtain the idex value at reporting error time is very difficult, so we
// use this string to avoid the problem.
//////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INDEX2
//
// MessageText:
//
//  The index specified is invalid.%0
//
#define NS_E_INVALID_INDEX2              0xC00D00D9L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
// IdRange = 400..599
//
// Admin Events:
//
// Alerts:
//
// Title Server:
//      %1 is the Title Server name
//
// Content Server:
//      %1 is the Content Server ID
//      %2 is the Content Server name
//      %3 is the Peer Content Server name (optional)
//
// Disks:
//      %1 is the Title Server disk ID
//      %2 is the device name
//      %3 is the Content Server ID
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_CUB_FAIL_LINK
//
// MessageText:
//
//  Content Server %1 (%2) has failed its link to Content Server %3.%0
//
#define NS_E_CUB_FAIL_LINK               0xC00D0190L

//
// MessageId: NS_I_CUB_UNFAIL_LINK
//
// MessageText:
//
//  Content Server %1 (%2) has established its link to Content Server %3.%0
//
#define NS_I_CUB_UNFAIL_LINK             0x400D0191L

//
// MessageId: NS_E_BAD_CUB_UID
//
// MessageText:
//
//  Content Server %1 (%2) has incorrect uid %3.%0
//
#define NS_E_BAD_CUB_UID                 0xC00D0192L

//
// MessageId: NS_I_RESTRIPE_START
//
// MessageText:
//
//  Restripe operation has started.%0
//
#define NS_I_RESTRIPE_START              0x400D0193L

//
// MessageId: NS_I_RESTRIPE_DONE
//
// MessageText:
//
//  Restripe operation has completed.%0
//
#define NS_I_RESTRIPE_DONE               0x400D0194L

//
// MessageId: NS_E_GLITCH_MODE
//
// MessageText:
//
//  Server unreliable because multiple components failed.%0
//
#define NS_E_GLITCH_MODE                 0xC00D0195L

//
// MessageId: NS_I_RESTRIPE_DISK_OUT
//
// MessageText:
//
//  Content disk %1 (%2) on Content Server %3 has been restriped out.%0
//
#define NS_I_RESTRIPE_DISK_OUT           0x400D0196L

//
// MessageId: NS_I_RESTRIPE_CUB_OUT
//
// MessageText:
//
//  Content server %1 (%2) has been restriped out.%0
//
#define NS_I_RESTRIPE_CUB_OUT            0x400D0197L

//
// MessageId: NS_I_DISK_STOP
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, has been offlined.%0
//
#define NS_I_DISK_STOP                   0x400D0198L

//
// MessageId: NS_I_CATATONIC_FAILURE
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, will be failed because it is catatonic.%0
//
#define NS_I_CATATONIC_FAILURE           0x800D0199L

//
// MessageId: NS_I_CATATONIC_AUTO_UNFAIL
//
// MessageText:
//
//  Disk %1 ( %2 ) on Content Server %3, auto online from catatonic state.%0
//
#define NS_I_CATATONIC_AUTO_UNFAIL       0x800D019AL

//
// MessageId: NS_E_NO_MEDIA_PROTOCOL
//
// MessageText:
//
//  Content Server %1 (%2) is unable to communicate with the Media System Network Protocol.%0
//
#define NS_E_NO_MEDIA_PROTOCOL           0xC00D019BL


//
// Advanced Streaming Format (ASF) codes occupy MessageIds 2000-2999
//
// See ASFErr.mc for more details - please do not define any symbols
// in that range in this file.
//


/////////////////////////////////////////////////////////////////////////
//
// Windows Media SDK Errors
//
// IdRange = 3000-3199
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INPUT_FORMAT
//
// MessageText:
//
//  The input media format is invalid.%0
//
#define NS_E_INVALID_INPUT_FORMAT        0xC00D0BB8L

//
// MessageId: NS_E_MSAUDIO_NOT_INSTALLED
//
// MessageText:
//
//  The MSAudio codec is not installed on this system.%0
//
#define NS_E_MSAUDIO_NOT_INSTALLED       0xC00D0BB9L

//
// MessageId: NS_E_UNEXPECTED_MSAUDIO_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the MSAudio codec.%0
//
#define NS_E_UNEXPECTED_MSAUDIO_ERROR    0xC00D0BBAL

//
// MessageId: NS_E_INVALID_OUTPUT_FORMAT
//
// MessageText:
//
//  The output media format is invalid.%0
//
#define NS_E_INVALID_OUTPUT_FORMAT       0xC00D0BBBL

//
// MessageId: NS_E_NOT_CONFIGURED
//
// MessageText:
//
//  The object must be fully configured before audio samples can be processed.%0
//
#define NS_E_NOT_CONFIGURED              0xC00D0BBCL

//
// MessageId: NS_E_PROTECTED_CONTENT
//
// MessageText:
//
//  You need a license to perform the requested operation on this media file.%0
//
#define NS_E_PROTECTED_CONTENT           0xC00D0BBDL

//
// MessageId: NS_E_LICENSE_REQUIRED
//
// MessageText:
//
//  You need a license to perform the requested operation on this media file.%0
//
#define NS_E_LICENSE_REQUIRED            0xC00D0BBEL

//
// MessageId: NS_E_TAMPERED_CONTENT
//
// MessageText:
//
//  This media file is corrupted or invalid. Contact the content provider for a new file.%0
//
#define NS_E_TAMPERED_CONTENT            0xC00D0BBFL

//
// MessageId: NS_E_LICENSE_OUTOFDATE
//
// MessageText:
//
//  The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_OUTOFDATE           0xC00D0BC0L

//
// MessageId: NS_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
//  You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_INCORRECT_RIGHTS    0xC00D0BC1L

//
// MessageId: NS_E_AUDIO_CODEC_NOT_INSTALLED
//
// MessageText:
//
//  The requested audio codec is not installed on this system.%0
//
#define NS_E_AUDIO_CODEC_NOT_INSTALLED   0xC00D0BC2L

//
// MessageId: NS_E_AUDIO_CODEC_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the audio codec.%0
//
#define NS_E_AUDIO_CODEC_ERROR           0xC00D0BC3L

//
// MessageId: NS_E_VIDEO_CODEC_NOT_INSTALLED
//
// MessageText:
//
//  The requested video codec is not installed on this system.%0
//
#define NS_E_VIDEO_CODEC_NOT_INSTALLED   0xC00D0BC4L

//
// MessageId: NS_E_VIDEO_CODEC_ERROR
//
// MessageText:
//
//  An unexpected error occurred with the video codec.%0
//
#define NS_E_VIDEO_CODEC_ERROR           0xC00D0BC5L

//
// MessageId: NS_E_INVALIDPROFILE
//
// MessageText:
//
//  The Profile is invalid.%0
//
#define NS_E_INVALIDPROFILE              0xC00D0BC6L

//
// MessageId: NS_E_INCOMPATIBLE_VERSION
//
// MessageText:
//
//  A new version of the SDK is needed to play the requested content.%0
//
#define NS_E_INCOMPATIBLE_VERSION        0xC00D0BC7L

//
// MessageId: NS_S_REBUFFERING
//
// MessageText:
//
//  The requested operation has caused the source to rebuffer.%0
//
#define NS_S_REBUFFERING                 0x000D0BC8L

//
// MessageId: NS_S_DEGRADING_QUALITY
//
// MessageText:
//
//  The requested operation has caused the source to degrade codec quality.%0
//
#define NS_S_DEGRADING_QUALITY           0x000D0BC9L

//
// MessageId: NS_E_OFFLINE_MODE
//
// MessageText:
//
//  The requested URL is not available in offline mode.%0
//
#define NS_E_OFFLINE_MODE                0xC00D0BCAL

//
// MessageId: NS_E_NOT_CONNECTED
//
// MessageText:
//
//  The requested URL cannot be accessed because there is no network connection.%0
//
#define NS_E_NOT_CONNECTED               0xC00D0BCBL

//
// MessageId: NS_E_TOO_MUCH_DATA
//
// MessageText:
//
//  The encoding process was unable to keep up with the amount of supplied data.%0
//
#define NS_E_TOO_MUCH_DATA               0xC00D0BCCL

//
// MessageId: NS_E_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The given property is not supported.%0
//
#define NS_E_UNSUPPORTED_PROPERTY        0xC00D0BCDL

//
// MessageId: NS_E_8BIT_WAVE_UNSUPPORTED
//
// MessageText:
//
//  Windows Media Player cannot copy the files to the CD because they are 8-bit. Convert the files to 16-bit, 44-kHz stereo files by using Sound Recorder or another audio-processing program, and then try again.%0
//
#define NS_E_8BIT_WAVE_UNSUPPORTED       0xC00D0BCEL

//
// MessageId: NS_E_NO_MORE_SAMPLES
//
// MessageText:
//
//  There are no more samples in the current range.%0
//
#define NS_E_NO_MORE_SAMPLES             0xC00D0BCFL

//
// MessageId: NS_E_INVALID_SAMPLING_RATE
//
// MessageText:
//
//  The given sampling rate is invalid.%0
//
#define NS_E_INVALID_SAMPLING_RATE       0xC00D0BD0L

//
// MessageId: NS_E_MAX_PACKET_SIZE_TOO_SMALL
//
// MessageText:
//
//  The given maximum packet size is too small to accommodate this profile
//
#define NS_E_MAX_PACKET_SIZE_TOO_SMALL   0xC00D0BD1L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Player Errors
//
// IdRange = 4000 - 4999
//
/////////////////////////////////////////////////////////////////////////

//
// WMP CD Filter Error codes
//
//
// MessageId: NS_E_NO_CD
//
// MessageText:
//
//  There is no CD in the CD-ROM drive. Insert a CD, and try again.%0
//
#define NS_E_NO_CD                       0xC00D0FA0L

//
// MessageId: NS_E_CANT_READ_DIGITAL
//
// MessageText:
//
//  Unable to perform digital reads on this compact disc drive.  Please try analog playback via the Tools Options menu.%0
//
#define NS_E_CANT_READ_DIGITAL           0xC00D0FA1L

//
// MessageId: NS_E_DEVICE_DISCONNECTED
//
// MessageText:
//
//  Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and then try downloading the file again.%0
//
#define NS_E_DEVICE_DISCONNECTED         0xC00D0FA2L

//
// MessageId: NS_E_DEVICE_NOT_SUPPORT_FORMAT
//
// MessageText:
//
//  Your Music Player does not support this song's format.%0
//
#define NS_E_DEVICE_NOT_SUPPORT_FORMAT   0xC00D0FA3L

//
// MessageId: NS_E_SLOW_READ_DIGITAL
//
// MessageText:
//
//  Digital reads on this compact disc drive are too slow.  Please try analog playback via the Tools Options menu.%0
//
#define NS_E_SLOW_READ_DIGITAL           0xC00D0FA4L

//
// MessageId: NS_E_MIXER_INVALID_LINE
//
// MessageText:
//
//  An invalid line error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_LINE          0xC00D0FA5L

//
// MessageId: NS_E_MIXER_INVALID_CONTROL
//
// MessageText:
//
//  An invalid control error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_CONTROL       0xC00D0FA6L

//
// MessageId: NS_E_MIXER_INVALID_VALUE
//
// MessageText:
//
//  An invalid value error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_VALUE         0xC00D0FA7L

//
// MessageId: NS_E_MIXER_UNKNOWN_MMRESULT
//
// MessageText:
//
//  An unrecognized MMRESULT occurred in the mixer.%0
//
#define NS_E_MIXER_UNKNOWN_MMRESULT      0xC00D0FA8L

//
// MessageId: NS_E_USER_STOP
//
// MessageText:
//
//  User has stopped the operation.%0
//
#define NS_E_USER_STOP                   0xC00D0FA9L

//
// MessageId: NS_E_MP3_FORMAT_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play the file. One or more codecs required to play the file cannot be found.%0
//
#define NS_E_MP3_FORMAT_NOT_FOUND        0xC00D0FAAL

//
// MessageId: NS_E_CD_READ_ERROR_NO_CORRECTION
//
// MessageText:
//
//  Windows Media Player cannot read the CD. It may contain flaws. Turn on error correction, and try again.%0
//
#define NS_E_CD_READ_ERROR_NO_CORRECTION 0xC00D0FABL

//
// MessageId: NS_E_CD_READ_ERROR
//
// MessageText:
//
//  Windows Media Player cannot read the CD. Be sure the CD is free of dirt and scratches and the CD-ROM drive is functioning properly.%0
//
#define NS_E_CD_READ_ERROR               0xC00D0FACL

//
// MessageId: NS_E_CD_SLOW_COPY
//
// MessageText:
//
//  To speed up the copy process, do not play CD tracks while copying.%0
//
#define NS_E_CD_SLOW_COPY                0xC00D0FADL

//
// MessageId: NS_E_CD_COPYTO_CD
//
// MessageText:
//
//  Cannot copy directly from a CDROM to a CD drive.%0
//
#define NS_E_CD_COPYTO_CD                0xC00D0FAEL

//
// MessageId: NS_E_MIXER_NODRIVER
//
// MessageText:
//
//  Could not open a sound mixer driver.%0
//
#define NS_E_MIXER_NODRIVER              0xC00D0FAFL

//
// MessageId: NS_E_REDBOOK_ENABLED_WHILE_COPYING
//
// MessageText:
//
//  Windows Media Player has detected that a setting for the CD-ROM drive will cause audio CDs to copy incorrectly; no audio is copied. Change the CD-ROM drive setting in Device Manager, and then try again.%0
//
#define NS_E_REDBOOK_ENABLED_WHILE_COPYING 0xC00D0FB0L

//
// MessageId: NS_E_CD_REFRESH
//
// MessageText:
//
//  Trying to refresh the CD playlist.%0
//
#define NS_E_CD_REFRESH                  0xC00D0FB1L

//
// MessageId: NS_E_CD_DRIVER_PROBLEM
//
// MessageText:
//
//  Windows Media Player must switch to analog  mode  because there is a problem reading the CD-ROM drive in digital mode. Verify that the CD-ROM drive is installed correctly or try to update the drivers for the CD-ROM drive, and then try to use digital mode again.%0
//
#define NS_E_CD_DRIVER_PROBLEM           0xC00D0FB2L

//
// MessageId: NS_E_WONT_DO_DIGITAL
//
// MessageText:
//
//  Windows Media Player must switch to analog mode because there is a problem reading the CD-ROM drive  in digital mode.%0
//
#define NS_E_WONT_DO_DIGITAL             0xC00D0FB3L

//
// WMP IWMPXMLParser Error codes
//
//
// MessageId: NS_E_WMPXML_NOERROR
//
// MessageText:
//
//  A call was made to GetParseError on the XML parser but there was no error to retrieve.%0
//
#define NS_E_WMPXML_NOERROR              0xC00D0FB4L

//
// MessageId: NS_E_WMPXML_ENDOFDATA
//
// MessageText:
//
//  The XML Parser ran out of data while parsing.%0
//
#define NS_E_WMPXML_ENDOFDATA            0xC00D0FB5L

//
// MessageId: NS_E_WMPXML_PARSEERROR
//
// MessageText:
//
//  A generic parse error occurred in the XML parser but no information is available.%0
//
#define NS_E_WMPXML_PARSEERROR           0xC00D0FB6L

//
// MessageId: NS_E_WMPXML_ATTRIBUTENOTFOUND
//
// MessageText:
//
//  A call get GetNamedAttribute or GetNamedAttributeIndex on the XML parser resulted in the index not being found.%0
//
#define NS_E_WMPXML_ATTRIBUTENOTFOUND    0xC00D0FB7L

//
// MessageId: NS_E_WMPXML_PINOTFOUND
//
// MessageText:
//
//  A call was made go GetNamedPI on the XML parser, but the requested Processing Instruction was not found.%0
//
#define NS_E_WMPXML_PINOTFOUND           0xC00D0FB8L

//
// MessageId: NS_E_WMPXML_EMPTYDOC
//
// MessageText:
//
//  Persist was called on the XML parser, but the parser has no data to persist.%0
//
#define NS_E_WMPXML_EMPTYDOC             0xC00D0FB9L

//
// Miscellaneous Media Player Error codes
//
//
// MessageId: NS_E_WMP_WINDOWSAPIFAILURE
//
// MessageText:
//
//  A Windows API call failed but no error information was available.%0
//
#define NS_E_WMP_WINDOWSAPIFAILURE       0xC00D0FC8L

//
// MessageId: NS_E_WMP_RECORDING_NOT_ALLOWED
//
// MessageText:
//
//  Windows Media Player cannot copy the file. Either the license restricts copying, or you must obtain a license to copy the file.%0
//
#define NS_E_WMP_RECORDING_NOT_ALLOWED   0xC00D0FC9L

//
// MessageId: NS_E_DEVICE_NOT_READY
//
// MessageText:
//
//  Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and try again.%0
//
#define NS_E_DEVICE_NOT_READY            0xC00D0FCAL

//
// MessageId: NS_E_DAMAGED_FILE
//
// MessageText:
//
//  Windows Media Player cannot play the file because it is either damaged or corrupt.%0
//
#define NS_E_DAMAGED_FILE                0xC00D0FCBL

//
// MessageId: NS_E_MPDB_GENERIC
//
// MessageText:
//
//  An error occurred when the Player was attempting to access information in your media library. Try closing and then reopening the Player.%0
//
#define NS_E_MPDB_GENERIC                0xC00D0FCCL

//
// MessageId: NS_E_FILE_FAILED_CHECKS
//
// MessageText:
//
//  The file cannot be added to Media Library because it is smaller than the minimum-size requirement. Adjust the size requirements, and then try again.%0
//
#define NS_E_FILE_FAILED_CHECKS          0xC00D0FCDL

//
// MessageId: NS_E_MEDIA_LIBRARY_FAILED
//
// MessageText:
//
//  Windows Media Player could not create Media Library. Check with your system administrator to get the necessary permissions to create Media Library on your computer, and then try installing the Player again.%0
//
#define NS_E_MEDIA_LIBRARY_FAILED        0xC00D0FCEL

//
// MessageId: NS_E_SHARING_VIOLATION
//
// MessageText:
//
//  The file is already in use. Close other programs that may be using the file, or stop playing the file, and try again.%0
//
#define NS_E_SHARING_VIOLATION           0xC00D0FCFL

//
// Generic Media PlayerUI error codes
//
//
// MessageId: NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED
//
// MessageText:
//
//  The control (%s) does not support creation of sub-controls, yet (%d) sub-controls have been specified.%0
//
#define NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED 0xC00D0FDEL

//
// MessageId: NS_E_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
//  Version mismatch: (%.1f required, %.1f found).%0
//
#define NS_E_WMP_UI_VERSIONMISMATCH      0xC00D0FDFL

//
// MessageId: NS_E_WMP_UI_NOTATHEMEFILE
//
// MessageText:
//
//  The layout manager was given valid XML that wasn't a theme file.%0
//
#define NS_E_WMP_UI_NOTATHEMEFILE        0xC00D0FE0L

//
// MessageId: NS_E_WMP_UI_SUBELEMENTNOTFOUND
//
// MessageText:
//
//  The %s subelement could not be found on the %s object.%0
//
#define NS_E_WMP_UI_SUBELEMENTNOTFOUND   0xC00D0FE1L

//
// MessageId: NS_E_WMP_UI_VERSIONPARSE
//
// MessageText:
//
//  An error occurred parsing the version tag.\nValid version tags are of the form:\n\n\t<?wmp version='1.0'?>.%0
//
#define NS_E_WMP_UI_VERSIONPARSE         0xC00D0FE2L

//
// MessageId: NS_E_WMP_UI_VIEWIDNOTFOUND
//
// MessageText:
//
//  The view specified in for the 'currentViewID' property (%s) was not found in this theme file.%0
//
#define NS_E_WMP_UI_VIEWIDNOTFOUND       0xC00D0FE3L

//
// MessageId: NS_E_WMP_UI_PASSTHROUGH
//
// MessageText:
//
//  This error used internally for hit testing.%0
//
#define NS_E_WMP_UI_PASSTHROUGH          0xC00D0FE4L

//
// MessageId: NS_E_WMP_UI_OBJECTNOTFOUND
//
// MessageText:
//
//  Attributes were specified for the %s object, but the object was not available to send them to.%0
//
#define NS_E_WMP_UI_OBJECTNOTFOUND       0xC00D0FE5L

//
// MessageId: NS_E_WMP_UI_SECONDHANDLER
//
// MessageText:
//
//  The %s event already has a handler, the second handler was ignored.%0
//
#define NS_E_WMP_UI_SECONDHANDLER        0xC00D0FE6L

//
// MessageId: NS_E_WMP_UI_NOSKININZIP
//
// MessageText:
//
//  No .wms file found in skin archive.%0
//
#define NS_E_WMP_UI_NOSKININZIP          0xC00D0FE7L

//
// MessageId: NS_S_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
//  An upgrade may be needed for the theme manager to correctly show this skin. Skin reports version: %.1f.%0
//
#define NS_S_WMP_UI_VERSIONMISMATCH      0x000D0FE8L

//
// MessageId: NS_S_WMP_EXCEPTION
//
// MessageText:
//
//  An error occurred in one of the UI components.%0
//
#define NS_S_WMP_EXCEPTION               0x000D0FE9L

//
// MessageId: NS_E_WMP_URLDOWNLOADFAILED
//
// MessageText:
//
//  Windows Media Player cannot download the file. Check the path to the server, and then try again. For example, if you specified "mms://" in the file name, and the file was actually located on a path beginning with "http://" the file cannot be downloaded, even though it can be played.%0
//
#define NS_E_WMP_URLDOWNLOADFAILED       0xC00D0FEAL

//
// WMP Regional button control
//
//
// MessageId: NS_E_WMP_RBC_JPGMAPPINGIMAGE
//
// MessageText:
//
//  JPG Images are not recommended for use as a mappingImage.%0
//
#define NS_E_WMP_RBC_JPGMAPPINGIMAGE     0xC00D1004L

//
// MessageId: NS_E_WMP_JPGTRANSPARENCY
//
// MessageText:
//
//  JPG Images are not recommended when using a transparencyColor.%0
//
#define NS_E_WMP_JPGTRANSPARENCY         0xC00D1005L

//
// WMP Slider control
//
//
// MessageId: NS_E_WMP_INVALID_MAX_VAL
//
// MessageText:
//
//  The Max property cannot be less than Min property.%0
//
#define NS_E_WMP_INVALID_MAX_VAL         0xC00D1009L

//
// MessageId: NS_E_WMP_INVALID_MIN_VAL
//
// MessageText:
//
//  The Min property cannot be greater than Max property.%0
//
#define NS_E_WMP_INVALID_MIN_VAL         0xC00D100AL

//
// WMP CustomSlider control
//
//
// MessageId: NS_E_WMP_CS_JPGPOSITIONIMAGE
//
// MessageText:
//
//  JPG Images are not recommended for use as a positionImage.%0
//
#define NS_E_WMP_CS_JPGPOSITIONIMAGE     0xC00D100EL

//
// MessageId: NS_E_WMP_CS_NOTEVENLYDIVISIBLE
//
// MessageText:
//
//  The (%s) image's size is not evenly divisible by the positionImage's size.%0
//
#define NS_E_WMP_CS_NOTEVENLYDIVISIBLE   0xC00D100FL

//
// WMP ZIP Decoder
//
//
// MessageId: NS_E_WMPZIP_NOTAZIPFILE
//
// MessageText:
//
//  The ZIP reader opened a file and its signature didn't match that of ZIP files.%0
//
#define NS_E_WMPZIP_NOTAZIPFILE          0xC00D1018L

//
// MessageId: NS_E_WMPZIP_CORRUPT
//
// MessageText:
//
//  The ZIP reader has detected that the file is corrupt.%0
//
#define NS_E_WMPZIP_CORRUPT              0xC00D1019L

//
// MessageId: NS_E_WMPZIP_FILENOTFOUND
//
// MessageText:
//
//  GetFileStream, SaveToFile, or SaveTemp file was called on the ZIP reader with a filename that was not found in the zip file.%0
//
#define NS_E_WMPZIP_FILENOTFOUND         0xC00D101AL

//
// WMP Image Decoding Error codes
//
//
// MessageId: NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED
//
// MessageText:
//
//  Image type not supported.%0
//
#define NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED 0xC00D1022L

//
// MessageId: NS_E_WMP_IMAGE_INVALID_FORMAT
//
// MessageText:
//
//  Image file may be corrupt.%0
//
#define NS_E_WMP_IMAGE_INVALID_FORMAT    0xC00D1023L

//
// MessageId: NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
//  Unexpected end of file. GIF file may be corrupt.%0
//
#define NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE 0xC00D1024L

//
// MessageId: NS_E_WMP_GIF_INVALID_FORMAT
//
// MessageText:
//
//  Invalid GIF file.%0
//
#define NS_E_WMP_GIF_INVALID_FORMAT      0xC00D1025L

//
// MessageId: NS_E_WMP_GIF_BAD_VERSION_NUMBER
//
// MessageText:
//
//  Invalid GIF version. Only 87a or 89a supported.%0
//
#define NS_E_WMP_GIF_BAD_VERSION_NUMBER  0xC00D1026L

//
// MessageId: NS_E_WMP_GIF_NO_IMAGE_IN_FILE
//
// MessageText:
//
//  No images found in GIF file.%0
//
#define NS_E_WMP_GIF_NO_IMAGE_IN_FILE    0xC00D1027L

//
// MessageId: NS_E_WMP_PNG_INVALIDFORMAT
//
// MessageText:
//
//  Invalid PNG image file format.%0
//
#define NS_E_WMP_PNG_INVALIDFORMAT       0xC00D1028L

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH
//
// MessageText:
//
//  PNG bitdepth not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH 0xC00D1029L

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
//  Compression format defined in PNG file not supported,%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION 0xC00D102AL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_FILTER
//
// MessageText:
//
//  Filter method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_FILTER  0xC00D102BL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_INTERLACE
//
// MessageText:
//
//  Interlace method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_INTERLACE 0xC00D102CL

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC
//
// MessageText:
//
//  Bad CRC in PNG file.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC 0xC00D102DL

//
// MessageId: NS_E_WMP_BMP_INVALID_BITMASK
//
// MessageText:
//
//  Invalid bitmask in BMP file.%0
//
#define NS_E_WMP_BMP_INVALID_BITMASK     0xC00D102EL

//
// MessageId: NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED
//
// MessageText:
//
//  Topdown DIB not supported.%0
//
#define NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED 0xC00D102FL

//
// MessageId: NS_E_WMP_BMP_BITMAP_NOT_CREATED
//
// MessageText:
//
//  Bitmap could not be created.%0
//
#define NS_E_WMP_BMP_BITMAP_NOT_CREATED  0xC00D1030L

//
// MessageId: NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED
//
// MessageText:
//
//  Compression format defined in BMP not supported.%0
//
#define NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED 0xC00D1031L

//
// MessageId: NS_E_WMP_BMP_INVALID_FORMAT
//
// MessageText:
//
//  Invalid Bitmap format.%0
//
#define NS_E_WMP_BMP_INVALID_FORMAT      0xC00D1032L

//
// MessageId: NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL
//
// MessageText:
//
//  JPEG Arithmetic coding not supported.%0
//
#define NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL 0xC00D1033L

//
// MessageId: NS_E_WMP_JPG_INVALID_FORMAT
//
// MessageText:
//
//  Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_INVALID_FORMAT      0xC00D1034L

//
// MessageId: NS_E_WMP_JPG_BAD_DCTSIZE
//
// MessageText:
//
//  Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_BAD_DCTSIZE         0xC00D1035L

//
// MessageId: NS_E_WMP_JPG_BAD_VERSION_NUMBER
//
// MessageText:
//
//  Internal version error. Unexpected JPEG library version.%0
//
#define NS_E_WMP_JPG_BAD_VERSION_NUMBER  0xC00D1036L

//
// MessageId: NS_E_WMP_JPG_BAD_PRECISION
//
// MessageText:
//
//  Internal JPEG Library error. Unsupported JPEG data precision.%0
//
#define NS_E_WMP_JPG_BAD_PRECISION       0xC00D1037L

//
// MessageId: NS_E_WMP_JPG_CCIR601_NOTIMPL
//
// MessageText:
//
//  JPEG CCIR601 not supported.%0
//
#define NS_E_WMP_JPG_CCIR601_NOTIMPL     0xC00D1038L

//
// MessageId: NS_E_WMP_JPG_NO_IMAGE_IN_FILE
//
// MessageText:
//
//  No image found in JPEG file.%0
//
#define NS_E_WMP_JPG_NO_IMAGE_IN_FILE    0xC00D1039L

//
// MessageId: NS_E_WMP_JPG_READ_ERROR
//
// MessageText:
//
//  Could not read JPEG file.%0
//
#define NS_E_WMP_JPG_READ_ERROR          0xC00D103AL

//
// MessageId: NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL
//
// MessageText:
//
//  JPEG Fractional sampling not supported.%0
//
#define NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL 0xC00D103BL

//
// MessageId: NS_E_WMP_JPG_IMAGE_TOO_BIG
//
// MessageText:
//
//  JPEG image too large. Maximum image size supported is 65500 X 65500.%0
//
#define NS_E_WMP_JPG_IMAGE_TOO_BIG       0xC00D103CL

//
// MessageId: NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
//  Unexpected end of file reached in JPEG file.%0
//
#define NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE 0xC00D103DL

//
// MessageId: NS_E_WMP_JPG_SOF_UNSUPPORTED
//
// MessageText:
//
//  Unsupported JPEG SOF marker found.%0
//
#define NS_E_WMP_JPG_SOF_UNSUPPORTED     0xC00D103EL

//
// MessageId: NS_E_WMP_JPG_UNKNOWN_MARKER
//
// MessageText:
//
//  Unknown JPEG marker found.%0
//
#define NS_E_WMP_JPG_UNKNOWN_MARKER      0xC00D103FL

//
// MessageId: NS_S_WMP_LOADED_GIF_IMAGE
//
// MessageText:
//
//  Successfully loaded a GIF file.%0
//
#define NS_S_WMP_LOADED_GIF_IMAGE        0x000D1040L

//
// MessageId: NS_S_WMP_LOADED_PNG_IMAGE
//
// MessageText:
//
//  Successfully loaded a PNG file.%0
//
#define NS_S_WMP_LOADED_PNG_IMAGE        0x000D1041L

//
// MessageId: NS_S_WMP_LOADED_BMP_IMAGE
//
// MessageText:
//
//  Successfully loaded a BMP file.%0
//
#define NS_S_WMP_LOADED_BMP_IMAGE        0x000D1042L

//
// MessageId: NS_S_WMP_LOADED_JPG_IMAGE
//
// MessageText:
//
//  Successfully loaded a JPG file.%0
//
#define NS_S_WMP_LOADED_JPG_IMAGE        0x000D1043L

//
// WMP WM Runtime Error codes
//
//
// MessageId: NS_E_WMG_INVALIDSTATE
//
// MessageText:
//
//  Operation attempted in an invalid graph state.%0
//
#define NS_E_WMG_INVALIDSTATE            0xC00D1054L

//
// MessageId: NS_E_WMG_SINKALREADYEXISTS
//
// MessageText:
//
//  A renderer cannot be inserted in a stream while one already exists.%0
//
#define NS_E_WMG_SINKALREADYEXISTS       0xC00D1055L

//
// MessageId: NS_E_WMG_NOSDKINTERFACE
//
// MessageText:
//
//  A necessary WM SDK interface to complete the operation doesn't exist at this time.%0
//
#define NS_E_WMG_NOSDKINTERFACE          0xC00D1056L

//
// MessageId: NS_E_WMG_NOTALLOUTPUTSRENDERED
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file may be formatted with an unsupported codec, or the Player could not download the codec.%0
//
#define NS_E_WMG_NOTALLOUTPUTSRENDERED   0xC00D1057L

//
// MessageId: NS_E_WMR_UNSUPPORTEDSTREAM
//
// MessageText:
//
//  Windows Media Player cannot play the file. The Player does not support the format you are trying to play.%0
//
#define NS_E_WMR_UNSUPPORTEDSTREAM       0xC00D1059L

//
// MessageId: NS_E_WMR_PINNOTFOUND
//
// MessageText:
//
//  An operation was attempted on a pin that doesn't exist in the DirectShow filter graph.%0
//
#define NS_E_WMR_PINNOTFOUND             0xC00D105AL

//
// MessageId: NS_E_WMR_WAITINGONFORMATSWITCH
//
// MessageText:
//
//  Specified operation cannot be completed while waiting for a media format change from the SDK.%0
//
#define NS_E_WMR_WAITINGONFORMATSWITCH   0xC00D105BL

//
// WMP Playlist Error codes
//
//
// MessageId: NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT
//
// MessageText:
//
//  The format of this file was not recognized as a valid playlist format.%0
//
#define NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT 0xC00D1068L

//
// MessageId: NS_E_ASX_INVALIDFORMAT
//
// MessageText:
//
//  This file was believed to be an ASX playlist, but the format was not recognized.%0
//
#define NS_E_ASX_INVALIDFORMAT           0xC00D1069L

//
// MessageId: NS_E_ASX_INVALIDVERSION
//
// MessageText:
//
//  The version of this playlist is not supported. Click Details to go to the microsoft web site and see if there is a newer version of the player to install.%0
//
#define NS_E_ASX_INVALIDVERSION          0xC00D106AL

//
// MessageId: NS_E_ASX_INVALID_REPEAT_BLOCK
//
// MessageText:
//
//  Format of a REPEAT loop within the current playlist file is invalid.%0
//
#define NS_E_ASX_INVALID_REPEAT_BLOCK    0xC00D106BL

//
// MessageId: NS_E_ASX_NOTHING_TO_WRITE
//
// MessageText:
//
//  Windows Media Player cannot export the playlist because it is empty.%0
//
#define NS_E_ASX_NOTHING_TO_WRITE        0xC00D106CL

//
// MessageId: NS_E_URLLIST_INVALIDFORMAT
//
// MessageText:
//
//  Windows Media Player does not recognize this file as a supported playlist.%0
//
#define NS_E_URLLIST_INVALIDFORMAT       0xC00D106DL

//
// MessageId: NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified attribute does not exist.%0
//
#define NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST 0xC00D106EL

//
// MessageId: NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS
//
// MessageText:
//
//  The specified attribute already exists.%0
//
#define NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS 0xC00D106FL

//
// MessageId: NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE
//
// MessageText:
//
//  Can not retrieve the specified attribute.%0
//
#define NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE 0xC00D1070L

//
// MessageId: NS_E_WMX_ITEM_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified item does not exist in the current playlist.%0
//
#define NS_E_WMX_ITEM_DOES_NOT_EXIST     0xC00D1071L

//
// MessageId: NS_E_WMX_ITEM_TYPE_ILLEGAL
//
// MessageText:
//
//  Items of the specified type can not be created within the current playlist.%0
//
#define NS_E_WMX_ITEM_TYPE_ILLEGAL       0xC00D1072L

//
// MessageId: NS_E_WMX_ITEM_UNSETTABLE
//
// MessageText:
//
//  The specified item can not be set in the current playlist.%0
//
#define NS_E_WMX_ITEM_UNSETTABLE         0xC00D1073L

//
// WMP Core  Error codes
//
//
// MessageId: NS_E_WMPCORE_NOSOURCEURLSTRING
//
// MessageText:
//
//  Windows Media Player cannot find the file. Be sure the path is typed correctly. If it is, the file may not exist in the specified location, or the computer where the file is stored may be offline.%0
//
#define NS_E_WMPCORE_NOSOURCEURLSTRING   0xC00D107CL

//
// MessageId: NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT
//
// MessageText:
//
//  Failed to create the Global Interface Table.%0
//
#define NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT 0xC00D107DL

//
// MessageId: NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE
//
// MessageText:
//
//  Failed to get the marshalled graph event handler interface.%0
//
#define NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE 0xC00D107EL

//
// MessageId: NS_E_WMPCORE_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer is too small for copying media type.%0
//
#define NS_E_WMPCORE_BUFFERTOOSMALL      0xC00D107FL

//
// MessageId: NS_E_WMPCORE_UNAVAILABLE
//
// MessageText:
//
//  Current state of the player does not allow the operation.%0
//
#define NS_E_WMPCORE_UNAVAILABLE         0xC00D1080L

//
// MessageId: NS_E_WMPCORE_INVALIDPLAYLISTMODE
//
// MessageText:
//
//  Playlist manager does not understand the current play mode (shuffle, normal etc).%0
//
#define NS_E_WMPCORE_INVALIDPLAYLISTMODE 0xC00D1081L

//
// MessageId: NS_E_WMPCORE_ITEMNOTINPLAYLIST
//
// MessageText:
//
//  The item is not in the playlist.%0
//
#define NS_E_WMPCORE_ITEMNOTINPLAYLIST   0xC00D1086L

//
// MessageId: NS_E_WMPCORE_PLAYLISTEMPTY
//
// MessageText:
//
//  There are no items in this playlist. Add items to the playlist, and try again.%0
//
#define NS_E_WMPCORE_PLAYLISTEMPTY       0xC00D1087L

//
// MessageId: NS_E_WMPCORE_NOBROWSER
//
// MessageText:
//
//  The Web site cannot be accessed. A Web browser is not detected on your computer.%0
//
#define NS_E_WMPCORE_NOBROWSER           0xC00D1088L

//
// MessageId: NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL
//
// MessageText:
//
//  Windows Media Player cannot find the specified file. Be sure the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is offline.%0
//
#define NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL 0xC00D1089L

//
// MessageId: NS_E_WMPCORE_GRAPH_NOT_IN_LIST
//
// MessageText:
//
//  Graph with the specified URL was not found in the prerolled graph list.%0
//
#define NS_E_WMPCORE_GRAPH_NOT_IN_LIST   0xC00D108AL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA
//
// MessageText:
//
//  Operation could not be performed because the playlist does not have more than one item.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA 0xC00D108BL

//
// MessageId: NS_E_WMPCORE_ERRORSINKNOTREGISTERED
//
// MessageText:
//
//  An error sink was never registered for the calling object.%0
//
#define NS_E_WMPCORE_ERRORSINKNOTREGISTERED 0xC00D108CL

//
// MessageId: NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE
//
// MessageText:
//
//  The error manager is not available to respond to errors.%0
//
#define NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE 0xC00D108DL

//
// MessageId: NS_E_WMPCORE_WEBHELPFAILED
//
// MessageText:
//
//  Failed launching WebHelp URL.%0
//
#define NS_E_WMPCORE_WEBHELPFAILED       0xC00D108EL

//
// MessageId: NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED
//
// MessageText:
//
//  Could not resume playing next item in playlist.%0
//
#define NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED 0xC00D108FL

//
// MessageId: NS_E_WMPCORE_NO_REF_IN_ENTRY
//
// MessageText:
//
//  No URL specified in the Ref attribute in playlist file.%0
//
#define NS_E_WMPCORE_NO_REF_IN_ENTRY     0xC00D1090L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
//  An empty string for playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY 0xC00D1091L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
//  An invalid playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL 0xC00D1092L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
//  An empty string for a playlist attribute value was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY 0xC00D1093L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL
//
// MessageText:
//
//  An illegal value for a playlist attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL 0xC00D1094L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
//  An empty string for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY 0xC00D1095L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
//  An illegal value for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL 0xC00D1096L

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
//  An illegal value for a playlist item attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY 0xC00D1097L

//
// MessageId: NS_E_WMPCORE_LIST_ENTRY_NO_REF
//
// MessageText:
//
//  No entries found in the playlist file.%0
//
#define NS_E_WMPCORE_LIST_ENTRY_NO_REF   0xC00D1098L

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_TRUSTED
//
// MessageText:
//
//  The codec downloaded for this media does not appear to be properly signed. Installation is not possible.%0
//
#define NS_E_WMPCORE_CODEC_NOT_TRUSTED   0xC00D109AL

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play the file. One or more codecs required to play the file could not be found.%0
//
#define NS_E_WMPCORE_CODEC_NOT_FOUND     0xC00D109BL

//
// MessageId: NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED
//
// MessageText:
//
//  Some of the codecs required by this media are not installed on your system. Since the option for automatic codec acquisition is disabled, no codecs will be downloaded.%0
//
#define NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED 0xC00D109CL

//
// MessageId: NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST
//
// MessageText:
//
//  Failed to download the playlist file.%0
//
#define NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST 0xC00D109DL

//
// MessageId: NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST
//
// MessageText:
//
//  Failed to build the playlist.%0
//
#define NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST 0xC00D109EL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE
//
// MessageText:
//
//  Playlist has no alternates to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE 0xC00D109FL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED
//
// MessageText:
//
//  No more playlist alternates available to switch to.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED 0xC00D10A0L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND
//
// MessageText:
//
//  Could not find the name of the alternate playlist to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND 0xC00D10A1L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED
//
// MessageText:
//
//  Failed to switch to an alternate for this media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED 0xC00D10A2L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED
//
// MessageText:
//
//  Failed to initialize an alternate for the media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED 0xC00D10A3L

//
// MessageId: NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY
//
// MessageText:
//
//  No URL specified for the roll over Refs in the playlist file.%0
//
#define NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY 0xC00D10A4L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME
//
// MessageText:
//
//  Encountered a playlist with no name.%0
//
#define NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME 0xC00D10A5L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT
//
// MessageText:
//
//  A required attribute in the event block of the playlist was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT 0xC00D10A6L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY
//
// MessageText:
//
//  No items were found in the event block of the playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY 0xC00D10A7L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_STACK_EMPTY
//
// MessageText:
//
//  No playlist was found while returning from a nested playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_STACK_EMPTY 0xC00D10A8L

//
// MessageId: NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE
//
// MessageText:
//
//  The media item is not active currently.%0
//
#define NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE 0xC00D10A9L

//
// MessageId: NS_E_WMPCORE_USER_CANCEL
//
// MessageText:
//
//  Open was aborted by user.%0
//
#define NS_E_WMPCORE_USER_CANCEL         0xC00D10ABL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY
//
// MessageText:
//
//  No items were found inside the playlist repeat block.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY 0xC00D10ACL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE
//
// MessageText:
//
//  Media object corresponding to start of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE 0xC00D10ADL

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE
//
// MessageText:
//
//  Media object corresponding to the end of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE 0xC00D10AEL

//
// MessageId: NS_E_WMPCORE_INVALID_PLAYLIST_URL
//
// MessageText:
//
//  Playlist URL supplied to the playlist manager is invalid.%0
//
#define NS_E_WMPCORE_INVALID_PLAYLIST_URL 0xC00D10AFL

//
// MessageId: NS_E_WMPCORE_MISMATCHED_RUNTIME
//
// MessageText:
//
//  Player is selecting a runtime that is not valid for this media file type.%0
//
#define NS_E_WMPCORE_MISMATCHED_RUNTIME  0xC00D10B0L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS
//
// MessageText:
//
//  Windows Media Player cannot import the playlist to Media Library because the playlist is empty.%0
//
#define NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS 0xC00D10B1L

//
// MessageId: NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION
//
// MessageText:
//
//  An error has occurred that could prevent the changing of the video contrast on this media.%0
//
#define NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION 0xC00D10B2L

//
// MessageId: NS_E_WMPCORE_MEDIA_UNAVAILABLE
//
// MessageText:
//
//  Windows Media Player cannot play this file. Connect to the Internet or insert the removable media on which the file is located, and then try to play the file again.%0
//
#define NS_E_WMPCORE_MEDIA_UNAVAILABLE   0xC00D10B3L

//
// MessageId: NS_E_WMPCORE_WMX_ENTRYREF_NO_REF
//
// MessageText:
//
//  The playlist contains an ENTRYREF for which no href was parsed. Check the syntax of playlist file.%0
//
#define NS_E_WMPCORE_WMX_ENTRYREF_NO_REF 0xC00D10B4L

//
// MessageId: NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST
//
// MessageText:
//
//  Windows Media Player cannot play any items in this playlist. For additional information, right-click an item that cannot be played, and then click Error Details.%0
//
#define NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST 0xC00D10B5L

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS
//
// MessageText:
//
//  Windows Media Player cannot play some or all of the playlist items.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS 0xC00D10B6L

//
// MessageId: NS_E_WMPCORE_BUSY
//
// MessageText:
//
//  Windows Media Player could not handle your request for digital media content in a timely manner. Try again later.%0
//
#define NS_E_WMPCORE_BUSY                0xC00D10B7L

//
// MessageId: NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE
//
// MessageText:
//
//  There is no child playlist available for this media item at this time.%0
//
#define NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE 0xC00D10B8L

//
// MessageId: NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST
//
// MessageText:
//
//  There is no child playlist for this media item.%0
//
#define NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST 0xC00D10B9L

//
// MessageId: NS_E_WMPCORE_FILE_NOT_FOUND
//
// MessageText:
//
//  Windows Media Player cannot play one or more files. Right-click the file, and then click Error Details to view information about the error.%0
//
#define NS_E_WMPCORE_FILE_NOT_FOUND      0xC00D10BAL

//
// MessageId: NS_E_WMPCORE_TEMP_FILE_NOT_FOUND
//
// MessageText:
//
//  The temporary file was not found.%0
//
#define NS_E_WMPCORE_TEMP_FILE_NOT_FOUND 0xC00D10BBL

//
// MessageId: NS_E_WMDM_REVOKED
//
// MessageText:
//
//  Windows Media Player cannot transfer media to the portable device without an update.  Please click details to find out how to update your device.%0
//
#define NS_E_WMDM_REVOKED                0xC00D10BCL

//
// MessageId: NS_E_DDRAW_GENERIC
//
// MessageText:
//
//  Windows Media Player cannot play the video stream because of a problem with your video card.%0
//
#define NS_E_DDRAW_GENERIC               0xC00D10BDL

//
// MessageId: NS_E_DISPLAY_MODE_CHANGE_FAILED
//
// MessageText:
//
//  Windows Media Player failed to change the screen mode for fullscreen video playback.%0
//
#define NS_E_DISPLAY_MODE_CHANGE_FAILED  0xC00D10BEL

//
// MessageId: NS_E_PLAYLIST_CONTAINS_ERRORS
//
// MessageText:
//
//  One or more items in the playlist cannot be played. For more details, right-click an item in the playlist, and then click Error Details.%0
//
#define NS_E_PLAYLIST_CONTAINS_ERRORS    0xC00D10BFL

//
// WMP Core  Success codes
//
//
// MessageId: NS_S_WMPCORE_PLAYLISTCLEARABORT
//
// MessageText:
//
//  Failed to clear playlist because it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTCLEARABORT  0x000D10FEL

//
// MessageId: NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT
//
// MessageText:
//
//  Failed to remove item in the playlist since it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT 0x000D10FFL

//
// MessageId: NS_S_WMPCORE_PLAYLIST_CREATION_PENDING
//
// MessageText:
//
//  Playlist is being generated asynchronously.%0
//
#define NS_S_WMPCORE_PLAYLIST_CREATION_PENDING 0x000D1102L

//
// MessageId: NS_S_WMPCORE_MEDIA_VALIDATION_PENDING
//
// MessageText:
//
//  Validation of the media is pending...%0
//
#define NS_S_WMPCORE_MEDIA_VALIDATION_PENDING 0x000D1103L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED
//
// MessageText:
//
//  Encountered more than one Repeat block during ASX processing.%0
//
#define NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED 0x000D1104L

//
// MessageId: NS_S_WMPCORE_COMMAND_NOT_AVAILABLE
//
// MessageText:
//
//  Current state of WMP disallows calling this method or property.%0
//
#define NS_S_WMPCORE_COMMAND_NOT_AVAILABLE 0x000D1105L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED
//
// MessageText:
//
//  Name for the playlist has been auto generated.%0
//
#define NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED 0x000D1106L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS
//
// MessageText:
//
//  The imported playlist does not contain all items from the original.%0
//
#define NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS 0x000D1107L

//
// MessageId: NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA
//
// MessageText:
//
//  The M3U playlist has been ignored because it only contains one item.%0
//
#define NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA 0x000D1108L

//
// MessageId: NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING
//
// MessageText:
//
//  The open for the child playlist associated with this media is pending.%0
//
#define NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING 0x000D1109L

//
// WMP Internet Manager error codes
//
//
// MessageId: NS_E_WMPIM_USEROFFLINE
//
// MessageText:
//
//  Windows Media Player has detected that you are not connected to the Internet. Connect to the Internet, and then try again.%0
//
#define NS_E_WMPIM_USEROFFLINE           0xC00D1126L

//
// MessageId: NS_E_WMPIM_USERCANCELED
//
// MessageText:
//
//  User cancelled attempt to connect to the Internet.%0
//
#define NS_E_WMPIM_USERCANCELED          0xC00D1127L

//
// MessageId: NS_E_WMPIM_DIALUPFAILED
//
// MessageText:
//
//  Attempt to dial connection to the Internet failed.%0
//
#define NS_E_WMPIM_DIALUPFAILED          0xC00D1128L

//
// WMP Backup and restore error and success codes
//
//
// MessageId: NS_E_WMPBR_NOLISTENER
//
// MessageText:
//
//  No window is currently listening to Backup and Restore events.%0
//
#define NS_E_WMPBR_NOLISTENER            0xC00D1130L

//
// MessageId: NS_E_WMPBR_BACKUPCANCEL
//
// MessageText:
//
//  Backup of your licenses has been cancelled.  Please try again to ensure license backup.%0
//
#define NS_E_WMPBR_BACKUPCANCEL          0xC00D1131L

//
// MessageId: NS_E_WMPBR_RESTORECANCEL
//
// MessageText:
//
//  The licenses were not restored because the restoration was cancelled.%0
//
#define NS_E_WMPBR_RESTORECANCEL         0xC00D1132L

//
// MessageId: NS_E_WMPBR_ERRORWITHURL
//
// MessageText:
//
//  An error occurred during the backup or restore operation that requires a web page be displayed to the user.%0
//
#define NS_E_WMPBR_ERRORWITHURL          0xC00D1133L

//
// MessageId: NS_E_WMPBR_NAMECOLLISION
//
// MessageText:
//
//  The licenses were not backed up because the backup was cancelled.%0
//
#define NS_E_WMPBR_NAMECOLLISION         0xC00D1134L

//
// MessageId: NS_S_WMPBR_SUCCESS
//
// MessageText:
//
//  Backup or Restore successful!.%0
//
#define NS_S_WMPBR_SUCCESS               0x000D1135L

//
// MessageId: NS_S_WMPBR_PARTIALSUCCESS
//
// MessageText:
//
//  Transfer complete with limitations.%0
//
#define NS_S_WMPBR_PARTIALSUCCESS        0x000D1136L

//
// WMP Effects Success codes
//
//
// MessageId: NS_S_WMPEFFECT_TRANSPARENT
//
// MessageText:
//
//  Request to the effects control to change transparency status to transparent.%0
//
#define NS_S_WMPEFFECT_TRANSPARENT       0x000D1144L

//
// MessageId: NS_S_WMPEFFECT_OPAQUE
//
// MessageText:
//
//  Request to the effects control to change transparency status to opaque.%0
//
#define NS_S_WMPEFFECT_OPAQUE            0x000D1145L

//
// WMP Application Success codes
//
//
// MessageId: NS_S_OPERATION_PENDING
//
// MessageText:
//
//  The requested application pane is performing an operation and will not be relased.%0
//
#define NS_S_OPERATION_PENDING           0x000D114EL

//
// WMP DVD Error Codes
//
//
// MessageId: NS_E_DVD_NO_SUBPICTURE_STREAM
//
// MessageText:
//
//  Windows Media Player cannot display subtitles or highlights in menus. Reinstall the DVD decoder or contact your device manufacturer to obtain an updated decoder, and then try again.%0
//
#define NS_E_DVD_NO_SUBPICTURE_STREAM    0xC00D1162L

//
// MessageId: NS_E_DVD_COPY_PROTECT
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a problem occurred with digital copyright protection.%0
//
#define NS_E_DVD_COPY_PROTECT            0xC00D1163L

//
// MessageId: NS_E_DVD_AUTHORING_PROBLEM
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc is incompatible with the Player.%0
//
#define NS_E_DVD_AUTHORING_PROBLEM       0xC00D1164L

//
// MessageId: NS_E_DVD_INVALID_DISC_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc prohibits playback in your region of the world. You must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_INVALID_DISC_REGION     0xC00D1165L

//
// MessageId: NS_E_DVD_COMPATIBLE_VIDEO_CARD
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because your video card does not support DVD playback.%0
//
#define NS_E_DVD_COMPATIBLE_VIDEO_CARD   0xC00D1166L

//
// MessageId: NS_E_DVD_MACROVISION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a problem occurred with analog copyright protection.%0
//
#define NS_E_DVD_MACROVISION             0xC00D1167L

//
// MessageId: NS_E_DVD_SYSTEM_DECODER_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the region assigned to your DVD drive does not match the region assigned to your DVD decoder.%0
//
#define NS_E_DVD_SYSTEM_DECODER_REGION   0xC00D1168L

//
// MessageId: NS_E_DVD_DISC_DECODER_REGION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because the disc prohibits playback in your region of the world. To play the disc by using the Player, you must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_DISC_DECODER_REGION     0xC00D1169L

//
// MessageId: NS_E_DVD_NO_VIDEO_STREAM
//
// MessageText:
//
//  Windows Media Player is currently unable to play DVD video. Close any open files and quit any other running programs, and then try again.%0
//
#define NS_E_DVD_NO_VIDEO_STREAM         0xC00D116AL

//
// MessageId: NS_E_DVD_NO_AUDIO_STREAM
//
// MessageText:
//
//  Windows Media Player cannot play DVD audio. Verify that your sound card is set up correctly, and then try again.%0
//
#define NS_E_DVD_NO_AUDIO_STREAM         0xC00D116BL

//
// MessageId: NS_E_DVD_GRAPH_BUILDING
//
// MessageText:
//
//  Windows Media Player cannot play DVD video. Close any open files and quit any other running programs, and then try again. If the problem continues, restart your computer.%0
//
#define NS_E_DVD_GRAPH_BUILDING          0xC00D116CL

//
// MessageId: NS_E_DVD_NO_DECODER
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because a compatible DVD decoder is not installed on your computer.%0
//
#define NS_E_DVD_NO_DECODER              0xC00D116DL

//
// MessageId: NS_E_DVD_PARENTAL
//
// MessageText:
//
//  Windows Media Player cannot play this DVD segment because the segment has a parental rating higher than the rating you are authorized to view.%0
//
#define NS_E_DVD_PARENTAL                0xC00D116EL

//
// MessageId: NS_E_DVD_CANNOT_JUMP
//
// MessageText:
//
//  Windows Media Player cannot skip to the requested location in the DVD at this time.%0
//
#define NS_E_DVD_CANNOT_JUMP             0xC00D116FL

//
// MessageId: NS_E_DVD_DEVICE_CONTENTION
//
// MessageText:
//
//  Windows Media Player cannot play this DVD because it is currently in use by another program. Quit the other program that is using the DVD, and then try to play it again.%0
//
#define NS_E_DVD_DEVICE_CONTENTION       0xC00D1170L

//
// MessageId: NS_E_DVD_NO_VIDEO_MEMORY
//
// MessageText:
//
//  Windows Media Player cannot play DVD video. Double-click Display in Control Panel to lower your screen resolution and color quality settings.%0
//
#define NS_E_DVD_NO_VIDEO_MEMORY         0xC00D1171L

//
// WMP PDA Error codes
//
//
// MessageId: NS_E_NO_CD_BURNER
//
// MessageText:
//
//  A CD recorder (burner) was not detected. Connect a CD recorder, and try copying again.%0
//
#define NS_E_NO_CD_BURNER                0xC00D1176L

//
// MessageId: NS_E_DEVICE_IS_NOT_READY
//
// MessageText:
//
//  Windows Media Player does not detect any removable media in your portable device. Insert the media in the device or check the connection between the device and your computer, and then press F5 to refresh.%0
//
#define NS_E_DEVICE_IS_NOT_READY         0xC00D1177L

//
// MessageId: NS_E_PDA_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the specified file. Your portable device does not support the specified format.%0
//
#define NS_E_PDA_UNSUPPORTED_FORMAT      0xC00D1178L

//
// MessageId: NS_E_NO_PDA
//
// MessageText:
//
//  Windows Media Player cannot detect a connected portable device. Connect your portable device, and try again.%0
//
#define NS_E_NO_PDA                      0xC00D1179L

//
// General Remapped Error codes in WMP
//
//
// MessageId: NS_E_WMP_PROTOCOL_PROBLEM
//
// MessageText:
//
//  Windows Media Player could not open the specified URL. Be sure Windows Media Player is configured to use all available protocols, and then try again.%0
//
#define NS_E_WMP_PROTOCOL_PROBLEM        0xC00D1194L

//
// MessageId: NS_E_WMP_NO_DISK_SPACE
//
// MessageText:
//
//  Windows Media Player cannot open the file because there is not enough disk space on your computer. Delete some unneeded files on your hard disk, and then try again.%0
//
#define NS_E_WMP_NO_DISK_SPACE           0xC00D1195L

//
// MessageId: NS_E_WMP_LOGON_FAILURE
//
// MessageText:
//
//  The user name or password is incorrect. Type your user name or password again.%0
//
#define NS_E_WMP_LOGON_FAILURE           0xC00D1196L

//
// MessageId: NS_E_WMP_CANNOT_FIND_FILE
//
// MessageText:
//
//  Windows Media Player cannot find the specified file. Be sure the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is offline.%0
//
#define NS_E_WMP_CANNOT_FIND_FILE        0xC00D1197L

//
// MessageId: NS_E_WMP_SERVER_INACCESSIBLE
//
// MessageText:
//
//  Windows Media Player cannot connect to the server. The server name may be incorrect or the server is busy. Try again later.%0
//
#define NS_E_WMP_SERVER_INACCESSIBLE     0xC00D1198L

//
// MessageId: NS_E_WMP_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file is either corrupt or the Player does not support the format you are trying to play.%0
//
#define NS_E_WMP_UNSUPPORTED_FORMAT      0xC00D1199L

//
// MessageId: NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT
//
// MessageText:
//
//  Windows Media Player cannot play the file. The file may be formatted with an unsupported codec, or the Internet security setting on your computer is set too high. Lower your browser's security setting, and then try again.%0
//
#define NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT 0xC00D119AL

//
// MessageId: NS_E_WMP_PLAYLIST_EXISTS
//
// MessageText:
//
//  Windows Media Player cannot create the playlist because the name already exists. Type a different playlist name.%0
//
#define NS_E_WMP_PLAYLIST_EXISTS         0xC00D119BL

//
// MessageId: NS_E_WMP_NONMEDIA_FILES
//
// MessageText:
//
//  Windows Media Player could not delete the playlist because it contains non-digital media files. Any digital media files in the playlist were deleted. Use Windows Explorer to delete non-digital media files, and then try deleting the playlist again.%0
//
#define NS_E_WMP_NONMEDIA_FILES          0xC00D119CL

//
// MessageId: NS_E_WMP_INVALID_ASX
//
// MessageText:
//
//  Windows Media Player cannot play the selected playlist.  The format of the playlist is either invalid or is not recognized.%0
//
#define NS_E_WMP_INVALID_ASX             0xC00D119DL

//
// MessageId: NS_E_WMP_ALREADY_IN_USE
//
// MessageText:
//
//  Windows Media Player is already in use. Stop playing any content and close all Player dialog boxes and then try again.%0
//
#define NS_E_WMP_ALREADY_IN_USE          0xC00D119EL

//
// WMP CD Filter Error codes extension
//
//
// MessageId: NS_E_CD_NO_BUFFERS_READ
//
// MessageText:
//
//  Windows Media Player encountered an error when reading the CD-ROM drive in digital mode. You can try to use digital mode again, or you can switch the Player to analog mode.%0
//
#define NS_E_CD_NO_BUFFERS_READ          0xC00D11F8L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Server Errors
//
// IdRange = 5000 - 5999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_REDIRECT
//
// MessageText:
//
//  The client is redirected to another server.%0
//
#define NS_E_REDIRECT                    0xC00D1388L

//
// MessageId: NS_E_STALE_PRESENTATION
//
// MessageText:
//
//  The streaming media description is no longer current.%0
//
#define NS_E_STALE_PRESENTATION          0xC00D1389L


 // Namespace Errors

//
// MessageId: NS_E_NAMESPACE_WRONG_PERSIST
//
// MessageText:
//
//  Attempt to create a persistent namespace node under a transient parent node.%0
//
#define NS_E_NAMESPACE_WRONG_PERSIST     0xC00D138AL

//
// MessageId: NS_E_NAMESPACE_WRONG_TYPE
//
// MessageText:
//
//  Unable to store a value in a namespace node of different value type.%0
//
#define NS_E_NAMESPACE_WRONG_TYPE        0xC00D138BL

//
// MessageId: NS_E_NAMESPACE_NODE_CONFLICT
//
// MessageText:
//
//  Unable to remove the root namespace node.%0
//
#define NS_E_NAMESPACE_NODE_CONFLICT     0xC00D138CL

//
// MessageId: NS_E_NAMESPACE_NODE_NOT_FOUND
//
// MessageText:
//
//  Could not find the specified namespace node.%0
//
#define NS_E_NAMESPACE_NODE_NOT_FOUND    0xC00D138DL

//
// MessageId: NS_E_NAMESPACE_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer supplied to hold namespace node string is too small.%0
//
#define NS_E_NAMESPACE_BUFFER_TOO_SMALL  0xC00D138EL

//
// MessageId: NS_E_NAMESPACE_TOO_MANY_CALLBACKS
//
// MessageText:
//
//  Callback list on a namespace node is at maximum size.%0
//
#define NS_E_NAMESPACE_TOO_MANY_CALLBACKS 0xC00D138FL

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_CALLBACK
//
// MessageText:
//
//  Attempt to register an already-registered callback on a namespace node.%0
//
#define NS_E_NAMESPACE_DUPLICATE_CALLBACK 0xC00D1390L

//
// MessageId: NS_E_NAMESPACE_CALLBACK_NOT_FOUND
//
// MessageText:
//
//  Could not find callback in namespace when attempting to remove callback.%0
//
#define NS_E_NAMESPACE_CALLBACK_NOT_FOUND 0xC00D1391L

//
// MessageId: NS_E_NAMESPACE_NAME_TOO_LONG
//
// MessageText:
//
//  The length of a namespace node name exceeds the allowed maximum length.%0
//
#define NS_E_NAMESPACE_NAME_TOO_LONG     0xC00D1392L

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_NAME
//
// MessageText:
//
//  Cannot create a namespace node which already exists.%0
//
#define NS_E_NAMESPACE_DUPLICATE_NAME    0xC00D1393L

//
// MessageId: NS_E_NAMESPACE_EMPTY_NAME
//
// MessageText:
//
//  The name of a namespace node cannot be a null string.%0
//
#define NS_E_NAMESPACE_EMPTY_NAME        0xC00D1394L

//
// MessageId: NS_E_NAMESPACE_INDEX_TOO_LARGE
//
// MessageText:
//
//  Finding a child namespace node by index failed because the index exceeded the number of children.%0
//
#define NS_E_NAMESPACE_INDEX_TOO_LARGE   0xC00D1395L

//
// MessageId: NS_E_NAMESPACE_BAD_NAME
//
// MessageText:
//
//  The name supplied for a namespace node is not valid.%0
//
#define NS_E_NAMESPACE_BAD_NAME          0xC00D1396L

//
// MessageId: NS_E_NAMESPACE_WRONG_SECURITY
//
// MessageText:
//
//  Unable to store a value in a namespace node of different security type.%0
//
#define NS_E_NAMESPACE_WRONG_SECURITY    0xC00D1397L


 // Cache Errors 5100-5199

//
// MessageId: NS_E_CACHE_ARCHIVE_CONFLICT
//
// MessageText:
//
//  Archive request conflicts with other requests in progress.%0
//
#define NS_E_CACHE_ARCHIVE_CONFLICT      0xC00D13ECL

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND
//
// MessageText:
//
//  The specified origin server cannot be found.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND 0xC00D13EDL

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_TIMEOUT
//
// MessageText:
//
//  The specified origin server does not respond.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_TIMEOUT 0xC00D13EEL

//
// MessageId: NS_E_CACHE_NOT_BROADCAST
//
// MessageText:
//
//  The internal code for HTTP status code 412 Precondition Failed due to not broadcast type.%0
//
#define NS_E_CACHE_NOT_BROADCAST         0xC00D13EFL

//
// MessageId: NS_E_CACHE_CANNOT_BE_CACHED
//
// MessageText:
//
//  The internal code for HTTP status code 403 Forbidden due to not cacheable.%0
//
#define NS_E_CACHE_CANNOT_BE_CACHED      0xC00D13F0L

//
// MessageId: NS_E_CACHE_NOT_MODIFIED
//
// MessageText:
//
//  The internal code for HTTP status code 304 Not Modified.%0
//
#define NS_E_CACHE_NOT_MODIFIED          0xC00D13F1L


// Object Model Errors 5200-5299

//
// MessageId: NS_E_CANNOT_REMOVE_PUBLISHING_POINT
//
// MessageText:
//
//  Publishing Points of type Cache or Proxy cannot be removed.%0
//
#define NS_E_CANNOT_REMOVE_PUBLISHING_POINT 0xC00D1450L

//
// MessageId: NS_E_CANNOT_REMOVE_PLUGIN
//
// MessageText:
//
//  Cannot remove last instance of plugin.%0
//
#define NS_E_CANNOT_REMOVE_PLUGIN        0xC00D1451L

//
// MessageId: NS_E_WRONG_PUBLISHING_POINT_TYPE
//
// MessageText:
//
//  Publishing Points of type Cache or Proxy do not support this property or method.%0
//
#define NS_E_WRONG_PUBLISHING_POINT_TYPE 0xC00D1452L

//
// MessageId: NS_E_UNSUPPORTED_LOAD_TYPE
//
// MessageText:
//
//  The Plugin does not support the specified Load Type.%0
//
#define NS_E_UNSUPPORTED_LOAD_TYPE       0xC00D1453L

//
// MessageId: NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION
//
// MessageText:
//
//  The Plugin does not support any Load Types.  The Plugin must support at least one Load Type.%0
//
#define NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION 0xC00D1454L

//
// MessageId: NS_E_INVALID_PUBLISHING_POINT_NAME
//
// MessageText:
//
//  The publishing point name contains invalid characters.%0
//
#define NS_E_INVALID_PUBLISHING_POINT_NAME 0xC00D1455L

//
// MessageId: NS_E_TOO_MANY_MULTICAST_SINKS
//
// MessageText:
//
//  Only one multicast data sink plug-in can be enabled on a publishing point.%0
//
#define NS_E_TOO_MANY_MULTICAST_SINKS    0xC00D1456L

//
// MessageId: NS_E_PUBLISHING_POINT_INVALID_REQUEST_WHILE_STARTED
//
// MessageText:
//
//  The requested operation cannot be completed while the publishing point is started.%0
//
#define NS_E_PUBLISHING_POINT_INVALID_REQUEST_WHILE_STARTED 0xC00D1457L


// Playlist Errors 5300-5399

//
// MessageId: NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING
//
// MessageText:
//
//  The playlist entry is already playing.%0
//
#define NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING 0xC00D14B4L

//
// MessageId: NS_E_EMPTY_PLAYLIST
//
// MessageText:
//
//  The playlist or directory you are requesting does not contain content.%0
//
#define NS_E_EMPTY_PLAYLIST              0xC00D14B5L

//
// MessageId: NS_E_PLAYLIST_PARSE_FAILURE
//
// MessageText:
//
//  The server was unable to parse the requested playlist file.%0
//
#define NS_E_PLAYLIST_PARSE_FAILURE      0xC00D14B6L


// Datapath Errors -- 5400 - 5499

//
// MessageId: NS_E_DATAPATH_NO_SINK
//
// MessageText:
//
//  The datapath does not have a sink.%0
//
#define NS_E_DATAPATH_NO_SINK            0xC00D1518L

//
// MessageId: NS_S_PUBLISHING_POINT_STARTED_WITH_FAILED_SINKS
//
// MessageText:
//
//  The publishing point successfully started, but one or more of the requested sinks failed.%0
//
#define NS_S_PUBLISHING_POINT_STARTED_WITH_FAILED_SINKS 0x000D1519L

//
// MessageId: NS_E_INVALID_PUSH_TEMPLATE
//
// MessageText:
//
//  The specified Push Template is invalid.%0
//
#define NS_E_INVALID_PUSH_TEMPLATE       0xC00D151AL

//
// MessageId: NS_E_INVALID_PUSH_PUBLISHING_POINT
//
// MessageText:
//
//  The specified Push Publishing Point is invalid.%0
//
#define NS_E_INVALID_PUSH_PUBLISHING_POINT 0xC00D151BL

//
// MessageId: NS_E_CRITICAL_ERROR
//
// MessageText:
//
//  The requested operation cannot be performed because the server or publishing point is in a critical error state.%0
//
#define NS_E_CRITICAL_ERROR              0xC00D151CL

//
// MessageId: NS_E_NO_NEW_CONNECTIONS
//
// MessageText:
//
//  The content can not be played because server is not currently accepting connections. Try connecting at a later time.%0
//
#define NS_E_NO_NEW_CONNECTIONS          0xC00D151DL


// Plugin Errors -- 5500 - 5599

//
// MessageId: NS_E_NO_SCRIPT_ENGINE
//
// MessageText:
//
//  There is no script engine available for this file.%0
//
#define NS_E_NO_SCRIPT_ENGINE            0xC00D157CL

//
// MessageId: NS_E_PLUGIN_ERROR_REPORTED
//
// MessageText:
//
//  The plugin has reported an error. See the Server Troubleshooting information or NT Application Event Log for details.%0
//
#define NS_E_PLUGIN_ERROR_REPORTED       0xC00D157DL

//
// MessageId: NS_E_SOURCE_PLUGIN_NOT_FOUND
//
// MessageText:
//
//  No enabled data source plug-in is available to access the requested content.%0
//
#define NS_E_SOURCE_PLUGIN_NOT_FOUND     0xC00D157EL

//
// MessageId: NS_E_PLAYLIST_PLUGIN_NOT_FOUND
//
// MessageText:
//
//  No enabled playlist parser plug-in is available to access the requested content.%0
//
#define NS_E_PLAYLIST_PLUGIN_NOT_FOUND   0xC00D157FL

//
// MessageId: NS_E_DATA_SOURCE_ENUMERATION_NOT_SUPPORTED
//
// MessageText:
//
//  The data source plugin does not support enumeration.%0
//
#define NS_E_DATA_SOURCE_ENUMERATION_NOT_SUPPORTED 0xC00D1580L

//
// MessageId: NS_E_MEDIA_PARSER_INVALID_FORMAT
//
// MessageText:
//
//  The server cannot stream the selected file because it is either damaged or corrupt. Please select a different file.%0
//
#define NS_E_MEDIA_PARSER_INVALID_FORMAT 0xC00D1581L



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Tools Errors
//
// IdRange = 7000 - 7999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_BAD_MARKIN
//
// MessageText:
//
//  The Mark In time should be greater than 0 and less than Mark Out time.%0
//
#define NS_E_BAD_MARKIN                  0xC00D1B58L

//
// MessageId: NS_E_BAD_MARKOUT
//
// MessageText:
//
//  The Mark Out time should be greater than Mark In time and less than file duration.%0
//
#define NS_E_BAD_MARKOUT                 0xC00D1B59L

//
// MessageId: NS_E_NOMATCHING_MEDIASOURCE
//
// MessageText:
//
//  No matching media source is found in source group %1.%0
//
#define NS_E_NOMATCHING_MEDIASOURCE      0xC00D1B5AL

//
// MessageId: NS_E_UNSUPPORTED_SOURCETYPE
//
// MessageText:
//
//  Unsupported source type.%0
//
#define NS_E_UNSUPPORTED_SOURCETYPE      0xC00D1B5BL

//
// MessageId: NS_E_TOO_MANY_AUDIO
//
// MessageText:
//
//  No more than 1 audio input is allowed.%0
//
#define NS_E_TOO_MANY_AUDIO              0xC00D1B5CL

//
// MessageId: NS_E_TOO_MANY_VIDEO
//
// MessageText:
//
//  No more than 2 video inputs are allowed.%0
//
#define NS_E_TOO_MANY_VIDEO              0xC00D1B5DL

//
// MessageId: NS_E_NOMATCHING_ELEMENT
//
// MessageText:
//
//  No matching element is found in the list.%0
//
#define NS_E_NOMATCHING_ELEMENT          0xC00D1B5EL

//
// MessageId: NS_E_MISMATCHED_MEDIACONTENT
//
// MessageText:
//
//  The profile's media content doesn't match the media content defined in the source group.%0
//
#define NS_E_MISMATCHED_MEDIACONTENT     0xC00D1B5FL

//
// MessageId: NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP
//
// MessageText:
//
//  Cannot remove an active source group from the source group collection while encoder is currently running.%0
//
#define NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP 0xC00D1B60L

//
// MessageId: NS_E_AUDIODEVICE_BUSY
//
// MessageText:
//
//  Cannot open specified audio capture device because it is in use right now.%0
//
#define NS_E_AUDIODEVICE_BUSY            0xC00D1B61L

//
// MessageId: NS_E_AUDIODEVICE_UNEXPECTED
//
// MessageText:
//
//  Cannot open specified audio capture device because unexpected error occurred.%0
//
#define NS_E_AUDIODEVICE_UNEXPECTED      0xC00D1B62L

//
// MessageId: NS_E_AUDIODEVICE_BADFORMAT
//
// MessageText:
//
//  Audio capture device doesn't support specified audio format.%0
//
#define NS_E_AUDIODEVICE_BADFORMAT       0xC00D1B63L

//
// MessageId: NS_E_VIDEODEVICE_BUSY
//
// MessageText:
//
//  Cannot open specified video capture device because it is in use right now.%0
//
#define NS_E_VIDEODEVICE_BUSY            0xC00D1B64L

//
// MessageId: NS_E_VIDEODEVICE_UNEXPECTED
//
// MessageText:
//
//  Cannot open specified video capture device because unexpected error occurred.%0
//
#define NS_E_VIDEODEVICE_UNEXPECTED      0xC00D1B65L

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING
//
// MessageText:
//
//  This operation is not allowed while encoder is running.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING 0xC00D1B66L

//
// MessageId: NS_E_NO_PROFILE_IN_SOURCEGROUP
//
// MessageText:
//
//  No profile is set in source group.%0
//
#define NS_E_NO_PROFILE_IN_SOURCEGROUP   0xC00D1B67L

//
// MessageId: NS_E_VIDEODRIVER_UNSTABLE
//
// MessageText:
//
//  The video capture driver returned an unrecoverable error.  It is now in an unstable state.%0
//
#define NS_E_VIDEODRIVER_UNSTABLE        0xC00D1B68L

//
// MessageId: NS_E_VIDCAPSTARTFAILED
//
// MessageText:
//
//  The video input device could not be started.%0
//
#define NS_E_VIDCAPSTARTFAILED           0xC00D1B69L

//
// MessageId: NS_E_VIDSOURCECOMPRESSION
//
// MessageText:
//
//  The video input source does not support the requested output format or color depth.%0
//
#define NS_E_VIDSOURCECOMPRESSION        0xC00D1B6AL

//
// MessageId: NS_E_VIDSOURCESIZE
//
// MessageText:
//
//  The video input source does not support the request capture size.%0
//
#define NS_E_VIDSOURCESIZE               0xC00D1B6BL

//
// MessageId: NS_E_ICMQUERYFORMAT
//
// MessageText:
//
//  Unable to obtain output information from video compressor.%0
//
#define NS_E_ICMQUERYFORMAT              0xC00D1B6CL

//
// MessageId: NS_E_VIDCAPCREATEWINDOW
//
// MessageText:
//
//  Unable to create video capture window.%0
//
#define NS_E_VIDCAPCREATEWINDOW          0xC00D1B6DL

//
// MessageId: NS_E_VIDCAPDRVINUSE
//
// MessageText:
//
//  There already is a running stream active on this video input device.%0
//
#define NS_E_VIDCAPDRVINUSE              0xC00D1B6EL

//
// MessageId: NS_E_NO_MEDIAFORMAT_IN_SOURCE
//
// MessageText:
//
//  No media format is set in source.%0
//
#define NS_E_NO_MEDIAFORMAT_IN_SOURCE    0xC00D1B6FL

//
// MessageId: NS_E_NO_VALID_OUTPUT_STREAM
//
// MessageText:
//
//  Cannot find valid output stream from source.%0
//
#define NS_E_NO_VALID_OUTPUT_STREAM      0xC00D1B70L

//
// MessageId: NS_E_NO_VALID_SOURCE_PLUGIN
//
// MessageText:
//
//  Cannot find valid source plugin to support specified source.%0
//
#define NS_E_NO_VALID_SOURCE_PLUGIN      0xC00D1B71L

//
// MessageId: NS_E_NO_ACTIVE_SOURCEGROUP
//
// MessageText:
//
//  No source group is currently active.%0
//
#define NS_E_NO_ACTIVE_SOURCEGROUP       0xC00D1B72L

//
// MessageId: NS_E_NO_SCRIPT_STREAM
//
// MessageText:
//
//  No script stream is set in current active source group.%0
//
#define NS_E_NO_SCRIPT_STREAM            0xC00D1B73L

//
// MessageId: NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING
//
// MessageText:
//
//  This operation is not allowed when file archival is started.%0
//
#define NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING 0xC00D1B74L

//
// MessageId: NS_E_INVALIDPACKETSIZE
//
// MessageText:
//
//  The MaxPacketSize value specified is invalid.%0
//
#define NS_E_INVALIDPACKETSIZE           0xC00D1B75L

//
// MessageId: NS_E_PLUGIN_CLSID_NOTINVALID
//
// MessageText:
//
//  The plugin CLSID specified is invalid.%0
//
#define NS_E_PLUGIN_CLSID_NOTINVALID     0xC00D1B76L

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVETYPE
//
// MessageText:
//
//  This Archive type is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVETYPE     0xC00D1B77L

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVEOPERATION
//
// MessageText:
//
//  This Archive operation is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVEOPERATION 0xC00D1B78L

//
// MessageId: NS_E_ARCHIVE_FILENAME_NOTSET
//
// MessageText:
//
//  The local archive filename was not set.%0
//
#define NS_E_ARCHIVE_FILENAME_NOTSET     0xC00D1B79L

//
// MessageId: NS_E_SOURCEGROUP_NOTPREPARED
//
// MessageText:
//
//  The SourceGroup is not yet prepared.%0
//
#define NS_E_SOURCEGROUP_NOTPREPARED     0xC00D1B7AL

//
// MessageId: NS_E_PROFILE_MISMATCH
//
// MessageText:
//
//  Profiles on the sourcegroups do not match.%0
//
#define NS_E_PROFILE_MISMATCH            0xC00D1B7BL

//
// MessageId: NS_E_INCORRECTCLIPSETTINGS
//
// MessageText:
//
//  The clip settings specified on the source are incorrect.%0
//
#define NS_E_INCORRECTCLIPSETTINGS       0xC00D1B7CL

//
// MessageId: NS_E_NOSTATSAVAILABLE
//
// MessageText:
//
//  No statistics are available at this time.%0
//
#define NS_E_NOSTATSAVAILABLE            0xC00D1B7DL

//
// MessageId: NS_E_NOTARCHIVING
//
// MessageText:
//
//  Encoder is not archiving.%0
//
#define NS_E_NOTARCHIVING                0xC00D1B7EL

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED
//
// MessageText:
//
//  This operation is not allowed while encoder is not running.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED 0xC00D1B7FL

//
// MessageId: NS_E_NOSOURCEGROUPS
//
// MessageText:
//
//  This SourceGroupCollection doesnt contain any SourceGroups.%0
//
#define NS_E_NOSOURCEGROUPS              0xC00D1B80L

//
// MessageId: NS_E_INVALIDINPUTFPS
//
// MessageText:
//
//  Because this source group does not have a frame rate of 30 frames per second, you cannot use the inverse telecine feature.%0
//
#define NS_E_INVALIDINPUTFPS             0xC00D1B81L

//
// MessageId: NS_E_NO_DATAVIEW_SUPPORT
//
// MessageText:
//
//  Internal problems are preventing the preview or postview of your content.%0
//
#define NS_E_NO_DATAVIEW_SUPPORT         0xC00D1B82L

//
// MessageId: NS_E_CODEC_UNAVAILABLE
//
// MessageText:
//
//  One or more codecs required to open this media could not be found.%0
//
#define NS_E_CODEC_UNAVAILABLE           0xC00D1B83L

//
// MessageId: NS_E_ARCHIVE_SAME_AS_INPUT
//
// MessageText:
//
//  The output archive file specified is the same as an input source in one of the source groups.%0
//
#define NS_E_ARCHIVE_SAME_AS_INPUT       0xC00D1B84L

//
// MessageId: NS_E_SOURCE_NOTSPECIFIED
//
// MessageText:
//
//  The input source has not been setup completely.%0
//
#define NS_E_SOURCE_NOTSPECIFIED         0xC00D1B85L

//
// MessageId: NS_E_NO_REALTIME_TIMECOMPRESSION
//
// MessageText:
//
//  Cannot apply time compression transform plug-in to a real time broadcast session.%0
//
#define NS_E_NO_REALTIME_TIMECOMPRESSION 0xC00D1B86L

//
// MessageId: NS_E_UNSUPPORTED_ENCODER_DEVICE
//
// MessageText:
//
//  The Encoder was unable to open this device. Please see the system requirements for more information.%0
//
#define NS_E_UNSUPPORTED_ENCODER_DEVICE  0xC00D1B87L

//
// MessageId: NS_E_UNEXPECTED_DISPLAY_SETTINGS
//
// MessageText:
//
//  Encoding cannot start because the display size or color setting has changed since the current session was defined. Restore the previous settings or create a new session.%0
//
#define NS_E_UNEXPECTED_DISPLAY_SETTINGS 0xC00D1B88L

//
// MessageId: NS_E_NO_AUDIODATA
//
// MessageText:
//
//  No audio data has been received for multiple seconds.  Check the audio source and restart the encoder.%0
//
#define NS_E_NO_AUDIODATA                0xC00D1B89L

//
// MessageId: NS_E_INPUTSOURCE_PROBLEM
//
// MessageText:
//
//  One or all of your specified input sources are not working properly. Make sure your input sources are configured correctly.%0
//
#define NS_E_INPUTSOURCE_PROBLEM         0xC00D1B8AL

//
// MessageId: NS_E_WME_VERSION_MISMATCH
//
// MessageText:
//
//  The supplied configuration file is not supported by this version of the encoder.%0
//
#define NS_E_WME_VERSION_MISMATCH        0xC00D1B8BL

//
// MessageId: NS_E_NO_REALTIME_PREPROCESS
//
// MessageText:
//
//  Image pre-process can not be used with realtime encoding.%0
//
#define NS_E_NO_REALTIME_PREPROCESS      0xC00D1B8CL

//
// MessageId: NS_E_NO_REPEAT_PREPROCESS
//
// MessageText:
//
//  Image pre-process can not be used when source is set to loop.%0
//
#define NS_E_NO_REPEAT_PREPROCESS        0xC00D1B8DL

//
// MessageId: NS_E_CANNOT_PAUSE_LIVEBROADCAST
//
// MessageText:
//
//  Pause encoder is forbidden because the encoding session is live broadcast.%0
//
#define NS_E_CANNOT_PAUSE_LIVEBROADCAST  0xC00D1B8EL

//
// MessageId: NS_E_DRM_PROFILE_NOT_SET
//
// MessageText:
//
//  DRM Profile is not set on the current encoding session.%0
//
#define NS_E_DRM_PROFILE_NOT_SET         0xC00D1B8FL

//
// MessageId: NS_E_DUPLICATE_DRMPROFILE
//
// MessageText:
//
//  The profile ID is already used by a DRM Profile in the system.  Please use a different profile ID.%0
//
#define NS_E_DUPLICATE_DRMPROFILE        0xC00D1B90L

//
// MessageId: NS_E_INVALID_DEVICE
//
// MessageText:
//
//  Setting of the selected device doesn't support control for playing back tapes.%0
//
#define NS_E_INVALID_DEVICE              0xC00D1B91L

//
// MessageId: NS_E_SPEECHEDL_ON_NON_MIXEDMODE
//
// MessageText:
//
//  Cannot set speech EDL when speech encoding mode is not set to mixed mode.%0
//
#define NS_E_SPEECHEDL_ON_NON_MIXEDMODE  0xC00D1B92L


/////////////////////////////////////////////////////////////////////////
//
// DRM Specific Errors
//
// IdRange = 10000..10999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_DRM_INVALID_APPLICATION
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_INVALID_APPLICATION     0xC00D2711L

//
// MessageId: NS_E_DRM_LICENSE_STORE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_STORE_ERROR     0xC00D2712L

//
// MessageId: NS_E_DRM_SECURE_STORE_ERROR
//
// MessageText:
//
//  Secure storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_ERROR      0xC00D2713L

//
// MessageId: NS_E_DRM_LICENSE_STORE_SAVE_ERROR
//
// MessageText:
//
//  License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_STORE_SAVE_ERROR 0xC00D2714L

//
// MessageId: NS_E_DRM_SECURE_STORE_UNLOCK_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_UNLOCK_ERROR 0xC00D2715L

//
// MessageId: NS_E_DRM_INVALID_CONTENT
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_CONTENT         0xC00D2716L

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_LICENSE
//
// MessageText:
//
//  The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_LICENSE  0xC00D2717L

//
// MessageId: NS_E_DRM_INVALID_LICENSE
//
// MessageText:
//
//  The license is corrupted or invalid. Acquire a new license%0
//
#define NS_E_DRM_INVALID_LICENSE         0xC00D2718L

//
// MessageId: NS_E_DRM_INVALID_MACHINE
//
// MessageText:
//
//  Licenses cannot be copied from one computer to another. Use License Management to transfer licenses, or get a new license for the media file.%0
//
#define NS_E_DRM_INVALID_MACHINE         0xC00D2719L

//
// MessageId: NS_E_DRM_ENUM_LICENSE_FAILED
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENUM_LICENSE_FAILED     0xC00D271BL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_REQUEST
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_LICENSE_REQUEST 0xC00D271CL

//
// MessageId: NS_E_DRM_UNABLE_TO_INITIALIZE
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_INITIALIZE    0xC00D271DL

//
// MessageId: NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
//  The license could not be acquired. Try again later.%0
//
#define NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE 0xC00D271EL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_ACQUIRED
//
// MessageText:
//
//  License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_INVALID_LICENSE_ACQUIRED 0xC00D271FL

//
// MessageId: NS_E_DRM_NO_RIGHTS
//
// MessageText:
//
//  The requested operation cannot be performed on this file.%0
//
#define NS_E_DRM_NO_RIGHTS               0xC00D2720L

//
// MessageId: NS_E_DRM_KEY_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_KEY_ERROR               0xC00D2721L

//
// MessageId: NS_E_DRM_ENCRYPT_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENCRYPT_ERROR           0xC00D2722L

//
// MessageId: NS_E_DRM_DECRYPT_ERROR
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_DECRYPT_ERROR           0xC00D2723L

//
// MessageId: NS_E_DRM_LICENSE_INVALID_XML
//
// MessageText:
//
//  The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_LICENSE_INVALID_XML     0xC00D2725L

//
// MessageId: NS_S_DRM_LICENSE_ACQUIRED
//
// MessageText:
//
//  Status message: The license was acquired.%0
//
#define NS_S_DRM_LICENSE_ACQUIRED        0x000D2726L

//
// MessageId: NS_S_DRM_INDIVIDUALIZED
//
// MessageText:
//
//  Status message: The security upgrade has been completed.%0
//
#define NS_S_DRM_INDIVIDUALIZED          0x000D2727L

//
// MessageId: NS_E_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
//  A security upgrade is required to perform the operation on this media file.%0
//
#define NS_E_DRM_NEEDS_INDIVIDUALIZATION 0xC00D2728L

//
// MessageId: NS_E_DRM_ACTION_NOT_QUERIED
//
// MessageText:
//
//  The application cannot perform this action. Contact product support for this application.%0
//
#define NS_E_DRM_ACTION_NOT_QUERIED      0xC00D272AL

//
// MessageId: NS_E_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
//  You cannot begin a new license acquisition process until the current one has been completed.%0
//
#define NS_E_DRM_ACQUIRING_LICENSE       0xC00D272BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZING
//
// MessageText:
//
//  You cannot begin a new security upgrade until the current one has been completed.%0
//
#define NS_E_DRM_INDIVIDUALIZING         0xC00D272CL

//
// MessageId: NS_E_DRM_PARAMETERS_MISMATCHED
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_PARAMETERS_MISMATCHED   0xC00D272FL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT
//
// MessageText:
//
//  A license cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT 0xC00D2730L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT 0xC00D2731L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT 0xC00D2732L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT 0xC00D2733L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT 0xC00D2734L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT 0xC00D2735L

//
// MessageId: NS_E_DRM_INDIVIDUALIZE_ERROR
//
// MessageText:
//
//  The security upgrade failed. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZE_ERROR     0xC00D2736L

//
// MessageId: NS_E_DRM_LICENSE_OPEN_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_OPEN_ERROR      0xC00D2737L

//
// MessageId: NS_E_DRM_LICENSE_CLOSE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_CLOSE_ERROR     0xC00D2738L

//
// MessageId: NS_E_DRM_GET_LICENSE_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSE_ERROR       0xC00D2739L

//
// MessageId: NS_E_DRM_QUERY_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_QUERY_ERROR             0xC00D273AL

//
// MessageId: NS_E_DRM_REPORT_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_REPORT_ERROR            0xC00D273BL

//
// MessageId: NS_E_DRM_GET_LICENSESTRING_ERROR
//
// MessageText:
//
//  License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSESTRING_ERROR 0xC00D273CL

//
// MessageId: NS_E_DRM_GET_CONTENTSTRING_ERROR
//
// MessageText:
//
//  The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_GET_CONTENTSTRING_ERROR 0xC00D273DL

//
// MessageId: NS_E_DRM_MONITOR_ERROR
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Try again later.%0
//
#define NS_E_DRM_MONITOR_ERROR           0xC00D273EL

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_PARAMETER
//
// MessageText:
//
//  The application has made an invalid call to the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_UNABLE_TO_SET_PARAMETER 0xC00D273FL

//
// MessageId: NS_E_DRM_INVALID_APPDATA
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPDATA         0xC00D2740L

//
// MessageId: NS_E_DRM_INVALID_APPDATA_VERSION
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_APPDATA_VERSION 0xC00D2741L

//
// MessageId: NS_E_DRM_BACKUP_EXISTS
//
// MessageText:
//
//  Licenses are already backed up in this location.%0
//
#define NS_E_DRM_BACKUP_EXISTS           0xC00D2742L

//
// MessageId: NS_E_DRM_BACKUP_CORRUPT
//
// MessageText:
//
//  One or more backed-up licenses are missing or corrupt.%0
//
#define NS_E_DRM_BACKUP_CORRUPT          0xC00D2743L

//
// MessageId: NS_E_DRM_BACKUPRESTORE_BUSY
//
// MessageText:
//
//  You cannot begin a new backup process until the current process has been completed.%0
//
#define NS_E_DRM_BACKUPRESTORE_BUSY      0xC00D2744L

//
// MessageId: NS_S_DRM_MONITOR_CANCELLED
//
// MessageText:
//
//  Status message: License monitoring has been cancelled.%0
//
#define NS_S_DRM_MONITOR_CANCELLED       0x000D2746L

//
// MessageId: NS_S_DRM_ACQUIRE_CANCELLED
//
// MessageText:
//
//  Status message: License acquisition has been cancelled.%0
//
#define NS_S_DRM_ACQUIRE_CANCELLED       0x000D2747L

//
// MessageId: NS_E_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
//  The license is invalid. Contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_UNUSABLE        0xC00D2748L

//
// MessageId: NS_E_DRM_INVALID_PROPERTY
//
// MessageText:
//
//  A required property was not set by the application. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_PROPERTY        0xC00D2749L

//
// MessageId: NS_E_DRM_SECURE_STORE_NOT_FOUND
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component of this application. Try to acquire a license again.%0
//
#define NS_E_DRM_SECURE_STORE_NOT_FOUND  0xC00D274AL

//
// MessageId: NS_E_DRM_CACHED_CONTENT_ERROR
//
// MessageText:
//
//  A license cannot be found for this media file. Use License Management to transfer a license for this file from the original computer, or acquire a new license.%0
//
#define NS_E_DRM_CACHED_CONTENT_ERROR    0xC00D274BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE
//
// MessageText:
//
//  A problem occurred during the security upgrade. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE 0xC00D274CL

//
// MessageId: NS_E_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
//  Certified driver components are required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_AUTH_FAILURE     0xC00D274DL

//
// MessageId: NS_E_DRM_NEED_UPGRADE
//
// MessageText:
//
//  A new version of the Digital Rights Management component is required. Contact product support for this application to get the latest version.%0
//
#define NS_E_DRM_NEED_UPGRADE            0xC00D274EL

//
// MessageId: NS_E_DRM_REOPEN_CONTENT
//
// MessageText:
//
//  Status message: Reopen the file.%0
//
#define NS_E_DRM_REOPEN_CONTENT          0xC00D274FL

//
// MessageId: NS_E_DRM_DRIVER_DIGIOUT_FAILURE
//
// MessageText:
//
//  Certain driver functionality is required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_DIGIOUT_FAILURE  0xC00D2750L

//
// MessageId: NS_E_DRM_INVALID_SECURESTORE_PASSWORD
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_SECURESTORE_PASSWORD 0xC00D2751L

//
// MessageId: NS_E_DRM_APPCERT_REVOKED
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_APPCERT_REVOKED         0xC00D2752L

//
// MessageId: NS_E_DRM_RESTORE_FRAUD
//
// MessageText:
//
//  You cannot restore your license(s).%0
//
#define NS_E_DRM_RESTORE_FRAUD           0xC00D2753L

//
// MessageId: NS_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
//  The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define NS_E_DRM_HARDWARE_INCONSISTENT   0xC00D2754L

//
// MessageId: NS_E_DRM_SDMI_TRIGGER
//
// MessageText:
//
//  To transfer this media file, you must upgrade the application.%0
//
#define NS_E_DRM_SDMI_TRIGGER            0xC00D2755L

//
// MessageId: NS_E_DRM_SDMI_NOMORECOPIES
//
// MessageText:
//
//  You cannot make any more copies of this media file.%0
//
#define NS_E_DRM_SDMI_NOMORECOPIES       0xC00D2756L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT 0xC00D2757L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT 0xC00D2758L

;// This error is never shown to user but needed for program logic.
//
// MessageId: NS_E_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
//  Unable to obtain license.%0
//
#define NS_E_DRM_LICENSE_NOTACQUIRED     0xC00D2759L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT 0xC00D275AL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT
//
// MessageText:
//
//  A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT 0xC00D275BL

//
// MessageId: NS_E_DRM_BUFFER_TOO_SMALL
//
// MessageText:
//
//  The buffer supplied is not sufficient.%0.
//
#define NS_E_DRM_BUFFER_TOO_SMALL        0xC00D275CL

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROPERTY
//
// MessageText:
//
//  The property requested is not supported.%0.
//
#define NS_E_DRM_UNSUPPORTED_PROPERTY    0xC00D275DL

//
// MessageId: NS_E_DRM_ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested operation.%0.
//
#define NS_E_DRM_ERROR_BAD_NET_RESP      0xC00D275EL

//
// MessageId: NS_E_DRM_STORE_NOTALLSTORED
//
// MessageText:
//
//  Some of the licenses could not be stored.%0.
//
#define NS_E_DRM_STORE_NOTALLSTORED      0xC00D275FL

//
// MessageId: NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID
//
// MessageText:
//
//  The Digital Rights Management security upgrade component could not be validated. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID 0xC00D2760L

//
// MessageId: NS_E_DRM_INVALID_DATA
//
// MessageText:
//
//  Invalid or corrupt data was encountered.%0
//
#define NS_E_DRM_INVALID_DATA            0xC00D2761L

//
// MessageId: NS_E_DRM_UNABLE_TO_CONTACT_SERVER
//
// MessageText:
//
//  Unable to contact the server for the requested operation.%0
//
#define NS_E_DRM_UNABLE_TO_CONTACT_SERVER 0xC00D2762L

//
// MessageId: NS_E_DRM_NOT_CONFIGURED
//
// MessageText:
//
//  Not all of the necessary properties for DRM have been set.%0
//
#define NS_E_DRM_NOT_CONFIGURED          0xC00D2763L

;// License Reasons Section
;// Error Codes why a license is not usable. Reserve 10200..10300 for this purpose.
;// 10200..10249 is for license reported reasons. 10250..10300 is for client detected reasons.
//
// MessageId: NS_E_DRM_LICENSE_EXPIRED
//
// MessageText:
//
//  The license for this file has expired and is no longer valid. Contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_EXPIRED         0xC00D27D8L

//
// MessageId: NS_E_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
//  The license for this file is not valid yet, but will be at a future date.%0
//
#define NS_E_DRM_LICENSE_NOTENABLED      0xC00D27D9L

//
// MessageId: NS_E_DRM_LICENSE_APPSECLOW
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_APPSECLOW       0xC00D27DAL

//
// MessageId: NS_E_DRM_STORE_NEEDINDI
//
// MessageText:
//
//  The license cannot be stored as it requires security upgrade of Digital Rights Management component.%0.
//
#define NS_E_DRM_STORE_NEEDINDI          0xC00D27DBL

//
// MessageId: NS_E_DRM_STORE_NOTALLOWED
//
// MessageText:
//
//  Your machine does not meet the requirements for storing the license.%0.
//
#define NS_E_DRM_STORE_NOTALLOWED        0xC00D27DCL

//
// MessageId: NS_E_DRM_LICENSE_APP_NOTALLOWED
//
// MessageText:
//
//  The license for this file requires an upgraded version of your player or a different player.%0.
//
#define NS_E_DRM_LICENSE_APP_NOTALLOWED  0xC00D27DDL

//
// MessageId: NS_S_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
//  A security upgrade is required to perform the operation on this media file.%0
//
#define NS_S_DRM_NEEDS_INDIVIDUALIZATION 0x000D27DEL

//
// MessageId: NS_E_DRM_LICENSE_CERT_EXPIRED
//
// MessageText:
//
//  The license server's certificate expired. Make sure your system clock is set correctly. Contact your content provider for further assistance. %0.
//
#define NS_E_DRM_LICENSE_CERT_EXPIRED    0xC00D27DFL

//
// MessageId: NS_E_DRM_LICENSE_SECLOW
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_SECLOW          0xC00D27E0L

//
// MessageId: NS_E_DRM_LICENSE_CONTENT_REVOKED
//
// MessageText:
//
//  The content owner for the license you just acquired is no longer supporting their content. Contact the content owner for a newer version of the content.%0
//
#define NS_E_DRM_LICENSE_CONTENT_REVOKED 0xC00D27E1L

//
// MessageId: NS_E_DRM_LICENSE_NOSAP
//
// MessageText:
//
//  The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSAP           0xC00D280AL

//
// MessageId: NS_E_DRM_LICENSE_NOSVP
//
// MessageText:
//
//  The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSVP           0xC00D280BL

//
// MessageId: NS_E_DRM_LICENSE_NOWDM
//
// MessageText:
//
//  The license for this file requires Windows Driver Model (WDM) audio drivers. Contact your sound card manufacturer for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOWDM           0xC00D280CL

//
// MessageId: NS_E_DRM_LICENSE_NOTRUSTEDCODEC
//
// MessageText:
//
//  The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_NOTRUSTEDCODEC  0xC00D280DL

;// End of License Reasons Section


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Setup Specific Errors
//
// IdRange = 11000..11999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_S_REBOOT_RECOMMENDED
//
// MessageText:
//
//  The requested operation is successful.  Some cleanup will not be complete until the system is rebooted.%0
//
#define NS_S_REBOOT_RECOMMENDED          0x000D2AF8L

//
// MessageId: NS_S_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation is successful.  The system will not function correctly until the system is rebooted.%0
//
#define NS_S_REBOOT_REQUIRED             0x000D2AF9L

//
// MessageId: NS_E_REBOOT_RECOMMENDED
//
// MessageText:
//
//  The requested operation failed.  Some cleanup will not be complete until the system is rebooted.%0
//
#define NS_E_REBOOT_RECOMMENDED          0xC00D2AFAL

//
// MessageId: NS_E_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation failed.  The system will not function correctly until the system is rebooted.%0
//
#define NS_E_REBOOT_REQUIRED             0xC00D2AFBL


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Networking Errors
//
// IdRange = 12000..12999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_UNKNOWN_PROTOCOL
//
// MessageText:
//
//  The specified protocol is not supported.%0
//
#define NS_E_UNKNOWN_PROTOCOL            0xC00D2EE0L

//
// MessageId: NS_E_REDIRECT_TO_PROXY
//
// MessageText:
//
//  The client is redirected to a proxy server.%0
//
#define NS_E_REDIRECT_TO_PROXY           0xC00D2EE1L

//
// MessageId: NS_E_INTERNAL_SERVER_ERROR
//
// MessageText:
//
//  The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define NS_E_INTERNAL_SERVER_ERROR       0xC00D2EE2L

//
// MessageId: NS_E_BAD_REQUEST
//
// MessageText:
//
//  The request could not be understood by the server.%0
//
#define NS_E_BAD_REQUEST                 0xC00D2EE3L

//
// MessageId: NS_E_ERROR_FROM_PROXY
//
// MessageText:
//
//  The proxy experienced an error while attempting to contact the media server.%0
//
#define NS_E_ERROR_FROM_PROXY            0xC00D2EE4L

//
// MessageId: NS_E_PROXY_TIMEOUT
//
// MessageText:
//
//  The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define NS_E_PROXY_TIMEOUT               0xC00D2EE5L

//
// MessageId: NS_E_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define NS_E_SERVER_UNAVAILABLE          0xC00D2EE6L

//
// MessageId: NS_E_REFUSED_BY_SERVER
//
// MessageText:
//
//  The server is refusing to fulfill the requested operation.%0
//
#define NS_E_REFUSED_BY_SERVER           0xC00D2EE7L

//
// MessageId: NS_E_INCOMPATIBLE_SERVER
//
// MessageText:
//
//  The server is not a compatible streaming media server.%0
//
#define NS_E_INCOMPATIBLE_SERVER         0xC00D2EE8L

//
// MessageId: NS_E_MULTICAST_DISABLED
//
// MessageText:
//
//  The content cannot be streamed because the Multicast protocol has been disabled.%0
//
#define NS_E_MULTICAST_DISABLED          0xC00D2EE9L

//
// MessageId: NS_E_INVALID_REDIRECT
//
// MessageText:
//
//  The server redirected the player to an invalid location.%0
//
#define NS_E_INVALID_REDIRECT            0xC00D2EEAL

//
// MessageId: NS_E_ALL_PROTOCOLS_DISABLED
//
// MessageText:
//
//  The content cannot be streamed because all protocols have been disabled.%0
//
#define NS_E_ALL_PROTOCOLS_DISABLED      0xC00D2EEBL

//
// MessageId: NS_E_MSBD_NO_LONGER_SUPPORTED
//
// MessageText:
//
//  The MSBD protocol is no longer supported. Please use HTTP to connect to the Windows Media stream.%0
//
#define NS_E_MSBD_NO_LONGER_SUPPORTED    0xC00D2EECL

//
// MessageId: NS_E_PROXY_NOT_FOUND
//
// MessageText:
//
//  The proxy server could not be located. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_NOT_FOUND             0xC00D2EEDL

//
// MessageId: NS_E_CANNOT_CONNECT_TO_PROXY
//
// MessageText:
//
//  Unable to establish a connection to the proxy server. Please check your proxy server configuration.%0
//
#define NS_E_CANNOT_CONNECT_TO_PROXY     0xC00D2EEEL

//
// MessageId: NS_E_SERVER_DNS_TIMEOUT
//
// MessageText:
//
//  Unable to locate the media server. The operation timed out.%0
//
#define NS_E_SERVER_DNS_TIMEOUT          0xC00D2EEFL

//
// MessageId: NS_E_PROXY_DNS_TIMEOUT
//
// MessageText:
//
//  Unable to locate the proxy server. The operation timed out.%0
//
#define NS_E_PROXY_DNS_TIMEOUT           0xC00D2EF0L

//
// MessageId: NS_E_CLOSED_ON_SUSPEND
//
// MessageText:
//
//  Media closed because Windows was shut down.%0
//
#define NS_E_CLOSED_ON_SUSPEND           0xC00D2EF1L

//
// MessageId: NS_E_CANNOT_READ_PLAYLIST_FROM_MEDIASERVER
//
// MessageText:
//
//  Unable to read the contents of a playlist file from a media server.%0
//
#define NS_E_CANNOT_READ_PLAYLIST_FROM_MEDIASERVER 0xC00D2EF2L

//
// MessageId: NS_E_SESSION_NOT_FOUND
//
// MessageText:
//
//  Session not found.%0
//
#define NS_E_SESSION_NOT_FOUND           0xC00D2EF3L

//
// MessageId: NS_E_REQUIRE_STREAMING_CLIENT
//
// MessageText:
//
//  Content requires a streaming media client.%0
//
#define NS_E_REQUIRE_STREAMING_CLIENT    0xC00D2EF4L

//
// MessageId: NS_E_PLAYLIST_ENTRY_HAS_CHANGED
//
// MessageText:
//
//  A command applies to a previous playlist entry.%0
//
#define NS_E_PLAYLIST_ENTRY_HAS_CHANGED  0xC00D2EF5L

//
// MessageId: NS_E_PROXY_ACCESSDENIED
//
// MessageText:
//
//  Proxy access denied.%0
//
#define NS_E_PROXY_ACCESSDENIED          0xC00D2EF6L


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Client Media Services
//
// IdRange = 13000..13999 (0x32C8-0x36AF)
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_END_OF_PLAYLIST
//
// MessageText:
//
//  The playlist has reached its end.%0
//
#define NS_E_END_OF_PLAYLIST             0xC00D32C8L


#endif // _NSERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\wmdm.h ===
EXTERN_C const CLSID CLSID_MediaDevMgr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\wmsysprf.h ===
#pragma once
//============================================================================
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//  File:        wmsysprf.h
//
//  Description: This file contains the GUIDs of the system profiles.
//
//============================================================================

///////////////////////////////////////////////////////////////////////////////

/* fd7f47f1-72a6-45a4-80f0-3aecefc32c07 */
EXTERN_GUID( WMProfile_V40_DialUpMBR, 
             0xfd7f47f1,
             0x72a6,
             0x45a4,
             0x80, 0xf0, 0x3a, 0xec, 0xef, 0xc3, 0x2c, 0x07 );

///////////////////////////////////////////////////////////////////////////////

/* 82cd3321-a94a-4ffc-9c2b-092c10ca16e7 */
EXTERN_GUID( WMProfile_V40_IntranetMBR, 
             0x82cd3321,
             0xa94a,
             0x4ffc,
             0x9c, 0x2b, 0x09, 0x2c, 0x10, 0xca, 0x16, 0xe7 );

///////////////////////////////////////////////////////////////////////////////

/* 5a1c2206-dc5e-4186-beb2-4c5a994b132e */
EXTERN_GUID( WMProfile_V40_2856100MBR, 
             0x5a1c2206,
             0xdc5e,
             0x4186,
             0xbe, 0xb2, 0x4c, 0x5a, 0x99, 0x4b, 0x13, 0x2e );

///////////////////////////////////////////////////////////////////////////////

/* D508978A-11A0-4d15-B0DA-ACDC99D4F890 */
EXTERN_GUID( WMProfile_V40_6VoiceAudio,
             0xD508978A,
             0x11A0,
             0x4d15,
             0xb0, 0xda, 0xac, 0xdc, 0x99, 0xd4, 0xf8, 0x90 );

///////////////////////////////////////////////////////////////////////////////

/* 0f4be81f-d57d-41e1-b2e3-2fad986bfec2 */
EXTERN_GUID( WMProfile_V40_16AMRadio, 
             0x0f4be81f,
             0xd57d,
             0x41e1,
             0xb2, 0xe3, 0x2f, 0xad, 0x98, 0x6b, 0xfe, 0xc2 );

///////////////////////////////////////////////////////////////////////////////

/* 7fa57fc8-6ea4-4645-8abf-b6e5a8f814a1 */
EXTERN_GUID( WMProfile_V40_288FMRadioMono, 
             0x7fa57fc8,
             0x6ea4,
             0x4645,
             0x8a, 0xbf, 0xb6, 0xe5, 0xa8, 0xf8, 0x14, 0xa1 );

///////////////////////////////////////////////////////////////////////////////

/* 22fcf466-aa40-431f-a289-06d0ea1a1e40 */
EXTERN_GUID( WMProfile_V40_288FMRadioStereo, 
             0x22fcf466,
             0xaa40,
             0x431f,
             0xa2, 0x89, 0x06, 0xd0, 0xea, 0x1a, 0x1e, 0x40 );

///////////////////////////////////////////////////////////////////////////////

/* e8026f87-e905-4594-a3c7-00d00041d1d9 */
EXTERN_GUID( WMProfile_V40_56DialUpStereo, 
             0xe8026f87,
             0xe905,
             0x4594,
             0xa3, 0xc7, 0x00, 0xd0, 0x00, 0x41, 0xd1, 0xd9 );

///////////////////////////////////////////////////////////////////////////////

/* 4820b3f7-cbec-41dc-9391-78598714c8e5 */
EXTERN_GUID( WMProfile_V40_64Audio, 
             0x4820b3f7,
             0xcbec,
             0x41dc,
             0x93, 0x91, 0x78, 0x59, 0x87, 0x14, 0xc8, 0xe5 );

///////////////////////////////////////////////////////////////////////////////

/* 0efa0ee3-9e64-41e2-837f-3c0038f327ba */
EXTERN_GUID( WMProfile_V40_96Audio, 
             0x0efa0ee3,
             0x9e64,
             0x41e2,
             0x83, 0x7f, 0x3c, 0x00, 0x38, 0xf3, 0x27, 0xba );

///////////////////////////////////////////////////////////////////////////////

/* 93ddbe12-13dc-4e32-a35e-40378e34279a */
EXTERN_GUID( WMProfile_V40_128Audio, 
             0x93ddbe12,
             0x13dc,
             0x4e32,
             0xa3, 0x5e, 0x40, 0x37, 0x8e, 0x34, 0x27, 0x9a );

///////////////////////////////////////////////////////////////////////////////

/* bb2bc274-0eb6-4da9-b550-ecf7f2b9948f */
EXTERN_GUID( WMProfile_V40_288VideoVoice, 
             0xbb2bc274,
             0x0eb6,
             0x4da9,
             0xb5, 0x50, 0xec, 0xf7, 0xf2, 0xb9, 0x94, 0x8f );

///////////////////////////////////////////////////////////////////////////////

/* ac617f2d-6cbe-4e84-8e9a-ce151a12a354 */
EXTERN_GUID( WMProfile_V40_288VideoAudio, 
             0xac617f2d,
             0x6cbe,
             0x4e84,
             0x8e, 0x9a, 0xce, 0x15, 0x1a, 0x12, 0xa3, 0x54 );

///////////////////////////////////////////////////////////////////////////////

/* abf2f00d-d555-4815-94ce-8275f3a70bfe */
EXTERN_GUID( WMProfile_V40_288VideoWebServer, 
             0xabf2f00d,
             0xd555,
             0x4815,
             0x94, 0xce, 0x82, 0x75, 0xf3, 0xa7, 0x0b, 0xfe );

///////////////////////////////////////////////////////////////////////////////

/* e21713bb-652f-4dab-99de-71e04400270f */
EXTERN_GUID( WMProfile_V40_56DialUpVideo, 
             0xe21713bb,
             0x652f,
             0x4dab,
             0x99, 0xde, 0x71, 0xe0, 0x44, 0x00, 0x27, 0x0f );

///////////////////////////////////////////////////////////////////////////////

/* b756ff10-520f-4749-a399-b780e2fc9250 */
EXTERN_GUID( WMProfile_V40_56DialUpVideoWebServer, 
             0xb756ff10,
             0x520f,
             0x4749,
             0xa3, 0x99, 0xb7, 0x80, 0xe2, 0xfc, 0x92, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* 8f99ddd8-6684-456b-a0a3-33e1316895f0 */
EXTERN_GUID( WMProfile_V40_100Video, 
             0x8f99ddd8,
             0x6684,
             0x456b,
             0xa0, 0xa3, 0x33, 0xe1, 0x31, 0x68, 0x95, 0xf0 );

///////////////////////////////////////////////////////////////////////////////

/* 541841c3-9339-4f7b-9a22-b11540894e42 */
EXTERN_GUID( WMProfile_V40_250Video, 
             0x541841c3,
             0x9339,
             0x4f7b,
             0x9a, 0x22, 0xb1, 0x15, 0x40, 0x89, 0x4e, 0x42 );

///////////////////////////////////////////////////////////////////////////////

/* 70440e6d-c4ef-4f84-8cd0-d5c28686e784 */
EXTERN_GUID( WMProfile_V40_512Video, 
             0x70440e6d,
             0xc4ef,
             0x4f84,
             0x8c, 0xd0, 0xd5, 0xc2, 0x86, 0x86, 0xe7, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* b4482a4c-cc17-4b07-a94e-9818d5e0f13f */
EXTERN_GUID( WMProfile_V40_1MBVideo, 
             0xb4482a4c,
             0xcc17,
             0x4b07,
             0xa9, 0x4e, 0x98, 0x18, 0xd5, 0xe0, 0xf1, 0x3f );

///////////////////////////////////////////////////////////////////////////////

/* 55374ac0-309b-4396-b88f-e6e292113f28 */
EXTERN_GUID( WMProfile_V40_3MBVideo, 
             0x55374ac0,
             0x309b,
             0x4396,
             0xb8, 0x8f, 0xe6, 0xe2, 0x92, 0x11, 0x3f, 0x28 );

///////////////////////////////////////////////////////////////////////////////

/* 5B16E74B-4068-45b5-B80E-7BF8C80D2C2F */
EXTERN_GUID( WMProfile_V70_DialUpMBR, 
             0x5b16e74b,
             0x4068,
             0x45b5,
             0xb8, 0xe, 0x7b, 0xf8, 0xc8, 0xd, 0x2c, 0x2f );

///////////////////////////////////////////////////////////////////////////////

/* 045880DC-34B6-4ca9-A326-73557ED143F3 */
EXTERN_GUID( WMProfile_V70_IntranetMBR, 
             0x45880dc,
             0x34b6,
             0x4ca9,
             0xa3, 0x26, 0x73, 0x55, 0x7e, 0xd1, 0x43, 0xf3 );

///////////////////////////////////////////////////////////////////////////////

/* 07DF7A25-3FE2-4a5b-8B1E-348B0721CA70 */
EXTERN_GUID( WMProfile_V70_2856100MBR, 
             0x7df7a25,
             0x3fe2,
             0x4a5b,
             0x8b, 0x1e, 0x34, 0x8b, 0x7, 0x21, 0xca, 0x70 );

///////////////////////////////////////////////////////////////////////////////

/* B952F38E-7DBC-4533-A9CA-B00B1C6E9800 */
EXTERN_GUID( WMProfile_V70_288VideoVoice, 
             0xb952f38e,
             0x7dbc,
             0x4533,
             0xa9, 0xca, 0xb0, 0xb, 0x1c, 0x6e, 0x98, 0x0 );

///////////////////////////////////////////////////////////////////////////////

/* 58BBA0EE-896A-4948-9953-85B736F83947 */
EXTERN_GUID( WMProfile_V70_288VideoAudio, 
             0x58bba0ee,
             0x896a,
             0x4948,
             0x99, 0x53, 0x85, 0xb7, 0x36, 0xf8, 0x39, 0x47 );

///////////////////////////////////////////////////////////////////////////////

/* 70A32E2B-E2DF-4ebd-9105-D9CA194A2D50 */
EXTERN_GUID( WMProfile_V70_288VideoWebServer, 
             0x70a32e2b,
             0xe2df,
             0x4ebd,
             0x91, 0x5, 0xd9, 0xca, 0x19, 0x4a, 0x2d, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* DEF99E40-57BC-4ab3-B2D1-B6E3CAF64257 */
EXTERN_GUID( WMProfile_V70_56VideoWebServer, 
             0xdef99e40,
             0x57bc,
             0x4ab3,
             0xb2, 0xd1, 0xb6, 0xe3, 0xca, 0xf6, 0x42, 0x57 );

///////////////////////////////////////////////////////////////////////////////

/* C2B7A7E9-7B8E-4992-A1A1-068217A3B311 */
EXTERN_GUID( WMProfile_V70_64VideoISDN,
             0xc2b7a7e9,
             0x7b8e,
             0x4992,
             0xa1, 0xa1, 0x06, 0x82, 0x17, 0xa3, 0xb3, 0x11 );

///////////////////////////////////////////////////////////////////////////////

/* D9F3C932-5EA9-4c6d-89B4-2686E515426E */
EXTERN_GUID( WMProfile_V70_100Video, 
             0xd9f3c932,
             0x5ea9,
             0x4c6d,
             0x89, 0xb4, 0x26, 0x86, 0xe5, 0x15, 0x42, 0x6e );

///////////////////////////////////////////////////////////////////////////////

/* AFE69B3A-403F-4a1b-8007-0E21CFB3DF84 */
EXTERN_GUID( WMProfile_V70_256Video,
             0xafe69b3a,
             0x403f,
             0x4a1b,
             0x80, 0x7, 0xe, 0x21, 0xcf, 0xb3, 0xdf, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* F3D45FBB-8782-44df-97C6-8678E2F9B13D */
EXTERN_GUID( WMProfile_V70_384Video,
             0xf3d45fbb,
             0x8782,
             0x44df,
             0x97, 0xc6, 0x86, 0x78, 0xe2, 0xf9, 0xb1, 0x3d );

///////////////////////////////////////////////////////////////////////////////

/* 0326EBB6-F76E-4964-B0DB-E729978D35EE */
EXTERN_GUID( WMProfile_V70_768Video, 
             0x326ebb6,
             0xf76e,
             0x4964,
             0xb0, 0xdb, 0xe7, 0x29, 0x97, 0x8d, 0x35, 0xee );

///////////////////////////////////////////////////////////////////////////////

/* 0B89164A-5490-4686-9E37-5A80884E5146 */
EXTERN_GUID( WMProfile_V70_1500Video, 
             0xb89164a,
             0x5490,
             0x4686,
             0x9e, 0x37, 0x5a, 0x80, 0x88, 0x4e, 0x51, 0x46 );

///////////////////////////////////////////////////////////////////////////////

/* AA980124-BF10-4e4f-9AFD-4329A7395CFF */
EXTERN_GUID( WMProfile_V70_2000Video,
             0xaa980124,
             0xbf10,
             0x4e4f, 
             0x9a, 0xfd, 0x43, 0x29, 0xa7, 0x39, 0x5c, 0xff );

///////////////////////////////////////////////////////////////////////////////

/* 7A747920-2449-4d76-99CB-FDB0C90484D4 */
EXTERN_GUID( WMProfile_V70_700FilmContentVideo,
             0x7a747920,
             0x2449,
             0x4d76,
             0x99, 0xcb, 0xfd, 0xb0, 0xc9, 0x4, 0x84, 0xd4 );

///////////////////////////////////////////////////////////////////////////////

/* F6A5F6DF-EE3F-434c-A433-523CE55F516B */
EXTERN_GUID( WMProfile_V70_1500FilmContentVideo,
             0xf6a5f6df,
             0xee3f,
             0x434c,
             0xa4, 0x33, 0x52, 0x3c, 0xe5, 0x5f, 0x51, 0x6b );

///////////////////////////////////////////////////////////////////////////////

/* EABA9FBF-B64F-49b3-AA0C-73FBDD150AD0 */
EXTERN_GUID( WMProfile_V70_6VoiceAudio, 
             0xeaba9fbf,
             0xb64f,
             0x49b3,
             0xaa, 0xc, 0x73, 0xfb, 0xdd, 0x15, 0xa, 0xd0 );

///////////////////////////////////////////////////////////////////////////////

/* C012A833-A03B-44a5-96DC-ED95CC65582D */
EXTERN_GUID( WMProfile_V70_288FMRadioMono, 
             0xc012a833,
             0xa03b,
             0x44a5,
             0x96, 0xdc, 0xed, 0x95, 0xcc, 0x65, 0x58, 0x2d );

///////////////////////////////////////////////////////////////////////////////

/* E96D67C9-1A39-4dc4-B900-B1184DC83620 */
EXTERN_GUID( WMProfile_V70_288FMRadioStereo, 
             0xe96d67c9,
             0x1a39,
             0x4dc4,
             0xb9, 0x0, 0xb1, 0x18, 0x4d, 0xc8, 0x36, 0x20 );

///////////////////////////////////////////////////////////////////////////////

/* 674EE767-0949-4fac-875E-F4C9C292013B */
EXTERN_GUID( WMProfile_V70_56DialUpStereo,
             0x674ee767,
             0x949,
             0x4fac,
             0x87, 0x5e, 0xf4, 0xc9, 0xc2, 0x92, 0x1, 0x3b );

///////////////////////////////////////////////////////////////////////////////

/* 91DEA458-9D60-4212-9C59-D40919C939E4 */
EXTERN_GUID( WMProfile_V70_64AudioISDN,
             0x91dea458,
             0x9d60,
             0x4212,
             0x9c, 0x59, 0xd4, 0x09, 0x19, 0xc9, 0x39, 0xe4 );

///////////////////////////////////////////////////////////////////////////////

/* B29CFFC6-F131-41db-B5E8-99D8B0B945F4 */
EXTERN_GUID( WMProfile_V70_64Audio, 
             0xb29cffc6,
             0xf131,
             0x41db,
             0xb5, 0xe8, 0x99, 0xd8, 0xb0, 0xb9, 0x45, 0xf4 );

///////////////////////////////////////////////////////////////////////////////

/* A9D4B819-16CC-4a59-9F37-693DBB0302D6 */
EXTERN_GUID( WMProfile_V70_96Audio, 
             0xa9d4b819,
             0x16cc,
             0x4a59,
             0x9f, 0x37, 0x69, 0x3d, 0xbb, 0x3, 0x2, 0xd6 );

///////////////////////////////////////////////////////////////////////////////

/* C64CF5DA-DF45-40d3-8027-DE698D68DC66 */
EXTERN_GUID( WMProfile_V70_128Audio, 
             0xc64cf5da,
             0xdf45,
             0x40d3,
             0x80, 0x27, 0xde, 0x69, 0x8d, 0x68, 0xdc, 0x66 );

///////////////////////////////////////////////////////////////////////////////

/* F55EA573-4C02-42b5-9026-A8260C438A9F */
EXTERN_GUID( WMProfile_V70_225VideoPDA, 
             0xf55ea573,
             0x4c02,
             0x42b5,
             0x90, 0x26, 0xa8, 0x26, 0xc, 0x43, 0x8a, 0x9f );

///////////////////////////////////////////////////////////////////////////////

/* 0F472967-E3C6-4797-9694-F0304C5E2F17 */
EXTERN_GUID( WMProfile_V70_150VideoPDA, 
             0xf472967,
             0xe3c6,
             0x4797,
             0x96, 0x94, 0xf0, 0x30, 0x4c, 0x5e, 0x2f, 0x17 );


///////////////////////////////////////////////////////////////////////////////
// {8461E183-AECE-49db-8117-072E5A8DD41B} - v9.0 #1
EXTERN_GUID( WMProfile_V90_DialUpMBR, 
0x8461e183, 0xaece, 0x49db, 0x81, 0x17, 0x7, 0x2e, 0x5a, 0x8d, 0xd4, 0x1b);

///////////////////////////////////////////////////////////////////////////////
// {D496979F-C262-477c-A543-203E77706654} - v9.0 #2
EXTERN_GUID( WMProfile_V90_IntranetMBR,
0xd496979f, 0xc262, 0x477c, 0xa5, 0x43, 0x20, 0x3e, 0x77, 0x70, 0x66, 0x54);

///////////////////////////////////////////////////////////////////////////////
// {1EA7E5FB-9710-4e8a-82AA-00EAE0EE016E} - v9.0 #3
EXTERN_GUID( WMProfile_V90_2856100MBR, 
0x1ea7e5fb, 0x9710, 0x4e8a, 0x82, 0xaa, 0x0, 0xea, 0xe0, 0xee, 0x1, 0x6e);

///////////////////////////////////////////////////////////////////////////////
// {5E5ACED0-B459-44de-BC7F-DABD1C9E0F14} - v9.0 #4
EXTERN_GUID( WMProfile_V90_288VideoVoice, 
0x5e5aced0, 0xb459, 0x44de, 0xbc, 0x7f, 0xda, 0xbd, 0x1c, 0x9e, 0xf, 0x14);

///////////////////////////////////////////////////////////////////////////////
// {6789E363-73C6-4e35-8980-05A0A361FC15} - v9.0 #5
EXTERN_GUID( WMProfile_V90_288VideoAudio, 
0x6789e363, 0x73c6, 0x4e35, 0x89, 0x80, 0x5, 0xa0, 0xa3, 0x61, 0xfc, 0x15);

///////////////////////////////////////////////////////////////////////////////
// {005392C1-54D1-4827-9D0C-445EF071760D} - v9.0 #6
EXTERN_GUID( WMProfile_V90_288VideoWebServer, 
0x5392c1, 0x54d1, 0x4827, 0x9d, 0xc, 0x44, 0x5e, 0xf0, 0x71, 0x76, 0xd);

///////////////////////////////////////////////////////////////////////////////
// {B959CDF6-29ED-4c5c-AE26-9049996A3F96} - v9.0 #7
EXTERN_GUID( WMProfile_V90_56VideoWebServer, 
0xb959cdf6, 0x29ed, 0x4c5c, 0xae, 0x26, 0x90, 0x49, 0x99, 0x6a, 0x3f, 0x96);

///////////////////////////////////////////////////////////////////////////////
// {7700DF8B-67F5-49a3-9716-398B24D4FC46} - v9.0 #8
EXTERN_GUID( WMProfile_V90_64VideoISDN, 
0x7700df8b, 0x67f5, 0x49a3, 0x97, 0x16, 0x39, 0x8b, 0x24, 0xd4, 0xfc, 0x46);

///////////////////////////////////////////////////////////////////////////////
// {B50C91F1-3317-4694-B09F-D77B7070746D} - v9.0 #9
EXTERN_GUID( WMProfile_V90_100Video, 
0xb50c91f1, 0x3317, 0x4694, 0xb0, 0x9f, 0xd7, 0x7b, 0x70, 0x70, 0x74, 0x6d);

///////////////////////////////////////////////////////////////////////////////
// {46D80051-D417-4a8c-8AA0-4477DD3C184C} - v9.0 #10
EXTERN_GUID( WMProfile_V90_256Video, 
0x46d80051, 0xd417, 0x4a8c, 0x8a, 0xa0, 0x44, 0x77, 0xdd, 0x3c, 0x18, 0x4c);

///////////////////////////////////////////////////////////////////////////////
// {6767596B-06A9-44ba-8559-3FA2E5D5FBE0} - v9.0 #11
EXTERN_GUID( WMProfile_V90_384Video, 
0x6767596b, 0x6a9, 0x44ba, 0x85, 0x59, 0x3f, 0xa2, 0xe5, 0xd5, 0xfb, 0xe0);

///////////////////////////////////////////////////////////////////////////////
// {15F38604-C14D-42e4-9796-9792A329DF0D} - v9.0 #12
EXTERN_GUID( WMProfile_V90_768Video, 
0x15f38604, 0xc14d, 0x42e4, 0x97, 0x96, 0x97, 0x92, 0xa3, 0x29, 0xdf, 0xd);

///////////////////////////////////////////////////////////////////////////////
// {FF293D7F-9A2E-4acb-A1DE-27F45A16DBB3} - v9.0 #13
EXTERN_GUID( WMProfile_V90_1500Video, 
0xff293d7f, 0x9a2e, 0x4acb, 0xa1, 0xde, 0x27, 0xf4, 0x5a, 0x16, 0xdb, 0xb3);

///////////////////////////////////////////////////////////////////////////////
// {57676CAD-FFF3-4032-8BD0-944CCBA02DDC} - v9.0 #14
EXTERN_GUID( WMProfile_V90_2000Video, 
0x57676cad, 0xfff3, 0x4032, 0x8b, 0xd0, 0x94, 0x4c, 0xcb, 0xa0, 0x2d, 0xdc);

///////////////////////////////////////////////////////////////////////////////
// {9B9C5E4A-2C8E-4c53-B3F2-E547EE03836F} - v9.0 #15
EXTERN_GUID( WMProfile_V90_700FilmContentVideo, 
0x9b9c5e4a, 0x2c8e, 0x4c53, 0xb3, 0xf2, 0xe5, 0x47, 0xee, 0x3, 0x83, 0x6f);

///////////////////////////////////////////////////////////////////////////////
// {F04DB16D-D18E-42cc-8BF0-67B6E6506DB8} - v9.0 #16
EXTERN_GUID( WMProfile_V90_1500FilmContentVideo, 
0xf04db16d, 0xd18e, 0x42cc, 0x8b, 0xf0, 0x67, 0xb6, 0xe6, 0x50, 0x6d, 0xb8);

///////////////////////////////////////////////////////////////////////////////
// {8CD98C72-9FD0-47e5-850C-254B0C705BF3} - v9.0 #17
EXTERN_GUID( WMProfile_V90_6VoiceAudio, 
0x8cd98c72, 0x9fd0, 0x47e5, 0x85, 0xc, 0x25, 0x4b, 0xc, 0x70, 0x5b, 0xf3);

///////////////////////////////////////////////////////////////////////////////
// {6628F165-3464-429e-91C0-029E285FC444} - v9.0 #18
EXTERN_GUID( WMProfile_V90_288FMRadioMono, 
0x6628f165, 0x3464, 0x429e, 0x91, 0xc0, 0x2, 0x9e, 0x28, 0x5f, 0xc4, 0x44);

///////////////////////////////////////////////////////////////////////////////
// {B300611E-A929-4077-B135-F97FA5AB58FC} - v9.0 #19
EXTERN_GUID( WMProfile_V90_288FMRadioStereo, 
0xb300611e, 0xa929, 0x4077, 0xb1, 0x35, 0xf9, 0x7f, 0xa5, 0xab, 0x58, 0xfc);

///////////////////////////////////////////////////////////////////////////////
// {A127B684-F0F4-4d41-AD6B-1D41697A1FAE} - v9.0 #20
EXTERN_GUID( WMProfile_V90_56DialUpStereo, 
0xa127b684, 0xf0f4, 0x4d41, 0xad, 0x6b, 0x1d, 0x41, 0x69, 0x7a, 0x1f, 0xae);

///////////////////////////////////////////////////////////////////////////////
// {084AB492-168B-4ffb-B54F-A3D4C088FC9F} - v9.0 #21
EXTERN_GUID( WMProfile_V90_64AudioISDN, 
0x84ab492, 0x168b, 0x4ffb, 0xb5, 0x4f, 0xa3, 0xd4, 0xc0, 0x88, 0xfc, 0x9f);

///////////////////////////////////////////////////////////////////////////////
// {D8116554-72E8-44a0-8776-4850968810FC} - v9.0 #22
EXTERN_GUID( WMProfile_V90_64Audio, 
0xd8116554, 0x72e8, 0x44a0, 0x87, 0x76, 0x48, 0x50, 0x96, 0x88, 0x10, 0xfc);

///////////////////////////////////////////////////////////////////////////////
// {763C686F-7719-4cb3-8D80-8888DB7A3C5E} - v9.0 #23
EXTERN_GUID( WMProfile_V90_96Audio, 
0x763c686f, 0x7719, 0x4cb3, 0x8d, 0x80, 0x88, 0x88, 0xdb, 0x7a, 0x3c, 0x5e);

///////////////////////////////////////////////////////////////////////////////
// {32AA4FCB-6510-4bcb-8FC7-73B25C627D9C} - v9.0 #24
EXTERN_GUID( WMProfile_V90_128Audio, 
0x32aa4fcb, 0x6510, 0x4bcb, 0x8f, 0xc7, 0x73, 0xb2, 0x5c, 0x62, 0x7d, 0x9c);

///////////////////////////////////////////////////////////////////////////////
// {D0751B2A-9E16-4ec3-A450-19B8F54F0D6F} - v9.0 #25
EXTERN_GUID( WMProfile_V90_225VideoPDA, 
0xd0751b2a, 0x9e16, 0x4ec3, 0xa4, 0x50, 0x19, 0xb8, 0xf5, 0x4f, 0xd, 0x6f);

///////////////////////////////////////////////////////////////////////////////
// {3F8622C7-8A00-4e63-9A5A-3BEC7155B9BD} - v9.0 #26
EXTERN_GUID( WMProfile_V90_150VideoPDA, 
0x3f8622c7, 0x8a00, 0x4e63, 0x9a, 0x5a, 0x3b, 0xec, 0x71, 0x55, 0xb9, 0xbd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\wmdmlog.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun Mar 18 02:44:29 2001
 */
/* Compiler settings for .\wmdmlog.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmdmlog_h__
#define __wmdmlog_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMDMLogger_FWD_DEFINED__
#define __IWMDMLogger_FWD_DEFINED__
typedef interface IWMDMLogger IWMDMLogger;
#endif 	/* __IWMDMLogger_FWD_DEFINED__ */


#ifndef __WMDMLogger_FWD_DEFINED__
#define __WMDMLogger_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMLogger WMDMLogger;
#else
typedef struct WMDMLogger WMDMLogger;
#endif /* __cplusplus */

#endif 	/* __WMDMLogger_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmdmlog_0000 */
/* [local] */ 

#define WMDM_LOG_SEV_INFO             0x00000001 
#define WMDM_LOG_SEV_WARN             0x00000002 
#define WMDM_LOG_SEV_ERROR            0x00000004 
#define WMDM_LOG_NOTIMESTAMP          0x00000010 


extern RPC_IF_HANDLE __MIDL_itf_wmdmlog_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmdmlog_0000_v0_0_s_ifspec;

#ifndef __IWMDMLogger_INTERFACE_DEFINED__
#define __IWMDMLogger_INTERFACE_DEFINED__

/* interface IWMDMLogger */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMLogger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("110A3200-5A79-11d3-8D78-444553540000")
    IWMDMLogger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( 
            /* [out] */ BOOL __RPC_FAR *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogFileName( 
            /* [size_is][string][out] */ LPSTR pszFilename,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogFileName( 
            /* [string][in] */ LPSTR pszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogString( 
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPSTR pszSrcName,
            /* [string][in] */ LPSTR pszLog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogDword( 
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPSTR pszSrcName,
            /* [string][in] */ LPSTR pszLogFormat,
            /* [in] */ DWORD dwLog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSizeParams( 
            /* [out] */ LPDWORD pdwMaxSize,
            /* [out] */ LPDWORD pdwShrinkToSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSizeParams( 
            /* [in] */ DWORD dwMaxSize,
            /* [in] */ DWORD dwShrinkToSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMLoggerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMLogger __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMLogger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEnabled )( 
            IWMDMLogger __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enable )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogFileName )( 
            IWMDMLogger __RPC_FAR * This,
            /* [size_is][string][out] */ LPSTR pszFilename,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogFileName )( 
            IWMDMLogger __RPC_FAR * This,
            /* [string][in] */ LPSTR pszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogString )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPSTR pszSrcName,
            /* [string][in] */ LPSTR pszLog);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogDword )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPSTR pszSrcName,
            /* [string][in] */ LPSTR pszLogFormat,
            /* [in] */ DWORD dwLog);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IWMDMLogger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeParams )( 
            IWMDMLogger __RPC_FAR * This,
            /* [out] */ LPDWORD pdwMaxSize,
            /* [out] */ LPDWORD pdwShrinkToSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSizeParams )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ DWORD dwMaxSize,
            /* [in] */ DWORD dwShrinkToSize);
        
        END_INTERFACE
    } IWMDMLoggerVtbl;

    interface IWMDMLogger
    {
        CONST_VTBL struct IWMDMLoggerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMLogger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMLogger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMLogger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMLogger_IsEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsEnabled(This,pfEnabled)

#define IWMDMLogger_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#define IWMDMLogger_GetLogFileName(This,pszFilename,nMaxChars)	\
    (This)->lpVtbl -> GetLogFileName(This,pszFilename,nMaxChars)

#define IWMDMLogger_SetLogFileName(This,pszFilename)	\
    (This)->lpVtbl -> SetLogFileName(This,pszFilename)

#define IWMDMLogger_LogString(This,dwFlags,pszSrcName,pszLog)	\
    (This)->lpVtbl -> LogString(This,dwFlags,pszSrcName,pszLog)

#define IWMDMLogger_LogDword(This,dwFlags,pszSrcName,pszLogFormat,dwLog)	\
    (This)->lpVtbl -> LogDword(This,dwFlags,pszSrcName,pszLogFormat,dwLog)

#define IWMDMLogger_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMDMLogger_GetSizeParams(This,pdwMaxSize,pdwShrinkToSize)	\
    (This)->lpVtbl -> GetSizeParams(This,pdwMaxSize,pdwShrinkToSize)

#define IWMDMLogger_SetSizeParams(This,dwMaxSize,dwShrinkToSize)	\
    (This)->lpVtbl -> SetSizeParams(This,dwMaxSize,dwShrinkToSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMLogger_IsEnabled_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnabled);


void __RPC_STUB IWMDMLogger_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_Enable_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IWMDMLogger_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_GetLogFileName_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [size_is][string][out] */ LPSTR pszFilename,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMLogger_GetLogFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_SetLogFileName_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [string][in] */ LPSTR pszFilename);


void __RPC_STUB IWMDMLogger_SetLogFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_LogString_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [string][in] */ LPSTR pszSrcName,
    /* [string][in] */ LPSTR pszLog);


void __RPC_STUB IWMDMLogger_LogString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_LogDword_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [string][in] */ LPSTR pszSrcName,
    /* [string][in] */ LPSTR pszLogFormat,
    /* [in] */ DWORD dwLog);


void __RPC_STUB IWMDMLogger_LogDword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_Reset_Proxy( 
    IWMDMLogger __RPC_FAR * This);


void __RPC_STUB IWMDMLogger_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_GetSizeParams_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [out] */ LPDWORD pdwMaxSize,
    /* [out] */ LPDWORD pdwShrinkToSize);


void __RPC_STUB IWMDMLogger_GetSizeParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_SetSizeParams_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [in] */ DWORD dwMaxSize,
    /* [in] */ DWORD dwShrinkToSize);


void __RPC_STUB IWMDMLogger_SetSizeParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMLogger_INTERFACE_DEFINED__ */



#ifndef __WMDMLogLib_LIBRARY_DEFINED__
#define __WMDMLogLib_LIBRARY_DEFINED__

/* library WMDMLogLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WMDMLogLib;

EXTERN_C const CLSID CLSID_WMDMLogger;

#ifdef __cplusplus

class DECLSPEC_UUID("110A3202-5A79-11d3-8D78-444553540000")
WMDMLogger;
#endif
#endif /* __WMDMLogLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\wmsbuffer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Apr 13 21:06:26 2001
 */
/* Compiler settings for .\wmsbuffer.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsbuffer_h__
#define __wmsbuffer_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INSSBuffer_FWD_DEFINED__
#define __INSSBuffer_FWD_DEFINED__
typedef interface INSSBuffer INSSBuffer;
#endif 	/* __INSSBuffer_FWD_DEFINED__ */


#ifndef __INSSBuffer2_FWD_DEFINED__
#define __INSSBuffer2_FWD_DEFINED__
typedef interface INSSBuffer2 INSSBuffer2;
#endif 	/* __INSSBuffer2_FWD_DEFINED__ */


#ifndef __INSSBuffer3_FWD_DEFINED__
#define __INSSBuffer3_FWD_DEFINED__
typedef interface INSSBuffer3 INSSBuffer3;
#endif 	/* __INSSBuffer3_FWD_DEFINED__ */


#ifndef __IWMSBufferAllocator_FWD_DEFINED__
#define __IWMSBufferAllocator_FWD_DEFINED__
typedef interface IWMSBufferAllocator IWMSBufferAllocator;
#endif 	/* __IWMSBufferAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsbuffer_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//=========================================================================
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_INSSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBufferAllocator, 0x61103CA4,0x2033,0x11d2,0x9E,0xF1,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_INSSBuffer2, 0x4f528693, 0x1035, 0x43fe, 0xb4, 0x28, 0x75, 0x75, 0x61, 0xad, 0x3a, 0x68);
EXTERN_GUID( IID_INSSBuffer3, 0xc87ceaaf, 0x75be, 0x4bc4, 0x84, 0xeb, 0xac, 0x27, 0x98, 0x50, 0x76, 0x72);
EXTERN_GUID( CLSID_WMTPropertyTimestamp, 0x855A7851,0x9199,0x4ade,0xBC,0x34,0x50,0x85,0x6C,0xF3,0x59,0x3D );
EXTERN_GUID( CLSID_WMTPropertyOutputCleanPoint, 0xf72a3c6f, 0x6eb4, 0x4ebc, 0xb1, 0x92, 0x9, 0xad, 0x97, 0x59, 0xe8, 0x28 );
EXTERN_GUID( CLSID_WMTPropertyFileName, 0xe165ec0e, 0x19ed, 0x45d7, 0xb4, 0xa7, 0x25, 0xcb, 0xd1, 0xe2, 0x8e, 0x9b);
#define IWMSBuffer INSSBuffer



extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_s_ifspec;

#ifndef __INSSBuffer_INTERFACE_DEFINED__
#define __INSSBuffer_INTERFACE_DEFINED__

/* interface INSSBuffer */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3524-03D7-11d2-9EED-006097D2D7CF")
    INSSBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        END_INTERFACE
    } INSSBufferVtbl;

    interface INSSBuffer
    {
        CONST_VTBL struct INSSBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer_GetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_SetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB INSSBuffer_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetMaxLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetMaxLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBuffer_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);


void __RPC_STUB INSSBuffer_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBufferAndLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetBufferAndLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer2_INTERFACE_DEFINED__
#define __INSSBuffer2_INTERFACE_DEFINED__

/* interface INSSBuffer2 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F528693-1035-43fe-B428-757561AD3A68")
    INSSBuffer2 : public INSSBuffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties);
        
        END_INTERFACE
    } INSSBuffer2Vtbl;

    interface INSSBuffer2
    {
        CONST_VTBL struct INSSBuffer2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer2_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer2_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer2_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer2_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer2_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)


#define INSSBuffer2_GetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties)

#define INSSBuffer2_SetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer2_GetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [out] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_GetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer2_SetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [in] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_SetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer2_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer3_INTERFACE_DEFINED__
#define __INSSBuffer3_INTERFACE_DEFINED__

/* interface INSSBuffer3 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C87CEAAF-75BE-4bc4-84EB-AC2798507672")
    INSSBuffer3 : public INSSBuffer2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ GUID guidBufferProperty,
            /* [in] */ void __RPC_FAR *pvBufferProperty,
            /* [in] */ DWORD dwBufferPropertySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ GUID guidBufferProperty,
            /* [out] */ void __RPC_FAR *pvBufferProperty,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferPropertySize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSampleProperties )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSampleProperties )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [in] */ GUID guidBufferProperty,
            /* [in] */ void __RPC_FAR *pvBufferProperty,
            /* [in] */ DWORD dwBufferPropertySize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            INSSBuffer3 __RPC_FAR * This,
            /* [in] */ GUID guidBufferProperty,
            /* [out] */ void __RPC_FAR *pvBufferProperty,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferPropertySize);
        
        END_INTERFACE
    } INSSBuffer3Vtbl;

    interface INSSBuffer3
    {
        CONST_VTBL struct INSSBuffer3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer3_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer3_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer3_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer3_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer3_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)


#define INSSBuffer3_GetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties)

#define INSSBuffer3_SetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties)


#define INSSBuffer3_SetProperty(This,guidBufferProperty,pvBufferProperty,dwBufferPropertySize)	\
    (This)->lpVtbl -> SetProperty(This,guidBufferProperty,pvBufferProperty,dwBufferPropertySize)

#define INSSBuffer3_GetProperty(This,guidBufferProperty,pvBufferProperty,pdwBufferPropertySize)	\
    (This)->lpVtbl -> GetProperty(This,guidBufferProperty,pvBufferProperty,pdwBufferPropertySize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer3_SetProperty_Proxy( 
    INSSBuffer3 __RPC_FAR * This,
    /* [in] */ GUID guidBufferProperty,
    /* [in] */ void __RPC_FAR *pvBufferProperty,
    /* [in] */ DWORD dwBufferPropertySize);


void __RPC_STUB INSSBuffer3_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer3_GetProperty_Proxy( 
    INSSBuffer3 __RPC_FAR * This,
    /* [in] */ GUID guidBufferProperty,
    /* [out] */ void __RPC_FAR *pvBufferProperty,
    /* [out][in] */ DWORD __RPC_FAR *pdwBufferPropertySize);


void __RPC_STUB INSSBuffer3_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer3_INTERFACE_DEFINED__ */


#ifndef __IWMSBufferAllocator_INTERFACE_DEFINED__
#define __IWMSBufferAllocator_INTERFACE_DEFINED__

/* interface IWMSBufferAllocator */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_IWMSBufferAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61103CA4-2033-11d2-9EF1-006097D2D7CF")
    IWMSBufferAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocatePageSizeBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBufferAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocatePageSizeBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        END_INTERFACE
    } IWMSBufferAllocatorVtbl;

    interface IWMSBufferAllocator
    {
        CONST_VTBL struct IWMSBufferAllocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBufferAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSBufferAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSBufferAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSBufferAllocator_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer)

#define IWMSBufferAllocator_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocateBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocatePageSizeBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocatePageSizeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSBufferAllocator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\wmsdk.h ===
#pragma once
//============================================================================
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//  File:        wmsdk.h
//
//  Description: WMSDK global include file
//
//============================================================================

#include "wmsdkidl.h"
#include "asferr.h"
#include "nserror.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tsdvr\wmsdk\inc\wmsdkidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue May 15 20:13:30 2001
 */
/* Compiler settings for .\wmsdkidl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsdkidl_h__
#define __wmsdkidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMMediaProps_FWD_DEFINED__
#define __IWMMediaProps_FWD_DEFINED__
typedef interface IWMMediaProps IWMMediaProps;
#endif 	/* __IWMMediaProps_FWD_DEFINED__ */


#ifndef __IWMVideoMediaProps_FWD_DEFINED__
#define __IWMVideoMediaProps_FWD_DEFINED__
typedef interface IWMVideoMediaProps IWMVideoMediaProps;
#endif 	/* __IWMVideoMediaProps_FWD_DEFINED__ */


#ifndef __IWMWriter_FWD_DEFINED__
#define __IWMWriter_FWD_DEFINED__
typedef interface IWMWriter IWMWriter;
#endif 	/* __IWMWriter_FWD_DEFINED__ */


#ifndef __IWMInputMediaProps_FWD_DEFINED__
#define __IWMInputMediaProps_FWD_DEFINED__
typedef interface IWMInputMediaProps IWMInputMediaProps;
#endif 	/* __IWMInputMediaProps_FWD_DEFINED__ */


#ifndef __IWMPropertyVault_FWD_DEFINED__
#define __IWMPropertyVault_FWD_DEFINED__
typedef interface IWMPropertyVault IWMPropertyVault;
#endif 	/* __IWMPropertyVault_FWD_DEFINED__ */


#ifndef __IWMIStreamProps_FWD_DEFINED__
#define __IWMIStreamProps_FWD_DEFINED__
typedef interface IWMIStreamProps IWMIStreamProps;
#endif 	/* __IWMIStreamProps_FWD_DEFINED__ */


#ifndef __IWMReader_FWD_DEFINED__
#define __IWMReader_FWD_DEFINED__
typedef interface IWMReader IWMReader;
#endif 	/* __IWMReader_FWD_DEFINED__ */


#ifndef __IWMSyncReader_FWD_DEFINED__
#define __IWMSyncReader_FWD_DEFINED__
typedef interface IWMSyncReader IWMSyncReader;
#endif 	/* __IWMSyncReader_FWD_DEFINED__ */


#ifndef __IWMOutputMediaProps_FWD_DEFINED__
#define __IWMOutputMediaProps_FWD_DEFINED__
typedef interface IWMOutputMediaProps IWMOutputMediaProps;
#endif 	/* __IWMOutputMediaProps_FWD_DEFINED__ */


#ifndef __IWMStatusCallback_FWD_DEFINED__
#define __IWMStatusCallback_FWD_DEFINED__
typedef interface IWMStatusCallback IWMStatusCallback;
#endif 	/* __IWMStatusCallback_FWD_DEFINED__ */


#ifndef __IWMReaderCallback_FWD_DEFINED__
#define __IWMReaderCallback_FWD_DEFINED__
typedef interface IWMReaderCallback IWMReaderCallback;
#endif 	/* __IWMReaderCallback_FWD_DEFINED__ */


#ifndef __IWMCredentialCallback_FWD_DEFINED__
#define __IWMCredentialCallback_FWD_DEFINED__
typedef interface IWMCredentialCallback IWMCredentialCallback;
#endif 	/* __IWMCredentialCallback_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor_FWD_DEFINED__
#define __IWMMetadataEditor_FWD_DEFINED__
typedef interface IWMMetadataEditor IWMMetadataEditor;
#endif 	/* __IWMMetadataEditor_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor2_FWD_DEFINED__
#define __IWMMetadataEditor2_FWD_DEFINED__
typedef interface IWMMetadataEditor2 IWMMetadataEditor2;
#endif 	/* __IWMMetadataEditor2_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo_FWD_DEFINED__
#define __IWMHeaderInfo_FWD_DEFINED__
typedef interface IWMHeaderInfo IWMHeaderInfo;
#endif 	/* __IWMHeaderInfo_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo2_FWD_DEFINED__
#define __IWMHeaderInfo2_FWD_DEFINED__
typedef interface IWMHeaderInfo2 IWMHeaderInfo2;
#endif 	/* __IWMHeaderInfo2_FWD_DEFINED__ */


#ifndef __IWMProfileManager_FWD_DEFINED__
#define __IWMProfileManager_FWD_DEFINED__
typedef interface IWMProfileManager IWMProfileManager;
#endif 	/* __IWMProfileManager_FWD_DEFINED__ */


#ifndef __IWMProfileManager2_FWD_DEFINED__
#define __IWMProfileManager2_FWD_DEFINED__
typedef interface IWMProfileManager2 IWMProfileManager2;
#endif 	/* __IWMProfileManager2_FWD_DEFINED__ */


#ifndef __IWMProfile_FWD_DEFINED__
#define __IWMProfile_FWD_DEFINED__
typedef interface IWMProfile IWMProfile;
#endif 	/* __IWMProfile_FWD_DEFINED__ */


#ifndef __IWMProfile2_FWD_DEFINED__
#define __IWMProfile2_FWD_DEFINED__
typedef interface IWMProfile2 IWMProfile2;
#endif 	/* __IWMProfile2_FWD_DEFINED__ */


#ifndef __IWMProfile3_FWD_DEFINED__
#define __IWMProfile3_FWD_DEFINED__
typedef interface IWMProfile3 IWMProfile3;
#endif 	/* __IWMProfile3_FWD_DEFINED__ */


#ifndef __IWMStreamConfig_FWD_DEFINED__
#define __IWMStreamConfig_FWD_DEFINED__
typedef interface IWMStreamConfig IWMStreamConfig;
#endif 	/* __IWMStreamConfig_FWD_DEFINED__ */


#ifndef __IWMStreamConfig2_FWD_DEFINED__
#define __IWMStreamConfig2_FWD_DEFINED__
typedef interface IWMStreamConfig2 IWMStreamConfig2;
#endif 	/* __IWMStreamConfig2_FWD_DEFINED__ */


#ifndef __IWMPacketSize_FWD_DEFINED__
#define __IWMPacketSize_FWD_DEFINED__
typedef interface IWMPacketSize IWMPacketSize;
#endif 	/* __IWMPacketSize_FWD_DEFINED__ */


#ifndef __IWMPacketSize2_FWD_DEFINED__
#define __IWMPacketSize2_FWD_DEFINED__
typedef interface IWMPacketSize2 IWMPacketSize2;
#endif 	/* __IWMPacketSize2_FWD_DEFINED__ */


#ifndef __IWMStreamList_FWD_DEFINED__
#define __IWMStreamList_FWD_DEFINED__
typedef interface IWMStreamList IWMStreamList;
#endif 	/* __IWMStreamList_FWD_DEFINED__ */


#ifndef __IWMMutualExclusion_FWD_DEFINED__
#define __IWMMutualExclusion_FWD_DEFINED__
typedef interface IWMMutualExclusion IWMMutualExclusion;
#endif 	/* __IWMMutualExclusion_FWD_DEFINED__ */


#ifndef __IWMMutualExclusion2_FWD_DEFINED__
#define __IWMMutualExclusion2_FWD_DEFINED__
typedef interface IWMMutualExclusion2 IWMMutualExclusion2;
#endif 	/* __IWMMutualExclusion2_FWD_DEFINED__ */


#ifndef __IWMBandwidthSharing_FWD_DEFINED__
#define __IWMBandwidthSharing_FWD_DEFINED__
typedef interface IWMBandwidthSharing IWMBandwidthSharing;
#endif 	/* __IWMBandwidthSharing_FWD_DEFINED__ */


#ifndef __IWMStreamPrioritization_FWD_DEFINED__
#define __IWMStreamPrioritization_FWD_DEFINED__
typedef interface IWMStreamPrioritization IWMStreamPrioritization;
#endif 	/* __IWMStreamPrioritization_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced_FWD_DEFINED__
#define __IWMWriterAdvanced_FWD_DEFINED__
typedef interface IWMWriterAdvanced IWMWriterAdvanced;
#endif 	/* __IWMWriterAdvanced_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced2_FWD_DEFINED__
#define __IWMWriterAdvanced2_FWD_DEFINED__
typedef interface IWMWriterAdvanced2 IWMWriterAdvanced2;
#endif 	/* __IWMWriterAdvanced2_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced3_FWD_DEFINED__
#define __IWMWriterAdvanced3_FWD_DEFINED__
typedef interface IWMWriterAdvanced3 IWMWriterAdvanced3;
#endif 	/* __IWMWriterAdvanced3_FWD_DEFINED__ */


#ifndef __IWMWriterPreprocess_FWD_DEFINED__
#define __IWMWriterPreprocess_FWD_DEFINED__
typedef interface IWMWriterPreprocess IWMWriterPreprocess;
#endif 	/* __IWMWriterPreprocess_FWD_DEFINED__ */


#ifndef __IWMDRMWriter_FWD_DEFINED__
#define __IWMDRMWriter_FWD_DEFINED__
typedef interface IWMDRMWriter IWMDRMWriter;
#endif 	/* __IWMDRMWriter_FWD_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_FWD_DEFINED__
#define __IWMWriterPostViewCallback_FWD_DEFINED__
typedef interface IWMWriterPostViewCallback IWMWriterPostViewCallback;
#endif 	/* __IWMWriterPostViewCallback_FWD_DEFINED__ */


#ifndef __IWMWriterPostView_FWD_DEFINED__
#define __IWMWriterPostView_FWD_DEFINED__
typedef interface IWMWriterPostView IWMWriterPostView;
#endif 	/* __IWMWriterPostView_FWD_DEFINED__ */


#ifndef __IWMWriterSink_FWD_DEFINED__
#define __IWMWriterSink_FWD_DEFINED__
typedef interface IWMWriterSink IWMWriterSink;
#endif 	/* __IWMWriterSink_FWD_DEFINED__ */


#ifndef __IWMRegisterCallback_FWD_DEFINED__
#define __IWMRegisterCallback_FWD_DEFINED__
typedef interface IWMRegisterCallback IWMRegisterCallback;
#endif 	/* __IWMRegisterCallback_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink_FWD_DEFINED__
#define __IWMWriterFileSink_FWD_DEFINED__
typedef interface IWMWriterFileSink IWMWriterFileSink;
#endif 	/* __IWMWriterFileSink_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink2_FWD_DEFINED__
#define __IWMWriterFileSink2_FWD_DEFINED__
typedef interface IWMWriterFileSink2 IWMWriterFileSink2;
#endif 	/* __IWMWriterFileSink2_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink3_FWD_DEFINED__
#define __IWMWriterFileSink3_FWD_DEFINED__
typedef interface IWMWriterFileSink3 IWMWriterFileSink3;
#endif 	/* __IWMWriterFileSink3_FWD_DEFINED__ */


#ifndef __IWMWriterNetworkSink_FWD_DEFINED__
#define __IWMWriterNetworkSink_FWD_DEFINED__
typedef interface IWMWriterNetworkSink IWMWriterNetworkSink;
#endif 	/* __IWMWriterNetworkSink_FWD_DEFINED__ */


#ifndef __IWMWriterPushSink_FWD_DEFINED__
#define __IWMWriterPushSink_FWD_DEFINED__
typedef interface IWMWriterPushSink IWMWriterPushSink;
#endif 	/* __IWMWriterPushSink_FWD_DEFINED__ */


#ifndef __IWMClientConnections_FWD_DEFINED__
#define __IWMClientConnections_FWD_DEFINED__
typedef interface IWMClientConnections IWMClientConnections;
#endif 	/* __IWMClientConnections_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced_FWD_DEFINED__
#define __IWMReaderAdvanced_FWD_DEFINED__
typedef interface IWMReaderAdvanced IWMReaderAdvanced;
#endif 	/* __IWMReaderAdvanced_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced2_FWD_DEFINED__
#define __IWMReaderAdvanced2_FWD_DEFINED__
typedef interface IWMReaderAdvanced2 IWMReaderAdvanced2;
#endif 	/* __IWMReaderAdvanced2_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced3_FWD_DEFINED__
#define __IWMReaderAdvanced3_FWD_DEFINED__
typedef interface IWMReaderAdvanced3 IWMReaderAdvanced3;
#endif 	/* __IWMReaderAdvanced3_FWD_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_FWD_DEFINED__
#define __IWMReaderAllocatorEx_FWD_DEFINED__
typedef interface IWMReaderAllocatorEx IWMReaderAllocatorEx;
#endif 	/* __IWMReaderAllocatorEx_FWD_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_FWD_DEFINED__
#define __IWMReaderTypeNegotiation_FWD_DEFINED__
typedef interface IWMReaderTypeNegotiation IWMReaderTypeNegotiation;
#endif 	/* __IWMReaderTypeNegotiation_FWD_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_FWD_DEFINED__
#define __IWMReaderCallbackAdvanced_FWD_DEFINED__
typedef interface IWMReaderCallbackAdvanced IWMReaderCallbackAdvanced;
#endif 	/* __IWMReaderCallbackAdvanced_FWD_DEFINED__ */


#ifndef __IWMDRMReader_FWD_DEFINED__
#define __IWMDRMReader_FWD_DEFINED__
typedef interface IWMDRMReader IWMDRMReader;
#endif 	/* __IWMDRMReader_FWD_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_FWD_DEFINED__
#define __IWMReaderNetworkConfig_FWD_DEFINED__
typedef interface IWMReaderNetworkConfig IWMReaderNetworkConfig;
#endif 	/* __IWMReaderNetworkConfig_FWD_DEFINED__ */


#ifndef __IWMReaderNetworkConfig2_FWD_DEFINED__
#define __IWMReaderNetworkConfig2_FWD_DEFINED__
typedef interface IWMReaderNetworkConfig2 IWMReaderNetworkConfig2;
#endif 	/* __IWMReaderNetworkConfig2_FWD_DEFINED__ */


#ifndef __IWMReaderStreamClock_FWD_DEFINED__
#define __IWMReaderStreamClock_FWD_DEFINED__
typedef interface IWMReaderStreamClock IWMReaderStreamClock;
#endif 	/* __IWMReaderStreamClock_FWD_DEFINED__ */


#ifndef __IWMIndexer_FWD_DEFINED__
#define __IWMIndexer_FWD_DEFINED__
typedef interface IWMIndexer IWMIndexer;
#endif 	/* __IWMIndexer_FWD_DEFINED__ */


#ifndef __IWMIndexer2_FWD_DEFINED__
#define __IWMIndexer2_FWD_DEFINED__
typedef interface IWMIndexer2 IWMIndexer2;
#endif 	/* __IWMIndexer2_FWD_DEFINED__ */


#ifndef __IWMLicenseBackup_FWD_DEFINED__
#define __IWMLicenseBackup_FWD_DEFINED__
typedef interface IWMLicenseBackup IWMLicenseBackup;
#endif 	/* __IWMLicenseBackup_FWD_DEFINED__ */


#ifndef __IWMLicenseRestore_FWD_DEFINED__
#define __IWMLicenseRestore_FWD_DEFINED__
typedef interface IWMLicenseRestore IWMLicenseRestore;
#endif 	/* __IWMLicenseRestore_FWD_DEFINED__ */


#ifndef __IWMBackupRestoreProps_FWD_DEFINED__
#define __IWMBackupRestoreProps_FWD_DEFINED__
typedef interface IWMBackupRestoreProps IWMBackupRestoreProps;
#endif 	/* __IWMBackupRestoreProps_FWD_DEFINED__ */


#ifndef __IWMCodecInfo_FWD_DEFINED__
#define __IWMCodecInfo_FWD_DEFINED__
typedef interface IWMCodecInfo IWMCodecInfo;
#endif 	/* __IWMCodecInfo_FWD_DEFINED__ */


#ifndef __IWMCodecInfo2_FWD_DEFINED__
#define __IWMCodecInfo2_FWD_DEFINED__
typedef interface IWMCodecInfo2 IWMCodecInfo2;
#endif 	/* __IWMCodecInfo2_FWD_DEFINED__ */


#ifndef __IWMCodecInfo3_FWD_DEFINED__
#define __IWMCodecInfo3_FWD_DEFINED__
typedef interface IWMCodecInfo3 IWMCodecInfo3;
#endif 	/* __IWMCodecInfo3_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmsbuffer.h"
#include "drmexternals.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsdkidl_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//=========================================================================
typedef unsigned __int64 QWORD;










































////////////////////////////////////////////////////////////////
//
// These are the special case attributes that give information 
// about the Windows Media file.
//
static const DWORD g_dwWMSpecialAttributes = 20;
static const WCHAR *g_wszWMDuration = L"Duration";
static const WCHAR *g_wszWMBitrate = L"Bitrate";
static const WCHAR *g_wszWMSeekable = L"Seekable";
static const WCHAR *g_wszWMStridable = L"Stridable";
static const WCHAR *g_wszWMBroadcast = L"Broadcast";
static const WCHAR *g_wszWMProtected = L"Is_Protected";
static const WCHAR *g_wszWMTrusted = L"Is_Trusted";
static const WCHAR *g_wszWMSignature_Name = L"Signature_Name";
static const WCHAR *g_wszWMHasAudio = L"HasAudio";
static const WCHAR *g_wszWMHasImage = L"HasImage";
static const WCHAR *g_wszWMHasScript = L"HasScript";
static const WCHAR *g_wszWMHasVideo = L"HasVideo";
static const WCHAR *g_wszWMCurrentBitrate = L"CurrentBitrate";
static const WCHAR *g_wszWMOptimalBitrate = L"OptimalBitrate";
static const WCHAR *g_wszWMHasAttachedImages = L"HasAttachedImages";
static const WCHAR *g_wszWMSkipBackward = L"Can_Skip_Backward";
static const WCHAR *g_wszWMSkipForward = L"Can_Skip_Forward";
static const WCHAR *g_wszWMNumberOfFrames = L"NumberOfFrames";
static const WCHAR *g_wszWMFileSize = L"FileSize";
static const WCHAR *g_wszWMHasArbitraryDataStream = L"HasArbitraryDataStream";
static const WCHAR *g_wszWMHasFileTransferStream = L"HasFileTransferStream";

////////////////////////////////////////////////////////////////
//
// The content description object supports 5 basic attributes.
//
static const DWORD g_dwWMContentAttributes = 5;
static const WCHAR *g_wszWMTitle = L"Title";
static const WCHAR *g_wszWMAuthor = L"Author";
static const WCHAR *g_wszWMDescription = L"Description";
static const WCHAR *g_wszWMRating = L"Rating";
static const WCHAR *g_wszWMCopyright = L"Copyright";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR *g_wszWMAlbumTitle = L"WM/AlbumTitle";
static const WCHAR *g_wszWMTrack = L"WM/Track";
static const WCHAR *g_wszWMPromotionURL = L"WM/PromotionURL";
static const WCHAR *g_wszWMAlbumCoverURL = L"WM/AlbumCoverURL";
static const WCHAR *g_wszWMGenre = L"WM/Genre";
static const WCHAR *g_wszWMYear = L"WM/Year";
static const WCHAR *g_wszWMGenreID = L"WM/GenreID";
static const WCHAR *g_wszWMMCDI = L"WM/MCDI";
static const WCHAR *g_wszWMComposer = L"WM/Composer";
static const WCHAR *g_wszWMLyrics = L"WM/Lyrics";
static const WCHAR *g_wszWMTrackNumber = L"WM/TrackNumber";
static const WCHAR *g_wszWMToolName = L"WM/ToolName";
static const WCHAR *g_wszWMToolVersion = L"WM/ToolVersion";
static const WCHAR *g_wszWMAlbumArtist = L"WM/AlbumArtist";

////////////////////////////////////////////////////////////////
//
// These optional attributes may be used to give information 
// about the branding of the content.
//
static const WCHAR *g_wszWMBannerImageType = L"BannerImageType";
static const WCHAR *g_wszWMBannerImageData = L"BannerImageData";
static const WCHAR *g_wszWMBannerImageURL = L"BannerImageURL";
static const WCHAR *g_wszWMCopyrightURL = L"CopyrightURL";
////////////////////////////////////////////////////////////////
//
// Optional attributes, used to give information 
// about video stream properties.
//
static const WCHAR *g_wszWMAspectRatioX = L"AspectRatioX";
static const WCHAR *g_wszWMAspectRatioY = L"AspectRatioY";
////////////////////////////////////////////////////////////////
//
// The NSC file supports the following attributes.
//
static const DWORD g_dwWMNSCAttributes = 5;
static const WCHAR *g_wszWMNSCName = L"NSC_Name";
static const WCHAR *g_wszWMNSCAddress = L"NSC_Address";
static const WCHAR *g_wszWMNSCPhone = L"NSC_Phone";
static const WCHAR *g_wszWMNSCEmail = L"NSC_Email";
static const WCHAR *g_wszWMNSCDescription = L"NSC_Description";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetOutputSetting
//
static const WCHAR *g_wszEarlyDataDelivery = L"EarlyDataDelivery";
static const WCHAR *g_wszJustInTimeDecode = L"JustInTimeDecode";
static const WCHAR *g_wszSingleOutputBuffer = L"SingleOutputBuffer";
static const WCHAR *g_wszSoftwareScaling = L"SoftwareScaling";
static const WCHAR *g_wszDeliverOnReceive = L"DeliverOnReceive";
static const WCHAR *g_wszScrambledAudio = L"ScrambledAudio";
static const WCHAR *g_wszDedicatedDeliveryThread = L"DedicatedDeliveryThread";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetInputSetting
//
static const WCHAR *g_wszDeinterlaceMode = L"DeinterlaceMode";
static const WCHAR *g_wszInitialPatternForInverseTelecine = L"InitialPatternForInverseTelecine";
static const WCHAR *g_wszJPEGCompressionQuality = L"JPEGCompressionQuality";

////////////////////////////////////////////////////////////////
//
// All known IWMPropertyVault property names
//
static const WCHAR *g_wszOriginalSourceFormatTag = L"_SOURCEFORMATTAG";
static const WCHAR *g_wszEDL = L"_EDL";

////////////////////////////////////////////////////////////////
//
// All known IWMIStreamProps property names
//
static const WCHAR *g_wszReloadIndexOnSeek = L"ReloadIndexOnSeek";
static const WCHAR *g_wszStreamNumIndexObjects = L"StreamNumIndexObjects";
static const WCHAR *g_wszFailSeekOnError = L"FailSeekOnError";
static const WCHAR *g_wszPermitSeeksBeyondEndOfStream = L"PermitSeeksBeyondEndOfStream";
static const WCHAR *g_wszUsePacketAtSeekPoint = L"UsePacketAtSeekPoint";
static const WCHAR *g_wszSourceBufferTime = L"SourceBufferTime";
static const WCHAR *g_wszSourceMaxBytesAtOnce = L"SourceMaxBytesAtOnce";

////////////////////////////////////////////////////////////////
//
// These attributes are used to configure DRM using IWMDRMWriter::SetDRMAttribute.
//
static const WCHAR *g_wszWMUse_DRM = L"Use_DRM";
static const WCHAR *g_wszWMDRM_Flags = L"DRM_Flags";
static const WCHAR *g_wszWMDRM_Level = L"DRM_Level";
static const WCHAR *g_wszWMUse_Advanced_DRM = L"Use_Advanced_DRM";
static const WCHAR *g_wszWMDRM_KeySeed = L"DRM_KeySeed";
static const WCHAR *g_wszWMDRM_KeyID = L"DRM_KeyID";
static const WCHAR *g_wszWMDRM_ContentID = L"DRM_ContentID";
static const WCHAR *g_wszWMDRM_IndividualizedVersion = L"DRM_IndividualizedVersion";
static const WCHAR *g_wszWMDRM_LicenseAcqURL = L"DRM_LicenseAcqURL";
static const WCHAR *g_wszWMDRM_V1LicenseAcqURL = L"DRM_V1LicenseAcqURL";
static const WCHAR *g_wszWMDRM_HeaderSignPrivKey = L"DRM_HeaderSignPrivKey";

////////////////////////////////////////////////////////////////
//
// VBR encoding settings
//
static const WCHAR *g_wszVBREnabled = L"_VBRENABLED";
static const WCHAR *g_wszVBRQuality = L"_VBRQUALITY";
static const WCHAR *g_wszVBRBitrateMax = L"_RMAX";
static const WCHAR *g_wszVBRBitrateAvg = L"_RAVG";
static const WCHAR *g_wszVBRBufferWindowMax = L"_BMAX";
static const WCHAR *g_wszVBRBufferWindowAvg = L"_BAVG";

////////////////////////////////////////////////////////////////
//
// Flags that can be passed into the Start method of IWMReader
//
#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )

#define WM_BACKUP_OVERWRITE    ((DWORD) 0x00000001)
#define WM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)
#define WAVE_FORMAT_DRM            0x0009

enum __MIDL___MIDL_itf_wmsdkidl_0000_0001
    {	WM_SF_CLEANPOINT	= 0x1,
	WM_SF_DISCONTINUITY	= 0x2,
	WM_SF_DATALOSS	= 0x4
    };

enum __MIDL___MIDL_itf_wmsdkidl_0000_0002
    {	WM_SFEX_NOTASYNCPOINT	= 0x2,
	WM_SFEX_DATALOSS	= 0x4
    };
typedef 
enum WMT_STATUS
    {	WMT_ERROR	= 0,
	WMT_OPENED	= 1,
	WMT_BUFFERING_START	= 2,
	WMT_BUFFERING_STOP	= 3,
	WMT_EOF	= 4,
	WMT_END_OF_FILE	= 4,
	WMT_END_OF_SEGMENT	= 5,
	WMT_END_OF_STREAMING	= 6,
	WMT_LOCATING	= 7,
	WMT_CONNECTING	= 8,
	WMT_NO_RIGHTS	= 9,
	WMT_MISSING_CODEC	= 10,
	WMT_STARTED	= 11,
	WMT_STOPPED	= 12,
	WMT_CLOSED	= 13,
	WMT_STRIDING	= 14,
	WMT_TIMER	= 15,
	WMT_INDEX_PROGRESS	= 16,
	WMT_SAVEAS_START	= 17,
	WMT_SAVEAS_STOP	= 18,
	WMT_NEW_SOURCEFLAGS	= 19,
	WMT_NEW_METADATA	= 20,
	WMT_BACKUPRESTORE_BEGIN	= 21,
	WMT_SOURCE_SWITCH	= 22,
	WMT_ACQUIRE_LICENSE	= 23,
	WMT_INDIVIDUALIZE	= 24,
	WMT_NEEDS_INDIVIDUALIZATION	= 25,
	WMT_NO_RIGHTS_EX	= 26,
	WMT_BACKUPRESTORE_END	= 27,
	WMT_BACKUPRESTORE_CONNECTING	= 28,
	WMT_BACKUPRESTORE_DISCONNECTING	= 29,
	WMT_ERROR_WITHURL	= 30,
	WMT_RESTRICTED_LICENSE	= 31,
	WMT_CLIENT_CONNECT	= 32,
	WMT_CLIENT_DISCONNECT	= 33,
	WMT_NATIVE_OUTPUT_PROPS_CHANGED	= 34,
	WMT_RESET_TIME	= 35,
	WMT_RECONNECT_START	= 36,
	WMT_RECONNECT_END	= 37
    }	WMT_STATUS;

typedef 
enum WMT_RIGHTS
    {	WMT_RIGHT_PLAYBACK	= 0x1,
	WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
	WMT_RIGHT_COPY_TO_CD	= 0x8,
	WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
	WMT_RIGHT_ONE_TIME	= 0x20,
	WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
	WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
    }	WMT_RIGHTS;

typedef 
enum WMT_STREAM_SELECTION
    {	WMT_OFF	= 0,
	WMT_CLEANPOINT_ONLY	= 1,
	WMT_ON	= 2
    }	WMT_STREAM_SELECTION;

typedef 
enum WMT_ATTR_DATATYPE
    {	WMT_TYPE_DWORD	= 0,
	WMT_TYPE_STRING	= 1,
	WMT_TYPE_BINARY	= 2,
	WMT_TYPE_BOOL	= 3,
	WMT_TYPE_QWORD	= 4,
	WMT_TYPE_WORD	= 5,
	WMT_TYPE_GUID	= 6
    }	WMT_ATTR_DATATYPE;

typedef 
enum WMT_ATTR_IMAGETYPE
    {	WMT_IMAGETYPE_BITMAP	= 1,
	WMT_IMAGETYPE_JPEG	= 2,
	WMT_IMAGETYPE_GIF	= 3
    }	WMT_ATTR_IMAGETYPE;

typedef 
enum WMT_VERSION
    {	WMT_VER_4_0	= 0x40000,
	WMT_VER_7_0	= 0x70000,
	WMT_VER_9_0	= 0x90000
    }	WMT_VERSION;

typedef 
enum tagWMT_STORAGE_FORMAT
    {	WMT_Storage_Format_MP3	= 0,
	WMT_Storage_Format_V1	= WMT_Storage_Format_MP3 + 1,
	WMT_Storage_Format_V2	= WMT_Storage_Format_V1 + 1
    }	WMT_STORAGE_FORMAT;

typedef 
enum tagWMT_TRANSPORT_TYPE
    {	WMT_Transport_Type_Unreliable	= 0,
	WMT_Transport_Type_Reliable	= WMT_Transport_Type_Unreliable + 1
    }	WMT_TRANSPORT_TYPE;

typedef 
enum WMT_NET_PROTOCOL
    {	WMT_PROTOCOL_HTTP	= 0
    }	WMT_NET_PROTOCOL;

typedef 
enum WMT_PLAY_MODE
    {	WMT_PLAY_MODE_AUTOSELECT	= 0,
	WMT_PLAY_MODE_LOCAL	= 1,
	WMT_PLAY_MODE_DOWNLOAD	= 2,
	WMT_PLAY_MODE_STREAMING	= 3
    }	WMT_PLAY_MODE;

typedef 
enum WMT_PROXY_SETTINGS
    {	WMT_PROXY_SETTING_NONE	= 0,
	WMT_PROXY_SETTING_MANUAL	= 1,
	WMT_PROXY_SETTING_AUTO	= 2,
	WMT_PROXY_SETTING_BROWSER	= 3
    }	WMT_PROXY_SETTINGS;

typedef 
enum WMT_CODEC_INFO_TYPE
    {	WMT_CODECINFO_AUDIO	= 0,
	WMT_CODECINFO_VIDEO	= 1,
	WMT_CODECINFO_UNKNOWN	= 0xffffffff
    }	WMT_CODEC_INFO_TYPE;


enum __MIDL___MIDL_itf_wmsdkidl_0000_0003
    {	WM_DM_NOTINTERLACED	= 0,
	WM_DM_DEINTERLACE_NORMAL	= 1,
	WM_DM_DEINTERLACE_HALFSIZE	= 2,
	WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE	= 3,
	WM_DM_DEINTERLACE_INVERSETELECINE	= 4,
	WM_DM_DEINTERLACE_VERTICALHALFSIZEDOUBLERATE	= 5
    };

enum __MIDL___MIDL_itf_wmsdkidl_0000_0004
    {	WM_DM_IT_DISABLE_COHERENT_MODE	= 0,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_AA	= 1,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BB	= 2,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_BC	= 3,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_CD	= 4,
	WM_DM_IT_FIRST_FRAME_IN_CLIP_IS_DD	= 5
    };
typedef 
enum tagWMT_OFFSET_FORMAT
    {	WMT_OFFSET_FORMAT_100NS	= 0,
	WMT_OFFSET_FORMAT_SMPTE	= WMT_OFFSET_FORMAT_100NS + 1,
	WMT_OFFSET_FORMAT_FRAME_NUMBERS	= WMT_OFFSET_FORMAT_SMPTE + 1,
	WMT_OFFSET_FORMAT_PLAYLIST_OFFSET	= WMT_OFFSET_FORMAT_FRAME_NUMBERS + 1
    }	WMT_OFFSET_FORMAT;

typedef 
enum tagWMT_INDEXER_TYPE
    {	WMT_IT_PRESENTATION_TIME	= 0,
	WMT_IT_FRAME_NUMBERS	= WMT_IT_PRESENTATION_TIME + 1
    }	WMT_INDEXER_TYPE;

typedef 
enum tagWMT_INDEX_TYPE
    {	WMT_IT_NEAREST_DATA_UNIT	= 1,
	WMT_IT_NEAREST_OBJECT	= WMT_IT_NEAREST_DATA_UNIT + 1,
	WMT_IT_NEAREST_CLEAN_POINT	= WMT_IT_NEAREST_OBJECT + 1
    }	WMT_INDEX_TYPE;

typedef 
enum tagWMT_FILESINK_MODE
    {	WMT_FM_SINGLE_BUFFERS	= 0x1,
	WMT_FM_FILESINK_DATA_UNITS	= 0x2
    }	WMT_FILESINK_MODE;

typedef struct  _WMStreamPrioritizationRecord
    {
    WORD wStreamNumber;
    BOOL fMandatory;
    }	WM_STREAM_PRIORITY_RECORD;

typedef struct  _WMWriterStatistics
    {
    QWORD qwSampleCount;
    QWORD qwByteCount;
    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;
    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
    }	WM_WRITER_STATISTICS;

typedef struct  _WMWriterStatisticsEx
    {
    DWORD dwBitratePlusOverhead;
    DWORD dwCurrentSampleDropRateInQueue;
    DWORD dwCurrentSampleDropRateInCodec;
    DWORD dwCurrentSampleDropRateInMultiplexer;
    DWORD dwTotalSampleDropsInQueue;
    DWORD dwTotalSampleDropsInCodec;
    DWORD dwTotalSampleDropsInMultiplexer;
    }	WM_WRITER_STATISTICS_EX;

typedef struct  _WMReaderStatistics
    {
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD wQuality;
    }	WM_READER_STATISTICS;

typedef 
enum _WMT_QOS_ENABLED
    {	WMT_QOS_NONE	= 0,
	WMT_QOS_BEST_EFFORT	= 1,
	WMT_QOS_CONTROLLED_LOAD	= 2,
	WMT_QOS_GUARANTEED	= 3
    }	WMT_QOS_MODE;

typedef struct  _WMReaderClientInfo
    {
    DWORD cbSize;
    WCHAR __RPC_FAR *wszLang;
    WCHAR __RPC_FAR *wszBrowserUserAgent;
    WCHAR __RPC_FAR *wszBrowserWebPage;
    QWORD qwReserved;
    LPARAM __RPC_FAR *pReserved;
    WCHAR __RPC_FAR *wszHostExe;
    QWORD qwHostVersion;
    }	WM_READER_CLIENTINFO;

typedef struct  _WMClientProperties
    {
    DWORD dwIPAddress;
    DWORD dwPort;
    }	WM_CLIENT_PROPERTIES;

typedef struct  _WMPortNumberRange
    {
    WORD wPortBegin;
    WORD wPortEnd;
    }	WM_PORT_NUMBER_RANGE;

typedef 
enum _WMT_TIMEBASE_DROPSCHEME
    {	WMT_DROPSCHEME_NONE	= 0,
	WMT_DROPSCHEME_SMPTE	= WMT_DROPSCHEME_NONE + 1
    }	WMT_TIMEBASE_DROPSCHEME;

typedef struct  _WMT_TIMEBASE
    {
    DWORD dwTicksPerSecond;
    DWORD dwTicksPerFrame;
    WMT_TIMEBASE_DROPSCHEME dropScheme;
    }	WMT_TIMEBASE;

typedef struct  _WMT_TIMESTAMP
    {
    long hours;
    signed char minutes;
    signed char seconds;
    signed char frames;
    long offset;
    }	WMT_TIMESTAMP;

typedef struct  _WMT_BUFFER_SEGMENT
    {
    INSSBuffer __RPC_FAR *pBuffer;
    DWORD cbOffset;
    DWORD cbLength;
    }	WMT_BUFFER_SEGMENT;

typedef struct  _WMT_PAYLOAD_FRAGMENT
    {
    DWORD dwPayloadIndex;
    WMT_BUFFER_SEGMENT segmentData;
    }	WMT_PAYLOAD_FRAGMENT;

typedef struct  _WMT_FILESINK_DATA_UNIT
    {
    WMT_BUFFER_SEGMENT packetHeaderBuffer;
    DWORD cPayloads;
    WMT_BUFFER_SEGMENT __RPC_FAR *pPayloadHeaderBuffers;
    DWORD cPayloadDataFragments;
    WMT_PAYLOAD_FRAGMENT __RPC_FAR *pPayloadDataFragments;
    }	WMT_FILESINK_DATA_UNIT;

typedef struct  _WM_LICENSE_STATE_DATA
    {
    DWORD dwSize;
    DWORD dwNumStates;
    DRM_LICENSE_STATE_DATA stateData[ 1 ];
    }	WM_LICENSE_STATE_DATA;

typedef struct  _WMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown __RPC_FAR *pUnk;
    ULONG cbFormat;
    /* [size_is] */ BYTE __RPC_FAR *pbFormat;
    }	WM_MEDIA_TYPE;

typedef struct tagWMVIDEOINFOHEADER
{
    //
    // The bit we really want to use.
    //
    RECT rcSource;

    //
    // Where the video should go.
    //
    RECT rcTarget;

    //
    // Approximate bit data rate.
    //
    DWORD dwBitRate;

    //
    // Bit error rate for this stream.
    //
    DWORD dwBitErrorRate;

    //
    // Average time per frame (100ns units).
    //
    LONGLONG AvgTimePerFrame;

    BITMAPINFOHEADER bmiHeader;
} WMVIDEOINFOHEADER;
typedef struct tagWMVIDEOINFOHEADER2
{
    //
    // The bit we really want to use.
    //
    RECT rcSource;

    //
    // Where the video should go.
    //
    RECT rcTarget;

    //
    // Approximate bit data rate.
    //
    DWORD dwBitRate;

    //
    // Bit error rate for this stream.
    //
    DWORD dwBitErrorRate;

    //
    // Average time per frame (100ns units).
    //
    LONGLONG AvgTimePerFrame;

    //
    // Use AMINTERLACE_* defines. Reject connection if undefined bits are not 0.
    //
    DWORD dwInterlaceFlags;

    //
    // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0.
    //
    DWORD dwCopyProtectFlags;

    //
    // X dimension of picture aspect ratio, e.g. 16 for 16x9 display.
    //
    DWORD dwPictAspectRatioX;

    //
    // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display.
    //
    DWORD dwPictAspectRatioY;

    //
    // Must be 0; reject connection otherwise.
    //
    DWORD dwReserved1;

    //
    // Must be 0; reject connection otherwise.
    //
    DWORD dwReserved2;

    BITMAPINFOHEADER bmiHeader;
} WMVIDEOINFOHEADER2;
typedef struct tagWMMPEG2VIDEOINFO
{
    //
    // Video info header2.
    //
    WMVIDEOINFOHEADER2 hdr;

    //
    // Not used for DVD.
    //
    DWORD dwStartTimeCode;

    //
    // Is 0 for DVD (no sequence header).
    //
    DWORD cbSequenceHeader;

    //
    // Use enum MPEG2Profile.
    //
    DWORD dwProfile;

    //
    // Use enum MPEG2Level.
    //
    DWORD dwLevel;

    //
    // Use AMMPEG2_* defines.  Reject connection if undefined bits are not 0.
    //
    DWORD dwFlags;

    //
    // Sequence header.
    //
    DWORD dwSequenceHeader[1];

} WMMPEG2VIDEOINFO;
typedef struct tagWMSCRIPTFORMAT
{
    GUID    scriptType; 
} WMSCRIPTFORMAT;
// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base 
EXTERN_GUID(WMMEDIASUBTYPE_Base, 
0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video 
EXTERN_GUID(WMMEDIATYPE_Video, 
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 
EXTERN_GUID(WMMEDIASUBTYPE_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 
EXTERN_GUID(WMMEDIASUBTYPE_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 
EXTERN_GUID(WMMEDIASUBTYPE_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 
EXTERN_GUID(WMMEDIASUBTYPE_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 
EXTERN_GUID(WMMEDIASUBTYPE_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 
EXTERN_GUID(WMMEDIASUBTYPE_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 
EXTERN_GUID(WMMEDIASUBTYPE_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// 30323449-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_I420 
EXTERN_GUID(WMMEDIASUBTYPE_I420, 
0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 56555949-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_IYUV 
EXTERN_GUID(WMMEDIASUBTYPE_IYUV, 
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 
EXTERN_GUID(WMMEDIASUBTYPE_YV12, 
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 
EXTERN_GUID(WMMEDIASUBTYPE_YUY2, 
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY 
EXTERN_GUID(WMMEDIASUBTYPE_UYVY, 
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU 
EXTERN_GUID(WMMEDIASUBTYPE_YVYU, 
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 
EXTERN_GUID(WMMEDIASUBTYPE_YVU9, 
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 
EXTERN_GUID(WMMEDIASUBTYPE_MP43, 
0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 5334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP4S 
EXTERN_GUID(WMMEDIASUBTYPE_MP4S, 
0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 31564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV1 
EXTERN_GUID(WMMEDIASUBTYPE_WMV1, 
0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 32564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMV2, 
0x32564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 3153534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS1 
EXTERN_GUID(WMMEDIASUBTYPE_MSS1, 
0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 3253534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS2 
EXTERN_GUID(WMMEDIASUBTYPE_MSS2, 
0x3253534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// e06d8026-db46-11cf-b4d1-00805f6cbbea            WMMEDIASUBTYPE_MPEG2_VIDEO 
EXTERN_GUID(WMMEDIASUBTYPE_MPEG2_VIDEO, 
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea); 
// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio 
EXTERN_GUID(WMMEDIATYPE_Aud