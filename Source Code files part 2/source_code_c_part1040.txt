WsbTrace(OLESTR("Library Information:\n") );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Library Type...  %-d\n"), pObjectInfo->Info.Library.LibraryType );
            WsbTrace(OLESTR("  CleanerSlot....  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Library.CleanerSlot) );
            WsbTrace(OLESTR("  CleanerSlotD...  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Library.CleanerSlotDefault) );
            WsbTrace(OLESTR("  Can Clean......  %-ls\n"), WsbBoolAsString(pObjectInfo->Info.Library.LibrarySupportsDriveCleaning) );
            WsbTrace(OLESTR("  Has Bar Code...  %-ls\n"), WsbBoolAsString(pObjectInfo->Info.Library.BarCodeReaderInstalled) );
            WsbTrace(OLESTR("  Inventory Method %-d\n"), pObjectInfo->Info.Library.InventoryMethod );
            WsbTrace(OLESTR("  Cleans Remaining %-d\n"), pObjectInfo->Info.Library.dwCleanerUsesRemaining );
            WsbTrace(OLESTR("  Drives.........  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfDrives,
                pObjectInfo->Info.Library.FirstDriveNumber);
            WsbTrace(OLESTR("  Slots..........  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfSlots,
                pObjectInfo->Info.Library.FirstSlotNumber);
            WsbTrace(OLESTR("  Doors..........  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfDoors,
                pObjectInfo->Info.Library.FirstDoorNumber);
            WsbTrace(OLESTR("  Ports..........  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfPorts,
                pObjectInfo->Info.Library.FirstPortNumber);
            WsbTrace(OLESTR("  Changers.......  %-d (%d)\n"),
                pObjectInfo->Info.Library.dwNumberOfChangers,
                pObjectInfo->Info.Library.FirstChangerNumber);
            WsbTrace(OLESTR("  Media Count....  %-d\n"), pObjectInfo->Info.Library.dwNumberOfMedia );
            WsbTrace(OLESTR("  Media Types....  %-d\n"), pObjectInfo->Info.Library.dwNumberOfMediaTypes );
            WsbTrace(OLESTR("  Requests.......  %-d\n"), pObjectInfo->Info.Library.dwNumberOfLibRequests );
            break;

        case NTMS_LIBREQUEST:
        case NTMS_LOGICAL_MEDIA:
            break;

        case NTMS_MEDIA_POOL:
            {
                // We need some temporaries since WsbGuidAsString() uses static memory to store string.
                CWsbStringPtr g1 = pObjectInfo->ObjectGuid;
                CWsbStringPtr g2 = pObjectInfo->Info.MediaPool.MediaType;
                CWsbStringPtr g3 = pObjectInfo->Info.MediaPool.Parent;

                WsbTrace( OLESTR("%ls %5ls %4d %ls %ls %5d %5d %8d %8d %8d %5d <%ls> / <%ls>\n"),
                                (WCHAR *)g1,
                                WsbBoolAsString(pObjectInfo->Enabled),
                                pObjectInfo->Info.MediaPool.PoolType,
                                (WCHAR *)g2,
                                (WCHAR *)g3,
                                pObjectInfo->Info.MediaPool.AllocationPolicy,
                                pObjectInfo->Info.MediaPool.DeallocationPolicy,
                                pObjectInfo->Info.MediaPool.dwMaxAllocates,
                                pObjectInfo->Info.MediaPool.dwNumberOfPhysicalMedia,
                                pObjectInfo->Info.MediaPool.dwNumberOfLogicalMedia,
                                pObjectInfo->Info.MediaPool.dwNumberOfMediaPools,
                                pObjectInfo->szName,
                                pObjectInfo->szDescription );
            }
            break;

        case NTMS_MEDIA_TYPE:
            WsbTrace( OLESTR("%ls %5ls %4d %5d %2d <%ls> / <%ls>\n"),
                            WsbGuidAsString(pObjectInfo->ObjectGuid),
                            WsbBoolAsString(pObjectInfo->Enabled),
                            pObjectInfo->Info.MediaType.MediaType,
                            pObjectInfo->Info.MediaType.NumberOfSides,
                            pObjectInfo->Info.MediaType.ReadWriteCharacteristics,
                            pObjectInfo->szName,
                            pObjectInfo->szDescription );
            break;

        case NTMS_PARTITION:
            WsbTrace(OLESTR("Partion Information:\n") );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  PhysicalMedia..  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Partition.PhysicalMedia));
            WsbTrace(OLESTR("  LogicalMedia...  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Partition.LogicalMedia));
            WsbTrace(OLESTR("  State..........  %-d\n"), pObjectInfo->Info.Partition.State);
            WsbTrace(OLESTR("  Side...........  %-d\n"), pObjectInfo->Info.Partition.Side);
            WsbTrace(OLESTR("  OmidLabelIdLen   %-d\n"), pObjectInfo->Info.Partition.dwOmidLabelIdLength);
            WsbTrace(OLESTR("  OmidLableId:\n"));
            WsbTraceBuffer(pObjectInfo->Info.Partition.dwOmidLabelIdLength, pObjectInfo->Info.Partition.OmidLabelId);
            WsbTrace(OLESTR("  OmidLabelType..  %-ls\n"), pObjectInfo->Info.Partition.szOmidLabelType);
            WsbTrace(OLESTR("  OmidLabelInfo..  %-ls\n"), pObjectInfo->Info.Partition.szOmidLabelInfo);
            WsbTrace(OLESTR("  MountCount.....  %-d\n"), pObjectInfo->Info.Partition.dwMountCount);
            WsbTrace(OLESTR("  AllocateCount..  %-d\n"), pObjectInfo->Info.Partition.dwAllocateCount);
            WsbTrace(OLESTR("  Capacity.......  %-I64d\n"), pObjectInfo->Info.Partition.Capacity.QuadPart);
            break;

        case NTMS_PHYSICAL_MEDIA:
        case NTMS_STORAGESLOT:
        case NTMS_OPREQUEST:
        default:
            break;
        }

    } WsbCatch(hr);

    return hr;
}


HRESULT
CRmsNTMS::getNtmsSupportFromRegistry(
    OUT DWORD *pNTMSSupportValue)
/*++

Routine Description:

    Determines if NTMS flag is set in the Registry.

Arguments:

    pNTMSSupportValue   - Receives the actual value of the regstry key value.  Any non-zero
                          values indicates NTMS support.

Return Values:

    S_OK                - NTMS support flag is on.
    S_FALSE             - NTMS support flag is off.

--*/
{
    HRESULT hr = S_OK;
    DWORD val = RMS_DEFAULT_NTMS_SUPPORT;

    WsbTraceIn(OLESTR("CRmsNTMS::getNtmsSupportFromRegistry"), OLESTR(""));

    try {
        DWORD   sizeGot;
        const int cDataSizeToGet = 100;
        OLECHAR dataString[cDataSizeToGet];
        OLECHAR *stopString;

        //
        // Get the value.  If the key doesn't exists, the default value is used.
        //

        try {

            WsbAffirmHrOk(WsbEnsureRegistryKeyExists(NULL, RMS_REGISTRY_STRING));
            WsbAffirmHrOk(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_NTMS_SUPPORT,
                dataString, cDataSizeToGet, &sizeGot));
            val = wcstoul(dataString,  &stopString, 10);

        } WsbCatch(hr);

        if (pNTMSSupportValue != NULL) {
            *pNTMSSupportValue = val;
        }

        hr = (val) ? S_OK : S_FALSE;

    } WsbCatchAndDo( hr,
            hr = S_FALSE;
        );


    WsbTraceOut(OLESTR("CRmsNTMS::getNtmsSupportFromRegistry"), OLESTR("hr = <%ls>, val = <%ld>"), WsbHrAsString(hr), val);

    return hr;
}


HRESULT 
CRmsNTMS::beginSession(void)
/*++

Implements:

    CRmsNTMS::beginSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( OLESTR("CRmsNTMS::beginSession"), OLESTR("") );

    try {

        WsbAffirmHrOk(IsInstalled());
        WsbAffirmHrOk(endSession());        // clear the old session
        WsbAffirmHrOk(waitUntilReady());    // starts a new session
        //WsbAffirmHrOk(waitForScratchPool());

    } WsbCatch(hr);


    WsbTraceOut( OLESTR("CRmsNTMS::beginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT 
CRmsNTMS::endSession(void)
/*++

Implements:

    CRmsNTMS::endSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( OLESTR("CRmsNTMS::endSession"), OLESTR("") );

    try {

        if ( m_SessionHandle != INVALID_HANDLE_VALUE ) {
            // NTMS - Close session
            WsbTraceAlways(OLESTR("CloseNtmsSession()\n"));
            WsbAffirmNoError(CloseNtmsSession(m_SessionHandle));
        }

    } WsbCatchAndDo(hr,
            switch (HRESULT_CODE(hr)) {
            case ERROR_CONNECTION_UNAVAIL:
            case ERROR_INVALID_HANDLE:
                break;
            default:
                WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                    OLESTR("CloseNtmsSession"), OLESTR("Undocumented Error: "),
                    WsbHrAsString(hr), NULL);
                break;
            }
        );

    m_SessionHandle = INVALID_HANDLE_VALUE;
    hr = S_OK;

    WsbTraceOut( OLESTR("CRmsNTMS::endSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT
CRmsNTMS::waitUntilReady(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::waitUntilReady"), OLESTR(""));

    try {

        int retry = 360; // number of retries

        // Retrieve the NotificationWaitTime parameter
        DWORD size;
        OLECHAR tmpString[256];
        DWORD notificationWaitTime = RMS_DEFAULT_NOTIFICATION_WAIT_TIME;
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_NOTIFICATION_WAIT_TIME, tmpString, 256, &size))) {
            notificationWaitTime = wcstol(tmpString, NULL, 10);
            WsbTrace(OLESTR("NotificationWaitTime is %d milliseconds.\n"), notificationWaitTime);
        }


        do {
            // NTMS - Open session
            WsbTraceAlways(OLESTR("OpenNtmsSession()\n"));

            CWsbStringPtr appName;
            WsbAffirmHr(appName.LoadFromRsc(_Module.m_hInst, IDS_PRODUCT_NAME));

            m_SessionHandle = OpenNtmsSession(NULL, (WCHAR *) appName, 0);
            if ( m_SessionHandle != INVALID_HANDLE_VALUE ) {
                break;
            }
            else {
                hr = HRESULT_FROM_WIN32(GetLastError());
                switch (HRESULT_CODE(hr)) {
                case ERROR_NOT_READY:
                    if ( retry > 0 ) {
                        WsbTrace(OLESTR("Waiting for NTMS to come ready - Seconds remaining before timeout: %d\n"), retry*notificationWaitTime/1000);
                        Sleep(notificationWaitTime);
                        hr = S_OK;
                    }
                    else {
                        //
                        // This is the last try, so log the failure.
                        //
                        WsbLogEvent(RMS_MESSAGE_NTMS_CONNECTION_NOT_ESABLISHED,
                            0, NULL, WsbHrAsString(hr), NULL);
                        WsbThrow(RMS_E_NTMS_NOT_CONNECTED);
                    }
                    break;

                case ERROR_INVALID_COMPUTERNAME:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NO_NETWORK:
                case ERROR_NOT_CONNECTED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_CONNECTION_NOT_ESABLISHED,
                        0, NULL, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("OpenNtmsSession"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                    break;
                }
            }
        } while( retry-- > 0 ) ;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::waitUntilReady"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsNTMS::waitForScratchPool(void)
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;
    DWORD err3 = NO_ERROR;
    HANDLE hNotify = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("CRmsNTMS::waitForScratchPool"), OLESTR(""));

    try {

        int retry = 60; // number of retries

        // Retrieve the NotificationWaitTime parameter
        DWORD size;
        OLECHAR tmpString[256];
        DWORD notificationWaitTime = RMS_DEFAULT_NOTIFICATION_WAIT_TIME;
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_NOTIFICATION_WAIT_TIME, tmpString, 256, &size))) {
            notificationWaitTime = wcstol(tmpString, NULL, 10);
            WsbTrace(OLESTR("NotificationWaitTime is %d milliseconds.\n"), notificationWaitTime);
        }

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbThrow(E_UNEXPECTED);
        }

        HANDLE hSession = m_SessionHandle;

        NTMS_OBJECTINFORMATION objectInfo;
        NTMS_OBJECTINFORMATION scratchInfo;
        NTMS_NOTIFICATIONINFORMATION notifyInfo;
        HANDLE hFind = NULL;

        BOOL bFound = FALSE;

        // TODO: We really should wait around until all libraries are classified.
        DWORD mediaCount = 0;

        hr = findFirstNtmsObject( NTMS_LIBRARY, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            mediaCount += objectInfo.Info.Library.dwNumberOfMedia;
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        if ( 0 == mediaCount) {
            WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
        }

        /*
        // First see if there is any media to be classified, if not we don't bother waiting around for
        // nothing to happen.
        hr = findFirstNtmsObject( NTMS_PHYSICAL_MEDIA, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        WsbAffirmHrOk( hr );
        findCloseNtmsObject( hFind );
        */

        // NTMS - Open notification channel
        WsbTraceAlways(OLESTR("OpenNtmsNotification()\n"));
        hNotify = OpenNtmsNotification(hSession, NTMS_MEDIA_POOL);
        if ( INVALID_HANDLE_VALUE == hNotify ) {
            err1 = GetLastError();
            WsbAffirmNoError(err1);
            WsbThrow(E_UNEXPECTED);
        }

        do {
            err2 = NO_ERROR;
            //
            // Count the number of NTMS Scratch pools, and if
            // there are more than one, we return.  If not,
            // we wait until the root level scratch pool object
            // is updated.
            //
            // More that one scratch media pools implies that at
            // least one unit of media was classified.  We don't
            // know until we complete the initialization if it
            // was one of the media types supported by RemoteStorage.
            //
            int count = 0;

            hr = findFirstNtmsObject( NTMS_MEDIA_POOL, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
            while( S_OK == hr ) {
                if ( NTMS_POOLTYPE_SCRATCH == objectInfo.Info.MediaPool.PoolType ) {
                    count++;
                    if ( count == 1 ) {
                        // Assueme this is the rool pool and one we'll check on for updates
                        // If the assumption is wrong count will end up > 1.
                        memcpy(&scratchInfo, &objectInfo, sizeof(NTMS_OBJECTINFORMATION));
                    }
                }
                hr = findNextNtmsObject( hFind, &objectInfo );
            }
            findCloseNtmsObject( hFind );

            if ( count > 1 ) {
                bFound = TRUE;
                hr = S_OK;
                break; // Normal exit.
            }

            if ( count == 0 ) {
                WsbThrow(E_UNEXPECTED);
            }

            // Just one scratch pool detected... wait until a media-type specific pool
            // is added root scratch pool.  This will show up as an update to the root
            // scratch pool.

            do {

                WsbTrace(OLESTR("Waiting for NTMS scratch pool - Seconds remaining before timeout: %d\n"), retry*notificationWaitTime/1000);

                // NTMS - Wait for notification
                WsbTraceAlways(OLESTR("WaitForNtmsNotification()\n"));
                err2 = WaitForNtmsNotification(hNotify, &notifyInfo, notificationWaitTime);
                if ( NO_ERROR == err2 ) {
                    //
                    // Note: With this notification mechanism, chances
                    //       are slim that we got notified on the object we really
                    //       care about.
                    //
                    WsbTrace(OLESTR("Processing: <%d> %ls\n"), notifyInfo.dwOperation, WsbGuidAsString(notifyInfo.ObjectId));
                    if ( notifyInfo.ObjectId != scratchInfo.ObjectGuid ) {
                        WsbTrace(OLESTR("Wrong object, try again...\n"));
                        continue; // skip this one
                    }
                    else {
                        if ( NTMS_OBJ_UPDATE != notifyInfo.dwOperation ) {
                            WsbTrace(OLESTR("Wrong operation, try again...\n"));
                            continue; // skip this one
                        }
                        else {
                            WsbTrace(OLESTR("Scratch pool update detected.\n"));
                            break;  // A scratch pool may have inserted, go check it out...
                        }
                    }
                }
                else if ( ERROR_TIMEOUT != err2 && ERROR_NO_DATA != err2 ) {
                    WsbAffirmNoError(err2);
                }
                retry--;
            } while( (retry > 0) && (!bFound) );
        } while( (retry > 0) && (!bFound) );

        // NTMS - Close notification channel
        WsbTraceAlways(OLESTR("CloseNtmsNotification()\n"));
        err3 = CloseNtmsNotification(hNotify);
        WsbAffirmNoError(err3);

        if ( !bFound ) {
            hr = RMS_E_RESOURCE_UNAVAILABLE;
        }

    } WsbCatchAndDo(hr,

            if ( hNotify != INVALID_HANDLE_VALUE ) {
                // NTMS - Close notification channel
                WsbTraceAlways(OLESTR("CloseNtmsNotification()\n"));
                err3 = CloseNtmsNotification(hNotify);
            }

            if (err1 != NO_ERROR) {
                // OpenNtmsNotification
                switch (HRESULT_CODE(hr)) {
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("OpenNtmsNotification"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("OpenNtmsNotification"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            if (err2 != NO_ERROR) {
                // WaitForNtmsNotification
                switch (HRESULT_CODE(hr)) {
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_TIMEOUT:
                case ERROR_NO_DATA:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("WaitForNtmsNotification"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("WaitForNtmsNotification"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            if (err3 != NO_ERROR) {
                // CloseNtmsNotification
                switch (HRESULT_CODE(hr)) {
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                case ERROR_DATABASE_FAILURE:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("CloseNtmsNotification"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("CloseNtmsNotification"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::waitForScratchPool"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsNTMS::storageMediaTypeToRmsMedia(
    IN NTMS_MEDIATYPEINFORMATION *pMediaTypeInfo,
    OUT RmsMedia *pTranslatedMediaType)
{
    HRESULT hr = S_OK;

    DWORD size;
    OLECHAR tmpString[256];

    // Media type is the main criteria
    WsbAssertPointer(pMediaTypeInfo);
    STORAGE_MEDIA_TYPE mediaType = (STORAGE_MEDIA_TYPE)(pMediaTypeInfo->MediaType);

    DWORD tapeEnabled = RMS_DEFAULT_TAPE;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_TAPE, tmpString, 256, &size))) {
        // Get the value.
        tapeEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD opticalEnabled = RMS_DEFAULT_OPTICAL;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_OPTICAL, tmpString, 256, &size))) {
        // Get the value.
        opticalEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD dvdEnabled = RMS_DEFAULT_DVD;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_DVD, tmpString, 256, &size))) {
        // Get the value.
        dvdEnabled = wcstol(tmpString, NULL, 10);
    }

    switch ( mediaType ) {

    case DDS_4mm:                   // Tape - DAT DDS1,2,... (all vendors) (0x20)
        *pTranslatedMediaType = (tapeEnabled) ? RmsMedia4mm : RmsMediaUnknown; 
        break;

    case MiniQic:                   // Tape - miniQIC Tape
    case Travan:                    // Tape - Travan TR-1,2,3,...
    case QIC:                       // Tape - QIC
        *pTranslatedMediaType = RmsMediaUnknown;
        break;

    case MP_8mm:                    // Tape - 8mm Exabyte Metal Particle
    case AME_8mm:                   // Tape - 8mm Exabyte Advanced Metal Evap
    case AIT1_8mm:                  // Tape - 8mm Sony AIT1
        *pTranslatedMediaType = (tapeEnabled) ? RmsMedia8mm : RmsMediaUnknown; 
        break;

    case DLT:                       // Tape - DLT Compact IIIxt: IV
        *pTranslatedMediaType = (tapeEnabled) ? RmsMediaDLT : RmsMediaUnknown; 
        break;

    case NCTP:                      // Tape - Philips NCTP
    case IBM_3480:                  // Tape - IBM 3480
    case IBM_3490E:                 // Tape - IBM 3490E
    case IBM_Magstar_3590:          // Tape - IBM Magstar 3590
    case IBM_Magstar_MP:            // Tape - IBM Magstar MP
    case STK_DATA_D3:               // Tape - STK Data D3
    case SONY_DTF:                  // Tape - Sony DTF
    case DV_6mm:                    // Tape - 6mm Digital Video
    case DMI:                       // Tape - Exabyte DMI and compatibles
    case SONY_D2:                   // Tape - Sony D2S and D2L
    case CLEANER_CARTRIDGE:         // Cleaner - All Drive types that support Drive Cleaners
    case CD_ROM:                    // Opt_Disk - CD
    case CD_R:                      // Opt_Disk - CD-Recordable (Write Once)
    case CD_RW:                     // Opt_Disk - CD-Rewriteable
    case DVD_ROM:                   // Opt_Disk - DVD-ROM
    case DVD_R:                     // Opt_Disk - DVD-Recordable (Write Once)
    case MO_5_WO:                   // Opt_Disk - MO 5.25" Write Once
        *pTranslatedMediaType = RmsMediaUnknown;
        break;

    case DVD_RW:                    // Opt_Disk - DVD-Rewriteable
        *pTranslatedMediaType = (dvdEnabled) ? RmsMediaDVD : RmsMediaUnknown;
        break;

    case MO_5_RW:                   // Opt_Disk - MO 5.25" Rewriteable (not LIMDOW)
    case MO_3_RW:                   // Opt_Disk - 3.5" Rewriteable MO Disk
    case MO_5_LIMDOW:               // Opt_Disk - MO 5.25" Rewriteable (LIMDOW)
    case PC_5_RW:                   // Opt_Disk - Phase Change 5.25" Rewriteable
    case PD_5_RW:                   // Opt_Disk - PhaseChange Dual Rewriteable
    case PINNACLE_APEX_5_RW:        // Opt_Disk - Pinnacle Apex 4.6GB Rewriteable Optical
    case NIKON_12_RW:               // Opt_Disk - Nikon 12" Rewriteable
        *pTranslatedMediaType = (opticalEnabled) ? RmsMediaOptical : RmsMediaUnknown; 
        break;

    case PC_5_WO:                   // Opt_Disk - Phase Change 5.25" Write Once Optical
    case ABL_5_WO:                  // Opt_Disk - Ablative 5.25" Write Once Optical
        *pTranslatedMediaType = RmsMediaUnknown;
        break;

    case SONY_12_WO:                // Opt_Disk - Sony 12" Write Once
    case PHILIPS_12_WO:             // Opt_Disk - Philips/LMS 12" Write Once
    case HITACHI_12_WO:             // Opt_Disk - Hitachi 12" Write Once
    case CYGNET_12_WO:              // Opt_Disk - Cygnet/ATG 12" Write Once
    case KODAK_14_WO:               // Opt_Disk - Kodak 14" Write Once
    case MO_NFR_525:                // Opt_Disk - Near Field Recording (Terastor)
    case IOMEGA_ZIP:                // Mag_Disk - Iomega Zip
    case IOMEGA_JAZ:                // Mag_Disk - Iomega Jaz
    case SYQUEST_EZ135:             // Mag_Disk - Syquest EZ135
    case SYQUEST_EZFLYER:           // Mag_Disk - Syquest EzFlyer
    case SYQUEST_SYJET:             // Mag_Disk - Syquest SyJet
    case AVATAR_F2:                 // Mag_Disk - 2.5" Floppy
        *pTranslatedMediaType = RmsMediaUnknown;
        break;

    case RemovableMedia:    // This is reported on stand-alone optical drives.
    default:
        // Check RSM characteristics for Rewriteable Disk
        if ((pMediaTypeInfo->ReadWriteCharacteristics == NTMS_MEDIARW_REWRITABLE) &&
            (pMediaTypeInfo->DeviceType == FILE_DEVICE_DISK)) {
            *pTranslatedMediaType = (opticalEnabled) ? RmsMediaOptical : RmsMediaUnknown; 
        } else  {
            // Not a rewritable disk and not one of the supported tape types...
            *pTranslatedMediaType = RmsMediaUnknown;
        }
        break;
    }

    if ((*pTranslatedMediaType == RmsMediaUnknown) &&
        (pMediaTypeInfo->DeviceType == FILE_DEVICE_TAPE)) {
        // Check in the Registry whether there are additional tapes that we need to support
        ULONG *pTypes= NULL;
        ULONG uTypes = 0;

        if (SUCCEEDED(WsbGetRegistryValueUlongAsMultiString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_ADDITIONAL_TAPE, &pTypes, &uTypes))) {
            // Compare Registry types to the media type we have
            for (ULONG u=0; u<uTypes; u++) {
                if ((STORAGE_MEDIA_TYPE)(pTypes[u]) == mediaType) {
                    // Support it !!
                    WsbTraceAlways(OLESTR("CRmsNTMS::storageMediaTypeToRmsMedia: Registry asks to support tape type %lu\n"),
                                pTypes[u]);

                    *pTranslatedMediaType = RmsMediaTape;

                    break;
                }
            }
        }

        if (pTypes != NULL) {
            WsbFree(pTypes);
            pTypes = NULL;
        }
    }

    return hr;
}


HRESULT
CRmsNTMS::createMediaPools(void)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsNTMS::createMediaPools"), OLESTR(""));

    try {

        HANDLE hSession;
        NTMS_GUID rootPoolId = GUID_NULL;

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        hSession = m_SessionHandle;

        try {

            // NTMS - Create Application Media Pool.
            WsbTraceAlways(OLESTR("CreateNtmsMediaPool()\n"));

            WsbAffirmNoError(CreateNtmsMediaPool(hSession, REMOTE_STORAGE_APP_NAME, NULL, NTMS_OPEN_ALWAYS, NULL, &rootPoolId));

            // Now  set access permissions on the pool: turn off ordinary users access
            WsbAffirmHrOk(setPoolDACL(&rootPoolId, DOMAIN_ALIAS_RID_USERS, REMOVE_ACE_MASK_BITS,NTMS_USE_ACCESS | NTMS_MODIFY_ACCESS | NTMS_CONTROL_ACCESS));

        } WsbCatchAndDo(hr,
                switch(HRESULT_CODE(hr)) {
                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_NAME:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_ALREADY_EXISTS:
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                    WsbLogEvent( RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("CreateNtmsMediaPool"), OLESTR(""),
                        WsbHrAsString(hr),
                        NULL );
                    break;
                default:
                    WsbLogEvent( RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("CreateNtmsMediaPool"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr),
                        NULL );
                    break;
                }
                WsbThrow(hr);
            );

        //
        // Only one of the following should be executed, comment out the other.
        //
        WsbAffirmHr( createMediaPoolForEveryMediaType(rootPoolId) );    // New way                        
        /*
        WsbAffirmHr( replicateScratchMediaPool(rootPoolId) );           // Old way
        */

    } WsbCatch(hr);


    WsbTraceOut( OLESTR("CRmsNTMS::createMediaPools"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}



HRESULT
CRmsNTMS::replicateScratchMediaPool(
    IN REFGUID /*rootPoolId*/)
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsNTMS::replicateScratchMediaPool"), OLESTR(""));

    try {

        HANDLE                  hSession;
        DWORD                   errCode;
        NTMS_OBJECTINFORMATION  mediaTypeInfo;
        NTMS_OBJECTINFORMATION  mediaPoolInfo;
        HANDLE                  hFind = NULL;
        NTMS_GUID               poolId = GUID_NULL;


        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        hSession = m_SessionHandle;

        // For each media pool in the scratch pool create an application specific pool.

        hr = findFirstNtmsObject( NTMS_MEDIA_POOL, GUID_NULL, NULL, GUID_NULL, &hFind, &mediaPoolInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &mediaPoolInfo );
            poolId = GUID_NULL;

            try {

                //  Set up application specific NTMS Media Pools.  One for each compatible type.
                //
                //  To get here we had to already detect a media-type specific scratch pool
                //  in waitForScratchPool()

                if ( NTMS_POOLTYPE_SCRATCH == mediaPoolInfo.Info.MediaPool.PoolType &&
                     0 == mediaPoolInfo.Info.MediaPool.dwNumberOfMediaPools ) {

                    // This is a base level scratch media pool.
                    // Create a similar pool for application specific use.

                    CWsbStringPtr name = REMOTE_STORAGE_APP_NAME;
                    name.Append( OLESTR("\\") );
                    name.Append( mediaPoolInfo.szName );

                    NTMS_GUID mediaTypeId = mediaPoolInfo.Info.MediaPool.MediaType;

                    // We need more information about the media type.

                    memset( &mediaTypeInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                    mediaTypeInfo.dwType = NTMS_MEDIA_TYPE;
                    mediaTypeInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                    // NTMS - Get Media Pool Information
                    WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                    errCode = GetNtmsObjectInformation( hSession, &mediaTypeId, &mediaTypeInfo );
                    if ( errCode != NO_ERROR ) {

                        WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                            OLESTR("GetNtmsObjectInformation"),
                            WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                            NULL );

                        WsbThrow( E_UNEXPECTED );

                    }

                    // Translate the NTMS media type into something understood by RMS
                    RmsMedia translatedMediaType;
                    storageMediaTypeToRmsMedia(&(mediaTypeInfo.Info.MediaType), &translatedMediaType);

                    if ( translatedMediaType != RmsMediaUnknown ) {

                        // This something that Remote Storage can deal with

                        CWsbBstrPtr mediaSetName = RMS_UNDEFINED_STRING;
                        CWsbBstrPtr mediaSetDesc = RMS_UNDEFINED_STRING;
                        BOOL mediaSetIsEnabled = FALSE;

                        // NTMS - Create Application Media Pool.
                        WsbTraceAlways(OLESTR("CreateNtmsMediaPool()\n"));
                        errCode = CreateNtmsMediaPool( hSession, (WCHAR *) name, &mediaTypeId, NTMS_CREATE_NEW, NULL, &poolId );

                        if ( ERROR_ALREADY_EXISTS == errCode ) {

                            // We still need the poolId of the existing pool.

                            // NTMS - Create Application Media Pool.
                            WsbTraceAlways(OLESTR("CreateNtmsMediaPool()\n"));
                            errCode = CreateNtmsMediaPool( hSession, (WCHAR *)name, &mediaTypeId, NTMS_OPEN_EXISTING, NULL, &poolId );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("CreateNtmsMediaPool"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            NTMS_OBJECTINFORMATION mediaPoolInfo;

                            memset( &mediaPoolInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                            mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                            mediaPoolInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                            // NTMS - Get Media Pool Information
                            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                            errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("GetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );
                            }

                            // Save relevant info
                            mediaSetName = mediaPoolInfo.szName;
                            mediaSetDesc = mediaPoolInfo.szDescription;
                            mediaSetIsEnabled = mediaPoolInfo.Enabled;

                        }
                        else if ( NO_ERROR == errCode ) {

                            memset( &mediaPoolInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                            mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                            mediaPoolInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                            // NTMS - Get Media Pool Information
                            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                            errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("GetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            WsbAssert( NTMS_POOLTYPE_APPLICATION == mediaPoolInfo.Info.MediaPool.PoolType, E_UNEXPECTED );

                            // Set media pool parameters

                            // Aallocation/deallocation policy
                            mediaPoolInfo.Info.MediaPool.AllocationPolicy = NTMS_ALLOCATE_FROMSCRATCH;
                            mediaPoolInfo.Info.MediaPool.DeallocationPolicy = 0;

                            // Max number of allocates per media
                            mediaPoolInfo.Info.MediaPool.dwMaxAllocates = 5;// Just a few... we automatically
                                                                            //   deallocate media if there's
                                                                            //   problem with scratch mount
                                                                            //   operation.
                                                                            // NOTE:  This can be overridden using
                                                                            //   the NTMS GUI.

                            // NTMS - Set Media Pool Information.
                            WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                            errCode = SetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("SetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            // Save relevant info
                            mediaSetName = mediaPoolInfo.szName;
                            mediaSetDesc = mediaPoolInfo.szDescription;
                            mediaSetIsEnabled = mediaPoolInfo.Enabled;

                        }
                        else {

                            WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                OLESTR("CreateNtmsMediaPool"),
                                WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                NULL );

                            WsbThrow( E_UNEXPECTED );

                        }

                        // Now we have an NTMS media pool for our specific use.  Now expose it
                        // through the RMS interface by creating a CRmsMediaSet.

                        if ( poolId != GUID_NULL ) {
                            CComPtr<IRmsMediaSet> pMediaSet;

                            // Find the RmsMediaSet with the same id, or create a new one.
                            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                            WsbAffirmHr( pServer->CreateObject( poolId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenAlways, (void **)&pMediaSet ) );

                            WsbTrace(OLESTR("CRmsNTMS::replicateScratchMediaPool - type %d CRmsMediaSet created.\n"), translatedMediaType);

                            WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetNTMS ) );
                            WsbAffirmHr( pMediaSet->SetMediaSupported( translatedMediaType ) );

                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pMediaSet;
                            WsbTrace(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType - MediaSet: <%ls/%ls>; Enabled: %ls\n"),
                                WsbQuickString(WsbStringAsString(mediaSetName)),
                                WsbQuickString(WsbStringAsString(mediaSetDesc)),
                                WsbQuickString(WsbBoolAsString(mediaSetIsEnabled)));
                            WsbAffirmHr(pObject->SetName(mediaSetName));
                            WsbAffirmHr(pObject->SetDescription(mediaSetDesc));
                            if (!mediaSetIsEnabled) {
                                WsbAffirmHr(pObject->Disable(E_FAIL));
                            }

                            if (S_OK == IsMediaCopySupported(poolId)) {
                                WsbAffirmHr( pMediaSet->SetIsMediaCopySupported(TRUE));
                            }
                            hr = pMediaSet->IsMediaCopySupported();

                            WsbTrace(OLESTR("CRmsNTMS::replicateScratchMediaPool - media copies are %ls.\n"),
                                (S_OK == pMediaSet->IsMediaCopySupported()) ? OLESTR("enabled") : OLESTR("disabled"));

                        }
                    }
                }

            } WsbCatch(hr);

            hr = findNextNtmsObject( hFind, &mediaPoolInfo );
        } // while finding media pools
        findCloseNtmsObject( hFind );

        hr = S_OK;

    } WsbCatch(hr);


    WsbTraceOut( OLESTR("CRmsNTMS::replicateScratchMediaPool"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT
CRmsNTMS::createMediaPoolForEveryMediaType(
    IN REFGUID /*rootPoolId*/)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType"), OLESTR(""));

    try {
        DWORD errCode;

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        HANDLE hSession = m_SessionHandle;

        HANDLE hFindLib = NULL;
        NTMS_OBJECTINFORMATION libraryInfo;

        BOOL bSupportedLib = FALSE;
        m_dwNofLibs = 0;

        hr = findFirstNtmsObject( NTMS_LIBRARY, GUID_NULL, NULL, GUID_NULL, &hFindLib, &libraryInfo);
        while( S_OK == hr ) {
            bSupportedLib = FALSE;

            reportNtmsObjectInformation( &libraryInfo );

            if (libraryInfo.Info.Library.dwNumberOfMediaTypes > 0) {

                HANDLE hFindType = NULL;
                NTMS_OBJECTINFORMATION mediaTypeInfo;

                hr = findFirstNtmsObject( NTMS_MEDIA_TYPE, libraryInfo.ObjectGuid, NULL, GUID_NULL, &hFindType, &mediaTypeInfo);
                while( S_OK == hr ) {
                    //
                    // Create an application Media Pool for each type
                    //

                    NTMS_GUID poolId;

                    // This is a base level scratch media pool.
                    // Create a similar pool for application specific use.

                    CWsbStringPtr name = REMOTE_STORAGE_APP_NAME;
                    name.Append( OLESTR("\\") );
                    name.Append( mediaTypeInfo.szName );

                    NTMS_GUID mediaTypeId = mediaTypeInfo.ObjectGuid;

                    // Translate the NTMS media type into something understood by RMS
                    RmsMedia translatedMediaType;
                    storageMediaTypeToRmsMedia(&(mediaTypeInfo.Info.MediaType), &translatedMediaType);

                    if ( translatedMediaType != RmsMediaUnknown ) {

                        // This something that Remote Storage can deal with

                        CWsbBstrPtr mediaSetName = RMS_UNDEFINED_STRING;
                        CWsbBstrPtr mediaSetDesc = RMS_UNDEFINED_STRING;
                        BOOL mediaSetIsEnabled = FALSE;

                        // NTMS - Create Application Media Pool.
                        WsbTraceAlways(OLESTR("CreateNtmsMediaPool(<%ls>) - Try New.\n"), (WCHAR *) name);
                        errCode = CreateNtmsMediaPool( hSession, (WCHAR *) name, &mediaTypeId, NTMS_CREATE_NEW, NULL, &poolId );

                        if ( ERROR_ALREADY_EXISTS == errCode ) {
                            WsbTraceAlways(OLESTR("MediaPool <%ls> already exists.\n"), (WCHAR *) name);

                            // We still need the poolId of the existing pool.

                            // NTMS - Create Application Media Pool.
                            WsbTraceAlways(OLESTR("CreateNtmsMediaPool(<%ls>) - Try Existing.\n"), (WCHAR *) name);
                            errCode = CreateNtmsMediaPool( hSession, (WCHAR *)name, &mediaTypeId, NTMS_OPEN_EXISTING, NULL, &poolId );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("CreateNtmsMediaPool"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            WsbTraceAlways(OLESTR("Media Pool %ls detected.\n"), WsbGuidAsString(poolId));

                            NTMS_OBJECTINFORMATION mediaPoolInfo;

                            memset( &mediaPoolInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                            mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                            mediaPoolInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                            // NTMS - Get Media Pool Information
                            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                            errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("GetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            // Save relevant info
                            mediaSetName = mediaPoolInfo.szName;
                            mediaSetDesc = mediaPoolInfo.szDescription;
                            mediaSetIsEnabled = mediaPoolInfo.Enabled;

                        }
                        else if ( NO_ERROR == errCode ) {
                            WsbTraceAlways(OLESTR("MediaPool <%ls> created.\n"), (WCHAR *) name);

                            NTMS_OBJECTINFORMATION mediaPoolInfo;

                            memset( &mediaPoolInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

                            mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                            mediaPoolInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

                            // NTMS - Get Media Pool Information
                            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
                            errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("GetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            WsbAssert( NTMS_POOLTYPE_APPLICATION == mediaPoolInfo.Info.MediaPool.PoolType, E_UNEXPECTED );

                            // Set media pool parameters

                            // Aallocation/deallocation policy
                            mediaPoolInfo.Info.MediaPool.AllocationPolicy = NTMS_ALLOCATE_FROMSCRATCH;
                            mediaPoolInfo.Info.MediaPool.DeallocationPolicy = 0;

                            // Max number of allocates per media
                            mediaPoolInfo.Info.MediaPool.dwMaxAllocates = 0;// Unlimited... we automatically
                                                                            //   deallocate media if there's
                                                                            //   problem with scratch mount
                                                                            //   operation.
                                                                            // TODO:  Verify that NTMS always allocates
                                                                            //        media with the lowest allocation
                                                                            //        count.
                                                                            // NOTE:  This can be overridden using
                                                                            //        the NTMS GUI.

                            // NTMS - Set Media Pool Information.
                            WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                            errCode = SetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
                            if ( errCode != NO_ERROR ) {

                                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                    OLESTR("SetNtmsObjectInformation"),
                                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                    NULL );

                                WsbThrow( E_UNEXPECTED );

                            }

                            // Save relevant info
                            mediaSetName = mediaPoolInfo.szName;
                            mediaSetDesc = mediaPoolInfo.szDescription;
                            mediaSetIsEnabled = mediaPoolInfo.Enabled;
                        }
                        else {

                            WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                                OLESTR("CreateNtmsMediaPool"),
                                WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                                NULL );

                            WsbThrow( E_UNEXPECTED );

                        }

                        // Now  set access permissions on the pool: turn off ordinary users access
                        WsbAffirmHrOk(setPoolDACL(&poolId, DOMAIN_ALIAS_RID_USERS, REMOVE_ACE_MASK_BITS,NTMS_USE_ACCESS | NTMS_MODIFY_ACCESS | NTMS_CONTROL_ACCESS));


                        // Now we have an NTMS media pool for our specific use.  Now expose it
                        // through the RMS interface by creating a CRmsMediaSet.

                        if ( poolId != GUID_NULL ) {

                            //
                            // Add to CRmsMediaSet collection
                            //

                            CComPtr<IRmsMediaSet> pMediaSet;

                            // Find the CRmsMediaSet with the same id, or create a new one.
                            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                            WsbAffirmHr( pServer->CreateObject( poolId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenAlways, (void **)&pMediaSet ) );

                            WsbTrace(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType - type %d CRmsMediaSet established.\n"), translatedMediaType);

                            WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetNTMS ) );
                            WsbAffirmHr( pMediaSet->SetMediaSupported( translatedMediaType ) );

                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pMediaSet;
                            WsbTrace(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType - MediaSet: <%ls/%ls> %ls; Enabled: %ls\n"),
                                WsbQuickString(WsbStringAsString(mediaSetName)),
                                WsbQuickString(WsbStringAsString(mediaSetDesc)),
                                WsbQuickString(WsbGuidAsString(poolId)),
                                WsbQuickString(WsbBoolAsString(mediaSetIsEnabled)));
                            WsbAffirmHr(pObject->SetName(mediaSetName));
                            WsbAffirmHr(pObject->SetDescription(mediaSetDesc));
                            if (!mediaSetIsEnabled) {
                                WsbAffirmHr(pObject->Disable(E_FAIL));
                            }

                            if (S_OK == IsMediaCopySupported(poolId)) {
                                WsbAffirmHr( pMediaSet->SetIsMediaCopySupported(TRUE));
                            }
                            hr = pMediaSet->IsMediaCopySupported();

                            WsbTrace(OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType - media copies are %ls.\n"),
                                (S_OK == pMediaSet->IsMediaCopySupported()) ? OLESTR("enabled") : OLESTR("disabled"));

                        }

                        // The library has a supported media type
                        bSupportedLib = TRUE;
                     }
                    hr = findNextNtmsObject( hFindType, &mediaTypeInfo );
                }
                findCloseNtmsObject( hFindType );
            }

            // Check if the library has supported media type
            if (bSupportedLib) {
                // Add library GUI to the libraries list
                //  (Realloc one item each time since we don't expect many items)
                m_dwNofLibs++;
                LPVOID pTemp = WsbRealloc(m_pLibGuids, m_dwNofLibs*sizeof(NTMS_GUID));
                if (!pTemp) {
                    WsbThrow(E_OUTOFMEMORY);
                }
                m_pLibGuids = (LPNTMS_GUID)pTemp;
                m_pLibGuids[m_dwNofLibs-1] = libraryInfo.ObjectGuid;
            }
            
            // Continue library enumeration
            hr = findNextNtmsObject( hFindLib, &libraryInfo );
        }
        findCloseNtmsObject( hFindLib );

        hr = S_OK;

    } WsbCatch(hr);


    WsbTraceOut( OLESTR("CRmsNTMS::createMediaPoolForEveryMediaType"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}



STDMETHODIMP 
CRmsNTMS::Allocate(
    IN REFGUID fromMediaSet,
    IN REFGUID prevSideId,
    IN OUT LONGLONG *pFreeSpace,
    IN BSTR displayName,
    IN DWORD dwOptions,
    OUT IRmsCartridge **ppCartridge)
/*++

Implements:

    IRmsNTMS::Allocate

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;
    DWORD err3 = NO_ERROR;
    DWORD err4 = NO_ERROR;
    DWORD err5 = NO_ERROR;
    DWORD err6 = NO_ERROR;
    DWORD err7 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::Allocate"), OLESTR("<%ls> <%ls> <%ls> <%ls> <0x%08x"),
        WsbGuidAsString(fromMediaSet), WsbGuidAsString(prevSideId), 
        WsbPtrToLonglongAsString(pFreeSpace), WsbStringAsString(displayName), dwOptions);

    try {
        WsbAssert(fromMediaSet != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(ppCartridge);

        // Retrieve the AllocateWaitTime and RequestWaitTime parameters
        DWORD size;
        OLECHAR tmpString[256];
        DWORD allocateWaitTime;
        DWORD requestWaitTime;

        BOOL bShortTimeout = ( dwOptions & RMS_SHORT_TIMEOUT ) ? TRUE : FALSE;

        if (bShortTimeout) {
            allocateWaitTime = RMS_DEFAULT_SHORT_WAIT_TIME;
            requestWaitTime = RMS_DEFAULT_SHORT_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_SHORT_WAIT_TIME, tmpString, 256, &size))) {
                allocateWaitTime = wcstol(tmpString, NULL, 10);
                requestWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("allocateWaitTime (Short) is %d milliseconds.\n"), allocateWaitTime);
                WsbTrace(OLESTR("RequestWaitTime (Short) is %d milliseconds.\n"), requestWaitTime);
            }
        } else {
            allocateWaitTime = RMS_DEFAULT_ALLOCATE_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_ALLOCATE_WAIT_TIME, tmpString, 256, &size))) {
                allocateWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("AllocateWaitTime is %d milliseconds.\n"), allocateWaitTime);
            }
            requestWaitTime = RMS_DEFAULT_REQUEST_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_REQUEST_WAIT_TIME, tmpString, 256, &size))) {
                requestWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("RequestWaitTime is %d milliseconds.\n"), requestWaitTime);
            }
        }

        // Special error recovery to handle when NTMS is down, or was cycled.
        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID setId = fromMediaSet;
            NTMS_GUID partId = GUID_NULL;
            NTMS_GUID *pPartId = NULL;
            NTMS_GUID requestId;

            err1 = NO_ERROR;
            err2 = NO_ERROR;
            err3 = NO_ERROR;
            err4 = NO_ERROR;
            err5 = NO_ERROR;
            err6 = NO_ERROR;
            err7 = NO_ERROR;

            try {

                // Look for a specific media ourselves if:
                //  1. A specific capacity is required                  AND
                //  2. We do not try to allocate a second side
                if (pFreeSpace && (prevSideId == GUID_NULL)) {
                    if (*pFreeSpace > 0) {
                        int retry = 3;  // Give the operator 3 chances to get it right!
                        do {
                            // We need to allocate a unit of media that matches the capacity specified.
                            //
                            // Enumerate the partitions in the scratch pool of the same type as
                            // specified to find a capatible unit of media
                            //

                            // First find the media type we looking for
                            NTMS_OBJECTINFORMATION mediaPoolInfo;
                            NTMS_OBJECTINFORMATION partitionInfo;
                            HANDLE hFindPool = NULL;
                            HANDLE hFindPart = NULL;
                            BOOL bFound = FALSE;
                            NTMS_GUID scratchPoolId;

                            err1 = NO_ERROR;
                            err2 = NO_ERROR;
                            err3 = NO_ERROR;
                            err4 = NO_ERROR;
                            err5 = NO_ERROR;
                            err6 = NO_ERROR;
                            err7 = NO_ERROR;

                            // First look in our pool for scratch media of the correct size

                            hr = findFirstNtmsObject(NTMS_PARTITION, setId, NULL, GUID_NULL, &hFindPart, &partitionInfo);
                            while(S_OK == hr) {
                                reportNtmsObjectInformation(&partitionInfo);
                                if ((TRUE == partitionInfo.Enabled) &&
                                    (NTMS_READY == partitionInfo.dwOperationalState) &&
                                    (NTMS_PARTSTATE_AVAILABLE == partitionInfo.Info.Partition.State) &&
                                    (partitionInfo.Info.Partition.Capacity.QuadPart >= *pFreeSpace)) {

                                    NTMS_GUID physicalPartMediaId = partitionInfo.Info.Partition.PhysicalMedia;
                                    try {
                                        // Check if the media is online and enabled
                                        NTMS_OBJECTINFORMATION mediaPartInfo;
                                        mediaPartInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                                        mediaPartInfo.dwType = NTMS_PHYSICAL_MEDIA;

                                        // NTMS - Get physical media information
                                        WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
                                        WsbAffirmNoError( GetNtmsObjectInformation( hSession, &physicalPartMediaId, &mediaPartInfo ) );

                                        // Check location type, if enabled & if all new
                                        if ( (mediaPartInfo.Info.PhysicalMedia.LocationType !=  NTMS_UNKNOWN)
                                            && (mediaPartInfo.Enabled) ) {                                    

                                            // Ensure that ALL sides are not allocated yet
                                            hr = EnsureAllSidesNotAllocated(physicalPartMediaId);

                                            if (S_OK == hr) {
                                                // We'll use this unit of media.
                                                // Save parameterers required for Allocate.
                                                bFound = TRUE;
                                                partId = partitionInfo.ObjectGuid;
                                                pPartId = &partId;
                                                break;
                                            } else if (S_FALSE != hr) {
                                                WsbAffirmHr(hr);
                                            }
                                        }

                                    } WsbCatchAndDo (hr,
                                            WsbTraceAlways(OLESTR("CRmsNTMS::Allocate: Failed to check media <%ls> hr = <%ls>\n"),
                                                WsbGuidAsString(physicalPartMediaId), WsbHrAsString(hr));
                                            hr = S_OK;
                                        )
                                }

                                hr = findNextNtmsObject(hFindPart, &partitionInfo);
                            } // while finding media pools

                            findCloseNtmsObject(hFindPart);
                            hr = S_OK;

                            if (!bFound) {

                                // Now try the Scratch Pool

                                memset(&mediaPoolInfo, 0, sizeof(NTMS_OBJECTINFORMATION));

                                mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
                                mediaPoolInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);

                                // NTMS - Get Media Pool Information
                                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_MEDIA_POOL)\n"));
                                err3 = GetNtmsObjectInformation(hSession, &setId, &mediaPoolInfo);
                                WsbAffirmNoError( err3 );

                                // Save the media type for the media pool
                                NTMS_GUID mediaTypeId = mediaPoolInfo.Info.MediaPool.MediaType;

                                // Find the scratch pool with the same media type
                                hr = findFirstNtmsObject(NTMS_MEDIA_POOL, GUID_NULL, NULL, GUID_NULL, &hFindPool, &mediaPoolInfo);
                                while(S_OK == hr) {
                                    if ((NTMS_POOLTYPE_SCRATCH == mediaPoolInfo.Info.MediaPool.PoolType) &&
                                        (mediaTypeId == mediaPoolInfo.Info.MediaPool.MediaType)) {
                                        // This is a base level scratch media pool for type we're looking for.
                                        scratchPoolId = mediaPoolInfo.ObjectGuid;

                                        hr = findFirstNtmsObject(NTMS_PARTITION, scratchPoolId, NULL, GUID_NULL, &hFindPart, &partitionInfo);
                                        while(S_OK == hr) {
                                            reportNtmsObjectInformation(&partitionInfo);
                                            if ((TRUE == partitionInfo.Enabled) &&
                                                (NTMS_READY == partitionInfo.dwOperationalState) &&
                                                (NTMS_PARTSTATE_AVAILABLE == partitionInfo.Info.Partition.State) &&
                                                (partitionInfo.Info.Partition.Capacity.QuadPart >= *pFreeSpace)) {

                                                // Check if the media is online and enabled
                                                DWORD errPart = NO_ERROR;
                                                NTMS_OBJECTINFORMATION mediaPartInfo;
                                                NTMS_GUID physicalPartMediaId = partitionInfo.Info.Partition.PhysicalMedia;
                                                mediaPartInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                                                mediaPartInfo.dwType = NTMS_PHYSICAL_MEDIA;

                                                // NTMS - Get physical media information
                                                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
                                                errPart = GetNtmsObjectInformation( hSession, &physicalPartMediaId, &mediaPartInfo );

                                                // Ignore error here, just don't use this partition
                                                if (errPart == NO_ERROR) {

                                                    // Check location type and if enabled
                                                    if ( (mediaPartInfo.Info.PhysicalMedia.LocationType !=  NTMS_UNKNOWN)
                                                        && (mediaPartInfo.Enabled) ) {
                                                        // We'll use this unit of media.
                                                        // Save parameterers required for Allocate.
                                                        bFound = TRUE;
                                                        partId = partitionInfo.ObjectGuid;
                                                        pPartId = &partId;
                                                        break;
                                                    }
                                                } else {
                                                    WsbTraceAlways(OLESTR("CRmsNTMS::Allocate: Failed to get object info for media <%ls> hr = <%ls>\n"),
                                                        WsbGuidAsString(physicalPartMediaId), WsbHrAsString(HRESULT_FROM_WIN32(errPart)));
                                                }
                                            }
                                            hr = findNextNtmsObject(hFindPart, &partitionInfo);
                                        } // while finding media pools
                                        findCloseNtmsObject(hFindPart);
                                        hr = S_OK;
                                        break;
                                    }
                                    hr = findNextNtmsObject(hFindPool, &mediaPoolInfo);
                                } // while finding media pools
                                findCloseNtmsObject(hFindPool);
                                hr = S_OK;
                            }

                            if (bFound) {
                                break;
                            }
                            else {
                                OLECHAR * messageText = NULL;
                                WCHAR *stringArr[2];
                                WCHAR capString[40];

                                WsbShortSizeFormat64(*pFreeSpace, capString);

                                stringArr[0] = mediaPoolInfo.szName;
                                stringArr[1] = capString;

                                if (0 == FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        LoadLibraryEx( WSB_FACILITY_PLATFORM_NAME, NULL, LOAD_LIBRARY_AS_DATAFILE ), 
                                        RMS_MESSAGE_SCRATCH_MEDIA_REQUEST, MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ), 
                                        (LPTSTR)&messageText, 0, (va_list *)stringArr)) {
                                    WsbTrace(OLESTR("CRmsNTMS::Allocate: FormatMessage failed: %ls\n"),
                                            WsbHrAsString(HRESULT_FROM_WIN32(GetLastError())));
                                }

                                // NTMS - Submit operator request
                                WsbTraceAlways(OLESTR("SubmitNtmsOperatorRequest()\n"));
                                err5 = SubmitNtmsOperatorRequest(hSession, NTMS_OPREQ_NEWMEDIA, messageText, &scratchPoolId, NULL, &requestId);
                                LocalFree(messageText);
                                WsbAffirmNoError(err5);

                                // NTMS - Wait for operator request
                                WsbTraceAlways(OLESTR("WaitForNtmsOperatorRequest()\n"));
                                err6 = WaitForNtmsOperatorRequest(hSession, &requestId, requestWaitTime);
                                //
                                // !!! NOTE !!!  At the time of this writting WaitForNtmsOperatorRequest
                                // did not return ERROR_TIMEOUT.
                                //
                                if (ERROR_TIMEOUT == err6) {
                                    // Best effort cleanup...
                                    // NTMS - Cancel operator request
                                    WsbTraceAlways(OLESTR("CancelNtmsOperatorRequest()\n"));
                                    err7 = CancelNtmsOperatorRequest(hSession, &requestId);
                                }
                                WsbAffirmNoError(err6);
                            }
                            WsbAssertHrOk(hr);

                            // At this point the operator added a compatable unit of media...
                            // Verify until we're exceed the retry count.
                            retry--;
                        } while (retry > 0);
                        if (0 == retry) {
                            WsbThrow(RMS_E_SCRATCH_NOT_FOUND);
                        }
                    }
                }
                // NTMS - Allocate a unit of scratch media
                WsbTraceAlways(OLESTR("AllocateNtmsMedia()\n"));

                // Set additional allocation settings
                DWORD dwAllocateOptions = 0;
                NTMS_GUID mediaId = prevSideId;
                if (mediaId == GUID_NULL) {
                    dwAllocateOptions |= NTMS_ALLOCATE_NEW;
                } else {
                    // Allocating the second side: mediaId should hold the LMID of the first side
                    dwAllocateOptions |= NTMS_ALLOCATE_NEXT;
                }
                if (dwOptions & RMS_ALLOCATE_NO_BLOCK) {
                    dwAllocateOptions |= NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE;
                    allocateWaitTime = 0;
                }

                err1 = AllocateNtmsMedia( hSession, &setId, pPartId, &mediaId,
                                          dwAllocateOptions, allocateWaitTime, NULL );
                WsbAffirmNoError( err1 );

                // Now get/set the various information fields for the unit of media.

                DWORD sideNo = 2;
                NTMS_GUID side[2];

                // NTMS - Enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err2 = EnumerateNtmsObject(hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0);
                WsbAffirmNoError( err2 );

                NTMS_OBJECTINFORMATION partitionInfo;
                partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                partitionInfo.dwType = NTMS_PARTITION;

                // NTMS - Get partition information
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                err3 = GetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err3 );

                NTMS_OBJECTINFORMATION mediaInfo;
                NTMS_GUID physicalMediaId = partitionInfo.Info.Partition.PhysicalMedia;
                mediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;

                // NTMS - Get physical media information
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
                err3 = GetNtmsObjectInformation( hSession, &physicalMediaId, &mediaInfo );
                WsbAffirmNoError( err3 );

                NTMS_OBJECTINFORMATION logicalMediaInfo;
                logicalMediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                logicalMediaInfo.dwType = NTMS_LOGICAL_MEDIA;

                // NTMS - Get physical media information
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_LOGICAL_MEDIA)\n"));
                err3 = GetNtmsObjectInformation( hSession, &mediaId, &logicalMediaInfo );
                WsbAffirmNoError( err3 );

                // Save the capacity for the return arg.
                if (pFreeSpace) {
                    *pFreeSpace = partitionInfo.Info.Partition.Capacity.QuadPart;
                }

                // Set name & description
                CWsbStringPtr mediaDisplayName;

                // Set new physical media name for first side
                // Modify original name for second side
                if ( !(dwAllocateOptions & NTMS_ALLOCATE_NEXT) ) {
                    mediaDisplayName = (WCHAR *)displayName;
                } else {
                    WCHAR *dashPtr = wcsrchr((WCHAR *)displayName, L'-');
                    mediaDisplayName = mediaInfo.szName;
                    if (dashPtr) {
                        WsbAffirmHr(mediaDisplayName.Append(dashPtr));
                    }
                }

                // Set the Name to the displayName, only if there's no bar code.
                if ( NTMS_BARCODESTATE_OK != mediaInfo.Info.PhysicalMedia.BarCodeState) {
                    wcscpy(mediaInfo.szName, mediaDisplayName);
                    wcscpy(partitionInfo.szName, (WCHAR *) displayName);

                    // NTMS doesn't allow dup logical media names.  We set
                    // the name to the mediaId to keep it unique.  The logical
                    // media name is not displayed in the Removable Storage UI.

                    wcscpy(logicalMediaInfo.szName, (WCHAR *) WsbGuidAsString(mediaId));
                }

                // Set the Description to the displayName
                wcscpy(logicalMediaInfo.szDescription, (WCHAR *) displayName);
                wcscpy(partitionInfo.szDescription, (WCHAR *) displayName);
                wcscpy(mediaInfo.szDescription, (WCHAR *) mediaDisplayName);

                // NTMS - Set partition information.
                WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                err4 = SetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err4 );

                // NTMS - Set physical media information.
                WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                err4 = SetNtmsObjectInformation( hSession, &physicalMediaId, &mediaInfo );
                WsbAffirmNoError( err4 );

                // NTMS - Set logical media information.
                WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                err4 = SetNtmsObjectInformation( hSession, &mediaId, &logicalMediaInfo );
                WsbAffirmNoError( err4 );

                WsbAssertHrOk(FindCartridge(mediaId, ppCartridge));
                WsbAssertHr((*ppCartridge)->SetStatus(RmsStatusScratch));

                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // AllocateNtmsMedia
                switch (HRESULT_CODE(hr)) {
                case ERROR_TIMEOUT:
                case ERROR_MEDIA_UNAVAILABLE:
                    hr = RMS_E_SCRATCH_NOT_FOUND;
                    break;

                case ERROR_CANCELLED:
                    hr = RMS_E_CANCELLED;
                    break;

                case ERROR_MEDIA_OFFLINE:
                    hr = RMS_E_MEDIA_OFFLINE;
                    break;

                case ERROR_REQUEST_REFUSED:
                    hr = RMS_E_REQUEST_REFUSED;
                    break;

                case ERROR_WRITE_PROTECT:
                    hr = RMS_E_WRITE_PROTECT;
                    break;

                case ERROR_INVALID_MEDIA_POOL:
                    hr = RMS_E_MEDIASET_NOT_FOUND;
                    break;

                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_DEVICE_NOT_AVAILABLE:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_MEDIA:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("AllocateNtmsMedia"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("AllocateNtmsMedia"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INSUFFICIENT_BUFFER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err3 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err4 != NO_ERROR) {
                // SetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_OBJECT_ALREADY_EXISTS:  // bmd: 1/18/99 - Not documented, but NTMS doesn't allow dup logical media names.
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err5 != NO_ERROR) {
                // SubmitNtmsOperatorRequest
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_CONNECTED:
                case ERROR_OBJECT_NOT_FOUND:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SubmitNtmsOperatorRequest"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SubmitNtmsOperatorRequest"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err6 != NO_ERROR) {
                // WaitForNtmsOperatorRequest
                switch (HRESULT_CODE(hr)) {
                case ERROR_TIMEOUT:
                    hr = RMS_E_TIMEOUT;
                    break;

                case ERROR_CANCELLED:
                    hr = RMS_E_CANCELLED;
                    break;

                case ERROR_REQUEST_REFUSED:
                    hr = RMS_E_REQUEST_REFUSED;
                    break;

                case ERROR_ACCESS_DENIED:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_CONNECTED:
                case ERROR_OBJECT_NOT_FOUND:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("WaitForNtmsOperatorRequest"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("WaitForNtmsOperatorRequest"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::Allocate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP 
CRmsNTMS::Mount(
    IN IRmsCartridge *pCart,
    IN OUT IRmsDrive **ppDrive,
	IN DWORD dwOptions OPTIONAL,
    IN DWORD threadId OPTIONAL)
/*++

Implements:

    IRmsNTMS::Mount

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;
    DWORD err3 = NO_ERROR;
    DWORD err4 = NO_ERROR;

    BOOL mediaMounted = FALSE;

    BOOL bNoBlock = ( dwOptions & RMS_MOUNT_NO_BLOCK ) ? TRUE : FALSE;

	// declared outside try block so it can be accessible throughout the method
    DWORD       sideNo = 2;
    NTMS_GUID   side[2];
             
    WsbTraceIn( OLESTR("CRmsNTMS::Mount"), OLESTR("") );

    try {
        WsbAssertPointer(pCart);

        CComPtr<IRmsDrive> pDrive;

        // determine the timeout for the operator request
        DWORD size;
        OLECHAR tmpString[256];
        BOOL bShortTimeout = ( dwOptions & RMS_SHORT_TIMEOUT ) ? TRUE : FALSE;
        DWORD mountWaitTime;
        if (bShortTimeout) {
            mountWaitTime = RMS_DEFAULT_SHORT_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_SHORT_WAIT_TIME, tmpString, 256, &size))) {
                mountWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("MountWaitTime (Short) is %d milliseconds.\n"), mountWaitTime);
            }
        } else {
            mountWaitTime = RMS_DEFAULT_MOUNT_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_MOUNT_WAIT_TIME, tmpString, 256, &size))) {
                mountWaitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("MountWaitTime is %d milliseconds.\n"), mountWaitTime);
            }
        }

        NTMS_OBJECTINFORMATION driveInfo;
        memset( &driveInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        // Special error recovery to handle when NTMS is down, or was cycled.
        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;

            NTMS_GUID mediaId = GUID_NULL;
            WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
            WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

            err1 = NO_ERROR;
            err2 = NO_ERROR;
            err3 = NO_ERROR;            

            try {

                // NTMS - enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err1 = EnumerateNtmsObject( hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0 );
                WsbAffirmNoError( err1 );

                DWORD       count = 1;
                NTMS_GUID   driveId;

                // NTMS - issue mount request
                WsbTraceAlways(OLESTR("MountNtmsMedia()\n"));
				DWORD dwOpt = NTMS_MOUNT_READ | NTMS_MOUNT_WRITE;
				if (bNoBlock) {
					dwOpt |= (NTMS_MOUNT_ERROR_NOT_AVAILABLE | NTMS_MOUNT_ERROR_OFFLINE);
				}
                if (dwOptions & RMS_USE_MOUNT_NO_DEADLOCK) {
                    /*
                    DEADLOCK AVOIDANCE: when RSM support for MountNtmsMediaDA is
                    in, the next line should be uncommented, and the other 2 lines
                    in this 'if' block should be removed. 
                    err2 = MountNtmsMediaDA( hSession, &side[0], &driveId, count, dwOpt, NTMS_PRIORITY_NORMAL, mountWaitTime, NULL, &threadId, 1);
                    */
                    UNREFERENCED_PARAMETER(threadId);
                    err2 = MountNtmsMedia( hSession, &side[0], &driveId, count, dwOpt, NTMS_PRIORITY_NORMAL, mountWaitTime, NULL);
                } else {
                    err2 = MountNtmsMedia( hSession, &side[0], &driveId, count, dwOpt, NTMS_PRIORITY_NORMAL, mountWaitTime, NULL);

                }
                WsbAffirmNoError( err2 );
                mediaMounted = TRUE;

                //
                // We now need two critical pieces of information.  The Device name and
                // the kind of media we just mounted.  This gives use the essential information
                // to create a data mover.  Since we drill through NTMS to get this information
                // we also create cartridge, drive objects.
                //

                driveInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                driveInfo.dwType = NTMS_DRIVE;

                // NTMS - get drive information
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_DRIVE)\n"));
                err3 = GetNtmsObjectInformation( hSession, &driveId, &driveInfo );
                WsbAffirmNoError( err3 );
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

        RmsMedia mediaType;
        WsbAffirmHr(pCart->GetType((LONG *)&mediaType));

        // Create Drive
        WsbAssertHr(CoCreateInstance(CLSID_CRmsDrive, 0, CLSCTX_SERVER, IID_IRmsDrive, (void **)&pDrive));

        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pElmt = pDrive;

        WsbAssertHr(pElmt->SetMediaSupported(mediaType));

        CComQIPtr<IRmsDevice, &IID_IRmsDevice> pDevice = pDrive;

        WsbAssertHr(pDevice->SetDeviceAddress(
            (BYTE) driveInfo.Info.Drive.ScsiPort,
            (BYTE) driveInfo.Info.Drive.ScsiBus,
            (BYTE) driveInfo.Info.Drive.ScsiTarget,
            (BYTE) driveInfo.Info.Drive.ScsiLun));

        CWsbBstrPtr deviceName = driveInfo.Info.Drive.szDeviceName;

        ////////////////////////////////////////////////////////////////////////////////////////
        // Convert the NTMS device name to something usable.
        //
        switch (mediaType) {
        case RmsMediaOptical:
        case RmsMediaDVD:
        case RmsMediaDisk:
            {
                // We need to convert \\.\PhysicalDriveN to something accessible by the file system.
                WCHAR *szDriveLetter = NULL;
                WCHAR *szVolumeName = NULL;
                err4 = GetVolumesFromDrive( (WCHAR *)deviceName, &szVolumeName, &szDriveLetter );
                if (szVolumeName) {
                    delete [] szVolumeName;    // don't need it for now
                }
                if (NO_ERROR == err4) {
                    if (szDriveLetter) {
                        deviceName = szDriveLetter;
                    } else {
                        WsbTraceAlways(OLESTR("CRmsNTMS::Mount: GetVolumesFromDrive succeeded but output drive is NULL !!\n"));
                        WsbThrow(RMS_E_RESOURCE_UNAVAILABLE);
                    }
                }
                if (szDriveLetter) {
                    delete [] szDriveLetter;
                }
                WsbAffirmNoError( err4 );
                WsbTrace(OLESTR("CRmsNTMS::Mount: device name after convert is %s\n"), (WCHAR *)deviceName);
            }       
            break;

        default:
            break;
        }
        ////////////////////////////////////////////////////////////////////////////////////////

        WsbAssertHr(pDevice->SetDeviceName(deviceName));

        WsbAssertHr(pCart->SetDrive(pDrive));

        // Fill in the return arguments.
        *ppDrive = pDrive;
        pDrive->AddRef();

    } WsbCatchAndDo(hr,
            // Process the exception
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INSUFFICIENT_BUFFER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // MountNtmsMedia
                switch (HRESULT_CODE(hr)) {
                case ERROR_TIMEOUT:
                    hr = RMS_E_CARTRIDGE_UNAVAILABLE;
                    break;

                case ERROR_CANCELLED:
                    hr = RMS_E_CANCELLED;
                    break;

                case ERROR_MEDIA_OFFLINE:
                    hr = RMS_E_MEDIA_OFFLINE;
					if (bNoBlock) {
						DWORD errSub = NO_ERROR;

						try	{
							// Since we are not blocking for NTMS to ask the operator
							//	to mount the offline media, we do it ourselves

							// create operator message
						    CWsbBstrPtr cartridgeName = "";
							CWsbBstrPtr cartridgeDesc = "";
                            OLECHAR * messageText = NULL;
                            WCHAR *stringArr[2];

					        cartridgeName.Free();
							WsbAffirmHr(pCart->GetName(&cartridgeName));
					        cartridgeDesc.Free();
							WsbAffirmHr(pCart->GetDescription(&cartridgeDesc));
                            stringArr[0] = (WCHAR *) cartridgeName;
                            stringArr[1] = (WCHAR *) cartridgeDesc;

                            if (0 == FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      LoadLibraryEx( WSB_FACILITY_PLATFORM_NAME, NULL, LOAD_LIBRARY_AS_DATAFILE ), 
                                      RMS_MESSAGE_OFFLINE_MEDIA_REQUEST, MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ), 
                                      (LPTSTR)&messageText, 0, (va_list *)stringArr)) {
								WsbTrace(OLESTR("CRmsNTMS::Mount: FormatMessage failed: %ls\n"),
                                            WsbHrAsString(HRESULT_FROM_WIN32(GetLastError())));
	                            messageText = NULL;
							}

							NTMS_GUID mediaId = GUID_NULL;
							NTMS_GUID libId = GUID_NULL;
							NTMS_GUID requestId = GUID_NULL;
							WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
							WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

							// Library Id should be gathered here - need to clarify why 
							//	does the GetHome return a null id !!!
//							WsbAffirmHr(pCart->GetHome(NULL, &libId, NULL, NULL, NULL, NULL, NULL, NULL));
//							WsbAssert(libId != GUID_NULL, E_INVALIDARG);

							// submit operator request
							errSub = SubmitNtmsOperatorRequest(m_SessionHandle, NTMS_OPREQ_MOVEMEDIA,
										messageText, &mediaId, &libId, &requestId);
                            LocalFree(messageText);
			                WsbAffirmNoError (errSub);

						}  WsbCatchAndDo(hr,
							// Process the error of the Corrective Action
							if (errSub != NO_ERROR ) {
			                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
									OLESTR("SubmitNtmsOperatorRequest"), OLESTR(""),
									WsbHrAsString(hr), NULL);
							}

							// place back the original mane error
		                    hr = RMS_E_MEDIA_OFFLINE;
						);
					}
                    break;

                case ERROR_REQUEST_REFUSED:
                    hr = RMS_E_REQUEST_REFUSED;
                    break;

                case ERROR_WRITE_PROTECT:
                    hr = RMS_E_WRITE_PROTECT;
                    break;

                case ERROR_INVALID_STATE:
                case ERROR_INVALID_DRIVE: {
					// when performing NTMS mount in non-blocking mode , this error may 
					//	just mean that a corrective action such as drive cleaning should 
					//	be performed before mounting (note that ONLY when not blocking, 
					//	NTMS can not instruct corrective actions by itself)
					if (bNoBlock) {
						try	{
						    CWsbBstrPtr cartridgeName = "";
							CWsbBstrPtr cartridgeDesc = "";
					        cartridgeName.Free();
							WsbAffirmHr(pCart->GetName(&cartridgeName));
					        cartridgeDesc.Free();
							WsbAffirmHr(pCart->GetDescription(&cartridgeDesc));
					        WsbLogEvent(RMS_MESSAGE_DRIVE_NOT_AVAILABLE, 0, NULL, 
								(WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);

					    } WsbCatch(hr);

						break;
					}
                  }
                case ERROR_RESOURCE_DISABLED: {
					// Check if the the media (cartridge) is disabled - different error should
					//	be returned for media and for other resources (library, drive, etc.)
					
                    HRESULT hrOrg = hr;
					DWORD errSub1 = NO_ERROR;
					DWORD errSub2 = NO_ERROR;
					try	{
						// get physical media information
		                NTMS_OBJECTINFORMATION objectInfo;
		                objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
				        objectInfo.dwType = NTMS_PARTITION;
						WsbAssert(side[0] != GUID_NULL, E_INVALIDARG);
		                errSub1 = GetNtmsObjectInformation( m_SessionHandle, &side[0], &objectInfo );
		                WsbAffirmNoError (errSub1);

		                NTMS_GUID physicalMediaId = objectInfo.Info.Partition.PhysicalMedia;
						WsbAssert(physicalMediaId != GUID_NULL, E_INVALIDARG);
		                objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
		                objectInfo.dwType = NTMS_PHYSICAL_MEDIA;
		                errSub2 = GetNtmsObjectInformation( m_SessionHandle, &physicalMediaId, &objectInfo );
		                WsbAffirmNoError (errSub2);

						// set our dedicated error only if (physical) media is disabled
						if (! objectInfo.Enabled) {
		                    hr = RMS_E_CARTRIDGE_DISABLED;
						}

					}  WsbCatchAndDo(hr,
						// Process the error of the get-info requests
						if (errSub1 != NO_ERROR ) {
		                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
								OLESTR("GetNtmsObjectInformation (Partition)"), OLESTR(""),
								WsbHrAsString(hr), NULL);
						} else if (errSub2 != NO_ERROR ) {
		                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
								OLESTR("GetNtmsObjectInformation (Physical Media)"), OLESTR(""),
								WsbHrAsString(hr), NULL);
						}

						// place back the original mane error
	                    hr = hrOrg;
					);
					break;
				  } 

                case ERROR_ACCESS_DENIED:
                case ERROR_BUSY:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_DRIVE_MEDIA_MISMATCH:
                case ERROR_INVALID_LIBRARY:
                case ERROR_INVALID_MEDIA:
                case ERROR_NOT_ENOUGH_MEMORY: {
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("MountNtmsMedia"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                  }
                default: {
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("MountNtmsMedia"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                  }
                }
            }
            else if (err3 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            } else if (err4 != NO_ERROR) {
                WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                    OLESTR("GetVolumesFromDrive"), OLESTR("Unexpected Failure: "),
                    WsbHrAsString(hr), NULL);
            }

            if (mediaMounted) {
                // Something failed after the mount completed, so need to clean up...
                // Dismount the media to release the resource before returning.
                Dismount(pCart, FALSE);
            }
        );

    WsbTraceOut( OLESTR("CRmsNTMS::Mount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


STDMETHODIMP 
CRmsNTMS::Dismount(
    IN IRmsCartridge *pCart, IN DWORD dwOptions)
/*++

Implements:

    IRmsNTMS::Dismount

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;

    WsbTraceIn( OLESTR("CRmsNTMS::Dismount"), OLESTR("") );

    try {
        WsbAssertPointer(pCart);

        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;

            NTMS_GUID mediaId = GUID_NULL;
            WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
            WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

            NTMS_GUID side[2];
            DWORD sideNo = 2;

            err1 = NO_ERROR;
            err2 = NO_ERROR;

            try {

                // NTMS - enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err1 = EnumerateNtmsObject( hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0 );
                WsbAffirmNoError( err1 );

                // NTMS - dismount media
                DWORD dwNtmsOptions = 0;
                WsbTraceAlways(OLESTR("DismountNtmsMedia()\n"));
				if (! ( dwOptions & RMS_DISMOUNT_IMMEDIATE )) {
					dwNtmsOptions |= NTMS_DISMOUNT_DEFERRED;
				}
                err2 = DismountNtmsMedia( hSession, &side[0], 1, dwNtmsOptions );
#ifdef DBG
                // TODO: Remove this trap for the unexpected ERROR_ACCESS_DENIED error.
                WsbAssert(err2 != ERROR_ACCESS_DENIED, HRESULT_FROM_WIN32(err2));
#endif
                WsbAffirmNoError( err2 );

                // Since RSM Dismount is asyncronous, we may need to wait some arbitrary time,
                //  in order that when we come back, the media is really dismounted
                if ( (dwOptions & RMS_DISMOUNT_DEFERRED_ONLY) && (!(dwOptions & RMS_DISMOUNT_IMMEDIATE)) ) {
                    CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                    if (S_OK == pServer->IsReady()) {
                        DWORD size;
                        OLECHAR tmpString[256];
                        DWORD waitTime = RMS_DEFAULT_AFTER_DISMOUNT_WAIT_TIME;
                        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_AFTER_DISMOUNT_WAIT_TIME, tmpString, 256, &size))) {
                            waitTime = wcstol(tmpString, NULL, 10);
                            WsbTrace(OLESTR("AfterDismountWaitTime is %d milliseconds.\n"), waitTime);
                        }

                        Sleep(waitTime);
                    }
                }

                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);


    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // DismountNtmsMedia
                switch (HRESULT_CODE(hr)) {
                case ERROR_MEDIA_OFFLINE:
                    hr = RMS_E_MEDIA_OFFLINE;
                    break;

                case ERROR_TIMEOUT:
                case ERROR_INVALID_MEDIA:
                case ERROR_INVALID_LIBRARY:
                case ERROR_DEVICE_NOT_AVAILABLE:
                case ERROR_MEDIA_NOT_AVAILABLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INVALID_STATE:
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("DismountNtmsMedia"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("DismountNtmsMedia"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut( OLESTR("CRmsNTMS::Dismount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


STDMETHODIMP 
CRmsNTMS::Deallocate(
    IN IRmsCartridge *pCart)
/*++

Implements:

    IRmsNTMS::DeallocateMedia

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;
    DWORD err3 = NO_ERROR;
    DWORD err4 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::Deallocate"), OLESTR(""));

    try {
        WsbAssertPointer(pCart);

        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;

            NTMS_GUID mediaId = GUID_NULL;
            WsbAffirmHr(pCart->GetCartridgeId(&mediaId));
            WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

            err1 = NO_ERROR;
            err2 = NO_ERROR;
            err3 = NO_ERROR;
            err4 = NO_ERROR;

            NTMS_OBJECTINFORMATION partitionInfo;
            memset( &partitionInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

            DWORD sideNo = 2;
            NTMS_GUID side[2];

            try {
                // NTMS - enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err1 = EnumerateNtmsObject( hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0 );
                WsbAffirmNoError( err1 );

                // NTMS - get partition information
                partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                partitionInfo.dwType = NTMS_PARTITION;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                err2 = GetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err2 );

                // NULL the Description
                wcscpy(partitionInfo.szDescription, L"");

                // NTMS - Set partition information.
                WsbTraceAlways(OLESTR("SetNtmsObjectInformation()\n"));
                err3 = SetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err3 );                

                // NTMS - deallocate media
                WsbTraceAlways(OLESTR("DeallocateNtmsMedia()\n"));
                err4 = DeallocateNtmsMedia( hSession, &mediaId, 0 );
                WsbAffirmNoError( err4 );

                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);



    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err3 != NO_ERROR) {
                // SetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_OBJECT_ALREADY_EXISTS:  // bmd: 1/18/99 - Not documented, but NTMS doesn't allow dup logical media names.
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err4 != NO_ERROR) {
                // DeallocateNtmsMedia
                switch (HRESULT_CODE(hr)) {
                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_MEDIA:
                //case ERROR_INVALID_PARTITION:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_DATABASE_FAILURE:
                case ERROR_DATABASE_FULL:
                case ERROR_ACCESS_DENIED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("DeallocateNtmsMedia"), OLESTR(""),
                        WsbHrAsString(hr),
                        NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("DeallocateNtmsMedia"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::Deallocate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsNTMS::UpdateOmidInfo(
    IN REFGUID cartId,
    IN BYTE *pBuffer,
    IN LONG size,
    IN LONG type)
/*++

Implements:

    IRmsNTMS::UpdateOmidInfo

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn( OLESTR("CRmsNTMS::UpdateOmidInfo"), OLESTR("<%ls> <0x%08x> <%d>"), WsbGuidAsString(cartId), pBuffer, size );

    try {
        WsbAssert(cartId != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(pBuffer);
        WsbAssert(size > 0, E_INVALIDARG);

        WsbTraceBuffer(size, pBuffer);

        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID mediaId = cartId;

            err1 = NO_ERROR;

            try {

                // NTMS - update on media information.
                WsbTraceAlways(OLESTR("UpdateNtmsOmidInfo()\n"));
                switch((RmsOnMediaIdentifier)type) {
                case RmsOnMediaIdentifierMTF:
                    err1 = UpdateNtmsOmidInfo(hSession, &mediaId, NTMS_OMID_TYPE_RAW_LABEL, size, pBuffer);
                    break;
                case RmsOnMediaIdentifierWIN32:
                    WsbAssert(size == sizeof(NTMS_FILESYSTEM_INFO), E_UNEXPECTED);
                    err1 = UpdateNtmsOmidInfo(hSession, &mediaId, NTMS_OMID_TYPE_FILESYSTEM_INFO, size, pBuffer);
                    break;
                default:
                    WsbThrow(E_UNEXPECTED);
                }
                WsbAffirmNoError( err1 );
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // UpdateNtmsOmidInfo
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_MEDIA:
                //case ERROR_INVALID_PARTITION:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_CONNECTED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("UpdateNtmsOmidInfo"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("UpdateNtmsOmidInfo"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut( OLESTR("CRmsNTMS::UpdateOmidInfo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}



STDMETHODIMP
CRmsNTMS::GetBlockSize(
    IN REFGUID cartId,
    OUT LONG *pBlockSize
    )
/*++

Implements:

    IRmsNTMS::GetBlockSize

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::GetBlockSize"), OLESTR("<%ls> <x%08x>"), WsbGuidAsString(cartId), pBlockSize);

    try {
        WsbAssertPointer(pBlockSize);

        do {
            hr = S_OK;
            err1 = NO_ERROR;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID mediaId = cartId;

            DWORD nBlockSize;
            DWORD sizeOfBlockSize = sizeof(DWORD);
            try {

                err1 = GetNtmsObjectAttribute(hSession, &mediaId, NTMS_LOGICAL_MEDIA, OLESTR("BlockSize"), (LPVOID) &nBlockSize, &sizeOfBlockSize);
                WsbAffirmNoError(err1);
                *pBlockSize = (LONG) nBlockSize;
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // GetNtmsObjectAttribute
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:        // Don't log this error.  Attribute doesn't
                    break;                          //  exist for new media.  We skip this error
                                                    //  and let the caller deal with it.

                case ERROR_DATABASE_FAILURE:        // Log these errors.
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                case ERROR_INSUFFICIENT_BUFFER:
                case ERROR_NO_DATA:
                case ERROR_INVALID_PARAMETER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectAttribute"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectAttribute"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::GetBlockSize"), OLESTR("hr = <%ls>, BlockSize = <%d>"), WsbHrAsString(hr), *pBlockSize);

    return hr;
}


STDMETHODIMP
CRmsNTMS::SetBlockSize(
    IN REFGUID cartId,
    IN LONG blockSize
    )
/*++

Implements:

    IRmsNTMS::SetBlockSize

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::SetBlockSize"), OLESTR("<%ls> <%d>"), WsbGuidAsString(cartId), blockSize);

    try {

        do {
            hr = S_OK;
            err1 = NO_ERROR;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID mediaId = cartId;

            DWORD nBlockSize = blockSize;
            DWORD sizeOfBlockSize = sizeof(DWORD);

            try {

                err1 = SetNtmsObjectAttribute(hSession, &mediaId, NTMS_LOGICAL_MEDIA, OLESTR("BlockSize"), (LPVOID) &nBlockSize, sizeOfBlockSize);
                WsbAffirmNoError(err1);
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // SetNtmsObjectAttribute
                switch (HRESULT_CODE(hr)) {
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_INSUFFICIENT_BUFFER:
                case ERROR_NOT_CONNECTED:
                case ERROR_NO_DATA:
                case ERROR_INVALID_PARAMETER:
                case ERROR_OBJECT_NOT_FOUND:
                case ERROR_INVALID_NAME:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectAttribute"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("SetNtmsObjectAttribute"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::SetBlockSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsNTMS::changeState(
    IN LONG newState
    )
/*++

Routine Description:

    Changes the state of the NTMS object.

Arguments:

    None.

Return Values:

    S_OK    - Success.

--*/
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::changeState"), OLESTR("<%d>"), newState);

    try {

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
        WsbAssertPointer( pObject );

        // TODO: Validate the state change
        WsbAffirmHr(pObject->SetState(newState));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::changeState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsNTMS::ExportDatabase(void)
/*++

Implements:

    CRmsNTMS::ExportDatabase

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;

    WsbTraceIn( OLESTR("CRmsNTMS::ExportDatabase"), OLESTR(""));

    try {

        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;
             
            err1 = NO_ERROR;

            try {

                err1 = ExportNtmsDatabase(hSession);
                WsbAffirmNoError(err1);
                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up, handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

    } WsbCatchAndDo(hr,
            if (err1 != NO_ERROR) {
                // ExportNtmsDatabase
                switch (HRESULT_CODE(hr)) {
                case ERROR_ACCESS_DENIED:
                case ERROR_DATABASE_FAILURE:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_CONNECTED:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("ExportNtmsDatabase"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;
                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("ExportNtmsDatabase"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut(OLESTR("CRmsNTMS::ExportDatabase"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CRmsNTMS::FindCartridge(
    IN REFGUID cartId,
    OUT IRmsCartridge **ppCartridge)
/*++

Implements:

    CRmsNTMS::FindCartridge

--*/
{
    HRESULT hr = S_OK;
    DWORD err1 = NO_ERROR;
    DWORD err2 = NO_ERROR;

    WsbTraceIn( OLESTR("CRmsNTMS::FindCartridge"), OLESTR("<%ls> <0x%08x>"), WsbGuidAsString(cartId), ppCartridge);

    try {
        WsbAssert(cartId != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(ppCartridge);

        NTMS_OBJECTINFORMATION partitionInfo;
        memset( &partitionInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION mediaInfo;
        memset( &mediaInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION mediaTypeInfo;
        memset( &mediaTypeInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION libraryInfo;
        memset( &libraryInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION logicalMediaInfo;
        memset( &logicalMediaInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        RmsMedia translatedMediaType = RmsMediaUnknown;

        // Special error recovery to handle when NTMS is down, or was cycled.
        do {
            hr = S_OK;

            HANDLE hSession = m_SessionHandle;
            NTMS_GUID mediaId = cartId;
            DWORD sideNo = 2;
            NTMS_GUID side[2];

            err1 = NO_ERROR;
            err2 = NO_ERROR;

            try {

                // NTMS - enumerate the sides of a unit of media
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                err1 = EnumerateNtmsObject( hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0 );
                WsbAffirmNoError( err1 );

                // NTMS - get partition information
                partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                partitionInfo.dwType = NTMS_PARTITION;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                err2 = GetNtmsObjectInformation( hSession, &side[0], &partitionInfo );
                WsbAffirmNoError( err2 );

                // NTMS - get physical media information
                NTMS_GUID physicalMediaId = partitionInfo.Info.Partition.PhysicalMedia;

                mediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
                err2 = GetNtmsObjectInformation( hSession, &physicalMediaId, &mediaInfo );
                WsbAffirmNoError( err2);

                // NTMS - get media type information
                NTMS_GUID mediaTypeId = mediaInfo.Info.PhysicalMedia.MediaType;

                mediaTypeInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                mediaTypeInfo.dwType = NTMS_MEDIA_TYPE;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_MEDIA_TYPE)\n"));
                err2 = GetNtmsObjectInformation( hSession, &mediaTypeId, &mediaTypeInfo );
                WsbAffirmNoError( err2 );

                // Translate the NTMS media type into something understood by RMS
                storageMediaTypeToRmsMedia(&(mediaTypeInfo.Info.MediaType), &translatedMediaType);

                // NTMS - get logical media information
                logicalMediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                logicalMediaInfo.dwType = NTMS_LOGICAL_MEDIA;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_LOGICAL_MEDIA)\n"));
                err2 = GetNtmsObjectInformation( hSession, &mediaId, &logicalMediaInfo );
                WsbAffirmNoError( err2 );

                // NTMS - get library information
                NTMS_GUID libraryId = mediaInfo.Info.PhysicalMedia.CurrentLibrary;

                libraryInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
                libraryInfo.dwType = NTMS_LIBRARY;

                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_LIBRARY)\n"));
                err2 = GetNtmsObjectInformation( hSession, &libraryId, &libraryInfo );
                WsbAffirmNoError( err2 );

                break;

            } WsbCatchAndDo(hr,
                    switch (HRESULT_CODE(hr)) {
                    case ERROR_INVALID_HANDLE:
                    case ERROR_NOT_CONNECTED:
                    case RPC_S_SERVER_UNAVAILABLE:  // Media Services is not running.
                    case RPC_S_CALL_FAILED_DNE:     // Media Services is up; handle is not valid.
                    case RPC_S_CALL_FAILED:         // Media Services crashed.
                        WsbAffirmHr(beginSession());
                        continue;
                    }
                    WsbThrow(hr);
                );
        } while(1);

        // Create Cartridge
        IRmsCartridge  *pCart = 0;
        WsbAssertHr(CoCreateInstance(CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                     IID_IRmsCartridge, (void **)&pCart));

        // Fill in the object data

        // The media Name is what is displaye by NTMS UI
        CWsbBstrPtr name = mediaInfo.szName;
        WsbAffirmHr(pCart->SetName(name));

        // The partition Description is what is displayed by NTMS UI.
        CWsbBstrPtr desc = partitionInfo.szDescription;
        WsbAffirmHr(pCart->SetDescription(desc));

        WsbAffirmHr(pCart->SetCartridgeId(cartId));

        CWsbBstrPtr barCode = mediaInfo.Info.PhysicalMedia.szBarCode;
        CWsbBstrPtr seqNo = mediaInfo.Info.PhysicalMedia.szSequenceNumber; // Not used
        WsbAffirmHr(pCart->SetTagAndNumber(barCode, 0));

        WsbAffirmHr(pCart->SetType((LONG) translatedMediaType));

        switch (mediaInfo.Info.PhysicalMedia.MediaState) {
            case NTMS_MEDIASTATE_IDLE:
            case NTMS_MEDIASTATE_UNLOADED:
                WsbAffirmHr(pCart->SetIsAvailable(TRUE));
                break;

            default:
                WsbAffirmHr(pCart->SetIsAvailable(FALSE));
                break;
        }        
        
        RmsElement type = RmsElementUnknown;

        if ( NTMS_LIBRARYTYPE_ONLINE == libraryInfo.Info.Library.LibraryType ) {

            switch (mediaInfo.Info.PhysicalMedia.LocationType) {
            case NTMS_STORAGESLOT:
                type = RmsElementStorage;
                break;

            case NTMS_DRIVE:
                type = RmsElementDrive;
                break;

            case NTMS_IEPORT:
                type = RmsElementIEPort;
                break;

            case NTMS_CHANGER:
                type = RmsElementChanger;
                break;

            default:
                type = RmsElementUnknown;
                break;
            }
        }
        else if ( NTMS_LIBRARYTYPE_STANDALONE == libraryInfo.Info.Library.LibraryType ) {

            switch (mediaInfo.Info.PhysicalMedia.LocationType) {
            case NTMS_DRIVE:
                type = RmsElementDrive;
                break;

            default:
                type = RmsElementUnknown;
                break;
            }
        } else {
            type = RmsElementShelf;
        }

        WsbAffirmHr(pCart->SetLocation(type,
           mediaInfo.Info.PhysicalMedia.CurrentLibrary,
           logicalMediaInfo.Info.LogicalMedia.MediaPool,
           0, 0, 0, 0, 0));

        WsbAffirmHr(pCart->SetManagedBy((LONG)RmsMediaManagerNTMS));

        WsbAssertHr(pCart->SetStatus(RmsStatusPrivate));

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObj = pCart;
        if (!mediaInfo.Enabled) {
            WsbAffirmHr(pObj->Disable(RMS_E_CARTRIDGE_DISABLED));
        }

        CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = pCart;
        WsbAffirmHr(pInfo->SetCapacity(partitionInfo.Info.Partition.Capacity.QuadPart));

        WsbTrace(OLESTR("Cartridge id <name/desc>:   %ls <%ls/%ls>\n"), WsbGuidAsString(cartId), (WCHAR *) name, (WCHAR *) desc);
        WsbTrace(OLESTR("Cartridge <barCode/seqNo>:  <%ls/%ls>\n"), (WCHAR *) barCode, (WCHAR *) seqNo );
        WsbTrace(OLESTR("Cartridge Enabled:          %ls\n"), WsbHrAsString(pObj->IsEnabled()));
        WsbTrace(OLESTR("Cartridge type:             %d\n"), translatedMediaType);
        WsbTrace(OLESTR("Cartridge capacity:         %I64d\n"), partitionInfo.Info.Partition.Capacity.QuadPart);
        WsbTrace(OLESTR("Cartridge domain:           %ls\n"), WsbGuidAsString(logicalMediaInfo.Info.LogicalMedia.MediaPool));

        if (mediaInfo.Info.PhysicalMedia.MediaPool != logicalMediaInfo.Info.LogicalMedia.MediaPool) {
            CWsbStringPtr idPhysical = mediaInfo.Info.PhysicalMedia.CurrentLibrary;
            CWsbStringPtr idLogical = logicalMediaInfo.Info.LogicalMedia.MediaPool;
            WsbTraceAlways(OLESTR("CRmsNTMS::FindCartridge - Media Pool Id mismatch %ls != %ls\n"), idPhysical, idLogical );
        }

        // Fill in the return argument.
        *ppCartridge = pCart;

    } WsbCatchAndDo( hr,
            WsbTrace(OLESTR("CRmsNTMS::FindCartridge - %ls Not Found.  hr = <%ls>\n"),WsbGuidAsString(cartId),WsbHrAsString(hr));
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Undocumented Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );


    WsbTraceOut( OLESTR("CRmsNTMS::FindCartridge"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


STDMETHODIMP
CRmsNTMS::Suspend(void)
/*++

Implements:

    CRmsNTMS::Suspend

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn( OLESTR("CRmsNTMS::Suspend"), OLESTR(""));

    try {

        WsbAffirmHr(changeState(RmsNtmsStateSuspending));
        WsbAffirmHr(endSession());
        WsbAffirmHr(changeState(RmsNtmsStateSuspended));

    } WsbCatch(hr);

    WsbTraceOut( OLESTR("CRmsNTMS::Suspend"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


STDMETHODIMP
CRmsNTMS::Resume(void)
/*++

Implements:

    CRmsNTMS::Resume

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn( OLESTR("CRmsNTMS::Resume"), OLESTR(""));

    try {

        WsbAffirmHr(changeState(RmsNtmsStateResuming));
        WsbAffirmHr(beginSession());
        WsbAffirmHr(changeState(RmsNtmsStateReady));

    } WsbCatch(hr);

    WsbTraceOut( OLESTR("CRmsNTMS::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT 
CRmsNTMS::InitializeInAnotherThread(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::InitializeInAnotherThread"), OLESTR(""));

    try {

        DWORD threadId;
        HANDLE hThread;
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        WsbAffirmHr( pServer->ChangeState( RmsServerStateInitializing ));
        WsbAffirmHandle(hThread = CreateThread(NULL, 1024, CRmsNTMS::InitializationThread, this, 0, &threadId));
        CloseHandle(hThread);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::InitializeInAnotherThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


DWORD WINAPI
CRmsNTMS::InitializationThread(
    IN LPVOID pv)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::InitializationThread"), OLESTR(""));


    try {
        WsbAssertPointer(pv);
        CRmsNTMS *pNTMS = (CRmsNTMS*)pv;
        WsbAffirmHr(pNTMS->Initialize());
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        WsbAffirmHr( pServer->ChangeState( RmsServerStateReady ));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::InitializationThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
    } 


HRESULT
CRmsNTMS::isReady(void)
{

    HRESULT hr = S_OK;

    try {

        BOOL isEnabled;
        HRESULT status;
        RmsServerState state;

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
        WsbAssertPointer( pObject );

        WsbAffirmHr( isEnabled = pObject->IsEnabled());
        WsbAffirmHr( pObject->GetState( (LONG *)&state ));
        WsbAffirmHr( pObject->GetStatusCode( &status ));

        if ( S_OK == isEnabled ) {
            if ( RmsServerStateReady == state ) {
                hr = S_OK;
            }
            else {
                if ( S_OK == status ) {
                    WsbThrow(E_UNEXPECTED);
                }
                else {
                    WsbThrow(status);
                }
            }
        }
        else {
            if ( S_OK == status ) {
                WsbThrow(E_UNEXPECTED);
            }
            else {
                WsbThrow(status);
            }
        }

    } WsbCatch(hr);

    return hr;
}



HRESULT
CRmsNTMS::setPoolDACL (
        IN OUT NTMS_GUID *pPoolId,
        IN DWORD subAuthority,
        IN DWORD action,
        IN DWORD mask)

{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::SetPoolDACL"), OLESTR("%ls <%d> <%d> <%d>"), WsbGuidAsString(*pPoolId), subAuthority, action, mask);

    PSID psidAccount = NULL;
    PSECURITY_DESCRIPTOR psdRePoolSd = NULL;

    try {

        SID_IDENTIFIER_AUTHORITY ntauth = SECURITY_NT_AUTHORITY;
        DWORD errCode = NO_ERROR, sizeTry = 5, sizeReturned = 0;
        PACL paclDis = NULL;
        ACCESS_ALLOWED_ACE *pAce = NULL;
        BOOL daclPresent = FALSE, daclDefaulted = FALSE;
        HANDLE hSession = m_SessionHandle;

        WsbAffirmStatus(AllocateAndInitializeSid(&ntauth, 2, SECURITY_BUILTIN_DOMAIN_RID, subAuthority, 0, 0, 0, 0, 0, 0, &psidAccount));

        //Get the security descriptor for the pool
        for (;;) {
            if (psdRePoolSd != NULL) {
				free(psdRePoolSd);
			}
            psdRePoolSd = (PSECURITY_DESCRIPTOR)malloc(sizeTry);
            WsbAffirm(NULL != psdRePoolSd, E_OUTOFMEMORY);

            errCode = GetNtmsObjectSecurity(hSession, pPoolId, NTMS_MEDIA_POOL, DACL_SECURITY_INFORMATION, psdRePoolSd, sizeTry, &sizeReturned);

            if (errCode == ERROR_SUCCESS) {
                break;
            }
            else if (errCode == ERROR_INSUFFICIENT_BUFFER) {
                sizeTry = sizeReturned;
                continue;
            }
			else {
				WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
							OLESTR("GetNtmsObjectSecurity"),
							WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
							NULL );
				WsbAffirmNoError(errCode);
			}
        }

        // Get a pointer to the DACL
        WsbAffirmStatus(GetSecurityDescriptorDacl(psdRePoolSd, &daclPresent, &paclDis, &daclDefaulted));

        // Go through the DACL and change the mask of the ACE that matches the SID
        for (DWORD i = 0;i < paclDis->AceCount; ++i) {
            WsbAffirmStatus(GetAce(paclDis, i, (LPVOID*) &pAce));
            if (EqualSid(psidAccount, &(pAce->SidStart))) {
                if (action == ADD_ACE_MASK_BITS) {
                    pAce->Mask |= mask;
                } else {
                    pAce->Mask &= ~mask;
                }
            }
        }

        // Set the pool security descriptor
        errCode = SetNtmsObjectSecurity(hSession, pPoolId, NTMS_MEDIA_POOL, DACL_SECURITY_INFORMATION, psdRePoolSd);
        WsbAffirmNoError(errCode);

    }  WsbCatch(hr);

	if (psdRePoolSd) {
		free(psdRePoolSd);
	}

	if (psidAccount) {
		FreeSid(psidAccount);
	}

    WsbTraceOut(OLESTR("CRmsNTMS::SetPoolDACL"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CRmsNTMS::IsMediaCopySupported (
    IN REFGUID mediaPoolId)
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsNTMS::IsMediaCopySupported"), OLESTR("%ls"), WsbGuidAsString(mediaPoolId));

    try {

        // If we can find two drives that support this media type then
        // the media copy operation is supported.

        // For each drive known to NTMS we need to find what media types
        // it supports.  NTMS doesn't keep media type information for the
        // drive, but assumes homogeneous drives in a library (per HighGound) -
        // so detecting this is a bit convoluted.

        // we'll search through each library and find the media types
        // supported, and count the number of drives in the library.

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        HANDLE hSession = m_SessionHandle;

        NTMS_OBJECTINFORMATION mediaPoolInfo;
        NTMS_GUID poolId = mediaPoolId;

        memset(&mediaPoolInfo, 0, sizeof(NTMS_OBJECTINFORMATION));

        mediaPoolInfo.dwType = NTMS_MEDIA_POOL;
        mediaPoolInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);

        // NTMS - Get Media Pool Information
        WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
        DWORD errCode = GetNtmsObjectInformation( hSession, &poolId, &mediaPoolInfo );
        if ( errCode != NO_ERROR ) {

            WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                OLESTR("GetNtmsObjectInformation"),
                WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                NULL );

            WsbThrow( E_UNEXPECTED );

        }

        NTMS_GUID mediaTypeId = mediaPoolInfo.Info.MediaPool.MediaType;

        NTMS_OBJECTINFORMATION libInfo;
        HANDLE hFindLib = NULL;
        int driveCount = 0;

        hr = findFirstNtmsObject( NTMS_LIBRARY,
            GUID_NULL, NULL, GUID_NULL, &hFindLib, &libInfo);
        while( S_OK == hr ) {
            HANDLE hFindLib2 = NULL;
            // now see if the library in which the drive is contained supported
            // the specified media type

            if ( libInfo.Info.Library.dwNumberOfDrives > 0 ) {
                hr = findFirstNtmsObject( NTMS_MEDIA_TYPE,
                    libInfo.ObjectGuid, NULL, mediaTypeId, &hFindLib2, NULL);
                WsbTrace(OLESTR("Searching <%ls> for media type and drives; hr = %ls (state = %d, enabled = %ls, drives = %d)\n"),
                    libInfo.szName, WsbHrAsString(hr),
                    libInfo.dwOperationalState,
                    WsbBoolAsString(libInfo.Enabled),
                    libInfo.Info.Library.dwNumberOfDrives);
                if ((S_OK == hr) &&
                    ((NTMS_READY == libInfo.dwOperationalState) ||
                     (NTMS_INITIALIZING == libInfo.dwOperationalState)) &&
                    (libInfo.Enabled)) {

                    driveCount += libInfo.Info.Library.dwNumberOfDrives;
                }
                findCloseNtmsObject( hFindLib2 );
            }

            hr = findNextNtmsObject( hFindLib, &libInfo );
        }
        findCloseNtmsObject( hFindLib );

        hr = (driveCount > 1) ? S_OK : S_FALSE;

    }  WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::IsMediaCopySupported"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP 
CRmsNTMS::UpdateDrive(
        IN IRmsDrive *pDrive)
/*++

Implements:

    IRmsNTMS::UpdateDrive

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IRmsComObject>  pObject;
    GUID                    driveId;
    DWORD                   err1 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::UpdateDrive"), OLESTR(""));

    try	{
		// get drive information
        WsbAffirmHr(pDrive->QueryInterface(IID_IRmsComObject, (void **)&pObject));
        WsbAffirmHr(pObject->GetObjectId(&driveId));

        NTMS_OBJECTINFORMATION objectInfo;
        objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        objectInfo.dwType = NTMS_DRIVE;
		WsbAssert(driveId != GUID_NULL, E_INVALIDARG);
        err1 = GetNtmsObjectInformation( m_SessionHandle, &driveId, &objectInfo );
        WsbAffirmNoError (err1);

        // Note: Currently, the method updates only the enable/disable state of the drive
        //          If required, the method may update more fields
		if (objectInfo.Enabled) {
            WsbAffirmHr(pObject->Enable());
        } else {
            WsbAffirmHr(pObject->Disable(S_OK));
        }

	}  WsbCatchAndDo(hr,
		// Process the error of the get-info request
		if (err1 != NO_ERROR ) {
            if (err1 == ERROR_OBJECT_NOT_FOUND) {
                hr = RMS_E_NTMS_OBJECT_NOT_FOUND;
            }
            WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
				OLESTR("GetNtmsObjectInformation (Drive)"), OLESTR(""),
				WsbHrAsString(hr), NULL);
        }
	);

    WsbTraceOut(OLESTR("CRmsNTMS::UpdateDrive"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CRmsNTMS::GetNofAvailableDrives( 
    OUT DWORD* pdwNofDrives 
    )

/*++

Implements:

  IRmsNTMS::GetNofAvailableDrives().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CRmsNTMS::GetNofAvailableDrives"), OLESTR(""));

    *pdwNofDrives = 0;
    
    // Enumerate over all libraries that HSM uses
    //  (Outside the try block, since we want to continue if a failure occur on a specific library)
    WsbTrace(OLESTR("CRmsNTMS::GetNofAvailableDrives: Total number of libraries is %lu\n"), m_dwNofLibs);
    for (int j=0; j<(int)m_dwNofLibs; j++) {

        LPNTMS_GUID     pObjects = NULL;
        DWORD           errCode = NO_ERROR;

        // get library id
        GUID libId = m_pLibGuids[j];

        try {

            // Enumerate on all drives in the library
            DWORD       dwNofObjects = 16;  // Initial size of object id array to allocate
            int         nRetry = 0;

            // Allocate according to 
            pObjects = (LPNTMS_GUID)WsbAlloc( dwNofObjects*sizeof(NTMS_GUID) );
            WsbAffirmPointer( pObjects );

            // Enumerate all drives
            do {
                errCode = EnumerateNtmsObject(m_SessionHandle, &libId, pObjects, &dwNofObjects, NTMS_DRIVE, 0);
                WsbTraceAlways(OLESTR("CRmsNTMS::GetNofAvailableDrives: Total number of drives is %lu\n"),
                                dwNofObjects);
                nRetry++;

                if ( (ERROR_OBJECT_NOT_FOUND == errCode) || (0 == dwNofObjects) ) {  // Don't count on NTMS returning the correct errCode
                    // Not considered as an NTMS error, prevent logging by setting to NO_ERROR
                    errCode = NO_ERROR;
                    WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
                } else if (ERROR_INSUFFICIENT_BUFFER == errCode) {
                    // Don't retry more than 3 times
                    if (3 <= nRetry) {
                        WsbThrow(HRESULT_FROM_WIN32(errCode));
                    }

                    // Allocate a new buffer, and retry.
                    WsbTrace(OLESTR("CRmsNTMS::GetNofAvailableDrives: Reallocating buffer\n"));
                    LPVOID pTemp = WsbRealloc( pObjects, dwNofObjects*sizeof(NTMS_GUID) );
                    if (!pTemp) {
                        WsbThrow(E_OUTOFMEMORY);
                    }
                    pObjects = (LPNTMS_GUID)pTemp;
                } else {
                    // Other unexpected error
                    WsbAffirmNoError(errCode);
                }

            } while (ERROR_INSUFFICIENT_BUFFER == errCode);

            // go over all drives, get information and check availablity
            for (int i = 0; i < (int)dwNofObjects; i++) {

                GUID driveId = pObjects[i];
                try {
                    NTMS_OBJECTINFORMATION objectInfo;
                    memset( &objectInfo, 0, sizeof(NTMS_OBJECTINFORMATION) );
                    objectInfo.dwSize = sizeof(NTMS_OBJECTINFORMATION);
                    objectInfo.dwType = NTMS_DRIVE;
        		    WsbAssert(driveId != GUID_NULL, E_INVALIDARG);
                    errCode = GetNtmsObjectInformation(m_SessionHandle, &driveId, &objectInfo );
                    WsbAffirmNoError (errCode);

                    WsbTrace(OLESTR("CRmsNTMS::GetNofAvailableDrives: drive <%ls> enable/disable = %ls\n"),
                            WsbGuidAsString(driveId), WsbBoolAsString(objectInfo.Enabled));
                       
		            if (objectInfo.Enabled) {
                        (*pdwNofDrives)++;
                    }

	            }  WsbCatchAndDo(hr,
		            // Log error and go on to the next drive
        		    if (errCode != NO_ERROR ) {
                        WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
    		    		    OLESTR("GetNtmsObjectInformation (Drive)"), OLESTR(""),
       			    	    WsbHrAsString(hr), NULL);
                    }

                    WsbTraceAlways(OLESTR("CRmsNTMS::GetNofAvailableDrives: Failed to get info for drive <%ls> hr = <%ls>\n"),
                            WsbGuidAsString(driveId), WsbHrAsString(hr));
                    hr = S_OK;
	            );        
            }

        } WsbCatchAndDo(hr,
            // Log error and go on to the next library
        	if (errCode != NO_ERROR ) {
                WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
    		        OLESTR("EnumerateNtmsObject (Drive)"), OLESTR(""),
       			    WsbHrAsString(hr), NULL);
            }

            WsbTraceAlways(OLESTR("CRmsNTMS::GetNofAvailableDrives: Failed to enumerate drives in library <%ls> hr = <%ls>\n"),
                    WsbGuidAsString(libId), WsbHrAsString(hr));
            hr = S_OK;
        );        

        if (pObjects) {
            WsbFree(pObjects);
        }

    }   // of for


    WsbTraceOut(OLESTR("CRmsNTMS::GetNofAvailableDrives"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CRmsNTMS::CheckSecondSide( 
    IN REFGUID firstSideId,
    OUT BOOL *pbValid,
    OUT GUID *pSecondSideId
    )

/*++

Implements:

  IRmsNTMS::CheckSecondSide().

--*/
{
    HRESULT         hr = S_OK;
    DWORD           err1 = NO_ERROR;
    DWORD           err2 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::CheckSecondSide"), OLESTR(""));

    *pbValid = FALSE;
    *pSecondSideId = GUID_NULL;

    try {

        WsbAssert(firstSideId != GUID_NULL, E_INVALIDARG);
        WsbAssertPointer(pbValid);
        WsbAssertPointer(pSecondSideId);

        NTMS_OBJECTINFORMATION partitionInfo;
        memset( &partitionInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        NTMS_OBJECTINFORMATION mediaInfo;
        memset( &mediaInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        HANDLE hSession = m_SessionHandle;
        NTMS_GUID mediaId = firstSideId;
        NTMS_GUID firstSidePartitionId;
        NTMS_GUID side[2];
        DWORD sideNo = 2;


        // NTMS - get Partition from LMID
        WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
        err1 = EnumerateNtmsObject(hSession, &mediaId, side, &sideNo, NTMS_PARTITION, 0);
        WsbAffirmNoError(err1);
        firstSidePartitionId = side[0];

        // NTMS - get partition information (using size 0 - LMID relates 1:1 to Partition
        partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        partitionInfo.dwType = NTMS_PARTITION;

        WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
        err2 = GetNtmsObjectInformation(hSession, &firstSidePartitionId, &partitionInfo);
        WsbAffirmNoError(err2);

        // NTMS - get physical media information
        NTMS_GUID physicalMediaId = partitionInfo.Info.Partition.PhysicalMedia;
        mediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;

        WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
        err2 = GetNtmsObjectInformation(hSession, &physicalMediaId, &mediaInfo);
        WsbAffirmNoError(err2);

        // Check whether there are more than one side
        if (mediaInfo.Info.PhysicalMedia.dwNumberOfPartitions > 1) {
            // Enumerate physical meida - expect 2 sides here.
            WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
            sideNo = 2;
            err1 = EnumerateNtmsObject(hSession, &physicalMediaId, side, &sideNo, NTMS_PARTITION, 0);
            WsbAffirmNoError(err1);
            WsbAffirm(sideNo > 1, RMS_E_NOT_FOUND);

            // Look for a side whos partition id is different from first side
            for (DWORD i=0; i<sideNo; i++) {
                if (firstSidePartitionId != side[i]) {
                    *pbValid = TRUE;    // Valid second side found

                    // Get its LMID
                    WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                    err2 = GetNtmsObjectInformation(hSession, &side[i], &partitionInfo);
                    WsbAffirmNoError(err2);

                    *pSecondSideId = partitionInfo.Info.Partition.LogicalMedia;
                }
            }
        } // of if two sides

    } WsbCatchAndDo( hr,
            WsbTrace(OLESTR("CRmsNTMS::CheckSecondSide - of %ls failed: hr = <%ls>\n"),WsbGuidAsString(firstSideId),WsbHrAsString(hr));
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Unexpected Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Unexpected Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );
        
    WsbTraceOut(OLESTR("CRmsNTMS::CheckSecondSide"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsNTMS::EnsureAllSidesNotAllocated(
    IN REFGUID mediaId
    )
{
    HRESULT     hr = S_OK;
    DWORD       err1 = NO_ERROR;
    DWORD       err2 = NO_ERROR;

    WsbTraceIn(OLESTR("CRmsNTMS::EnsureAllSidesNotAllocated"), OLESTR(""));

    try {
        WsbAssert(mediaId != GUID_NULL, E_INVALIDARG);

        NTMS_OBJECTINFORMATION partitionInfo;
        memset( &partitionInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );
        NTMS_OBJECTINFORMATION mediaInfo;
        memset( &mediaInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        HANDLE hSession = m_SessionHandle;

        NTMS_GUID physicalMediaId = mediaId;
        mediaInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        mediaInfo.dwType = NTMS_PHYSICAL_MEDIA;
        partitionInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );
        partitionInfo.dwType = NTMS_PARTITION;

        WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PHYSICAL_MEDIA)\n"));
        err2 = GetNtmsObjectInformation(hSession, &physicalMediaId, &mediaInfo);
        WsbAffirmNoError(err2);

        // Check whether there are more than one side
        if (mediaInfo.Info.PhysicalMedia.dwNumberOfPartitions > 1) {
            // Enumerate physical meida - expect 2 sides here.
            NTMS_GUID side[2];
            DWORD sideNo = 2;
            WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
            err1 = EnumerateNtmsObject(hSession, &physicalMediaId, side, &sideNo, NTMS_PARTITION, 0);
            WsbAffirmNoError(err1);

            // Look for a side which is allocated
            for (DWORD i=0; i<sideNo; i++) {
                WsbTraceAlways(OLESTR("GetNtmsObjectInformation(NTMS_PARTITION)\n"));
                err2 = GetNtmsObjectInformation(hSession, &side[i], &partitionInfo);
                WsbAffirmNoError(err2);

                if (GUID_NULL != partitionInfo.Info.Partition.LogicalMedia) {
                    hr = S_FALSE;
                    break;
                }
            }
        } // of if two sides

    } WsbCatchAndDo( hr,
            WsbTrace(OLESTR("CRmsNTMS::EnsureAllSidesNotAllocated - of %ls failed: hr = <%ls>\n"),WsbGuidAsString(mediaId),WsbHrAsString(hr));
            if (err1 != NO_ERROR ) {
                // EnumerateNtmsObject
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_PARAMETER:
                case ERROR_INVALID_HANDLE:
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_INSUFFICIENT_BUFFER:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("EnumerateNtmsObject"), OLESTR("Unexpected Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
            else if (err2 != NO_ERROR) {
                // GetNtmsObjectInformation
                switch (HRESULT_CODE(hr)) {
                case ERROR_OBJECT_NOT_FOUND:
                    hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    break;

                case ERROR_INVALID_HANDLE:
                case ERROR_INVALID_PARAMETER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR(""),
                        WsbHrAsString(hr), NULL);
                    break;

                default:
                    WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                        OLESTR("GetNtmsObjectInformation"), OLESTR("Unexpected Error: "),
                        WsbHrAsString(hr), NULL);
                    break;
                }
            }
        );

    WsbTraceOut(OLESTR("CRmsNTMS::EnsureAllSidesNotAllocated"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

STDMETHODIMP 
CRmsNTMS::DismountAll(
    IN REFGUID fromMediaSet,
    IN DWORD dwOptions)
/*++

Implements:

    IRmsNTMS::DismountAll

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn( OLESTR("CRmsNTMS::DismountAll"), OLESTR("") );

    try {
        WsbAssert(GUID_NULL != fromMediaSet, E_INVALIDARG);

        HANDLE hFindMedia = NULL;
        DWORD err1 = NO_ERROR;
        HANDLE hSession = m_SessionHandle;
        NTMS_OBJECTINFORMATION physicalMediaInfo;
        NTMS_GUID setId = fromMediaSet;
        NTMS_GUID partId = GUID_NULL;

        // Dismount all mounted medias from the given pool

        hr = findFirstNtmsObject(NTMS_PHYSICAL_MEDIA, setId, NULL, GUID_NULL, &hFindMedia, &physicalMediaInfo);
        while(S_OK == hr) {
            switch (physicalMediaInfo.Info.PhysicalMedia.MediaState) {
                case NTMS_MEDIASTATE_LOADED:
                case NTMS_MEDIASTATE_MOUNTED:
                    // Dismount the media
                    try {
                        partId = physicalMediaInfo.Info.PhysicalMedia.MountedPartition;
                        WsbAffirm(GUID_NULL != partId, E_UNEXPECTED);

                        DWORD dwNtmsOptions = 0;
                        WsbTraceAlways(OLESTR("DismountNtmsMedia()\n"));
				        if (! ( dwOptions & RMS_DISMOUNT_IMMEDIATE )) {
					        dwNtmsOptions |= NTMS_DISMOUNT_DEFERRED;
				        }
                        err1 = DismountNtmsMedia(hSession, &partId, 1, dwNtmsOptions);
                        WsbAffirmNoError(err1);

                    } WsbCatchAndDo(hr,
                        if (err1 != NO_ERROR) {
                            WsbLogEvent(RMS_MESSAGE_NTMS_FAULT, 0, NULL,
                                OLESTR("DismountNtmsMedia"), OLESTR(""),
                                WsbHrAsString(hr), NULL);
                        }
                    );

                    break;

                default:
                    // Media is not mounted - skip it
                    break;
            }

            hr = findNextNtmsObject(hFindMedia, &physicalMediaInfo);
       } 

       findCloseNtmsObject(hFindMedia);
       hr = S_OK;

    } WsbCatch(hr);

    WsbTraceOut( OLESTR("CRmsNTMS::DismountAll"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsobjct.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsObjct.cpp

Abstract:

    Implementation of CRmsComObject

Author:

    Brian Dodd      [brian]     15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsObjct.h"

/////////////////////////////////////////////////////////////////////////////
//


CRmsComObject::CRmsComObject(void)
/*++

Routine Description:

    CRmsComObject constructor

Arguments:

    None

Return Value:

    None

--*/
{
    // Default values
    (void) CoCreateGuid( &m_objectId );

    m_ObjectType    = RmsObjectUnknown;
    m_IsEnabled     = TRUE;
    m_State         = 0;
    m_StatusCode    = S_OK;
    m_Name          = OLESTR("Object");
    m_Description   = OLESTR("");

    memset( &m_Permit, 0, sizeof( SECURITY_DESCRIPTOR ) );

    m_findBy        = RmsFindByUnknown;

}


HRESULT
CRmsComObject::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    CRmsComObject::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsComObject::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsComObject interface to get the value of the object.
        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByObjectId:
        default:
            {
                GUID objectId;

                // Get objectId.
                WsbAffirmHr( pObject->GetObjectId( &objectId ));

                if ( m_objectId == objectId ) {

                    // Object IDs match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }
            }
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsComObject::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsComObject::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize)
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsComObject::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(GUID) +           // m_objectId
//                             WsbPersistSizeOf(LONG) +           // m_findBy
//                             WsbPersistSizeOf(LONG) +           // m_state
//                             WsbPersistSizeOf(HRESULT);         // m_errCode

////                           WsbPersistSizeOf(SECURITY_DESCRIPTOR); // m_permit

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsComObject::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return hr;
}


HRESULT
CRmsComObject::Load(
    IN IStream* pStream)
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsComObject::Load"), OLESTR(""));

    try {
        WsbAssertPointer( pStream );

        USHORT usTemp;
        ULONG  ulTemp;

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &usTemp));
        m_ObjectType = (RmsObject)usTemp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_IsEnabled));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_State));
        WsbAffirmHr(WsbLoadFromStream(pStream, &ulTemp));
        m_StatusCode = (HRESULT)ulTemp;

        m_Name.Free(); // Clean out any thing previously held
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_Name));
        m_Description.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_Description));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_permit));

        WsbAffirmHr(WsbLoadFromStream(pStream, &usTemp));
        m_findBy = (RmsFindBy)usTemp;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsComObject::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsComObject::Save(
    IN IStream* pStream,
    IN BOOL clearDirty)
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsComObject::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssertPointer( pStream );

        // Read value
        WsbAffirmHr(WsbSaveToStream(pStream, m_objectId));
        WsbAffirmHr(WsbSaveToStream(pStream, (USHORT) m_ObjectType));
        WsbAffirmHr(WsbSaveToStream(pStream, m_IsEnabled));
        WsbAffirmHr(WsbSaveToStream(pStream, m_State));
        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_StatusCode));
        WsbAffirmHr(WsbBstrToStream(pStream, m_Name));
        WsbAffirmHr(WsbBstrToStream(pStream, m_Description));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_permit));

        WsbAffirmHr(WsbSaveToStream(pStream, (USHORT) m_findBy));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsComObject::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsComObject::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed)
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>    pMediaSet1;
    CComPtr<IRmsMediaSet>    pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longWork1;
    LONG                    longWork2;

    HRESULT                 hresultVal1 = 11111111;
    HRESULT                 hresultWork1;

//  SECURITY_DESCRIPTOR     permitVal1;
//  SECURITY_DESCRIPTOR     permitWork1;


    WsbTraceIn(OLESTR("CRmsComObject::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            // Test SetState & GetState
            for (i = RmsStateUnknown; i < RmsStateError; i++){

                longWork1 = i;

                SetState (longWork1);

                GetState (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test GetErrCode
            m_StatusCode = hresultVal1;

            GetStatusCode(&hresultWork1);

            if(hresultVal1 == hresultWork1){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test SetPermissions & GetPermissions
//          SetPermissions(permitVal1);

//          GetPermissions(&permitWork1);

//          if((permitVal1 == permitWork1)){
//             (*pPassed)++;
//          }  else {
//              (*pFailed)++;
//          }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsComObject::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsComObject::InterfaceSupportsErrorInfo(
    IN REFIID riid)
/*++

Implements:

    ISupportsErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] =
    {
    &IID_IRmsServer,
    &IID_IRmsLibrary,
    &IID_IRmsDriveClass,
    &IID_IRmsCartridge,
    &IID_IRmsDrive,
    &IID_IRmsStorageSlot,
    &IID_IRmsMediumChanger,
    &IID_IRmsIEPort,
    &IID_IRmsMediaSet,
    &IID_IRmsRequest,
    &IID_IRmsPartition,
    &IID_IRmsComObject,
    &IID_IRmsChangerElement,
    &IID_IRmsDevice,
    &IID_IRmsStorageInfo,
    &IID_IRmsNTMS,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
    if (InlineIsEqualGUID(*arr[i],riid))
        return S_OK;
    }
    return S_FALSE;
}


STDMETHODIMP
CRmsComObject::GetObjectId(
    OUT GUID *pObjectId)
/*++

Implements:

    IRmsComObject::GetObjectId

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pObjectId );

        *pObjectId = m_objectId;

    } WsbCatch(hr);

    return hr;
}



STDMETHODIMP
CRmsComObject::SetObjectId(
    IN GUID objectId)
/*++

Implements:

    IRmsComObject::SetObjectId

--*/
{
    m_objectId = objectId;
    return S_OK;
}

STDMETHODIMP
CRmsComObject::GetObjectType(
    OUT LONG *pType)
/*++

Implements:

    IRmsComObject::GetObjectType

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pType );

        *pType = m_ObjectType;

    } WsbCatch(hr);

    return hr;
}



STDMETHODIMP
CRmsComObject::SetObjectType(
    IN LONG type)
/*++

Implements:

    IRmsComObject::SetObjectType

--*/
{
    m_ObjectType = (RmsObject) type;
    return S_OK;
}


STDMETHODIMP
CRmsComObject::IsEnabled(void)
/*++

Implements:

    IRmsComObject::IsEnabled

--*/
{
    return (m_IsEnabled) ? S_OK : S_FALSE;
}


STDMETHODIMP
CRmsComObject::Enable()
/*++

Implements:

    IRmsComObject::Enable

--*/
{
    HRESULT hr = S_OK;

    try {

        m_IsEnabled = TRUE;
        WsbAffirmHr(SetStatusCode(S_OK));

        // Log an Event
        WsbLogEvent(RMS_MESSAGE_OBJECT_ENABLED, 0, NULL, (WCHAR *)m_Name, NULL );

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::Disable(
    IN HRESULT reason)
/*++

Implements:

    IRmsComObject::Disable

--*/
{
    HRESULT hr = S_OK;

    try {

        m_IsEnabled = FALSE;
        WsbAffirmHr(SetStatusCode(reason));

        // Log an Event
        WsbLogEvent(RMS_MESSAGE_OBJECT_DISABLED, 0, NULL, (WCHAR *)m_Name, WsbHrAsString(reason), NULL );

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::GetState(
    OUT LONG *pState)
/*++

Implements:

    IRmsComObject::GetState

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pState );

        *pState = m_State;
        WsbTrace(OLESTR("GetState: Object <0x%08x> - Enabled = <%ls>; State = <%d>; StatusCode = <%ls>.\n"),
            this, WsbBoolAsString(m_IsEnabled), m_State, WsbHrAsString(m_StatusCode));

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::SetState(
    IN LONG state)
/*++

Implements:

    IRmsComObject::SetState

--*/
{
    HRESULT hr = S_OK;

    try {

        m_State = state;
        WsbAffirmHr(SetStatusCode(S_OK));

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::GetStatusCode(
    OUT HRESULT *pResult)
/*++

Implements:

    IRmsComObject::GetStatusCode

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pResult );

        *pResult = m_StatusCode;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::SetStatusCode(
    IN HRESULT result
    )
/*++

Implements:

    IRmsComObject::SetStatusCode

--*/
{
    HRESULT hr = S_OK;

    try {

        m_StatusCode = result;
        WsbAffirmHr(adviseOfStatusChange());

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::GetName(
    OUT BSTR *pName)
/*++

Implements:

    IRmsComObject::GetName

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pName );

        WsbAffirmHr( m_Name.CopyToBstr(pName) );

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CRmsComObject::SetName(
    IN BSTR name)
/*++

Implements:

    IRmsComObject::SetName

--*/
{
    m_Name = name;
    return S_OK;
}


STDMETHODIMP
CRmsComObject::GetDescription(
    OUT BSTR *pDesc)
/*++

Implements:

    IRmsComObject::GetDescription

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pDesc );

        WsbAffirmHr( m_Name.CopyToBstr(pDesc) );

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CRmsComObject::SetDescription(
    IN BSTR desc)
/*++

Implements:

    IRmsComObject::SetDescription

--*/
{
    m_Description = desc;
    return S_OK;
}


STDMETHODIMP
CRmsComObject::GetPermissions(
    OUT SECURITY_DESCRIPTOR *lpPermit)
/*++

Implements:

    IRmsComObject::GetPermissions

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( lpPermit );

        *lpPermit = m_Permit;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::SetPermissions(
    IN SECURITY_DESCRIPTOR permit)
/*++

Implements:

    IRmsComObject::GetPermissions

--*/
{

    m_Permit = permit;
    return S_OK;
}


STDMETHODIMP
CRmsComObject::GetFindBy(
    OUT LONG *pFindBy)
/*++

Implements:

    IRmsComObject::GetFindBy

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( pFindBy );

        *pFindBy = m_findBy;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsComObject::SetFindBy(
    IN LONG findBy)
/*++

Implements:

    IRmsComObject::SetFindBy

--*/
{
    m_findBy = (RmsFindBy) findBy;
    return S_OK;
}


HRESULT
CRmsComObject::adviseOfStatusChange(void)
/*++

Routine Description:

    Notifies of object state changes. 

Arguments:

    None

Return Value:

    S_OK            - Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( OLESTR("CRmsComObject::adviseOfStatusChange"), OLESTR(""));

    try {
        CONNECTDATA                         pConnectData;
        CComPtr<IConnectionPoint>           pCP;
        CComPtr<IConnectionPointContainer>  pCPC;
        CComPtr<IEnumConnections>           pConnection;
        CComPtr<IRmsSinkEveryEvent>         pSink;

        WsbTrace(OLESTR("Object <0x%08x> - Enabled = <%ls>; State = <%d>; StatusCode = <%ls>.\n"),
            this, WsbBoolAsString(m_IsEnabled), m_State, WsbHrAsString(m_StatusCode));

        // Tell everyone the new state of the object.
        WsbAffirmHr(((IUnknown*)(IRmsComObject*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IRmsSinkEveryEvent, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IRmsSinkEveryEvent, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessObjectStatusChange( m_IsEnabled, m_State, m_StatusCode ));
            } WsbCatch(hr);

            (pConnectData.pUnk)->Release();
            pSink=0;
        }

    } WsbCatch(hr);

    // We don't care if the sink has problems!
    hr = S_OK;

    WsbTraceOut(OLESTR("CRmsComObject::adviseOfStatusChange"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmspartn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsPartn.cpp

Abstract:

    Implementation of CRmsPartition

Author:

    Brian Dodd          [brian]         19-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsPartn.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsPartition::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsPartition::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsPartition interface to get the value of the object.
        CComQIPtr<IRmsPartition, &IID_IRmsPartition> pPartition = pCollectable;
        WsbAssertPointer( pPartition );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByPartitionNumber:
            {
                LONG    partNo;

                WsbAffirmHr( pPartition->GetPartNo( &partNo ) );

                if( m_partNo == partNo ) {

                    // partition numbers match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }
                break;
            }

        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsPartition::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsPartition::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_partNo = 0;

        m_attributes = RmsAttributesUnknown;

        m_sizeofIdentifier = 0;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsPartition::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsPartition::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsPartition;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsPartition::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsPartition::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart = WsbPersistSizeOf(LONG) +        // m_partNo
//                            WsbPersistSizeOf(LONG) +        // m_attributes
//                            WsbPersistSizeOf(SHORT);        // m_sizeofIdentifier

////                          MaxId;                          // m_pIdentifier


//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsPartition::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsPartition::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsStorageInfo::Load(pStream));

        // Read value

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_partNo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_attributes = (RmsAttribute)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_sizeofIdentifier));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsPartition::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsPartition::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsStorageInfo::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_partNo));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_attributes));

        WsbAffirmHr(WsbSaveToStream(pStream, m_sizeofIdentifier));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsPartition::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IRmsPartition>  pPartition1;
    CComPtr<IRmsPartition>  pPartition2;
    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longWork1;
    LONG                    longWork2;

    WsbTraceIn(OLESTR("CRmsPartition::Test"), OLESTR(""));

    try {
        // Get the Partition interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsPartition*) this)->QueryInterface(IID_IRmsPartition, (void**) &pPartition1));

            // Test SetAttributes & GetAttributes
            for (i = RmsAttributesUnknown; i < RmsAttributesVerify; i++){

                longWork1 = i;

                SetAttributes(longWork1);

                GetAttributes(&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsPartition::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsPartition::GetPartNo(
    LONG    *pPartNo
    )
/*++

Implements:

    IRmsPartition::GetPartNo

--*/
{
    *pPartNo = m_partNo;
    return S_OK;
}


STDMETHODIMP
CRmsPartition::GetAttributes (
    LONG    *pAttr
    )
/*++

Implements:

    IRmsPartition::GetAttributes

--*/
{
    *pAttr = (LONG) m_attributes;
    return S_OK;
}


STDMETHODIMP
CRmsPartition::SetAttributes (
    LONG  attr
    )
/*++

Implements:

    IRmsPartition::SetAttributes

--*/
{
    m_attributes = (RmsAttribute) attr;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsPartition::GetIdentifier (
    UCHAR   *pIdent,
    SHORT   *pSize
    )
/*++

Implements:

    IRmsPartition::GetIdentifier

--*/
{
    *pSize = m_sizeofIdentifier;
    memmove (pIdent, m_pIdentifier, m_sizeofIdentifier);
    return S_OK;
}


STDMETHODIMP
CRmsPartition::SetIdentifier (
    UCHAR   *pIdent,
    SHORT   size
    )
/*++

Implements:

    IRmsPartition::SetIdentifier

--*/
{
    m_sizeofIdentifier = size;
    memmove (m_pIdentifier, pIdent, size);
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsPartition::GetStorageInfo(
    IRmsStorageInfo** /*ptr*/
    )
/*++

Implements:

    IRmsPartition::GetStorageInfo

--*/
{

    return S_OK;
}


STDMETHODIMP
CRmsPartition::VerifyIdentifier(
    void
    )
/*++

Implements:

    IRmsPartition::VerifyIdentifier

--*/
{

    return S_OK;
}


STDMETHODIMP
CRmsPartition::ReadOnMediaId(
    UCHAR* /*pid*/,
    LONG* /*pSize*/
    )
/*++

Implements:

    IRmsPartition::ReadOnMediaId

--*/
{

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsobjct.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsObjct.h

Abstract:

    Declaration of the CRmsComObject class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSOBJCT_
#define _RMSOBJCT_

#include "resource.h"       // resource symbols

/*++

Class Name:

    CRmsComObject

Class Description:

    A CRmsComObject is the base class for all Rms service COM objects.  This
    object holds state, security, and error information about an Rms object.

--*/

class CRmsComObject :
    public CComDualImpl<IRmsComObject, &IID_IRmsComObject, &LIBID_RMSLib>,
    public ISupportErrorInfo
{
// CRmsComObject
public:
    CRmsComObject();

    HRESULT GetSizeMax(OUT ULARGE_INTEGER* pSize);
    HRESULT Load(IN IStream* pStream);
    HRESULT Save(IN IStream* pStream, IN BOOL clearDirty);

    HRESULT CompareTo( IN IUnknown* pCollectable, OUT SHORT* pResult);

    HRESULT Test(OUT USHORT *pPassed, OUT USHORT *pFailed);

// ISupportsErrorInfo
public:
    STDMETHOD(InterfaceSupportsErrorInfo)(IN REFIID riid);

// IRmsComObject
public:
    STDMETHOD(GetObjectId)(OUT GUID *pObjectId);
    STDMETHOD(SetObjectId)(IN GUID objectId);

    STDMETHOD(GetObjectType)(OUT LONG *pType);
    STDMETHOD(SetObjectType)(IN LONG type);

    STDMETHOD(IsEnabled)(void);
    STDMETHOD(Enable)();
    STDMETHOD(Disable)(IN HRESULT reason);

    STDMETHOD(GetState)(OUT LONG *pState);
    STDMETHOD(SetState)(IN LONG state);

    STDMETHOD(GetStatusCode)(OUT HRESULT *pResult);
    STDMETHOD(SetStatusCode)(IN HRESULT result);

    STDMETHOD(GetName)(OUT BSTR *pName);
    STDMETHOD(SetName)(IN BSTR name);

    STDMETHOD(GetDescription)(OUT BSTR *pName);
    STDMETHOD(SetDescription)(IN BSTR name);

    STDMETHOD(GetPermissions)(OUT SECURITY_DESCRIPTOR *lpPermit);
    STDMETHOD(SetPermissions)(IN SECURITY_DESCRIPTOR permit);

    STDMETHOD(GetFindBy)(OUT LONG *pFindBy);
    STDMETHOD(SetFindBy)(IN LONG findBy);

////////////////////////////////////////////////////////////////////////////////////////
//
// data members
//
protected:
    GUID                    m_objectId;         // Unique ID for this object.
    RmsObject               m_ObjectType;       // The type of object.
    BOOL                    m_IsEnabled;        // TRUE, if the object is enabled for normal
                                                //   processing.
    LONG                    m_State;            // The current operating state of the object.
                                                //   Varies by object type.  See RmsXXXState.
    HRESULT                 m_StatusCode;       // S_OK if the object is enabled for normal
                                                //   processing, otherwise this holds the
                                                //   result code, or reason, associated with
                                                //   the disabled object.  This result is
                                                //   returned whenever normal processing
                                                //   on the object is attempted while object
                                                //   is disabled.
    CWsbBstrPtr             m_Name;             // Name of the object.
    CWsbBstrPtr             m_Description;      // Description for the object.
    SECURITY_DESCRIPTOR     m_Permit;           // Defines security attributes of the object.
    RmsFindBy               m_findBy;           // Defines the type of CompareTo to perform
                                                //   when searching a collection.
////////////////////////////////////////////////////////////////////////////////////////
//
// local methods
//
private:
    HRESULT adviseOfStatusChange(void);
};

#endif // _RMSOBJCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsmdset.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsMdSet.h

Abstract:

    Declaration of the CRmsMediaSet class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSMDSET_
#define _RMSMDSET_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsSInfo.h"       // CRmsStorageInfo

/*++

Class Name:

    CRmsMediaSet

Class Description:

    A CRmsMediaSet is a logical repository for Cartridges.

--*/

class CRmsMediaSet :
    public CComDualImpl<IRmsMediaSet, &IID_IRmsMediaSet, &LIBID_RMSLib>,
    public CRmsStorageInfo,     // inherits CRmsComObject
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsMediaSet,&CLSID_CRmsMediaSet>
{
public:
    CRmsMediaSet() {}
BEGIN_COM_MAP(CRmsMediaSet)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsMediaSet)
    COM_INTERFACE_ENTRY(IRmsMediaSet)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsStorageInfo)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsMediaSet)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsMediaSet
public:
    STDMETHOD(GetMediaSetId)(GUID *pMediaSetId);

    STDMETHOD(GetName)(BSTR *pName);
    STDMETHOD(SetName)(BSTR name);

    STDMETHOD(GetMediaSupported)(LONG *pType);
    STDMETHOD(SetMediaSupported)(LONG type);

    STDMETHOD(GetInfo)(UCHAR *pInfo, SHORT *pSize);
    STDMETHOD(SetInfo)(UCHAR *pInfo, SHORT size);

    STDMETHOD(GetOwnerClassId)(CLSID *pClassId);
    STDMETHOD(SetOwnerClassId)(CLSID classId);

    STDMETHOD(GetMediaSetType)(LONG *pType);
    STDMETHOD(SetMediaSetType)(LONG type);

    STDMETHOD(GetMaxCartridges)(LONG *pNum);
    STDMETHOD(SetMaxCartridges)(LONG num);

    STDMETHOD(GetOccupancy)(LONG *pNum);
    STDMETHOD(SetOccupancy)(LONG num);

    STDMETHOD(IsMediaCopySupported)();
    STDMETHOD(SetIsMediaCopySupported)(BOOL flag);

    STDMETHOD(Allocate)(
        IN REFGUID prevSideId,
        IN OUT LONGLONG *pFreeSpace,
        IN BSTR displayName,
        IN DWORD dwOptions,
        OUT IRmsCartridge **ppCart);

    STDMETHOD(Deallocate)(
        IN IRmsCartridge *pCart);

////////////////////////////////////////////////////////////////////////////////////////
//
// data members
//

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = 128,                      // Size of the application specific
                                            //   infomation buffer.  Currently
                                            //   fixed in size.
        };                                  //
    RmsMedia        m_MediaSupported;       // supported media format(s) for this media set.
                                            //   One or more types are permissible, but
                                            //   not all combinations are sensical.
    SHORT           m_SizeOfInfo;           // The size of valid data in the application
                                            //   specific information buffer.
    UCHAR           m_Info[MaxInfo];        // Application specific information.
    CLSID           m_OwnerId;              // the registered Class ID of the
                                            //   application that owns/created the
                                            //   MediaSet.
    RmsMediaSet     m_MediaSetType;         // the type of MediaSet.
    LONG            m_MaxCartridges;        // max number of Cartridges allowed in the
                                            //    MediaSet.
    LONG            m_Occupancy;            // number of Cartridges presently in the
                                            //    MediaSet.
    BOOL            m_IsMediaCopySupported; // TRUE, if the media in the MediaSet can be
                                            //    copied.  This requires simultaneous
                                            //    access to two drives.
};

#endif // _RMSMDSET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmspartn.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsPartn.h

Abstract:

    Declaration of the CRmsPartition class

Author:

    Brian Dodd          [brian]         19-Nov-1996

Revision History:

--*/

#ifndef _RMSPARTN_
#define _RMSPARTN_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsSInfo.h"       // CRmsStorageInfo

/*++

Class Name:

    CRmsPartition

Class Description:

    A CRmsPartition represents a partition on a tape or a single side of
    a unit of optical media.  This object keeps on-media identification
    information, and various statistics about the Partition including:
    capacity, free space, number of physical mounts issued for the
    particular Partition, and the amount of data read or written for the
    Partition.

--*/

class CRmsPartition :
    public CComDualImpl<IRmsPartition, &IID_IRmsPartition, &LIBID_RMSLib>,
    public CRmsStorageInfo,     // inherits CRmsComObject
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsPartition,&CLSID_CRmsPartition>
{
public:
    CRmsPartition() {}
BEGIN_COM_MAP(CRmsPartition)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsPartition)
    COM_INTERFACE_ENTRY(IRmsPartition)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsStorageInfo)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsPartition)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsPartition
public:
    STDMETHOD(GetPartNo)(LONG *pPartNo);

    STDMETHOD(GetAttributes)(LONG *pAttr);
    STDMETHOD(SetAttributes)(LONG attr);

    STDMETHOD(GetIdentifier)(UCHAR *pIdent, SHORT *pSize);
    STDMETHOD(SetIdentifier)(UCHAR *pIdent, SHORT size);

    STDMETHOD(GetStorageInfo)(IRmsStorageInfo **ptr);

    STDMETHOD(VerifyIdentifier)(void);
    STDMETHOD(ReadOnMediaId)(UCHAR *pId, LONG *pSize);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxId = 64,                         // The maximum size of the on-media ID.
                                            //   Note: this restritiction should
                                            //   be eliminated when the DB records
                                            //   are variable length.
        };                                  //
    LONG            m_partNo;               // The partition number or side.
    RmsAttribute    m_attributes;           // Partition attributes (see RmsAttributes).
    SHORT           m_sizeofIdentifier;     // The size of the on-media identifier.
    UCHAR           m_pIdentifier[MaxId];   // The on-media identifier.
};

#endif // _RMSPARTN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsreqst.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsReqst.cpp

Abstract:

    Implementation of CRmsRequest

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsReqst.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsRequest::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsRequest::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsRequest interface to get the value of the object.
        CComQIPtr<IRmsRequest, &IID_IRmsRequest> pRequest = pCollectable;
        WsbAssertPointer( pRequest );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByRequestNo:
            {
                LONG    requestNo;

                WsbAffirmHr(pRequest->GetRequestNo(&requestNo));

                if ( m_requestNo == requestNo ) {

                    // request number matches
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }
            }
            break;

        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsRequest::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsRequest::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_requestNo = 0;

        m_requestDescription = RMS_UNDEFINED_STRING;

        m_isDone = FALSE;

        m_operation = RMS_UNDEFINED_STRING;

//      m_percentComplete = 0;

//      m_startTimestamp = 0;

//      m_stopTimestamp = 0;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsRequest::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsRequest::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsRequest;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsRequest::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       requestDescriptionLen;
//    ULONG       operationLen;

    WsbTraceIn(OLESTR("CRmsRequest::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        requestDescriptionLen = SysStringByteLen(m_requestDescription);
//        operationLen = SysStringByteLen(m_operation);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)   +     // m_requestNo
//                             WsbPersistSizeOf(LONG)   +     // length of m_requestDescription
//                             requestDescriptionLen    +     // m_requestDescription
//                             WsbPersistSizeOf(BOOL)   +     // m_isDone
//                             WsbPersistSizeOf(LONG)   +     // length of m_operation
//                             operationLen             +     // m_operation
//                             WsbPersistSizeOf(BYTE)   +     // m_percentComplete
//                             WsbPersistSizeOf(DATE)   +     // m_startTimestamp
//                             WsbPersistSizeOf(DATE);        // m_stopTimestamp

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsRequest::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsRequest::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_requestNo));

        WsbAffirmHr(WsbBstrFromStream(pStream, &m_requestDescription));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isDone));

        WsbAffirmHr(WsbBstrFromStream(pStream, &m_operation));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_percentComplete));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_startTimestamp));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_stopTimeStamp));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsRequest::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsRequest::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_requestNo));

        WsbAffirmHr(WsbBstrToStream(pStream, m_requestDescription));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isDone));

        WsbAffirmHr(WsbBstrToStream(pStream, m_operation));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_percentComplete));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_startTimestamp));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_stopTimeStamp));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsRequest::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsRequest>    pRequest1;
    CComPtr<IRmsRequest>    pRequest2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrVal2 = OLESTR("A5A5A5");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longWork1;
    LONG                    longWork2;


    WsbTraceIn(OLESTR("CRmsRequest::Test"), OLESTR(""));

    try {
        // Get the Request interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsRequest*) this)->QueryInterface(IID_IRmsRequest, (void**) &pRequest1));

            // Test GetRequestNo
            m_requestNo = 99;
            longWork1 = m_requestNo;

            GetRequestNo(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetRequestDescription & GetRequestDescription interface
            bstrWork1 = bstrVal1;

            SetRequestDescription(bstrWork1);

            GetRequestDescription(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsDone & IsDone to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsDone (TRUE));
                WsbAffirmHr(IsDone ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsDone & IsDone to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsDone (FALSE));
                WsbAffirmHr(IsDone ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetOperation & GetOperation interface
            bstrWork1 = bstrVal1;

            SetOperation(bstrWork1);

            GetOperation(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetPercentComplete & GetPercentComplete

            // Test GetStartTimestamp

            // Test GetStopTimestamp

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsRequest::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsRequest::GetRequestNo(
    LONG   *pRequestNo
    )
/*++

Implements:

    IRmsRequest::GetRequestNo

--*/
{
    *pRequestNo = m_requestNo;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::GetRequestDescription(
    BSTR   *pDesc
    )
/*++

Implements:

    IRmsRequest::GetRequestDescription

--*/
{
    WsbAssertPointer (pDesc);

    m_requestDescription. CopyToBstr (pDesc);
    return S_OK;
}


STDMETHODIMP
CRmsRequest::SetRequestDescription(
    BSTR   desc

    )
/*++

Implements:

    IRmsRequest::SetRequestDescription

--*/
{
    m_requestDescription = desc;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::SetIsDone(
    BOOL    flag
    )
/*++

Implements:

    IRmsRequest::SetIsDone

--*/
{
    m_isDone = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::IsDone(
    void
    )
/*++

Implements:

    IRmsRequest::IsDone

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isDone){
    hr = S_OK;
    }

    return (hr);
}


STDMETHODIMP
CRmsRequest::GetOperation(
    BSTR    *pOperation
    )
/*++

Implements:

    IRmsRequest::GetOperation

--*/
{
    WsbAssertPointer (pOperation);

    m_operation. CopyToBstr (pOperation);
    return S_OK;
}


STDMETHODIMP
CRmsRequest::SetOperation(
    BSTR   operation
    )
/*++

Implements:

    IRmsRequest::SetOperation

--*/
{
    m_operation = operation;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::GetPercentComplete(
    BYTE    *pPercent
    )
/*++

Implements:

    IRmsRequest::GetPercentComplete

--*/
{
    *pPercent = m_percentComplete;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::SetPercentComplete(
    BYTE    percent
    )
/*++

Implements:

    IRmsRequest::SetPercentComplete

--*/
{
    m_percentComplete = percent;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::GetStartTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsRequest::GetStartTimestamp

--*/
{
    *pDate = m_startTimestamp;
    return S_OK;
}


STDMETHODIMP
CRmsRequest::GetStopTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsRequest::GetStopTimestamp

--*/
{
    *pDate = m_stopTimestamp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsreqst.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsReqst.h

Abstract:

    Declaration of the CRmsRequest class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSREQST_
#define _RMSREQST_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsRequest

Class Description:

    A CRmsRequest represents a specific asynchronous job performed by the
    Removable Media Service, like mounting cartridges, checking in and out
    cartridges, and auditing a library.

--*/

class CRmsRequest :
    public CComDualImpl<IRmsRequest, &IID_IRmsRequest, &LIBID_RMSLib>,
    public CRmsComObject,
    public CWsbObject,         // inherits CComObjectRoot
    public CComCoClass<CRmsRequest,&CLSID_CRmsRequest>
{
public:
    CRmsRequest() {}
BEGIN_COM_MAP(CRmsRequest)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsRequest)
    COM_INTERFACE_ENTRY(IRmsRequest)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsRequest)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsRequest
public:
    STDMETHOD(GetRequestNo)(LONG *pRequestNo);

    STDMETHOD(GetRequestDescription)(BSTR *pDesc);
    STDMETHOD(SetRequestDescription)(BSTR desc);

    STDMETHOD(SetIsDone)(BOOL flag);
    STDMETHOD(IsDone)(void);

    STDMETHOD(GetOperation)(BSTR *pOperation);
    STDMETHOD(SetOperation)(BSTR operation);

    STDMETHOD(GetPercentComplete)( BYTE *pPercent);
    STDMETHOD(SetPercentComplete)( BYTE percent);

    STDMETHOD(GetStartTimestamp)(DATE *pDate);
    STDMETHOD(GetStopTimestamp)(DATE *pDate);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    LONG            m_requestNo;            // A request number.
    CWsbBstrPtr     m_requestDescription;   // A textual description of the request.
    BOOL            m_isDone;               // If TRUE, the request has completed.
    CWsbBstrPtr     m_operation;            // An internal description of the in-progress operation.
    BYTE            m_percentComplete;      // A value between 0-100 that indicates
                                            //   what portion of the operation is complete.
    DATE            m_startTimestamp;       // The time the request was started.
    DATE            m_stopTimestamp;        // The time the request finished.
};

#endif // _RMSREQST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsservr.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsServr.cpp

Abstract:

    Implementation of CRmsServer

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"
//#include <stl.h>

//using namespace std ;

//#pragma warning (disable : 4786) 
//using namespace std ;

#include <devioctl.h>
#include <ntddscsi.h>

#include "RmsServr.h"
#include "rsbuild.h"
#include "wsb.h"
#include "ntverp.h"

#define PERSIST_CHECK_VALUE 0x526f6e57

#if 0
#define DebugPrint(a)   {                   \
    CWsbStringPtr out = a;                  \
    out.Prepend(L": ");                     \
    out.Prepend(WsbLongAsString(GetCurrentThreadId()));  \
    OutputDebugString((WCHAR *) out);       \
}
#else
#define DebugPrint(a)
#endif // DBG


//  This is made global so that anybody in the context of the server has
//  quick access to it
IRmsServer *g_pServer = 0;


/////////////////////////////////////////////////////////////////////////////
// CComObjectRoot


HRESULT
CRmsServer::FinalConstruct(void)
/*++

Routine Description:

    This method does some initialization of the object that is necessary
    after construction.

Arguments:

    None.

Return Value:

    S_OK

    Anything returned by CWsbPersistStream::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::FinalConstruct"), OLESTR(""));

    // Zeroing global variable
    g_pServer = 0;

    CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;

    try {
        WsbAssertPointer( pObject );

        CWsbBstrPtr tmpString;

        WsbAssertHr( CWsbPersistStream::FinalConstruct() );

        WsbAffirmHr( ChangeState( RmsServerStateStarting ));

        // Figure out where to store information and initialize trace.

        // Setup the collections
        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pCartridges ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pActiveCartridges ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pDataMovers ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pLibraries ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pMediaSets ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pRequests ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pClients ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pUnconfiguredDevices ));

        // Create NTMS object
        WsbAssertHr(CoCreateInstance( CLSID_CRmsNTMS,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IRmsNTMS,
                                      (void **)&m_pNTMS ));

        // Get the name of the computer on which we running.
        CWsbStringPtr               serverNameString;
        WsbAffirmHr( WsbGetComputerName( serverNameString ));
        m_ServerName = serverNameString;

        m_HardDrivesUsed = 0;

        m_LockReference = 0;

        WsbAffirmHr( ChangeState( RmsServerStateStarted ));

    } WsbCatchAndDo(hr,
            pObject->Disable( hr );
        );

    WsbTraceOut(OLESTR("CRmsServer::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsServer::FinalRelease(void)
/*++

Routine Description:

    This method does some uninitialization of the object that is necessary
    before destrucruction.

Arguments:

    None.

Return Value:

    S_OK

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::FinalRelease"), OLESTR(""));

    try {
        WsbAffirmHr( ChangeState( RmsServerStateStopping ));

        CWsbPersistStream::FinalRelease();
        WsbAffirmHr( ChangeState( RmsServerStateStopped ));

#ifdef WSB_TRACK_MEMORY
        (void) WsbObjectTracePointers(WSB_OTP_SEQUENCE | WSB_OTP_STATISTICS | WSB_OTP_ALLOCATED);
        (void) WsbObjectTraceTypes();
#endif

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}




STDMETHODIMP 
CRmsServer::InitializeInAnotherThread(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::InitializeInAnotherThread"), OLESTR(""));

    try {

        DWORD threadId;
        HANDLE hThread;
        WsbAffirmHandle(hThread = CreateThread(NULL, 1024, CRmsServer::InitializationThread, this, 0, &threadId));
        CloseHandle(hThread);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::InitializeInAnotherThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



DWORD WINAPI
CRmsServer::InitializationThread(
    IN LPVOID pv)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::InitializationThread"), OLESTR(""));


    try {
        WsbAssertPointer(pv);
        CRmsServer *pServer = (CRmsServer*)pv;
        WsbAffirmHr(pServer->Initialize());
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::InitializationThread"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
    } 


STDMETHODIMP 
CRmsServer::Initialize(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::Initialize"), OLESTR(""));

    CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;

    DWORD fixedDriveEnabled = RMS_DEFAULT_FIXED_DRIVE;
    DWORD size;
    OLECHAR tmpString[256];
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FIXED_DRIVE, tmpString, 256, &size))) {
        // Get the value.
        fixedDriveEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD opticalEnabled = RMS_DEFAULT_OPTICAL;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_OPTICAL, tmpString, 256, &size))) {
        // Get the value.
        opticalEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD tapeEnabled = RMS_DEFAULT_TAPE;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_TAPE, tmpString, 256, &size))) {
        // Get the value.
        tapeEnabled = wcstol(tmpString, NULL, 10);
    }

    DWORD dvdEnabled = RMS_DEFAULT_DVD;
    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_DVD, tmpString, 256, &size))) {
        // Get the value.
        dvdEnabled = wcstol(tmpString, NULL, 10);
    }

    WsbTraceAlways(OLESTR("Fixed Drive Media Enabled: %ls\n"), WsbBoolAsString((BOOL)fixedDriveEnabled));
    WsbTraceAlways(OLESTR("Optical Media Enabled:     %ls\n"), WsbBoolAsString((BOOL)opticalEnabled));
    WsbTraceAlways(OLESTR("Tape Media Enabled:        %ls\n"), WsbBoolAsString((BOOL)tapeEnabled));
    WsbTraceAlways(OLESTR("DVD Media Enabled:        %ls\n"), WsbBoolAsString((BOOL)dvdEnabled));

    try {
        if (0 == g_pServer) {
            // Set global variable for quick access (if not set yet)
            WsbAffirmHr(((IUnknown*)(IRmsServer *)this)->QueryInterface(IID_IRmsServer, (void**) &g_pServer));

            // We don't want the reference count bumped for this global so release it here.
            g_pServer->Release();
        }

        // initializing
        WsbAssertPointer( pObject );

        CWsbStringPtr tmpString;

        WsbAffirmHr( ChangeState( RmsServerStateInitializing ));

        hr = IsNTMSInstalled();
        if ( S_OK == hr ) {

            try {
                // Perform any initialization required for using NTMS subsystem.
                WsbAffirmHr( m_pNTMS->Initialize() );
            } WsbCatch (hr);
            hr = S_OK;

            if (fixedDriveEnabled) {
                // Scan for drives.
                WsbAffirmHr( ScanForDrives() );
            }

            // Resolve the devices detected by the scan.
            WsbAffirmHr( resolveUnconfiguredDevices() );

            // Auto configure the remaining devices.
            WsbAffirmHr( autoConfigureDevices() );

            // Try to dismount all of our medias, ignore errors
            HRESULT hrDismountAll = S_OK;
            try {
                CComPtr<IWsbEnum>       pEnumSets;
                CComPtr<IRmsMediaSet>   pMediaSet;
                CComPtr<IRmsComObject>  pObject;
                GUID                    mediaSetId;

                WsbAffirmHr(m_pMediaSets->Enum(&pEnumSets));
                WsbAssertPointer(pEnumSets);
                hrDismountAll = pEnumSets->First(IID_IRmsMediaSet, (void **)&pMediaSet);
                while (S_OK == hrDismountAll) {
                    WsbAffirmHr(pMediaSet->QueryInterface(IID_IRmsComObject, (void**) &pObject));
                    WsbAffirmHr(pObject->GetObjectId(&mediaSetId));
                    WsbAffirmHr(m_pNTMS->DismountAll(mediaSetId));

                    hrDismountAll = pEnumSets->Next(IID_IRmsMediaSet, (void **)&pMediaSet);
                }
                if (hrDismountAll == WSB_E_NOTFOUND) {
                    hrDismountAll = S_OK;
                } else {
                    WsbAffirmHr(hrDismountAll);
                }
            } WsbCatch(hrDismountAll);
        }
        else if ( RMS_E_NOT_CONFIGURED_FOR_NTMS == hr ) {
            hr = S_OK;

            // Scan for devices.
            WsbAffirmHr( ScanForDevices() );

            if (fixedDriveEnabled) {
                // Scan for drives.
                WsbAffirmHr( ScanForDrives() );
            }

            // Resolve the devices detected by the scan.
            WsbAffirmHr( resolveUnconfiguredDevices() );

            // Auto configure the remaining devices.
            WsbAffirmHr( autoConfigureDevices() );

        }
        else { // Some other NTMS connection failure (NTMS not installed, configured, or running)
            hr = S_OK;

            if (fixedDriveEnabled) {
                // Scan for drives.
                WsbAffirmHr( ScanForDrives() );

                // Resolve the devices detected by the scan.
                WsbAffirmHr( resolveUnconfiguredDevices() );

                // Auto configure the remaining devices.
                WsbAffirmHr( autoConfigureDevices() );
            }

        }

        // Enable RMS process for backup operations.
        WsbAffirmHr( enableAsBackupOperator() );

        // Save the configuration information.
        WsbAffirmHr( SaveAll() );

        WsbAffirmHr( ChangeState( RmsServerStateReady ));

        WsbTraceAlways(OLESTR("RMS is ready.\n"));

    } WsbCatchAndDo(hr,
            pObject->Disable( hr );
        );


    WsbTraceOut(OLESTR("CRmsServer::Initialize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP 
CRmsServer::IsNTMSInstalled(void)
{

    return m_pNTMS->IsInstalled();

}


STDMETHODIMP
CRmsServer::GetNTMS(
    OUT IRmsNTMS **ptr)
/*++

Implements:

    IRmsServer::GetNTMS

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( ptr );

        *ptr = m_pNTMS;
        m_pNTMS->AddRef();

        hr = S_OK;

    } WsbCatch( hr );

    return hr;
}

//
// Rms no longer save independently its own .col file, but only the NTMS database
//

STDMETHODIMP 
CRmsServer::SaveAll(void)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::SaveAll"), OLESTR(""));

    static BOOL saving = FALSE;

    try {
        WsbAffirm(!saving, S_FALSE);
        saving = TRUE;

        hr = m_pNTMS->ExportDatabase();

        saving = FALSE;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::SaveAll"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP 
CRmsServer::Unload(void)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::Unload"), OLESTR(""));

    try {

        //  We only need to release what may have gotten set/created by
        //  a failed Load attempt.
        if (m_pCartridges) {
            WsbAffirmHr(m_pCartridges->RemoveAllAndRelease());
        }
        if (m_pLibraries) {
            WsbAffirmHr(m_pLibraries->RemoveAllAndRelease());
        }
        if (m_pMediaSets) {
            WsbAffirmHr(m_pMediaSets->RemoveAllAndRelease());
        }
        if (m_pRequests) {
            WsbAffirmHr(m_pRequests->RemoveAllAndRelease());
        }
        if (m_pClients) {
            WsbAffirmHr(m_pClients->RemoveAllAndRelease());
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::Unload"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CRmsServer::GetClassID(
    OUT CLSID* pClsid)
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsServer;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsServer::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return hr;
}


STDMETHODIMP
CRmsServer::GetSizeMax(
    OUT ULARGE_INTEGER* /*pcbSize*/)
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT         hr = E_NOTIMPL;

//  ULONG           serverNameLen;

//  ULARGE_INTEGER  cartridgesLen;
//  ULARGE_INTEGER  librariesLen;
//  ULARGE_INTEGER  mediaSetsLen;
//  ULARGE_INTEGER  requestsLen;
//  ULARGE_INTEGER  clientsLen;
//  ULARGE_INTEGER  unconfiguredDevicesLen;


//  WsbTraceIn(OLESTR("CRmsServer::GetSizeMax"), OLESTR(""));

//  try {
//      WsbAssert(0 != pcbSize, E_POINTER);

//      m_pCartridges-> GetSizeMax (&cartridgesLen);

        // set up size of CRmsServer
//      pcbSize->QuadPart  = WsbPersistSizeOf(ULONG)       +  // length of serverName
//                           cartridgesLen.QuadPart;          // m_pCartridges

//  } WsbCatch(hr);

//  WsbTraceOut(OLESTR("CRmsServer::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return hr;
}

STDMETHODIMP
CRmsServer::Load(
    IN IStream* pStream)
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::Load"), OLESTR(""));

    //
    // Check if the global pointer is already set - if not, update it
    // (Today, Load is the only method that is executed before Initialize)
    //
    if (0 == g_pServer) {
        // Set global variable for quick access (if not set yet)
        WsbAffirmHr(((IUnknown*)(IRmsServer *)this)->QueryInterface(IID_IRmsServer, (void**) &g_pServer));

        // We don't want the reference count bumped for this global so release it here.
        g_pServer->Release();
    }

    //
    // Lock down the server while we are loading.
    //
    InterlockedIncrement( &m_LockReference );

    //
    // The Load reverts the state, which is undesired for the server object.
    // Save away the original status information
    //
    BOOL bTemp = m_IsEnabled;
    LONG lTemp = m_State;
    HRESULT hrTemp = m_StatusCode;

    try {
        WsbAssertPointer(pStream);

        CComPtr<IPersistStream> pPersistStream;

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Load the collections
        WsbAffirmHr(m_pMediaSets->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pLibraries->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pRequests->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pClients->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        //  Check that we got everything
        ULONG check_value;
        WsbAffirmHr(WsbLoadFromStream(pStream, &check_value));
        WsbAffirm(check_value == PERSIST_CHECK_VALUE, E_UNEXPECTED);

    } WsbCatch(hr);


    // Reset the object status information to their original settings.
    m_IsEnabled = bTemp;
    m_State = lTemp;
    m_StatusCode = hrTemp;

    //
    // Unlock the server.
    //
    InterlockedDecrement( &m_LockReference );

    WsbTraceOut(OLESTR("CRmsServer::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CRmsServer::Save(
    IN IStream* pStream,
    IN BOOL clearDirty)
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;


    WsbTraceIn(OLESTR("CRmsServer::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        CComPtr<IPersistStream>   pPersistStream;

        WsbAssertPointer(pStream);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Save the collections
        WsbAffirmHr(m_pMediaSets->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pLibraries->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pRequests->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pClients->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        //  Put this at the end as a check during load
        ULONG check_value = PERSIST_CHECK_VALUE;
        WsbAffirmHr(WsbSaveToStream(pStream, check_value));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
// IRmsServer


STDMETHODIMP
CRmsServer::GetServerName(
    OUT BSTR *pName)
/*++

Implements:

    IRmsServer::GetServerName

--*/
{
    WsbAssertPointer(pName);

    m_ServerName.CopyToBstr(pName);
    return S_OK;
}



STDMETHODIMP
CRmsServer::GetCartridges(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetCartridges

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pCartridges;
        m_pCartridges->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetActiveCartridges(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetActiveCartridges

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pActiveCartridges;
        m_pActiveCartridges->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetDataMovers(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetDataMovers

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pDataMovers;
        m_pDataMovers->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::SetActiveCartridge(
    IN IRmsCartridge *ptr)
/*++

Implements:

    IRmsServer::SetActiveCartridge

--*/
{
    HRESULT hr = S_OK;

    try {

        if (m_pActiveCartridge) {
            m_pActiveCartridge = 0;
        }
        m_pActiveCartridge = ptr;

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetLibraries(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetLibraries

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pLibraries;
        m_pLibraries->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetMediaSets(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetMediaSets

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        // We need to reinit NTMS to account for PNP devices.
        (void) m_pNTMS->Initialize();

        *ptr = m_pMediaSets;
        m_pMediaSets->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetRequests(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetRequests

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pRequests;
        m_pRequests->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetClients(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetClients

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pClients;
        m_pClients->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::GetUnconfiguredDevices(
    OUT IWsbIndexedCollection **ptr)
/*++

Implements:

    IRmsServer::GetUnconfiguredDevices

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pUnconfiguredDevices;
        m_pUnconfiguredDevices->AddRef();

    } WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsServer::ScanForDevices(void)
/*++

Implements:

    IRmsServer::ScanForDevices

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::ScanForDevices"), OLESTR(""));

    HANDLE portHandle = INVALID_HANDLE_VALUE;

    LONGLONG trace = 0;

    try {

//        WsbAssertPointer( g_pTrace );

        BOOL        status;
        DWORD       accessMode = GENERIC_READ;
        DWORD       shareMode  = FILE_SHARE_READ;
        UCHAR       portData[2048];
        OLECHAR     string[25];
        ULONG       returned;
        int         portNumber = 0;

//        BOOL     traceTimeStamp;
//        BOOL     traceCount;
//        BOOL     traceThreadId;

//        WsbAssertHr( g_pTrace->GetTraceSettings( &trace )); 
//        WsbAssertHr( g_pTrace->SetTraceOff( WSB_TRACE_BIT_ALL )); 
//        WsbAssertHr( g_pTrace->GetOutputFormat( &traceTimeStamp, &traceCount, &traceThreadId )); 
//        WsbAssertHr( g_pTrace->SetOutputFormat( FALSE, FALSE, FALSE )); 
        WsbTraceAlways( OLESTR("\n\n----- Begin Device Scan ---------------------------------------------------------------\n\n") );

        //
        // Go to each SCSI adapter connected to the system and build
        // out the device list.
        //

        do {

            swprintf( string, OLESTR("\\\\.\\Scsi%d:"), portNumber );

            portHandle = CreateFile( string,
                                     accessMode,
                                     shareMode,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL );

            if ( portHandle == INVALID_HANDLE_VALUE ) {
                break; // we're done
            }

            //
            // Get the inquiry data.
            //

            WsbAffirmStatus( DeviceIoControl( portHandle,
                                      IOCTL_SCSI_GET_INQUIRY_DATA,
                                      NULL,
                                      0,
                                      portData,
                                      sizeof(portData),
                                      &returned,
                                      FALSE ));

            status = CloseHandle( portHandle );
            portHandle = INVALID_HANDLE_VALUE;
            WsbAffirmStatus( status );

            WsbAffirmHrOk( processInquiryData( portNumber, portData ) );

            portNumber++;

        } while ( 1 );


        WsbTraceAlways( OLESTR("\n\n----- End Device Scan -----------------------------------------------------------------\n\n") );
//        WsbAssertHr( g_pTrace->SetOutputFormat( traceTimeStamp, traceCount, traceThreadId )); 
//        WsbAssertHr( g_pTrace->SetTraceOn( trace )); 

        hr = S_OK;

    }
    WsbCatchAndDo( hr,
//        if (g_pTrace) {
//            WsbAssertHr( g_pTrace->SetTraceOn( trace )); 
            WsbTraceAlways( OLESTR("\n\n !!!!! ERROR !!!!! Device Scan Terminated.\n\n") );
//        }
        if ( portHandle != INVALID_HANDLE_VALUE ) {
           CloseHandle( portHandle );
        }
    );


    WsbTraceOut(OLESTR("CRmsServer::ScanForDevices"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CRmsServer::ScanForDrives(void)
/*++

Implements:

    IRmsServer::ScanForDrives

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::ScanForDrives"), OLESTR(""));

    try {

        //
        // Build out device objects for various drive types:  fixed drives, removables, and CD-ROM.
        // These are all supported by the system, and have drive letters associated with them.
        //
        // Use best effort to dectect drives.  If anything fails we just go on to the next one.

        // Get the unconfigured device list
        CComPtr<IWsbIndexedCollection> pDevices;
        WsbAssertHr( this->GetUnconfiguredDevices( &pDevices ));

        // Get the drive letters
        const DWORD bufSize = 256; // 26*4 + 1 = 105 is all we really need
        OLECHAR driveLetters[bufSize];
        DWORD len;

        // See if there are drives for us to support
        if ( getHardDrivesToUseFromRegistry( driveLetters, &len ) != S_OK )  {
            len = GetLogicalDriveStrings( bufSize, driveLetters );
        }

        UINT    type;

        // For each drive letter see if it is something managed
        // by RMS.

        m_HardDrivesUsed = 0;
        for ( DWORD i = 0; i < len; i += 4 ) {      // drive letters have the form "A:\"

            try {

                type = GetDriveType( &driveLetters[i] );

                switch ( type ) {

                case DRIVE_REMOVABLE:
                    {
                        WsbTrace( OLESTR("Removable Drive Detected: %C\n"), driveLetters[i] );

                        CComPtr<IRmsDevice> pDevice;
                        WsbAffirmHr( CoCreateInstance( CLSID_CRmsDrive, 0, CLSCTX_SERVER, IID_IRmsDevice, (void **)&pDevice ));

                        CWsbBstrPtr name = &(driveLetters[i]);

                        WsbAffirmHr( pDevice->SetDeviceName( name ));
                        WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceRemovableDisk ));

                        //
                        // Don't add it if it was already detected in the SCSI device scan
                        //

                        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pDevice;
                        WsbAssertPointer( pObject );
                        WsbAffirmHr( pObject->SetFindBy( RmsFindByDeviceName ));

                        if ( S_OK == pDevices->Contains( pDevice ) ) {
                            break;
                        }

                        WsbAffirmHr( pDevices->Add( pDevice ));
                        pDevice = 0;
                    }
                    break;

                case DRIVE_FIXED:
                    {
                        CWsbBstrPtr name = &(driveLetters[i]);
                        WCHAR volumeName[32];
                        DWORD volumeSerialNumber;
                        DWORD filenameLength;
                        DWORD fileSystemFlags;
                        WCHAR fileSystemName[32];

                        WsbAffirmStatus(GetVolumeInformation( (WCHAR *)name, volumeName, 32,
                            &volumeSerialNumber, &filenameLength, &fileSystemFlags, fileSystemName, 32));

                        WsbTrace( OLESTR("Fixed Drive Detected    : %ls <%ls/%d> [len=%d, flags=0x%08x] %ls\n"),
                            (WCHAR *)name, volumeName, volumeSerialNumber, filenameLength,
                            fileSystemFlags, fileSystemName );

                        //
                        // Use any volume with name starting with RStor, Remote Stor, RemoteStor, RS
                        //
                        if ( (0 == _wcsnicmp(volumeName, L"RS", 2)) ||
                                 (0 == _wcsnicmp(volumeName, L"Remote Stor", 11)) ||
                                 (0 == _wcsnicmp(volumeName, L"RemoteStor", 10))) {
                            CComPtr<IRmsDevice> pDevice;
                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsDrive, 0, CLSCTX_SERVER, IID_IRmsDevice, (void **)&pDevice ));

                            WsbAffirmHr( pDevice->SetDeviceName( name ));
                            WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceFixedDisk ));
                            WsbAffirmHr( pDevices->Add( pDevice ));
                            pDevice = 0;
                            m_HardDrivesUsed++;
                            WsbTrace( OLESTR("  %ls added to Collection of unconfigured devices.\n"), (WCHAR *)name );
                        }
                    }
                    break;

                case DRIVE_CDROM:
                    {
                        WsbTrace( OLESTR("CD-ROM Drive Detected   : %C\n"), driveLetters[i] );

                        CComPtr<IRmsDevice> pDevice;
                        WsbAffirmHr( CoCreateInstance( CLSID_CRmsDrive, 0, CLSCTX_SERVER, IID_IRmsDevice, (void **)&pDevice ));

                        CWsbBstrPtr name = &(driveLetters[i]);

                        WsbAffirmHr( pDevice->SetDeviceName( name ));
                        WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceCDROM ));
                        WsbAffirmHr( pDevices->Add( pDevice ));
                        pDevice = 0;
                    }
                    break;

                case DRIVE_UNKNOWN:
                case DRIVE_REMOTE:
                case DRIVE_RAMDISK:
                default:
                    break;

                } // switch drive types

            } WsbCatchAndDo(hr,
                    hr = S_OK;  // Best effort
                );

        } // for each drive

    } WsbCatchAndDo( hr,
            WsbTraceAlways( OLESTR("\n\n !!!!! ERROR !!!!! Drive Scan Terminated.\n\n") );
            hr = S_OK;  // Best effort
        );


    WsbTraceOut(OLESTR("CRmsServer::ScanForDrives"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CRmsServer::processInquiryData(
    IN int portNumber,
    IN UCHAR *pDataBuffer)
/*++

Routine Description:

    Builds RMS device objects from adapter port scan data.

Arguments:

    portNumber          - The adapter port to be processed.

    pDataBuffer         - The adapter port data.

Return Value:

    S_OK

--*/

{
    HRESULT hr = E_FAIL;


    try {

        PSCSI_ADAPTER_BUS_INFO  adapterInfo;
        PSCSI_INQUIRY_DATA inquiryData;
        OLECHAR deviceString[25];

        CComPtr<IRmsDevice> pDevice;
        CComPtr<IWsbIndexedCollection> pDevices;
        WsbAffirmHr( this->GetUnconfiguredDevices( &pDevices ));

        adapterInfo = (PSCSI_ADAPTER_BUS_INFO) pDataBuffer;

        WsbTraceAlways( OLESTR("Port: %d\n"), portNumber );
        WsbTraceAlways( OLESTR("Bus TID LUN Claimed String                       Inquiry Header          Other\n") );
        WsbTraceAlways( OLESTR("--- --- --- ------- ---------------------------- ----------------------- --------------\n") );

        for ( UCHAR i = 0; i < adapterInfo->NumberOfBuses; i++) {
            inquiryData = (PSCSI_INQUIRY_DATA) (pDataBuffer +
                            adapterInfo->BusData[i].InquiryDataOffset);

            while (adapterInfo->BusData[i].InquiryDataOffset) {
                WsbTraceAlways( OLESTR(" %d   %d  %3d    %s    %.28S "),
                          i,
                          inquiryData->TargetId,
                          inquiryData->Lun,
                          (inquiryData->DeviceClaimed) ? "Y" : "N",
                          &inquiryData->InquiryData[8] );

                for ( UCHAR j = 0; j < 8; j++) {
                    WsbTraceAlways( OLESTR("%02X "), inquiryData->InquiryData[j] );
                }

                WsbTraceAlways( OLESTR("%d %3d "), inquiryData->InquiryDataLength, inquiryData->NextInquiryDataOffset );

                switch ( inquiryData->InquiryData[0] & 0x1f ) {

                case DIRECT_ACCESS_DEVICE:

                    //
                    // Is this a SCSI removable disk?  (Fixed drives are dealt with later in the scan)
                    //

                    if ( (inquiryData->InquiryData[1] & 0x80) && inquiryData->InquiryData[2] & 0x02) {

                        //
                        // The device is a SCSI removable hard drive, So...
                        // Create the Drive object and add it to the collection of unconfigured devices.
                        //

                        try {

                            if ( inquiryData->DeviceClaimed ) {

                                WsbAffirmHr( CoCreateInstance(CLSID_CRmsDrive, NULL, CLSCTX_SERVER, IID_IRmsDevice, (void**) &pDevice));

                                WsbAffirmHr( pDevice->SetDeviceAddress( (BYTE)portNumber, i, inquiryData->TargetId, inquiryData->Lun ));
                                WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceRemovableDisk ));
                                WsbAffirmHr( pDevice->SetDeviceInfo( &inquiryData->InquiryData[0], 36 ));


                                //
                                // find drive letter
                                //

                                try {
                                    WsbAffirmHr( findDriveLetter( (UCHAR)portNumber, i, inquiryData->TargetId, inquiryData->Lun, deviceString ))
                                    WsbTraceAlways( OLESTR("%ls"), deviceString );
                                    WsbAffirmHr( pDevice->SetDeviceName( deviceString ));
                                    WsbAffirmHr(pDevices->Add( pDevice ));
                                }
                                WsbCatch(hr);

                                pDevice = 0;

                            }
                        }
                        WsbCatch(hr);
                    }
                    break;

                case SEQUENTIAL_ACCESS_DEVICE:

                    //
                    // Create the Drive object and add it
                    // to the collection of unconfigured devices.
                    //

                    try {

                        if ( inquiryData->DeviceClaimed ) {

                            WsbAffirmHr( CoCreateInstance(CLSID_CRmsDrive, NULL, CLSCTX_SERVER, IID_IRmsDevice, (void**) &pDevice));

                            WsbAffirmHr( pDevice->SetDeviceAddress( (BYTE)portNumber, i, inquiryData->TargetId, inquiryData->Lun ));
                            WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceTape ));
                            WsbAffirmHr( pDevice->SetDeviceInfo( &inquiryData->InquiryData[0], 36 ));

                            //
                            // Find tape name
                            //

                            try {
                                WsbAffirmHr( getDeviceName( (UCHAR)portNumber, i, inquiryData->TargetId, inquiryData->Lun, deviceString ));
                                WsbTraceAlways( OLESTR("%ls"), deviceString );

                                // Create the name to use when creating a handle
                                CWsbBstrPtr name = deviceString;
                                name.Prepend( OLESTR("\\\\.\\") );
                                WsbAffirmHr( pDevice->SetDeviceName( name ));
                                WsbAffirmHr(pDevices->Add( pDevice ));
                            }
                            WsbCatch(hr);

                            pDevice = 0;

                        }
                    }
                    WsbCatch(hr);
                    break;

                case WRITE_ONCE_READ_MULTIPLE_DEVICE:

                    //
                    // Supported as OPTICAL_DEVICE only
                    //

                    break;

                case READ_ONLY_DIRECT_ACCESS_DEVICE:

                    //
                    // we'll deal with CD-ROM later in the scan...
                    //

                    break;

                case OPTICAL_DEVICE:

                    //
                    // Create the Drive object and add it
                    // to the collection of unconfigured devices.
                    //

                    try {

                        if ( inquiryData->DeviceClaimed ) {

                            WsbAffirmHr( CoCreateInstance(CLSID_CRmsDrive, NULL, CLSCTX_SERVER, IID_IRmsDevice, (void**) &pDevice));

                            WsbAffirmHr( pDevice->SetDeviceAddress( (BYTE)portNumber, i, inquiryData->TargetId, inquiryData->Lun ));
                            WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceOptical ));
                            WsbAffirmHr( pDevice->SetDeviceInfo( &inquiryData->InquiryData[0], 36 ));

                            //
                            // Find drive letter
                            //

                            try {
                                WsbAffirmHr( findDriveLetter( (UCHAR)portNumber, i, inquiryData->TargetId, inquiryData->Lun, deviceString ))
                                WsbTraceAlways( OLESTR("%ls"), deviceString );
                                WsbAffirmHr( pDevice->SetDeviceName( deviceString ));                            
                                WsbAffirmHr(pDevices->Add( pDevice ));
                            }
                            WsbCatch(hr);

                            pDevice = 0;

                        }
                    }
                    WsbCatch(hr);
                    break;

                case MEDIUM_CHANGER:

                    //
                    // Create the Medium Changer object and add it
                    // to the collection of unconfigured devices.
                    //

                    try {

                        if ( inquiryData->DeviceClaimed ) {

                            WsbAffirmHr( CoCreateInstance(CLSID_CRmsMediumChanger, NULL, CLSCTX_SERVER, IID_IRmsDevice, (void**) &pDevice));

                            WsbAffirmHr( pDevice->SetDeviceAddress( (BYTE)portNumber, i, inquiryData->TargetId, inquiryData->Lun ));
                            WsbAffirmHr( pDevice->SetDeviceType( RmsDeviceChanger ));
                            WsbAffirmHr( pDevice->SetDeviceInfo( &inquiryData->InquiryData[0], 36 ));

                            //
                            // Find library name
                            //

                            try {
                                WsbAffirmHr( getDeviceName( (UCHAR)portNumber, i, inquiryData->TargetId, inquiryData->Lun, deviceString ));
                                WsbTraceAlways( OLESTR("%ls"), deviceString );

                                // Create the name to use when creating a handle
                                CWsbBstrPtr name = deviceString;
                                name.Prepend( OLESTR("\\\\.\\") );
                                WsbAffirmHr( pDevice->SetDeviceName( name ));
                                WsbAffirmHr(pDevices->Add( pDevice ));
                            }
                            WsbCatch(hr);
                        }

                        pDevice = 0;

                    }
                    WsbCatch(hr);
                    break;

                } // switch device type

                    WsbTraceAlways( OLESTR("\n") );

                if (inquiryData->NextInquiryDataOffset == 0) {
                    break;
                }

                inquiryData = (PSCSI_INQUIRY_DATA) (pDataBuffer +
                                inquiryData->NextInquiryDataOffset);

            } // for each device

        } // for each bus

        WsbTraceAlways( OLESTR("\n\n") );

        hr = S_OK;

    }
    WsbCatch(hr);

    return hr;
}


HRESULT
CRmsServer::findDriveLetter(
    IN UCHAR portNo,
    IN UCHAR pathNo,
    IN UCHAR id,
    IN UCHAR lun,
    OUT OLECHAR *driveString)
/*++

Routine Description:

    Find associated drive letter for defined parameters.

Arguments:

    portNo          - input port number.
    pathNo          - input path number.
    id              - input id.
    lun             - input logical unit number.
    driveString     - pointer to drive letter string to return.


Return Value:

    S_OK            - Success


--*/
{

    HRESULT         hr = E_FAIL;
    const DWORD     bufSize = 256; // 26*4 + 1 = 105 is all we really need
    OLECHAR         driveLetters[bufSize];
    BOOL            status;
    DWORD           accessMode = 0, // just get some drive properties.
                    shareMode = FILE_SHARE_READ;
    HANDLE          driveHandle = INVALID_HANDLE_VALUE;
    SCSI_ADDRESS    address;
    DWORD           returned;
    OLECHAR         string[25];
    UINT            uiType;

    try {
        // first find which drives are mapped.
        DWORD len = GetLogicalDriveStrings( bufSize, driveLetters );

        for ( DWORD i = 0; (i < len) && (hr != S_OK); i += 4 ) { // drive letters have the form "A:\"

            uiType = GetDriveType( &driveLetters[i] );
            switch ( uiType ) {

            case DRIVE_REMOVABLE:

                //
                // get the SCSI address of the device and see if it's a match.
                //

                swprintf( string, OLESTR("\\\\.\\%C:"), driveLetters[i] );

                driveHandle = CreateFile( string,
                                          accessMode,
                                          shareMode,
                                          NULL,
                                          OPEN_EXISTING,
                                          0,
                                          NULL);

                WsbAffirmHandle( driveHandle );

                //
                // Get the address structure.
                //

                status = DeviceIoControl( driveHandle,
                                                  IOCTL_SCSI_GET_ADDRESS,
                                                  NULL,
                                                  0,
                                                  &address,
                                                  sizeof(SCSI_ADDRESS),
                                                  &returned,
                                                  FALSE );
                if (!status ) {

                    //
                    // asking for the SCSI address is not always a valid request for
                    // all types of drives, so getting an error here means we're
                    // not talking to a SCSI device... so skip it.
                    //

                    break;  // out of switch
                }

                //
                // Let's check the SCSI address and see if we get a match.
                //

                if ( (address.PortNumber == portNo) &&
                     (address.PathId == pathNo)     &&
                     (address.TargetId == id)       &&
                     (address.Lun == lun)) {

                    // its a match...
                    wcscpy( driveString, &driveLetters[i] );
                    hr = S_OK;
                }

                break;  // out of switch

            } // switch

            //
            // Cleanup
            //

            if ( driveHandle != INVALID_HANDLE_VALUE ) {
                status = CloseHandle( driveHandle );
                driveHandle = INVALID_HANDLE_VALUE;
                WsbAffirmStatus( status );
            }

        } // for each drive letter
    } WsbCatchAndDo( hr,
                        if ( driveHandle != INVALID_HANDLE_VALUE ) {
                            CloseHandle(driveHandle);
                        } );

    return hr;
}

HRESULT
CRmsServer::getDeviceName(
    IN UCHAR portNo,
    IN UCHAR pathNo,
    IN UCHAR id,
    IN UCHAR lun,
    OUT OLECHAR *deviceName)
/*++

Routine Description:

    Get device name from selected parameters.

Arguments:

    portNo          - port number.

    pathNo          - path number.

    id              - id.

    lun             - logical unit number.

    deviceName      - pointer to returned device name.


Return Value:

    S_OK            - Success

--*/
{
    HRESULT         hr = S_FALSE;
    OLECHAR         string[256];
    DWORD           len;
    OLECHAR         name[25];

    // just go to the registry and get the DeviceName

    swprintf( string,
              OLESTR("HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target Id %d\\Logical Unit Id %d"),
              portNo, pathNo, id, lun );


    hr = WsbGetRegistryValueString( NULL,
                                    string,
                                    OLESTR("DeviceName"),
                                    name,
                                    sizeof(name),
                                    &len );

    if ( S_OK == hr ) {
        wcscpy( deviceName, name );
    }

    return hr;
}


HRESULT
CRmsServer::resolveUnconfiguredDevices(void)
/*++

  This method goes through the unconfigured device list, which is created by
  the ScanForDevices() method, and determines if a device has already been configured.
  If a device is already configured, it is removed from the unconfigured device list.

--*/
{
    HRESULT hr = E_FAIL;
    WsbTraceIn(OLESTR("CRmsServer::resolveUnconfiguredDevices"), OLESTR(""));

    BOOL                                    tracingPlatform = 0;

    try {

        CComPtr<IWsbIndexedCollection>  pDevices;
        CComPtr<IWsbIndexedCollection>  pLibs;
        CComPtr<IRmsDevice>             pDevice;
        CComPtr<IWsbEnum>               pEnumDevices;
        CComPtr<IWsbEnum>               pEnumLibs;
        RmsDevice                       type;
        BOOL                            deviceIsConfigured = FALSE;

//        WsbAssertPointer( g_pTrace );
//        WsbAffirmHr( g_pTrace->GetTraceSetting( WSB_TRACE_BIT_PLATFORM, &tracingPlatform ));

        WsbAssertHr( GetLibraries( &pLibs ) );
        WsbAffirmHr( pLibs->Enum( &pEnumLibs ));
        WsbAssertPointer( pEnumLibs );

        WsbAssertHr( GetUnconfiguredDevices( &pDevices ));
        WsbAffirmHr( pDevices->Enum( &pEnumDevices ));
        WsbAssertPointer( pEnumDevices );

        // start off with the first unconfigured device.
        hr = pEnumDevices->First( IID_IRmsDevice, (void **)&pDevice );
        while ( S_OK == hr ) {
            try {

                CComPtr<IRmsLibrary>    pLib;

                deviceIsConfigured = FALSE;

                //
                // If a device is already in a library, then it is configured and
                // should be removed from the list of unconfigured devices.
                //
                // To test if a device is in a library we simply go to each library
                // and try to find the device.
                //

                WsbAffirmHr( pDevice->GetDeviceType( (LONG *) &type ) );
                WsbTrace(OLESTR("CRmsServer::resolveUnconfiguredDevices: external loop: device type = %ld\n"), (LONG)type);

                CComPtr<IWsbIndexedCollection> pChangers;
                CComPtr<IWsbIndexedCollection> pDrives;

                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pDevice;
                WsbAssertPointer( pObject );

                // Set up search method for the changer
                WsbAffirmHr( pObject->SetFindBy( RmsFindByDeviceInfo ));

                // start off with the first library.
                hr = pEnumLibs->First( IID_IRmsLibrary, (void **)&pLib );
                while ( S_OK == hr ) {

                    try {
                        WsbTrace(OLESTR("CRmsServer::resolveUnconfiguredDevices: internal loop: device type = %ld\n"), (LONG)type);

                        switch ( type ) {
                        case RmsDeviceChanger:
                            {
                                CComQIPtr<IRmsMediumChanger, &IID_IRmsMediumChanger> pChanger = pDevice;
                                WsbAffirmHr( pLib->GetChangers( &pChangers ) );
                                WsbAffirmHrOk( pChangers->Contains( pChanger ));
                                deviceIsConfigured = TRUE;
                            }
                            break;

                        default:
                            {
                                CComQIPtr<IRmsDrive, &IID_IRmsDrive> pDrive = pDevice;
                                WsbAffirmHr( pLib->GetDrives( &pDrives ) );
                                WsbAffirmHrOk( pDrives->Contains( pDrive ));
                                deviceIsConfigured = TRUE;
                            }
                            break;
                        }

                    }
                    WsbCatch(hr);
                    
                    if ( deviceIsConfigured ) {
                        WsbAffirmHr( pDevices->RemoveAndRelease( pDevice ));
                        break;
                    }

                    pLib = 0;
                    hr = pEnumLibs->Next( IID_IRmsLibrary, (void **)&pLib );
                }

            }
            WsbCatch(hr);

            pDevice = 0;
            if ( deviceIsConfigured )
                hr = pEnumDevices->This( IID_IRmsDevice, (void **)&pDevice );
            else
                hr = pEnumDevices->Next( IID_IRmsDevice, (void **)&pDevice );
        }

//        if ( !tracingPlatform )
//            WsbAffirmHr( g_pTrace->SetTraceOff( WSB_TRACE_BIT_PLATFORM ) );

        hr = S_OK;

    }
    WsbCatch(hr);
//    WsbCatchAndDo( hr,
//            if (g_pTrace) {
//                if ( !tracingPlatform )
//                    g_pTrace->SetTraceOff( WSB_TRACE_BIT_PLATFORM );
//            }        
//        );

    WsbTraceOut(OLESTR("CRmsServer::resolveUnconfiguredDevices"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsServer::autoConfigureDevices(void)
/*++

  This method automatically configures supported devices for RMS.

  The algorythm simply goes through the list of unconfigured devices and adds them
  to the appropriate library.

  Eventually, we need to be smart about when to bypass the auto-config step in favor
  of adminstrative overrides, but for now we'll automatically configure everything we
  can.

--*/
{

    //
    // for each device in the unconfigured list, check if it was previously configured,
    // if it is not add it to a library; otherwise delete it from the list of unconfigured devices.
    //
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsServer::autoConfigureDevices"), OLESTR(""));

    try {

        CComPtr<IWsbIndexedCollection>  pDevices;
        CComPtr<IWsbIndexedCollection>  pLibs;
        CComPtr<IWsbIndexedCollection>  pCarts;
        CComPtr<IRmsDevice>             pDevice;
        CComPtr<IWsbEnum>               pEnumDevices;

        RmsDevice   type;
        BOOL        deviceWasConfigured;

        WsbAssertHr( GetUnconfiguredDevices( &pDevices ));
        WsbAssertHr( GetLibraries( &pLibs ));
        WsbAssertHr( GetCartridges( &pCarts ));

        WsbAffirmHr( pDevices->Enum( &pEnumDevices ));
        WsbAssertPointer( pEnumDevices );

        // first find all the changer devices
        hr = pEnumDevices->First( IID_IRmsDevice, (void **)&pDevice );
        while ( S_OK == hr ) {
            try {

                deviceWasConfigured = FALSE;

                WsbAffirmHr( pDevice->GetDeviceType( (LONG *) &type ));
                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices: first loop: device type = %ld\n"), (LONG)type);

                switch ( type ) {

                case RmsDeviceChanger:
                    {

                        CComPtr<IWsbIndexedCollection>  pChangers;
                        CComPtr<IWsbIndexedCollection>  pDrives;
                        CComPtr<IWsbIndexedCollection>  pMediaSets;
                        CComPtr<IRmsLibrary>            pLib;
                        CComPtr<IRmsMediaSet>           pMediaSet;

                        CComQIPtr<IRmsMediumChanger, &IID_IRmsMediumChanger> pChanger = pDevice;
                        WsbAssertPointer( pChanger );

                        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pChangerElmt = pChanger;
                        WsbAssertPointer( pChanger );

                        // Create a Library object
                        WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                            IID_IRmsLibrary, (void **)&pLib ));

                        // Fill in library info
                        WsbAffirmHr( pLib->SetName( RMS_DEFAULT_OPTICAL_LIBRARY_NAME ));
                        WsbAffirmHr( pLib->SetMediaSupported( RmsMedia8mm /*RmsMediaOptical*/ ));

                        // Add the library to the server's collection
                        WsbAffirmHr( pLibs->Add( pLib ));

                        // Create a media set
                        WsbAffirmHr( CoCreateInstance( CLSID_CRmsMediaSet, 0, CLSCTX_SERVER,
                                                            IID_IRmsMediaSet, (void **)&pMediaSet ));

                        // Fill in media set info
                        WsbAffirmHr( pMediaSet->SetName( RMS_DEFAULT_OPTICAL_MEDIASET_NAME ));
                        WsbAffirmHr( pMediaSet->SetMediaSupported( RmsMedia8mm /*RmsMediaOptical*/ ));
                        WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetLibrary ) );

                        // Add the media set the libary's collection
                        WsbAssertHr( pLib->GetMediaSets( &pMediaSets ));
                        WsbAssertPointer( pMediaSets );
                        WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                        pMediaSets = 0;
                        // Add the media set the server's collection
                        WsbAssertHr( GetMediaSets( &pMediaSets ) );
                        WsbAssertPointer( pMediaSets );
                        WsbAffirmHr( pMediaSets->Add( pMediaSet ));

                        // Add the changer device to the library's collection
                        WsbAffirmHr( pLib->GetChangers( &pChangers ));
                        WsbAssertPointer( pChangers );
                        WsbAffirmHr( pChangers->Add( pChanger ));

                        // Set the changer's element information
                        GUID libId;
                        WsbAffirmHr( pLib->GetLibraryId( &libId ));
                        WsbAffirmHr( pChangerElmt->SetLocation( RmsElementChanger, libId, GUID_NULL, 0, 0, 0, 0, FALSE));
                        WsbAffirmHr( pChangerElmt->SetMediaSupported( RmsMedia8mm /*RmsMediaOptical*/ ));

                        // Initialize the changer device
                        WsbAffirmHr( pChanger->Initialize() );

                        deviceWasConfigured = TRUE;

                    }
                    break;

                default:
                    break;
                }

            }
            WsbCatch(hr);

            pDevice = 0;
            if ( deviceWasConfigured )
                hr = pEnumDevices->This( IID_IRmsDevice, (void **)&pDevice );
            else
                hr = pEnumDevices->Next( IID_IRmsDevice, (void **)&pDevice );

        }

        // any remaining devices are stand alone drives.
        hr = pEnumDevices->First( IID_IRmsDevice, (void **)&pDevice );
        while ( S_OK == hr ) {
            try {

                deviceWasConfigured = FALSE;

                WsbAffirmHr( hr = pDevice->GetDeviceType( (LONG *) &type ));
                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices: second loop: device type = %ld\n"), (LONG)type);

                switch ( type ) {
                    case RmsDeviceFixedDisk:
                       // find the fixed disk library and add this drive.
                       {

                            CComPtr<IWsbIndexedCollection>  pDrives;
                            CComPtr<IWsbIndexedCollection>  pMediaSets;
                            CComPtr<IRmsLibrary>            pFixedLib;
                            CComPtr<IRmsMediaSet>           pFixedMediaSet;
                            CComPtr<IRmsLibrary>            pFindLib;
                            CComPtr<IRmsCartridge>          pCart;

                            GUID    libId = GUID_NULL;
                            GUID    mediaSetId = GUID_NULL;
                            ULONG   driveNo;

                            CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pDriveElmt = pDevice;
                            WsbAssertPointer( pDriveElmt );

                            CComQIPtr<IRmsDrive, &IID_IRmsDrive> pDrive = pDevice;
                            WsbAssertPointer( pDrive );

                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                                IID_IRmsLibrary, (void **)&pFindLib ));

                            // Set up the find template

                            WsbAffirmHr( pFindLib->SetMediaSupported( RmsMediaFixed ));
                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindLib;
                            WsbAffirmHr( pObject->SetFindBy( RmsFindByMediaSupported ));

                            // Find the library

                            hr = pLibs->Find( pFindLib, IID_IRmsLibrary, (void **)&pFixedLib );

                            if ( WSB_E_NOTFOUND == hr ) {

                                // We don't have a fixed drive library yet, so create one...

                                WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                                    IID_IRmsLibrary, (void **)&pFixedLib ));
                                WsbAffirmHr( pFixedLib->SetName( RMS_DEFAULT_FIXEDDRIVE_LIBRARY_NAME ));
                                WsbAffirmHr( pFixedLib->SetMediaSupported( RmsMediaFixed ));

                                WsbAffirmHr( pLibs->Add( pFixedLib ));

                                CComPtr<IRmsMediaSet> pMediaSet;
                                WsbAffirmHr( CoCreateInstance( CLSID_CRmsMediaSet, 0, CLSCTX_SERVER,
                                                                    IID_IRmsMediaSet, (void **)&pMediaSet ));

                                
                                WsbAffirmHr( pMediaSet->SetName( RMS_DEFAULT_FIXEDDRIVE_MEDIASET_NAME ));
                                WsbAffirmHr( pMediaSet->SetMediaSupported( RmsMediaFixed ));
                                WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetLibrary ) );

                                // Add the media set the libary's collection
                                WsbAssertHr( pFixedLib->GetMediaSets( &pMediaSets ));
                                WsbAssertPointer( pMediaSets );
                                WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                                pMediaSets = 0;
                                // Add the media set the server's collection
                                WsbAssertHr( GetMediaSets( &pMediaSets ) );
                                WsbAssertPointer( pMediaSets );
                                WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                                DWORD num;
                                WsbAffirmHr( pMediaSets->GetEntries( &num ));
                                pMediaSets = 0;

                                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices - type %d CRmsMediaSet created.\n"), RmsMediaFixed);
                                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices - Number of sets = %d.\n"), num);

                            }

                            // Add the drive to the library
                            WsbAssertHr( pFixedLib->GetDrives( &pDrives ));
                            WsbAffirmHr( pDrives->Add( pDevice ));
                            WsbAffirmHr( pDrives->GetEntries( &driveNo ));

                            // Remove the drive form the unconfigured list
                            WsbAffirmHr( pDevices->RemoveAndRelease( pDevice ));
                            deviceWasConfigured = TRUE;

                            // Get library information
                            WsbAssertHr( pFixedLib->GetMediaSets( &pMediaSets ));

                            WsbAffirmHr( pFixedLib->GetLibraryId( &libId ));

                            WsbAffirmHr( pMediaSets->First( IID_IRmsMediaSet, (void **)&pFixedMediaSet ));
                            WsbAffirmHr( pFixedMediaSet->GetMediaSetId( &mediaSetId ));


                            // Set the location
                            WsbAffirmHr( pDriveElmt->SetLocation( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));

                            // Set the kind of media supported
                            WsbAffirmHr( pDriveElmt->SetMediaSupported( RmsMediaFixed ));

                            // Create a cartridge for the media in the drive.
                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                                                IID_IRmsCartridge, (void **)&pCart ));
                            WsbAffirmHr( pCart->SetLocation( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));
                            WsbAffirmHr( pCart->SetHome( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));
                            WsbAffirmHr( pCart->SetStatus( RmsStatusScratch ));
                            WsbAffirmHr( pCart->SetType( RmsMediaFixed ));

                            // Add the drive to the Cartridge object.
                            WsbAffirmHr( pCart->SetDrive( pDrive ));

                            // Add the cartridge to the cartridge collection
                            WsbAffirmHr( pCarts->Add( pCart ));

                        }
                        break;

                    case RmsDeviceRemovableDisk:
                        // find manual library and add this stand alone drive.
                        break;

                    case RmsDeviceTape:
                        // find manual tape library and add this stand alone drive.
                        {

                            CComPtr<IWsbIndexedCollection>  pDrives;
                            CComPtr<IWsbIndexedCollection>  pMediaSets;
                            CComPtr<IRmsLibrary>            pTapeLib;
                            CComPtr<IRmsMediaSet>           pTapeMediaSet;
                            CComPtr<IRmsLibrary>            pFindLib;
                            CComPtr<IRmsCartridge>          pCart;

                            GUID    libId = GUID_NULL;
                            GUID    mediaSetId = GUID_NULL;
                            ULONG   driveNo;

                            CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pDriveElmt = pDevice;
                            WsbAssertPointer( pDriveElmt );

                            CComQIPtr<IRmsDrive, &IID_IRmsDrive> pDrive = pDevice;
                            WsbAssertPointer( pDrive );

                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                                IID_IRmsLibrary, (void **)&pFindLib ));

                            // Set up the find template

                            WsbAffirmHr( pFindLib->SetMediaSupported( RmsMedia4mm ));
                            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindLib;
                            WsbAffirmHr( pObject->SetFindBy( RmsFindByMediaSupported ));

                            // Find the library

                            hr = pLibs->Find( pFindLib, IID_IRmsLibrary, (void **)&pTapeLib );

                            if ( WSB_E_NOTFOUND == hr ) {

                                // We don't have a manual tape library yet, so create one...

                                WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                                                    IID_IRmsLibrary, (void **)&pTapeLib ));
                                WsbAffirmHr( pTapeLib->SetName( RMS_DEFAULT_TAPE_LIBRARY_NAME ));
                                WsbAffirmHr( pTapeLib->SetMediaSupported( RmsMedia4mm ));

                                WsbAffirmHr( pLibs->Add( pTapeLib ));

                                CComPtr<IRmsMediaSet> pMediaSet;
                                WsbAffirmHr( CoCreateInstance( CLSID_CRmsMediaSet, 0, CLSCTX_SERVER,
                                                                    IID_IRmsMediaSet, (void **)&pMediaSet ));
                                WsbAffirmHr( pMediaSet->SetName( RMS_DEFAULT_TAPE_MEDIASET_NAME ));
                                WsbAffirmHr( pMediaSet->SetMediaSupported( RmsMedia4mm ));
                                WsbAffirmHr( pMediaSet->SetMediaSetType( RmsMediaSetLibrary ) );

                                // Add the media set the library's collection
                                WsbAssertHr( pTapeLib->GetMediaSets( &pMediaSets ));
                                WsbAssertPointer( pMediaSets );
                                WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                                pMediaSets = 0;
                                // Add the media set the server's collection
                                WsbAssertHr( GetMediaSets( &pMediaSets ) );
                                WsbAssertPointer( pMediaSets );
                                WsbAffirmHr( pMediaSets->Add( pMediaSet ));
                                pMediaSets = 0;

                                WsbTrace(OLESTR("CRmsServer::autoConfigureDevices - type %d CRmsMediaSet created.\n"), RmsMedia4mm);

                            }

                            // Add the drive to the library
                            WsbAssertHr( pTapeLib->GetDrives( &pDrives ));
                            WsbAffirmHr( pDrives->Add( pDevice ));
                            WsbAffirmHr( pDrives->GetEntries( &driveNo ));

                            // Remove the drive form the unconfigured list
                            WsbAffirmHr( pDevices->RemoveAndRelease( pDevice ));
                            deviceWasConfigured = TRUE;

                            // Get library information
                            WsbAssertHr( pTapeLib->GetMediaSets( &pMediaSets ));
                            WsbAffirmHr( pTapeLib->GetLibraryId( &libId ));

                            WsbAffirmHr( pMediaSets->First( IID_IRmsMediaSet, (void **)&pTapeMediaSet ));
                            WsbAffirmHr( pTapeMediaSet->GetMediaSetId( &mediaSetId ));

                            // Set the location
                            WsbAffirmHr( pDriveElmt->SetLocation( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));

                            // Set the kind of media supported
                            WsbAffirmHr( pDriveElmt->SetMediaSupported( RmsMedia4mm ));

                            // Create a cartridge for the media in the drive.
                            // TODO:  it may be empty.
                            WsbAffirmHr( CoCreateInstance( CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                                           IID_IRmsCartridge, (void **)&pCart ));
                            WsbAffirmHr( pCart->SetLocation( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));
                            WsbAffirmHr( pCart->SetHome( RmsElementDrive, libId, mediaSetId,
                                                                  driveNo-1, 0, 0, 0, 0 ));
                            WsbAffirmHr( pCart->SetStatus( RmsStatusScratch ));
                            WsbAffirmHr( pCart->SetType( RmsMedia4mm ));

                            // Add the drive to the Cartridge object.
                            WsbAffirmHr( pCart->SetDrive( pDrive ));

                            // Add the cartridge to the cartridge collection
                            WsbAffirmHr( pCarts->Add( pCart ));

                        }
                        break;

                    case RmsDeviceCDROM:
                    case RmsDeviceWORM:
                    case RmsDeviceOptical:
                        // find manual library and add this stand alone drive.
                        break;

                    default:
                        break;
                }

            } WsbCatch(hr);

            pDevice = 0;

            if ( deviceWasConfigured )
                hr = pEnumDevices->This( IID_IRmsDevice, (void **)&pDevice );
            else    
                hr = pEnumDevices->Next( IID_IRmsDevice, (void **)&pDevice );

        }

        hr = S_OK;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsServer::autoConfigureDevices"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


// Maximum number of retries for allocating and mounting a scratch piece of media
#define     MAX_RETRIES     2


STDMETHODIMP
CRmsServer::MountScratchCartridge(
    OUT GUID *pCartId,
    IN REFGUID fromMediaSet,
    IN REFGUID prevSideId,
    IN OUT LONGLONG *pFreeSpace,
    IN LONG blockingFactor,
    IN BSTR displayName,
    IN OUT IRmsDrive **ppDrive,
    OUT IRmsCartridge **ppCartridge,
    OUT IDataMover **ppDataMover,
	IN DWORD dwOptions)
/*++

Implements:

    IRmsServer::MountScratchCartridge

Notes: The default flag for mounting (in dwOptions) is blocking, i.e. waiting for the Mount 
		to finish even if the media is offline, the drive is not ready, etc. Calling with 
		flag set to non-blocking indicates performing the Mount only if everything is 
		available immediately.

--*/
{

    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::MountScratchCartridge"), OLESTR("<%ls> <%ls> <%ls>"),
        WsbQuickString(WsbGuidAsString(fromMediaSet)),
        WsbQuickString(WsbPtrToLonglongAsString(pFreeSpace)),
        WsbQuickString(WsbPtrToStringAsString((WCHAR **)&displayName)));

    CWsbBstrPtr cartridgeName = "";
    CWsbBstrPtr cartridgeDesc = "";

    GUID cartId = GUID_NULL;
    CWsbBstrPtr label;

    try {
        WsbAssertPointer(pCartId);

       
        WsbAssertPointer(displayName);
        WsbAssert(wcslen((WCHAR *)displayName) > 0, E_INVALIDARG);

        WsbAffirmHrOk( IsReady() );

        DWORD retry = 0;
        CComPtr<IRmsDrive>      pDrive;
        CComPtr<IRmsCartridge>  pCart[MAX_RETRIES];
        CComPtr<IDataMover>     pMover;

        // Decrease max-retries to 1 if short-timeout or non-blocking is specified 
        //  or if we want to allocate a specific side
        DWORD maxRetries = MAX_RETRIES;
        BOOL bShortTimeout = ( (dwOptions & RMS_SHORT_TIMEOUT) || (dwOptions & RMS_ALLOCATE_NO_BLOCK) ) ? TRUE : FALSE;
        if (bShortTimeout || (GUID_NULL != prevSideId)) {
            maxRetries = 1;
        }
        WsbTrace(OLESTR("Try to allocate and mount a scratch media %lu times\n"), maxRetries);

        // Get the media set
        CComPtr<IRmsMediaSet>   pMediaSet;
        WsbAffirmHr(CreateObject(fromMediaSet, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **) &pMediaSet));

        try {
            // Allocate from the specified media set
            WsbAffirmHr(pMediaSet->Allocate(prevSideId, pFreeSpace, displayName, dwOptions, &pCart[retry]));

            // We want to try the scratch mount twice, but do not deallocate the first until we
            // grab the second cartridge so we'll get a different cartridge.  If both fail, drop out.
            do {
                //Clear these,in case we're retrying.
                pDrive = NULL;
                pMover = NULL;

                try {

                    cartId = GUID_NULL;
                    cartridgeName = "";
                    cartridgeDesc = "";


                    WsbAffirmHr(pCart[retry]->GetCartridgeId(&cartId));         // for the log message

                    cartridgeName.Free();
                    WsbAffirmHr(pCart[retry]->GetName(&cartridgeName));         // for the log message

                    cartridgeDesc.Free();
                    WsbAffirmHr(pCart[retry]->GetDescription(&cartridgeDesc));  // for the log message

                    // Mount the cartridge.
                    WsbAffirmHr(pCart[retry]->Mount(&pDrive, dwOptions));

                    try {

                        // Set blockingFactor before we create the DataMover (only for a non-fixed block size media)
                        if (blockingFactor > 0) {
                            HRESULT hrBlock = pCart[retry]->IsFixedBlockSize();
                            WsbAffirmHr(hrBlock);
                            if (hrBlock == S_FALSE) {
                                WsbTrace(OLESTR("MountScratchCartridge: Setting block size on scratch media to %ld\n"), blockingFactor);
                                WsbAffirmHr(pCart[retry]->SetBlockSize(blockingFactor));
                            }
                        }

                        // Create a data mover for the application.
                        WsbAffirmHr(pCart[retry]->CreateDataMover(&pMover));

                        // Write out the On Media Label.                                                                 
                        label.Free();
                        WsbAffirmHr(pMover->FormatLabel(displayName, &label));
                        WsbAffirmHr(pMover->WriteLabel(label));

                        // Mark the media private before returning.
                        WsbAffirmHr(pCart[retry]->SetStatus(RmsStatusPrivate));

                        // Since we don't have a DB, we need to persist the current state here.
                        WsbAffirmHr(SaveAll());

                        //
                        // Fill in the return arguments.
                        //

                        WsbAssertHr(pCart[retry]->GetCartridgeId(pCartId));

                        *ppDrive = pDrive;
                        pDrive->AddRef();
                        *ppCartridge = pCart[retry];
                        pCart[retry]->AddRef();
                        *ppDataMover = pMover;
                        pMover->AddRef();  
                        

                        // We're done, so break out.
                        break;


                    } WsbCatchAndDo(hr,

                            // Best effort dismount...
					        DWORD dwDismountOptions = RMS_DISMOUNT_IMMEDIATE;
	                        pCart[retry]->Dismount(dwDismountOptions);
                            WsbThrow(hr);                     

                        )
  
               

            } WsbCatchAndDo(hr,

                    retry++;

                    // Check the exact error code:
                    // Alllow another retry only if the error may be media-related
                    BOOL bContinue = TRUE;
                    switch (hr) {
                        case RMS_E_SCRATCH_NOT_FOUND:
                        case RMS_E_CANCELLED:
                        case RMS_E_REQUEST_REFUSED:
                        case RMS_E_CARTRIDGE_UNAVAILABLE:   // timeout during Mount
                        case HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_AVAILABLE):
                        case HRESULT_FROM_WIN32(ERROR_INVALID_DRIVE):
                        case HRESULT_FROM_WIN32(ERROR_RESOURCE_DISABLED):   // disabled drives
                        case HRESULT_FROM_WIN32(ERROR_DATABASE_FULL):
                            // Prevent another retry
                            bContinue = FALSE;
                            break;

                        default:
                            break;
                    }

                    if (bContinue && (retry < maxRetries)) {                       
						WsbLogEvent(RMS_MESSAGE_SCRATCH_MOUNT_RETRY, sizeof(GUID), (void *) &cartId, (WCHAR *) displayName, 
                            WsbHrAsString(hr), NULL);
                            							
                        // Allocate from the specified media set						
                        hr = pMediaSet->Allocate(prevSideId, pFreeSpace, displayName, dwOptions, &pCart[retry]);

                        // Deallocate the previous retry media set
                        pMediaSet->Deallocate(pCart[(retry-1)]);

                        // Make sure the allocate worked, if not, throw.
                        WsbAffirmHr(hr);
                                                
                    }
                    else {
                        // If were on the last retry, deallocate the last media set and E_ABORT
                        pMediaSet->Deallocate(pCart[(retry-1)]);

                        WsbThrow(hr);

                    }
                )


            } while (retry < maxRetries);

        } WsbCatch(hr)

    } WsbCatch(hr)

    if ( SUCCEEDED(hr) ) {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_MOUNTED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);
    }
    else {
        BOOL bShortTimeout = ( (dwOptions & RMS_SHORT_TIMEOUT) || (dwOptions & RMS_ALLOCATE_NO_BLOCK) ) ? TRUE : FALSE;
        // In case of short-timeout or non-blocking mode, log message with low severity
        if (bShortTimeout) {
            WsbLogEvent(RMS_MESSAGE_EXPECTED_SCRATCH_MOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) displayName, WsbHrAsString(hr), NULL);
        } else {
            WsbLogEvent(RMS_MESSAGE_SCRATCH_MOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) displayName, WsbHrAsString(hr), NULL);
        }
    }

    WsbTraceOut(OLESTR("CRmsServer::MountScratchCartridge"), OLESTR("hr = <%ls>, name/desc = <%ls/%ls>, cartId = %ls"), WsbHrAsString(hr), (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbQuickString(WsbGuidAsString(cartId)));

    return hr;
}


STDMETHODIMP
CRmsServer::MountCartridge(
    IN REFGUID cartId,
    IN OUT IRmsDrive **ppDrive,
    OUT IRmsCartridge **ppCartridge,
    OUT IDataMover **ppDataMover,
	IN  DWORD dwOptions OPTIONAL,
    IN  DWORD threadId OPTIONAL)
/*++

Implements:

    IRmsServer::MountCartridge

Notes: The default flag for mounting (in dwOptions) is blocking, i.e. waiting for the Mount 
		to finish even if the media is offline, the drive is not ready, etc. Calling with 
		flag set to non-blocking indicates performing the Mount only if everything is 
		available immediately.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::MountCartridge"), OLESTR("<%ls>"), WsbGuidAsString(cartId));

    CWsbBstrPtr cartridgeName = "";
    CWsbBstrPtr cartridgeDesc = "";

    try {
        WsbAffirmHrOk( IsReady() );

        CComPtr<IRmsDrive>      pDrive;
        CComPtr<IRmsCartridge>  pCart;
        CComPtr<IDataMover>     pMover;

        WsbAffirmHr(FindCartridgeById(cartId, &pCart));

        cartridgeName.Free();
        WsbAffirmHr(pCart->GetName(&cartridgeName));        // for the log message

        cartridgeDesc.Free();
        WsbAffirmHr(pCart->GetDescription(&cartridgeDesc)); // for the log message

        WsbAffirmHr(pCart->Mount(&pDrive, dwOptions, threadId));

        try {
            WsbAffirmHr(pCart->CreateDataMover(&pMover));

            //
            // Fill in the return arguments.
            //

            *ppDrive = pDrive;
            pDrive->AddRef();
            *ppCartridge = pCart;
            pCart->AddRef();
            *ppDataMover = pMover;
            pMover->AddRef();

        } WsbCatchAndDo(hr,
                // Best effort dismount...
				DWORD dwDismountOptions = RMS_DISMOUNT_IMMEDIATE;
                pCart->Dismount(dwDismountOptions);
                WsbThrow(hr);
            )


    } WsbCatch(hr)

    if ( SUCCEEDED(hr) ) {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_MOUNTED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);
    }
    else {
        BOOL bShortTimeout = ( dwOptions & RMS_SHORT_TIMEOUT ) ? TRUE : FALSE;
        // In case of short timeout, log message with low severity
        if (bShortTimeout) {
            WsbLogEvent(RMS_MESSAGE_EXPECTED_MOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbHrAsString(hr), NULL);
        } else {
            WsbLogEvent(RMS_MESSAGE_MOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbHrAsString(hr), NULL);
        }
    }

    WsbTraceOut(OLESTR("CRmsServer::MountCartridge"), OLESTR("hr = <%ls>, name/desc = <%ls/%ls>, cartId = %ls"), WsbHrAsString(hr), (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbQuickString(WsbGuidAsString(cartId)));

    return hr;
}


STDMETHODIMP
CRmsServer::DismountCartridge(
    IN REFGUID cartId, IN DWORD dwOptions)
/*++

Implements:

    IRmsServer::DismountCartridge

Notes: The default flag for dismounting (in dwOptions) is not set for immediate dismount, 
		i.e. delaying the Dismount for a configurable amount of time. Setting the flag
		for immediate dismount indicates performing Dismount immediately with no delay.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::DismountCartridge"), OLESTR("<%ls>"), WsbGuidAsString(cartId));

    CWsbBstrPtr cartridgeName = "";
    CWsbBstrPtr cartridgeDesc = "";

    try {

        //
        // Allow dismount when ready or in transition...
        // to handle in-progress duplicate operations.
        //
        HRESULT hrReady = IsReady();
        WsbAffirm((S_OK == hrReady) ||
                  (RMS_E_NOT_READY_SERVER_SUSPENDING == hrReady), hrReady);
   
        CComPtr<IRmsCartridge>  pCart;

        WsbAffirmHr(FindCartridgeById(cartId, &pCart));

        cartridgeName.Free();
        WsbAffirmHr(pCart->GetName(&cartridgeName));        // for the log message

        cartridgeDesc.Free();
        WsbAffirmHr(pCart->GetDescription(&cartridgeDesc)); // for the log message

        WsbAffirmHr(pCart->Dismount(dwOptions));

    } WsbCatch(hr)

    if ( SUCCEEDED(hr) ) {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_DISMOUNTED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);
    }
    else {
        WsbLogEvent(RMS_MESSAGE_DISMOUNT_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbHrAsString(hr), NULL);
    }

    WsbTraceOut(OLESTR("CRmsServer::DismountCartridge"), OLESTR("hr = <%ls>, name/desc = <%ls/%ls>, cartId = %ls"), WsbHrAsString(hr), (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbQuickString(WsbGuidAsString(cartId)));

    return hr;

}

STDMETHODIMP
CRmsServer::DuplicateCartridge(
    IN REFGUID originalCartId,
    IN REFGUID firstSideId,
    IN OUT GUID *pCopyCartId,
    IN REFGUID copySetId,
    IN BSTR copyName,
    OUT LONGLONG *pFreeSpace,
    OUT LONGLONG *pCapacity,
    IN DWORD options)
/*++

Implements:

    IRmsServer::DuplicateCartridge

--*/
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::DuplicateCartridge"), OLESTR("<%ls> <%ls> <%ls> <%ls> <%d>"),
        WsbQuickString(WsbGuidAsString(originalCartId)),
        WsbQuickString(WsbPtrToGuidAsString(pCopyCartId)),
        WsbQuickString(WsbGuidAsString(copySetId)),
        WsbQuickString(WsbPtrToStringAsString((WCHAR **)&copyName)),
        options);

    CComPtr<IDataMover> pMover1;
    CComPtr<IDataMover> pMover2;

    GUID newCartId = GUID_NULL;

    LONGLONG freeSpace = 0;
    LONGLONG capacity = 0;

    try {
        WsbAffirmHrOk( IsReady() );

        WsbAssertPointer( pCopyCartId );

        // Mount the Copy first and then the original
        CComPtr<IRmsDrive>      pDrive1;
        CComPtr<IRmsCartridge>  pCart1;
        CComPtr<IRmsDrive>      pDrive2;
        CComPtr<IRmsCartridge>  pCart2;


        LONG blockSize1=0, blockSize2=0;

        // Serialize mounts for media copies
        DWORD dwMountOptions = RMS_SERIALIZE_MOUNT;

        // mount copy
        if ( *pCopyCartId != GUID_NULL ) {
            WsbAffirmHr(MountCartridge(*pCopyCartId, &pDrive2, &pCart2, &pMover2, dwMountOptions));
        }
        else {
            GUID mediaSetId = copySetId;
            CComPtr<IRmsCartridge>  pCart;

            WsbAffirmHr(FindCartridgeById(originalCartId, &pCart));
            WsbAffirmHr(pCart->GetBlockSize(&blockSize1));
            if ( mediaSetId == GUID_NULL ) {
                WsbAffirmHr(pCart->GetMediaSetId(&mediaSetId));
            }

            //  Get capacity of original media and adjust by fudge factor
            LONGLONG capacity=0;
            CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = pCart;
            WsbAffirmHr(pInfo->GetCapacity(&capacity));

            LONG  fudge = RMS_DEFAULT_MEDIA_COPY_TOLERANCE;
            DWORD size;
            OLECHAR tmpString[256];

            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_MEDIA_COPY_TOLERANCE, tmpString, 256, &size))) {
                // Get the value.
                fudge = wcstol(tmpString, NULL, 10);
            }
            capacity -= (capacity * fudge) / 100;

            WsbAffirmHr(MountScratchCartridge( &newCartId, mediaSetId, firstSideId, &capacity, blockSize1, copyName, &pDrive2, &pCart2, &pMover2, dwMountOptions ));
        }

        // Mount original (in a non-blocking manner)
        dwMountOptions |= RMS_MOUNT_NO_BLOCK;
        WsbAffirmHr(MountCartridge(originalCartId, &pDrive1, &pCart1, &pMover1, dwMountOptions));

        // Verify matching block size (only for a non-fixed block size media)
        HRESULT hrBlock = pCart1->IsFixedBlockSize();
        WsbAffirmHr(hrBlock);
        if (hrBlock == S_FALSE) {
            if (blockSize1 == 0) {
                // didn't get it yet...
                WsbAffirmHr(pCart1->GetBlockSize(&blockSize1));
            }

            WsbAffirmHr(pCart2->GetBlockSize(&blockSize2));
            WsbAssert(blockSize1 == blockSize2, E_UNEXPECTED);
        }

        WsbAffirmHr(pMover1->Duplicate(pMover2, options, NULL, NULL));

        // Now get stats to return to caller.
        WsbAffirmHr(pMover2->GetLargestFreeSpace(&freeSpace, &capacity));

        if (pFreeSpace) {
            *pFreeSpace = freeSpace;
        }

        if (pCapacity) {
            *pCapacity = capacity;
        }

    } WsbCatch(hr)

    if ( pMover1 ) {
        DismountCartridge(originalCartId);
    }
    if ( pMover2 ) {
        // We always perform immediate dismount to the copy media
		//	(We may need to recycle a new copy in case of an error + there's no benefit in a deferred
        //  dismount for the copy-media - we don't expect the copy-media to be needed again soon)
		DWORD dwDismountOptions = RMS_DISMOUNT_IMMEDIATE;

        if (newCartId == GUID_NULL) {
            // this is the case of an existing copy
            DismountCartridge(*pCopyCartId, dwDismountOptions);
        } else {
            // this is the case of a scratch copy
            DismountCartridge(newCartId, dwDismountOptions);

            // if mounting of original failed, we always recycle the scratch copy
            if (((options & RMS_DUPLICATE_RECYCLEONERROR) || (pMover1 == NULL)) && (S_OK != hr)) {
                //
                // If we failed and a scratch mount was performed
                // we need to recycle the cartridge since the calling
                // app can't be depended upon to do this.
                //
                RecycleCartridge(newCartId, 0);
            } else {
                *pCopyCartId = newCartId;
            }
        }
    }

    WsbTraceOut(OLESTR("CRmsServer::DuplicateCartridge"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CRmsServer::RecycleCartridge(
    IN REFGUID cartId,
    IN DWORD options)
/*++

Implements:

    IRmsServer::RecycleCartridge

--*/
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::RecycleCartridge"), OLESTR("<%ls> <%d>"), WsbGuidAsString(cartId), options);

    CWsbBstrPtr cartridgeName = "";
    CWsbBstrPtr cartridgeDesc = "";

    try {
        //
        // Allow recycle when ready or in transition...
        // to handle in-progress duplicate operations.
        //
        HRESULT hrReady = IsReady();
        WsbAffirm((S_OK == hrReady) ||
                  (RMS_E_NOT_READY_SERVER_SUSPENDING == hrReady), hrReady);

        CComPtr<IRmsCartridge>  pCart;

        GUID                    mediaSetId;
        CComPtr<IRmsMediaSet>   pMediaSet;

        WsbAffirmHr(FindCartridgeById(cartId, &pCart));

        cartridgeName.Free();
        WsbAffirmHr(pCart->GetName(&cartridgeName));        // for the log message

        cartridgeDesc.Free();
        WsbAffirmHr(pCart->GetDescription(&cartridgeDesc)); // for the log message

        // Now go to the media set to deallocate
        WsbAffirmHr(pCart->GetMediaSetId(&mediaSetId));
        WsbAffirmHr(CreateObject(mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **) &pMediaSet));
        WsbAffirmHr(pMediaSet->Deallocate(pCart));

    } WsbCatch(hr)

    if ( SUCCEEDED(hr) ) {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_RECYCLED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, NULL);
    }
    else {
        WsbLogEvent(RMS_MESSAGE_CARTRIDGE_RECYCLE_FAILED, sizeof(GUID), (void *) &cartId, (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbHrAsString(hr), NULL);
    }


    WsbTraceOut(OLESTR("CRmsServer::RecycleCartridge"), OLESTR("hr = <%ls>, name/desc = <%ls/%ls>, cartId = %ls"), WsbHrAsString(hr), (WCHAR *) cartridgeName, (WCHAR *) cartridgeDesc, WsbQuickString(WsbGuidAsString(cartId)));

    return hr;
}


STDMETHODIMP
CRmsServer::FindLibraryById(
    IN REFGUID libId,
    OUT IRmsLibrary **pLib)
/*++

Implements:

    IRmsServer::FindLibraryById

--*/
{

    HRESULT hr = E_FAIL;

    CComPtr<IRmsCartridge> pFindLib;

    try {

        WsbAssertPointer( pLib );

        // Create a cartridge template
        WsbAffirmHr( CoCreateInstance( CLSID_CRmsLibrary, 0, CLSCTX_SERVER,
                                       IID_IRmsLibrary, (void **)&pFindLib ));

        // Fill in the find template
        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindLib;

        WsbAffirmHr( pObject->SetObjectId( libId ));
        WsbAffirmHr( pObject->SetFindBy( RmsFindByObjectId ));

        // Find the cartridge
        WsbAffirmHr( m_pLibraries->Find( pFindLib, IID_IRmsLibrary, (void **)pLib ));

        hr = S_OK;

    } WsbCatchAndDo(hr,
            if ( WSB_E_NOTFOUND == hr) hr = RMS_E_LIBRARY_NOT_FOUND;
            WsbTrace(OLESTR("CRmsServer::FindLibraryById - %ls Not Found.  hr = <%ls>\n"),WsbGuidAsString(libId),WsbHrAsString(hr));
        );

    return hr;
}


STDMETHODIMP
CRmsServer::FindCartridgeById(
    IN REFGUID cartId,
    OUT IRmsCartridge **ppCart)
/*++

Implements:

    IRmsServer::FindCartridgeById

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::FindCartridgeById"), OLESTR("%ls"), WsbGuidAsString(cartId));

    try {
        WsbAssertPointer(ppCart);

        //
        // The search algorithms attempts to avoid unnecessary throws that
        // clutter the trace file.  Each media management subsystem is tried.
        //

        // First check the most active cartridge.
        hr = RMS_E_CARTRIDGE_NOT_FOUND;

        if (m_pActiveCartridge) {
            GUID activeId;
            WsbAffirmHr( m_pActiveCartridge->GetCartridgeId(&activeId));
            if (activeId == cartId) {
                *ppCart = m_pActiveCartridge;
                m_pActiveCartridge->AddRef();
                hr = S_OK;
            }
        }

        if (hr != S_OK ) {

            //
            // Try native RMS
            //
            try {
                hr = S_OK;

                CComPtr<IRmsCartridge> pFindCart;

                // Create a cartridge template
                WsbAffirmHr(CoCreateInstance(CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                              IID_IRmsCartridge, (void **)&pFindCart));

                // Fill in the find template
                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindCart;

                WsbAffirmHr( pObject->SetObjectId(cartId));
                WsbAffirmHr( pObject->SetFindBy(RmsFindByObjectId));

                // Try to find the cartridge in the collection of active cartridges.
                hr = m_pActiveCartridges->Find(pFindCart, IID_IRmsCartridge, (void **)ppCart);
                WsbAffirm(S_OK == hr || WSB_E_NOTFOUND == hr, hr);

                if (WSB_E_NOTFOUND == hr) {

                    // Find the cartridge in the collection of cartridges
                    hr = m_pCartridges->Find(pFindCart, IID_IRmsCartridge, (void **)ppCart);
                    WsbAffirm(S_OK == hr || WSB_E_NOTFOUND == hr, hr);

                    if (WSB_E_NOTFOUND == hr) {
                        hr = RMS_E_CARTRIDGE_NOT_FOUND;
                    }

                }

            } WsbCatch(hr);

        }


        if ( hr != S_OK ) {

            //
            // Try NTMS
            //
            try {
                hr = S_OK;

                hr = IsNTMSInstalled();
                if ( S_OK == hr ) {
                    hr = m_pNTMS->FindCartridge(cartId, ppCart);
                    WsbAffirm(S_OK == hr || RMS_E_CARTRIDGE_NOT_FOUND == hr, hr);
                }
                else {
                    switch(hr) {
                    case RMS_E_NOT_CONFIGURED_FOR_NTMS:
                    case RMS_E_NTMS_NOT_REGISTERED:
                        // Normal errors
                        hr = RMS_E_CARTRIDGE_NOT_FOUND;
                        break;
                    default:
                        // Unexpected Error!
                        WsbThrow(hr);
                        break;
                    }
                }

            } WsbCatch(hr);

        }

    } WsbCatchAndDo(hr,
            CWsbStringPtr idString = cartId;
            WsbLogEvent(RMS_MESSAGE_CARTRIDGE_NOT_FOUND, 0, NULL, (WCHAR *) idString, WsbHrAsString(hr), NULL);
            hr = RMS_E_CARTRIDGE_NOT_FOUND;
        );


    WsbTraceOut(OLESTR("CRmsServer::FindCartridgeById"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsServer::CreateObject(
    IN REFGUID objectId,
    IN REFCLSID rclsid,
    IN REFIID riid,
    IN DWORD dwCreate,
    OUT void **ppvObj)
/*++

Implements:

    IRmsServer::CreateObject

--*/
{

    HRESULT hr = E_FAIL;


    try {

        WsbAssertPointer( ppvObj );
        WsbAssert( NULL == *ppvObj, E_INVALIDARG );

        CComPtr<IWsbIndexedCollection>  pCollection;
        CComPtr<IWsbCollectable>        pCollectable;

        if ( objectId != GUID_NULL ) {

            CComPtr<IRmsComObject> pFindObject;

            // Create an object template
            WsbAffirmHr( CoCreateInstance( rclsid, 0, CLSCTX_SERVER,
                                           IID_IRmsComObject, (void **)&pFindObject ));

            WsbAffirmHr( pFindObject->SetObjectId( objectId ));
            WsbAffirmHr( pFindObject->SetFindBy( RmsFindByObjectId ));

            // The only kinds created must support: IRmsComObject (for the object Id),
            // and IWsbCollectable (to be added to a collection).

            // See if the object is already in a collection.
            try {
                if ( CLSID_CRmsCartridge == rclsid ) {
                    pCollection = m_pCartridges;
                    WsbAffirmHrOk( m_pCartridges->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else if ( CLSID_CRmsLibrary == rclsid ) {
                    pCollection = m_pLibraries;
                    WsbAffirmHrOk( m_pLibraries->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else if ( CLSID_CRmsMediaSet == rclsid ) {
                    pCollection = m_pMediaSets;
                    WsbAffirmHrOk( m_pMediaSets->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else if ( CLSID_CRmsRequest == rclsid ) {
                    pCollection = m_pRequests;
                    WsbAffirmHrOk( m_pRequests->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else if ( CLSID_CRmsClient == rclsid ) {
                    pCollection = m_pClients;
                    WsbAffirmHrOk( m_pClients->Find( pFindObject,
                                   IID_IWsbCollectable, (void **) &pCollectable ) );
                }
                else {
                    WsbThrow( E_UNEXPECTED );
                }

                hr = S_OK;
            } WsbCatch(hr);

        }
        else if ( RmsOpenExisting == dwCreate ) {

            // If we get GUID_NULL, we must going after a default object, and we only support this
            // with existing objects. This is only legal if the default media set registry key exists.

            if ( CLSID_CRmsMediaSet == rclsid ) {

                CWsbBstrPtr defaultMediaSetName = RMS_DEFAULT_MEDIASET;

                DWORD size;
                OLECHAR tmpString[256];
                if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_DEFAULT_MEDIASET, tmpString, 256, &size))) {
                    // Get the value.
                    defaultMediaSetName = tmpString;
                }
                else {
                    WsbAssert( objectId != GUID_NULL, E_INVALIDARG );
                }

                CComPtr<IRmsComObject> pFindObject;

                // Create an object template
                WsbAffirmHr( CoCreateInstance( rclsid, 0, CLSCTX_SERVER,
                                               IID_IRmsComObject, (void **)&pFindObject ));

                WsbAffirmHr( pFindObject->SetName( defaultMediaSetName ));
                WsbAffirmHr( pFindObject->SetFindBy( RmsFindByName ));

                pCollection = m_pMediaSets;
                WsbAffirmHrOk( m_pMediaSets->Find( pFindObject,
                               IID_IWsbCollectable, (void **) &pCollectable ) );

                WsbTrace(OLESTR("Using Default MediaSet <%ls>.\n"), (WCHAR *) defaultMediaSetName);

                hr = S_OK;
            }
            else {
                WsbThrow( E_INVALIDARG );
            }
        }
        else {
            WsbThrow( E_UNEXPECTED );
        }

        // If the object wasn't found we create it here, and add it to the appropriate collection.
        switch ( (RmsCreate)dwCreate ) {
        case RmsOpenExisting:
            if ( S_OK == hr ) {
                WsbAffirmHr( pCollectable->QueryInterface( riid, ppvObj ) ); 
            }
            else {
                WsbThrow( hr );
            }
            break;

        case RmsOpenAlways:
            if ( WSB_E_NOTFOUND == hr ) {
                // Create the object
                WsbAffirmHr( CoCreateInstance( rclsid, 0, CLSCTX_SERVER,
                                               IID_IWsbCollectable, (void **) &pCollectable ));

                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
                WsbAffirmPointer( pObject );
                WsbAffirmHr( pObject->SetObjectId( objectId ) );

                // Before we add the collection, make sure the interface is supported.
                WsbAffirmHr( pCollectable->QueryInterface( riid, ppvObj )); 
                WsbAffirmPointer( pCollection );
                WsbAffirmHr( pCollection->Add( pCollectable ) );
            }
            else if ( S_OK == hr ) {
                WsbAffirmHr( pCollectable->QueryInterface( riid, ppvObj ) ); 
            }
            else {
                WsbThrow( hr );
            }
            break;

        case RmsCreateNew:
            if ( WSB_E_NOTFOUND == hr ) {
                // Create the object
                WsbAffirmHr( CoCreateInstance( rclsid, 0, CLSCTX_SERVER,
                                               IID_IWsbCollectable, (void **) &pCollectable ));

                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
                WsbAffirmPointer( pObject );
                WsbAffirmHr( pObject->SetObjectId( objectId ) );

                // Before we add the collection, make sure the interface is supported.
                WsbAffirmHr( pCollectable->QueryInterface( riid, ppvObj ) );
                WsbAffirmPointer( pCollection );
                WsbAffirmHr( pCollection->Add( pCollectable ) );
            }
            else if ( S_OK == hr ) {
                WsbThrow( RMS_E_ALREADY_EXISTS );
            }
            else {
                WsbThrow( hr );
            }
            break;

        default:
            WsbThrow( E_UNEXPECTED );
            break;

        }

        hr = S_OK;

    }
    WsbCatchAndDo( hr,
                        if ( WSB_E_NOTFOUND == hr) hr = RMS_E_NOT_FOUND;
                        WsbTrace(OLESTR("!!!!! ERROR !!!!! CRmsServer::CreateObject: %ls; hr = <%ls>\n"),WsbGuidAsString(objectId),WsbHrAsString(hr));
                  );

    return hr;
}


HRESULT
CRmsServer::getHardDrivesToUseFromRegistry(
    OUT OLECHAR *pDrivesToUse,
    OUT DWORD *pLen)
/*++


--*/
{
    HRESULT         hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::GetHardpDrivesToUseFromRegistry"),OLESTR(""));

    try {
        WsbAssert(0 != pDrivesToUse, E_POINTER); 
        WsbAssert(0 != pLen, E_POINTER); 

        DWORD           sizeGot;
        OLECHAR         tmpString[1000];

        *pLen = 0;
        pDrivesToUse[0] = OLECHAR('\0');
        pDrivesToUse[1] = OLECHAR('\0');

        //
        // Get the default value
        //
        WsbAffirmHr(WsbEnsureRegistryKeyExists (NULL, RMS_REGISTRY_STRING));
        WsbAffirmHr(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_HARD_DRIVES_TO_USE, 
                                            tmpString, RMS_DIR_LEN, &sizeGot));
        // We are doing some string manipulation here to match the Win32 call 
        // GetLogicalDriveStrings.  It returns a string of drives separated by 
        // Nulls with a double NULL at the end.  For example:  if we want to use
        // the C and E drives the string should be: C:\<null>E:\<null><null>
        // and len would be 8.
        DWORD myCharCount = 0;
        sizeGot = wcslen(tmpString);
        for (DWORD i = 0; i < sizeGot; i++) {
            swprintf((OLECHAR *)&pDrivesToUse[myCharCount], OLESTR("%c:\\"), tmpString[i]);
            myCharCount = ((i + 1)* 4);
        }
        pDrivesToUse[myCharCount] = OLECHAR('\0');
        if (myCharCount != 0)  {
            *pLen = myCharCount + 1;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::GetHardpDrivesToUseFromRegistry"),  OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    return hr;
}



HRESULT
CRmsServer::enableAsBackupOperator(void)
/*++

Routine Description:

    This routine enables backup operator privilege for the process.  This is required
    to insure that RMS has full access to all resources on the system, primarily with
    regard to the data mover.

Arguments:

    None.

Return Values:

    S_OK                        - Success.

--*/
{

    HRESULT hr = E_FAIL;

    try {

        HANDLE              pHandle;
        LUID                backupValue;
        HANDLE              tokenHandle;
        TOKEN_PRIVILEGES    newState;
        DWORD               lErr;

        pHandle = GetCurrentProcess();
        WsbAffirmStatus(OpenProcessToken(pHandle, MAXIMUM_ALLOWED, &tokenHandle));
        //
        // adjust backup token privileges
        //
        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeBackupPrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));
        //
        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        //
        if ( (lErr = GetLastError()) != ERROR_SUCCESS ) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            //
            WsbLogEvent( RMS_MESSAGE_SERVICE_UNABLE_TO_SET_BACKUP_PRIVILEGE, 0, NULL,
                         WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );
        }

        WsbAffirmStatus(LookupPrivilegeValueW(NULL, L"SeRestorePrivilege", &backupValue));
        newState.PrivilegeCount = 1;
        newState.Privileges[0].Luid = backupValue;
        newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        WsbAffirmStatus(AdjustTokenPrivileges(tokenHandle, FALSE, &newState, (DWORD)0, NULL, NULL));
        //
        // Note that AdjustTokenPrivileges may return success even if it did not assign all privileges.
        // We check last error here to insure everything was set.
        //
        if ( (lErr = GetLastError()) != ERROR_SUCCESS ) {
            // Not backup user or some other error
            //
            // TODO: Should we fail here or just log something?
            //
            WsbLogEvent( RMS_MESSAGE_SERVICE_UNABLE_TO_SET_RESTORE_PRIVILEGE, 0, NULL,
                              WsbHrAsString(HRESULT_FROM_WIN32(lErr)), NULL );

        }
        CloseHandle( tokenHandle );

        hr = S_OK;

    }
    WsbCatch( hr );

    return hr;

}


STDMETHODIMP 
CRmsServer::ChangeState(
    IN LONG newState)
/*++

Implements:

    IRmsServer::CreateObject

--*/
{

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::ChangeState"), OLESTR("<%d>"), newState);

    try {

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
        WsbAssertPointer( pObject );

        switch ((RmsServerState) newState) {
        case RmsServerStateStarting:
        case RmsServerStateStarted:
        case RmsServerStateInitializing:
        case RmsServerStateReady:
        case RmsServerStateStopping:
        case RmsServerStateStopped:
        case RmsServerStateSuspending:
        case RmsServerStateSuspended:
        case RmsServerStateResuming:
            WsbAffirmHr(pObject->SetState(newState));
            break;
        default:
            WsbAssert(0, E_UNEXPECTED);
            break;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsServer::ChangeState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsServer::IsReady(void)
/*++

Implements:

    IRmsServer::IsReady

--*/
{

    HRESULT hr = S_OK;

    try {

        BOOL isEnabled;
        HRESULT status;
        RmsServerState state;

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
        WsbAssertPointer( pObject );

        WsbAffirm(m_LockReference == 0, RMS_E_NOT_READY_SERVER_LOCKED);

        WsbAffirmHr( isEnabled = pObject->IsEnabled());
        WsbAffirmHr( pObject->GetState( (LONG *)&state ));
        WsbAffirmHr( pObject->GetStatusCode( &status ));

        if ( S_OK == isEnabled ) {
            if ( RmsServerStateReady == state ) {
                hr = S_OK;
            }
            else {
                if ( S_OK == status ) {
                    switch ( state ) {
                    case RmsServerStateStarting:
                        WsbThrow(RMS_E_NOT_READY_SERVER_STARTING);
                        break;
                    case RmsServerStateStarted:
                        WsbThrow(RMS_E_NOT_READY_SERVER_STARTED);
                        break;
                    case RmsServerStateInitializing:
                        WsbThrow(RMS_E_NOT_READY_SERVER_INITIALIZING);
                        break;
                    case RmsServerStateStopping:
                        WsbThrow(RMS_E_NOT_READY_SERVER_STOPPING);
                        break;
                    case RmsServerStateStopped:
                        WsbThrow(RMS_E_NOT_READY_SERVER_STOPPED);
                        break;
                    case RmsServerStateSuspending:
                        WsbThrow(RMS_E_NOT_READY_SERVER_SUSPENDING);
                        break;
                    case RmsServerStateSuspended:
                        WsbThrow(RMS_E_NOT_READY_SERVER_SUSPENDED);
                        break;
                    case RmsServerStateResuming:
                        WsbThrow(RMS_E_NOT_READY_SERVER_RESUMING);
                        break;
                    default:
                        WsbThrow(E_UNEXPECTED);
                        break;
                    }
                }
                else {
                    WsbThrow(status);
                }
            }
        }
        else {
            if ( S_OK == status ) {
                WsbThrow(RMS_E_NOT_READY_SERVER_DISABLED);
            }
            else {
                WsbThrow(status);
            }
        }

    } WsbCatch(hr);

    return hr;
}


HRESULT
CRmsServer::ChangeSysState( 
    IN OUT HSM_SYSTEM_STATE* pSysState 
    )

/*++

Implements:

  IHsmSystemState::ChangeSysState().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::ChangeSysState"), OLESTR("State = %lx"), 
            pSysState->State);
    
    try {
        if ((pSysState->State & HSM_STATE_SHUTDOWN) ||
            (pSysState->State & HSM_STATE_SUSPEND)) {
            //
            // Shutdown or Suspend operations
            //
            // For power mangement support we need to release
            // all device handles, and the NTMS (RSM) session handle.
            //
            // To accomplish this we simply disable each cartridge,
            // then disable NTMS.
            //
            // The fallout from this gets everything in the power ready state.
            //

            WsbAffirmHr(ChangeState(RmsServerStateSuspending));

            //
            // Suspend operations with NMTS.  This will cancel any in-progress mounts.
            //
            WsbAffirmHr(m_pNTMS->Suspend());

            //
            // Disable each of the active cartridges
            //
            CComPtr<IWsbEnum>       pEnumCartridges;
            CComPtr<IWsbEnum>       pEnumDataMovers;
            CComPtr<IRmsComObject>  pObject;
            CComPtr<IRmsCartridge>  pCart;
            CComPtr<IDataMover>     pMover;
            CComPtr<IRmsDrive>      pDrive;

            WsbAffirmHr( m_pActiveCartridges->Enum( &pEnumCartridges ));
            WsbAssertPointer( pEnumCartridges );

            //
            // Disable each cartridge.
            //

            hr = pEnumCartridges->First( IID_IRmsComObject, (void **)&pObject );
            while (S_OK == hr) {
                try {
                    WsbAffirmHr(pObject->Disable(RMS_E_NOT_READY_SERVER_SUSPENDING));
                } WsbCatch(hr);

                pObject = 0;
                hr = pEnumCartridges->Next( IID_IRmsComObject, (void **)&pObject );
            }
            hr = S_OK;


/*
            Tracking DataMovers is only partially implemented.


            //
            // Cancel I/O requests.
            //

            WsbAffirmHr( m_pDataMovers->Enum( &pEnumDataMovers ));
            WsbAssertPointer( pEnumDataMovers );
            hr = pEnumDataMovers->First( IID_IDataMover, (void **)&pMover );
            while (S_OK == hr) {
                try {
                    WsbAffirmHr(pMover->Cancel());
                } WsbCatch(hr);

                pMover = 0;
                hr = pEnumDataMovers->Next( IID_IDataMover, (void **)&pMover );
            }
            hr = S_OK;

*/

            //
            // Unload all drives.
            //

            hr = pEnumCartridges->First( IID_IRmsCartridge, (void **)&pCart );
            while (S_OK == hr) {
                try {
                    WsbAffirmHr(pCart->GetDrive(&pDrive));
                    WsbAffirmHr(pDrive->UnloadNow());
                } WsbCatch(hr);

                pDrive = 0;
                pCart = 0;

                //
                // We use "->This" since the UnloadNow() method will wait
                // until the active cartridge is dismount, and removed
                // from the active cartridge list.
                //
                hr = pEnumCartridges->This( IID_IRmsCartridge, (void **)&pCart );
            }
            hr = S_OK;

            //
            // Suspend operations with NMTS.  This will close the NTMS handle in
            // case it was reopend for dismounts during shutdown.
            //
            WsbAffirmHr(m_pNTMS->Suspend());

            WsbAffirmHr(ChangeState(RmsServerStateSuspended));

        } else if (pSysState->State & HSM_STATE_RESUME) {
            //
            // Resume operations
            //
            WsbAffirmHr(ChangeState(RmsServerStateResuming));

            WsbAffirmHr(m_pNTMS->Resume());

            CComPtr<IWsbEnum>      pEnumCartridges;
            CComPtr<IRmsComObject> pObject;

            WsbAffirmHr( m_pActiveCartridges->Enum( &pEnumCartridges ));
            WsbAssertPointer( pEnumCartridges );

            //
            // Enable each of the active cartridges
            //
            hr = pEnumCartridges->First( IID_IRmsComObject, (void **)&pObject );
            while (S_OK == hr) {
                try {
                    WsbAffirmHr(pObject->Enable());
                } WsbCatch(hr);

                pObject = 0;
                hr = pEnumCartridges->Next( IID_IRmsComObject, (void **)&pObject );
            }
            hr = S_OK;

            WsbAffirmHr(ChangeState(RmsServerStateReady));

        }
        
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CRmsServer::ChangeSysState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsServer::GetNofAvailableDrives( 
    IN REFGUID fromMediaSet,
    OUT DWORD* pdwNofDrives 
    )

/*++

Implements:

  IRmsServer::GetNofAvailableDrives().

--*/
{
    HRESULT                         hr = S_OK;

    WsbTraceIn(OLESTR("CRmsServer::GetNofAvailableDrives"), OLESTR(""));

    try {
        WsbAssertPointer(pdwNofDrives);
        *pdwNofDrives = 0;

        // Get the media set
        CComPtr<IRmsMediaSet>   pMediaSet;
        WsbAffirmHr(CreateObject(fromMediaSet, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **) &pMediaSet));

        // Check if the media set is of fixed drives
        LONG mediaType;
        WsbAffirmHr(pMediaSet->GetMediaSupported(&mediaType));

        if (RmsMediaFixed == mediaType) {
            // Count fixed drives
            // We take a shortcut here and just use number of drives that were counted
            //  during initialization. (FindCartridgeStatusById can give current state)
            *pdwNofDrives = m_HardDrivesUsed;
        } else {
            // Just use NTMS
            // TEMPORARY - We might want RmsNtms to use media-set info as well,
            //  in order not to count both tape and optical drives on a system that has both
            WsbAffirmHr(m_pNTMS->GetNofAvailableDrives(pdwNofDrives));
        }

    } WsbCatch(hr);

    WsbTrace(OLESTR("CRmsServer::GetNofAvailableDrives: Number of enabled drives is %lu\n"), *pdwNofDrives);

    WsbTraceOut(OLESTR("CRmsServer::GetNofAvailableDrives"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsServer::FindCartridgeStatusById( 
    IN REFGUID cartId,
    OUT DWORD* pdwStatus 
    )

/*++

Implements:

  IRmsServer::FindCartridgeStatusById().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IRmsCartridge>          pCart;
    CComPtr<IRmsCartridge>          pFindCart;

    WsbTraceIn(OLESTR("CRmsServer::FindCartridgeStatusById"), OLESTR("cartId = %ls"), WsbGuidAsString(cartId));

    try {
        WsbAssertPointer(pdwStatus);
        *pdwStatus = 0;

        // Try native RMS, Currently this should succeed only if media is a fixed drive
        WsbAffirmHr(CoCreateInstance(CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                      IID_IRmsCartridge, (void **)&pFindCart));

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindCart;

        WsbAffirmHr(pObject->SetObjectId(cartId));
        WsbAffirmHr(pObject->SetFindBy(RmsFindByObjectId));

        hr = m_pCartridges->Find(pFindCart, IID_IRmsCartridge, (void **)&pCart);
        WsbAffirm(S_OK == hr || WSB_E_NOTFOUND == hr, hr);
        if (WSB_E_NOTFOUND == hr) {
            hr = RMS_E_CARTRIDGE_NOT_FOUND;
        }

        // Search in RSM 
        if (S_OK != hr) {
            hr = IsNTMSInstalled();
            if (S_OK == hr) {
                hr = m_pNTMS->FindCartridge(cartId, &pCart);
                WsbAffirm(S_OK == hr || RMS_E_CARTRIDGE_NOT_FOUND == hr, hr);
            } else {
                switch(hr) {
                    case RMS_E_NOT_CONFIGURED_FOR_NTMS:
                    case RMS_E_NTMS_NOT_REGISTERED:
                        // Normal errors
                        hr = RMS_E_CARTRIDGE_NOT_FOUND;
                        break;
                    default:
                        // Unexpected Error!
                        WsbThrow(hr);
                        break;
                }
            }
        }
        
        // if media found...
        if (S_OK == hr) {
            // Check media type
            LONG mediaType;
            WsbAffirmHr(pCart->GetType(&mediaType));

            if (RmsMediaFixed != mediaType) {
                // RSM media

                // set flags
                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCart;
                WsbAffirmPointer(pObject);
                if (S_OK == pObject->IsEnabled()) {
                    (*pdwStatus) |= RMS_MEDIA_ENABLED;
                }

                if (S_OK == pCart->IsAvailable()) {
                    (*pdwStatus) |= RMS_MEDIA_AVAILABLE;
                }

                LONG lLocationType;
                GUID Dum1,Dum2;
                LONG lDum3, lDum4, lDum5, lDum6;
                BOOL bDum7;
                WsbAffirmHr(pCart->GetLocation(&lLocationType, &Dum1, &Dum2, &lDum3, &lDum4, 
                                &lDum5, &lDum6, &bDum7));
                switch (lLocationType) {
                    case RmsElementUnknown:
                    case RmsElementShelf:
                    case RmsElementOffSite:
                        // media is offline...
                        break;

                    default:
                        (*pdwStatus) |= RMS_MEDIA_ONLINE;
                        break;
                }

            } else {
                // Fixed drive - just try to access the volume and see if it's still valid
                // If so, set all flags, otherwise, set none
                CComPtr<IRmsDrive>      pDrive;
                CWsbBstrPtr             driveName;
                WCHAR                   fileSystemType[MAX_PATH];

                // Get drive name (volume name for fixed drives) to check
                WsbAffirmHr(pCart->GetDrive(&pDrive));
                CComQIPtr<IRmsDevice, &IID_IRmsDevice> pDevice = pDrive;
                WsbAssertPointer(pDevice);
                WsbAffirmHr(pDevice->GetDeviceName(&driveName));

                if (GetVolumeInformation((WCHAR *)driveName, NULL, 0,
                    NULL, NULL, NULL, fileSystemType, MAX_PATH) ) {
                    if (0 == wcscmp(L"NTFS", fileSystemType)) {
                        // Volume is ready for migration - set all flags
                        (*pdwStatus) |= (RMS_MEDIA_ENABLED | RMS_MEDIA_ONLINE | RMS_MEDIA_AVAILABLE);
                    } else {
                        // Not NTFS - don't use that volume
                        WsbTrace(OLESTR("CRmsServer::FindCartridgeStatusById: Fixed volume %ls is formatted to %ls\n"), 
                            (WCHAR *)driveName, fileSystemType);
                    }
                } else {
                    // Volume is not available - don't use it
                    WsbTrace(OLESTR("CRmsServer::FindCartridgeStatusById: GetVolumeInformation returned %lu for Fixed volume %ls\n"), 
                        GetLastError(), (WCHAR *)driveName);
                }
            }

        }

    } WsbCatch(hr);

    WsbTrace(OLESTR("CRmsServer::FindCartridgeStatusById: Status bits are %lX\n"), *pdwStatus);

    WsbTraceOut(OLESTR("CRmsServer::FindCartridgeStatusById"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CRmsServer::IsMultipleSidedMedia(
                IN REFGUID mediaSetId
                )
/*++

Implements:

    IRmsServer::IsMultipleSidedMedia

Notes:

    Currently, optical & DVD media types are reported as multiple sided media
    Tapes and fixed disks would fall in the default - one side media

--*/
{
    HRESULT hr = S_FALSE;
    WsbTraceIn(OLESTR("CRmsServer::IsMultipleSidedMedia"), OLESTR(""));

    try {
        // Multiple sided is currently determined if the media set is optical or not
        // This may change to include other media types of according two other characteristics
        CComPtr<IRmsMediaSet>   pMediaSet;
        LONG                    mediaType;                

        if (mediaSetId != GUID_NULL) {
            // if input media set is non-null, check this data-set. 
            WsbAffirmHr(CreateObject(mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenAlways, (void **)&pMediaSet));
            WsbAffirmHr(pMediaSet->GetMediaSupported(&mediaType));
            if ((RmsMediaOptical == mediaType) || (RmsMediaDVD == mediaType)) {
                hr = S_OK;
            }
        
        } else {
            // Otherwise, enumerate the collection seeking for any media set that might have two sides
            CComPtr<IWsbEnum>  pEnumSets;

            WsbAffirmHr(m_pMediaSets->Enum(&pEnumSets));
            WsbAssertPointer(pEnumSets);
            hr = pEnumSets->First(IID_IRmsMediaSet, (void **)&pMediaSet);
            while (S_OK == hr) {
                WsbAffirmHr(pMediaSet->GetMediaSupported(&mediaType));
                if ((RmsMediaOptical == mediaType) || (RmsMediaDVD == mediaType)) {
                    hr = S_OK;
                    break;
                }

                hr = pEnumSets->Next(IID_IRmsMediaSet, (void **)&pMediaSet);
                if (hr == WSB_E_NOTFOUND) {
                    hr = S_FALSE;
                } else {
                    WsbAffirmHr(hr);
                }
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsServer::IsMultipleSidedMedia"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}

HRESULT
CRmsServer::CheckSecondSide( 
    IN REFGUID firstSideId,
    OUT BOOL *pbValid,
    OUT GUID *pSecondSideId
    )
/*++

Implements:

  IRmsServer::CheckSecondSide().

Notes:

  It is not expected that this utility is called on a single sided media.
  If it does, it would return invalid second side for tape and would fail on fixed disks.

--*/
{
    HRESULT  hr = S_OK;
    WsbTraceIn(OLESTR("CRmsServer::CheckSecondSide"), OLESTR(""));

    try {
        // just use NTMS (RmsServer collections are not used today!)
        WsbAffirmHr(m_pNTMS->CheckSecondSide(firstSideId, pbValid, pSecondSideId));

    } WsbCatch(hr);

    WsbTrace(OLESTR("CRmsServer::CheckSecondSide: Valid second side: %ls, id=<%ls>\n"), 
        WsbBoolAsString(*pbValid), WsbGuidAsString(*pSecondSideId));

    WsbTraceOut(OLESTR("CRmsServer::CheckSecondSide"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsservr.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsServr.h

Abstract:

    Declaration of the CRmsServer class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSSERVR_
#define _RMSSERVR_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

//
// Registry entry
//

class CRmsServer :
    public CComDualImpl<IRmsServer, &IID_IRmsServer, &LIBID_RMSLib>,
    public IHsmSystemState,
    public CRmsComObject,
    public CWsbPersistStream,
    public IConnectionPointContainerImpl<CRmsServer>,
    public IConnectionPointImpl<CRmsServer, &IID_IRmsSinkEveryEvent, CComDynamicUnkArray>,
    public CComCoClass<CRmsServer,&CLSID_CRmsServer>
{
public:
    CRmsServer() {}
BEGIN_COM_MAP(CRmsServer)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsServer)
    COM_INTERFACE_ENTRY(IRmsServer)
    COM_INTERFACE_ENTRY(IHsmSystemState)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CRmsServer)
DECLARE_REGISTRY_RESOURCEID(IDR_RmsServer)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_CONNECTION_POINT_MAP(CRmsServer)
    CONNECTION_POINT_ENTRY(IID_IRmsSinkEveryEvent)
END_CONNECTION_POINT_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(
        OUT CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(
        OUT ULARGE_INTEGER* pSize);

    STDMETHOD(Load)(
        IN IStream* pStream);

    STDMETHOD(Save)(
        IN IStream* pStream,
        IN BOOL clearDirty);

// IHsmSystemState
public:
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

// IRmsServer
public:
    STDMETHOD( InitializeInAnotherThread )(void);

    STDMETHOD( Initialize )(void);

    STDMETHOD( SaveAll )(void);

    STDMETHOD( Unload )(void);

    STDMETHOD( GetServerName )(
        OUT BSTR *pName);

    STDMETHOD( GetCartridges )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetActiveCartridges )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetDataMovers )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( SetActiveCartridge )(
        IN IRmsCartridge *ptr);

    STDMETHOD( GetLibraries )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetMediaSets )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetRequests )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetClients )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( GetUnconfiguredDevices )(
        OUT IWsbIndexedCollection **ptr);

    STDMETHOD( ScanForDevices )(void);

    STDMETHOD( ScanForDrives )(void);

    STDMETHOD( MountScratchCartridge )(
        OUT GUID *pCartId,
        IN REFGUID fromMediaSet,
        IN REFGUID prevSideId,
        IN OUT LONGLONG *pFreeSpace,
        IN LONG blockingFactor,
        IN BSTR displayName,
        IN OUT IRmsDrive **ppDrive,
        OUT IRmsCartridge **ppCartridge,
        OUT IDataMover **ppDataMover,
		IN DWORD dwOptions = RMS_NONE);

    STDMETHOD( MountCartridge )(
        IN REFGUID cartId,
        IN OUT IRmsDrive **ppDrive,
        OUT IRmsCartridge **ppCartridge,
        OUT IDataMover **ppDataMover,
		IN DWORD dwOptions = RMS_NONE,
		IN DWORD threadId  = 0);

    STDMETHOD( DismountCartridge )(
        IN REFGUID cartId,
		IN DWORD dwOptions = RMS_NONE);

    STDMETHOD( DuplicateCartridge )(
        IN REFGUID cartId,
        IN REFGUID firstSideId,
        IN OUT GUID *pCopyCartId,
        IN REFGUID copySetId,
        IN BSTR copyName,
        OUT LONGLONG *pFreeSpace,
        OUT LONGLONG *pCapacity,
        IN DWORD options);

    STDMETHOD( RecycleCartridge )(
        IN REFGUID cartId,
        IN DWORD options);

    STDMETHOD( FindLibraryById )(
        IN REFGUID libId,
        OUT IRmsLibrary **ptr);

    STDMETHOD( FindCartridgeById )(
        IN REFGUID cartId,
        OUT IRmsCartridge **ptr);

    STDMETHOD( CreateObject )(
        IN REFGUID objectId,
        IN REFCLSID rclsid,
        IN REFIID riid,
        IN DWORD dwCreate,
        OUT void **ppvObj);

    STDMETHOD( IsNTMSInstalled )(void);

    STDMETHOD( GetNTMS )(
        OUT IRmsNTMS **ptr);

    STDMETHOD( IsReady )(void);

    STDMETHOD( ChangeState )(
        IN LONG newState);

    STDMETHOD( GetNofAvailableDrives ) (
        IN REFGUID fromMediaSet,
        OUT DWORD *pdwNofDrives);

    STDMETHOD( FindCartridgeStatusById )(
        IN REFGUID cartId,
        OUT DWORD *dwStatus);

    STDMETHOD( IsMultipleSidedMedia )(
        IN REFGUID mediaSetId);

    STDMETHOD( CheckSecondSide )( 
        IN REFGUID firstSideId,
        OUT BOOL *pbValid,
        OUT GUID *pSecondSideId);


// CRmsServer
private:
    HRESULT resolveUnconfiguredDevices(void);

    HRESULT autoConfigureDevices(void);

    HRESULT processInquiryData(
        IN int portNumber,
        IN UCHAR *pPortScanData);

    HRESULT findDriveLetter(
        IN UCHAR portNo,
        IN UCHAR pathNo,
        IN UCHAR id,
        IN UCHAR lun,
        OUT OLECHAR *driveString);

    HRESULT getDeviceName(
        IN UCHAR portNo, 
        IN UCHAR pathNo,
        IN UCHAR id,
        IN UCHAR lun,
        OUT OLECHAR *deviceName);

    HRESULT getHardDrivesToUseFromRegistry(
        OUT OLECHAR *pDrivesToUse, OUT DWORD *pLen);

    HRESULT enableAsBackupOperator(void);

private:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxActive = 8                       // Max number of active cartridges.
    };

    CWsbStringPtr                       m_dbPath;       // The directory where databases are stored.
    LONG                                m_LockReference;// The server lock used for blocking normal access during synchornized operations.
    CWsbBstrPtr                         m_ServerName;   // The name of the computer running the server.
    CComPtr<IWsbIndexedCollection>      m_pCartridges;  // The cartridges known to the server.
    CComPtr<IWsbIndexedCollection>      m_pLibraries;   // The libraries managed by the server.
    CComPtr<IWsbIndexedCollection>      m_pMediaSets;   // The media sets known to the server.
    CComPtr<IWsbIndexedCollection>      m_pRequests;    // The requests associated with the server.
    CComPtr<IWsbIndexedCollection>      m_pClients;     // The clients associated with the server.
    CComPtr<IWsbIndexedCollection>      m_pUnconfiguredDevices;     // The unconfigured devices associated with the server.
    CComPtr<IRmsNTMS>                   m_pNTMS;        // NTMS support.
    ULONG                               m_HardDrivesUsed; // the number of hard drives in use by RMS.
    
    //typedef List<int> LISTINT;

    //LISTINT::iterator i;
    //LISTINT test;                   
    //List<IRmsCartridge *>               m_ListOfActiveCartridges;   // The cartridges already mounted into a drive.
    //List<IRmsCartridge *>::iterator     m_IteratorForListOfActiveCartridges;  // The cartridges already mounted into a drive.
    CComPtr<IWsbIndexedCollection>      m_pActiveCartridges;        // The cartridges already mounted into a drive.
    CComPtr<IWsbIndexedCollection>      m_pDataMovers;              // The active data movers.
    CComPtr<IRmsCartridge>              m_pActiveCartridge ;        // The cartridges already mounted into a drive.

// Thread routines
public:
    static DWORD WINAPI InitializationThread(
        IN LPVOID pv);

};

/////////////////////////////////////////////////////////////////////////////
//
//        g_pServer
//
//  This is made global so that anybody in the context of Rms has
//  quick access to it
//

extern IRmsServer *g_pServer;
extern CRITICAL_SECTION g_CriticalSection;

#endif // _RMSSERVR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmssinfo.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsSInfo.h

Abstract:

    Declaration of the CRmsStorageInfo class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSSINFO_
#define _RMSSINFO_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsStorageInfo

Class Description:

    A CRmsStorageInfo represents storage information about a Cartridge, Partition, or
    MediaSet.  Various statistics about an element are kept for an object of this
    type.  These include the number of times a Cartridge, or Partition has been put into
    the element or taken from (get) the element.

--*/

class CRmsStorageInfo :
    public CComDualImpl<IRmsStorageInfo, &IID_IRmsStorageInfo, &LIBID_RMSLib>,
    public CRmsComObject
{
public:
    CRmsStorageInfo();

// CRmsStorageInfo
public:

    HRESULT GetSizeMax(ULARGE_INTEGER* pSize);
    HRESULT Load(IStream* pStream);
    HRESULT Save(IStream* pStream, BOOL clearDirty);

    HRESULT CompareTo(IUnknown* pCollectable, SHORT* pResult);

    HRESULT Test(USHORT *pPassed, USHORT *pFailed);

// IRmsStorageInfo
public:
    STDMETHOD(GetMountCounters)(LONG *pReads, LONG *pWrites);

    STDMETHOD(GetBytesRead2)(LONG *pReadHi, LONG *pReadLo);
    STDMETHOD(GetBytesRead)(LONGLONG *pRead);
    STDMETHOD(SetBytesRead2)(LONG readHi, LONG readLo);
    STDMETHOD(SetBytesRead)(LONGLONG read);
    STDMETHOD(IncrementBytesRead)(LONG val);

    STDMETHOD(GetBytesWritten2)(LONG *pWriteHi, LONG *pWriteLo);
    STDMETHOD(GetBytesWritten)(LONGLONG *pWritten);
    STDMETHOD(SetBytesWritten2)(LONG writeHi, LONG writeLo);
    STDMETHOD(SetBytesWritten)(LONGLONG written);
    STDMETHOD(IncrementBytesWritten)(LONG val);

    STDMETHOD(GetCapacity2)(LONG *pCapHi, LONG *pCapLo);
    STDMETHOD(GetCapacity)(LONGLONG *pCap);
    STDMETHOD(GetUsedSpace2)(LONG *pUsedHi, LONG *pUsedLo);
    STDMETHOD(GetUsedSpace)(LONGLONG *pUsed);
    STDMETHOD(GetLargestFreeSpace2)(LONG *pFreeHi, LONG *pFreeLo);
    STDMETHOD(GetLargestFreeSpace)(LONGLONG *pFree);

    STDMETHOD(SetCapacity)(IN LONGLONG cap);
    STDMETHOD(SetUsedSpace)(IN LONGLONG used);
    STDMETHOD(SetFreeSpace)(IN LONGLONG free);

    STDMETHOD(ResetCounters)(void);
    // STDMETHOD(ResetAllCounters)(void) = 0;

    STDMETHOD(GetResetCounterTimestamp)(DATE *pDate);
    STDMETHOD(GetLastReadTimestamp)(DATE *pDate);
    STDMETHOD(GetLastWriteTimestamp)(DATE *pDate);
    STDMETHOD(GetCreatedTimestamp)(DATE *pDate);

////////////////////////////////////////////////////////////////////////////////////////
//
// data members
//

protected:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    LONG            m_readMountCounter;     // A resetable counter holding
                                            //   the number of times the storage object
                                            //   has been mounted for read access.
    LONG            m_writeMountCounter;    // A resetable counter holding
                                            //   the number of times the storage object
                                            //   has been mounted for write access.
    LONGLONG        m_bytesWrittenCounter;  // Amount of data written to a storage
                                            //   object.
                                            //   Note: For some devices this has to be
                                            //   provided by the application.
    LONGLONG        m_bytesReadCounter;     // Amount of data read from a storage
                                            //   object.
                                            //   Note: For some devices this has to be
                                            //   provided by the application.
    LONGLONG        m_capacity;             // The total capacity, in bytes, of the
                                            //   storage object.  This is a best
                                            //   guess for tape media.  For media, the
                                            //   value is usually provided by the device driver.
    LONGLONG        m_usedSpace;            // A calculated value that represents the
                                            //   effective used space in the storage
                                            //   object, in bytes.  It is not necessarily
                                            //   equal to the difference between the
                                            //   capacity and largest free space.  For
                                            //   example, compressible media can effectively
                                            //   hold significantly more data that non-compressible
                                            //   media.  In this case the free space is a
                                            //   function of both compression ratio of the data
                                            //   and the number of bytes written to the media.
                                            //   Deleted files must be accounted for.
    LONGLONG        m_largestFreeSpace;     // Largest usable free space in the
                                            //   storage object, in bytes.  For media,
                                            //   the value is usually provided
                                            //   by the device driver. Negative numbers
                                            //   indicate last known value for free space.
    DATE            m_resetCounterTimestamp;// The date the counters were reset.
    DATE            m_lastReadTimestamp;    // The date of last access for read.
    DATE            m_lastWriteTimestamp;   // The date of last access of write.
    DATE            m_createdTimestamp;     // The date the storage object was created.
};

#endif // _RMSSINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmssinfo.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsSInfo.cpp

Abstract:

    Implementation of CRmsStorageInfo

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsSInfo.h"

extern IUnknown *g_pServer;

/////////////////////////////////////////////////////////////////////////////
//
// IRmsStorageInfo implementation
//


CRmsStorageInfo::CRmsStorageInfo(
    void
    )
/*++

Routine Description:

    CRmsStorageInfo constructor

Arguments:

    None

Return Value:

    None

--*/
{
    // Initialize values
    m_readMountCounter = 0;

    m_writeMountCounter = 0;

    m_bytesWrittenCounter = 0;

    m_bytesReadCounter = 0;

    m_capacity = 0;

    m_usedSpace = 0;

    m_largestFreeSpace = -1;

    m_resetCounterTimestamp = 0;

    m_lastReadTimestamp = 0;

    m_lastWriteTimestamp = 0;

    m_createdTimestamp = 0;
}


HRESULT
CRmsStorageInfo::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    CRmsStorageInfo::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsStorageInfo::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByUnknown:
        default:

            // What default makes sense?
            WsbAssertHr( E_UNEXPECTED );
            break;

        }

    }
    WsbCatch(hr);

    if ( 0 != pResult ) {
       *pResult = result;
    }

    WsbTraceOut(OLESTR("CRmsStorageInfo::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CRmsStorageInfo::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsStorageInfo::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG) +           // m_readMountCounter
//                             WsbPersistSizeOf(LONG) +           // m_writeMountCounter
//                             WsbPersistSizeOf(LONGLONG) +       // m_bytesWrittenCounter
//                             WsbPersistSizeOf(LONGLONG) +       // m_bytesReadCounter
//                             WsbPersistSizeOf(LONGLONG) +       // m_capacity
//                             WsbPersistSizeOf(LONGLONG) +       // m_usedSpace
//                             WsbPersistSizeOf(LONGLONG) +       // m_largestFreeSpace
//                             WsbPersistSizeOf(DATE)     +       // m_resetCounterTimestamp
//                             WsbPersistSizeOf(DATE)     +       // m_lastReadTimestamp
//                             WsbPersistSizeOf(DATE)     +       // m_lastWriteTimestamp
//                             WsbPersistSizeOf(DATE);            // m_createdTimestamp

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageInfo::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CRmsStorageInfo::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsStorageInfo::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_readMountCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_writeMountCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_bytesWrittenCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_bytesReadCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_capacity));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_usedSpace));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_largestFreeSpace));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageInfo::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsStorageInfo::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsStorageInfo::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_readMountCounter));
        
        WsbAffirmHr(WsbSaveToStream(pStream, m_writeMountCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_bytesWrittenCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_bytesReadCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_capacity));

        WsbAffirmHr(WsbSaveToStream(pStream, m_usedSpace));

        WsbAffirmHr(WsbSaveToStream(pStream, m_largestFreeSpace));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_resetCounterTimestamp));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_lastReadTimestamp));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_lastWriteTimestamp));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_createdTimestamp));


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageInfo::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsStorageInfo::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>   pMediaSet1;
    CComPtr<IRmsMediaSet>   pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longHiVal1 = 12345;
    LONG                    longLoVal1 = 67890;

    LONG                    longHiWork1;
    LONG                    longLoWork1;

    LONG                    longVal1 = 11111111;
    LONG                    longWork1;

    LONG                    longVal2 = 22222222;
    LONG                    longWork2;

    LONGLONG                longLongVal1 = 1111111111111111;
    LONGLONG                longLongWork1;

    LONG                    cntBase = 100000;
    LONG                    cntIncr = 25;


//  DATE                    dateVal1 = today;
    DATE                    dateVal1 = 0;
//  DATE                    dateWork1;


    WsbTraceIn(OLESTR("CRmsStorageInfo::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            // Test GetMountCounters
            ResetCounters();

            GetMountCounters(&longWork1, &longWork2);

            if((longVal1 == 0) &&
               (longVal2 == 0)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test SetBytesRead & GetBytesRead
            SetBytesRead(longLongVal1);

            GetBytesRead(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test SetBytesRead2 & GetBytesRead2
            SetBytesRead2(longHiVal1, longLoVal1);

            GetBytesRead2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test IncrementBytesRead

            for(i = 0; i < 500; i += cntIncr){
                SetBytesRead(cntBase + i);

                IncrementBytesRead(cntIncr);

                GetBytesRead(&longLongWork1);

                if (longLongWork1 == (cntBase + i + cntIncr)){
                   (*pPassed)++;
                }  else {
                    (*pFailed)++;
                }
            }

            // Test SetBytesWritten & GetBytesWritten
            SetBytesWritten(longLongVal1);

            GetBytesWritten(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test SetBytesWritten2 & GetBytesWritten2
            SetBytesWritten2(longHiVal1, longLoVal1);

            GetBytesWritten2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test IncrementBytesWritten

            for(i = 0; i < 500; i += cntIncr){
                SetBytesWritten(cntBase + i);

                IncrementBytesWritten(cntIncr);

                GetBytesWritten(&longLongWork1);

                if (longLongWork1 == (cntBase + i + cntIncr)){
                   (*pPassed)++;
                }  else {
                    (*pFailed)++;
                }
            }

            // Test GetCapacity
            m_capacity = longLongVal1;

            GetCapacity(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetCapacity2
            m_capacity = (LONGLONG) (longHiVal1 << 32) + longLoVal1;

            GetCapacity2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetUsedSpace
            m_usedSpace = longLongVal1;

            GetUsedSpace(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetUsedSpace2
            m_usedSpace = (LONGLONG) (longHiVal1 << 32) + longLoVal1;

            GetUsedSpace2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetLargestFreeSpace
            m_largestFreeSpace = longLongVal1;

            GetLargestFreeSpace(&longLongWork1);

            if((longLongVal1 == longLongWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

            // Test GetLargestFreeSpace2
            m_largestFreeSpace = (LONGLONG) (longHiVal1 << 32) + longLoVal1;

            GetLargestFreeSpace2(&longHiWork1, &longLoWork1);

            if((longHiVal1 == longHiWork1) &&
               (longLoVal1 == longLoWork1)){
               (*pPassed)++;
            }  else {
                (*pFailed)++;
            }

//          Handle all date stamp values

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageInfo::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsStorageInfo::GetMountCounters(
    LONG  *pReads,
    LONG  *pWrites
    )
/*++

Implements:

    IRmsStorageInfo::GetMountcounters

--*/
{
    *pReads  = m_readMountCounter;
    *pWrites = m_writeMountCounter;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetBytesRead2(
    LONG  *pReadHi,
    LONG  *pReadLo
    )
/*++

Implements:

    IRmsStorageInfo::GetBytesRead2

--*/
{
    *pReadHi = (LONG) (m_bytesReadCounter  >> 32);
    *pReadLo = (LONG) (m_bytesReadCounter  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetBytesRead(
    LONGLONG    *pRead
    )
/*++

Implements:

    IRmsStorageInfo::GetBytesRead

--*/
{
    *pRead = m_bytesReadCounter;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetBytesRead2(
    LONG    readHi,
    LONG    readLo
    )
/*++

Implements:

    IRmsStorageInfo::SetBytesRead2

--*/
{
    m_bytesReadCounter = (LONGLONG) (readHi << 32) + (readLo);
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetBytesRead(
    LONGLONG    read
    )
/*++

Implements:

    IRmsStorageInfo::SetBytesRead

--*/
{
    m_bytesReadCounter = read;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::IncrementBytesRead(
    LONG    val
    )
/*++

Implements:

    IRmsStorageInfo::IncrementBytesRead

--*/
{
    m_bytesReadCounter += val;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetBytesWritten2(
    LONG  *pWriteHi,
    LONG  *pWriteLo
    )
/*++

Implements:

    IRmsStorageInfo::GetBytesWritten2

--*/
{
    *pWriteHi = (LONG) (m_bytesWrittenCounter  >> 32);
    *pWriteLo = (LONG) (m_bytesWrittenCounter  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetBytesWritten(
    LONGLONG    *pWritten
    )
/*++

Implements:

    IRmsStorageInfo::GetBytesWritten

--*/
{
    *pWritten = m_bytesWrittenCounter;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetBytesWritten2(
    LONG    writeHi,
    LONG    writeLo
    )
/*++

Implements:

    IRmsStorageInfo::SetBytesWritten2

--*/
{
    m_bytesWrittenCounter = (LONGLONG) (writeHi << 32) + (writeLo);
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetBytesWritten(
    LONGLONG    written
    )
/*++

Implements:

    IRmsStorageInfo::SetBytesWritten

--*/
{
    m_bytesWrittenCounter = written;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::IncrementBytesWritten(
    LONG    val
    )
/*++

Implements:

    IRmsStorageInfo::IncrementBytesWritten

--*/
{
    //WsbTraceIn( OLESTR("CRmsStorageInfo::IncrementBytesWritten"), OLESTR("<%d>"), val );

    m_bytesWrittenCounter += val;
    m_usedSpace +=val;


    if (m_largestFreeSpace > 0) {
        // Decrement written bytes from free space
        m_largestFreeSpace -= val;
        if (m_largestFreeSpace < 0) {
            // Indicates inaccurate calulation of free space...
            WsbTraceAlways(OLESTR("CRmsStorageInfo::IncrementBytesWritten: Negative free space decrementing %ld bytes\n"), val);
            m_largestFreeSpace = 0;
        }

    } else {
        if (m_largestFreeSpace < 0) {
            // Not expected - somebody is trying to start counting free space 
            // without setting an appropriate initial value
            WsbTraceAlways(OLESTR("CRmsStorageInfo::IncrementBytesWritten: Was called before setting initial free space !!\n"), val);
            m_largestFreeSpace = 0;
        }
    }


/***    // Decrement the free space acordingly.
    m_largestFreeSpace *= (m_largestFreeSpace > 0) ? 1 : -1;  // Absolute value
    m_largestFreeSpace -= val;

    // if we go negative here, we simply set the free space to zero;
    // otherwise we set the value negative to indicate an
    // approximation.

    m_largestFreeSpace *= (m_largestFreeSpace > 0) ? -1 : 0;    ***/

    //WsbTrace( OLESTR("FreeSpace=%I64d, UsedSpace=%I64d, BytesWritten=%I64d\n"), m_largestFreeSpace, m_usedSpace, m_bytesWrittenCounter);
    //WsbTraceOut(OLESTR("CRmsStorageInfo::IncrementBytesWritten"), OLESTR("hr = <%ls>"), WsbHrAsString(S_OK));

    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetCapacity2(
    LONG  *pCapHi,
    LONG  *pCapLo
    )
/*++

Implements:

    IRmsStorageInfo::GetCapacity2

--*/
{
    *pCapHi = (LONG) (m_capacity  >> 32);
    *pCapLo = (LONG) (m_capacity  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetCapacity(
    LONGLONG    *pCap
    )
/*++

Implements:

    IRmsStorageInfo::GetCapacity

--*/
{
    *pCap = m_capacity;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetUsedSpace2(
    LONG  *pFreeHi,
    LONG  *pFreeLo
    )
/*++

Implements:

    IRmsStorageInfo::GetUsedSpace2

--*/
{
    *pFreeHi = (LONG) (m_usedSpace  >> 32);
    *pFreeLo = (LONG) (m_usedSpace  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetUsedSpace(
    LONGLONG    *pFree
    )
/*++

Implements:

    IRmsStorageInfo::GetUsedSpace

--*/
{
    *pFree = m_usedSpace;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetLargestFreeSpace2(
    LONG  *pFreeHi,
    LONG  *pFreeLo
    )
/*++

Implements:

    IRmsStorageInfo::GetLargestFreeSpace2

--*/
{
    // Negative numbers indicate last known value for free space.
    *pFreeHi = (LONG) (m_largestFreeSpace  >> 32);
    *pFreeLo = (LONG) (m_largestFreeSpace  & 0x00000000FFFFFFFF);
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetLargestFreeSpace(
    LONGLONG    *pFree
    )
/*++

Implements:

    IRmsStorageInfo::GetLargestFreeSpace

--*/
{
    // Negative numbers indicate last known value for free space.
    *pFree = m_largestFreeSpace;
    return S_OK;
}



STDMETHODIMP
CRmsStorageInfo::SetCapacity(
    IN LONGLONG cap)
/*++

Implements:

    IRmsStorageInfo::SetCapacity

--*/
{
    m_capacity = cap;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetUsedSpace(
    IN LONGLONG used)
/*++

Implements:

    IRmsStorageInfo::SetUsedSpace

--*/
{
    m_usedSpace = used;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::SetFreeSpace(
    IN LONGLONG free)
/*++

Implements:

    IRmsStorageInfo::SetFreeSpace

--*/
{
    m_largestFreeSpace = free;

    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::ResetCounters(
    void
    )
/*++

Implements:

    IRmsStorageInfo::ResetCounters

--*/
{
    m_readMountCounter = 0;
    m_writeMountCounter = 0;
    m_bytesWrittenCounter = 0;
    m_bytesReadCounter = 0;

//    m_resetCounterTimestamp = COleDateTime::GetCurrentTime();
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetResetCounterTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsStorageInfo::GetResetCounterTimestamp

--*/
{
    *pDate = m_resetCounterTimestamp;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetLastReadTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsStorageInfo::GetLastReadTimestamp

--*/
{
    *pDate = m_lastReadTimestamp;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetLastWriteTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsStorageInfo::GetLastWriteTimestamp

--*/
{
    *pDate = m_lastWriteTimestamp;
    return S_OK;
}


STDMETHODIMP
CRmsStorageInfo::GetCreatedTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsStorageInfo::GetCreatedTimestamp

--*/
{
    *pDate = m_createdTimestamp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmssslot.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsSSlot.h

Abstract:

    Declaration of the CRmsStorageSlot class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSSSLOT_
#define _RMSSSLOT_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsCElmt.h"       // CRmsChangerElement

/*++

Class Name:

    CRmsStorageSlot

Class Description:

    A CRmsStorageSlot represents a specific storage location within a libray.

--*/

class CRmsStorageSlot :
    public CComDualImpl<IRmsStorageSlot, &IID_IRmsStorageSlot, &LIBID_RMSLib>,
    public CRmsChangerElement,  // inherits CRmsComObject
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsStorageSlot,&CLSID_CRmsStorageSlot>
{
public:
    CRmsStorageSlot() {}
BEGIN_COM_MAP(CRmsStorageSlot)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsStorageSlot)
    COM_INTERFACE_ENTRY(IRmsStorageSlot)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsChangerElement)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsStorageSlot)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsStorageSlot
public:
    STDMETHOD(SetIsInMagazine)(BOOL flag);
    STDMETHOD(IsInMagazine)(void);

    STDMETHOD(GetMagazineAndCell)(LONG *pMag, LONG *pCell);
    STDMETHOD(SetMagazineAndCell)(LONG mag, LONG cell);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
    };                                      //
    BOOL            m_isInMagazine;         // If TRUE, the slot is contained within
                                            //   a magazine.
    LONG            m_magazineNo;           // The magazine number for this slot.
    LONG            m_cellNo;               // The cell number for this slot.
};

#endif // _RMSSSLOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmssslot.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsSSlot.cpp

Abstract:

    Implementation of CRmsStorageSlot

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsSSlot.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsStorageSlot::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsStorageSlot::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByElementNumber:
        case RmsFindByMediaSupported:

            // Do CompareTo for changer element
            hr = CRmsChangerElement::CompareTo( pCollectable, &result );
            break;

        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsStorageSlot::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsStorageSlot::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_isInMagazine = FALSE;

        m_magazineNo = 0;

        m_cellNo = 0;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsStorageSlot::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsStorageSlot;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsStorageSlot::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(BOOL)   +     // m_isInMagazine
//                             WsbPersistSizeOf(LONG)   +     // m_magazineNo
//                             WsbPersistSizeOf(LONG);        // m_cellNo
//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsStorageSlot::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isInMagazine));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_magazineNo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_cellNo));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsStorageSlot::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_isInMagazine));

        WsbAffirmHr(WsbSaveToStream(pStream, m_magazineNo));

        WsbAffirmHr(WsbSaveToStream(pStream, m_cellNo));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsStorageSlot>    pStorageSlot1;
    CComPtr<IRmsStorageSlot>    pStorageSlot2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    longWork1;
    LONG                    longWork2;
    LONG                    longWork3;
    LONG                    longWork4;


    WsbTraceIn(OLESTR("CRmsStorageSlot::Test"), OLESTR(""));

    try {
        // Get the StorageSlot interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsStorageSlot*) this)->QueryInterface(IID_IRmsStorageSlot, (void**) &pStorageSlot1));

            // Test SetIsInMagazine & IsInMagazine to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsInMagazine (TRUE));
                WsbAffirmHr(IsInMagazine ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsInMagazine & IsInMagazine to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsInMagazine (FALSE));
                WsbAffirmHr(IsInMagazine ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetMagazineAndCell & GetMagazineAndCell
            longWork1 = 99;
            longWork2 = 11;

            SetMagazineAndCell(longWork1, longWork2);

            GetMagazineAndCell(&longWork3, &longWork4);

            if((longWork1 == longWork3)  &&  (longWork2  ==  longWork4)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsStorageSlot::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsStorageSlot::SetIsInMagazine(
    BOOL    flag
    )
/*++

Implements:

    IRmsStorageSlot::SetIsInMagazine

--*/
{
    m_isInMagazine = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsStorageSlot::IsInMagazine(
    void
    )
/*++

Implements:

    IRmsStorageSlot::IsInMagazine

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isInMagazine){
    hr = S_OK;
    }

    return (hr);
}



STDMETHODIMP
CRmsStorageSlot::GetMagazineAndCell(
    LONG    *pMag,
    LONG    *pCell
    )
/*++

Implements:

    IRmsStorageSlot::GetMagazineAndCell

--*/
{
    *pMag  = m_magazineNo;
    *pCell = m_cellNo;
    return S_OK;
}


STDMETHODIMP
CRmsStorageSlot::SetMagazineAndCell(
    LONG    mag,
    LONG    cell
    )
/*++

Implements:

    IRmsStorageSlot::SetMagazineAndCell

--*/
{
    m_magazineNo = mag;
    m_cellNo     = cell;

    m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmstmplt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsTmplt.cpp

Abstract:

    Implementation of CRmsTemplate

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsTmplt.h"

/////////////////////////////////////////////////////////////////////////////
// CRmsTemplate Implementation


STDMETHODIMP
CRmsTemplate::InterfaceSupportsErrorInfo(
    REFIID riid
    )
/*++

Implements:

    ISupportsErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] =
    {
    &IID_IRmsTemplate,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
    if (InlineIsEqualGUID(*arr[i],riid))
        return S_OK;
    }
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmstmplt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsTmplt.h

Abstract:

    Declaration of the CRmsTemplate class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSTMPLT_
#define _RMSTMPLT_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"
/*++

Class Name:

    CRmsTemplate

Class Description:

    A CRmsTemplate represents...

--*/

class CRmsTemplate :
    public CComDualImpl<IRmsTemplate, &IID_IRmsTemplate, &LIBID_RMSLib>,
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CRmsTemplate,&CLSID_CRmsTemplate>
{
public:
    CRmsTemplate() {}
BEGIN_COM_MAP(CRmsTemplate)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRmsTemplate)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
    //DECLARE_NOT_AGGREGATABLE(CRmsTemplate)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

DECLARE_REGISTRY_RESOURCEID(IDR_RmsTemplate)

// ISupportsErrorInfo
public:
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IRmsTemplate
public:
};

#endif // _RMSTMPLT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#define WSB_TRACE_IS    WSB_TRACE_BIT_RMS

#include "Rms.h"

// extern CComPtr<IWsbTrace> g_pTrace; 

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\types\rms\makefile.inc ===
clean:
    -del $(PASS0_HEADERDIR)\rmsint.h
    -del $(PASS0_HEADERDIR)\rmslib.h
    -del $(MIDL_UUIDDIR)\rmsint_i.c
    -del $(MIDL_UUIDDIR)\rmslib_i.c
    -del $(PASS0_SOURCEDIR)\rmsint_p.c
    -del $(PASS0_SOURCEDIR)\dlldata.c
    -del $(TLBDIR)\rmslib.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\types\wsb\makefile.inc ===
clean:
    -del $(PASS0_HEADERDIR)\wsberror.h
    -del $(PASS0_HEADERDIR)\wsbdef.h
    -del $(MIDL_UUIDDIR)\wsbint.h
    -del $(MIDL_UUIDDIR)\wsblib.h
    -del /q $(PASS0_SOURCEDIR)\*
    -del $(MIDL_TLBDIR)\mvrlib.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

// MIDL Generated proxy stub generates warning c4047 - kill these
#include "dlldata.c"
#pragma warning( disable : 4047 )
#include "wsbint_p.c"
#pragma warning( default : 4047 )

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\types\mover\makefile.inc ===
clean:
    -del $(PASS0_HEADERDIR)\mvrint.h
    -del $(PASS0_HEADERDIR)\mvrlib.h
    -del $(MIDL_UUIDDIR)\mvrint_i.c
    -del $(MIDL_UUIDDIR)\mvrlib_i.c
    -del $(PASS0_SOURCEDIR)\mvrint_p.c
    -del $(PASS0_SOURCEDIR)\dlldata.c
    -del $(MIDL_TLBDIR)\mvrlib.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rstore\rstore.cpp ===
// Restore Remote Storage Engine database from backup directory
//
// Usage: RsTore backup_dir
//         backup_dir  - location of backup directory
//  The database is restored to the current directory

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>

#include "esent.h"


//  Local data
WCHAR *backup_dir;
WCHAR *usage = L"RsTore <backup-directory>";

//  Local functions
HRESULT FileCount(WCHAR* Pattern, LONG* pCount);
HRESULT parseCommand(int argc, wchar_t *argv[]);

#define WsbCatch(hr)                    \
    catch(HRESULT catchHr) {            \
        hr = catchHr;                   \
    }


//  FileCount - count files matching the pattern
HRESULT FileCount(WCHAR* Pattern, LONG* pCount)
{
    DWORD             err;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    HRESULT           hr = S_OK;
    int               nCount = 0;
    int               nSkipped = 0;

    try {
        hFind =  FindFirstFile(Pattern, &FindData);
        if (INVALID_HANDLE_VALUE == hFind) {
            err = GetLastError();
            throw(HRESULT_FROM_WIN32(err));
        }

        while (TRUE) {

            if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                    FILE_ATTRIBUTE_HIDDEN)) {
                //  Don't count system files (such as "." and "..")
                nSkipped++;
            } else {
                nCount++;
            }
            if (!FindNextFile(hFind, &FindData)) { 
                err = GetLastError();
                if (ERROR_NO_MORE_FILES == err) break;
                throw(HRESULT_FROM_WIN32(err));
            }
        }
    } WsbCatch(hr);

    *pCount = nCount;
    return(hr);
}

//  parseCommand - Parse the command line
HRESULT parseCommand(int argc, wchar_t *argv[])
{
    HRESULT     hr = E_FAIL;

    try {
        int  i;

        // There should be cmd name + one parameters.
        if (argc != 2) {
            throw (E_FAIL);
        }

        for (i = 1; i < argc; i++) {
            if (WCHAR('-') == argv[i][0]) {
                throw(E_FAIL);

            } else {
                backup_dir = argv[i];
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    return(hr);
}


//  wmain - Main function
extern "C"
int _cdecl wmain(int argc, wchar_t *argv[]) 
{
    HRESULT                     hr = S_OK;

    try {
        hr = parseCommand(argc, argv);
        if (!SUCCEEDED(hr)) {
            printf("Command line is incorrect\n%ls\n", usage);
            return -1;
        }

        try {
            PCHAR          cbdir = NULL;
            LONG           count;
            ULONG          size;
            JET_ERR        jstat;
            WCHAR         *pattern;
            
            //
            // Allocate memory for the string
            //
            size = wcslen(backup_dir) + 20;

            pattern = new WCHAR[size];
 
            if (pattern == NULL) {
                throw(E_OUTOFMEMORY);
            }                                     
            //  Check that there's a HSM DB to restore
            wcscpy(pattern, backup_dir);
            wcscat(pattern, L"\\*.jet");

            hr = FileCount(pattern, &count);
        
            delete pattern;
            pattern = 0;

            if (S_OK != hr || count == 0) {
                printf("No Remote Storage databases were found in the given\n");
                printf("directory: %ls\n", static_cast<WCHAR*>(backup_dir));
                printf("Please enter the directory containing the backup files.\n");
                throw(E_FAIL);
            }

            //  Check that the current directory is empty
            pattern = L".\\*";
            hr = FileCount(pattern, &count);
            if (S_OK != hr || count != 0) {
                printf("The current directory is not empty\n");
                printf("The database restore can only be done to an empty directory.\n");
                throw(E_FAIL);
            }

            //  Set the log size to avoid an error JetRestore
            jstat = JetSetSystemParameter(0, 0, JET_paramLogFileSize, 
                    64, NULL);
            if (JET_errSuccess != jstat) {
                printf("JetSetSystemParameter(JET_paramLogFileSize) failed, JET error = %ld\n", (LONG)jstat);
                throw(E_FAIL);
            }

            //  Try the restore
            size = wcstombs(0, backup_dir, 0) + 1;
            cbdir = new CHAR[size];
            if (cbdir == NULL) {
                throw(E_OUTOFMEMORY);
            }
            wcstombs(cbdir, backup_dir, size);

            jstat = JetRestore(cbdir, NULL);

            if (JET_errSuccess == jstat) {
                printf("Restore succeeded\n");
                hr = S_OK;
            } else {
                printf("Restore failed, JET error = %ld\n", (LONG)jstat);
                hr = E_FAIL;
            }

            delete cbdir;
            cbdir = 0;
        } WsbCatch(hr);
    
    } WsbCatch(hr);

    if (SUCCEEDED(hr)) {
        return(0);
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\makefile.inc ===
$(O)\wsb.res: wsb.rgs                \
              wsbguid.rgs            \
              wsbienum.rgs           \
              wsbocltn.rgs           \
              wsbstrg.rgs            \
              wsbtrace.rgs           \
              ..\inc\$(O)\wsblib.tlb \

clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wsb.rc
//
#define IDS_WSBCOLLECTABLE_DESC         1
#define IDS_WSBSTRING_DESC              1
#define IDS_WSBCOLLECTION_DESC          2
#define IDS_WSBORDEREDCOLLECTION_DESC   2
#define IDR_CWsbGuid                    2
#define IDS_WSBENUMUNKNOWN_DESC         3
#define IDS_WSBINDEXEDENUM_DESC         3
#define IDR_CWsbIndexedEnum             3
#define IDS_WSBGUID_DESC                4
#define IDR_CWsbOrderedCollection       5
#define IDR_CWsbString                  7
#define IDS_WSBPERSISTABLEBASE_DESC     10
#define IDS_WSBCOLLECTABLEBASE_DESC     11
#define IDR_CWsbTrace                   19
#define IDS_WSBTRACE_DESC               19
#define IDR_Wsb                         21
#define IDS_WSB_DESC                    21
#define IDS_WSB_FT_TYPE_YEAR            101
#define IDS_WSB_FT_TYPE_MONTH           102
#define IDS_WSB_FT_TYPE_WEEK            103
#define IDS_WSB_FT_TYPE_DAY             104
#define IDS_WSB_FT_TYPE_HOUR            105
#define IDS_WSB_FT_TYPE_MINUTE          106
#define IDS_WSB_FT_TYPE_SECOND          107
#define IDS_WSB_BYTES                   110
#define IDS_WSB_ORDERKB                 111
#define IDS_WSB_ORDERMB                 112
#define IDS_WSB_ORDERGB                 113
#define IDS_WSB_ORDERTB                 114
#define IDS_WSB_ORDERPB                 115
#define IDS_WSB_ORDEREB                 116
#define IDS_WSB_ERROR_HEADER            117
#define IDS_WSBPERSISTABLE_DEF_FILE     201
#define IDS_WSBSVC_DESC                 202
#define IDS_PRODUCT_NAME                203

/***
    The range of 1024 - 2047 is reserved for 
    HSM global string identifiers, defined in rsstrdef.h 
***/

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H
//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
}
extern "C" {
#include <ntrtl.h>
}
extern "C" {
#include <nturtl.h>
}

#define WSB_TRACE_IS        WSB_TRACE_BIT_PLATFORM
#include "wsb.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbbool.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbbool.h

Abstract:

    This component is an object representations of the BOOL standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBBOOL_
#define _WSBBOOL_


/*++

Class Name:
    
    CWsbBool

Class Description:

    An object representations of the BOOL standard type. It
    is both persistable and collectable.

--*/

class CWsbBool : 
    public CWsbObject,
    public IWsbBool,
    public CComCoClass<CWsbBool,&CLSID_CWsbBool>
{
public:
    CWsbBool() {}
BEGIN_COM_MAP(CWsbBool)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbBool)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbBool)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbBool)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbBool
public:
    STDMETHOD(CompareToBool)(BOOL value, SHORT* pResult);
    STDMETHOD(CompareToIBool)(IWsbBool* pBool, SHORT* pResult);
    STDMETHOD(GetBool)(BOOL* pValue);
    STDMETHOD(SetBool)(BOOL value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    BOOL            m_value;
};

#endif // _WSBBOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbaccnt.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbAccnt.cpp

Abstract:

    This is the implementation of account helper functions.

Author:

    Rohde Wakefield    [rohde]   10-Apr-1997

Revision History:

--*/


#include "stdafx.h"
#include "lm.h"



HRESULT
WsbGetAccountDomainName(
    OLECHAR * szDomainName,
    DWORD     cSize
    )
/*++

Routine Description:

    This routine is called to find out what domain the current process's
    account belongs to. An array of cSize wide chars is required. 
    This is recommended to be MAX_COMPUTERNAMELENGTH.

Arguments:

    hInst - HINSTANCE of this dll.

    ulReason - Context of the attaching/detaching

Return Value:

    S_OK     - Success
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr     = S_OK;
    HANDLE  hToken = 0;

    try {

        if( !OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ) ) {
        
            //
            // Ensure failure was because no token existed
            //

            WsbAffirm( GetLastError() == ERROR_NO_TOKEN, E_FAIL );
        
            //
            // attempt to open the process token, since no thread token
            // exists
            //
        
            WsbAffirmStatus( OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) );

        }
        
        DWORD dw;
        BYTE buf[ 512 ];
        TOKEN_USER * pTokenUser = (TOKEN_USER*)buf;
        WsbAffirmStatus( GetTokenInformation( hToken, TokenUser, buf, 512, &dw ) );
        
        WCHAR szName[ 256 ];
        DWORD cName = 256; 
        DWORD cDomain = cSize;
        SID_NAME_USE snu;
        WsbAffirmStatus( LookupAccountSid( 0, pTokenUser->User.Sid, szName, &cName, szDomainName, &cDomain, &snu ) );

    } WsbCatch( hr );

    if( hToken ) {

        CloseHandle( hToken );

    }

    return( hr );
}

HRESULT
WsbGetServiceInfo(
    IN  GUID            guidApp,
    OUT OLECHAR **      pszServiceName, OPTIONAL
    OUT OLECHAR **      pszAccountName  OPTIONAL
    )
/*++

Routine Description:

    This function retrieves the name of the service, as well as the
    account a COM service runs under. The returned strings are 
    WsbAlloc'd so they must be freed by the caller.

Arguments:

    guidApp - app id of the service to get the account of.

    pszServiceName - the name of the service.

    pszAccountName - the full account name to set on the account.

Return Value:

    S_OK     - Success
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;


    try {

        CWsbStringPtr serviceName;
        CWsbStringPtr accountName;

        if( pszServiceName )  *pszServiceName = 0;
        if( pszAccountName )  *pszAccountName = 0;

        //
        // Find the service in the registry
        //

        CWsbStringPtr regPath = L"SOFTWARE\\Classes\\AppID\\";
        regPath.Append( CWsbStringPtr( guidApp ) );

        //
        // Get the name of the service
        //

        if( pszServiceName ) {

            serviceName.Realloc( 255 );
            WsbAffirmHr( WsbGetRegistryValueString( 0, regPath, L"LocalService", serviceName, 255, 0 ) );

        }

        //
        // Get the account for it to run under
        //

        if( pszAccountName ) {

            accountName.Realloc( 255 );
            hr = WsbGetRegistryValueString( 0, regPath, L"RunAs", accountName, 255, 0 ) ;

            if( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == hr ) {

                WsbGetLocalSystemName( accountName );
                hr = S_OK;

            } else {

                WsbAffirmHr( hr );

            }


        }

        //
        // Wait till end to do final assignments in case error
        // occurs, in which case smart pointers automatically 
        // cleanup for us, and OUT params are not set.
        //

        if( pszServiceName ) serviceName.GiveTo( pszServiceName );
        if( pszAccountName ) accountName.GiveTo( pszAccountName );

    } WsbCatch( hr );

    return( hr );
}


HRESULT
WsbGetComputerName(
    OUT CWsbStringPtr & String
    )
/*++

Routine Description:

    This routine retrieves the name of the computer into a CWsbStringPtr.

Arguments:

    String - String object to fill in with the name.

Return Value:

    S_OK     - Success
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;

    try {

        //
        // Force allocation of enough characters and call Win32
        //

        DWORD cbName = MAX_COMPUTERNAME_LENGTH + 1;
        WsbAffirmHr( String.Realloc( cbName ) );
        WsbAffirmStatus( GetComputerName( String, &cbName ) );

    } WsbCatch( hr );

    return( hr );
}


HRESULT
WsbGetLocalSystemName(
    OUT CWsbStringPtr & String
    )
/*++

Routine Description:

    This routine retrieves the name of the account for LocalSystem.

Arguments:

    String - String object to fill in with the name.

Return Value:

    S_OK     - Success
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;

    try {

        //
        // For now, hardcode. May need to lookup name of
        // SECURITY_LOCAL_SYSTEM_RID
        //

        String = L"LocalSystem";

    } WsbCatch( hr );

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbbool.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbbool.cpp

Abstract:

    This component is an object representations of the BOOL standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbbool.h"


HRESULT
CWsbBool::CompareToBool(
    IN BOOL value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbBool::CompareToBool

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbBool::CompareToBool"), OLESTR("value = <%ls>"), WsbBoolAsString(value));

    // Compare.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbBool::CompareToBool"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbBool::CompareToIBool(
    IN IWsbBool* pBool,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbBool::CompareToIBool

--*/
{
    HRESULT     hr = E_FAIL;
    BOOL        value;

    WsbTraceIn(OLESTR("CWsbBool::CompareToIBool"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pBool, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pBool->GetBool(&value));
        hr = CompareToBool(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::CompareToIBool"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbBool::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbBool*   pBool;

    WsbTraceIn(OLESTR("CWsbBool::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbBool, (void**) &pBool));

        hr = CompareToIBool(pBool, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbBool::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_value = FALSE;
    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbBool::GetBool(
    OUT BOOL* pValue
    )

/*++

Implements:

  IWsbBool::GetBool

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::GetBool"), OLESTR(""));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::GetBool"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbBoolAsString(m_value));
    
    return(hr);
}


HRESULT
CWsbBool::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CWsbBool;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbBool::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::GetSizeMax"), OLESTR(""));

    try {
        WsbAssert(0 != pcbSize, E_POINTER);
        
        pcbSize->QuadPart = WsbPersistSizeOf(BOOL);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbBool::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::Load"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbBoolAsString(m_value));

    return(hr);
}


HRESULT
CWsbBool::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbBool::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbBool::SetBool(
    IN BOOL value
    )

/*++

Implements:

  IWsbBool::SetBool

--*/
{
    WsbTraceIn(OLESTR("CWsbBool::SetBool"), OLESTR("value = <%ls>"), WsbBoolAsString(value));

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbBool::SetBool"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbBool::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbBool>       pBool1;
    CComPtr<IWsbBool>       pBool2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    BOOL                    value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbBool::Test"), OLESTR(""));

    try {

        // Get the pBool interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbBool*) this)->QueryInterface(IID_IWsbBool, (void**) &pBool1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pBool1->SetBool(TRUE));
                WsbAffirmHr(pBool1->GetBool(&value));
                WsbAffirm(value == TRUE, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbBool, NULL, CLSCTX_ALL, IID_IWsbBool, (void**) &pBool2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pBool2->GetBool(&value));
                    WsbAffirm(value == FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(TRUE));
                    WsbAffirmHr(pBool2->SetBool(TRUE));
                    WsbAffirm(pBool1->IsEqual(pBool2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(TRUE));
                    WsbAffirmHr(pBool2->SetBool(FALSE));
                    WsbAffirm(pBool1->IsEqual(pBool2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(FALSE));
                    WsbAffirmHr(pBool2->SetBool(FALSE));
                    WsbAffirm((pBool1->CompareTo(pBool2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(TRUE));
                    WsbAffirmHr(pBool2->SetBool(FALSE));
                    WsbAffirm((pBool1->CompareTo(pBool2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->SetBool(FALSE));
                    WsbAffirmHr(pBool2->SetBool(TRUE));
                    WsbAffirm((pBool1->CompareTo(pBool2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pBool1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pBool2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pBool2->SetBool(TRUE));
                        WsbAffirm(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbBool.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirm(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pBool1->SetBool(FALSE));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbBool.tst"), 0));
                        WsbAffirm(pBool1->CompareToBool(TRUE, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbBool::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif  // WSB_NO_TEST

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsb.cpp ===
// Wsb.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      Modify the custom build rule for Wsb.idl by adding the following 
//      files to the Outputs.  You can select all of the .IDL files by 
//      expanding each project and holding Ctrl while clicking on each of them.
//          Wsb_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f Wsbps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wsb.h"
#include "wsbcltn.h"
#include "wsbenum.h"
#include "wsbguid.h"
#include "wsbstrg.h"
#include "wsbtrc.h"

#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CWsbGuid, CWsbGuid)
    OBJECT_ENTRY(CLSID_CWsbIndexedEnum, CWsbIndexedEnum)
    OBJECT_ENTRY(CLSID_CWsbOrderedCollection, CWsbOrderedCollection)
    OBJECT_ENTRY(CLSID_CWsbString, CWsbString)
    OBJECT_ENTRY(CLSID_CWsbTrace, CWsbTrace)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        _Module.Init(ObjectMap, hInstance);
        WsbTraceInit();
        break;

    case DLL_THREAD_DETACH :
        WsbTraceCleanupThread();
        break;

    case DLL_PROCESS_DETACH:
        WsbTraceCleanupThread();
        WsbTraceTerminate();
        _Module.Term();
        break;

    default:
        break;

    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;
#ifdef _MERGE_PROXYSTUB
    hr = PrxDllRegisterServer();
    if( FAILED( hr ) )
        return hr;
#endif

#if 0
    // Add service entries
    hr = _Module.UpdateRegistryFromResourceS(IDR_Wsb, TRUE);
    if( FAILED( hr ) )
        return hr;
#endif

    hr = WsbRegisterEventLogSource( WSB_LOG_APP, WSB_LOG_SOURCE_NAME,
        WSB_LOG_SVC_CATCOUNT, WSB_LOG_SVC_CATFILE, WSB_LOG_SVC_MSGFILES );
    if( FAILED( hr ) ) return( hr );

    // registers object, typelib and all interfaces in typelib
    CoInitialize( 0 );
    hr = _Module.RegisterServer( FALSE );
    CoUninitialize( );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

#if 0
    // Remove service entries
    _Module.UpdateRegistryFromResourceS(IDR_Wsb, FALSE);
#endif

    WsbUnregisterEventLogSource( WSB_LOG_APP, WSB_LOG_SOURCE_NAME );

    hr =  CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbbstrg.cpp ===
#include "stdafx.h"

#include "wsb.h"
#include "wsbbstrg.h"

// {C03D4862-70D7-11d1-994F-0060976A546D}
static const GUID BstrPtrGuid = 
{ 0xc03d4862, 0x70d7, 0x11d1, { 0x99, 0x4f, 0x0, 0x60, 0x97, 0x6a, 0x54, 0x6d } };

CWsbBstrPtr::CWsbBstrPtr()
{
    HRESULT     hr = S_OK;

    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);
}

CWsbBstrPtr::CWsbBstrPtr(const CHAR* pChar)
{
    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);

    *this = pChar;
}

CWsbBstrPtr::CWsbBstrPtr(const WCHAR* pWchar)
{
    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);

    *this = pWchar;
}


CWsbBstrPtr::CWsbBstrPtr(REFGUID rguid)
{
    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);

    *this = rguid;
}

CWsbBstrPtr::CWsbBstrPtr(const CWsbBstrPtr& pString)
{
    m_pString = 0;
    m_givenSize = 0;
    WSB_OBJECT_ADD(BstrPtrGuid, this);

    *this = pString;
}

CWsbBstrPtr::~CWsbBstrPtr()
{
    WSB_OBJECT_SUB(BstrPtrGuid, this);
    Free();
}

CWsbBstrPtr::operator BSTR()
{
    return(m_pString);
}

WCHAR& CWsbBstrPtr::operator *()
{
    _ASSERTE(0 != m_pString);
    return(*m_pString);
}

WCHAR** CWsbBstrPtr::operator &()
{
    //  This assert only allows the caller to get the address of our pointer
    //  if we don't have anything allocated.
    _ASSERTE(0 == m_pString);
    
    return(&m_pString);
}

WCHAR& CWsbBstrPtr::operator [](const int i)
{
    _ASSERTE(0 != m_pString);
    return(m_pString[i]);
}

CWsbBstrPtr& CWsbBstrPtr::operator =(const CHAR* pChar)
{
    HRESULT     hr = S_OK;
    ULONG       length;
    int         count;

    try {
    
        // Are they setting it to something?
        if (0 != pChar) {
        
            // Otherwise, see if our current buffer is big enough.
            //
            // NOTE: With multibyte characters, we may be getting a bigger
            // buffer than we need, but the call to return the accurate
            // size is not ANSI.
            length = strlen(pChar);
            WsbAffirmHr(Realloc(length));
            WsbAffirm(0 != m_pString, E_OUTOFMEMORY);

            // Copy the data (and convert to wide characters)
            count = mbstowcs(m_pString, pChar, length + 1);
            WsbAffirm((count != -1), E_FAIL);
        }

        else {
            Free();
        }

    } WsbCatch(hr);

    return(*this);
}

CWsbBstrPtr& CWsbBstrPtr::operator =(const WCHAR* pWchar)
{
    HRESULT     hr = S_OK;
    ULONG       length;

    try {
    
        // Are they setting it to something?
        if (0 != pWchar) {
        
            // Otherwise, see if our current buffer is big enough.
            length = wcslen(pWchar);
            WsbAssertHr(Realloc(length));

            // Copy the data (and convert to wide characters)
            wcscpy(m_pString, pWchar);
        }

        else {
            Free();
        }

    } WsbCatch(hr);

    return(*this);
}


CWsbBstrPtr& CWsbBstrPtr::operator =(REFGUID rguid)
{
    HRESULT hr = S_OK;

    try {
    
        // Otherwise, see if our current buffer is big enough.
        WsbAssertHr(Realloc(WSB_GUID_STRING_SIZE));

        // Copy the data (and convert to wide characters)
        WsbStringFromGuid(rguid, m_pString);

    } WsbCatch(hr);

    return (*this);
}

CWsbBstrPtr& CWsbBstrPtr::operator =(const CWsbBstrPtr& pString)
{
    *this = pString.m_pString;

    return(*this);
}

BOOL CWsbBstrPtr::operator !()
{
    return((0 == m_pString) ? TRUE : FALSE);
}

HRESULT CWsbBstrPtr::Alloc(ULONG size)
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 == m_pString, E_UNEXPECTED);

//      m_pString = (WCHAR*) SysAllocStringLen(0, size);
        m_pString = (WCHAR*) WsbAllocStringLen(0, size);
        WsbAffirm(0 != m_pString, E_OUTOFMEMORY);

        // Make sure we always have a valid string so bad things don't happen.
        *m_pString = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Append(const CHAR* pChar)
{
    HRESULT         hr = S_OK;
    CWsbBstrPtr     tmpString = pChar;

    hr = Append(tmpString);

    return(hr);
}

HRESULT CWsbBstrPtr::Append(const WCHAR* pWchar)
{
    HRESULT         hr = S_OK;
    ULONG           length = 0;
    ULONG           appendLength;

    try {
    
        // If they passed us a null pointer, then we don't need to do anything.
        WsbAffirm(pWchar != 0, S_OK);

        // If they passed us an empty string, then we don't need to do anything.
        appendLength = wcslen(pWchar);
        WsbAffirm(0 != appendLength, S_OK);

        // 
        if (0 != m_pString) {
            length = wcslen(m_pString);
        }

        // Make sure the buffer is big enough.
        WsbAffirmHr(Realloc(length + appendLength));
        
        // Append the string.
        wcscat(m_pString, pWchar);

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Append(const CWsbBstrPtr& pString) {
    HRESULT         hr = S_OK;

    hr = Append(pString.m_pString);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(CHAR** ppChar)
{
    HRESULT     hr = S_OK;

    hr = CopyTo(ppChar, 0);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(CHAR** ppChar, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;
    CHAR*       tmpString = 0;

    try {
    

        // Allocate a buffer big enough to hold their string.
        //
        // NOTE: With multibyte characters, we may be getting a bigger
        // buffer than we need, but the call to return the accurate
        // size is not ANSI.
        if (m_pString != 0) {
            length = wcstombs(0, m_pString, 0);
        }

        if (bufferSize == 0) {
            tmpString = (CHAR*) WsbRealloc(*ppChar, (length + 1) * sizeof(CHAR));
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);
            if (*ppChar == 0) {
                tmpString = (CHAR*) WsbRealloc(*ppChar, (bufferSize + 1) * sizeof(CHAR));
            }
        }

        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppChar = tmpString;

        // Copy and return the string;
        if (m_pString != 0) {
            WsbAffirm (-1 != wcstombs(*ppChar, m_pString, length + 1), E_FAIL);
        } else {
            **ppChar = 0;
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(WCHAR** ppWchar)
{
    HRESULT     hr = S_OK;

    hr = CopyTo(ppWchar, 0);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(WCHAR** ppWchar, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;
    WCHAR*      tmpString = 0;

    try {
    
        // Allocate a buffer big enough to hold their string.
        if (m_pString != 0) {
            length = wcslen(m_pString);
        }

        if (bufferSize == 0) {
            tmpString = (WCHAR*) WsbRealloc(*ppWchar, (length + 1) * sizeof(WCHAR));
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);

            if (*ppWchar == 0) {
                tmpString = (WCHAR*) WsbRealloc(*ppWchar, (bufferSize + 1) * sizeof(WCHAR));
            }
        }

        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppWchar = tmpString;

        // Copy and return the string;
        if (m_pString != 0) {
            wcscpy(*ppWchar, m_pString);
        } else {
            **ppWchar = 0;
        }


    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyTo(GUID * pguid)
{
    HRESULT hr = S_OK;

    hr = WsbGuidFromString(m_pString, pguid);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyToBstr(BSTR* pBstr)
{
    HRESULT     hr = S_OK;

    hr = CopyToBstr(pBstr, 0);

    return(hr);
}

HRESULT CWsbBstrPtr::CopyToBstr(BSTR* pBstr, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;

    try {
    
        // Allocate a buffer big enough to hold their string.
        if (m_pString != 0) {
            length = wcslen(m_pString);
        }

        if (bufferSize == 0) {
            if (0 == *pBstr) {
//              *pBstr = SysAllocString(m_pString);
                *pBstr = WsbAllocString(m_pString);
            } else {
//              WsbAffirm(SysReAllocString(pBstr, m_pString), E_OUTOFMEMORY);
                WsbAffirm(WsbReallocString(pBstr, m_pString), E_OUTOFMEMORY);
            }
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);

            if (0 == *pBstr) {
//              *pBstr = SysAllocStringLen(m_pString, bufferSize);
                *pBstr = WsbAllocStringLen(m_pString, bufferSize);
            } else {
//              WsbAffirm(SysReAllocStringLen(pBstr, m_pString, bufferSize), E_OUTOFMEMORY);
                WsbAffirm(WsbReallocStringLen(pBstr, m_pString, bufferSize), E_OUTOFMEMORY);
            }
        }

        WsbAffirm(0 != pBstr, E_OUTOFMEMORY);

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::FindInRsc(ULONG startId, ULONG idsToCheck, ULONG* pMatchId)
{
    HRESULT         hr = S_FALSE;
    CWsbBstrPtr dest;

    try {
    
        WsbAssert(0 != pMatchId, E_POINTER);

        // Initialize the return value.
        *pMatchId = 0;

        // Check each resource string mention and see if it is the same as
        // the string provided.
        for (ULONG testId = startId; (testId < (startId + idsToCheck)) && (*pMatchId == 0); testId++) {

            WsbAffirmHr(dest.LoadFromRsc(_Module.m_hInst, testId));

            if (wcscmp(dest, m_pString) == 0) {
                *pMatchId = testId;
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Free(void)
{
    HRESULT     hr = S_OK;

    try {

        if ((0 != m_pString) && (0 == m_givenSize)) {
//          SysFreeString(m_pString);
            WsbFreeString(m_pString);
            m_pString = 0;
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::GetSize(ULONG* pSize)
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);

        if (0 == m_pString) {
            *pSize = 0;
        } else if (0 != m_givenSize) {
            *pSize = m_givenSize;
        } else {
            *pSize = SysStringLen(m_pString);
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::GiveTo(BSTR* pBstr)
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != pBstr, E_POINTER);

        // Given the our string buffer, and forget about it.
        *pBstr = m_pString;
        m_pString = 0;
        m_givenSize = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::LoadFromRsc(HINSTANCE instance, ULONG id)
{
    HRESULT     hr = S_OK;
    HRSRC       resource;
    ULONG       stringSize;

    try {

        // Find the resource requested. This requires converting the resource
        // identifier into a string.
        //
        // NOTE: Strings are not number individually, but in groups of 16!! This throws
        // off the latter size calculation, and some other strategy might be better
        // here (e.g. load to a fixed size and then allocate again if too small).
        resource = FindResource(instance, MAKEINTRESOURCE((id/16) + 1), RT_STRING);
        WsbAffirm(resource != 0, E_FAIL);

        // How big is the string?
        stringSize = SizeofResource(instance, resource);
        WsbAffirm(0 != stringSize, E_FAIL);
                  
        // Get the right sized buffer.
        WsbAffirmHr(Realloc(stringSize / sizeof(WCHAR)));

        // Load the string into the buffer.
        WsbAffirm(LoadString(instance, id, m_pString, (stringSize / sizeof(WCHAR)) + 1) != 0, E_FAIL);

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Prepend(const CHAR* pChar) {
    HRESULT         hr = S_OK;
    CWsbBstrPtr     tmpString = pChar;

    hr = Prepend(tmpString);

    return(hr);
}

HRESULT CWsbBstrPtr::Prepend(const WCHAR* pWchar) {
    HRESULT         hr = S_OK;
    ULONG           length;
    ULONG           prependLength;
    ULONG           i, j;

    try {
   
        // If they passed us a null pointer, then we don't need to do anything.
        WsbAffirm(pWchar != 0, S_OK);

        // If they passed us an empty string, then we don't need to do anything.
        prependLength = wcslen(pWchar);
        WsbAffirm(0 != prependLength, S_OK);

        if (0 != m_pString) {
            length = wcslen(m_pString);
        } else {
            // Prepend code will work as long as we have a null string and not a null pointer...
            // Next Realloc statement will make it happen...
            length = 0;
        }

        WsbAffirmHr(Realloc(length + prependLength));
        
        // First move the existing string down in the buffer.
        for (i = length + 1, j = length + prependLength; i > 0; i--, j--) {
            m_pString[j] = m_pString[i - 1];
        }

        // Now prepend the string (except for the null)
        for (i = 0; i < prependLength; i++) {
            m_pString[i] = pWchar[i];
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::Prepend(const CWsbBstrPtr& pString) {
    HRESULT         hr = S_OK;

    hr = Prepend(pString.m_pString);

    return(hr);
}

HRESULT CWsbBstrPtr::Realloc(ULONG size)
{
    HRESULT     hr = S_OK;
    ULONG       currentSize = 0;
    BOOL        bigEnough = FALSE;
    OLECHAR*    pString;

    try {
        
        // We want to try to get a buffer of the size indicated.
        // If the buffer is already bigger than the size needed, then
        // don't do anything.
        if (0 != m_pString) {
            WsbAffirmHr(GetSize(&currentSize));

            if (currentSize >= size) {
                bigEnough = TRUE;
            }
        }

        // Reallocate the buffer if we need a bigger one.
        if (!bigEnough) {
            
            // If we were given this buffer, then we can't reallocate it.
            WsbAssert(0 == m_givenSize, E_UNEXPECTED);

            // The realloc won't handle it properly if no BSTR has ever been allocated, so
            // use Alloc() in that case.
            if (0 == m_pString) {
                WsbAffirmHr(Alloc(size));       
            } else {

                // According to Bounds checker, Realloc doesn't work the way we expected, so
                // do the steps by hand.
                pString = m_pString;
                m_pString = 0;
                WsbAffirmHr(Alloc(size));       
                wcsncpy(m_pString, pString, currentSize + 1);
//              SysFreeString(pString);
                WsbFreeString(pString);
//              WsbAffirm(SysReAllocStringLen(&m_pString, 0, size + 1), E_OUTOFMEMORY);
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbBstrPtr::TakeFrom(BSTR bstr, ULONG bufferSize)
{
    HRESULT         hr = S_OK;

    try {
        
        // Clear out any previously "taken" string.
        if (0 != m_givenSize) {
            m_pString = 0;
            m_givenSize = 0;
        }

        // If the given buffer is null, then we are responsible for allocating it.
        if (0 == bstr) {
            if (0 != bufferSize) {
                WsbAffirmHr(Realloc(bufferSize));
            }
        }
        
        // Otherwise, we need to get rid of any buffer we had and use the one indicated.
        else {
            if (0 != m_pString) {
                WsbAffirmHr(Free());
            }
            m_pString = bstr;

            if (0 != bufferSize) {
                m_givenSize = bufferSize;
            }
        }

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbcltn.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    Wsbcltn.h

Abstract:

    These classes provide support for collections (lists) of "collectable"
    objects.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"
#include "Wsbpstbl.h"

#ifndef _WSBCLTN_
#define _WSBCLTN_


/*++

Class Name:
    
    CWsbCollection 

Class Description:

    A collection of objects.

--*/

class CWsbCollection : 
    public CWsbPersistStream,
    public IWsbCollection,
    public IWsbTestable
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollection
public:
    STDMETHOD(Contains)(IUnknown* pCollectable);
    STDMETHOD(GetEntries)(ULONG* pEntries);
    STDMETHOD(Find)(IUnknown* pCollectable, REFIID riid, void** ppElement);
    STDMETHOD(IsEmpty)(void);
    STDMETHOD(IsLocked)(void);
    STDMETHOD(Lock)(void);
    STDMETHOD(OccurencesOf)(IUnknown* pCollectable, ULONG* occurences);
    STDMETHOD(RemoveAndRelease)(IUnknown* pCollectable);
    STDMETHOD(Unlock)(void);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    ULONG               m_entries;
    CRITICAL_SECTION                m_CritSec;
};

#define WSB_FROM_CWSBCOLLECTION \
    STDMETHOD(Contains)(IUnknown* pCollectable) \
        {return(CWsbCollection::Contains(pCollectable));};  \
    STDMETHOD(GetEntries)(ULONG* pEntries) \
        {return(CWsbCollection::GetEntries(pEntries));};    \
    STDMETHOD(Find)(IUnknown* pCollectable, REFIID riid, void** ppElement) \
        {return(CWsbCollection::Find(pCollectable, riid, ppElement));}; \
    STDMETHOD(IsEmpty)(void) \
        {return(CWsbCollection::IsEmpty());};   \
    STDMETHOD(IsLocked)(void) \
        {return(CWsbCollection::IsLocked());};  \
    STDMETHOD(Lock)(void) \
        {return(CWsbCollection::Lock());};  \
    STDMETHOD(OccurencesOf)(IUnknown* pCollectable, ULONG* occurences) \
        {return(CWsbCollection::OccurencesOf(pCollectable, occurences));};  \
    STDMETHOD(RemoveAndRelease)(IUnknown* pCollectable) \
        {return(CWsbCollection::RemoveAndRelease(pCollectable));};  \
    STDMETHOD(Unlock)(void) \
        {return(CWsbCollection::Unlock());};    \



/*++

Class Name:
    
    CWsbIndexedCollection 

Class Description:

    A indexed collection of objects.

--*/

class CWsbIndexedCollection : 
    public IWsbIndexedCollection,
    public CWsbCollection
{
// IWsbCollection
public:
    WSB_FROM_CWSBCOLLECTION;

// IWsbIndexedCollection
public:
    STDMETHOD(Add)(IUnknown* pCollectable);
    STDMETHOD(Append)(IUnknown* pCollectable);

    STDMETHOD(First)(REFIID riid, void** ppElement);
    STDMETHOD(Index)(IUnknown* pCollectable, ULONG* index);
    STDMETHOD(Last)(REFIID riid, void** ppElement);
    STDMETHOD(Prepend)(IUnknown* pCollectable);
    STDMETHOD(Remove)(IUnknown* pCollectable, REFIID riid, void** ppElement);
    STDMETHOD(RemoveAllAndRelease)(void);

    STDMETHOD(Enum)(IWsbEnum** ppEnum);
    STDMETHOD(EnumUnknown)(IEnumUnknown** ppEnum);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);
};



/*++

Class Name:
    
    CWsbOrderedCollection 

Class Description:

    An ordered collection of objects.

--*/

class CWsbOrderedCollection : 
    public CWsbIndexedCollection,
    public CComCoClass<CWsbOrderedCollection,&CLSID_CWsbOrderedCollection>
{
public:
    CWsbOrderedCollection() {}
BEGIN_COM_MAP(CWsbOrderedCollection)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY2(IWsbCollection, IWsbIndexedCollection)
    COM_INTERFACE_ENTRY(IWsbIndexedCollection)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbOrderedCollection)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbIndexedCollection
    STDMETHOD(AddAt)(IUnknown* pCollectable, ULONG index);
    STDMETHOD(At)(ULONG index, REFIID riid, void** ppElement);
    STDMETHOD(Copy)(ULONG start, ULONG stop, REFIID riid, void** rgElement, ULONG* pElementFetched);
    STDMETHOD(CopyIfMatches)(ULONG start, ULONG stop, IUnknown* pCollectable, ULONG element, REFIID riid, void** rgElement, ULONG* pElementFetched, ULONG* pStoppedAt);
    STDMETHOD(RemoveAt)(ULONG index, REFIID riid, void** ppElement);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed) {
        return(CWsbIndexedCollection::Test(passed, failed));
    };

protected:
    ULONG               m_maxEntries;
    ULONG               m_growBy;
    IWsbCollectable**   m_pCollectable;
};

#endif // _WSBCLTN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbcltbl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbcltbl.cpp

Abstract:

    Abstract classes that provide methods that allow the derived objects to
    be stored in collections.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"


HRESULT
CWsbObject::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
     return(CWsbPersistStream::FinalConstruct());
}

    

void
CWsbObject::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    CWsbPersistStream::FinalRelease();
}


HRESULT
CWsbObject::CompareTo(
    IN IUnknown* pObject,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::Compare().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       result = 0;
    CComPtr<IWsbCollectable> pCollectable;

    WsbTraceIn(OLESTR("CWsbObject::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(pObject != NULL, E_POINTER);
        WsbAffirmHr(pObject->QueryInterface(IID_IWsbCollectable,
                (void **)&pCollectable));

        // Check it's values.
        if (pCollectable == ((IWsbCollectable*) this)) {
            hr = S_OK;
            result = 0;
        } else {
            hr = S_FALSE;
            result = 1;
        }

        // If they want the value back, then return it to them.
        if (0 != pResult) {
            *pResult = result;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbObject::CompareTo"), OLESTR("hr = <%ls>, value = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}



HRESULT
CWsbObject::IsEqual(
    IUnknown* pObject
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbObject::IsEqual"), OLESTR(""));

    hr = CompareTo(pObject, NULL);

    WsbTraceOut(OLESTR("CWsbObject::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


// ************* CWsbCollectable ************


HRESULT
CWsbCollectable::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
     return(CWsbPersistable::FinalConstruct());
}

    

void
CWsbCollectable::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    CWsbPersistable::FinalRelease();
}


HRESULT
CWsbCollectable::CompareTo(
    IN IUnknown* pObject,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::Compare().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       result = 0;
    CComPtr<IWsbCollectable> pCollectable;

    WsbTraceIn(OLESTR("CWsbCollectable::CompareTo"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(pObject != NULL, E_POINTER);
        WsbAffirmHr(pObject->QueryInterface(IID_IWsbCollectable,
                (void **)&pCollectable));

        // Check it's values.
        if (pCollectable == ((IWsbCollectable*) this)) {
            hr = S_OK;
            result = 0;
        } else {
            hr = S_FALSE;
//          if (pCollectable > ((IWsbCollectable*) this)) {
//              result = -1;
//          } else {
                result = 1;
//          }
        }

        // If they want the value back, then return it to them.
        if (0 != pResult) {
            *pResult = result;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbCollectable::CompareTo"), OLESTR("hr = <%ls>, value = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}



HRESULT
CWsbCollectable::IsEqual(
    IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbCollectable::IsEqual"), OLESTR(""));

    hr = CompareTo(pCollectable, NULL);

    WsbTraceOut(OLESTR("CWsbCollectable::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbcltn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbcltn.cpp

Abstract:


    These classes provide support for collections (lists) of "collectable"
    objects.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbcltn.h"



HRESULT
CWsbCollection::Contains(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollection::Contains().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbCollectable>    pOut;
    
    WsbTraceIn(OLESTR("CWsbCollection::Contains"), OLESTR(""));

    hr = Find(pCollectable, IID_IWsbCollectable, (void**) &pOut);

    if (hr == WSB_E_NOTFOUND) {
        hr = S_FALSE;
    }
    
    WsbTraceOut(OLESTR("CWsbCollection::Contains"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbCollection::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbPersistStream::FinalConstruct());
        m_entries = 0;
        InitializeCriticalSection(&m_CritSec);
    } WsbCatch(hr);

    return(hr);
}
    

void
CWsbCollection::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    DeleteCriticalSection(&m_CritSec);
    CWsbPersistStream::FinalRelease();
}


HRESULT
CWsbCollection::Find(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbCollection::Find().

--*/
{
    CComPtr<IWsbEnum>           pEnum;
    HRESULT                     hr = S_OK;
    BOOL                        matched = FALSE;

    WsbTraceIn(OLESTR("CWsbCollection::Find"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        WsbAssert(0 != ppElement, E_POINTER);

        WsbAffirmHr(Enum(&pEnum));
        WsbAffirmHr(pEnum->Find(pCollectable, riid, ppElement));
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbCollection::Find"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbCollection::GetEntries(
    OUT ULONG* pEntries
    )

/*++

Implements:

  IWsbCollection::GetEntries().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbCollection::GetEntries"), OLESTR(""));

    try {
        WsbAssert(0 != pEntries, E_POINTER);
        *pEntries = m_entries;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbCollection::GetEntries"), OLESTR("hr = <%ls>, entries = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pEntries));

    return(S_OK);
}


HRESULT
CWsbCollection::IsEmpty(
    void
    )

/*++

Implements:

  IWsbCollection::IsEmpty().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbCollection::IsEmpty"), OLESTR(""));

    if (0 != m_entries) {
        hr = S_FALSE;
    }
    
    WsbTraceOut(OLESTR("CWsbCollection::IsEmpty"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbCollection::IsLocked(
    void
    )

/*++

Implements:

  IWsbCollection::IsLocked().

--*/
{
    HRESULT     hr = S_OK;
    BOOL        tryEnter = FALSE;
    
    WsbTraceIn(OLESTR("CWsbCollection::IsLocked"), OLESTR(""));
    tryEnter = TryEnterCriticalSection(&m_CritSec);
    if (tryEnter == 0)  {
        //
        // Another thread has the collection locked
        //
        hr = S_OK;
    } else  {
        //
        // We got the lock, so unlock it
        LeaveCriticalSection(&m_CritSec);
        hr = S_FALSE;
    }
    WsbTraceOut(OLESTR("CWsbCollection::IsLocked"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}

HRESULT
CWsbCollection::Lock(
    void
    )

/*++

Implements:

  CComObjectRoot::Lock().

--*/
{
    WsbTrace(OLESTR("CWsbCollection::Lock - waiting for critical section\n"));
    EnterCriticalSection(&m_CritSec);
    WsbTrace(OLESTR("CWsbCollection::Lock - got critical section\n"));
    return(S_OK);
}

HRESULT
CWsbCollection::OccurencesOf(
    IN IUnknown* pCollectable,
    OUT ULONG* pOccurences
    )

/*++

Implements:

  IWsbCollection::OccurrencesOf().

--*/
{
    CComPtr<IWsbCollectable>    pCollectableEnum;
    CComPtr<IWsbEnum>           pEnum;
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbCollection::OccurencesOf"), OLESTR(""));

    Lock();
    try {


        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAssert(0 != pOccurences, E_POINTER);

        // Initialize the return value.
        *pOccurences = 0;

        // Get an enumerator.
        WsbAffirmHr(Enum(&pEnum));

        // Start at the front of the list.
        for (hr = pEnum->Find(pCollectable, IID_IWsbCollectable, (void**) &pCollectableEnum);
             SUCCEEDED(hr);
             hr = pEnum->FindNext(pCollectable, IID_IWsbCollectable, (void**) &pCollectableEnum)) {
            
            (*pOccurences)++;
            pCollectableEnum = 0;
        }

        // We should always hit the end of the collection, so then
        // change the return code to the appropriate value.
        if (hr == WSB_E_NOTFOUND) {
            if (0 == *pOccurences) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbCollection::OccurencesOf"), OLESTR("hr = <%ls>, occurences = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pOccurences));

    return(hr);
}


HRESULT
CWsbCollection::RemoveAndRelease(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollection::RemoveAndRelease().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbCollection::RemoveAndRelease"), OLESTR(""));

    try {
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(Remove(pCollectable,  IID_IWsbCollectable, NULL));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbCollection::RemoveAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbCollection::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbGuid>   pGuid1;
    CComPtr<IWsbGuid>   pGuid2;
    CComPtr<IWsbGuid>   pGuid3;
    CComPtr<IWsbGuid>   pGuid4;
    ULONG               entries;

    WsbTraceIn(OLESTR("CWsbCollection::Test"), OLESTR(""));

    try {

        // Clear out any entries that might be present.
        hr = S_OK;
        try {
            WsbAssertHr(RemoveAllAndRelease());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // There shouldn't be any entries.
        hr = S_OK;
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(0 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // It should be empty.
        hr = S_OK;
        try {
            WsbAssert(IsEmpty() == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // We need some collectable items to exercise the collection.
        WsbAssertHr(CoCreateInstance(CLSID_CWsbGuid, NULL, CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid1));
        WsbAssertHr(pGuid1->SetGuid(CLSID_CWsbGuid));
        

        // Add the item to the collection.
        hr = S_OK;
        try {
            WsbAssertHr(Add(pGuid1));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // There should be 1 entry.
        hr = S_OK;
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // It should not be empty.
        hr = S_OK;
        try {
            WsbAssert(IsEmpty() == S_FALSE, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Does it think it has the item?
        hr = S_OK;
        try {
            WsbAssertHr(Find(pGuid1, IID_IWsbGuid, (void**) &pGuid2));
            WsbAssert(pGuid1->IsEqual(pGuid2) == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        
        // Add some more items
        pGuid2 = 0;
        WsbAssertHr(CoCreateInstance(CLSID_CWsbGuid, NULL, CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid2));
        WsbAssertHr(pGuid2->SetGuid(CLSID_CWsbGuid));
        WsbAssertHr(CoCreateInstance(CLSID_CWsbGuid, NULL, CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid3));
        WsbAssertHr(pGuid3->SetGuid(IID_IWsbGuid));

        // Add the items to the collection.
        hr = S_OK;
        try {
            WsbAssertHr(Add(pGuid2));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(Add(pGuid3));
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // There should be 3 entries.
        hr = S_OK;
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(3 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // How many copies does it have?
        hr = S_OK;
        try {
            WsbAssertHr(OccurencesOf(pGuid1, &entries));
            WsbAssert(2 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(OccurencesOf(pGuid3, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        
        // Remove one of the two identical items.
        hr = S_OK;
        try {
            WsbAssertHr(Remove(pGuid1, IID_IWsbGuid, (void**) &pGuid4));
            WsbAssertHr(pGuid1->IsEqual(pGuid4));
            pGuid4 = 0;
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // There should be 2 entries.
        hr = S_OK;
        try {
            WsbAssertHr(GetEntries(&entries));
            WsbAssert(2 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // How many copies does it have?
        hr = S_OK;
        try {
            WsbAssertHr(OccurencesOf(pGuid1, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }

        hr = S_OK;
        try {
            WsbAssertHr(OccurencesOf(pGuid3, &entries));
            WsbAssert(1 == entries, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Can we find an entry?
        hr = S_OK;
        try {
            WsbAssertHr(Find(pGuid3, IID_IWsbGuid, (void**) &pGuid4));
            WsbAssertHr(pGuid4->IsEqual(pGuid3));
            pGuid4 = 0;
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Does the collection still contain it?
        hr = S_OK;
        try {
            WsbAssert(Contains(pGuid1) == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Remove the last of the two identical items, and verify
        // that it can't be found. Then puit it back.
        hr = S_OK;
        try {
            WsbAssertHr(Remove(pGuid1, IID_IWsbGuid, (void**) &pGuid4));
            WsbAssert(Contains(pGuid1) == S_FALSE, E_FAIL);
            WsbAssertHr(Add(pGuid4));
            pGuid4 = 0;
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Try out the persistence stuff.
        {
            CComPtr<IPersistFile>       pFile1;
            CComPtr<IPersistFile>       pFile2;
            CComPtr<IWsbCollection>     pCollect2;

            WsbAssertHr(((IUnknown*)(IWsbCollection*)this)->QueryInterface(IID_IPersistFile, (void**) &pFile1));
            WsbAssertHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IPersistFile, (void**) &pFile2));


            // The item should be dirty.
            hr = S_OK;
            try {
                WsbAssert(pFile1->IsDirty() == S_OK, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }

                            
            // Save the item, and remember.
            hr = S_OK;
            try {
                WsbAssertHr(pFile1->Save(OLESTR("c:\\WsbTests\\WsbCollection.tst"), TRUE));
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // It shouldn't be dirty.
            hr = S_OK;
            try {
                WsbAssert(pFile1->IsDirty() == S_FALSE, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Load it back in to another instance.
            hr = S_OK;
            try {
                WsbAssertHr(pFile2->Load(OLESTR("c:\\WsbTests\\WsbCollection.tst"), 0));
                WsbAssertHr(pFile2->QueryInterface(IID_IWsbCollection, (void**) &pCollect2));
                WsbAssert(pCollect2->Contains(pGuid1) == S_OK, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        }


        // Remove and Release all the items.
        hr = S_OK;
        try {
            WsbAssertHr(RemoveAllAndRelease());
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // It should be empty.
        hr = S_OK;
        try {
            WsbAssert(IsEmpty() == S_OK, E_FAIL);
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }
    
    } WsbCatch(hr);


    // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    WsbTraceOut(OLESTR("CWsbCollection::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif  // WSB_NO_TEST

    return(hr);
}


HRESULT
CWsbCollection::Unlock(
    void
    )

/*++

Implements:

  CComObjectRoot::Unlock().

--*/
{
    LeaveCriticalSection(&m_CritSec);
    WsbTrace(OLESTR("CWsbCollection::Unlock - freed critical section\n"));
    return(S_OK);

}

// Class: CWsbIndexedCollection

HRESULT
CWsbIndexedCollection::Add(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IWsbCollection::Add().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Add"), OLESTR(""));

    Lock();
    try {
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(AddAt(pCollectable, m_entries));
    } WsbCatch(hr);

    Unlock();
    WsbTraceOut(OLESTR("CWsbIndexedCollection::Add"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Append(
    IUnknown* pCollectable
    )

/*++

Implements:

  IWsbIndexedCollection::Append().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Append"), OLESTR(""));

    hr = Add(pCollectable);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Append"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Enum(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IWsbCollection::Enum().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnum>   pEnum;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Enum"), OLESTR(""));

    try {

        WsbAssert(0 != ppEnum, E_POINTER);

        // Create the instance, initialize it to point to this collection, and
        // return the pointer to the caller.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbIndexedEnum, NULL, CLSCTX_ALL, IID_IWsbEnum, (void**) &pEnum));
        WsbAffirmHr(pEnum->Init((IWsbCollection*) ((IWsbIndexedCollection*) this)));
        *ppEnum = pEnum;
        (*ppEnum)->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Enum"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::EnumUnknown(
    OUT IEnumUnknown** ppEnum
    )

/*++

Implements:

  IWsbCollection::EnumUnknown().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnum>   pWsbEnum;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::EnumUnknown"), OLESTR(""));

    try {
        WsbAssert(0 != ppEnum, E_POINTER);

        // Get the IWsbEnum interface, and then query for the IEnumUknown interface.
        WsbAffirmHr(Enum(&pWsbEnum));
        WsbAffirmHr(pWsbEnum->QueryInterface(IID_IEnumUnknown, (void**) ppEnum));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::EnumUnknown"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::First(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbCollection::First().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::First"), OLESTR("iid = <%ls>"), WsbGuidAsString(riid));

    try {
        WsbAssert(0 != ppElement, E_POINTER);
        WsbAffirm(m_entries != 0, WSB_E_NOTFOUND);
        WsbAffirmHr(At(0, riid, ppElement));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::First"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Index(
    IN IUnknown* pCollectable,
    OUT ULONG* pIndex
    )

/*++

Implements:

  IWsbIndexedCollection::Index().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbCollectable>    pOut;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Index"), OLESTR(""));

    try {

        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAssert(0 != pIndex, E_POINTER);

        // Find the first occurence of the item.
        WsbAffirmHr(CopyIfMatches(WSB_COLLECTION_MIN_INDEX, m_entries, pCollectable, 1, IID_IWsbCollectable, (void**) &pOut, NULL, pIndex));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Index"), OLESTR("hr = <%ls>, index = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pIndex));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Last(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbCollection::Last().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Last"), OLESTR("iid = <%ls>"), WsbGuidAsString(riid));

    try {

        // As long as we have some entires, get the last one.
        WsbAssert(0 != ppElement, E_POINTER);
        WsbAffirm(m_entries != 0, WSB_E_NOTFOUND);
        WsbAffirmHr(At(m_entries - 1, riid, ppElement));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Last"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Prepend(
    IN IUnknown* pCollectable
    )

/*++

Implements:

  IWsbIndexedCollection::Prepend().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Prepend"), OLESTR(""));

    try {
        WsbAssert(0 != pCollectable, E_POINTER);
        WsbAffirmHr(AddAt(pCollectable, 0));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Prepend"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CWsbIndexedCollection::Remove(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbCollection::Remove().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       index;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Remove"), OLESTR(""));

    Lock();
    try {
        // Can we find it in our array?
        WsbAffirmHr(Index(pCollectable, &index));

        // Remove it from the specified offset.
        WsbAffirmHr(RemoveAt(index, riid, ppElement));
    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Remove"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::RemoveAllAndRelease(
    void
    )

/*++

Implements:

  IWsbIndexedCollection::RemoveAllAndRelease().

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedCollection::RemoveAllAndRelease"), OLESTR(""));

    Lock();
    try {

        // Start at the end of the list, and keep removing from the
        // back. For some types of collections, this may not be the most
        // efficient way to remove all the elements.

        if (m_entries > 0) {

            ULONG index = m_entries - 1;

            while (index > 0) {

                WsbAffirmHr(RemoveAt(index, IID_IWsbCollectable, NULL));
                --index;
            }

            WsbAffirmHr(RemoveAt(index, IID_IWsbCollectable, NULL));
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbIndexedCollection::RemoveAllAndRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedCollection::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)

    WsbTraceIn(OLESTR("CWsbIndexedCollection::Test"), OLESTR(""));

    try {

        // First run the standard tests for all collections.
        WsbAffirmHr(CWsbCollection::Test(passed, failed));

        // Now do the test that are specific for an indexed collection



        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedCollection::Test"), OLESTR("hr =<%ls>, testsRun = <%u>"), WsbHrAsString(hr));
#endif  // WSB_NO_TEST

    return(hr);
}



// Class:   CWsbOrderedCollection

HRESULT
CWsbOrderedCollection::AddAt(
    IN IUnknown* pCollectable,
    IN ULONG index
    )

/*++

Implements:

  IWsbIndexedCollection::AddAt().

--*/
{
    HRESULT             hr = S_OK;
    IWsbCollectable**   pCollectableNew;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::AddAt"), OLESTR("index = <%lu>"), index);

    Lock();
    try {

        // Are we beyond the end of the collection?
        WsbAffirm(index <= m_entries, WSB_E_OUTOFBOUNDS);
    
        // Is it full?
        if (m_entries >= m_maxEntries) {

            // Could we grow?
            WsbAffirm(((WSB_COLLECTION_MAX_INDEX - m_maxEntries) >= m_growBy), WSB_E_TOOLARGE);

            // Try to allocate a bigger array.
            pCollectableNew = (IWsbCollectable**) WsbRealloc((void*) m_pCollectable, (m_maxEntries + m_growBy) * sizeof(IWsbCollectable*));

            WsbAffirm(pCollectableNew != NULL, E_OUTOFMEMORY);

            m_pCollectable = pCollectableNew;
            m_maxEntries += m_growBy;
        }

        // If we have room, then add it to the collection.
        // First shift any existing entries.
        for (ULONG tmpIndex = m_entries; tmpIndex > index; tmpIndex--) {
            m_pCollectable[tmpIndex] = m_pCollectable[tmpIndex - 1];
        }

        // Now add the new entry.
        m_entries++;
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbCollectable, 
                (void**)&m_pCollectable[index]));
        m_isDirty = TRUE;

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::AddAt"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbOrderedCollection::At(
    IN ULONG index,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbIndexedCollection::At().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::At"), OLESTR("index = <%lu>, riid = <%ls>"), index, WsbGuidAsString(riid));

    Lock();
    try {

        WsbAffirm(index < m_entries, WSB_E_OUTOFBOUNDS);
        WsbAssert(0 != ppElement, E_POINTER);

        // If they asked for an interface, then try to get the desired
        // interface for the item specified.
        WsbAffirmHr((m_pCollectable[index])->QueryInterface(riid, (void**) ppElement));

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::At"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbOrderedCollection::Copy(
    IN ULONG start,
    IN ULONG stop,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbIndexedCollection::Copy().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       toDo;
    ULONG       copied = 0;
    ULONG       index;
    BOOL        isIncrement = TRUE;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::Copy"), OLESTR("start = <%lu>, stop = <%lu>, riid = <%ls>"), start, stop, WsbGuidAsString(riid));

    Lock();
    try {

        WsbAssert(0 != elements, E_POINTER);
        WsbAssert(0 != pElementsFetched, E_POINTER);
        WsbAffirm(start < m_entries, WSB_E_NOTFOUND);

        // Determine how many elements to copy, and the order in which we are
        // going (increasing vs. decreasing).
        if (start <= stop) {
            toDo = stop - start + 1;
        } else {
            toDo = start - stop + 1;
            isIncrement = FALSE;
        }

        // Iterate over all the items in the range specified, and copy
        // the interface in to the target array.
        for (copied = 0, index = start; ((copied < toDo) && (index < m_entries)); copied++, isIncrement ? index++ : index--) {
            WsbAffirmHr(m_pCollectable[index]->QueryInterface(riid, (void**) &(elements[copied])));
        }

        // Let them know if we didn't fill up the return buffer.
        if (copied < toDo) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    *pElementsFetched = copied;
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::Copy"), OLESTR("hr = <%ls>, elementsFetched = <%lu>"), WsbHrAsString(hr), copied);

    return(hr); 
}


HRESULT
CWsbOrderedCollection::CopyIfMatches(
    ULONG start,
    ULONG stop,
    IUnknown* pObject,
    ULONG element,
    REFIID riid,
    void** elements,
    ULONG* pElementsFetched,
    ULONG* pStoppedAt
    )

/*++

Implements:

  IWsbIndexedCollection::CopyIfMatches().

--*/
{
    HRESULT     hr = S_OK;
    ULONG       copied = 0;
    ULONG       index = start;
    ULONG       end = stop;
    BOOL        done = FALSE;
    CComPtr<IWsbCollectable> pCollectable;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::CopyIfMatches"), OLESTR("start = <%lu>, stop = <%lu>, riid = <%ls>"), start, stop, WsbGuidAsString(riid));

    Lock();
    try {

        WsbAssert(0 != elements, E_POINTER);
        WsbAssert(0 != pStoppedAt, E_POINTER);
        WsbAssert((1 == element) || (0 != pElementsFetched), E_POINTER);
        WsbAssert(0 != element, E_INVALIDARG);

        WsbAffirm(start < m_entries, WSB_E_NOTFOUND);
        WsbAffirmHr(pObject->QueryInterface(IID_IWsbCollectable,
                (void **)&pCollectable));
        
        if (start <= stop) {

            // Incrementing.
            if (stop >= m_entries) {
                end = m_entries - 1;
            }
            
            // Continue from here to the end of the range.
            while (!done) {
                if (pCollectable->IsEqual(m_pCollectable[index]) == S_OK) {
                    WsbAffirmHr(m_pCollectable[index]->QueryInterface(riid, (void**) &(elements[copied])));
                    copied++;
                }

                if ((copied < element) && (index < end)) {
                    index++;
                }
                else {
                    done = TRUE;
                }
            }

        } else {

            // Decrementing..
            while (!done) {
                if (m_pCollectable[index]->IsEqual(pCollectable) == S_OK) {
                    WsbAffirmHr(m_pCollectable[index]->QueryInterface(riid, (void**) &(elements[copied])));
                    copied++;
                }

                if ((copied < element) && (index > end)) {
                    index--;
                }
                else {
                    done = TRUE;
                }
            }
        }

        if (0 != pElementsFetched) {
            *pElementsFetched = copied;
        }

        *pStoppedAt = index;

        // If we didn't find anything, then let them know.
        WsbAffirm(0 != copied, WSB_E_NOTFOUND);

        // Let them know if we didn't fill the output buffer,
        // and t=let them know the last index that was checked.
        if (copied < element) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::CopyIfMatches"), OLESTR("hr = <%ls>, elementsFetched = <%lu>, stoppedAt = <%ls>"), WsbHrAsString(hr), copied, WsbPtrToUlongAsString(pStoppedAt));

    return(hr); 
}


HRESULT
CWsbOrderedCollection::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CWsbCollection::FinalConstruct());

        m_pCollectable = NULL;
        m_maxEntries = 0;
        m_growBy = 256;
    } WsbCatch(hr);

    return(hr);
}
    

void
CWsbOrderedCollection::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    if (0 != m_pCollectable) {
        Lock();
        RemoveAllAndRelease();
        WsbFree((void*) m_pCollectable);
        Unlock();
    }

    CWsbCollection::FinalRelease();
}


HRESULT
CWsbOrderedCollection::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbOrderedCollection;
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CWsbOrderedCollection::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbOrderedCollection::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT             hr = S_OK;
    IPersistStream*     pPersistStream;
    ULARGE_INTEGER      size;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::GetSizeMax"), OLESTR(""));

    try {
        WsbAssert(0 == pSize, E_POINTER);

        // The size of the header information.
        pSize->QuadPart = 3 * WsbPersistSizeOf(ULONG);
    
        // If we have entries, then add in the size for the maximum number
        // of entries, assuming that they are all the same size.
        if (m_entries != 0) {
            WsbAffirmHr(First(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->GetSizeMax(&size));
            pSize->QuadPart += (m_maxEntries * (size.QuadPart));
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbOrderedCollection::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CWsbOrderedCollection::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbCollectable>    pCollectable;
    ULONG                       entries;
    ULONG                       growBy;
    ULONG                       maxEntries;
    
    WsbTraceIn(OLESTR("CWsbOrderedCollection::Load"), 
            OLESTR("m_entries = %ld, m_maxEntries = %ld, m_growBy = %ld, m_pCollectable = %p"),
            m_entries, m_maxEntries, m_growBy, m_pCollectable);

    Lock();
    try {
        IWsbCollectable**       pTmp;

        // Make sure the collection starts empty
        if (m_entries != 0) {
            WsbAffirmHr(RemoveAllAndRelease());
        }

        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &entries));
        WsbAffirmHr(WsbLoadFromStream(pStream, &maxEntries));
        WsbAffirmHr(WsbLoadFromStream(pStream, &growBy));
        WsbAffirm(entries <= maxEntries, WSB_E_PERSISTENCE_FILE_CORRUPT);

        // Allocate space for the array.
        if (entries > m_maxEntries) {
            pTmp = (IWsbCollectable**) WsbRealloc(m_pCollectable, 
                    maxEntries * sizeof(IWsbCollectable*));
            WsbAffirm(0 != pTmp, E_OUTOFMEMORY);
    
            // Remember our new buffer.
            m_pCollectable = pTmp;
            m_maxEntries = maxEntries;
        }
        m_growBy = growBy;

        // Now do the items in the collection.
        for (ULONG index = 0; (index < entries); index++) {
            WsbAffirmHr(OleLoadFromStream(pStream, IID_IWsbCollectable, (void**) &pCollectable));
            WsbAffirmHr(Append(pCollectable));
            pCollectable = 0;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::Load"), 
            OLESTR("m_entries = %ld, m_maxEntries = %ld, m_growBy = %ld, m_pCollectable = %p"),
            m_entries, m_maxEntries, m_growBy, m_pCollectable);

    return(hr);
}


HRESULT
CWsbOrderedCollection::RemoveAt(
    IN ULONG index,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbIndexedCollection::RemoveAt().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbOrderedCollection::RemoveAt"), OLESTR("index = <%lu>, riid = <%ls>"), index, WsbGuidAsString(riid));

    Lock();
    try {

        // Make sure that the index is in range.
        WsbAffirm(index < m_entries, WSB_E_OUTOFBOUNDS);

        // If they asked for an interface, then try to get the desired
        // interface for the item specified.
        if (0 != ppElement) {
            WsbAffirmHr(m_pCollectable[index]->QueryInterface(riid, (void**) ppElement));
        }

        // Remove the item
        m_pCollectable[index]->Release();

        // Now shift all the items in the collection.
        for (ULONG tmpIndex = index; (tmpIndex < (m_entries - 1)); tmpIndex++) {
            m_pCollectable[tmpIndex] = m_pCollectable[tmpIndex + 1];
        }

        m_entries--;
        m_isDirty = TRUE;
            
        // If the collection has really shrunk in size, then we
        // should free up some memory.
        if ((m_maxEntries - m_entries) >= (2 * m_growBy)) {

            // Try to allocate a smaller array.
            IWsbCollectable** pCollectableNew = (IWsbCollectable**) WsbRealloc((void*) m_pCollectable, (m_maxEntries - m_growBy) * sizeof(IWsbCollectable*));

            WsbAffirm(pCollectableNew != NULL, E_OUTOFMEMORY);

            m_pCollectable = pCollectableNew;
            m_maxEntries -= m_growBy;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::RemoveAt"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbOrderedCollection::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    
    WsbTraceIn(OLESTR("CWsbOrderedCollection::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    Lock();
    try {

        // Check for consistency first
        WsbAffirm(m_entries <= m_maxEntries, WSB_E_INVALID_DATA);

        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_entries));
        WsbAffirmHr(WsbSaveToStream(pStream, m_maxEntries));
        WsbAffirmHr(WsbSaveToStream(pStream, m_growBy));

        // Now do the items in the collection.
        if (m_entries > 0) {
            CComPtr<IWsbEnum>       pEnum;
            CComPtr<IPersistStream> pPersistStream;

            // We need to enumerate the items in the collection.
            WsbAffirmHr(Enum(&pEnum));

            for (hr = pEnum->First(IID_IPersistStream, (void**) &pPersistStream);
                 SUCCEEDED(hr);
                 hr = pEnum->Next(IID_IPersistStream, (void**) &pPersistStream)) {
                    
                hr = OleSaveToStream(pPersistStream, pStream);
                pPersistStream = 0;
            }

            WsbAssert(hr == WSB_E_NOTFOUND, hr);
            hr = S_OK;
        }

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);
    Unlock();

    WsbTraceOut(OLESTR("CWsbOrderedCollection::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbenum.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbenum.cpp

Abstract:

    These classes provides enumerators (iterators) for the collection classes.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbenum.h"


HRESULT
CWsbIndexedEnum::Clone(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IWsbEnum::Clone

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnum>   pWsbEnum;
    
    WsbTraceIn(OLESTR("CWsbIndexedEnum::Clone(IWsbEnum)"), OLESTR(""));

    try {

        // Create a new enumeration instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbIndexedEnum, NULL, CLSCTX_ALL, IID_IWsbEnum, (void**) &pWsbEnum));

        // It should reference the same collection.
        WsbAffirmHr(pWsbEnum->Init((IWsbCollection*) m_pCollection));

        // It should reference the same item in the collection.
        WsbAffirmHr(pWsbEnum->SkipTo(m_currentIndex));

        *ppEnum = pWsbEnum;
        pWsbEnum->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Clone(IWbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Clone(
    OUT IWsbEnumEx** ppEnum
    )

/*++

Implements:

  IWsbEnumEx::Clone

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnumEx> pWsbEnum;
    
    WsbTraceIn(OLESTR("CWsbIndexedEnum::Clone(IWsbEnumEx)"), OLESTR(""));

    try {

        // Create a new enumeration instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbIndexedEnum, NULL, CLSCTX_ALL, IID_IWsbEnumEx, (void**) &pWsbEnum));

        // It should reference the same collection.
        WsbAffirmHr(pWsbEnum->Init((IWsbCollection*) m_pCollection));

        // It should reference the same item in the collection.
        WsbAffirmHr(pWsbEnum->SkipTo(m_currentIndex));

        *ppEnum = pWsbEnum;
        pWsbEnum->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Clone(IWbEnumEx)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbIndexedEnum::Clone(
    OUT IEnumUnknown** ppEnum
    )

/*++

Implements:

  IEnumUknown::Clone

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IWsbEnum>   pWsbEnum;
    
    WsbTraceIn(OLESTR("CWsbIndexedEnum::Clone(IEnumUnknown)"), OLESTR(""));

    try {

        // This does the major part of the work.
        WsbAffirmHr(Clone(&pWsbEnum));
        
        // Now get them the interace that they wanted.
        WsbAffirmHr(pWsbEnum->QueryInterface(IID_IEnumUnknown, (void**) ppEnum));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Clone(IEnumUnknown)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
#pragma optimize("g", off)


HRESULT
CWsbIndexedEnum::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CComObjectRoot::FinalConstruct());
        m_currentIndex = 0;
    } WsbCatch(hr);

    return(hr);
}
#pragma optimize("", on)
    

HRESULT
CWsbIndexedEnum::Find(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::Find

--*/
{
    HRESULT     hr = S_OK;
    ULONG       elementsFetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Find(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        hr = m_pCollection->CopyIfMatches(WSB_COLLECTION_MIN_INDEX, WSB_COLLECTION_MAX_INDEX, pCollectable, 1, riid, ppElement, &elementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Find(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Find(
    IN IUnknown* pCollectable,
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::Find

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Find(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        hr = m_pCollection->CopyIfMatches(WSB_COLLECTION_MIN_INDEX, WSB_COLLECTION_MAX_INDEX, pCollectable, element, riid, elements, pElementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Find(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::FindNext(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::FindNext

--*/
{
    HRESULT     hr = S_OK;
    ULONG       elementsFetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::FindNext(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // If we are already at the end of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MAX_INDEX != m_currentIndex, WSB_E_NOTFOUND);
        
        hr = m_pCollection->CopyIfMatches(m_currentIndex + 1, WSB_COLLECTION_MAX_INDEX, pCollectable, 1, riid, ppElement, &elementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::FindNext(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::FindNext(
    IN IUnknown* pCollectable,
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::FindNext

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::FindNext(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        // If we are already at the end of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MAX_INDEX != m_currentIndex, WSB_E_NOTFOUND);
        
        hr = m_pCollection->CopyIfMatches(m_currentIndex + 1, WSB_COLLECTION_MAX_INDEX, pCollectable, element, riid, elements, pElementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::FindNext(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::FindPrevious(
    IN IUnknown* pCollectable,
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::FindPrevious

--*/
{
    HRESULT     hr = S_OK;
    ULONG       elementsFetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::FindPrevious(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // If we are already at the beginning of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MIN_INDEX != m_currentIndex, WSB_E_NOTFOUND);

        hr = m_pCollection->CopyIfMatches(m_currentIndex - 1, WSB_COLLECTION_MIN_INDEX, pCollectable, 1, riid, ppElement, &elementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::FindPrevious(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::FindPrevious(
    IN IUnknown* pCollectable,
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::FindPrevious

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::FindPrevious(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        // If we are already at the beginning of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MIN_INDEX != m_currentIndex, WSB_E_NOTFOUND);

        hr = m_pCollection->CopyIfMatches(m_currentIndex - 1, WSB_COLLECTION_MIN_INDEX, pCollectable, element, riid, elements, pElementsFetched, &m_currentIndex);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::FindPrevious(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::First(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::First

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched = 0;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::First(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // Since we aren't doing any addition to the number of elements, the
        // Copy command does all the range checking that we need.
        WsbAffirmHr(m_pCollection->Copy(WSB_COLLECTION_MIN_INDEX, 0, riid, ppElement, &fetched));

        // If items were read, then update the current index, and return to
        // them the number of elements fetched if they wanted to know.
        m_currentIndex = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::First(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::First(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::First

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched = 0;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::First(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssert((0 != pElementsFetched), E_POINTER);


        // Since we aren't doing any addition to the number of elements, the
        // Copy command does all the range checking that we need.
        WsbAffirmHr(m_pCollection->Copy(WSB_COLLECTION_MIN_INDEX, element - 1, riid, elements, &fetched));

        // If items were read, then update the current index, and return to
        // them the number of elements fetched if they wanted to know.
        m_currentIndex = fetched - 1;

        *pElementsFetched = fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::First(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), fetched);

    return(hr);
}


HRESULT
CWsbIndexedEnum::Init(
    IN IWsbCollection* pCollection
    )

/*++

Implements:

  IWsbEnum::Init

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Init"), OLESTR(""));

    try {

        WsbAssert(0 != pCollection, E_POINTER);

        // Only let them initialize the enumeration once.
        WsbAssert(m_pCollection == 0, S_FALSE);
    
        // Since this enum is for indexed collections, get an indexed
        // interface to it.
        WsbAffirmHr(pCollection->QueryInterface(IID_IWsbIndexedCollection, (void**) &m_pCollection));   

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Init"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
};
    

HRESULT
CWsbIndexedEnum::Last(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::Last

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Last(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // We must have some entries.
        WsbAffirm(entries != 0, WSB_E_NOTFOUND);

        WsbAffirmHr(m_pCollection->Copy(entries - 1, entries - 1, riid, ppElement, &fetched));

        // If items were read, then update the current index, and return to
        // them the number of elements fetched if they wanted to know.
        m_currentIndex = entries - fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Last(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Last(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::Last

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Last(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssertPointer(pElementsFetched);

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // We must have some entries.
        WsbAffirm(entries != 0, WSB_E_NOTFOUND);

        // If they have asked for more elements than could be represented by
        // then index, then don't let the index wrap around.
        if (element > entries) {
            WsbAffirmHr(m_pCollection->Copy(entries - 1, WSB_COLLECTION_MIN_INDEX, riid, elements, &fetched));

            // Let them know that they didn't get all the items they requested.
            hr = S_FALSE;
        } else {
            WsbAffirmHr(m_pCollection->Copy(entries - 1, entries - element, riid, elements, &fetched));
        }

        // If items were read, then update the current index, and return to
        // them the number of elements fetched if they wanted to know.
        m_currentIndex = entries - fetched;

        *pElementsFetched = fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Last(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Next(
    IN ULONG element,
    OUT IUnknown** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IEnumUknown::Next

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Next(IEnumUnknown)"), OLESTR("element = <%lu>"), element);

    hr = Next(element, IID_IUnknown, (void**) elements, pElementsFetched);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Next(IEnumUnknown)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Next(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::Next

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Next(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // If we are already at the end of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MAX_INDEX != m_currentIndex, WSB_E_NOTFOUND);

        WsbAffirmHr(m_pCollection->Copy(m_currentIndex + 1, m_currentIndex + 1, riid, ppElement, &fetched));

        m_currentIndex += fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Next(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Next(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnumEx::Next

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Next(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssert(0 != element, E_INVALIDARG);
        WsbAssertPointer(pElementsFetched);

        // If we are already at the end of the list, then you can't go any
        // further.
        WsbAffirm(WSB_COLLECTION_MAX_INDEX != m_currentIndex, WSB_E_NOTFOUND);

        // If they have asked for more elements than could be represented by
        // then index, then don't let the index wrap around.
        if ((WSB_COLLECTION_MAX_INDEX - m_currentIndex) < element) {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex + 1, WSB_COLLECTION_MAX_INDEX, riid, elements, &fetched));
        
            // Let them know that they didn't get all the items they requested.
            hr = S_FALSE;
        } else {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex + 1, m_currentIndex + element, riid, elements, &fetched));
        }

        m_currentIndex += fetched;

        *pElementsFetched = fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Next(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Previous(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::Previous

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Previous(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        // If we are already at the beginning of the list, then you can't go any
        // further.
        WsbAffirm(m_currentIndex != WSB_COLLECTION_MIN_INDEX, WSB_E_NOTFOUND);

        WsbAffirmHr(m_pCollection->Copy(m_currentIndex - 1, m_currentIndex - 1, riid, ppElement, &fetched));

        m_currentIndex -= fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Previous(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Previous(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    IN ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnum::Previous

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Previous(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssertPointer(pElementsFetched);

        // If we are already at the beginning of the list, then you can't go any
        // further.
        WsbAffirm(m_currentIndex != WSB_COLLECTION_MIN_INDEX, WSB_E_NOTFOUND);

        // If they have asked for more elements than are before us in the
        // collection, then don't let the index wrap around.
        if (m_currentIndex < element) {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex - 1, WSB_COLLECTION_MIN_INDEX, riid, elements, &fetched));
        
            // Let them know that they didn't get all the items they requested.
            hr = S_FALSE;
        } else {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex - 1, m_currentIndex - element, riid, elements, &fetched));
        }

        m_currentIndex -= fetched;

        *pElementsFetched = fetched;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Previous(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}


HRESULT
CWsbIndexedEnum::Reset(
    void
    )

/*++

Implements:

  IEnumUnknown::Reset

--*/
{
    HRESULT     hr = S_OK;
  
    WsbTraceIn(OLESTR("CWsbIndexedEnum::Reset"), OLESTR(""));
    
    hr = SkipToFirst();
    
    WsbTraceOut(OLESTR("CWsbIndexedEnum::Reset"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(S_OK);
}


HRESULT
CWsbIndexedEnum::Skip(
    IN ULONG element
    )

/*++

Implements:

  IEnumUnknown::Skip

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::Skip"), OLESTR("element = <%lu>"), element);
    
    hr = SkipNext(element);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::Skip"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipNext(
    IN ULONG element
    )

/*++

Implements:

  IWsbEnum::SkipNext

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipNext"), OLESTR("element = <%lu>"), element);
    
    try {

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // If there aren't any entries, then put it at the beginning
        // and let them no it was empty.
        if (0 == entries) {
            hr = S_FALSE;
            m_currentIndex = WSB_COLLECTION_MIN_INDEX;
        }

        // Are we already at the end of the list, or have they requested
        // to go beyond the end of the list?
        else if ((m_currentIndex >= (entries - 1)) ||
                 ((entries - m_currentIndex) < element)) {
            hr = S_FALSE;
            m_currentIndex = entries - 1;
        }

        // They asked for something legal.
        else {
            m_currentIndex += element;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipNext"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipPrevious(
    IN ULONG element
    )

/*++

Implements:

  IWsbEnum::SkipPrevious

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipPrevious"), OLESTR("element = <%lu>"), element);
    
    // If we are already at the beginning of the list, then you can't go any
    // further.
    if (m_currentIndex == WSB_COLLECTION_MIN_INDEX) {
        hr = S_FALSE;
    }

    // If they have asked for more elements than could be represented by
    // then index, then don't let the index wrap around.
    else if (m_currentIndex < element) {
        m_currentIndex = WSB_COLLECTION_MIN_INDEX;
 
        // Let them know that they didn't get all the items they requested.
        hr = S_FALSE;
    }

    // They asked for something legal.
    else {
        m_currentIndex -= element;
    }

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipPrevious"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipTo(
    IN ULONG index
    )

/*++

Implements:

  IWsbEnum::SkipTo

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipToIndex"), OLESTR("index = <%lu>"), index);

    try {
        
        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // If there aren't any entries, then put it at the beginning
        // and let them no it was empty.
        if (0 == entries) {
            hr = S_FALSE;
            m_currentIndex = WSB_COLLECTION_MIN_INDEX;
        }

        // They asked for something beyond the end of the collection, so
        // put them at the end of the collection and let them now there
        // was a problem.
        else if (index > (entries - 1)) {
            hr = S_FALSE;
            m_currentIndex = entries - 1;
        }

        // They asked for something legal.
        else {
            m_currentIndex = index;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipToIndex"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipToFirst(
    void
    )

/*++

Implements:

  IWsbEnum::SkipToFirst

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipToFirst"), OLESTR(""));

    try {

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // If there aren't any entries, then put it at the beginning
        // and let them no it was empty.
        if (0 == entries) {
            hr = S_FALSE;
        }

        m_currentIndex = WSB_COLLECTION_MIN_INDEX;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipToFirst"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::SkipToLast(
    void
    )

/*++

Implements:

  IWsbEnum::SkipToLast

--*/
{
    HRESULT     hr = S_OK;
    ULONG       entries;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::SkipToLast"), OLESTR(""));

    try {

        // Find out where the end is located.
        WsbAffirmHr(m_pCollection->GetEntries(&entries));

        // If there aren't any entries, then put it at the beginning
        // and let them no it was empty.
        if (0 == entries) {
            hr = S_FALSE;
            m_currentIndex = WSB_COLLECTION_MIN_INDEX;
        }

        // They asked for something legal.
        else {
            m_currentIndex = entries - 1;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::SkipToLast"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::This(
    IN REFIID riid,
    OUT void** ppElement
    )

/*++

Implements:

  IWsbEnum::This

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::This(IWsbEnum)"), OLESTR("riid = <%ls>"), WsbGuidAsString(riid));

    try {

        WsbAssert(0 != ppElement, E_POINTER);

        WsbAffirmHr(m_pCollection->Copy(m_currentIndex, m_currentIndex, riid, ppElement, &fetched));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::This(IWsbEnum)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbIndexedEnum::This(
    IN ULONG element,
    IN REFIID riid,
    OUT void** elements,
    OUT ULONG* pElementsFetched
    )

/*++

Implements:

  IWsbEnum::This

--*/
{
    HRESULT     hr = S_OK;
    ULONG       fetched;

    WsbTraceIn(OLESTR("CWsbIndexedEnum::This(IWsbEnumEx)"), OLESTR("element = <%lu>, riid = <%ls>"), element, WsbGuidAsString(riid));

    try {

        WsbAssert(0 != element, E_INVALIDARG);
        WsbAssertPointer(elements);
        WsbAssertPointer(pElementsFetched);

        // If they have asked for more elements than could be represented by
        // then index, then don't let the index wrap around.
        if ((WSB_COLLECTION_MAX_INDEX - m_currentIndex) <= element) {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex, WSB_COLLECTION_MAX_INDEX, riid, elements, &fetched));
        
            // Let them know that they didn't get all the items they requested.
            hr = S_FALSE;
        } else {
            WsbAffirmHr(m_pCollection->Copy(m_currentIndex, m_currentIndex + element - 1, riid, elements, &fetched));
        }

        *pElementsFetched = fetched - 1;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbIndexedEnum::This(IWsbEnumEx)"), OLESTR("hr = <%ls>, fetched = <%lu>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pElementsFetched));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbcore.cpp ===
#include "StdAfx.h"
#include "resource.h"
#include "errno.h"

#include "Wsb.h"

#include "rpfilt.h"

// File/Directory

// Create a directory and all the parent directories necessary for this directory to
// exist.
HRESULT WsbCreateAllDirectories(OLECHAR* path) {
    HRESULT         hr = S_OK;
    CWsbBstrPtr     win32Path;
    CWsbBstrPtr     parentPath;

    try {

        // Convert the path to the win32 style path (to handle long file names), and
        // then try to create the directory.
        WsbAffirmHr(WsbGetWin32PathAsBstr(path, &win32Path));
        if (CreateDirectory(win32Path, 0) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // There are 4 possibilities:
        //      1) it worked (we are done)
        //      2) the directory already exists (we are done)
        //      3) the directory doesn't exist, so try again after creating the parent
        //      4) some other error occurred, so quit
        if (FAILED(hr)) {

            if ((HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr) || (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr) || (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)) {
                hr = S_OK;
            } else if ((HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr) || (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)) {

                // Create the parent directory and try again.
                WsbAffirmHr(WsbCreateAllDirectoriesForFile(path));

                if (CreateDirectory(win32Path, 0) == 0) {
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    if ((HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr) || (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)) {
                        hr = S_OK;
                    }
                } else {
                    hr = S_OK;
                }
            }
        }

    } WsbCatch(hr);

    return(hr);
}

// Create a all the parent directories necessary for this file to exist.
HRESULT WsbCreateAllDirectoriesForFile(OLECHAR* path) {
    HRESULT         hr = S_OK;
    CWsbBstrPtr     parentPath;
    OLECHAR*        slashPtr = 0;
    OLECHAR*        pathStart = 0;

    try {

        // Find out where the relative portion of the path starts, since we don't need to try
        // to create the root directory.
        parentPath = path;
        if ((parentPath[0] == L'\\') && (parentPath[1] == L'\\')) {
            pathStart = wcschr(&parentPath[2], L'\\');
            WsbAffirm(pathStart != 0, E_INVALIDARG);
            pathStart = wcschr(++pathStart, L'\\');
            WsbAffirm(pathStart != 0, E_INVALIDARG);
        } else if (parentPath[1] == L':') {
            pathStart = &parentPath[2];
        } else {
            WsbAssert(FALSE, E_INVALIDARG);
        }

        WsbAffirm(*pathStart != 0, E_INVALIDARG);

        // Create the path to the parent directory and use the create all to create it.
        slashPtr = wcsrchr(pathStart, L'\\');
        if ((slashPtr != 0) && (slashPtr != pathStart)) {
            *slashPtr = 0;

            WsbAffirmHr(WsbCreateAllDirectories(parentPath));
        }

    } WsbCatch(hr);

    return(hr);
}

// Convert a normal path (UNC or drive letter) to the internal format that is needed by
// win32 to deal with long paths and special characters.
HRESULT WsbGetWin32PathAsBstr(OLECHAR* path, BSTR* pWin32Path)
{
    HRESULT         hr = S_OK;
    CWsbBstrPtr     win32Path;

    try {

        WsbAssert(0 != pWin32Path, E_POINTER);

        // Is it a UNC or a drive letter base path?
        if ((path[0] == L'\\') && (path[1] == L'\\')) {
            
            // UNC Paths must be preceeded with '\\?\UNC', but the then should only be
            // followed by one '\' not two. 
            win32Path = L"\\\\?\\UNC";
            WsbAffirmHr(win32Path.Append(&path[1]));

        } else if (path[1] == L':') {

            // Drive letter based paths need to be preceeded by \\?\.
            win32Path = L"\\\\?\\";
            WsbAffirmHr(win32Path.Append(path));
        } else {
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(win32Path.CopyToBstr(pWin32Path));

    } WsbCatch(hr);

    return(hr);
}

// Convert the internal format that is needed by win32 to deal with long paths and
// special characters to a normal path (UNC or drive letter).
HRESULT WsbGetPathFromWin32AsBstr(OLECHAR* win32Path, BSTR* pPath)
{
    HRESULT         hr = S_OK;
    CWsbBstrPtr     path;

    try {

        WsbAssert(0 != pPath, E_POINTER);

        // Is it a UNC or a drive letter base path?
        if (_wcsnicmp(win32Path, L"\\\\?\\", 4) == 0) {
            path = &win32Path[4];
        } else if (_wcsnicmp(win32Path, L"\\\\?\\UNC", 7) == 0) {
            path = "\\";
            WsbAffirmHr(path.Append(&path[7]));
        } else {
            WsbThrow(E_INVALIDARG);
        }

        WsbAffirmHr(path.CopyToBstr(pPath));

    } WsbCatch(hr);

    return(hr);
}

// String & Buffer Copy
HRESULT WsbGetComBuffer(OLECHAR** pDest, ULONG requestedSize, ULONG neededSize, BOOL* pWasAllocated) {
    HRESULT     hr = S_OK;
    
    // If they didn't give us a buffer, then let them know that we
    // had to allocate one for them.
    if (pWasAllocated != NULL) {
        if (*pDest == NULL) {
            *pWasAllocated = TRUE;
        }
        else {
            *pWasAllocated = FALSE;
        }
    }

    // If they gave us the size they wanted (or have) for the
    // buffer, then it better be big enough.
    if (requestedSize != 0) {
        if (requestedSize < neededSize) {
            hr = E_INVALIDARG;
        }
        else if (*pDest == NULL) {
            *pDest = (OLECHAR*)WsbAlloc(requestedSize);

            if (*pDest == NULL) {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // If we control the size of the buffer, then make sure it is
    // the right size.
    //
    // NOTE: This may move the buffer!
    else {
        LPVOID pTemp = WsbRealloc(*pDest, neededSize);
        if (pTemp == NULL) {
            hr = E_OUTOFMEMORY;
        } else {
            *pDest = (OLECHAR *) pTemp;
        }
    }

    return(hr);
}


HRESULT WsbAllocAndCopyComString(OLECHAR** pszDest, OLECHAR* szSrc, ULONG bufferSize) {
    return(WsbAllocAndCopyComString2(pszDest, szSrc, bufferSize, TRUE));
}


HRESULT WsbAllocAndCopyComString2(OLECHAR** pszDest, OLECHAR* szSrc, ULONG bufferSize, BOOL bInOrder) {
    HRESULT     hr = S_OK;
    ULONG       ulStringSize;
    BOOL        bWasAllocated;
    BOOL        bCopyFailed = FALSE;

    // Determine how big a buffer we need to store the string.
    // NOTE: If we given a NULL pointer, then assume a "" will
    // be created.
    if (szSrc == NULL) {
        ulStringSize = sizeof(OLECHAR);
    }
    else {
        ulStringSize = (wcslen(szSrc) + 1) * sizeof(OLECHAR);
    }


    // Make sure that we have a buffer that we can use, and also
    // remember if we created it (so that we can free it on failure).
    hr = WsbGetComBuffer(pszDest, bufferSize, ulStringSize, &bWasAllocated);

    // If we have a valid buffer, then copy the string.
    if (SUCCEEDED(hr)) {

        if (szSrc == NULL) {
            *pszDest[0] = 0;
        }

        else if (bInOrder) {
            if (wcscpy(*pszDest, szSrc) != *pszDest) {
                bCopyFailed = TRUE;
            }
        }
        else {
            int     i,j;

            for (i = 0, j = (ulStringSize / sizeof(OLECHAR)) - 2; j >= 0; i++, j--) {
                (*pszDest)[i] = szSrc[j];
            }
            (*pszDest)[i] = OLECHAR( '\0' );
        }

        if (bCopyFailed) {
                
            // If the copy failed then free the buffer and
            // return an error.
            if (bWasAllocated) {
                WsbFree(*pszDest);
                *pszDest = NULL;
            }

            hr = E_FAIL;
        }
    }
    
    return(hr);
}


HRESULT WsbLoadComString(HINSTANCE hInstance, UINT uID, OLECHAR** pszDest, ULONG bufferSize) {
    HRESULT     hr = S_OK;
    HRSRC       hResource;
    ULONG       ulStringSize;
    BOOL        bWasAllocated = FALSE;

    // Find the resource requested. This requires converting the resource
    // identifier into a string.
    //
    // NOTE: Strings are not number individually, but in groups of 16!! This throws
    // off the latter size calculation, and some other strategy might be better
    // here (e.g. load to a fixed size and then allocate again if too small).
    hResource = FindResource(hInstance, MAKEINTRESOURCE((uID/16) + 1), RT_STRING);
    if (hResource == NULL) {
        hr = E_FAIL;
    }
    else {

        // How big is the string?
        ulStringSize = SizeofResource(hInstance, hResource);
        if (ulStringSize == 0) {
            hr = E_FAIL;
        }
        else {
              
            // Get the right sized buffer.
            hr = WsbGetComBuffer(pszDest, bufferSize, ulStringSize, &bWasAllocated);
            if (SUCCEEDED(hr)) {

                // Load the string into the buffer.
                if (LoadString(hInstance, uID, (LPTSTR) *pszDest, ulStringSize) == 0) {
                    
                    // If we couldn't load the string, then free the buffer that
                    // if we allocated it.
                    if (bWasAllocated)  {
                        WsbFree(*pszDest);
                    }
                    hr = E_FAIL;
                }
            }
        }
    }

    return(hr);
}


HRESULT WsbMatchComString(OLECHAR* szEnd, UINT uId, USHORT usChecks, UINT* uIdMatch) {
    HRESULT     hr = S_FALSE;
    HRESULT     hr2;
    OLECHAR*    szDest = NULL;

    // Initialize the return value.
    *uIdMatch = 0;

    // Check each resource string mention and see if it is the same as
    // the string provided.
    for (UINT uIdTest = uId; ((uIdTest < (uId + usChecks)) && (hr == S_FALSE)); uIdTest++) {

        hr2 = WsbLoadComString(_Module.m_hInst, uIdTest, &szDest, 0);

        if (SUCCEEDED(hr2)) {
            if (wcscmp(szDest, szEnd) == 0) {
                *uIdMatch = uIdTest;
            }
        }
        else {
            hr =hr2;
        }
    }

    // If we allocated a buffer, then we need to free it.
    if (szDest != NULL) {
        WsbFree(szDest);
    }

    return(hr);
}



// Type Conversion
void WsbLLtoHL(LONGLONG ll, LONG* pHigh, LONG* pLow) {

    *pHigh = (DWORD) (ll >> 32);
    *pLow = (DWORD) (ll & 0x00000000ffffffff);
}

LONGLONG WsbHLtoLL(LONG high, LONG low) {
    LONGLONG        ll;

    ll = ((LONGLONG) high) << 32;
    ll += (LONGLONG) (ULONG) low;

    return(ll);         
}

FILETIME WsbLLtoFT(LONGLONG ll) {
    FILETIME        ft;

    WsbLLtoHL(ll, (LONG*) &ft.dwHighDateTime, (LONG*) &ft.dwLowDateTime);

    return(ft);         
}


LONGLONG WsbFTtoLL(FILETIME ft) {
    LONGLONG        ll;

    ll = WsbHLtoLL((LONG) ft.dwHighDateTime, (LONG) ft.dwLowDateTime);

    return(ll);         
}


HRESULT WsbFTtoWCS(BOOL isRelative, FILETIME ft, OLECHAR** pszA, ULONG bufferSize) {
    SYSTEMTIME      st;
    HRESULT         hr = S_OK;
    BOOL            bWasAllocated = FALSE;
    LONGLONG        llIn = WsbFTtoLL(ft);

    WsbTraceIn(OLESTR("WsbFTtoWCS"), OLESTR("isRelative = %ls, ft = %I64x"),
            WsbQuickString(WsbBoolAsString(isRelative)), ft);

    // If this is a relative time, then FT is just ticks.
    if (isRelative) {
        LONGLONG    llTicks=0;
        UINT        uId=0;

        // Try to find a scale that works (i.e. the largest one with
        // no remainder.
        if (llIn  == 0) {
            llTicks = 0;
            uId = IDS_WSB_FT_TYPE_SECOND;
        } 

        else if ((llIn % WSB_FT_TICKS_PER_YEAR) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_YEAR;
            uId = IDS_WSB_FT_TYPE_YEAR;
        }

        else if ((llIn % WSB_FT_TICKS_PER_MONTH) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_MONTH;
            uId = IDS_WSB_FT_TYPE_MONTH;
        }

        else if ((llIn % WSB_FT_TICKS_PER_DAY) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_DAY;
            uId = IDS_WSB_FT_TYPE_DAY;
        }

        else if ((llIn % WSB_FT_TICKS_PER_HOUR) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_HOUR;
            uId = IDS_WSB_FT_TYPE_HOUR;
        }

        else if ((llIn % WSB_FT_TICKS_PER_MINUTE) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_MINUTE;
            uId = IDS_WSB_FT_TYPE_MINUTE;
        }

        else if ((llIn % WSB_FT_TICKS_PER_SECOND) == 0) {
            llTicks = llIn / WSB_FT_TICKS_PER_SECOND;
            uId = IDS_WSB_FT_TYPE_SECOND;
        }

        else {
            hr = E_INVALIDARG;
        }

        // If we found a scale, then form the proper string.
        if (SUCCEEDED(hr)) {
            OLECHAR*    szTmp1 = NULL;
            OLECHAR*    szTmp2 = NULL;

            // Get the string corresponding to the time period selected.
            hr = WsbLoadComString(_Module.m_hInst, uId, &szTmp1, 0);

            if (SUCCEEDED(hr)) {
                hr = WsbLLtoWCS(llTicks, &szTmp2, 0);

                if (SUCCEEDED(hr)) {
                    hr = WsbGetComBuffer(pszA, bufferSize, (wcslen(szTmp1) + wcslen(szTmp2) + 2) * sizeof(OLECHAR), NULL);
            
                    if (SUCCEEDED(hr)) {
                        swprintf( *pszA, OLESTR("%ls %ls"), szTmp2, szTmp1);
                    }

                    WsbFree(szTmp2);
                }

                WsbFree(szTmp1);
            }
        }
    }

    // Otherwise it is absolute and converts to a specific date and time.
    else {
    
        // Convert the filetime to a system time.
        if (!FileTimeToSystemTime(&ft, &st)) {
            hr = E_FAIL;
        }

        else {

            // Get a buffer for the time string.
            hr = WsbGetComBuffer(pszA, bufferSize, WSB_FT_TO_WCS_ABS_STRLEN * sizeof(OLECHAR), &bWasAllocated);

            if (SUCCEEDED(hr)) {
                // Print the time in the buffer according to the standard
                // format mm/dd/yy @ hh:mm:ss.
                swprintf( *pszA, OLESTR("%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d"), st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
            }
        }
    }

    WsbTraceOut(OLESTR("WsbFTtoWCS"), OLESTR("pszA = %ls"), *pszA);

    return(hr);
}


HRESULT WsbLLtoWCS(LONGLONG ll, OLECHAR** pszA, ULONG bufferSize) {
    OLECHAR     szTmp[80];
    HRESULT     hr = S_OK;
    int         i = 0;
    LONGLONG    value = ll;
    BOOL        bIsNegative = FALSE;

    // First check to see if ll is negative
    if (value < 0) {
        bIsNegative = TRUE;
        value *= -1;
    }

    // This builds the string in reverse, but we'll change the order
    // again we we copy it to a buffer.
    do {
        szTmp[i++] = (OLECHAR) ('0' + (value % 10));
        value /= 10;
    } while (value > 0);
    
    // Add the negative symbol is negative just before terminating NULL
    if (bIsNegative) {
        szTmp[i] = OLECHAR('-');
        i++;
    }

    // Add a terminating NULL
    szTmp[i] = OLECHAR( '\0' );

    // Now vopy the string into the target buffer.
    hr = WsbAllocAndCopyComString2(pszA, szTmp, bufferSize, FALSE);

    return(hr);
}


HRESULT WsbWCStoFT(OLECHAR* szA, BOOL* pisRelative, FILETIME* pft) {
    HRESULT     hr = S_OK;
    OLECHAR*    szEnd;

    // Is this an absolute time (i.e. a date and time) or a relative
    // time (e.g. 6 days, ...). This is determined by seeing a / in the
    // string, which should only be present in absolute times.  (Input
    // format expected for an absolute time is either "mm/dd/yyyy hh:mm:ss"
    // or "mm/dd/yyyy".  If no time is input for an absolute time (i.e.,
    // the "mm/dd/yyyy" format), then the current local time will be
    // filled in for the user.
    // Note that no millisecond info is to be included, since we supply
    // a 'ticks' field as a separate parameter whenever we work at the 
    // millisecond/fraction of millisecond level.)
    szEnd = wcschr(szA, '/');

    // Is it a relative time (i.e. no '/')?
    if (szEnd == NULL) {
        LONGLONG    llValue;

        *pisRelative = TRUE;

        // The first token should be a number, so convert the string to
        // a number.
        llValue = wcstoul(szA, &szEnd, 10);

        if (errno == ERANGE) {
            hr = E_INVALIDARG;
        }

        else {
            UINT        uId;

            // The second token should be a type (i.e. second, hour, minute, ...).
            hr = WsbMatchComString(szEnd, IDS_WSB_FT_TYPE_YEAR, WSB_FT_TYPES_MAX, &uId);
            if (S_OK == hr) {

                switch (uId) {
                case IDS_WSB_FT_TYPE_YEAR:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_YEAR);
                    break;

                case IDS_WSB_FT_TYPE_MONTH:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_MONTH);
                    break;

                case IDS_WSB_FT_TYPE_WEEK:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_WEEK);
                    break;

                case IDS_WSB_FT_TYPE_DAY:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_DAY);
                    break;

                case IDS_WSB_FT_TYPE_HOUR:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_HOUR);
                    break;

                case IDS_WSB_FT_TYPE_MINUTE:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_MINUTE);
                    break;

                case IDS_WSB_FT_TYPE_SECOND:
                    *pft = WsbLLtoFT(llValue * WSB_FT_TICKS_PER_SECOND);
                    break;

                default:
                    hr = E_INVALIDARG;
                    break;
                }
            }
        }
    }

    // It is an absolute time.
    else {
        SYSTEMTIME      st;
        BOOL            timeWasInput = TRUE;
        OLECHAR*    szSearchString;
    
        // The first number should represent the month.
        st.wMonth = (USHORT) wcstoul(szA, &szEnd, 10);
        // test resultant month within range, and that the format of the input
        // absolute date/time is valid (i.e., the character which stopped the
        // above conversion is the slash between the month and day digits)
        if ((st.wMonth < 1) || (st.wMonth > 12) || (*szEnd != ((OLECHAR) '/'))) {
            hr = E_INVALIDARG;
        }

        // The next number should represent the day.
        if (SUCCEEDED(hr)) {
            // set szSearchString to 1 character beyond the character that
            // stopped the above 'wcstoul' conversion
            szSearchString = szEnd + 1;
            st.wDay = (USHORT) wcstoul(szSearchString, &szEnd, 10);
            if ((st.wDay < 1) || (st.wDay > 31) || (*szEnd != ((OLECHAR) '/'))) {
                hr = E_INVALIDARG;
            }
        }

        // The next number should represent the year.
        if (SUCCEEDED(hr)) {
            szSearchString = szEnd + 1;
            st.wYear = (USHORT) wcstoul(szSearchString, &szEnd, 10);
            // test resultant year equal to at least 1601, since NT records
            // time and date starting from 12:00am, January 1, 1601.  This
            // test also is used to enforce that a 4 digit year was entered.
            if ((st.wYear < 1601) || (*szEnd != ((OLECHAR) ' '))) {
                if (( st.wYear >= 1601 ) && ( szEnd[0] == 0 )) {
                    SYSTEMTIME  now;
                    GetLocalTime ( &now );
                    st.wHour = now.wHour;
                    st.wMinute = now.wMinute;
                    st.wSecond = now.wSecond;
                    timeWasInput = FALSE;
                }
                else {
                    hr = E_INVALIDARG;
                }
            }
        }

        // The next number should represent the hour.
        if ( timeWasInput ) {
            if (SUCCEEDED(hr)) {
                szSearchString = szEnd + 1;
                st.wHour = (USHORT) wcstoul(szSearchString, &szEnd, 10);
                if ((st.wHour > 23) || (*szEnd != ((OLECHAR) ':'))) {
                    hr = E_INVALIDARG;
                }
            }
        }

        // The next number should represent the minutes.
        if ( timeWasInput ) {
            if (SUCCEEDED(hr)) {
                szSearchString = szEnd + 1;
                st.wMinute = (USHORT) wcstoul(szSearchString, &szEnd, 10);
                if ((st.wMinute > 59) || (*szEnd != ((OLECHAR) ':'))) {
                    hr = E_INVALIDARG;
                }
            }
        }

        // The next number should represent the seconds.
        if ( timeWasInput ) {
            if (SUCCEEDED(hr)) {
                szSearchString = szEnd + 1;
                st.wSecond = (USHORT) wcstoul(szSearchString, &szEnd, 10);
                if ((st.wSecond > 59) || (szEnd[0] != 0)) {
                    hr = E_INVALIDARG;
                }
            }
        }

        // NOTE: Although the SYSTEMTIME structure contains a milliseconds field, 
        // it can only express milliseconds as whole numbers, so this function
        // does not support any way to specify the number of milliseconds.  If
        // millisecond/fraction of milliseconds are necessary, after this function 
        // returns add in the NT-supported 'number of 100 nanosecond 'ticks'' to 
        // the FILETIME result output by this function.  The number of 
        // ticks is used to represent both milliseconds and fractions thereof.

        // initialize the millisecond field before converting SystemTime to FileTime
        st.wMilliseconds = 0;

        
        // If we properly converted the string, then convert the
        // system time into a file time.
        if (SUCCEEDED(hr)) {
            if ( SystemTimeToFileTime(&st, pft) == FALSE) {
                hr = E_FAIL;
            }
        }
    }

    return(hr);
}



HRESULT WsbWCStoLL(OLECHAR* szA, LONGLONG* pll) {
    HRESULT     hr = S_OK;
    LONGLONG    llFactor = 1;
    size_t      ulLength = wcslen(szA);

    // It is an error not to have any digits.
    if (ulLength == 0) {
        hr = E_INVALIDARG;
    }

    else {
        int     i;
    
        // Step through character by character.
        for (i = ulLength, *pll = 0; ((i > 0) && (SUCCEEDED(hr))); i--) {
            if (iswalpha(szA[i-1])) {
                (*pll) += llFactor * ((LONGLONG) (szA[i-1] - ((OLECHAR) '0')));
                llFactor *= 10;
            }
            else {
                hr = E_INVALIDARG;
            }
        }
    }

    return(hr);
}

HRESULT WsbDatetoFT(DATE date, LONG ticks, FILETIME* pFt)
{
    HRESULT         hr = S_OK;
    SYSTEMTIME      st;

    try {

        WsbAssert(0 != pFt, E_POINTER);

        // Do the basic date conversion
        WsbAffirmHr(VariantTimeToSystemTime(date, &st));
        WsbAffirmStatus(SystemTimeToFileTime(&st, pFt));

        // Variant DATE field only tracks time and date down to seconds.
        // FILETIMEs are kept using a 64 bit value specifying the number
        // of 100-nanosecond intervals that have elapsed since 12:00am
        // January 1, 1601.  Since our 'ticks' value represents milliseconds
        // and fractions of milliseconds using the same 100-nanosecond interval 
        // units, to add in milliseconds add in the ticks.  But since FILETIME 
        // is actually a structure of 2 DWORDs, we must use some conversions.

        LONGLONG FTasLL;
        FTasLL = WsbFTtoLL ( *pFt );

        FTasLL += (LONGLONG) ticks;

        *pFt = WsbLLtoFT ( FTasLL );

    } WsbCatch(hr);
 
    return(hr);
}

HRESULT WsbFTtoDate(FILETIME ft, DATE* pDate, LONG* pTicks)
{
    HRESULT         hr = S_OK;
    SYSTEMTIME      st;
    FILETIME        ft2;

    try {
        
        WsbAssert(0 != pDate, E_POINTER);
        WsbAssert(0 != pTicks, E_POINTER);

        // Do the basic time conversion.
        WsbAffirmStatus(FileTimeToSystemTime(&ft, &st));
        WsbAffirmStatus(SystemTimeToVariantTime(&st, pDate));

        // Now convert back what we have and figure out how many ticks got lost.
        WsbAffirmHr(WsbDatetoFT(*pDate, 0, &ft2));
        *pTicks = (LONG) (WsbFTtoLL(ft) - WsbFTtoLL(ft2));

    } WsbCatch(hr)

    return(hr);
}


HRESULT WsbLocalDateTicktoUTCFT(DATE date, LONG ticks, FILETIME* pFT)
{
    // This routine converts a VARIANT DATE field (expressed in local time)
    // and a 'number of 100 nanosecond intervals' ticks field to a FILETIME
    // in UTC format.  This is the format that file timestamps are kept in.
    // The result of this call is suitable for use in setting a file's timestamp.

    HRESULT         hr = S_OK;
    FILETIME        localFTHolder;

    try {

        WsbAssert(0 != pFT, E_POINTER);

        // Do the basic date conversion which yields a FILETIME in local time
        WsbAffirmHr(WsbDatetoFT(date, ticks, &localFTHolder));

        // Now convert the local time to UTC format FILETIME
        WsbAffirmStatus(LocalFileTimeToFileTime(&localFTHolder, pFT));

    } WsbCatch(hr);
 
    return(hr);
}


HRESULT WsbUTCFTtoLocalDateTick(FILETIME ft, DATE* pDate, LONG* pTicks)
{
    // This routine converts a FILETIME field (expressed in UTC format - which 
    // is the format file timestamps are stored in) to a VARIANT DATE field
    // (expressed in local time) and a Ticks field.  The Ticks field represents
    // a 'number of 100 nanosecond intervals' which represents the 'milliseconds
    // and fractions of a millisecond' that was contained in the UTC formatted
    // FILETIME.

    HRESULT         hr = S_OK;
    FILETIME        localFT;

    try {
        
        WsbAssert(0 != pDate, E_POINTER);
        WsbAssert(0 != pTicks, E_POINTER);

        // First convert the UTC format FILETIME to one in Local Time
        WsbAffirmStatus(FileTimeToLocalFileTime(&ft, &localFT));
        
        // Do the basic time conversion.
        WsbAffirmHr(WsbFTtoDate(localFT, pDate, pTicks));

    } WsbCatch(hr)

    return(hr);
}


HRESULT WsbDateToString(DATE date, OLECHAR** string) {
    
    // NOTE: the caller owns the memory occupied by 'string' when this
    // helper function returns.  Since 'string''s buffer is allocated
    // by WsbAlloc/Realloc(), memory needs to be freed via
    // WsbFree()
    
    HRESULT     hr = S_OK;
    SYSTEMTIME  systime;
    BOOL        wasBufferAllocated;

    try {
        // convert the VARIANT Date to a system time
        WsbAffirmHr ( VariantTimeToSystemTime ( date, &systime ) );

        // create a COM buffer (meaning it was allocated with 
        // WsbAlloc/Realloc()) to hold the date/time string which this method 
        // will return.  The buffer, passed back as 'string', will need to be freed 
        // with WsbFree() by the caller.  Note that passing a 'requested size' 
        // (2nd arg) of zero forces a realloc of the 'string' buffer.
        WsbAffirmHr ( WsbGetComBuffer ( string, 0, 
                        (WSB_VDATE_TO_WCS_ABS_STRLEN * sizeof (OLECHAR)),
                        &wasBufferAllocated ) );

        // load the buffer with the date and time using the standard
        // format:  mm/dd/yyyy hh:mm:ss.  Note that milliseconds are 
        // not represented since a VARIANT Date field can only track 
        // time to second granularity.
        swprintf ( *string, L"%2.2d/%2.2d/%2.4d %2.2d:%2.2d:%2.2d",
                    systime.wMonth, systime.wDay, systime.wYear,
                    systime.wHour, systime.wMinute, systime.wSecond );

    } WsbCatch ( hr )

    return ( hr );
}


HRESULT WsbStringToDate(OLECHAR* string, DATE* date) 
{
    HRESULT     conversionHR = S_OK;
    BOOL        isRelative;
    FILETIME    holdFT;
    SYSTEMTIME  holdST;

    try {
        // convert input wide char string to a FILETIME.  Throw hr as
        // exception if not successful.
        WsbAffirmHr ( WsbWCStoFT ( string, &isRelative, &holdFT ) );

        // convert FILETIME result from above to SYSTEMTIME.  If this 
        // Boolean call fails, get Last Error, convert to hr and throw it.
        WsbAffirmStatus ( FileTimeToSystemTime ( &holdFT, &holdST ) );

        // finally, convert SYSTEMTIME result from above to VARIANT Date
        WsbAffirmHr ( SystemTimeToVariantTime ( &holdST, date ) );

    } WsbCatch ( conversionHR )

    return ( conversionHR );
}


// Filetime Manipulations
FILETIME WsbFtSubFt(FILETIME ft1, FILETIME ft2)
{
    return(WsbLLtoFT(WsbFTtoLL(ft1) - WsbFTtoLL(ft2)));
}

SHORT WsbCompareFileTimes(FILETIME ft1, FILETIME ft2, BOOL isRelative, BOOL isNewer)
{
    SHORT       result = 0;
    LONGLONG    ll1;
    LONGLONG    ll2;
    LONGLONG    tmp;
    FILETIME    ftNow;
    LONGLONG    llNow;

    WsbTraceIn(OLESTR("WsbCompareFileTimes"), OLESTR("ft1 = %ls, ft2 = %ls, isRelative = %ls, isNewer = %ls"),
            WsbQuickString(WsbFiletimeAsString(FALSE, ft1)),
            WsbQuickString(WsbFiletimeAsString(isRelative, ft2)),
            WsbQuickString(WsbBoolAsString(isRelative)), WsbQuickString(WsbBoolAsString(isRelative)));

    ll1 = WsbFTtoLL(ft1);
    ll2 = WsbFTtoLL(ft2);

    if (isRelative) {
        
        GetSystemTimeAsFileTime(&ftNow);
        WsbTrace(OLESTR("WsbCompareFileTimes: ftNow = %ls\n"),
                WsbFiletimeAsString(FALSE, ftNow));
        llNow = WsbFTtoLL(ftNow);

        if (isNewer) {
            tmp = ll1 - llNow;
        } else {
            tmp = llNow - ll1;
        }

        if (tmp > ll2) {
            result = 1;
        } if (tmp < ll2) {
            result = -1;
        }
    }
    
    else {

        if (ll1 > ll2) {
            result = 1;
        } if (ll1 < ll2) {
            result = -1;
        }

        if (!isNewer) {
            result *= -1;
        }
    }

    WsbTraceOut(OLESTR("WsbCompareFileTimes"), OLESTR("result = %hd"), result);
    return(result);
}

// GUID Manipulations
int WsbCompareGuid(REFGUID guid1, REFGUID guid2)
{
    return(memcmp(&guid1, &guid2, sizeof(GUID)));
}

HRESULT WsbStringFromGuid(REFGUID rguid, OLECHAR* sz)
{
    int returnCount = StringFromGUID2(rguid, sz, WSB_GUID_STRING_SIZE);

    return ( ( returnCount > 0) ? S_OK : E_FAIL );
}

HRESULT WsbGuidFromString(const OLECHAR* sz, GUID * pguid)
{
    return CLSIDFromString((OLECHAR*)sz, pguid);
}

HRESULT WsbGetServiceId(OLECHAR* serviceName, GUID* pGuid )
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       outString;
    CWsbStringPtr       tmpString;

    try {

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));

        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(outString.Alloc(256));

        // if the SettingId value is there then we tell caller there is none 
        // clean up the registry ?????
        if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("SettingId"), outString, 256, &sizeGot) == S_OK) {
            // if the Id is there remove it first
            if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) == S_OK) {
                WsbAffirmHr( WsbRemoveRegistryValue(NULL, tmpString, OLESTR("Id") ) );
            }
            // Remove the SettingId value last
            WsbAffirmHr( WsbRemoveRegistryValue(NULL, tmpString, OLESTR("SettingId") ) );
            *pGuid = GUID_NULL ;
            WsbThrow( WSB_E_NOTFOUND );

        // if it is not there we return GUID_NULL
        } else if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) != S_OK) {
            *pGuid = GUID_NULL ;
            WsbThrow( WSB_E_NOTFOUND );

        // verify that the Id value is really there
        } else {
            WsbAffirmHr(IIDFromString(outString, (IID *)pGuid));
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT WsbSetServiceId(OLECHAR* serviceName, GUID guid )
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       outString;
    CWsbStringPtr       tmpString;

    try {

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));

        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(outString.Alloc(256));

        // If the Id string is not there then set it
        if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) != S_OK) {
            // if there is a SettingId then we have something wrong in here so throw an error
            if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("SettingId"), outString, 256, &sizeGot) == S_OK) {
                WsbThrow( WSB_E_INVALID_DATA );
            }
            WsbAffirmHr( WsbSetRegistryValueString(NULL, tmpString, OLESTR("Id"), WsbGuidAsString(guid) ) );
        } else {
            // ID already exists so set it and blast the SettingId 
            WsbAffirmHr( WsbSetRegistryValueString(NULL, tmpString, OLESTR("SettingId"), WsbGuidAsString(guid)));
            WsbAffirmHr( WsbSetRegistryValueString(NULL, tmpString, OLESTR("Id"), WsbGuidAsString(guid)));
            WsbAffirmHr( WsbRemoveRegistryValue(NULL, tmpString, OLESTR("SettingId") ) );
        }

    } WsbCatch(hr);

    return(hr);
}
HRESULT WsbCreateServiceId(OLECHAR* serviceName, GUID* pGuid )
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       outString;
    CWsbStringPtr       tmpString;

    try {

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));

        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(outString.Alloc(256));

        if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) != S_OK) {
            WsbAffirmHr(CoCreateGuid(pGuid));
            WsbAffirmHr(WsbSetRegistryValueString(NULL, tmpString, OLESTR("SettingId"), WsbGuidAsString(*pGuid)));
            WsbAffirmHr(WsbSetRegistryValueString(NULL, tmpString, OLESTR("Id"), WsbGuidAsString(*pGuid)));
        } else {
            WsbThrow( WSB_E_INVALID_DATA );
        }

    } WsbCatch(hr);

    return(hr);
}
HRESULT WsbConfirmServiceId(OLECHAR* serviceName, GUID guidConfirm )
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       outString;
    CWsbStringPtr       tmpString;
    GUID                guid;

    try {

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));

        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(outString.Alloc(256));

        // verify that the Id value is really there
        WsbAffirmHr( WsbGetRegistryValueString(NULL, tmpString, OLESTR("Id"), outString, 256, &sizeGot) ) ;
        WsbAffirmHr( IIDFromString( outString, (IID *)&guid ) );
        WsbAffirm( guid == guidConfirm, WSB_E_INVALID_DATA );

        // verify that the SettingId value is really there and the same
        WsbAffirmHr( WsbGetRegistryValueString( NULL, tmpString, OLESTR("SettingId"), outString, 256, &sizeGot ) ) ;
        WsbAffirmHr( IIDFromString( outString, (IID *)&guid ) );
        WsbAffirm( guid == guidConfirm, WSB_E_INVALID_DATA );

        // remove the flag value
        WsbAffirmHr( WsbRemoveRegistryValue(NULL, tmpString, OLESTR("SettingId") ) );

    } WsbCatch(hr);

    return(hr);
}


HRESULT WsbGetMetaDataPath(OUT CWsbStringPtr & Path)
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    
    try {

        // Find out where they have NT installed, and make sure that our subdirectory exists.
        WsbAffirmHr(Path.Alloc(256));
        //
        // Use the relocatable meta-data path if it's available,
        // otherwise default to the %SystemRoot%\System32\RemoteStorage
        //
        hr = WsbCheckIfRegistryKeyExists(NULL, WSB_CONTROL_REGISTRY_KEY);
        if (hr == S_OK) {
            WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CONTROL_REGISTRY_KEY, WSB_METADATA_REGISTRY_VALUE, Path, 256, &sizeGot));

        } else {
            WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY));
            WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY, WSB_SYSTEM_ROOT_REGISTRY_VALUE, Path, 256, &sizeGot));
            WsbAffirmHr(Path.Append(OLESTR("\\system32\\RemoteStorage")));
        }
    } WsbCatchAndDo(hr,
                    Path.Free();
                   );

    return(hr);
}


HRESULT WsbGetServiceTraceDefaults(OLECHAR* serviceName, OLECHAR* traceFile, IUnknown* pUnk)
{
    HRESULT             hr = S_OK;
    DWORD               sizeGot;
    CWsbStringPtr       pathString;
    CWsbStringPtr       outString;
    CWsbStringPtr       rsPath;
    CWsbStringPtr       tmpString;
    CComPtr<IWsbTrace>  pTrace;
    OLECHAR*            lastSlash;
    
    try {

        WsbAssertPointer(serviceName);

        WsbAffirmHr(WsbGetMetaDataPath(rsPath));

        // NOTE: Might want to check for errors, and ignore the directory already existing. Since I don't know
        // what the error is, so we'll ignore this for now.
        tmpString = rsPath;
        WsbAffirmHr(tmpString.Prepend(OLESTR("\\\\?\\")));
        CreateDirectory(tmpString, 0);

        // Look in the registry to see if this service has already created itself and has
        // a GUID registered.
        tmpString = OLESTR("SYSTEM\\CurrentControlSet\\Services\\");
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));
        WsbAffirmHr(tmpString.Append(serviceName));
        WsbAffirmHr(tmpString.Append(OLESTR("\\Parameters")));
        WsbAffirmHr(WsbEnsureRegistryKeyExists(NULL, tmpString));

        WsbAffirmHr(outString.Alloc(256));

        // We also want to put the path where the trce file should go.
        if (WsbGetRegistryValueString(NULL, tmpString, OLESTR("WsbTraceFileName"), outString, 256, &sizeGot) != S_OK) {
            outString = rsPath;
            WsbAffirmHr(outString.Append(OLESTR("\\Trace\\")));
            WsbAffirmHr(outString.Append(traceFile));
            WsbAffirmHr(WsbSetRegistryValueString(NULL, tmpString, OLESTR("WsbTraceFileName"), outString));
        }

        // Try a little to make sure the trace directory exists.
        lastSlash = wcsrchr(outString, L'\\');
        if ((0 != lastSlash) && (lastSlash != outString)) {
            *lastSlash = 0;
            CreateDirectory(outString, 0);
        }

        // Turn tracing on, if requested.
        if (0 != pUnk) {
            WsbAffirmHr(pUnk->QueryInterface(IID_IWsbTrace, (void**) &pTrace));
            WsbAffirmHr(pTrace->SetRegistryEntry(tmpString));
            WsbAffirmHr(pTrace->LoadFromRegistry());
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT
WsbRegisterEventLogSource(
    IN  const WCHAR * LogName,
    IN  const WCHAR * SourceName,
    IN  DWORD         CategoryCount,
    IN  const WCHAR * CategoryMsgFile OPTIONAL,
    IN  const WCHAR * MsgFiles
    )

/*++

Routine Description:

    Registers the given event source in the event log.
    
    We have to do the event log registration outside the rgs
    files since event log viewer insists on REG_EXPAND_SZ type
    values (which cannot be done via rgs).

Arguments:

    None.

Return Value:

    S_OK - Service Registered and everything is set

--*/

{

    CWsbStringPtr rpPath;
    HRESULT hr = S_OK;

    try {

        CWsbStringPtr   regPath;
        DWORD types = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;

        //
        // Everything goes into HKLM\SYSTEM\CurrentControlSet\Services\EventLog\<LogName>\<SourceName>
        //
        regPath.Printf(  OLESTR("%ls\\%ls\\%ls"), WSB_LOG_BASE, LogName, SourceName );
        WsbAffirmHr( WsbEnsureRegistryKeyExists( 0, regPath ) );


        //
        // See if we have Categories within this source. Register if so
        //
        if( CategoryCount ) {

            WsbAffirmHr( WsbSetRegistryValueDWORD(  0, regPath, WSB_LOG_CAT_COUNT, CategoryCount ) );
            WsbAffirmHr( WsbSetRegistryValueString( 0, regPath, WSB_LOG_CAT_FILE,  CategoryMsgFile, REG_EXPAND_SZ ) );

        }

        //
        // Register the message source and types of events
        //
        WsbAffirmHr( WsbSetRegistryValueString( 0, regPath, WSB_LOG_MESSAGE_FILE, MsgFiles, REG_EXPAND_SZ ) );
        WsbAffirmHr( WsbSetRegistryValueDWORD(  0, regPath, WSB_LOG_TYPES,        types ) );

    } WsbCatch( hr );

    return ( hr );
}

HRESULT
WsbUnregisterEventLogSource(
    IN  const WCHAR * LogName,
    IN  const WCHAR * SourceName
    )

/*++

Routine Description:

    Registers the given event source in the event log.

Arguments:

    None.

Return Value:

    S_OK - Service Registered and everything is set

--*/

{

    CWsbStringPtr rpPath;
    HRESULT hr = S_OK;

    try {

        CWsbStringPtr   regPath;

        //
        // Everything goes into HKLM\SYSTEM\CurrentControlSet\Services\EventLog\<LogName>\<SourceName>
        //
        regPath.Printf(  OLESTR("%ls\\%ls\\%ls"), WSB_LOG_BASE, LogName, SourceName );

        //
        // Some of these may not exist, so don't check return value
        //
        WsbRemoveRegistryValue( 0, regPath, WSB_LOG_CAT_COUNT );
        WsbRemoveRegistryValue( 0, regPath, WSB_LOG_CAT_FILE );
        WsbRemoveRegistryValue( 0, regPath, WSB_LOG_MESSAGE_FILE );
        WsbRemoveRegistryValue( 0, regPath, WSB_LOG_TYPES );

        regPath.Printf(  OLESTR("%ls\\%ls"), WSB_LOG_BASE, LogName );
        WsbAffirmHr( WsbRemoveRegistryKey( 0, regPath, SourceName ) );

    } WsbCatch( hr );

    return ( hr );
}

HRESULT
WsbRegisterRsFilter (
    BOOL bDisplay
    )

/*++

Routine Description:

    Registers the RsFilter for use by the system.
    We assume that the filter is already in the system32\driver directory.

Arguments:

    None.

Return Value:

    S_OK - Service Registered and everything is set

    ERROR_SERVICE_EXISTS - service already exists

    ERROR_DUP_NAME - The display name already exists in teh SCM as a service name or a display name
--*/

{

    CWsbStringPtr rpPath;
    CWsbStringPtr rpDescription;
    SC_HANDLE hService;
    SC_HANDLE hSCM = NULL;
    HRESULT hr = S_OK;
    DWORD rpTag = 0;

    try {
        rpPath.Printf( OLESTR("%%SystemRoot%%\\System32\\drivers\\%ls%ls"), TEXT(RSFILTER_APPNAME), TEXT(RSFILTER_EXTENSION) );

        //
        // First make sure not already installed
        //
        hSCM = OpenSCManager( 0, 0, GENERIC_READ | GENERIC_WRITE );
        WsbAffirmPointer( hSCM );


        //
        // and install it
        //
            
        hService = CreateService(
                        hSCM,                       // SCManager database
                        TEXT(RSFILTER_SERVICENAME), // Service name
                        TEXT(RSFILTER_DISPLAYNAME), // Display name
                        SERVICE_ALL_ACCESS,         // desired access
                        SERVICE_FILE_SYSTEM_DRIVER, // service type
                        SERVICE_BOOT_START,         // start type
                        SERVICE_ERROR_NORMAL,       // error control type
                        rpPath,                     // Executable location 
                        TEXT(RSFILTER_GROUP),       // group
                        &rpTag,                     // Set tag to zero so we are loaded first in the filter group.
                        TEXT(RSFILTER_DEPENDENCIES),
                        NULL,
                        NULL);
            
        WsbAffirmStatus( 0 != hService );


        rpDescription.LoadFromRsc(_Module.m_hInst, IDS_WSBSVC_DESC );
        SERVICE_DESCRIPTION svcDesc;
        svcDesc.lpDescription = rpDescription;
        ChangeServiceConfig2( hService, SERVICE_CONFIG_DESCRIPTION, &svcDesc );

        CloseServiceHandle( hService );

        //
        // Add event logging entries
        //
        WsbAffirmHr( WsbRegisterEventLogSource(
            WSB_LOG_SYS, WSB_LOG_FILTER_NAME, 0, 0, TEXT(RSFILTER_FULLPATH) ) );

        //
        // Make sure params Key exists
        //
        CWsbStringPtr regPath;
        regPath.Printf( OLESTR("%ls\\%ls\\Parameters"), WSB_SVC_BASE, TEXT(RSFILTER_SERVICENAME) );
        WsbAffirmHr( WsbEnsureRegistryKeyExists( 0, regPath ) );
        

    } WsbCatchAndDo( hr,

            // If the caller wants error messages then give a message
            if ( bDisplay ) MessageBox(NULL, WsbHrAsString( hr ), WSB_FACILITY_PLATFORM_NAME, MB_OK);

        );

    if( hSCM ) {

        CloseServiceHandle( hSCM );
        hSCM = NULL;

    }

    return ( hr );
}

HRESULT
WsbUnregisterRsFilter (
    BOOL bDisplay
    )

/*++

Routine Description:

    Registers the RsFilter for use by the system.

Arguments:

    None.

Return Value:

    S_OK - Service Registered and everything is set

    ERROR_SERVICE_EXISTS - service already exists

    ERROR_DUP_NAME - The display name already exists in teh SCM as a service name or a display name
--*/

{
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    HRESULT   hr = S_OK;

    try {
        //
        // First connect with the Service Control Manager
        //
        hSCM = OpenSCManager( 0, 0, GENERIC_READ | GENERIC_WRITE );
        WsbAffirmPointer( hSCM );

        //
        // Open the service
        //
        hService = OpenService( hSCM, TEXT(RSFILTER_SERVICENAME), SERVICE_ALL_ACCESS );
        //
        // if the handle is NULL then there is a problem and need to call GetLastError to get error code
        //
        WsbAffirmStatus( 0 != hService );

        //
        // Delete the service - if it does not work then return the error
        //
        WsbAffirmStatus( DeleteService( hService ) );

        //
        // Remove the registry values
        //
        WsbAffirmHr( WsbUnregisterEventLogSource( WSB_LOG_SYS, WSB_LOG_FILTER_NAME ) );
        
    } WsbCatchAndDo( hr, 
            // If the caller wants error messages then give a message
            if ( bDisplay ) MessageBox(NULL, WsbHrAsString( hr ), WSB_FACILITY_PLATFORM_NAME, MB_OK);
        );

    if ( hService ){
        CloseServiceHandle( hService );
        hService = NULL;
    }
        
    if( hSCM ) {
        CloseServiceHandle( hSCM );
        hSCM = NULL;
    }

    return ( hr );
}

STDAPI
DllRegisterRsFilter (
    void
    )
{
    return( WsbRegisterRsFilter( FALSE ) ) ;
}

STDAPI
DllUnregisterRsFilter (
    void
    )
{
    return( WsbUnregisterRsFilter( FALSE ) ) ;
}

HRESULT
WsbCheckAccess(
    WSB_ACCESS_TYPE AccessType
    )
{
    HRESULT hr = S_OK;
    
    PSID   psid = 0;

    try  {

        //
        // Set up the SID to check against
        //
        SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
        switch( AccessType ) {
        
        case WSB_ACCESS_TYPE_ADMINISTRATOR:
            WsbAffirmStatus( 
                AllocateAndInitializeSid( 
                    &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psid ) );
            break;

        case WSB_ACCESS_TYPE_OPERATOR:
            WsbAffirmStatus( 
                AllocateAndInitializeSid( 
                    &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_SYSTEM_OPS, 0, 0, 0, 0, 0, 0, &psid ) );
            break;

        case WSB_ACCESS_TYPE_USER:
            WsbAffirmStatus( 
                AllocateAndInitializeSid( 
                    &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_USERS, 0, 0, 0, 0, 0, 0, &psid ) );
            break;

        case WSB_ACCESS_TYPE_ALL:
            WsbThrow( S_OK );
            break;

        default:
            WsbThrow( E_INVALIDARG );

        }

        //
        // Check for membership
        //
        BOOL pMember = FALSE;
        WsbAffirmStatus( CheckTokenMembership( 0, psid, &pMember ) );

        if( !pMember ) {

            WsbThrow( E_ACCESSDENIED );
   
        }
        
    } WsbCatch( hr );
    
    if( psid )   FreeSid( psid );

    return( hr );
}


HRESULT
CWsbSecurityDescriptor::AllowRid(
    DWORD Rid,
    DWORD dwAccessMask
    )
{
    HRESULT hr = S_OK;
    PSID pSid = 0;
    PACL newACL = 0;

    try {

        //
        // First, create the SID from Rid
        //
        SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
        WsbAffirmStatus( AllocateAndInitializeSid(
               &sia,
               2,
               SECURITY_BUILTIN_DOMAIN_RID,
               Rid,
               0, 0, 0, 0, 0, 0,
               &pSid
               ) );

        //
        // Construct new ACL
        //
        ACL_SIZE_INFORMATION aclSizeInfo;
        int   aclSize;
        PACL  oldACL;

        aclSizeInfo.AclBytesInUse = 0;
        oldACL = m_pDACL;
        if( oldACL ) {

            GetAclInformation( oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation );

        }

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid( pSid ) - sizeof(DWORD);

        WsbAffirmAlloc(  newACL = (PACL)( new BYTE[aclSize] ) );
        WsbAffirmStatus( InitializeAcl( newACL, aclSize, ACL_REVISION ) );
        WsbAffirmHr(     CopyACL( newACL, oldACL ) );

        WsbAffirmStatus( AddAccessAllowedAce( newACL, ACL_REVISION2, dwAccessMask, pSid ) );

        //
        // Swap over to new ACL
        //
        m_pDACL = newACL;
        newACL  = 0;

        if( oldACL ) {

            delete( oldACL );

        }

        //
        // Update the security descriptor
        //
        SetSecurityDescriptorDacl( m_pSD, TRUE, m_pDACL, FALSE );

    } WsbCatch( hr );

    if( pSid )   FreeSid( pSid );
    if( newACL ) delete( newACL );
    return( hr );
}

HRESULT
WsbGetResourceString(
    ULONG id,
    WCHAR **ppString
    )
{
    HRESULT hr = S_OK;
    
    try  {
        WsbAssert(ppString != 0, E_INVALIDARG);

        *ppString = NULL;

        // Let our srting class to do the work...
        CWsbStringPtr loader;
        WsbAffirmHr(loader.LoadFromRsc(_Module.m_hInst, id));

        *ppString = *(&loader);
        *(&loader) = NULL;
        
    } WsbCatch( hr );
    

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbenum.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbenum.h

Abstract:

    These classes provides enumerators (iterators) for the collection classes.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#if !defined WSBENUM_INCL
#define WSBENUM_INCL

class CWsbIndexedEnum : 
    public IEnumUnknown,
    public IWsbEnum,
    public IWsbEnumEx,
    public CComObjectRoot,
    public CComCoClass<CWsbIndexedEnum,&CLSID_CWsbIndexedEnum>
{
public:
    CWsbIndexedEnum() {}
BEGIN_COM_MAP(CWsbIndexedEnum)
    COM_INTERFACE_ENTRY(IWsbEnum)
    COM_INTERFACE_ENTRY(IWsbEnumEx)
    COM_INTERFACE_ENTRY(IEnumUnknown)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbIndexedEnum)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IWsbEnum
public:
    STDMETHOD(First)(REFIID riid, void** ppElement);
    STDMETHOD(Next)(REFIID riid, void** ppElement);
    STDMETHOD(This)(REFIID riid, void** ppElement);
    STDMETHOD(Previous)(REFIID riid, void** ppElement);
    STDMETHOD(Last)(REFIID riid, void** ppElement);
    
    STDMETHOD(FindNext)(IUnknown* pCollectable, REFIID riid, void** ppElement);
    STDMETHOD(Find)(IUnknown* pCollectable, REFIID riid, void** ppElements);
    STDMETHOD(FindPrevious)(IUnknown* pCollectable, REFIID riid, void** ppElement);

    STDMETHOD(SkipToFirst)(void);
    STDMETHOD(SkipNext)(ULONG element);
    STDMETHOD(SkipTo)(ULONG index);
    STDMETHOD(SkipPrevious)(ULONG element);
    STDMETHOD(SkipToLast)(void);

    STDMETHOD(Init)(IWsbCollection* pCollection);
    STDMETHOD(Clone)(IWsbEnum** ppEnum);
    
// IWsbEnumEx
public:
    STDMETHOD(First)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    STDMETHOD(Next)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    STDMETHOD(This)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    STDMETHOD(Previous)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    STDMETHOD(Last)(ULONG element, REFIID riid, void** elements, ULONG* pElementsFetched);
    
    STDMETHOD(FindNext)(IUnknown* pCollectable, ULONG element, REFIID riid, void** elements, ULONG* elementsFetched);
    STDMETHOD(Find)(IUnknown* pCollectable, ULONG element, REFIID riid, void** elements, ULONG* elementsFetched);
    STDMETHOD(FindPrevious)(IUnknown* pCollectable, ULONG element, REFIID riid, void** elements, ULONG* elementsFetched);

    STDMETHOD(Clone)(IWsbEnumEx** ppEnum);
    
// IEnumUnknown
public:
    STDMETHOD(Next)(ULONG element, IUnknown** elements, ULONG* pElementsFetched);
    STDMETHOD(Skip)(ULONG element);
    STDMETHOD(Clone)(IEnumUnknown** ppEnum);

// Shared
public:
    STDMETHOD(Reset)(void);

protected:
    CComPtr<IWsbIndexedCollection>      m_pCollection;
    ULONG                               m_currentIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbfile.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbfile.cpp

Abstract:

    This file implements the common Wsb routines dealing with file operations.

Author:

    Christopher J. Timmes    [ctimmes@avail.com]   23 Jun 1997

Revision History:

    Christopher J. Timmes    [ctimmes@avail.com]   21 July 1997

        - modified function WsbCalcCRCofFile().  Added NT system calls 
          NTQueryInformationFile and NTSetInformationFile so as to preserve the 
          input file's timestamp.  Until this change this function updated the 
          file's Date Last Accessed.

    Christopher J. Timmes    [ctimmes@avail.com]   05 August 1997

        - modified function WsbCalcCRCofFile().  Added doFileRead() function, an 
          extra 'mode' parameter and supporting code to enable WsbCalcCRCofFile() 
          to support 4 different combinations (modes) of file open and read:
          a normal open and sync read, a 'no recall' open and sync read, a 'norecall'
          open and async read, and a 'norecall' open and memory-mapped 'read'.

   Shawn L. Kaczmarek        15 September 1997

      - First set of modifications to 'back out' the file IO wrapper to the CRC
        routine. The tsterror.h is now 'out' as well.

    Shawn L. Kaczmarek          16 Sept 1997

        Moved WsbCalcCRCofFile() and doFileRead() to the item commander class
      in hsmivrfy.cpp ( hsmicmdr.h ). These methods provided the file IO wrappers
      for the CRC method which is retained in here. The CRC look up table is 
      externed with an instantiation in the RsCommon.dll.

    Shawn L. Kaczmarek          17 Sept 1997

        Removed a doFileRead() prototype that remained from prior 'move out' of
      functions.

--*/


#include "stdafx.h"                         // req'd first: common includes
                                            // (including wsb.h, rqd for this)
                                            // (wsb.h includes wsbfile,h, this file's hdr)

// 32-bit CRC table values (256 entries)
unsigned long crc_32_tab[] =
{ /* CRC polynomial 0xedb88320 */
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};



HRESULT
WsbCRCReadFile   (
    IN BYTE* pchCurrent,
    IN OUT ULONG* oldcrc32
    )

/*

Routine Description:

    This routine exists so that any read excpetions triggered by accessing invalid memory
    can be properly caught.
*/ 

{
    HRESULT     hr = S_OK;

    // This call can caused an invalid page to be accessed, so it needs to
    // be done within an exception handling block. It uses different exception handling,
    // so it can not be used in a function with normal try - catch blocks.

    __try {

        // call CRC algorythm, pass in current byte and present CRC value
        CALC_CRC( *pchCurrent, *oldcrc32);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());    \
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbguid.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbguid.h

Abstract:

    This component is an object representations of the GUID standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBGUID_
#define _WSBGUID_


/*++

Class Name:
    
    CWsbGuid

Class Description:

    An object representations of the GUID standard type. It
    is both persistable and collectable.

--*/
class CWsbGuid : 
    public CWsbObject,
    public IWsbGuid,
    public CComCoClass<CWsbGuid,&CLSID_CWsbGuid>
{
public:
    CWsbGuid() {}
BEGIN_COM_MAP(CWsbGuid)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbGuid)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbGuid)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbGuid)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbGuid
public:
    STDMETHOD(CompareToGuid)(GUID value, SHORT* pResult);
    STDMETHOD(CompareToIGuid)(IWsbGuid* pGuid, SHORT* pResult);
    STDMETHOD(GetGuid)(GUID* pValue);
    STDMETHOD(SetGuid)(GUID value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    GUID            m_value;
};

#endif // _WSBGUID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbllong.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbllong.h

Abstract:

    This component is an object representations of the LONGLONG standard type. It
    is both a persistable and collectable.

Author:

    Ron White   [ronw]   21-Jan-97

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBLONGLONG_
#define _WSBLONGLONG_


/*++

Class Name:
    
    CWsbLonglong

Class Description:

    An object representations of the LONGLONG standard type. It
    is both persistable and collectable.

--*/
class CWsbLonglong : 
    public CWsbObject,
    public IWsbLonglong,
    public CComCoClass<CWsbLonglong,&CLSID_CWsbLonglong>
{
public:
    CWsbLonglong() {}
BEGIN_COM_MAP(CWsbLonglong)
    COM_INTERFACE_ENTRY(IWsbLonglong)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbLonglong)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbLonglong)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbLonglong
public:
    STDMETHOD(CompareToLonglong)(LONGLONG value, SHORT* pResult);
    STDMETHOD(CompareToILonglong)(IWsbLonglong* pValue, SHORT* pResult);
    STDMETHOD(GetLonglong)(LONGLONG* pValue);
    STDMETHOD(SetLonglong)(LONGLONG value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    LONGLONG            m_value;
};

#endif // _WSBLONGLONG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbguid.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbguid.cpp

Abstract:

    This component is an object representations of the GUID standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbguid.h"


HRESULT
CWsbGuid::CompareToGuid(
    IN GUID value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbGuid::CompareToGuid

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbGuid::CompareToGuid"), OLESTR("value = <%ls>"), WsbGuidAsString(value));

    // Compare.
    result = WsbSign( memcmp(&m_value, &value, sizeof(GUID)) );

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbGuid::CompareToGuid"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbGuid::CompareToIGuid(
    IN IWsbGuid* pGuid,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbGuid::CompareToIGuid

--*/
{
    HRESULT     hr = E_FAIL;
    GUID        value;

    WsbTraceIn(OLESTR("CWsbGuid::CompareToIGuid"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pGuid, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pGuid->GetGuid(&value));
        hr = CompareToGuid(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::CompareToIGuid"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbGuid::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbGuid*   pGuid;

    WsbTraceIn(OLESTR("CWsbGuid::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbGuid interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbGuid, (void**) &pGuid));

        hr = CompareToIGuid(pGuid, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbGuid::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_value = GUID_NULL;
    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbGuid::GetGuid(
    OUT GUID* pValue
    )

/*++

Implements:

  IWsbGuid::GetGuid

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::GetGuid"), OLESTR(""));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::GetGuid"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(m_value));
    
    return(hr);
}


HRESULT
CWsbGuid::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CWsbGuid;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbGuid::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::GetSizeMax"), OLESTR(""));

    try {
        WsbAssert(0 != pcbSize, E_POINTER);
        
        pcbSize->QuadPart = WsbPersistSizeOf(GUID);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbGuid::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::Load"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(m_value));

    return(hr);
}


HRESULT
CWsbGuid::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbGuid::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbGuid::SetGuid(
    IN GUID value
    )

/*++

Implements:

  IWsbGuid::SetGuid

--*/
{
    WsbTraceIn(OLESTR("CWsbGuid::SetGuid"), OLESTR("value = <%ls>"), WsbGuidAsString(value));

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbGuid::SetGuid"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbGuid::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbGuid>       pGuid1;
    CComPtr<IWsbGuid>       pGuid2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    GUID                    value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbGuid::Test"), OLESTR(""));

    try {

        // Get the pGuid interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbGuid*) this)->QueryInterface(IID_IWsbGuid, (void**) &pGuid1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                WsbAffirmHr(pGuid1->GetGuid(&value));
                WsbAssert(value == CLSID_CWsbGuid, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbGuid, NULL, CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid2->GetGuid(&value));
                    WsbAssert(value == GUID_NULL, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(CLSID_CWsbGuid));
                    WsbAssert(pGuid1->IsEqual(pGuid2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(IID_IWsbGuid));
                    WsbAssert(pGuid1->IsEqual(pGuid2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(CLSID_CWsbGuid));
                    WsbAssert((pGuid1->CompareTo(pGuid2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(CLSID_CWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(IID_IWsbGuid));
                    WsbAssert((pGuid1->CompareTo(pGuid2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->SetGuid(IID_IWsbGuid));
                    WsbAffirmHr(pGuid2->SetGuid(CLSID_CWsbGuid));
                    WsbAssert((pGuid1->CompareTo(pGuid2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef GUID_PERSIST_FILE
// TODO? Open the file and convert to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pGuid1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pGuid2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pGuid2->SetGuid(CLSID_CWsbGuid));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbGuid.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pGuid1->SetGuid(IID_IWsbGuid));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbGuid.tst"), 0));
                        WsbAssert(pGuid1->CompareToGuid(CLSID_CWsbGuid, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbGuid::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbhash.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    Wsbhash.cpp

Abstract:

    Some functions for hashing text strings and creating DB keys from
    file path names.

    NOTE: Since no one needed this code by the time I got it done, it
    hasn't been tested!

Author:

    Ron White   [ronw]   25-Apr-1997

Revision History:

--*/

#include "stdafx.h"

// This pseudorandom permutation table (used by the SimpleHash function below)
// is taken from the article referenced in the comments for that function.
static UCHAR perm_table[] = {
      1,  87,  49,  12, 176, 178, 102, 166, 121, 193,   6,  84, 249, 230,  44, 163,
     14, 197, 213, 181, 161,  85, 218,  80,  64, 239,  24, 226, 236, 142,  38, 200,
    110, 177, 104, 103, 141, 253, 255,  50,  77, 101,  81,  18,  45,  96,  31, 222,
     25, 107, 190,  70,  86, 237, 240,  34,  72, 242,  20, 214, 244, 227, 149, 235,
     97, 234,  57,  22,  60, 250,  82, 175, 208,   5, 127, 199, 111,  62, 135, 248,
    174, 169, 211,  58,  66, 154, 106, 195, 245, 171,  17, 187, 182, 179,   0, 243,
    132,  56, 148,  75, 128, 133, 158, 100, 130, 126,  91,  13, 153, 246, 216, 219,
    119,  68, 223,  78,  83,  88, 201,  99, 122,  11,  92,  32, 136, 114,  52,  10,
    138,  30,  48, 183, 156,  35,  61,  26, 143,  74, 251,  94, 129, 162,  63, 152,
    170,   7, 115, 167, 241, 206,   3, 150,  55,  59, 151, 220,  90,  53,  23, 131,
    125, 173,  15, 238,  79,  95,  89,  16, 105, 137, 225, 224, 217, 160,  37, 123,
    118,  73,   2, 157,  46, 116,   9, 145, 134, 228, 207, 212, 202, 215,  69, 229,
     27, 188,  67, 124, 168, 252,  42,   4,  29, 108,  21, 247,  19, 205,  39, 203,
    233,  40, 186, 147, 198, 192, 155,  33, 164, 191,  98, 204, 165, 180, 117,  76,
    140,  36, 210, 172,  41,  54, 159,   8, 185, 232, 113, 196, 231,  47, 146, 120,
     51,  65,  28, 144, 254, 221,  93, 189, 194, 139, 112,  43,  71, 109, 184, 209
};

//  Local functions
static HRESULT ProgressiveHash(WCHAR* pWstring, ULONG nChars, UCHAR* pKey, 
        ULONG keySize, ULONG* pKeyCount);
static UCHAR SimpleHash(UCHAR* pString, ULONG count);


//  ProgressiveHash - hash a wide-character string into a byte key of a given
//  maximum size.  The string is limited to 32K characters (64K bytes) and the
//  key size must be at least 16. 
//
//  The algorithm starts out merely XORing the two bytes of each character into a
//  single byte in the key.  If it must use the last 15 bytes of the key, it begins
//  using the SimpleHash function to hash progressively larger (doubling) chuncks
//  of the string into a single byte.
//
//  This method is used to try and preserve as much information about short strings
//  as possible; to preserve, to some extent, the sort order of strings; and to
//  compress long strings into a reasonably sized key. It is assumed (perhaps
//  incorrectly) that many of the characters will be ANSI characters an so the
//  XOR of the bytes in the initial part of the string won't lose any information.

static HRESULT ProgressiveHash(WCHAR* pWstring, ULONG nChars, UCHAR* pKey, 
        ULONG keySize, ULONG* pKeyCount)
{
    HRESULT hr = S_OK;

    try {
        ULONG   chunk;           // Current chunk size
        ULONG   headSize;
        ULONG   keyIndex = 0;    // Current index into the key
        UCHAR*  pBytes;          // Byte pointer into the string
        ULONG   remains;         // Bytes remaining in the string

        //  Check arguments
        WsbAffirm(NULL != pWstring, E_POINTER);
        WsbAffirm(NULL != pKey, E_POINTER);
        remains = nChars * 2;
        WsbAffirm(65536 >= remains, E_INVALIDARG);
        WsbAffirm(15 < keySize, E_INVALIDARG);

        //  Do the non-progressive part
        pBytes = (UCHAR*)pWstring;
        headSize = keySize - 15;
        while (remains > 0 && keyIndex < headSize) {
            pKey[keyIndex++] = (UCHAR) ( *pBytes ^ *(pBytes + 1) );
            pBytes += 2;
            remains -= 2;
        }

        //  Do the progressive part
        chunk = 4;
        while (remains > 0) {
            if (chunk > remains) {
                chunk = remains;
            }
            pKey[keyIndex++] = SimpleHash(pBytes, chunk);
            pBytes += chunk;
            remains -= chunk;
            chunk *= 2;
        }

        if (NULL != pKeyCount) {
            *pKeyCount = keyIndex;
        }
    } WsbCatch(hr);

    return(hr);
}


//  SimpleHash - hash a string of bytes into a single byte.
//
//  This algorithm and the permutation table come from the article "Fast Hashing
//  of Variable-Length Text Strings" in the June 1990 (33, 6) issue of Communications
//  of the ACM (CACM).
//  NOTE: For a hash value larger than one byte, the article suggests hashing the
//  original string with this function to get one byte, adding 1 (mod 256) to the
//  first byte of the string and hashing the new string with this function to get
//  the second byte, etc.

static UCHAR SimpleHash(UCHAR* pString, ULONG count)
{
    int h = 0;

    for (ULONG i = 0; i < count; i++) {
        h = perm_table[h ^ pString[i]];
    }
    return((UCHAR)h);
}

//  SquashFilepath - compress a file path name into a (possibly) shorter key.
//
//  This function splits the key into a path part (about 3/4 of the initial
//  bytes of the key) and a file name part (the rest of the key).  For each
//  part it uses the ProgressiveHash function to compress the substring.

//  This function attempts to preserve enough information in the key that keys
//  will be sorted in approximately the same order as the original path names
//  and it is unlikely (though not impossible) that two different paths would
//  result in the same key.  Both of these are dependent on the size of the key.
//  A reasonable size is probably 128 bytes, which gives 96 bytes for the path
//  and 32 bytes for the file name.  A key size of 64 or less will fail because
//  the file name part will be too small for the Progressive Hash function.

HRESULT SquashFilepath(WCHAR* pWstring, UCHAR* pKey, ULONG keySize)
{
    HRESULT hr = S_OK;

    try {
        ULONG  keyIndex;
        ULONG  nChars;
        WCHAR* pFilename;
        ULONG  pathKeySize;

        //  Check arguments
        WsbAffirm(NULL != pWstring, E_POINTER);
        WsbAffirm(NULL != pKey, E_POINTER);
        WsbAffirm(60 < keySize, E_INVALIDARG);

        //  Calculate some initial values
        pFilename = wcsrchr(pWstring, WCHAR('\\'));
        if (NULL == pFilename) {
            nChars = 0;
            pFilename = pWstring;
        } else {
            nChars = (ULONG)(pFilename - pWstring);
            pFilename++;
        }
        pathKeySize = (keySize / 4) * 3;

        //  Compress the path
        if (0 < nChars) {
            WsbAffirmHr(ProgressiveHash(pWstring, nChars, pKey, pathKeySize,
                    &keyIndex));
        } else {
            keyIndex = 0;
        }

        //  Fill the rest of the path part of the key with zeros
        for ( ; keyIndex < pathKeySize; keyIndex++) {
            pKey[keyIndex] = 0;
        }

        //  Compress the file name
        nChars = wcslen(pFilename);
        if (0 < nChars) {
            WsbAffirmHr(ProgressiveHash(pFilename, nChars, &pKey[keyIndex],
                    keySize - pathKeySize, &keyIndex));
            keyIndex += pathKeySize;
        }

        //  Fill the rest of the file name part of the key with zeros
        for ( ; keyIndex < keySize; keyIndex++) {
            pKey[keyIndex] = 0;
        }
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbfmt.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wsbfmt.cpp

Abstract:

    This module implements file-system formatting support routines 

Author:

    Ravisankar Pudipeddi [ravisp] 19, January 2000

Revision History:

--*/


#include <stdafx.h>
extern "C" {
#include <ntdddisk.h>
#include <fmifs.h>
}
#include <wsbfmt.h>


#define MAX_FS_NAME_SIZE      256
#define MAX_PARAMS  20
#define INVALID_KEY 0

typedef struct _FORMAT_PARAMS {
    PWSTR volumeSpec;
    PWSTR label;
    PWSTR fsName;
    LONG  fsType;
    ULONG fsflags;
    ULONG allocationUnitSize; // Cluster size in Bytes
    HRESULT result;
    ULONG   threadId; 
    PFMIFS_ENABLECOMP_ROUTINE compressRoutine;
    PFMIFS_FORMAT_ROUTINE formatRoutine;
    PFMIFS_FORMATEX2_ROUTINE formatRoutineEx;
    BOOLEAN quick;
    BOOLEAN force;
    BOOLEAN cancel;
} FORMAT_PARAMS, *PFORMAT_PARAMS;

typedef struct _FM_ENTRY {
    ULONG key;
    PFORMAT_PARAMS val;
} FM_ENTRY, *PFM_ENTRY;

static  FM_ENTRY formatParamsTable[MAX_PARAMS];
static  PFMIFS_FORMATEX2_ROUTINE FormatRoutineEx = NULL; 
static  PFMIFS_FORMAT_ROUTINE   FormatRoutine = NULL;
static  PFMIFS_SETLABEL_ROUTINE LabelRoutine  = NULL;
static  PFMIFS_ENABLECOMP_ROUTINE  CompressRoutine = NULL;
static  HINSTANCE      IfsDllHandle = NULL;

void MountFileSystem(PWSTR volumeSpec);


HRESULT GetFormatParam(IN ULONG key, OUT PFORMAT_PARAMS *fp)
/*++

Routine Description:

    Returns the format parameter structure indexed by the
    supplied key

Arguments:

    key     - key indexing the format params 
    fp      - pointer to format params returned in this var.

Return Value:
    S_OK if found
    S_FALSE if not

--*/
{
    HRESULT hr = S_FALSE;
    ULONG i;

    WsbTraceIn(OLESTR("GetFormatParam"), OLESTR(""));

    for (i = 0; i < MAX_PARAMS; i++) {
        if (formatParamsTable[i].key == key) {
            hr = S_OK;
            *fp = formatParamsTable[i].val;
            break;
        }
    }

    WsbTraceOut(OLESTR("GetFormatParam"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}


HRESULT SetFormatParam(IN ULONG key, IN PFORMAT_PARAMS fp)
/*++

Routine Description:
    
    Finds a free slot and stores the supplied format params,
    indexed by the key

Arguments:
        key - key indexing the format params
        fp  - pointer to format params

Return Value:

    S_OK            - Found a slot and stored the format params
    E_OUTOFMEMORY   - Couldn't find a slot: too many formats in progress

--*/
{
    HRESULT hr = E_OUTOFMEMORY;
    ULONG i;

    WsbTraceIn(OLESTR("SetFormatParam"), OLESTR(""));
    for (i = 0; i < MAX_PARAMS; i++) {
        if (formatParamsTable[i].key == INVALID_KEY) {
            hr = S_OK;
            formatParamsTable[i].val = fp;
            formatParamsTable[i].key = key;
            break;
        }
    }

    WsbTraceOut(OLESTR("SetFormatParam"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}


HRESULT DeleteFormatParam(IN ULONG key) 
/*++

Routine Description:


    Locates the format params indexed by the key, deletes all allocated structures
    and frees up the slot

Arguments:

    key - key indexing the format params

Return Value:


    S_OK   - if format params found and deleted
    E_FAIL - if not
--*/
{
    PFORMAT_PARAMS formatParams;
    HRESULT hr = E_FAIL;
    ULONG i;

    WsbTraceIn(OLESTR("DeleteFormatParam"), OLESTR(""));
    for (i = 0; i < MAX_PARAMS; i++) {
        if (formatParamsTable[i].key == key) {
            hr = S_OK;
            formatParams = formatParamsTable[i].val;
            if (formatParams) {
                if (formatParams->volumeSpec) {
                    delete [] formatParams->volumeSpec;
                }
                if (formatParams->label) {
                    delete [] formatParams->label;
                }
                if (formatParams->fsName) {
                    delete [] formatParams->fsName;
                }
            }
            formatParamsTable[i].key = INVALID_KEY;
            formatParamsTable[i].val = NULL;
            break;
        }
    }

    WsbTraceOut(OLESTR("DeleteFormatParam"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}



BOOL
LoadIfsDll(void)
/*++

Routine Description:

    Loads the FMIFS DLL and stores the handle to it in IfsDllHandle
    Also sets the FormatXXX, LabelXXX, CompressXXX routines 

Arguments:

    None

Return Value:

    TRUE  if dll was loaded successfully
    FALSE if not

--*/
{
    BOOL retVal = TRUE;

    WsbTraceIn(OLESTR("LoadIfsDll"), OLESTR(""));

    if (IfsDllHandle != NULL) {

        // Library is already loaded and the routines needed
        // have been located.

        retVal = TRUE;
        goto exit;
    }

    IfsDllHandle = LoadLibrary(L"fmifs.dll");
    if (IfsDllHandle == (HANDLE)NULL) {
        // FMIFS not available.
        retVal = FALSE;
        goto exit;
    }

    // Library is loaded.  Locate the two routines needed

    FormatRoutineEx = (PFMIFS_FORMATEX2_ROUTINE) GetProcAddress(IfsDllHandle, "FormatEx2");
    FormatRoutine = (PFMIFS_FORMAT_ROUTINE) GetProcAddress(IfsDllHandle, "Format");
    LabelRoutine  = (PFMIFS_SETLABEL_ROUTINE) GetProcAddress(IfsDllHandle, "SetLabel");
    CompressRoutine = (PFMIFS_ENABLECOMP_ROUTINE) GetProcAddress(IfsDllHandle, 
                                                                 "EnableVolumeCompression");
    if (!FormatRoutine || !LabelRoutine || !FormatRoutineEx) {

        // Couldn't find something, so shut down all access 
        // to the library by ensuring FormatRoutine is NULL
        FreeLibrary(IfsDllHandle);
        FormatRoutine = NULL;
        FormatRoutineEx = NULL;
        LabelRoutine = NULL;
        retVal = FALSE;
    }

exit:

    WsbTraceOut(OLESTR("LoadIfsDll"), OLESTR("result = <%ls>"), WsbBoolAsString(retVal));

    return retVal;
}



void
UnloadIfsDll(void)
/*++

Routine Description:

    Unloads the FMIFS dll

Arguments:

    none

Return Value:

    TRUE if unloaded

--*/
{
    WsbTraceIn(OLESTR("UnloadIfsDll"), OLESTR(""));
    if (IfsDllHandle != (HANDLE) NULL) {
        FreeLibrary(IfsDllHandle);
        FormatRoutine = NULL;
        FormatRoutineEx = NULL;
        IfsDllHandle  = NULL;
        LabelRoutine  = NULL;
    }
    WsbTraceOut(OLESTR("UnloadIfsDll"), OLESTR(""));
}

BOOL
FmIfsCallback(IN FMIFS_PACKET_TYPE    PacketType,
              IN ULONG                PacketLength,
              IN PVOID                PacketData)
/*++

Routine Description:

    This routine gets callbacks from fmifs.dll regarding
    progress and status of the ongoing format 

Arguments:

    [PacketType] -- an fmifs packet type
    [PacketLength] -- length of the packet data
    [PacketData] -- data associated with the packet

Return Value:

    TRUE if the fmifs activity should continue, FALSE if the
    activity should halt immediately.

--*/
{
    BOOL         ret = TRUE;
    WCHAR        driveName[256];
    PFORMAT_PARAMS  formatParams;

    UNREFERENCED_PARAMETER(PacketLength);

    WsbTraceIn(OLESTR("FmIfsCallback"), OLESTR(""));

    if (GetFormatParam(GetCurrentThreadId(), &formatParams) != S_OK) {
        formatParams->result = E_FAIL;
        goto exit; 
    }
    //
    // Cancel if needed
    //
    if (formatParams->cancel) {
        formatParams->result = E_ABORT;
    } else {

        switch (PacketType) {
        case FmIfsPercentCompleted:
            if (((PFMIFS_PERCENT_COMPLETE_INFORMATION)
                 PacketData)->PercentCompleted % 10 == 0) {
                WsbTrace(L"FmIfsPercentCompleted: %d%%\n",
                        ((PFMIFS_PERCENT_COMPLETE_INFORMATION)
                         PacketData)->PercentCompleted);
            }
            break;

        case FmIfsFormatReport:
            WsbTrace(OLESTR("Format total kB: %d  available kB %d\n"),
                    ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesTotalDiskSpace,
                    ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesAvailable);
            break;

        case FmIfsIncompatibleFileSystem:
            formatParams->result = WSB_E_INCOMPATIBLE_FILE_SYSTEM;
            break;

        case FmIfsInsertDisk:
            break;

        case FmIfsFormattingDestination:
            break;

        case FmIfsIncompatibleMedia:
            formatParams->result = WSB_E_BAD_MEDIA;
            break;

        case FmIfsAccessDenied:
            formatParams->result = E_ACCESSDENIED;
            break;

        case FmIfsMediaWriteProtected:
            formatParams->result = WSB_E_WRITE_PROTECTED;
            break;

        case FmIfsCantLock:
            formatParams->result = WSB_E_CANT_LOCK;
            break;

        case FmIfsBadLabel:
            formatParams->result = WSB_E_BAD_LABEL;
            break;

        case FmIfsCantQuickFormat:
            formatParams->result = WSB_E_CANT_QUICK_FORMAT;
            break;

        case FmIfsIoError:
            formatParams->result = WSB_E_IO_ERROR;
            break;

        case FmIfsVolumeTooSmall:
            formatParams->result = WSB_E_VOLUME_TOO_SMALL;
            break;

        case FmIfsVolumeTooBig:
            formatParams->result = WSB_E_VOLUME_TOO_BIG;
            break;

        case FmIfsClusterSizeTooSmall:
            formatParams->result = E_FAIL;
            break;

        case FmIfsClusterSizeTooBig:
            formatParams->result = E_FAIL;
            break;

        case FmIfsClustersCountBeyond32bits:
            formatParams->result = E_FAIL;
            break;

        case FmIfsFinished:

            if (formatParams->result == S_OK) {
                ret = ((PFMIFS_FINISHED_INFORMATION) PacketData)->Success;
                if (ret) {
                    MountFileSystem(formatParams->volumeSpec);
                    WsbTrace(OLESTR("Format finished for %S filesystem on %S label %S\n"),
                            formatParams->fsName, formatParams->volumeSpec, formatParams->label );
                    if ((formatParams->compressRoutine != NULL) && !wcscmp(formatParams->fsName , L"NTFS") && (formatParams->fsflags & WSBFMT_ENABLE_VOLUME_COMPRESSION)) {
                        swprintf(driveName, L"%s\\", formatParams->volumeSpec);
                            (formatParams->compressRoutine)(driveName, COMPRESSION_FORMAT_DEFAULT);                         
                    }
                } else {
                   WsbTrace(OLESTR("Format finished failure with ret = %d\n"),ret);
                   formatParams->result = WSB_E_FORMAT_FAILED;
                }
                ret = FALSE;
            }
            break;

        default:
            break;
        }
    }
    
exit:

    if (formatParams->result != S_OK) {
        ret = FALSE;
    }

    WsbTraceOut(OLESTR("FmIfsCallback"), OLESTR("result = <%ls>"), WsbBoolAsString(ret));
    return ret;
}



void
MountFileSystem(PWSTR mountPoint)
/*++

Routine Description:


  Ensures a filesystem  is mounted at the given root:
  a) Opens the mount point and closes it.
  b) Does a FindFirstFile on the mount point
 
  The latter may sound redundant but is not because if we create the first
  FAT32 filesystem then just opening and closing is not enough
 

Arguments:

    mountPoint -  path name to the root of filesystem to be mounted

Return Value:
        
    none

--*/
{
    WCHAR buffer[1024];
    HANDLE handle;
    WIN32_FIND_DATA fileData;

    WsbTraceIn(OLESTR("MountFileSystem"), OLESTR(""));

    handle = CreateFile(mountPoint, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    0, OPEN_EXISTING, 0, 0);
    if (handle != INVALID_HANDLE_VALUE)
        CloseHandle(handle);
    swprintf(buffer,L"%s\\*.*",mountPoint);
    /*
     * Go ahead and try to find the first file, this will make sure that
     * the file system is mounted
     */
    handle = FindFirstFile(buffer, &fileData);
    if (handle != INVALID_HANDLE_VALUE) {
        FindClose(handle);
    }
    WsbTraceOut(OLESTR("MountFileSystem"), OLESTR(""));
}


void
FormatVolume(IN PFORMAT_PARAMS params)
/*++

Routine Description:

    This routine format the volume described by params

Arguments:

    params - pointer to the FORMAT_PARAMS describing the volume,
             file system to be formatted to, quick/force etc.

Return Value:

    None. 
    params->result contains the result of this operation

--*/
{
    FMIFS_FORMATEX2_PARAM exParam;
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("FormatVolume"), OLESTR(""));
    /*
     * Get the object corresponding to the storage Id and
     * and notify all clients that the region has changed
     * i.e. there is a format in progress on that region
     */
     memset(&exParam, 0, sizeof(exParam));
     exParam.Major = 1;
     exParam.Minor = 0;
     if (params->quick) {
        exParam.Flags |= FMIFS_FORMAT_QUICK;
     }
     if (params->force) {
        exParam.Flags |= FMIFS_FORMAT_FORCE;
     }
     exParam.LabelString = params->label;
     exParam.ClusterSize = params->allocationUnitSize;
     (params->formatRoutineEx)(params->volumeSpec,
                               FmMediaUnknown,
                               params->fsName,
                               &exParam,
                              (FMIFS_CALLBACK)&FmIfsCallback);

    if (params->result == NULL) {
        /* Format is successful so we lock unlock the filesystem */
        MountFileSystem(params->volumeSpec);
    }
    DeleteFormatParam(params->threadId);
    WsbTraceOut(OLESTR("FormatVolume"), OLESTR(""));
}


HRESULT
FormatPartition(IN PWSTR volumeSpec, 
                IN LONG fsType, 
                IN PWSTR label,
                IN ULONG fsflags, 
                IN BOOLEAN quick, 
                IN BOOLEAN force,
                IN ULONG allocationUnitSize)
/*++

Routine Description:


    Entry point for formatting a volume. 
    No defaults are assumed and all parameters need to be supplied

Arguments:

    volumeSpec  - Drive letter or name of volume
    fsType      - One of FSTYPE_FAT, FSTYPE_FAT32, FSTYE_NTFS
    label       - Volume label to be assigned to the partition/volume
    fsflags     - Flags describing desired characteristics
    quick       - If TRUE, a quick format is attempted
    force       - If TRUE a force format is done
    allocationUnitSize - 
                 cluster size   

Return Value:

    Result of the operation

--*/
{
    FORMAT_PARAMS   params;

    WsbTraceIn(OLESTR("FormatPartition"), OLESTR(""));

    if (fsType > 0 && !LoadIfsDll()) // fsType is +ve for FAT, FAT32 and NTFS which are supported by fmifs
    {
        // could not load the Dll
        WsbTrace(OLESTR("Can't load fmifs.dll\n"));
        return E_FAIL;
    }

    params.volumeSpec = new WCHAR[wcslen(volumeSpec) + 1];
    if (params.volumeSpec == NULL) {
        return E_INVALIDARG;
    }

    params.label = new WCHAR[wcslen(label) + 1];
    if (params.label == NULL) {
        delete [] params.volumeSpec;
        return E_INVALIDARG;
    }
    params.fsName = new WCHAR[MAX_FS_NAME_SIZE];
    if (params.fsName == NULL) {
        delete [] params.volumeSpec;
        delete [] params.label;
        return E_INVALIDARG;
    }

    if (fsType > 0) {
        wcscpy(params.fsName, (fsType == FSTYPE_FAT ? L"FAT" :
                               (fsType == FSTYPE_FAT32 ? L"FAT32" : L"NTFS")));
    }

    wcscpy(params.volumeSpec, volumeSpec);
    wcscpy(params.label, label);
    params.fsType = fsType;
    params.fsflags = fsflags;
    params.allocationUnitSize = allocationUnitSize;
    params.quick = quick;
    params.force = force;
    params.result = S_OK;
    params.cancel = FALSE;
    params.formatRoutine = FormatRoutine;
    params.formatRoutineEx = FormatRoutineEx;
    params.compressRoutine = CompressRoutine;
    params.threadId = GetCurrentThreadId();

    if (SetFormatParam(params.threadId, &params) != S_OK) {
            delete [] params.label;
            delete [] params.volumeSpec;
            delete [] params.fsName;
            return E_OUTOFMEMORY;
    };

    FormatVolume(&params);

    WsbTraceOut(OLESTR("FormatPartition"), OLESTR("result = <%ls>"), WsbHrAsString(params.result));
    return params.result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbllong.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbllong.cpp

Abstract:

    This component is an object representations of the LONGLONG standard type. It
    is both a persistable and collectable.

Author:

    Ron White   [ronw]   21-Jan-97

Revision History:

--*/

#include "stdafx.h"

#include "wsbllong.h"


HRESULT
CWsbLonglong::CompareToLonglong(
    IN LONGLONG value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbLonglong::CompareToLonglong

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbLonglong::CompareToLonglong"), 
            OLESTR("m_value = <%ls>, value = <%ls>"), 
            WsbLonglongAsString(m_value), WsbLonglongAsString(value));

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbLonglong::CompareToLonglong"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbLonglong::CompareToILonglong(
    IN IWsbLonglong* pLonglong,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbLonglong::CompareToILonglong

--*/
{
    HRESULT     hr = E_FAIL;
    LONGLONG        value;

    WsbTraceIn(OLESTR("CWsbLonglong::CompareToILonglong"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pLonglong, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pLonglong->GetLonglong(&value));
        hr = CompareToLonglong(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::CompareToILonglong"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbLonglong::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbLonglong*   pLonglong;

    WsbTraceIn(OLESTR("CWsbLonglong::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbLonglong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbLonglong, (void**) &pLonglong));

        hr = CompareToILonglong(pLonglong, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbLonglong::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_value = 0;
    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbLonglong::GetLonglong(
    OUT LONGLONG* pValue
    )

/*++

Implements:

  IWsbLonglong::GetLonglong

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::GetLonglong"), OLESTR("m_value = <%ls>"),
            WsbLonglongAsString(m_value));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::GetLonglong"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CWsbLonglong::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CWsbLonglong;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::GetClassID"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbLonglong::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::GetSizeMax"), OLESTR(""));

    try {
        WsbAssert(0 != pcbSize, E_POINTER);
        
        pcbSize->QuadPart = WsbPersistSizeOf(LONGLONG);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbLonglong::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbLonglong::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLonglong::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbLonglong::SetLonglong(
    IN LONGLONG value
    )

/*++

Implements:

  IWsbLonglong::SetLonglong

--*/
{
    WsbTraceIn(OLESTR("CWsbLonglong::SetLonglong"), OLESTR("value = <%ls>"),
            WsbLonglongAsString(value));

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbLonglong::SetLonglong"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbLonglong::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbLonglong>   pLonglong1;
    CComPtr<IWsbLonglong>   pLonglong2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    LONGLONG                value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbLonglong::Test"), OLESTR(""));

    try {

        // Get the pLonglong interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbLonglong*) this)->QueryInterface(IID_IWsbLonglong, (void**) &pLonglong1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pLonglong1->SetLonglong(0xefffffff));
                WsbAffirmHr(pLonglong1->GetLonglong(&value));
                WsbAssert(value == 0xefffffff, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbLonglong, NULL, CLSCTX_ALL, IID_IWsbLonglong, (void**) &pLonglong2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong2->GetLonglong(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(-767));
                    WsbAffirmHr(pLonglong2->SetLonglong(-767));
                    WsbAssert(pLonglong1->IsEqual(pLonglong2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(767));
                    WsbAffirmHr(pLonglong2->SetLonglong(-767));
                    WsbAssert(pLonglong1->IsEqual(pLonglong2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(-900));
                    WsbAffirmHr(pLonglong2->SetLonglong(-900));
                    WsbAssert((pLonglong1->CompareTo(pLonglong2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(-900));
                    WsbAffirmHr(pLonglong2->SetLonglong(-400));
                    WsbAssert((pLonglong1->CompareTo(pLonglong2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->SetLonglong(75000));
                    WsbAffirmHr(pLonglong2->SetLonglong(20000));
                    WsbAssert((pLonglong1->CompareTo(pLonglong2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pLonglong1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pLonglong2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pLonglong2->SetLonglong(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbLonglong.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pLonglong1->SetLonglong(-888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbLonglong.tst"), 0));
                        WsbAssert(pLonglong1->CompareToLonglong(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLonglong::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsblong.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsblong.h

Abstract:

    This component is an object representations of the LONG standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsb.h"
#include "wsbcltbl.h"

#ifndef _WSBLONG_
#define _WSBLONG_


/*++

Class Name:
    
    CWsbLong

Class Description:

    An object representations of the LONG standard type. It
    is both persistable and collectable.

--*/

class CWsbLong : 
    public CWsbObject,
    public IWsbLong,
    public CComCoClass<CWsbLong,&CLSID_CWsbLong>
{
public:
    CWsbLong() {}
BEGIN_COM_MAP(CWsbLong)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbLong)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbLong)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbLong)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbLong
public:
    STDMETHOD(CompareToLong)(LONG value, SHORT* pResult);
    STDMETHOD(CompareToILong)(IWsbLong* pLong, SHORT* pResult);
    STDMETHOD(GetLong)(LONG* pValue);
    STDMETHOD(SetLong)(LONG value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    LONG            m_value;
};

#endif // _WSBLONG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsblong.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsblong.cpp

Abstract:

    This component is an object representations of the LONG standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsblong.h"


HRESULT
CWsbLong::CompareToLong(
    IN LONG value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbLong::CompareToLong

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbLong::CompareToLong"), OLESTR("value = <%ld>"), value);

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbLong::CompareToLong"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbLong::CompareToILong(
    IN IWsbLong* pLong,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbLong::CompareToILong

--*/
{
    HRESULT     hr = E_FAIL;
    LONG        value;

    WsbTraceIn(OLESTR("CWsbLong::CompareToILong"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pLong, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pLong->GetLong(&value));
        hr = CompareToLong(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::CompareToILong"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbLong::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbLong*   pLong;

    WsbTraceIn(OLESTR("CWsbLong::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbLong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbLong, (void**) &pLong));
        hr = CompareToILong(pLong, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbLong::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = 0;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbLong::GetLong(
    OUT LONG* pValue
    )

/*++

Implements:

  IWsbLong::GetLong

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::GetLong"), OLESTR(""));

    try {

        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::GetLong"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbLong::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbLong;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbLong::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(LONG);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbLong::Load(
    IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));      

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::Load"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);

    return(hr);
}


HRESULT
CWsbLong::Save(
    IStream* pStream,
    BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbLong::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));     

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbLong::SetLong(
    LONG value
    )

/*++

Implements:

  IWsbLong::SetLong

--*/
{
    WsbTraceIn(OLESTR("CWsbLong::SetLong"), OLESTR("value = <%ld>"), value);

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbLong::SetLong"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbLong::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbLong>       pLong1;
    CComPtr<IWsbLong>       pLong2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    LONG                    value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbLong::Test"), OLESTR(""));

    try {

        // Get the pLong interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbLong*) this)->QueryInterface(IID_IWsbLong, (void**) &pLong1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pLong1->SetLong(0xefffffff));
                WsbAffirmHr(pLong1->GetLong(&value));
                WsbAssert(value == 0xefffffff, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbLong, NULL, CLSCTX_ALL, IID_IWsbLong, (void**) &pLong2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pLong2->GetLong(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(-767));
                    WsbAffirmHr(pLong2->SetLong(-767));
                    WsbAssert(pLong1->IsEqual(pLong2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(767));
                    WsbAffirmHr(pLong2->SetLong(-767));
                    WsbAssert(pLong1->IsEqual(pLong2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(-900));
                    WsbAffirmHr(pLong2->SetLong(-900));
                    WsbAssert((pLong1->CompareTo(pLong2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(-900));
                    WsbAffirmHr(pLong2->SetLong(-400));
                    WsbAssert((pLong1->CompareTo(pLong2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->SetLong(75000));
                    WsbAffirmHr(pLong2->SetLong(20000));
                    WsbAssert((pLong1->CompareTo(pLong2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pLong1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pLong2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pLong2->SetLong(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbLong.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pLong1->SetLong(-888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbLong.tst"), 0));
                        WsbAssert(pLong1->CompareToLong(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbLong::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbport.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbPort.cpp

Abstract:

    Macros, functions, and classes to support portability.

Author:

    Ron White   [ronw]   19-Dec-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbport.h"


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    BOOL*   pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a BOOL value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array.

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(BOOL)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(1 == WSB_BYTE_SIZE_BOOL, E_UNEXPECTED);

        if (*pBytes) {
            *pValue = TRUE;
        } else {
            *pValue = FALSE;
        }
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_BOOL;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(BOOL)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    GUID*   pValue,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a GUID value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 16 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(GUID)"), OLESTR(""));

    try {
        ULONG lsize;
        ULONG tsize;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &pValue->Data1, &lsize));
        tsize = lsize;
        WsbAffirmHr(WsbConvertFromBytes(pBytes + tsize, &pValue->Data2, &lsize));
        tsize += lsize;
        WsbAffirmHr(WsbConvertFromBytes(pBytes + tsize, &pValue->Data3, &lsize));
        tsize += lsize;
        memcpy(pValue->Data4, pBytes + tsize, 8);
        tsize += 8;
        if (pSize) {
            *pSize = tsize;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(GUID)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    LONG*   pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a LONG value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 4 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(LONG)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(4 == WSB_BYTE_SIZE_LONG, E_UNEXPECTED);

        *pValue = (pBytes[0] << 24) | (pBytes[1] << 16) |
                (pBytes[2] << 8) | pBytes[3];
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_LONG;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(LONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*    pBytes,
    LONGLONG* pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a LONGLONG value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(LONGLONG)"), OLESTR(""));

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
        LONGLONG    ll;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pBytes += size;
        ll = (LONGLONG) ul;
        *pValue = ll << 32;
        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        ll = (LONGLONG) ul;
        *pValue |= ll;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(LONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*    pBytes,
    ULONGLONG* pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a ULONGLONG value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(ULONGLONG)"), OLESTR(""));

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
        LONGLONG    ll;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pBytes += size;
        ll = (ULONGLONG) ul;
        *pValue = ll << 32;
        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        ll = (ULONGLONG) ul;
        *pValue |= ll;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(ULONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    DATE*   pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a DATE value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(DATE)"), OLESTR(""));

    try {
        LONGLONG  ll;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(WSB_BYTE_SIZE_DATE == WSB_BYTE_SIZE_LONGLONG, E_UNEXPECTED);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ll, NULL));
        *pValue = (DATE) ll;

        if (pSize) {
            *pSize = WSB_BYTE_SIZE_DATE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(DATE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*    pBytes,
    FILETIME* pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a FILETIME value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(FILETIME)"), OLESTR(""));

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pBytes += size;
        pValue->dwHighDateTime = ul;
        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pValue->dwLowDateTime = ul;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(FILETIME)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    SHORT*  pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a SHORT value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 2 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(SHORT)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(2 == WSB_BYTE_SIZE_SHORT, E_UNEXPECTED);

        *pValue = (SHORT)( (pBytes[0] << 8) | pBytes[1] );
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_SHORT;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(SHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*    pBytes,
    ULARGE_INTEGER* pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a ULARGE_INTEGER value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 8 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(ULARGE_INTEGER)"), OLESTR(""));

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pBytes += size;
        pValue->HighPart = ul;
        WsbAffirmHr(WsbConvertFromBytes(pBytes, &ul, &size));
        total += size;
        pValue->LowPart = ul;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(ULARGE_INTEGER)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    ULONG*  pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a ULONG value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 4 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(ULONG)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(4 == WSB_BYTE_SIZE_ULONG, E_UNEXPECTED);

        *pValue = (pBytes[0] << 24) | (pBytes[1] << 16) |
                (pBytes[2] << 8) | pBytes[3];
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_ULONG;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(ULONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertFromBytes(
    UCHAR*  pBytes,
    USHORT* pValue,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a USHORT value from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array (must at least 2 bytes long).

    pValue - Pointer to the returned value.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertFromBytes(USHORT)"), OLESTR(""));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(2 == WSB_BYTE_SIZE_USHORT, E_UNEXPECTED);

        *pValue = (USHORT)( ( pBytes[0] << 8 ) | pBytes[1] );
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_USHORT;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertFromBytes(USHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    BOOL    value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a BOOL value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array.

    value  - The BOOL value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(BOOL)"), OLESTR("value = <%s>"), 
            WsbBoolAsString(value));

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(1 == WSB_BYTE_SIZE_BOOL, E_UNEXPECTED);

        if (value) {
            *pBytes = 1;
        } else {
            *pBytes = 0;
        }
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_BOOL;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(BOOL)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    GUID    value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a GUID value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 16 bytes long).

    value  - The GUID value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(GUID)"), OLESTR("value = <%s>"), 
            WsbGuidAsString(value));

    try {
        ULONG lsize;
        ULONG tsize;
    
        WsbAssert(0 != pBytes, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(pBytes, value.Data1, &lsize));
        tsize = lsize;
        WsbAffirmHr(WsbConvertToBytes(pBytes + tsize, value.Data2, &lsize));
        tsize += lsize;
        WsbAffirmHr(WsbConvertToBytes(pBytes + tsize, value.Data3, &lsize));
        tsize += lsize;
        memcpy(pBytes + tsize, value.Data4, 8);
        tsize += 8;
        if (pSize) {
            *pSize = tsize;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(GUID)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    LONG   value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a LONG value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 4 bytes long).

    value  - The LONG value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(LONG)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(4 == WSB_BYTE_SIZE_LONG, E_UNEXPECTED);

        pBytes[0] = ((UCHAR)(value >> 24));
        pBytes[1] = ((UCHAR)((value >> 16) & 0xFF));
        pBytes[2] = ((UCHAR)((value >> 8) & 0xFF));
        pBytes[3] = ((UCHAR)(value & 0xFF));
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_LONG;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(LONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    LONGLONG value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a LONGLONG value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The LONGLONG value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(LONGLONG)"), OLESTR("value = <%d>"), value);

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);

        ul = (ULONG)(value >> 32);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        pBytes += size;
        ul = (ULONG)(value & 0xFFFFFFFF);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(LONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    ULONGLONG value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a ULONGLONG value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The LONGLONG value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(ULONGLONG)"), OLESTR("value = <%d>"), value);

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);

        ul = (ULONG)(value >> 32);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        pBytes += size;
        ul = (ULONG)(value & 0xFFFFFFFF);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(ULONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    DATE    value,
    ULONG*  pSize
    )

/*++


Routine Description:

    Convert a DATE value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The DATE value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(DATE)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(WSB_BYTE_SIZE_DATE == WSB_BYTE_SIZE_LONGLONG, E_UNEXPECTED);

        // Needs to modified after WsbDate functions.
        WsbAffirmHr(WsbConvertToBytes(pBytes, (LONGLONG) value, NULL));

        if (pSize) {
            *pSize = WSB_BYTE_SIZE_DATE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(DATE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    FILETIME value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a FILETIME value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The FILETIME value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(FILETIME)"), OLESTR("value = <%d>"), value);

    try {
        ULONG size;
        ULONG total = 0;
    
        WsbAssert(0 != pBytes, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(pBytes, value.dwHighDateTime, &size));
        total += size;
        pBytes += size;
        WsbAffirmHr(WsbConvertToBytes(pBytes, value.dwLowDateTime, &size));
        total += size;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(FILETIME)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    SHORT   value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a SHORT value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 2 bytes long).

    value  - The SHORT value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(SHORT)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(2 == WSB_BYTE_SIZE_SHORT, E_UNEXPECTED);

        pBytes[0] = (UCHAR)( (value >> 8) & 0xFF);
        pBytes[1] = (UCHAR)( value & 0xFF );
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_SHORT;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(SHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    ULARGE_INTEGER value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a ULARGE_INTEGER value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 8 bytes long).

    value  - The ULARGE_INTEGER value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(ULARGE_INTEGER)"), OLESTR("value = <%d>"), value);

    try {
        ULONG size;
        ULONG total = 0;
        ULONG ul;
    
        WsbAssert(0 != pBytes, E_POINTER);

        ul = (ULONG)(value.QuadPart >> 32);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        pBytes += size;
        ul = (ULONG)(value.QuadPart & 0xFFFFFFFF);
        WsbAffirmHr(WsbConvertToBytes(pBytes, ul, &size));
        total += size;
        if (pSize) {
            *pSize = total;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(ULARGE_INTEGER)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    ULONG   value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a ULONG value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 4 bytes long).

    value  - The ULONG value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(ULONG)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(4 == WSB_BYTE_SIZE_ULONG, E_UNEXPECTED);

        pBytes[0] = ((UCHAR)(value >> 24));
        pBytes[1] = ((UCHAR)((value >> 16) & 0xFF));
        pBytes[2] = ((UCHAR)((value >> 8) & 0xFF));
        pBytes[3] = ((UCHAR)(value & 0xFF));
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_ULONG;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(ULONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbConvertToBytes(
    UCHAR*  pBytes,
    USHORT  value,
    ULONG* pSize
    )

/*++


Routine Description:

    Convert a USHORT value to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must at least 2 bytes long).

    value  - The USHORT value to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbConvertToBytes(USHORT)"), OLESTR("value = <%d>"), value);

    try {
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(2 == WSB_BYTE_SIZE_USHORT, E_UNEXPECTED);

        pBytes[0] = (UCHAR)( ( value >> 8 ) & 0xFF );
        pBytes[1] = (UCHAR)( value & 0xFF );
        if (pSize) {
            *pSize = WSB_BYTE_SIZE_USHORT;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbConvertToBytes(USHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbOlestrFromBytes(
    UCHAR*    pBytes,
    OLECHAR*  pValue,
    ULONG*    pSize
    )

/*++


Routine Description:

    Convert a OLECHAR string from a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The source byte array.

    pValue - Pointer to the returned string.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes or pValue was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbOlestrFromBytes(OLECHAR)"), OLESTR(""));

    try {
        ULONG size = 0;

        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == 2, E_FAIL);
        while (TRUE) {
            OLECHAR wc;

            wc = (OLECHAR)( (*pBytes++) << 8 );
            wc |= *pBytes++;
            size += 2;
            *pValue++ = wc;
            if (wc == 0) break;
        }
        if (pSize) {
            *pSize = size;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbOlestrFromBytes(OLECHAR)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbOlestrToBytes(
    UCHAR*   pBytes,
    OLECHAR* pValue,
    ULONG*   pSize
    )

/*++


Routine Description:

    Convert a OLECHAR sring to a string of bytes.  Useful
    for stream portability and creating WsbDbKey values.

Arguments:

    pBytes - The target byte array (must long enough).

    pValue - The OLECHAR string to convert.

    pSize  - Returns the number of bytes used. Can be NULL.

Return Value:

  S_OK      - Success
  E_POINTER - pBytes was NULL.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbOlestrToBytes(OLECHAR)"), OLESTR("value = <%S>"), pValue);

    try {
        ULONG size = 0;
    
        WsbAssert(0 != pBytes, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == 2, E_FAIL);

        while (TRUE) {
            OLECHAR wc;

            wc = *pValue++;
            *pBytes++ = (UCHAR)( ( wc >> 8 ) & 0xFF );
            *pBytes++ = (UCHAR)( wc & 0xFF );
            size += 2;
            if (wc == 0) break;
        }
        if (pSize) {
            *pSize = size;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbOlestrToBytes(OLECHAR)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbpstrg.cpp ===
#include "stdafx.h"

#include "wsb.h"
#include "wsbpstrg.h"

// {C03D4861-70D7-11d1-994F-0060976A546D}
static const GUID StringPtrGuid = 
{ 0xc03d4861, 0x70d7, 0x11d1, { 0x99, 0x4f, 0x0, 0x60, 0x97, 0x6a, 0x54, 0x6d } };


CComPtr<IMalloc>        CWsbStringPtr::m_pMalloc = 0;

CWsbStringPtr::CWsbStringPtr()
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
                
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

    } WsbCatch(hr);
}

CWsbStringPtr::CWsbStringPtr(const CHAR* pChar)
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
        
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

        *this = pChar;

    } WsbCatch(hr);
}

CWsbStringPtr::CWsbStringPtr(const WCHAR* pWchar)
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
        
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

        *this = pWchar;

    } WsbCatch(hr);
}


CWsbStringPtr::CWsbStringPtr(REFGUID rguid)
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
        
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

        *this = rguid;

    } WsbCatch(hr);
}

CWsbStringPtr::CWsbStringPtr(const CWsbStringPtr& pString)
{
    HRESULT     hr = S_OK;

    try {
        
        m_pString = 0;
        m_givenSize = 0;
        
        if (m_pMalloc == 0) {
            WsbAssertHr(CoGetMalloc(1, &m_pMalloc));
        }
        WSB_OBJECT_ADD(StringPtrGuid, this);

        *this = pString;

    } WsbCatch(hr);
}

CWsbStringPtr::~CWsbStringPtr()
{
    WSB_OBJECT_SUB(StringPtrGuid, this);
    Free();
}

CWsbStringPtr::operator WCHAR*()
{
    return(m_pString);
}

WCHAR& CWsbStringPtr::operator *()
{
    _ASSERTE(0 != m_pString);
    return(*m_pString);
}

WCHAR** CWsbStringPtr::operator &()
{
    return(&m_pString);
}

WCHAR& CWsbStringPtr::operator [](const int i)
{
    _ASSERTE(0 != m_pString);
    return(m_pString[i]);
}

CWsbStringPtr& CWsbStringPtr::operator =(const CHAR* pChar)
{
    HRESULT     hr = S_OK;
    ULONG       length;
    int         count;

    try {
    
        // Are they setting it to something?
        if (0 != pChar) {
        
            // Otherwise, see if our current buffer is big enough.
            //
            // NOTE: With multibyte characters, we may be getting a bigger
            // buffer than we need, but the call to return the accurate
            // size is not ANSI.
            length = strlen(pChar);
            WsbAffirmHr(Realloc(length));
            WsbAffirm(0 != m_pString, E_OUTOFMEMORY);

            // Copy the data (and convert to wide characters)
            count = mbstowcs(m_pString, pChar, length + 1);
            WsbAffirm((count != -1), E_FAIL);
        }

        else {
            Free();
        }

    } WsbCatch(hr);

    return(*this);
}

CWsbStringPtr& CWsbStringPtr::operator =(const WCHAR* pWchar)
{
    HRESULT     hr = S_OK;
    ULONG       length;

    try {
    
        // Are they setting it to something?
        if (0 != pWchar) {
        
            // Otherwise, see if our current buffer is big enough.
            length = wcslen(pWchar);
            WsbAffirmHr(Realloc(length));

            // Copy the data (and convert to wide characters)
            wcscpy(m_pString, pWchar);
        }

        else {
            Free();
        }

    } WsbCatch(hr);

    return(*this);
}

CWsbStringPtr& CWsbStringPtr::operator =(REFGUID rguid)
{
    HRESULT     hr = S_OK;
    OLECHAR*    tmpString = 0;

    try {
    
        // See if our current buffer is big enough.
        WsbAffirmHr(Realloc(WSB_GUID_STRING_SIZE));

        // Fill with the GUID in string format
        WsbAffirmHr(WsbStringFromGuid(rguid, m_pString));

    } WsbCatch(hr);

    return(*this);
}

CWsbStringPtr& CWsbStringPtr::operator =(const CWsbStringPtr& pString)
{
    *this = pString.m_pString;

    return(*this);
}

BOOL CWsbStringPtr::operator !()
{
    return((0 == m_pString) ? TRUE : FALSE);
}

HRESULT CWsbStringPtr::Alloc(ULONG size)
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 == m_pString, E_UNEXPECTED);
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        m_pString = (WCHAR*)WsbAlloc((size + 1) * sizeof(WCHAR));
        WsbAffirm(0 != m_pString, E_OUTOFMEMORY);

        // Make sure we always have a valid string so bad things don't happen.
        *m_pString = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::Append(const CHAR* pChar)
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString = pChar;

    hr = Append(tmpString);

    return(hr);
}

HRESULT CWsbStringPtr::Append(const WCHAR* pWchar)
{
    HRESULT         hr = S_OK;
    ULONG           length = 0;
    ULONG           appendLength;

    try {
    
        // If they passed us a null pointer, then we don't need to do anything.
        WsbAffirm(pWchar != 0, S_OK);

        // If they passed us an empty string, then we don't need to do anything.
        appendLength = wcslen(pWchar);
        if (0 != appendLength) {

            // Make sure the buffer is big enough.
            if (0 != m_pString) {
                length = wcslen(m_pString);
            }

            WsbAffirmHr(Realloc(length + appendLength));

            // Append the string.
            wcscat(m_pString, pWchar);
        }
    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::Append(const CWsbStringPtr& pString) {
    HRESULT         hr = S_OK;

    hr = Append(pString.m_pString);

    return(hr);
}

HRESULT CWsbStringPtr::CopyTo(CHAR** ppChar)
{
    HRESULT     hr = S_OK;

    hr = CopyTo(ppChar, 0);

    return(hr);
}

HRESULT CWsbStringPtr::CopyTo(CHAR** ppChar, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;
    CHAR*       tmpString = 0;

    try {
    
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        // Allocate a buffer big enough to hold their string.
        //
        // NOTE: With multibyte characters, we may be getting a bigger
        // buffer than we need, but the call to return the accurate
        // size is not ANSI.
        if (m_pString != 0) {
            length = wcstombs(0, m_pString, 0);
        }

        if (bufferSize == 0) {
            tmpString = (CHAR*) WsbRealloc(*ppChar, (length + 1) * sizeof(CHAR));
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);
            if (*ppChar == 0) {
                tmpString = (CHAR*)WsbAlloc((bufferSize + 1) * sizeof(CHAR));
            } else {
                tmpString = *ppChar;
            }
        }

        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppChar = tmpString;

        // Copy and return the string;
        if (m_pString != 0) {
            WsbAffirm (-1 != wcstombs(*ppChar, m_pString, length + 1), E_FAIL);
        } else {
            **ppChar = 0;
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::CopyTo(WCHAR** ppWchar)
{
    HRESULT     hr = S_OK;

    hr = CopyTo(ppWchar, 0);

    return(hr);
}

HRESULT CWsbStringPtr::CopyTo(WCHAR** ppWchar, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;
    WCHAR*      tmpString = 0;

    try {
    
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        // Allocate a buffer big enough to hold their string.
        if (m_pString != 0) {
            length = wcslen(m_pString);
        }

        if (bufferSize == 0) {
            tmpString = (WCHAR*) WsbRealloc(*ppWchar, (length + 1) * sizeof(WCHAR));
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);
            if (*ppWchar == 0) {
                tmpString = (WCHAR*) WsbRealloc(*ppWchar, (bufferSize + 1) * sizeof(WCHAR));
            }

        }

        WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
        *ppWchar = tmpString;

        // Copy and return the string;
        if (m_pString != 0) {
            wcscpy(*ppWchar, m_pString);
        } else {
            **ppWchar = 0;
        }


    } WsbCatch(hr);

    return(hr);
}


HRESULT CWsbStringPtr::CopyTo(GUID * pguid)
{
    HRESULT     hr = S_OK;

    hr = WsbGuidFromString(m_pString, pguid);

    return(hr);
}

HRESULT CWsbStringPtr::CopyToBstr(BSTR* pBstr)
{
    HRESULT     hr = S_OK;

    hr = CopyToBstr(pBstr, 0);

    return(hr);
}

HRESULT CWsbStringPtr::CopyToBstr(BSTR* pBstr, ULONG bufferSize)
{
    HRESULT     hr = S_OK;
    ULONG       length = 0;

    try {
    
        // Allocate a buffer big enough to hold their string.
        if (m_pString != 0) {
            length = wcslen(m_pString);
        }

        if (bufferSize == 0) {
            if (0 == *pBstr) {
                *pBstr = WsbAllocString(m_pString);
            } else {
                WsbAffirm(WsbReallocString(pBstr, m_pString), E_OUTOFMEMORY);
            }
        } else {
            WsbAssert(bufferSize >= length, E_FAIL);

            if (0 == pBstr) {
                *pBstr = WsbAllocStringLen(m_pString, bufferSize);
            } else {
                WsbAffirm(WsbReallocStringLen(pBstr, m_pString, bufferSize), E_OUTOFMEMORY);
            }
        }

        WsbAffirm(0 != pBstr, E_OUTOFMEMORY);

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::FindInRsc(ULONG startId, ULONG idsToCheck, ULONG* pMatchId)
{
    HRESULT         hr = S_FALSE;
    CWsbStringPtr   dest;

    try {
    
        WsbAssert(0 != pMatchId, E_POINTER);

        // Initialize the return value.
        *pMatchId = 0;

        // Check each resource string mention and see if it is the same as
        // the string provided.
        for (ULONG testId = startId; (testId < (startId + idsToCheck)) && (*pMatchId == 0); testId++) {

            WsbAffirmHr(dest.LoadFromRsc(_Module.m_hInst, testId));

            if (wcscmp(dest, m_pString) == 0) {
                *pMatchId = testId;
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::Free(void)
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        if ((0 != m_pString) && (0 == m_givenSize)) {
            WsbFree(m_pString);
            m_pString = 0;
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::GetSize(ULONG* pSize)
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pSize, E_POINTER);
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);

        if (0 == m_pString) {
            *pSize = 0;
        } else if (0 != m_givenSize) {
            *pSize = m_givenSize;
        } else {
            *pSize = (ULONG)(m_pMalloc->GetSize(m_pString) / sizeof(WCHAR) - 1);
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::GiveTo(WCHAR** ppWchar)
{
    HRESULT         hr = S_OK;

    try {

        WsbAssert(0 != ppWchar, E_POINTER);

        // Given them our string buffer, and forget about it.
        *ppWchar = m_pString;
        m_pString = 0;
        m_givenSize = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::LoadFromRsc(HINSTANCE instance, ULONG id)
{
    HRESULT     hr = S_OK;
    HRSRC       resource;
    ULONG       stringSize;

    try {

        // Find the resource requested. This requires converting the resource
        // identifier into a string.
        //
        // NOTE: Strings are not number individually, but in groups of 16!! This throws
        // off the latter size calculation, and some other strategy might be better
        // here (e.g. load to a fixed size and then allocate again if too small).
        resource = FindResource(instance, MAKEINTRESOURCE((id/16) + 1), RT_STRING);
        WsbAffirm(resource != 0, E_FAIL);

        // How big is the string?
        stringSize = SizeofResource(instance, resource);
        WsbAffirm(0 != stringSize, E_FAIL);
                  
        // Get the right sized buffer.
        WsbAffirmHr(Realloc(stringSize / sizeof(WCHAR)));

        // Load the string into the buffer.
        WsbAffirm(LoadString(instance, id, m_pString, (stringSize / sizeof(WCHAR)) + 1) != 0, E_FAIL);

    } WsbCatch(hr);

    return(hr);
}



HRESULT CWsbStringPtr::Prepend(const CHAR* pChar) {
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString = pChar;

    hr = Prepend(tmpString);

    return(hr);
}

HRESULT CWsbStringPtr::Prepend(const WCHAR* pWchar) {
    HRESULT         hr = S_OK;
    ULONG           length;
    ULONG           prependLength;
    ULONG           i, j;

    try {
    
        // If they passed us a null pointer, then we don't need to do anything.
        WsbAffirm(pWchar != 0, S_OK);

        // If they passed us an empty string, then we don't need to do anything.
        prependLength = wcslen(pWchar);
        WsbAffirm(0 != prependLength, S_OK);

        if (0 != m_pString) {
            length = wcslen(m_pString);
        } else {
            // Prepend code will work as long as we have a null string and not a null pointer...
            // Next Realloc statement will make it happen...
            length = 0;
        }

        WsbAffirmHr(Realloc(length + prependLength));
        
        // First move the existing string down in the buffer.
        for (i = length + 1, j = length + prependLength; i > 0; i--, j--) {
            m_pString[j] = m_pString[i - 1];
        }

        // Now prepend the string (except for the null)
        for (i = 0; i < prependLength; i++) {
            m_pString[i] = pWchar[i];
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::Prepend(const CWsbStringPtr& pString) {
    HRESULT         hr = S_OK;

    hr = Prepend(pString.m_pString);

    return(hr);
}

HRESULT CWsbStringPtr::Realloc(ULONG size)
{
    HRESULT     hr = S_OK;
    WCHAR*      tmpString;
    ULONG       currentSize;
    BOOL        bigEnough = FALSE;

    try {
        
        // We want to try to get a buffer of the size indicated.
        WsbAssert(m_pMalloc != 0, E_UNEXPECTED);
 
        // If the buffer is already bigger than the size needed, then
        // don't do anything.
        if (0 != m_pString) {
            WsbAffirmHr(GetSize(&currentSize));
            if (currentSize >= size) {
                bigEnough = TRUE;
            }
        }

        // Reallocate the buffer if we need a bigger one.
        if (!bigEnough) {
            
            // If we were given this buffer, then we can't reallocate it.
            WsbAssert(0 == m_givenSize, E_UNEXPECTED);

            // If we have never allocated a buffer, then allocate it normally.
            if (0 == m_pString) {
                WsbAffirmHr(Alloc(size));
            } else {
                WsbAssert(m_pMalloc != 0, E_UNEXPECTED);
                tmpString = (WCHAR*) WsbRealloc(m_pString, (size + 1) * sizeof(WCHAR));
                WsbAffirm(0 != tmpString, E_OUTOFMEMORY);
                m_pString = tmpString;
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::TakeFrom(WCHAR* pWchar, ULONG bufferSize)
{
    HRESULT         hr = S_OK;

    try {
        
        // Clear out any previously "taken" string.
        if (0 != m_givenSize) {
            m_pString = 0;
            m_givenSize = 0;
        }

        // If the given buffer is null, then we are responsible for allocating it.
        if (0 == pWchar) {
            if (0 != bufferSize) {
                WsbAffirmHr(Realloc(bufferSize));
            }
        }
        
        // Otherwise, we need to get rid of any buffer we had and use the one indicated.
        else {
            if (0 != m_pString) {
                WsbAffirmHr(Free());
            }
            m_pString = pWchar;

            if (0 != bufferSize) {
                m_givenSize = bufferSize;
            }
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT CWsbStringPtr::VPrintf(const WCHAR* fmtString, va_list vaList)
{
    HRESULT         hr = S_OK;

    try {
        Realloc(WSB_TRACE_BUFF_SIZE);
        vswprintf (m_pString, fmtString, vaList);
            
    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbregty.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbregty.cpp

Abstract:

    This is the implementation of registry access helper functions 
    and is a part of RsCommon.dll.

Author:

    Rohde Wakefield    [rohde]   05-Nov-1996

Revision History:

--*/

#include "stdafx.h"


HRESULT
WsbOpenRegistryKey (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  REGSAM sam,
    OUT HKEY * phKeyMachine,
    OUT HKEY * phKey
    )

/*++

Routine Description:

    Given a machine name and path, connect to obtain an HKEY
    that can be used to do registry work.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    sam - permission desired to registry key.

    phKeyMachine - return of HKEY to machine.

    phKey - return of HKEY to path.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

--*/

{
    WsbTraceIn ( L"WsbOpenRegistryKey",
        L"szMachine = '%ls', szPath = '%ls', sam = 0x%p, phKeyMachine = 0x%p, phKey = 0x%p",
        szMachine, szPath, sam, phKeyMachine, phKey );

    HRESULT hr = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        WsbAssert ( 0 != phKey, E_POINTER );
        WsbAssert ( 0 != phKeyMachine, E_POINTER );

        *phKey = *phKeyMachine = 0;
    
        WsbAffirmWin32 ( RegConnectRegistry ( (WCHAR*) szMachine, HKEY_LOCAL_MACHINE, phKeyMachine ) );

        WsbAffirmWin32 ( RegOpenKeyEx ( *phKeyMachine, szPath, 0, sam, phKey ) );


    } WsbCatchAndDo ( hr,

        //
        // Clean up from error
        //

        if ( phKeyMachine && *phKeyMachine ) {

            RegCloseKey ( *phKeyMachine );
            *phKeyMachine = 0;

        }

    ) // WsbCatchAndDo

    WsbTraceOut ( L"WsbOpenRegistryKey",
        L"HRESULT = %ls, *phKeyMachine = %ls, *phKey = %ls",
        WsbHrAsString ( hr ),
        WsbStringCopy ( WsbPtrToPtrAsString ( (void**)phKeyMachine ) ),
        WsbStringCopy ( WsbPtrToPtrAsString ( (void**)phKey ) ) );

    return ( hr );
}


HRESULT
WsbCloseRegistryKey (
    IN OUT HKEY * phKeyMachine,
    IN OUT HKEY * phKey
    )

/*++

Routine Description:

    As a companion to WsbOpenRegistryKey, close the given keys and zero
    their results.

Arguments:

    phKeyMachine - HKEY to machine.

    phKey - HKEY to path.

Return Value:

    S_OK - Success.

    E_POINTER - Invalid pointer passed in.

--*/

{
    WsbTraceIn ( L"WsbCloseRegistryKey",
        L"phKeyMachine = 0x%p, phKey = 0x%p", phKeyMachine, phKey );

    HRESULT hr = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != phKey, E_POINTER );
        WsbAssert ( 0 != phKeyMachine, E_POINTER );

        //
        // Clean up the keys
        //

        if ( *phKey ) {

            RegCloseKey ( *phKey );
            *phKey = 0;

        }

        if ( *phKeyMachine ) {

            RegCloseKey ( *phKeyMachine );
            *phKeyMachine = 0;

        }
    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbCloseRegistryKey",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbRemoveRegistryKey (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szKey
    )

/*++

Routine Description:

    This routine removes the value of a key as specified.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_FAIL - Failure occured setting the value.

    E_POINTER - invalid pointer passed in as parameter.

--*/

{
    WsbTraceIn ( L"WsbRemoveRegistryKey",
        L"szMachine = '%ls', szPath = '%ls', szKey = '%ls'",
        szMachine, szPath, szKey );

    HKEY hKeyMachine = 0,
         hKey        = 0;
    
    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        
        //
        // Open and delete the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE | DELETE, &hKeyMachine, &hKey ) );
        WsbAffirmWin32 ( RegDeleteKey ( hKey, szKey ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbRemoveRegistryKey",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbRemoveRegistryValue (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue
    )

/*++

Routine Description:

    This routine removes the value of a key as specified.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to remove.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_FAIL - Failure occured setting the value.

    E_POINTER - invalid pointer passed in as parameter.

--*/

{
    WsbTraceIn ( L"WsbRemoveRegistryValue",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls'",
        szMachine, szPath, szValue );

    HKEY hKeyMachine = 0,
         hKey        = 0;
    
    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        WsbAssert ( 0 != szValue, E_POINTER );
        
        //
        // Open and write the value in the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE, &hKeyMachine, &hKey ) );
        WsbAffirmWin32 ( RegDeleteValue ( hKey, szValue ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbRemoveRegistryValue",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbSetRegistryValueData (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN  const BYTE *pData,
    IN  DWORD cbData
    )

/*++

Routine Description:

    This routine set the value of a key as specified to the data
    given. Type of the value is REG_BINARY.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to set.

    pData - Pointer to the data buffer to copy into value.

    cbData - Number of bytes to copy from pData.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_FAIL - Failure occured setting the value.

    E_POINTER - invalid pointer passed in as parameter.

--*/

{
    WsbTraceIn ( L"WsbSetRegistryValueData",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pData = 0x%p, cbData = %ld",
        szMachine, szPath, szValue, pData, cbData );

    HKEY hKeyMachine = 0,
         hKey        = 0;
    
    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        WsbAssert ( 0 != szValue, E_POINTER );
        
        //
        // Open and write the value in the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE, &hKeyMachine, &hKey ) );
        WsbAffirmWin32 ( RegSetValueEx ( hKey, szValue, 0, REG_BINARY, pData, cbData ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbSetRegistryValueData",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbGetRegistryValueData (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT BYTE *pData,
    IN  DWORD cbData,
    OUT DWORD * pcbData OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the value of a key as specified. Type of
    the value must be REG_BINARY.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    pData - Pointer to the data buffer to copy into value.

    cbData - Size in bytes of pData.

    pcbData - number of bytes filled in pData.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured getting the value.

--*/

{
    WsbTraceIn ( L"WsbGetRegistryValueData",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pData = 0x%p, cbData = %ld, pcbData = 0x%p",
        szMachine, szPath, szValue, pData, cbData, pcbData );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath, E_POINTER );
        WsbAssert ( 0 != szValue, E_POINTER );
        WsbAssert ( 0 != pData, E_POINTER );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey ) );

        //
        // Set up temporary vars in case NULL passed for pcbData
        //
        DWORD dwType, cbData2;
        if ( !pcbData ) {

            pcbData = &cbData2;

        }

        //
        // Query for the REG_BINARY value
        //

        *pcbData = cbData;
        WsbAffirmWin32 ( RegQueryValueEx ( hKey, szValue, 0, &dwType, pData, pcbData ) );

        WsbAffirm ( REG_BINARY == dwType, E_FAIL );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbGetRegistryValueData",
        L"HRESULT = %ls, *pcbData = %ls", WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pcbData ) );

    return ( hr );
}


HRESULT
WsbSetRegistryValueString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN  const OLECHAR * szString,
    IN        DWORD     dwType
    )

/*++

Routine Description:

    This routine set the value of a key as specified to the data
    given. Type of the value is dwType (defaults to REG_SZ)

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to set.

    szString - The string to place in the value.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbSetRegistryValueString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', szString = '%ls'",
        szMachine, szPath, szValue, szString );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        WsbAssert ( 0 != szValue,   E_POINTER );
        WsbAssert ( 0 != szString,  E_POINTER );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE, &hKeyMachine, &hKey ) );

        WsbAffirmWin32 ( RegSetValueEx ( hKey, szValue, 0, dwType, (BYTE*)szString, ( wcslen ( szString ) + 1 ) * sizeof ( OLECHAR ) ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbSetRegistryValueString",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbGetRegistryValueString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT OLECHAR * szString,
    IN  DWORD cSize,
    OUT DWORD *pcLength OPTIONAL
    )

/*++

Routine Description:

    This routine get the value specified
    Type of the value must be REG_SZ or REG_EXPAND_SZ

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    szString - The string buffer to fill with the value.

    cSize - Size of szString in OLECAHR's.

    pcLength - Number of OLECHAR actually written (without L'\0').

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbGetRegistryValueString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', szString = 0x%p, cSize = '%ld', pcLength = 0x%p",
        szMachine, szPath, szValue, szString, cSize, pcLength );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        WsbAssert ( 0 != szValue,   E_POINTER );
        WsbAssert ( 0 != szString,  E_POINTER );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey ) );


        //
        // Temporary size vars in case pcLength is NULL
        //

        DWORD dwType, cbData2;
        if ( !pcLength ) {

            pcLength = &cbData2;

        }

        //
        // And do the query
        //

        *pcLength = cSize * sizeof ( OLECHAR );
        WsbAffirmWin32 ( RegQueryValueEx ( hKey, szValue, 0, &dwType, (BYTE*)szString, pcLength ) ) ;

        WsbAffirm ( (REG_SZ == dwType) || (REG_EXPAND_SZ == dwType), E_FAIL );

        //
        // return characters, not bytes
        //

        *pcLength = ( *pcLength / sizeof ( OLECHAR ) ) - 1;

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbGetRegistryValueString",
        L"HRESULT = %ls, szString = '%ls', *pcbLength = %ls",
        WsbHrAsString ( hr ), szString, WsbPtrToUlongAsString ( pcLength ) );

    return ( hr );
}

HRESULT
WsbGetRegistryValueMultiString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT OLECHAR * szMultiString,
    IN  DWORD cSize,
    OUT DWORD *pcLength OPTIONAL
    )

/*++

Routine Description:

    This routine get the value specified
    Type of the value must be REG_MULTI_SZ

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    szMultiString - The string buffer to fill with the value.

    cSize - Size of szString in OLECAHR's.

    pcLength - Number of OLECHAR actually written (without L'\0').

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbGetRegistryValueMultiString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', szMultiString = 0x%p, cSize = '%ld', pcLength = 0x%p",
        szMachine, szPath, szValue, szMultiString, cSize, pcLength );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        WsbAssert ( 0 != szValue,   E_POINTER );
        WsbAssert ( 0 != szMultiString,  E_POINTER );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey ) );


        //
        // Temporary size vars in case pcLength is NULL
        //

        DWORD dwType, cbData2;
        if ( !pcLength ) {

            pcLength = &cbData2;

        }

        //
        // And do the query
        //

        *pcLength = cSize * sizeof ( OLECHAR );
        WsbAffirmWin32 ( RegQueryValueEx ( hKey, szValue, 0, &dwType, (BYTE*)szMultiString, pcLength ) ) ;

        WsbAffirm ( REG_MULTI_SZ == dwType, E_FAIL );

        //
        // return characters, not bytes
        //

        *pcLength = ( *pcLength / sizeof ( OLECHAR ) ) - 1;

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbGetRegistryValueMultiString",
        L"HRESULT = %ls, *pcbLength = %ls",
        WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pcLength ) );

    return ( hr );
}


HRESULT
WsbSetRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        DWORD     dw
    )

/*++

Routine Description:

    This routine set the value of a key as specified to the data
    given. Type of the value is REG_DWORD

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to set.

    dw - DWORD value to store.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbSetRegistryValueDWORD",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', dw = %lu [0x%p]",
        szMachine, szPath, szValue, dw, dw );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssertPointer( szPath );
        WsbAssertPointer( szValue );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_SET_VALUE, &hKeyMachine, &hKey ) );

        WsbAffirmWin32 ( RegSetValueEx ( hKey, szValue, 0, REG_DWORD, (BYTE*)&dw, sizeof( DWORD ) ) );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbSetRegistryValueDWORD",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbGetRegistryValueDWORD(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       DWORD *   pdw
    )

/*++

Routine Description:

    This routine set the value of a key as specified to the data
    given. Type of the value is REG_SZ or REG_EXPAND_SZ

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    pdw - pointer to a DWORD to store value in.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbGetRegistryValueDWORD",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pdw = 0x%p",
        szMachine, szPath, szValue, pdw );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssertPointer( szPath );
        WsbAssertPointer( szValue );
        WsbAssertPointer( pdw );
        
        //
        // Open the key
        //

        WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey ) );


        //
        // And do the query
        //

        DWORD dwType, cbData = sizeof( DWORD );
        WsbAffirmWin32 ( RegQueryValueEx ( hKey, szValue, 0, &dwType, (BYTE*)pdw, &cbData ) ) ;

        WsbAffirm( REG_DWORD == dwType, E_FAIL );

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbGetRegistryValueDWORD",
        L"HRESULT = %ls, *pdw = %ls",
        WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pdw ) );

    return ( hr );
}


HRESULT
WsbAddRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        DWORD     adw
    )

/*++

Routine Description:

    This routine adds an amount to a  registry value.
    Type of the value must be REG_DWORD

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to increment

    adw - DWORD value to add.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbAddRegistryValueDWORD",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', adw = %lu",
        szMachine, szPath, szValue, adw);

    HRESULT hr    = S_OK;
    DWORD   value = 0;

    //  Get the old value
    hr = WsbGetRegistryValueDWORD(szMachine, szPath, szValue, &value);

    //  Add to value and replace
    if (S_OK == hr) {
        value += adw;
    } else {
        value = adw;
    }
    hr = WsbSetRegistryValueDWORD(szMachine, szPath, szValue, value);

    WsbTraceOut ( L"WsbAddRegistryValueDWORD",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbIncRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue
    )

/*++

Routine Description:

    This routine increments a registry value by one.
    Type of the value must be REG_DWORD

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to increment

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    WsbTraceIn ( L"WsbIncRegistryValueDWORD",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls'",
        szMachine, szPath, szValue);

    HRESULT hr       = S_OK;

    hr = WsbAddRegistryValueDWORD(szMachine, szPath, szValue, 1);

    WsbTraceOut ( L"WsbIncRegistryValueDWORD",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbCheckIfRegistryKeyExists(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath
    )

/*++

Routine Description:

    This routine  check if the supplied key exists
    If the key already exists, S_OK is returned.
    If it needed to be created, S_FALSE is returned.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

Return Value:

    S_OK - Connection made, Key already exists.

    S_FALSE - Connection made, key did not exist but was created

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured creating the key.

--*/

{
    WsbTraceIn ( L"WsbCheckIfRegistryKeyExists",
        L"szMachine = '%ls', szPath = '%ls'", szMachine, szPath );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        
        //
        // Open the key
        //

        HRESULT resultOpen = WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey );

        //
        // If key could be opened, everything is fine - return S_OK
        //

        if ( SUCCEEDED ( resultOpen ) ) {
            hr = S_OK;
            WsbCloseRegistryKey ( &hKeyMachine, &hKey );
        } else {
            hr = S_FALSE;
        }

    } WsbCatch ( hr )


    WsbTraceOut ( L"WsbCheckIfRegistryKeyExists",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbEnsureRegistryKeyExists (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath
    )

/*++

Routine Description:

    This routine creates the key specified by szPath. Multiple 
    levels in the path can be missing and thus created. If the
    key already exists, S_OK is returned. If it needed to be
    created, S_FALSE is returned.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

Return Value:

    S_OK - Connection made, Key already exists.

    S_FALSE - Connection made, key did not exist but was created

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured creating the key.

--*/

{
    WsbTraceIn ( L"WsbEnsureRegistryKeyExists",
        L"szMachine = '%ls', szPath = '%ls'", szMachine, szPath );

    HKEY hKeyMachine = 0,
         hKey        = 0;

    HRESULT hr       = S_OK;

    try {

        //
        // Ensure parameters are valid
        //

        WsbAssert ( 0 != szPath,    E_POINTER );
        
        //
        // Open the key
        //

        HRESULT resultOpen = WsbOpenRegistryKey ( szMachine, szPath, KEY_QUERY_VALUE, &hKeyMachine, &hKey );

        //
        // If key could be opened, everything is fine - return S_OK
        //

        if ( SUCCEEDED ( resultOpen ) ) {

            hr = S_OK;

        } else {

            //
            // Otherwise, we need to start at root and create missing portion
            //
            
            //
            // Create a copy of the string. Using WsbQuickString so we have
            // automatic freeing of memory
            //
            
            WsbQuickString copyString ( szPath );
            WCHAR * pSubKey = copyString;
            
            WsbAffirm ( 0 != pSubKey, E_OUTOFMEMORY );
            
            DWORD result, createResult;
            HKEY  hSubKey;

            WsbAffirmHr ( WsbOpenRegistryKey ( szMachine, L"", KEY_CREATE_SUB_KEY, &hKeyMachine, &hKey ) );
            
            pSubKey = wcstok ( pSubKey, L"\\" );

            while ( 0 != pSubKey ) {
            
                //
                // Create the key. If it exists, RegCreateKeyEx returns 
                // REG_OPENED_EXISTING_KEY which is ok here.
                //

                createResult = 0;

                result = RegCreateKeyEx ( hKey, pSubKey, 0, L"", 
                    REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY, 0, &hSubKey, &createResult );

                WsbAffirm ( ERROR_SUCCESS == result, E_FAIL );

                WsbAffirm (
                    ( REG_CREATED_NEW_KEY     == createResult ) ||
                    ( REG_OPENED_EXISTING_KEY == createResult), E_FAIL );
            
                //
                // And move this hkey to be the next parent
                //
            
                RegCloseKey ( hKey );
                hKey = hSubKey;
                hSubKey = 0;
            
                //
                // And finally, find next token
                //

                pSubKey = wcstok ( 0, L"\\" );

            };
            
            //
            // If we succeeded to this point, return S_FALSE
            // for successfull creation of path
            //
            
            hr = S_FALSE;
        }

    } WsbCatch ( hr )

    WsbCloseRegistryKey ( &hKeyMachine, &hKey );

    WsbTraceOut ( L"WsbEnsureRegistryKeyExists",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbSetRegistryValueUlongAsString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        ULONG     value
    )

/*++

Routine Description:

    This routine puts a ULONG value in the registry as a string value.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to set.

    value - ULONG value to store.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    HRESULT hr       = S_OK;

    WsbTraceIn ( L"WsbSetRegistryValueUlongAsString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', value = %lu",
        szMachine, szPath, szValue, value );

    try {
        OLECHAR      dataString[100];

        WsbAffirmHr(WsbEnsureRegistryKeyExists(szMachine, szPath));
        wsprintf(dataString, OLESTR("%lu"), value);
        WsbAffirmHr(WsbSetRegistryValueString (szMachine, szPath, szValue,
                dataString, REG_SZ));
    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbSetRegistryValueUlongAsString",
        L"HRESULT = %ls", WsbHrAsString ( hr ) );

    return ( hr );
}


HRESULT
WsbGetRegistryValueUlongAsString(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       ULONG *   pvalue
    )

/*++

Routine Description:

    This routine gets a string value from the registry and converts
    it to a ULONG value.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    pvalue - pointer to a ULONG to store value in.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    HRESULT      hr = S_OK;

    WsbTraceIn ( L"WsbGetRegistryValueUlongAsString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pvalue = 0x%p",
        szMachine, szPath, szValue, pvalue );

    try {
        OLECHAR      dataString[100];
        DWORD        sizeGot;
        OLECHAR *    stopString;

        WsbAssertPointer( pvalue );
        
        WsbAffirmHr(WsbGetRegistryValueString(szMachine, szPath, szValue,
                dataString, 100, &sizeGot));
        *pvalue  = wcstoul( dataString,  &stopString, 10 );

    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbGetRegistryValueUlongAsString",
        L"HRESULT = %ls, *pvalue = %ls",
        WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pvalue ) );

    return ( hr );
}

HRESULT
WsbGetRegistryValueUlongAsMultiString(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       ULONG **  ppValues,
    OUT       ULONG *   pNumValues
    )

/*++

Routine Description:

    This routine gets a multi-string value from the registry and converts
    it to a vector of ULONG values.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    ppvalues - pointer to a ULONG * to alloacte and store the output vector in

    pNumValues - Number of items returned

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured getting the value.

--*/

{
    HRESULT      hr = S_OK;

    WsbTraceIn ( L"WsbGetRegistryValueUlongAsString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls'",
        szMachine, szPath, szValue );

    try {
        OLECHAR      dataString[256];
        DWORD        sizeGot;
        OLECHAR *    stopString;

        WsbAssertPointer(ppValues);
        WsbAssertPointer(pNumValues);

        *pNumValues = 0;
        *ppValues = NULL;

        WsbAffirmHr(WsbGetRegistryValueMultiString(szMachine, szPath, szValue,
                dataString, 256, &sizeGot));

        // Build the output vector
        OLECHAR *currentString = dataString;
        int size = 10;
        if ((*currentString) != NULL) {
            // first alocation
            *ppValues = (ULONG *)WsbAlloc(size*sizeof(ULONG));
            WsbAffirm(*ppValues != 0, E_OUTOFMEMORY);
        } else {
            hr = E_FAIL;
        }

        while ((*currentString) != NULL) {
            (*ppValues)[*pNumValues]  = wcstoul( currentString,  &stopString, 10 );
            (*pNumValues)++;

            if (*pNumValues == size) {
                size += 10;
                ULONG* pTmp = (ULONG *)WsbRealloc(*ppValues, size*sizeof(ULONG));
                WsbAffirm(0 != pTmp, E_OUTOFMEMORY);
                *ppValues = pTmp;
            }

            currentString += wcslen(currentString);
            currentString ++;
        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbGetRegistryValueUlongAsString",
        L"HRESULT = %ls, num values = %lu",
        WsbHrAsString ( hr ), *pNumValues );

    return ( hr );
}


HRESULT
WsbRegistryValueUlongAsString(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN OUT    ULONG *   pvalue
    )

/*++

Routine Description:

    If a registry string value is present, this routine gets it and converts
    it to a ULONG value.  If it is not present, this routine sets it to the
    supplied default value.

Arguments:

    szMachine - Name of computer to connect to.

    szPath - Path inside registry to connect to.

    szValue - Name of the value to get.

    pvalue - In: default value , Out: pointer to a ULONG to store value.

Return Value:

    S_OK - Connection made, Success.

    CO_E_OBJNOTCONNECTED - could not connect to registry or key.

    E_POINTER - invalid pointer in parameters.

    E_FAIL - Failure occured setting the value.

--*/

{
    HRESULT      hr = S_OK;

    WsbTraceIn ( L"WsbRegistryValueUlongAsString",
        L"szMachine = '%ls', szPath = '%ls', szValue = '%ls', pvalue = 0x%p",
        szMachine, szPath, szValue, pvalue );

    try {
        ULONG l_value;
        
        WsbAssertPointer( pvalue );
        
        if (S_OK == WsbGetRegistryValueUlongAsString(szMachine, szPath, szValue,
                &l_value)) {
            *pvalue = l_value;
        } else {
            WsbAffirmHr(WsbSetRegistryValueUlongAsString(szMachine, szPath, 
                    szValue, *pvalue));
        }

    } WsbCatch ( hr )

    WsbTraceOut ( L"WsbRegistryValueUlongAsString",
        L"HRESULT = %ls, *pvalue = %ls",
        WsbHrAsString ( hr ), WsbPtrToUlongAsString ( pvalue ) );

    return ( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbshrt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbshrt.h

Abstract:

    This component is an object representations of the SHORT standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBSHORT_
#define _WSBSHORT_

/*++

Class Name:
    
    CWsbShort

Class Description:

    An object representations of the SHORT standard type. It
    is both persistable and collectable.

--*/

class CWsbShort : 
    public CWsbObject,
    public IWsbShort,
    public CComCoClass<CWsbShort,&CLSID_CWsbShort>
{
public:
    CWsbShort() {}
BEGIN_COM_MAP(CWsbShort)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbShort)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbShort)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbShort)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbShort
public:
    STDMETHOD(CompareToShort)(SHORT value, SHORT* pResult);
    STDMETHOD(CompareToIShort)(IWsbShort* pShort, SHORT* pResult);
    STDMETHOD(GetShort)(SHORT* pValue);
    STDMETHOD(SetShort)(SHORT value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    SHORT           m_value;
};

#endif // _WSBSHORT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbshrt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbshrt.cpp

Abstract:

    This component is an object representations of the SHORT standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbshrt.h"


HRESULT
CWsbShort::CompareToShort(
    IN SHORT value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbShort::CompareToShort

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbShort::CompareToShort"), OLESTR("value = <%ld>"), value);

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbShort::CompareToShort"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbShort::CompareToIShort(
    IN IWsbShort* pShort,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbShort::CompareToIShort

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       value;

    WsbTraceIn(OLESTR("CWsbShort::CompareToIShort"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pShort, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pShort->GetShort(&value));
        hr = CompareToShort(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::CompareToIShort"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbShort::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbShort*  pShort;

    WsbTraceIn(OLESTR("CWsbShort::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbShort interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbShort, (void**) &pShort));
        hr = CompareToIShort(pShort, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::CompareTo"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbShort::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = 0;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbShort::GetShort(
    OUT SHORT* pValue
    )

/*++

Implements:

  IWsbShort::GetShort

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::GetShort"), OLESTR(""));

    try {

        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::GetShort"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbShort::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbShort;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbShort::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(SHORT);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbShort::Load(
    IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));      

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::Load"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);

    return(hr);
}


HRESULT
CWsbShort::Save(
    IStream* pStream,
    BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbShort::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));     

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbShort::SetShort(
    SHORT value
    )

/*++

Implements:

  IWsbShort::SetShort

--*/
{
    WsbTraceIn(OLESTR("CWsbShort::SetShort"), OLESTR("value = <%ld>"), value);

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbShort::SetShort"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbShort::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbShort>      pShort1;
    CComPtr<IWsbShort>      pShort2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    SHORT                   value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbShort::Test"), OLESTR(""));

    try {

        // Get the pShort interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbShort*) this)->QueryInterface(IID_IWsbShort, (void**) &pShort1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pShort1->SetShort(32000));
                WsbAffirmHr(pShort1->GetShort(&value));
                WsbAssert(value == 32000, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbShort, NULL, CLSCTX_ALL, IID_IWsbShort, (void**) &pShort2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pShort2->GetShort(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(-767));
                    WsbAffirmHr(pShort2->SetShort(-767));
                    WsbAssert(pShort1->IsEqual(pShort2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(767));
                    WsbAffirmHr(pShort2->SetShort(-767));
                    WsbAssert(pShort1->IsEqual(pShort2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(-900));
                    WsbAffirmHr(pShort2->SetShort(-900));
                    WsbAssert((pShort1->CompareTo(pShort2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(-900));
                    WsbAffirmHr(pShort2->SetShort(-400));
                    WsbAssert((pShort1->CompareTo(pShort2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->SetShort(15000));
                    WsbAffirmHr(pShort2->SetShort(10000));
                    WsbAssert((pShort1->CompareTo(pShort2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pShort1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pShort2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pShort2->SetShort(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbShort.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pShort1->SetShort(-888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbShort.tst"), 0));
                        WsbAssert(pShort1->CompareToShort(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbShort::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbstrg.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbstrg.cpp

Abstract:

    This component is an object representations of the STRING standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbstrg.h"


HRESULT
CWsbString::CompareToString(
    IN OLECHAR* value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbString::CompareToString
    
--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbString::CompareToString"), OLESTR("value = <%ls>"), value);

    // Comapre the two strings, and do the null checking in case the clib
    // can't handle it. If there are two valid strings, then use this objects
    // isCaseDependent flag to determine how to compare the values.
    if (0 == value) {
        if (m_value == 0) {
            result = 0;
        } else {
            result = 1;
        }

    } else {
        if (m_value == 0) {
            result = -1;
        } else {
            if (m_isCaseDependent) {
                result = (SHORT)wcscmp(m_value, value);
            }
            else {
                result = (SHORT)_wcsicmp(m_value, value);
            }
        }
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (0 != pResult) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbString::CompareToString"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbString::CompareToIString(
    IN IWsbString* pString,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbString::CompareToIString
    
--*/
{
    HRESULT         hr = E_FAIL;
    CWsbStringPtr   value;

    WsbTraceIn(OLESTR("CWsbString::CompareToIString"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pString, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pString->GetString(&value, 0));
        hr = CompareToString(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::CompareToIString"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbString::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbString* pString;

    WsbTraceIn(OLESTR("CWsbString::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbString interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbString, (void**) &pString));

        hr = CompareToIString(pString, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbString::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_isCaseDependent = TRUE;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbString::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbString;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbString::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(ULONG) + WsbPersistSize((wcslen(m_value) + 1) * sizeof(OLECHAR));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbString::GetString(
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IWsbString::GetString
    
--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::GetString"), OLESTR(""));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        WsbAffirmHr(m_value.CopyTo(pValue, bufferSize));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::GetString"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbString::GetStringAndCase(
    OUT OLECHAR** pValue,
    OUT BOOL* pIsCaseDependent,
    IN ULONG bufferSize
    )

/*++

Implements:

  IWsbString::GetStringAndCase

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::GetString"), OLESTR(""));

    try {
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(0 != pIsCaseDependent, E_POINTER);
        WsbAffirmHr(m_value.CopyTo(pValue, bufferSize));
        *pIsCaseDependent = m_isCaseDependent;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::GetString"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbString::IsCaseDependent(
    void
    )

/*++

Implements:

  IWsbString::IsCaseDependent

--*/
{
    WsbTraceIn(OLESTR("CWsbString::IsCaseDependent"), OLESTR(""));

    WsbTraceOut(OLESTR("CWsbString::IsCaseDependent"), OLESTR("isCaseDependent = <%ls>"), WsbBoolAsString(m_isCaseDependent));
  
    return(m_isCaseDependent ? S_OK : S_FALSE);
}


HRESULT
CWsbString::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // First get CaseDependent flag.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isCaseDependent));

        // Now get the string.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value, 0));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::Load"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(&m_value));

    return(hr);
}


HRESULT
CWsbString::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);
        
        // First save the  CaseDependent flag.
        WsbAffirmHr(WsbSaveToStream(pStream, m_isCaseDependent));

        // Now save the string.
        WsbAffirmHr(WsbSaveToStream(pStream, (OLECHAR*)m_value));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbString::SetIsCaseDependent(
    BOOL isCaseDependent
    )

/*++

Implements:

  IWsbString::SetIsCaseDependent

--*/
{
    WsbTraceIn(OLESTR("CWsbString::SetIsCaseDependent"), OLESTR("value = <%ls>"), WsbBoolAsString(isCaseDependent));

    m_isDirty = TRUE;
    m_isCaseDependent = isCaseDependent;

    WsbTraceOut(OLESTR("CWsbString::SetIsCaseDependent"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbString::SetString(
    IN OLECHAR* value
    )

/*++

Implements:

  IWsbString::SetString

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::SetString"), OLESTR("value = <%ls>"), WsbPtrToStringAsString(&value));

    try {

        m_value = value;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::SetString"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbString::SetStringAndCase(
    IN OLECHAR* value,
    IN BOOL isCaseDependent
    )

/*++

Implements:

  IWsbString::SetStringAndCase

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbString::SetStringAndCase"), OLESTR("value = <%ls>, isCaseDependent = <%ls>"), WsbPtrToStringAsString(&value), WsbBoolAsString(isCaseDependent));

    try {

        m_value = value;
        m_isDirty = TRUE;
        m_isCaseDependent = isCaseDependent;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbString::SetStringAndCase"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbString::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbString>     pString1;
    CComPtr<IWsbString>     pString2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    OLECHAR*                value = NULL;
    BOOL                    isCaseDependent;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbString::Test"), OLESTR(""));

    try {

        // Get the pString interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbString*) this)->QueryInterface(IID_IWsbString, (void**) &pString1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pString1->SetString(OLESTR("Test Case")));
                WsbAffirmHr(pString1->GetString(&value, 0));
                WsbAssert(wcscmp(value, OLESTR("Test Case")) == 0, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Set the case dependence flag.
            hr = S_OK;
            try {
                WsbAffirmHr(pString1->SetIsCaseDependent(FALSE));
                WsbAssert(pString1->IsCaseDependent() == S_FALSE, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
            
            hr = S_OK;
            try {
                WsbAffirmHr(pString1->SetIsCaseDependent(TRUE));
                WsbAssert(pString1->IsCaseDependent() == S_OK, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Set Both string and case
            hr = S_OK;
            try {
                WsbAffirmHr(pString1->SetStringAndCase(OLESTR("Both"), FALSE));
                WsbAffirmHr(pString1->GetStringAndCase(&value, &isCaseDependent, 0));
                WsbAssert((wcscmp(value, OLESTR("Both")) == 0) && (isCaseDependent == FALSE), E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbString, NULL, CLSCTX_ALL, IID_IWsbString, (void**) &pString2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pString2->GetStringAndCase(&value, &isCaseDependent, 0));
                    WsbAssert((wcscmp(value, OLESTR("")) == 0) && isCaseDependent, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), TRUE));
                    WsbAffirmHr(pString2->SetStringAndCase(OLESTR("HiJk"), FALSE));
                    WsbAssert(pString1->IsEqual(pString2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), TRUE));
                    WsbAffirmHr(pString2->SetStringAndCase(OLESTR("HIJK"), FALSE));
                    WsbAssert(pString1->IsEqual(pString2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), FALSE));
                    WsbAffirmHr(pString2->SetStringAndCase(OLESTR("HiJk"), TRUE));
                    WsbAssert(pString1->IsEqual(pString2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), FALSE));
                    WsbAffirmHr(pString2->SetStringAndCase(OLESTR("HIJK"), TRUE));
                    WsbAssert(pString1->IsEqual(pString2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("HiJk"), TRUE));
                    WsbAffirmHr(pString2->SetString(OLESTR("HiJk")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("AABC"), TRUE));
                    WsbAffirmHr(pString2->SetString(OLESTR("ABCC")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("BBC"), TRUE));
                    WsbAffirmHr(pString2->SetString(OLESTR("ABCC")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("abcc"), TRUE));
                    WsbAffirmHr(pString2->SetString(OLESTR("ABCC")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->SetStringAndCase(OLESTR("abcc"), FALSE));
                    WsbAffirmHr(pString2->SetString(OLESTR("ABCC")));
                    WsbAssert((pString1->CompareTo(pString2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef STRG_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pString1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pString2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pString2->SetStringAndCase(OLESTR("The quick brown fox."), TRUE));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbString.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pString1->SetStringAndCase(OLESTR("jumped over the lazy dog."), FALSE));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbString.tst"), 0));
                        WsbAssert(pString1->CompareToString(OLESTR("The quick brown fox."), NULL) == S_OK, E_FAIL);
                        WsbAssert(pString1->IsCaseDependent() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    // If we used the temporary string buffer, then free it now.
    if (0 != value) {
        WsbFree(value);
    }

    WsbTraceOut(OLESTR("CWsbString::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbpstbl.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbpstbl.cpp

Abstract:

    Abstract classes that provides persistence methods.


Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"

#include "wsbport.h"
#include "wsbpstbl.h"
#include "wsbtrak.h"

#define BYTE_SIZE           64          // Larger than largest BYTE_SIZE_*
#define PERSIST_CHECK_VALUE 0x456D5377  // ASCII: "EmSw" (Eastman Software)

//  Local functions
static BOOL WsbFileExists(OLECHAR* pFileName);


// ******** CWsbPersistStream ************

#pragma optimize("g", off)

HRESULT
CWsbPersistStream::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        // Initialize some member data.
        m_isDirty       = TRUE;

        //  Add class to object table
        GUID guid;
        if (S_OK != GetClassID(&guid)) {
            guid = GUID_NULL;
        }
        WSB_OBJECT_ADD(guid, this);

    } WsbCatch(hr);

    return(hr);
}
#pragma optimize("", on)


void
CWsbPersistStream::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    //  Subtract class from object table
    GUID guid;
    if (S_OK != GetClassID(&guid)) {
        guid = GUID_NULL;
    }
    WSB_OBJECT_SUB(guid, this);

    CComObjectRoot::FinalRelease();
}

#if defined(WSB_TRACK_MEMORY)
ULONG
CWsbPersistStream::InternalAddRef(
    )
{
    WsbTraceIn( L"CWsbPersistStream::InternalAddRef", L"this = %p", 
            static_cast<void *>(this) );

    ULONG retval = CComObjectRoot::InternalAddRef( );

    WsbTraceOut( L"CWsbPersistStream::InternalAddRef", L"retval = %lu", retval);
    return( retval );
}

ULONG
CWsbPersistStream::InternalRelease(
    )
{
    WsbTraceIn( L"CWsbPersistStream::InternalRelease", L"this = %p", 
            static_cast<void *>(this) );

    ULONG retval = CComObjectRoot::InternalRelease( );

    WsbTraceOut( L"CWsbPersistStream::InternalRelease", L"retval = %lu", retval);
    return( retval );
}
#endif


HRESULT
CWsbPersistStream::IsDirty(
    void
    )

/*++

Implements:

  IPersistStream::IsDirty().

--*/
{
    HRESULT     hr = S_FALSE;

    WsbTraceIn(OLESTR("CWsbPersistStream::IsDirty"), OLESTR(""));
    
    if (m_isDirty) {
        hr = S_OK;
    }
    
    WsbTraceOut(OLESTR("CWsbPersistStream::IsDirty"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CWsbPersistStream::SetIsDirty(
    IN BOOL isDirty
    )

/*++

Implements:

  IWsbPersistable::SetIsDirty().

--*/
{
    WsbTraceIn(OLESTR("CWsbPersistable::SetIsDirty"), OLESTR("isDirty = <%ls>"), WsbBoolAsString(isDirty));

    m_isDirty = isDirty;

    WsbTraceOut(OLESTR("CWsbPersistable::SetIsDirty"), OLESTR(""));

    return(S_OK);
}



// ******** CWsbPersistable ************


HRESULT
CWsbPersistable::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAffirmHr(CWsbPersistStream::FinalConstruct());

        // Initialize some member data.
        m_persistState          = WSB_PERSIST_STATE_UNINIT;

    } WsbCatch(hr);

    return(hr);
}


void
CWsbPersistable::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT     hr = S_OK;
    
    CWsbPersistStream::FinalRelease();
}


HRESULT
CWsbPersistable::GetCurFile(
    OUT OLECHAR** pFileName
    )

/*++

Implements:

  IPersistFile::GetCurFile().

--*/
{
    HRESULT     hr = S_OK;

    // Make sure that the string is returned into newly allocated
    // memory (or not at all).
    *pFileName = NULL;
    
    try {
        ULONG  Size;

        WsbAffirm(m_persistState != WSB_PERSIST_STATE_UNINIT, E_UNEXPECTED);

        // Retrieve the actual name if one is specifed or the default name
        // if one has not been specified.
        WsbAffirmHr(m_persistFileName.GetSize(&Size));
        if (Size > 0) {
            WsbAffirmHr(WsbAllocAndCopyComString(pFileName, m_persistFileName, 0));
        } else {
            WsbAffirmHr(GetDefaultFileName(pFileName, 0));
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CWsbPersistable::GetDefaultFileName(
    OUT OLECHAR** pFileName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IWsbPersistable::GetDefaultFileName().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbPersistable::GetDefaultFileName"), OLESTR("bufferSize = <%lu>"), bufferSize);
   
    try {
        ULONG  Size;

        // If we haven't read the default in from the resource file, then
        // do so now.
        WsbAffirmHr(m_persistDefaultName.GetSize(&Size));
        if (Size == 0) {
            WsbAffirmHr(m_persistDefaultName.LoadFromRsc(_Module.m_hInst, IDS_WSBPERSISTABLE_DEF_FILE));
        }

        WsbAffirmHr(WsbAllocAndCopyComString(pFileName, m_persistDefaultName, bufferSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbPersistable::GetDefaultFileName"), OLESTR("hr = <%ls>, FileName = <%ls>"), WsbHrAsString(hr), pFileName);
    
    return(hr);
}


HRESULT
CWsbPersistable::Load(
    IN LPCOLESTR fileName,
    IN DWORD mode
    )

/*++

Implements:

  IPersistFile::Load().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IStream>                pStream;
    CLSID                           clsid;
    CLSID                           clsidFile;
    CComPtr<IRunningObjectTable>    pROT;
    CComPtr<IMoniker>               pMoniker;

    WsbTraceIn(OLESTR("CWsbPersistable::Load"), OLESTR("fileName = <%ls>, mode = <%lx>> m_persistState = <%d>"), 
                    fileName, mode, m_persistState);

    try {
        CComPtr<IPersistStream> pIPersistStream;

        WsbAffirm(m_persistState == WSB_PERSIST_STATE_UNINIT,  E_UNEXPECTED);
        WsbAffirm(fileName,  E_UNEXPECTED);
     
        // Open a storage on the file where the data is stored.
        if (0 == mode) {
            WsbAffirmHr(StgOpenStorageEx(fileName, STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                    STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (void**)&m_persistStorage));
        }
        else {
            WsbAffirmHr(StgOpenStorageEx(fileName, mode, 
                    STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (void**)&m_persistStorage));
        }

        // Get the IPersistStream interface.
        WsbAffirmHr(((IUnknown*)(IWsbPersistable*) this)->QueryInterface(IID_IPersistStream, (void**) &pIPersistStream));

        // Open a stream.
        WsbAffirmHr(m_persistStorage->OpenStream(WSB_PERSIST_DEFAULT_STREAM_NAME, NULL, STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                0, &pStream));
            
        // Load the object using the IPersistStream::Load() method, checking
        // to make sure the CLSID is correct.
        WsbAffirmHr(pIPersistStream->GetClassID(&clsid));
        WsbAffirmHr(ReadClassStm(pStream, &clsidFile));
        WsbAffirm(clsid == clsidFile, WSB_E_STREAM_ERROR);
        
        WsbAffirmHr(pIPersistStream->Load(pStream));

        //  Check that we got everything by reading a special ULONG
        //  that should be at the end
        ULONG check_value;
        WsbAffirmHr(WsbLoadFromStream(pStream, &check_value));
        WsbAffirm(check_value == PERSIST_CHECK_VALUE, WSB_E_PERSISTENCE_FILE_CORRUPT);

        // We are now in the normal state.
        m_persistFileName = fileName;
        m_persistState = WSB_PERSIST_STATE_NORMAL;

        m_persistStream = pStream;
    
    } WsbCatchAndDo(hr,
        //
        // Set the storage pointer to null on an error to make sure the file is closed.
        //
        m_persistStorage = NULL;

    );

    WsbTraceOut(OLESTR("CWsbPersistable::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbPersistable::ReleaseFile(
    void
    )

/*++

Implements:

  IWsbPersistable::ReleaseFile().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbPersistable::ReleaseFile"), OLESTR(""));
   
    try {
        WsbAffirm(m_persistState != WSB_PERSIST_STATE_UNINIT, E_UNEXPECTED);

        // Try to make sure changes are committed
        if (m_persistStream) {
            m_persistStream->Commit(STGC_DEFAULT);
        }
        if (m_persistStorage) {
            m_persistStorage->Commit(STGC_DEFAULT);
        }
        
        // Release the resources that we have been holding open.
        m_persistStream = NULL;
        m_persistStorage = NULL;
        m_persistFileName.Free();

        m_persistState = WSB_PERSIST_STATE_RELEASED;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbPersistable::ReleaseFile"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT CWsbPersistable::Save(
    IN LPCOLESTR fileName,
    IN BOOL remember
    )

/*++

Implements:

  IPersistFile::Save().

--*/
{
    HRESULT             hr = S_OK;
    OLECHAR*            name;
    BOOL                create = FALSE;
    CComPtr<IStream>    pStream;
    CLSID               clsid;
    
    WsbTraceIn(OLESTR("CWsbPersistable::Save"), OLESTR("fileName = <%ls>, remember = <%ls>"), WsbPtrToStringAsString((OLECHAR**) &fileName), WsbBoolAsString(remember));

    try {
        CComPtr<IPersistStream> pIPersistStream;
    
        // Make sure that we are in the right state.
        WsbAffirm(((m_persistState == WSB_PERSIST_STATE_UNINIT) ||
                    (m_persistState == WSB_PERSIST_STATE_NORMAL) ||
                    (m_persistState == WSB_PERSIST_STATE_RELEASED)),
                  E_UNEXPECTED);

        WsbAssert((m_persistState == WSB_PERSIST_STATE_NORMAL) || (0 != fileName), E_POINTER);

        // If they supplied a name use it,
        if ((m_persistState == WSB_PERSIST_STATE_UNINIT) ||
                (m_persistState == WSB_PERSIST_STATE_RELEASED)) {
            
            // We need to create a new file based on the name
            // that they gave us.
            name = (OLECHAR*) fileName;
            create = TRUE;
        } else {

            // If they gave a name and it is different than what we have
            // stored, then we need to create a new file.
            if ((0 != fileName) && (_wcsicmp(m_persistFileName, fileName) != 0)) {
                name = (OLECHAR*) fileName;
                create = TRUE;
            }
          
            // Otherwise, use the stored name.
            else {
                name = m_persistFileName;
            }
        }

        // We should now have a file name and know whether to open or
        // create a file.
        if (create) {
            WsbAffirmHr(StgCreateStorageEx(name, STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 
                    STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (void**)&m_persistStorage));
            WsbAffirmHr(m_persistStorage->CreateStream(WSB_PERSIST_DEFAULT_STREAM_NAME, STGM_DIRECT | STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE, 
                    0, 0, &pStream));
        } else {
            LARGE_INTEGER       llOffset;
                
            pStream = m_persistStream;

            llOffset.QuadPart = 0;
            WsbAffirmHr(pStream->Seek(llOffset, STREAM_SEEK_SET, NULL));
        }

        // Get the IPersistStream interface.
        WsbAffirmHr(((IUnknown*)(IWsbPersistable*) this)->QueryInterface(IID_IPersistStream, (void**) &pIPersistStream));

        // Write out the class id, and then Save the data using IPersistStream method.
        WsbAffirmHr(pIPersistStream->GetClassID(&clsid));
        WsbAffirmHr(WriteClassStm(pStream, clsid));
        WsbAffirmHr(pIPersistStream->Save(pStream, remember));

        //  Put a special ULONG value at the end as a check during load
        ULONG check_value = PERSIST_CHECK_VALUE;
        WsbAffirmHr(WsbSaveToStream(pStream, check_value));
        //
        // Commit the stream right now, as ReleaseFile will not commit it
        // if we close the stream
        //
        WsbAffirmHr(pStream->Commit(STGC_DEFAULT));

        // Should we remember the file that was specified as the new
        // current file?
        if (remember) {
            m_persistState = WSB_PERSIST_STATE_NOSCRIBBLE;

            // If we created a new file, then remember it's name.
            if (create) {
                m_persistFileName = fileName;
            }

            // We need to make sure that we don't have anything open on this
            // file.
            m_persistStream = NULL;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbPersistable::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbPersistable::SaveCompleted(
    IN LPCOLESTR fileName
    )

/*++

Implements:

  IPersistFile::SaveCompleted().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IStream>    pStream;

    WsbTraceIn(OLESTR("CWsbPersistable::SaveCompleted"), OLESTR("fileName = <%ls>"), fileName);

    try {

        // Are we doing any other kind of persistance, are we doing storage
        // persistence, but are in the wrong state, or are the parameters
        // wrong.
        WsbAffirm(m_persistState == WSB_PERSIST_STATE_NOSCRIBBLE, E_UNEXPECTED);

        // Save off the name that was given to us, and only another save to
        // begin.
        if (fileName != NULL) {
            m_persistFileName = fileName;
        }

        // Open a storage to the file where the data is stored.
        WsbAffirmHr(StgOpenStorageEx(m_persistFileName, STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                STGFMT_STORAGE, 0, NULL, NULL, IID_IStorage, (void**)&m_persistStorage));

        // Open a stream.
        WsbAffirmHr(m_persistStorage->OpenStream(WSB_PERSIST_DEFAULT_STREAM_NAME, NULL, STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pStream));
     
        // Save it all off.
        m_persistState = WSB_PERSIST_STATE_NORMAL;

        m_persistStream = pStream;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbPersistable::SaveCompleted"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbPersistable::SetDefaultFileName(
    IN OLECHAR* fileName
    )

/*++

Implements:

  IWsbPersistable::SetDefaultFileName().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbPersistable::SetDefaultFileName"), OLESTR("fileName = <%ls>"), fileName);
    
    m_persistDefaultName = fileName;
    
    WsbTraceOut(OLESTR("CWsbPersistable::SetDefaultFileName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}



// Standard Type Helper Functions

HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT BOOL* pValue
    )

/*++

Routine Description:

  Loads a BOOL value from the specified stream and sets
  pValue to value of the BOOL.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a BOOL that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(BOOL)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(BOOL)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToBoolAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT LONG* pValue
    )

/*++

Routine Description:

  Loads a LONG value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a LONG that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(LONG)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(LONG)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToLongAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT GUID* pValue
    )

/*++

Routine Description:

  Loads a GUID value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a GUID that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(GUID)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(GUID)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToGuidAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT SHORT* pValue
    )

/*++

Routine Description:

  Loads a SHORT value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a SHORT that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(SHORT)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(SHORT)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN  IStream*    pStream,
    OUT BYTE*       pValue
    )

/*++

Routine Description:

  Loads a BYTE value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream    - The stream from which the value will be read.

  pValue     - A pointer to a BYTE that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(BYTE)"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) pValue, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(BYTE)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToByteAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN  IStream*    pStream,
    OUT UCHAR*      pValue,
    IN  ULONG       bufferSize
    )

/*++

Routine Description:

  Loads a UCHAR array value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream    - The stream from which the value will be read.

  pValue     - A pointer to a BYTE that will be set to the value.

  bufferSize - number of bytes to load

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(UCHAR)"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = bufferSize;
        WsbAffirmHr(pStream->Read((void*) pValue, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(UCHAR)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr));

    return(hr);

}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT OLECHAR** pValue,
    IN ULONG ulBufferSize
    )

/*++

Routine Description:

  Loads a STRING value from the specified stream and sets
  pValue to the string.

Arguments:

  pStream   - The stream from which the string will be read.

  pValue    - A pointer to a STRING that will be set to the string
                read in..

  ulBufferSize - Size of buffer pValue points to or zero allow
                alloc/realloc of the  buffer.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbLoadFromStream(STRING)"), OLESTR(""));

    try {
        ULONG               nchar;
        OLECHAR             *pc;
        ULONG               size;
        USHORT              wc;

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == sizeof(USHORT), E_UNEXPECTED);

        // Get the length of the string (in bytes).
        WsbAffirmHr(WsbLoadFromStream(pStream, &size));
       
        if (size != 0) {
          // Allocate a buffer to hold the string.
          WsbAffirmHr(WsbGetComBuffer(pValue, ulBufferSize, size, NULL));
          pc = *pValue;
      
          // Now read in the proper number of wide chars.
          nchar = size / sizeof(USHORT);
          for (ULONG i = 0; i < nchar; i++) {
              WsbAffirmHr(WsbLoadFromStream(pStream, &wc));
              *pc++ = wc;
          }
        } else {
          // Allocate a buffer to hold the string.
          WsbAffirmHr(WsbGetComBuffer(pValue, ulBufferSize, sizeof(OLECHAR), NULL));
          *(*pValue) = 0;
        }         
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(STRING)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT ULONG* pValue
    )

/*++

Routine Description:

  Loads a ULONG value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a ULONG that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(ULONG)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(ULONG)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToUlongAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT USHORT* pValue
    )

/*++

Routine Description:

  Loads a USHORT value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a USHORT that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(USHORT)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(USHORT)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToUshortAsString(pValue));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT LONGLONG* pValue
    )

/*++

Routine Description:

  Loads a LONGLONG value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a LONGLONG that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(LONGLONG)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(LONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT ULONGLONG* pValue
    )

/*++

Routine Description:

  Loads a ULONGLONG value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a ULONGLONG that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(ULONGLONG)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(ULONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT DATE* pValue
    )

/*++

Routine Description:

  Loads a DATE value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a DATE that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(DATE)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

//  WsbTraceOut(OLESTR("WsbLoadFromStream(DATE)"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToLongAsString(pValue));

    // Modify next statement after WsbDate functions written to be like the one above.
    WsbTraceOut(OLESTR("WsbLoadFromStream(DATE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT FILETIME* pValue
    )

/*++

Routine Description:

  Loads a FILETIME value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a FILETIME that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(FILETIME)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(FILETIME)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbLoadFromStream(
    IN IStream* pStream,
    OUT ULARGE_INTEGER* pValue
    )

/*++

Routine Description:

  Loads a ULARGE_INTEGER value from the specified stream and sets
  pValue to the value.

Arguments:

  pStream   - The stream from which the value will be read.

  pValue    - A pointer to a ULARGE_INTEGER that will be set to the value.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbLoadFromStream(ULARGE_INTEGER)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        size = WsbByteSize(*pValue);
        WsbAffirmHr(pStream->Read((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);
        WsbAffirmHr(WsbConvertFromBytes(bytes, pValue, &size));
        WsbAffirm(size == ulBytes, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbLoadFromStream(ULARGE_INTEGER)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
WsbSaveToStream(
    IN IStream* pStream,
    IN BOOL value
    )

/*++

Routine Description:

  Saves a BOOL value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the BOOL to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(BOOL)"), OLESTR("value = <%ls>"), WsbBoolAsString(value));

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(BOOL)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IN IStream* pStream,
    IN GUID value
    )

/*++

Routine Description:

  Saves a GUID value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the GUID to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(GUID)"), OLESTR("value = <%ls>"), WsbGuidAsString(value));

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(GUID)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    LONG value
    )

/*++

Routine Description:

  Saves a LONG value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the LONG to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(LONG)"), OLESTR("value = <%ld>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(LONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    SHORT value
    )

/*++

Routine Description:

  Saves a SHORT value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the SHORT to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(SHORT)"), OLESTR("value = <%ld>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(SHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream*    pStream,
    BYTE        value
    )

/*++

Routine Description:

  Saves a BYTE value to the specified stream.

Arguments:

  pStream    - The stream to which the value will be written.

  value      - The value of the BYTE to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(BYTE)"), OLESTR("value = <%ld>"), value);

    try {

        WsbAssert(0 != pStream, E_POINTER);

        size = WsbByteSize(value);
        WsbAffirmHr(pStream->Write((void*) &value, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(BYTE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream*    pStream,
    UCHAR*      value,
    ULONG       bufferSize
    )

/*++

Routine Description:

  Saves a UCHAR array to the specified stream.

Arguments:

  pStream    - The stream to which the value will be written.

  value      - The pointer to value of the UCHAR array to be written.

  bufferSize - Size of array to save (in bytes).

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(UCHAR)"), OLESTR("value = <%ld>"), value);

    try {
    
        WsbAssert(0 != pStream, E_POINTER);

//      WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));

        size = bufferSize;
        WsbAffirmHr(pStream->Write((void*) value, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(UCHAR)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IN IStream* pStream,
    IN OLECHAR* value
    )

/*++

Routine Description:

  Saves a OLECHAR string to the specified stream.

Arguments:

  pStream   - The stream to which the string will be written.

  value     - The string to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or value was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbSaveToStream(STRING)"), OLESTR("value = <%ls>"), WsbPtrToStringAsString(&value));

    try {
        ULONG               nchar;
        OLECHAR             *pc;
        ULONG               size;
        USHORT              wc;
    
        WsbAssert(0 != pStream, E_POINTER);
//      WsbAssert(0 != value, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == sizeof(USHORT), E_UNEXPECTED);

        // Save the length of the string (in bytes).
        if (value) {
            nchar = wcslen(value) + 1;
        } else {
            nchar = 0;
        }
        size = nchar * sizeof(USHORT);
        WsbAffirmHr(WsbSaveToStream(pStream, size));
                
        // Now write out the proper number of wide chars
        pc = value;
        for (ULONG i = 0; i < nchar; i++) {
            wc = *pc++;
            WsbAffirmHr(WsbSaveToStream(pStream, wc));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(STRING)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    ULONG value
    )

/*++

Routine Description:

  Saves a ULONG value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the ULONG to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(ULONG)"), OLESTR("value = <%ld>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(ULONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    USHORT value
    )

/*++

Routine Description:

  Saves a USHORT value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the USHORT to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(USHORT)"), OLESTR("value = <%ld>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(USHORT)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    LONGLONG value
    )

/*++

Routine Description:

  Saves a LONGLONG value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the LONGLONG to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(LONGLONG)"), OLESTR("value = <%l64x>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(LONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
WsbSaveToStream(
    IStream* pStream,
    ULONGLONG value
    )

/*++

Routine Description:

  Saves a ULONGLONG value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the ULONGLONG to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(ULONGLONG)"), OLESTR("value = <%l64x>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(ULONGLONG)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    DATE    value
    )

/*++

Routine Description:

  Saves a DATE value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the DATE to be written.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    // Modify next statement to return date after WsbDate functions written.
    WsbTraceIn(OLESTR("WsbSaveToStream(DATE)"), OLESTR("value = <%f>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(DATE)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
WsbSaveToStream(
    IStream* pStream,
    FILETIME value
    )

/*++

Routine Description:

  Saves a FILETIME value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the FILETIME to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(FILETIME)"), OLESTR(""));

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(FILETIME)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbBstrFromStream(
    IN IStream* pStream,
    OUT BSTR* pValue
    )

/*++

Routine Description:

  Loads a BSTR value from the specified stream.

Arguments:

  pStream   - The stream from which the BSTR will be read.

  pValue    - A pointer to a BSTR.  If *pValue is NULL, this
                function will allocate the BSTR; if it already
                points to a BSTR that is too short, the BSTR
                will be reallocated.

Return Value:

  S_OK      - Success
  E_POINTER - Either pStream or pValue were NULL.
  E_...     - Anything returned by IStream::Read.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbBstrFromStream"), OLESTR(""));

    try {
        ULONG               bchar;
        ULONG               nchar;
        OLECHAR             *pc;
        ULONG               size;
        USHORT              wc;

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == sizeof(USHORT), E_UNEXPECTED);

        // Get the length of the string (in bytes).
        WsbAffirmHr(WsbLoadFromStream(pStream, &size));
                
        // (Re)allocate a buffer to hold the string.
        nchar = size / sizeof(USHORT);
        bchar = nchar - 1;
        if (*pValue) {
            if (bchar != SysStringLen(*pValue)) {
                WsbAffirm(WsbReallocStringLen(pValue, NULL, bchar), 
                        WSB_E_RESOURCE_UNAVAILABLE);
            }
        } else {
            *pValue = WsbAllocStringLen(NULL, bchar);
            WsbAffirm(*pValue, WSB_E_RESOURCE_UNAVAILABLE);
        }

        // Now read in the proper number of wide chars.
        pc = *pValue;
        for (ULONG i = 0; i < nchar; i++) {
            WsbAffirmHr(WsbLoadFromStream(pStream, &wc));
            *pc++ = wc;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbBstrFromStream"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), WsbPtrToStringAsString(pValue));

    return(hr);
}


HRESULT
WsbBstrToStream(
    IN IStream* pStream,
    IN BSTR value
    )

/*++

Routine Description:

  Saves a BSTR to the specified stream.

Arguments:

  pStream   - The stream to which the BSTR will be written.

  value     - The BSTR to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("WsbBstrToStream"), OLESTR("value = <%ls>"), WsbPtrToStringAsString(&value));

    try {
        ULONG               nchar;
        OLECHAR             *pc;
        ULONG               size;
        USHORT              wc;
    
        WsbAssert(0 != pStream, E_POINTER);
        WsbAssert(0 != value, E_POINTER);
        WsbAssert(sizeof(OLECHAR) == sizeof(USHORT), E_UNEXPECTED);

        // Save the length of the string (in bytes).
        nchar = SysStringLen(value) + 1;
        size = nchar * sizeof(USHORT);
        WsbAffirmHr(WsbSaveToStream(pStream, size));
                
        // Now write out the proper number of wide chars
        pc = value;
        for (ULONG i = 0; i < nchar; i++) {
            wc = *pc++;
            WsbAffirmHr(WsbSaveToStream(pStream, wc));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbBstrToStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
WsbSaveToStream(
    IStream* pStream,
    ULARGE_INTEGER value
    )

/*++

Routine Description:

  Saves a ULARGE_INTEGER value to the specified stream.

Arguments:

  pStream   - The stream to which the value will be written.

  value     - The value of the ULARGE_INTEER to be written.

Return Value:

  S_OK      - Success
  E_POINTER - pStream was NULL.
  E_...     - Anything returned by IStream::Write.

--*/
{
    HRESULT                     hr = S_OK;
    ULONG               size;
    ULONG               ulBytes;

    WsbTraceIn(OLESTR("WsbSaveToStream(ULARGE_INTEGER)"), OLESTR("value = <%l64x>"), value);

    try {
        UCHAR bytes[BYTE_SIZE];
    
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbConvertToBytes(bytes, value, &size));
        WsbAffirmHr(pStream->Write((void*) bytes, size, &ulBytes));
        WsbAffirm(ulBytes == size, WSB_E_STREAM_ERROR);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbSaveToStream(ULARGE_INTEGER)"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


static HRESULT 
WsbMakeBackupName(
    OLECHAR*  pSaveName,
    OLECHAR*  pExtension,
    OLECHAR** ppBackupName
)

/*++

Routine Description:

  Converts a Save file name to a backup file name.

Arguments:

  pSaveName     - Orginal file name.

  pExtension    - The file extension to substitute.

  ppBackupName  - Pointer to pointer to new backup file name.

Return Value:

  S_OK      - Success
  E_...     - Some error.

--*/
{
    HRESULT        hr = S_OK;

    try {
        size_t        len;
        CWsbStringPtr NewName;
        OLECHAR*      pC;

        //  It sure would be nice to have a general function for parsing
        //  file names!

        //  Find the file extension (if any)
        NewName = pSaveName;
        if (NewName == NULL) {
            WsbThrow(E_OUTOFMEMORY);
        }
        len = wcslen(NewName);
        pC = wcsrchr(NewName, OLECHAR('.'));
        if (pC && (size_t)((pC - (OLECHAR*)NewName) + 4) >= len) {
            *pC = 0;
        }

        //  Put on new file extension
        NewName.Append(pExtension);

        //  Give the buffer to the output parameter
        NewName.GiveTo(ppBackupName);
    } WsbCatch(hr);

    return(hr);
}


HRESULT   
WsbPrintfToStream(
    IStream* pStream, 
    OLECHAR* fmtString, 
    ...
)

/*++

Routine Description:

    Print printf-style format string and arguments to a stream.

Arguments:

    pStream     - The stream to which the value will be written.

    fmtString   - A printf style string indicating the number of
                  arguments and how they should be formatted.

Return Value:

    S_OK        - Success.

--*/

{
    HRESULT     hr = S_OK;
    
    try {
        ULONG         bytesWritten;
        ULONG         nBytes;
        ULONG         nChars=0;
        CWsbStringPtr tmpString;
        va_list       vaList;

        va_start(vaList, fmtString);
        WsbAffirmHr(tmpString.VPrintf(fmtString, vaList));
        va_end(vaList);
        WsbAffirmHr(tmpString.GetLen(&nChars));
        nBytes = nChars * sizeof(WCHAR);
        if (0 < nBytes) {
            WsbAffirmHr(pStream->Write(static_cast<WCHAR *>(tmpString), 
                nBytes, &bytesWritten));
            WsbAffirm(bytesWritten == nBytes, E_FAIL);
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
WsbSafeCreate(
    OLECHAR*      pFileName,
    IPersistFile* pIPFile
    )

/*++

Routine Description:
   Makes sure there are no database files found and then creates the database files.

Arguments:

  pFileName - Name of the file containing the persisted data
  pIPFile   - Pointer to the objects IPersistFile interface.

Return Value:

  S_OK                          - Success
  WSB_E_DATABASE_ALREADY_EXISTS - The databases already exist and cannot be created.
  E_...                         - Some other error.

--*/
{
    HRESULT        hr = S_OK;
    OLECHAR*       pBackupName = NULL;
    OLECHAR*       pNewName = NULL;


    WsbTraceIn(OLESTR("WsbSafeCreate"), OLESTR("<%ls>"), pFileName);

    try {
        CComPtr<IWsbPersistable> pIWsbPersist;
        BOOL                     fileThere = FALSE;

        //  Save the file name passed as the default file name
        WsbAffirmHr(pIPFile->QueryInterface(IID_IWsbPersistable,
                (void**)&pIWsbPersist));
        WsbAffirmHr(pIWsbPersist->SetDefaultFileName(pFileName));
        
        //
        // Check to see if the file exists.  If so, life is BAD.
        // If not, then see if the new or backup files exist
        // and use them
        //
        //  Make sure the Save file exists
        if (!WsbFileExists(pFileName)) {
            //
            // The file doesn't exist.  See if the new copy is there
            //
            //  Create name for new (temporary) file
            //
            WsbAffirmHr(WsbMakeBackupName(pFileName, OLESTR(".new"), &pNewName));

            //  See if the new file exists
            if (!WsbFileExists(pNewName)) {
                //
                // Don't have the new file, look for the backup file
                //
                WsbAffirmHr(WsbMakeBackupName(pFileName, OLESTR(".bak"), &pBackupName));
                if (WsbFileExists(pBackupName)) {
                    //
                    // Backup is there - complain
                    //
                    hr = WSB_E_DATABASE_ALREADY_EXISTS;
                }
            } else  {
                //
                // New is there - complain
                //
                hr = WSB_E_DATABASE_ALREADY_EXISTS;
            }                
        } else  {
            //
            // The file exists so complain
            //
            hr = WSB_E_DATABASE_ALREADY_EXISTS;
            WsbThrow( hr );
        }
        
        //
        // If we haven't thrown then it is OK to create the files
        //
        hr = pIPFile->Save( pFileName, TRUE);
        if (!SUCCEEDED(hr)) {
            WsbLogEvent(WSB_MESSAGE_SAFECREATE_SAVE_FAILED, 0, NULL, pFileName, NULL);
            WsbThrow(hr);
        }

        //  Release the file
        WsbAffirmHr(pIWsbPersist->ReleaseFile());
        
    } WsbCatch(hr);

    if (pBackupName) {
        WsbFree(pBackupName);
    }
    if (pNewName) {
        WsbFree(pNewName);
    }

    WsbTraceOut(OLESTR("WsbSafeCreate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
WsbSafeLoad(
    OLECHAR*      pFileName,
    IPersistFile* pIPFile,
    BOOL          UseBackup
    )

/*++

Routine Description:
   Loads data from the specified file name.  Works in conjunction with WsbSafeSave
   to best recover from disaster situations.

Arguments:

  pFileName - Name of the file containing the persisted data
  pIPFile   - Pointer to the objects IPersistFile interface.
  UseBackup - Load data from backup file instead of normal file
              NOTE: (this is not used anymore)

Return Value:

  S_OK              - Success
  WSB_E_NOTFOUND    - The databases could not be found
  E_...             - Some other error.

--*/
{
    HRESULT        hr = S_OK;
    OLECHAR*       pBackupName = NULL;
    OLECHAR*       pLoadName = NULL;
    BOOL           usingBackup = FALSE;
    BOOL           TracePersistence = FALSE;

    UNREFERENCED_PARAMETER(UseBackup);

    //  Turn tracing off during save if it's not wanted
    if (g_pWsbTrace) {
        g_pWsbTrace->GetTraceSetting(WSB_TRACE_BIT_PERSISTENCE, &TracePersistence);
    }
    if (!TracePersistence) {
        WsbTraceThreadOff();
    }
    WsbTraceIn(OLESTR("WsbSafeLoad"), OLESTR("File = <%ls>, UseBackup = %ls"), 
            pFileName, WsbBoolAsString(UseBackup));

    try {
        HRESULT                  hrLoad;
        BOOL                     fileThere = FALSE;
        CComPtr<IWsbPersistable> pIWsbPersist;

        //  Save the file name passed as the default file name
        WsbAffirmHr(pIPFile->QueryInterface(IID_IWsbPersistable,
                (void**)&pIWsbPersist));
        WsbAffirmHr(pIWsbPersist->SetDefaultFileName(pFileName));

        //
        // Create the backup file name
        //
        WsbAffirmHr(WsbMakeBackupName(pFileName, OLESTR(".bak"), &pBackupName));

        //
        // Check if the .col exists
        //
        if (WsbFileExists(pFileName)) {
            //
            // The file exists. Use it
            //
            fileThere = TRUE;
            pLoadName = pFileName;
        } else  {
                //
                // Look for the backup file
                //
                WsbTrace(OLESTR("WsbSafeLoad: trying .bak\n"));
                if (WsbFileExists(pBackupName)) {
                    //
                    // Use the backup file
                    //
                    // WsbLogEvent(WSB_MESSAGE_SAFELOAD_USING_BACKUP, 0, NULL, pFileName, NULL);
                    pLoadName = pBackupName;
                    fileThere = TRUE;
                    usingBackup= TRUE;
               } 
        }

        WsbAffirm(fileThere, WSB_E_NOTFOUND);
        //
        // The file exists so try to load from it
        //
        hr = pIPFile->Load(pLoadName, 0);

        if (SUCCEEDED(hr)) {
            //
            //  Load succeeded, release the file
            //
            WsbAffirmHr(pIWsbPersist->ReleaseFile());
            //
            // TO BE DONE: check if .bak file is out of date
            // and update it if so..
            // 
        } else if (!usingBackup) {
            WsbTrace(OLESTR("WsbSafeLoad: trying .bak\n"));
            if (WsbFileExists(pBackupName)) {
                WsbLogEvent(WSB_MESSAGE_SAFELOAD_USING_BACKUP, 0, NULL, pLoadName, WsbHrAsString(hr));
                //
                // Use the backup file
                //
                hrLoad = pIPFile->Load(pBackupName, 0);
                if (SUCCEEDED(hrLoad)) {
                    //  Load succeeded, release the file
                    WsbAffirmHr(pIWsbPersist->ReleaseFile());
                    //
                    // Now save the changes to the .col file to keep it in sync
                    //
                    hr = pIPFile->Save(pFileName, FALSE);

                    if (!SUCCEEDED(hr)) {
                        WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_SAVE, 0, NULL, pFileName, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    }
                    //
                    // Commit and release .col file
                    //
                    WsbAffirmHr(pIWsbPersist->ReleaseFile());

                } else {
                    WsbLogEvent(WSB_MESSAGE_SAFELOAD_RECOVERY_FAILED, 0, NULL, pFileName, WsbHrAsString(hrLoad), NULL);
                    WsbThrow(hrLoad);
                }
            } else {
                WsbLogEvent(WSB_MESSAGE_SAFELOAD_RECOVERY_FAILED, 0, NULL, pFileName, NULL);
            }
        } else {
            WsbLogEvent(WSB_MESSAGE_SAFELOAD_RECOVERY_FAILED, 0, NULL, pFileName, WsbHrAsString(hr)); 
        }
    } WsbCatch(hr);

    if (pBackupName) {
        WsbFree(pBackupName);
    }

    WsbTraceOut(OLESTR("WsbSafeLoad"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    //  Restore tracing if we turned it off
    if (!TracePersistence) {
        WsbTraceThreadOn();
    }

    return(hr);
}

HRESULT
WsbSafeSave(
    IPersistFile* pIPFile
    )

/*++

Routine Description:

  Saves the object to a backup file and then replaces the objects Save file
  with the backup file.  Use with WsbSafeLoad

Arguments:

  pIPFile   - Pointer to the objects IPersistFile interface.

Return Value:

  S_OK      - Success
  E_...     - Some error.

--*/
{
    HRESULT        hr = S_OK;
    OLECHAR*       pBackupName = NULL;
    OLECHAR*       pFileName = NULL;
    BOOL           TracePersistence = FALSE;
    DWORD          file_attrs;

    //  Turn tracing off during save if it's not wanted
    if (g_pWsbTrace) {
        g_pWsbTrace->GetTraceSetting(WSB_TRACE_BIT_PERSISTENCE, &TracePersistence);
    }
    if (!TracePersistence) {
        WsbTraceThreadOff();
    }
    WsbTraceIn(OLESTR("WsbSafeSave"), OLESTR(""));

    try {
        CComPtr<IWsbPersistable> pIWsbPersist;

        //  Get the current Save file name
        WsbAffirmHr(pIPFile->GetCurFile(&pFileName));
        WsbTrace(OLESTR("WsbSafeSave: filename = <%ls>\n"), pFileName);

        //  Create name for backup file
        WsbAffirmHr(WsbMakeBackupName(pFileName, OLESTR(".bak"), &pBackupName));


        //  Make sure we have write access to the save file if it exists!
        if (WsbFileExists(pFileName)) {
            file_attrs = GetFileAttributes(pFileName);
            if (file_attrs & FILE_ATTRIBUTE_READONLY) {
               WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_ACCESS, 0, NULL, pFileName, NULL);
              WsbThrow(E_FAIL);
            }
        }

        //  Save data to save file
        hr = pIPFile->Save(pFileName, FALSE);
        if (!SUCCEEDED(hr)) {
            WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_SAVE, 0, NULL, pFileName, WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
        //  Commit and release the save file
        WsbAffirmHr(pIPFile->QueryInterface(IID_IWsbPersistable,
                (void**)&pIWsbPersist));
        WsbAffirmHr(pIWsbPersist->ReleaseFile());

        //  Save data to .bak file
        //  Make sure we have write access to the save file if it exists!
        if (WsbFileExists(pBackupName)) {
            file_attrs = GetFileAttributes(pBackupName);
            if (file_attrs & FILE_ATTRIBUTE_READONLY) {
               WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_ACCESS, 0, NULL, pBackupName, NULL);
              WsbThrow(E_FAIL);
            }
        }
        hr = pIPFile->Save(pBackupName, FALSE);
        if (!SUCCEEDED(hr)) {
            WsbLogEvent(WSB_MESSAGE_SAFESAVE_RECOVERY_CANT_SAVE, 0, NULL, pBackupName, WsbHrAsString(hr), NULL);
            WsbThrow(hr);
        }
        //  Commit and release the .bak file
        WsbAffirmHr(pIWsbPersist->ReleaseFile());
    } WsbCatch(hr);

    if (pFileName) {
        WsbFree(pFileName);
    }
    if (pBackupName) {
        WsbFree(pBackupName);
    }

    WsbTraceOut(OLESTR("WsbSafeSave"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    //  Restore tracing if we turned it off
    if (!TracePersistence) {
        WsbTraceThreadOn();
    }

    return(hr);
}


HRESULT WsbStreamToFile(
    HANDLE   hFile, 
    IStream* pStream,
    BOOL     AddCR
)
/*++

Routine Description:

  Copies text from a stream (which must have been created with CreateStreamOnHGlobal)
  to an open file (opened via CreateFile).  The text is assumed to be wide characters
  with no embedded wide-character nulls.  The text is converted to multibyte characters
  for output to the file.

  After the text is copied, the stream position is reset to the beggining.

Arguments:

  hFile      - Handle of output file.

  pStream    - Pointer to an IStream interface.

  AddCR      - Convert LF to CR-LF if TRUE.

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;
    const int         safe_size = 1024;
    static char       buf[safe_size + 16];
    static char       CRLF[3] = "\r\n";

    try {
        WCHAR*            addr;
        WCHAR             big_eof = 0;
        BOOL              doCRLF = FALSE;
        DWORD             err;
        HGLOBAL           hMem = 0;        // Mem block for stream
        DWORD             nbytes;
        int               nchars_todo;
        int               nchars_remaining;
        LARGE_INTEGER     seek_pos_zero;

        //  Make sure the text ends with a null
        WsbAffirmHr(pStream->Write(&big_eof, sizeof(WCHAR), NULL));

        //  Get the address of the memory block for the stream
        WsbAffirmHr(GetHGlobalFromStream(pStream, &hMem));
        addr = static_cast<WCHAR *>(GlobalLock(hMem));
        WsbAffirm(addr, E_HANDLE);

        //  Get the total number of chars. in the string
        nchars_remaining = wcslen(addr);

        //  Loop until all chars. are written
        while (nchars_remaining) {
            DWORD bytesWritten;

            if (nchars_remaining * sizeof(WCHAR) > safe_size) {
                nchars_todo = safe_size / sizeof(WCHAR);
            } else {
                nchars_todo = nchars_remaining;
            }

            //  Stop at LineFeed if we need to convert to CR-LF
            if (AddCR) {
                int    lf_todo;
                WCHAR* pLF;

                pLF = wcschr(addr, WCHAR('\n'));
                if (pLF) {
                    lf_todo = (int)(pLF - addr);
                    if (lf_todo < nchars_todo) {
                        nchars_todo = lf_todo;
                        doCRLF = TRUE;
                    }
                }
            }

            //  Output everything up to LF
            if (0 < nchars_todo) {
                nbytes = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, addr, nchars_todo, buf, 
                                safe_size, NULL, NULL);
                if (0 == nbytes) {
                    DWORD dwErr = GetLastError();          
                    hr = HRESULT_FROM_WIN32(dwErr);
                    WsbAffirmHr(hr);
                }                               

                if (!WriteFile(hFile, buf, nbytes, &bytesWritten, NULL)) {
                    err = GetLastError();
                    WsbThrow(HRESULT_FROM_WIN32(err));
                }
                WsbAffirm(bytesWritten == nbytes, E_FAIL);
            }

            //  Output CR-LF in place of LF if needed
            if (doCRLF) {
                if (!WriteFile(hFile, CRLF, 2, &bytesWritten, NULL)) {
                    err = GetLastError();
                    WsbThrow(HRESULT_FROM_WIN32(err));
                }
                WsbAffirm(bytesWritten == 2, E_FAIL);
                nchars_todo++;
                doCRLF = FALSE;
            }
            nchars_remaining -= nchars_todo;
            addr += nchars_todo;
        }

        seek_pos_zero.QuadPart = 0;
        WsbAffirmHr(pStream->Seek(seek_pos_zero, STREAM_SEEK_SET, NULL));

    } WsbCatch(hr);

    return(hr);
}

// WsbFileExists - determine if a file exists or not
static BOOL WsbFileExists(OLECHAR* pFileName)
{
    BOOL                     doesExist = FALSE;
    DWORD                    file_attrs;

    WsbTraceIn(OLESTR("WsbFileExists"), OLESTR("%ls"), pFileName);

    file_attrs = GetFileAttributes(pFileName);
    if (0xffffffff != file_attrs)  {
        doesExist = TRUE;
    }

    WsbTraceOut(OLESTR("WsbFileExists"), OLESTR("%ls"), 
            WsbBoolAsString(doesExist));
    return(doesExist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbserv.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbSvc.cpp

Abstract:

    This is the implementation of common methods that the Remote Storage
    services should utilize.

Author:

    Cat Brant       [cbrant]    24-Sep-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsbServ.h"

HRESULT 
WsbPowerEventNtToHsm(
    IN  DWORD NtEvent, 
    OUT ULONG * pHsmEvent
    )
/*++

Routine Description:
              
    Convert a NT power event (PBT_APM*) into our state change event.

Arguments:

    NtEvent     - The PBT_APM* power event.

    pHsmEvent   - Pointer to HSM change state (combination of
            HSM_SYSTEM_STATE_* values)
              
Return Value:

    S_OK     - Succes
    

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("WsbPowerEventNtToHsm"), OLESTR(""));

    try {
        WsbAffirmPointer(pHsmEvent);

        *pHsmEvent = HSM_STATE_NONE;
        switch(NtEvent)
        {
            case PBT_APMQUERYSTANDBY:
            case PBT_APMQUERYSUSPEND:
            case PBT_APMSTANDBY:
            case PBT_APMSUSPEND:
                // Suspend operations
                *pHsmEvent = HSM_STATE_SUSPEND;
                break;
            case PBT_APMQUERYSTANDBYFAILED:
            case PBT_APMQUERYSUSPENDFAILED:
            case PBT_APMRESUMESTANDBY:
            case PBT_APMRESUMESUSPEND:
                // Resume operations
                *pHsmEvent = HSM_STATE_RESUME;
                break;
            default:
                break;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("WsbPowerEventNtToHsm"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    return( hr );
}

HRESULT
WsbServiceSafeInitialize(
    IN  IWsbServer *pServer,
    IN  BOOL        bVerifyId,
    IN  BOOL        bPrimaryId,
    OUT BOOL       *pWasCreated
    )
/*++

Routine Description:
              
    This function performs various checks to guarantee that the instance of
    the service matches the instance that created the existing persistence 
    files. If this is not the case, the function returns an HRESULT that 
    indicates where the mismatch occured.
    
    Each service keeps a GUID in the registry and each HSM server object keeps
    the same id in its persistence file.  
    During the initial start (no registry and no persistence file) this 
    function establishes this match.  Upon subsequent starts, this function 
    guarantees the match of these GUIDs.
    
    It is considered recoverable if the GUID does not exist in the registry 
    but the persistence file can be found and contains a GUID.  In this 
    situation, this function re-establishes the GUID in the registry.  However, 
    if the GUID is found in the registry and either the persistence file is not 
    found or the GUID in the persistence file does not match, this function 
    returns an HRESULT that should prevent the service from running.

    Note: Since one service may have several server objects with several persistency files, 
    there may be some exceptions to the above, according ot the input flags:
    1) bVerifyId sets whether to verify existence of service id in the Registry. Generally, 
       a service should call with the flag on only once (for the first persistency file loaded).
    2) bPrimaryId sets whether to use this server id as the Registry id. Eventually, this id 
       becomes the only id in the Registry and all persistency files. Generally,  service 
       should call with the flag on only once (for one of its persistency files).


Arguments:

    pServer     - pointer to the IWsbServer interface of the Remote Storage
                  service that is being started

    bVerifyId   - A flag for whether to verify existence of a file if id is found in the Registry

    bPrimaryId  - A flag for whether to force equivalence of id and whether to set Registry id according to file id

    pWasCreated - if non-NULL, set to TRUE if the persistence file was created.
                  (If FALSE and return value is S_OK, the file was read.)
              
Return Value:

    S_OK     - Success - service startup completed successfully
    

--*/
{
    HRESULT         hr = S_OK;
    GUID            regServerId = GUID_NULL;    // GUID of service in registry
    GUID            dbServerId  = GUID_NULL;    // GUID of service in database
    BOOL            foundRegId = FALSE;         // Found Service ID in registry
    BOOL            foundDbId  = FALSE;         // Found Service ID in database
    CWsbStringPtr   regName;                    // Registry Name for service
    CWsbStringPtr   dbName;                     // Persistable File name for service
    CComPtr<IPersistFile>  pServerPersist;      // Service's persistable interface


    WsbTraceIn(OLESTR("WsbServiceSafeInitialize"), OLESTR(""));

    if (pWasCreated) {
        *pWasCreated = FALSE;
    }

    try {
        //
        // Go to the registry and find the GUID for this service
        //
        //
        // Get the registry name for the service
        //
        try  {
            WsbAffirmHr(pServer->GetRegistryName(&regName, 0));
            WsbAffirmHr(WsbGetServiceId(regName, &regServerId));
            foundRegId = TRUE;
        } WsbCatchAndDo( hr, if (WSB_E_NOTFOUND == hr)  \
            {WsbLogEvent(WSB_MESSAGE_SERVICE_ID_NOT_REGISTERED, 0, NULL, regName, WsbHrAsString(hr), NULL); \
            hr = S_OK;};);
        WsbAffirmHr( hr );
        
        //
        // Locate the persistence file for this service and load it
        //
        // Get the path to the file and the IPersist Interface
        //
        try  {
            WsbAffirmHr(pServer->GetDbPathAndName(&dbName, 0));
            WsbAffirmHr(pServer->QueryInterface(IID_IPersistFile, (void **)&pServerPersist));
            hr = WsbSafeLoad(dbName, pServerPersist, FALSE);

            if (WSB_E_NOTFOUND == hr) {
                WsbThrow(hr);
            }
            //  Check the status from the read; WSB_E_NOTFOUND means that
            //  there was no persistence file found to read
            if (!SUCCEEDED(hr)) {
                WsbAffirmHr(pServer->Unload());
                WsbThrow(hr);
            }

            WsbAffirmHr(pServer->GetId(&dbServerId));
            foundDbId = TRUE;
        } WsbCatchAndDo( hr, if (WSB_E_NOTFOUND == hr)  \
            {WsbLogEvent(WSB_MESSAGE_DATABASES_NOT_FOUND, 0, NULL, regName, WsbHrAsString(hr), NULL); \
            hr = S_OK;};);
        WsbAffirmHr( hr );
        
        //
        // Now evaluate what we have
        //
        if (foundDbId == TRUE )  {
            //
            // Got the persistence file, see if things are OK
            if (foundRegId == TRUE)  {
                if (regServerId != dbServerId)  {
                    if (bPrimaryId) {
                        //
                        // BIG PROBLEM!!!!!  The running instance of the
                        // server and the persistence file do not match.
                        // Log a message, STOP the server!
                        //
                        hr = WSB_E_SERVICE_INSTANCE_MISMATCH;
                        WsbLogEvent(WSB_MESSAGE_SERVICE_INSTANCE_MISMATCH, 0, NULL, regName, WsbHrAsString(hr), NULL); 
                    } else {
                        //
                        // This may happen once after an upgrade, when the primary id doesn't match all ids:
                        // Just set the already found (primary) id, after next Save it will be set in all col files
                        //
                        WsbAffirmHr(pServer->SetId(regServerId));   
                    }
                } else  {
                    //
                    // Life is good, OK to start
                    //   
                }
            } else  {
                //
                // We have an ID from the persistence file but there isn't one in
                // the registry.  So add it to the registry (if it is the primary id) and go on.
                //
                if (bPrimaryId) {
                    WsbAffirmHr(WsbSetServiceId(regName, dbServerId));
                    WsbLogEvent(WSB_MESSAGE_SERVICE_ID_REGISTERED, 0, NULL, regName, WsbHrAsString(hr), NULL); 
                }
            }
        } else  {
            //
            // No persistence file was found!  
            //
            if (foundRegId == TRUE)  {
                if (bVerifyId) {
                    //
                    // BIG PROBLEM!!!!!  There is a registered instance
                    // ID but we can't find the file - this is bad.
                    // Log a  warning message
                    //
                    hr = WSB_E_SERVICE_MISSING_DATABASES;
                    WsbLogEvent(WSB_MESSAGE_SERVICE_MISSING_DATABASES, 0, NULL, regName, WsbHrAsString(hr), NULL); 

                    // 
                    // We continue and recreate the col files using the id we found 
                    // That way, truncated files could be recalled even if the original col
                    // files are completely lost for some reason.
                    //
                    hr = S_OK;
                } 
                //
                // Just create the persistence file and save the existing id in it
                // regServerId contains the found id
                //
                WsbAffirmHr(pServer->SetId(regServerId));   

                WsbAffirmHr(WsbSafeCreate(dbName, pServerPersist));
                if (pWasCreated) {
                    *pWasCreated = TRUE;
                }
                WsbLogEvent(WSB_MESSAGE_SERVICE_NEW_INSTALLATION, 0, NULL, regName, WsbHrAsString(hr), NULL); 

            } else  {
                //
                // No persistence file and no registry entry - must be a new 
                // installation.  So get a GUID, save it in the registry
                // and save it in the file.
                //
                WsbAffirmHr(WsbCreateServiceId(regName, &regServerId));
                WsbAffirmHr(pServer->SetId(regServerId));

                WsbAffirmHr(WsbSafeCreate(dbName, pServerPersist));
                if (pWasCreated) {
                    *pWasCreated = TRUE;
                }
                WsbAffirmHr(WsbConfirmServiceId(regName, regServerId));
                WsbLogEvent(WSB_MESSAGE_SERVICE_NEW_INSTALLATION, 0, NULL, regName, WsbHrAsString(hr), NULL); 
            }
        }
        
    } WsbCatch( hr );

    WsbTraceOut(OLESTR("WsbServiceSafeInitialize"), OLESTR("hr = <%ls>, wasCreated= %ls"), 
            WsbHrAsString(hr), WsbPtrToBoolAsString(pWasCreated));
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbsvc.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbSvc.cpp

Abstract:

    This is the implementation of service helper functions.

Author:

    Art Bragg      5/29/97

Revision History:

--*/


#include "stdafx.h"
#include "ntsecapi.h"

HRESULT
WsbCheckService(
    IN  const OLECHAR * Computer,
    IN  GUID            GuidApp
    )
/*++

Routine Description:

Arguments:

    computer - NULL if local computer
    guidApp - app id of the service to check.


Return Value:

    S_OK     - Success - service is running
    S_FALSE  - Success - service is not running
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;

    try {

        //
        // Get the service status
        //
        DWORD serviceState;
        WsbAffirmHr( WsbGetServiceStatus( Computer, GuidApp, &serviceState ) );

        //
        // Is the service running?
        //
        if( SERVICE_RUNNING != serviceState ) WsbThrow( S_FALSE );

    } WsbCatch( hr );

    return( hr );
}

HRESULT
WsbGetServiceStatus(
    IN  const OLECHAR   *Computer,
    IN  GUID            GuidApp,
    OUT DWORD           *ServiceStatus
    )
/*++

Routine Description:

Arguments:

    Computer - NULL if local computer
    GuidApp - app id of the service to check.
    ServiceStatus - status of the service


Return Value:

    S_OK     - Success - service is running
    S_FALSE  - Success - service is not running
    
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;

    SC_HANDLE hSCM = 0;
    SC_HANDLE hService = 0;
    SERVICE_STATUS serviceStatusStruct;
    try {

        //
        // Find the service in the registry
        //

        CWsbStringPtr regPath = L"SOFTWARE\\Classes\\AppID\\";
        regPath.Append( CWsbStringPtr( GuidApp ) );

        //
        // Get the name of the service
        //

        OLECHAR serviceName[WSB_MAX_SERVICE_NAME];
        WsbAffirmHr( WsbGetRegistryValueString( Computer, regPath, L"LocalService", serviceName, WSB_MAX_SERVICE_NAME, 0 ) );

        //
        // Setup the service to run under the account
        //

        hSCM = OpenSCManager( Computer, 0, GENERIC_READ );
        WsbAffirmStatus( 0 != hSCM );

        hService = OpenService( hSCM, serviceName, SERVICE_QUERY_STATUS );
        WsbAffirmStatus( 0 != hService );

        // Get the service status
        WsbAffirmStatus( QueryServiceStatus( hService, &serviceStatusStruct ) );

        *ServiceStatus = serviceStatusStruct.dwCurrentState;

    } WsbCatch( hr );

    if( hSCM )        CloseServiceHandle( hSCM );
    if( hService )    CloseServiceHandle( hService );

    return( hr );
}

HRESULT
WsbGetServiceName(
    IN  const OLECHAR   *computer,
    IN  GUID            guidApp,
    IN  DWORD           cSize,
    OUT OLECHAR         *serviceName
    )
/*++

Routine Description:

Arguments:

    computer - NULL if local computer
    guidApp - app id of the service whose name to get.


Return Value:

    S_OK     - Success 
    E_*      - Problem occured, error passed down.

--*/
{
    HRESULT hr = S_OK;
    try {

        //
        // Find the service in the registry
        //

        CWsbStringPtr regPath = L"SOFTWARE\\Classes\\AppID\\";
        regPath.Append( CWsbStringPtr( guidApp ) );

        //
        // Get the name of the service
        //

        WsbAffirmHr( WsbGetRegistryValueString( computer, regPath, L"LocalService", serviceName, cSize, 0 ) );

    } WsbCatch( hr );
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbtrak.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbtrak.cpp

Abstract:

    Utility functions to keep track of run-time information.


Author:

    Ron White   [ronw]   5-Dec-1997

Revision History:

--*/

#include "stdafx.h"
#include "wsbguid.h"

#if defined(WSB_TRACK_MEMORY)

#define OBJECT_TABLE_SIZE       100
#define POINTER_DATA_CURRENT    0
#define POINTER_DATA_CUMULATIVE 2
#define POINTER_DATA_MAX        1
#define POINTER_DATA_SIZE       3
#define POINTER_LIST_SIZE       1000

typedef struct {
    GUID     guid;
    LONG     count;
    LONG     total_count;
    LONG     max_count;
} OBJECT_TABLE_ENTRY;

typedef struct {
    OLECHAR *  guid_string;
    OLECHAR *  name;
    GUID *     pGuid;
} OBJECT_NAME_ENTRY;

typedef struct {
    LONG        count;
    LONGLONG    size;
} POINTER_DATA_ENTRY;

typedef struct {
    const void *     addr;
    LONG             order;
    ULONG            size;
    int              index;   // Index into object table
    const char *     filename;
    int              linenum;
} POINTER_LIST_ENTRY;

//  Module data
#if defined(CRT_DEBUG_MEMORY)
static _CrtMemState        CrtMemState;
#endif

static OBJECT_TABLE_ENTRY  object_table[OBJECT_TABLE_SIZE];
static int                 object_table_count = 0;
static POINTER_DATA_ENTRY  pointer_data[POINTER_DATA_SIZE];
static BOOL                pointer_data_initialized = FALSE;
static POINTER_LIST_ENTRY  pointer_list[POINTER_LIST_SIZE];
static int                 pointer_list_count = 0;

static OBJECT_NAME_ENTRY object_name_table[] = {
    { L"{C03D4861-70D7-11d1-994F-0060976A546D}", L"CWsbStringPtr", NULL },
    { L"{C03D4862-70D7-11d1-994F-0060976A546D}", L"CWsbBstrPtr", NULL },
    { L"{A0FF1F42-237A-11D0-81BA-00A0C91180F2}", L"CWsbGuid", NULL },
    { L"{9C7D6F13-1562-11D0-81AC-00A0C91180F2}", L"CWsbOrderedCollection", NULL },
    { L"{46CE9EDE-447C-11D0-98FC-00A0C9058BF6}", L"CWsbDbKey", NULL },

    { L"{E707D9B2-4F89-11D0-81CC-00A0C91180F2}", L"CFsaServerNTFS", NULL },
    { L"{FCDC8671-7329-11d0-81DF-00A0C91180F2}", L"CFsaFilterNTFS", NULL },
    { L"{112981B3-1BA5-11D0-81B2-00A0C91180F2}", L"CFsaResourceNTFS", NULL },
    { L"{0B8B6F12-8B3A-11D0-990C-00A0C9058BF6}", L"CFsaPremigratedDb", NULL },
    { L"{14005FF1-8B4F-11d0-81E6-00A0C91180F2}", L"CFsaTruncatorNTFS", NULL },
    { L"{CECCB131-286D-11d1-993E-0060976A546D}", L"CFsaRecoveryRec", NULL },
    { L"{7CA819F2-8AAB-11D0-990C-00A0C9058BF6}", L"CFsaPremigratedRec", NULL },
    { L"{B2AD2931-84FD-11d0-81E4-00A0C91180F2}", L"CFsaFilterClientNTFS", NULL },
    { L"{F7860350-AA27-11d0-B16D-00A0C916F120}", L"CFsaPostIt", NULL },
    { L"{B2AD2932-84FD-11d0-81E4-00A0C91180F2}", L"CFsaFilterRecallNTFS", NULL },
    { L"{112981B2-1BA5-11D0-81B2-00A0C91180F2}", L"CFsaScanItemNTFS", NULL },

    { L"{7B22FF29-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmActionManage", NULL },
    { L"{D9E04211-14D7-11d1-9938-0060976A546D}", L"CHsmActionOnResourcePostValidate", NULL },
    { L"{D9E04212-14D7-11d1-9938-0060976A546D}", L"CHsmActionOnResourcePreValidate", NULL },
    { L"{7B22FF24-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmActionTruncate", NULL },
    { L"{D3AF5DB1-1DF8-11D0-81B6-00A0C91180F2}", L"CHsmActionUnmanage", NULL },
    { L"{7B22FF26-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmActionValidate", NULL },
    { L"{AD40235F-00FC-11D0-819C-00A0C91180F2}", L"CHsmCritAlways", NULL },
    { L"{CFB04622-1C9F-11D0-81B4-00A0C91180F2}", L"CHsmCritManageable", NULL },
    { L"{7B22FF2C-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmCritMigrated", NULL },
    { L"{7B22FF2D-1AD6-11D0-81B1-00A0C91180F2}", L"CHsmCritPremigrated", NULL },
    { L"{AD402346-00FC-11D0-819C-00A0C91180F2}", L"CHsmJob", NULL },
    { L"{AD402364-00FC-11D0-819C-00a0C91180F2}", L"CHsmJobContext", NULL },
    { L"{AD40234B-00FC-11D0-819C-00a0C91180F2}", L"CHsmJobDef", NULL },
    { L"{B8E1CD21-81D3-11d0-81E4-00A0C91180F2}", L"CHsmJobWorkItem", NULL },
    { L"{AB939AD0-6D67-11d0-9E2E-00A0C916F120}", L"CHsmManagedResource", NULL },
    { L"{8448dd80-7614-11d0-9e33-00a0c916f120}", L"CHsmManagedResourceCollection", NULL },
    { L"{BEA60F8A-7EBA-11d0-81E4-00A0C91180F2}", L"CHsmPhase", NULL },
    { L"{AD402350-00FC-11D0-819C-00A0C91180F2}", L"CHsmPolicy", NULL },
    { L"{AD40235A-00FC-11D0-819C-00A0C91180F2}", L"CHsmRule", NULL },
    { L"{C2E29801-B1BA-11d0-81E9-00A0C91180F2}", L"CHsmRuleStack", NULL },
    { L"{2D1E3156-25DE-11D0-8073-00A0C905F098}", L"CHsmServer", NULL },
    { L"{BEA60F80-7EBA-11d0-81E4-00A0C91180F2}", L"CHsmSession", NULL },
    { L"{FF67BB34-8430-11d0-81E4-00A0C91180F2}", L"CHsmSessionTotals", NULL },
    { L"{61F0B790-82D9-11d0-9E35-00A0C916F120}", L"CHsmStoragePool", NULL },
    { L"{23E45B60-C598-11d0-B16F-00A0C916F120}", L"CHsmWorkItem", NULL },
    { L"{247DF540-C558-11d0-B16F-00A0C916F120}", L"CHsmWorkQueue", NULL },

    { L"{450024A3-47D0-11D0-9E1E-00A0C916F120}", L"CBagHole", NULL },
    { L"{B13FA473-4E1B-11D0-9E22-00A0C916F120}", L"CBagInfo", NULL },
    { L"{F0D7AFE0-9026-11d0-9E3B-00A0C916F120}", L"CMediaInfo", NULL },
    { L"{768AD5A4-40C8-11D0-9E17-00A0C916F120}", L"CSegDB", NULL },
    { L"{37F704E6-3EF9-11D0-9E17-00A0C916F120}", L"CSegRec", NULL },

    { L"{BD030C00-000B-11D0-D0DD-00A0C9190459}", L"CMemIo Class", NULL },
    { L"{BD040C00-000B-11D0-D0DD-00A0C9190459}", L"CNtTapeIo Class", NULL },
    { L"{BD050C00-000B-11D0-D0DD-00A0C9190459}", L"CNtFileIo Class", NULL },

    { L"{FE37FA04-3729-11D0-8CF4-00A0C9190459}", L"RmsCartridge Class", NULL },
    { L"{FE37FA07-3729-11D0-8CF4-00A0C9190459}", L"RmsMediumChanger Class", NULL },
    { L"{FE37FA12-3729-11D0-8CF4-00A0C9190459}", L"RmsClient Class", NULL },
    { L"{FE37FA03-3729-11D0-8CF4-00A0C9190459}", L"RmsDriveClass Class", NULL },
    { L"{FE37FA05-3729-11D0-8CF4-00A0C9190459}", L"RmsDrive Class", NULL },
    { L"{FE37FA08-3729-11D0-8CF4-00A0C9190459}", L"RmsIEPort Class", NULL },
    { L"{FE37FA02-3729-11D0-8CF4-00A0C9190459}", L"RmsLibrary Class", NULL },
    { L"{FE37FA09-3729-11D0-8CF4-00A0C9190459}", L"RmsMediaSet Class", NULL },
    { L"{FE37FA13-3729-11D0-8CF4-00A0C9190459}", L"RmsNTMS Class", NULL },
    { L"{FE37FA11-3729-11D0-8CF4-00A0C9190459}", L"RmsPartition Class", NULL },
    { L"{FE37FA10-3729-11D0-8CF4-00A0C9190459}", L"RmsRequest Class", NULL },
    { L"{FE37FA01-3729-11D0-8CF4-00A0C9190459}", L"RmsServer Class", NULL },
    { L"{FE37FA14-3729-11D0-8CF4-00A0C9190459}", L"RmsSink Class", NULL },
    { L"{FE37FA06-3729-11D0-8CF4-00A0C9190459}", L"RmsStorageSlot Class", NULL },
    { L"{FE37FA15-3729-11D0-8CF4-00A0C9190459}", L"RmsTemplate Class", NULL },

    { NULL, NULL, NULL  }
};

//  Local functions
static BOOL     AddPointer(const void* addr, ULONG size, int index, const char * filename,
        int linenum);
static OLECHAR* GuidToObjectName(const GUID& guid);
static BOOL     SubPointer(const void* addr, int index);


//  AddPointer - add a new pointer to the pointer list
//    Return FALSE on failure (list is full or pointer is already in list)
static BOOL AddPointer(const void* addr, ULONG size, int index, 
        const char * filename, int linenum)
{
    int    empty_slot = -1;
    int    i;
    BOOL   status = TRUE;

    if (!pointer_data_initialized) {
        pointer_data[POINTER_DATA_CURRENT].count = 0;
        pointer_data[POINTER_DATA_CURRENT].size = 0;
        pointer_data[POINTER_DATA_MAX].count = 0;
        pointer_data[POINTER_DATA_MAX].size = 0;
        pointer_data[POINTER_DATA_CUMULATIVE].count = 0;
        pointer_data[POINTER_DATA_CUMULATIVE].size = 0;
        pointer_data_initialized = TRUE;
    }

    for (i = 0; i < pointer_list_count; i++) {
        if (NULL == pointer_list[i].addr) {
            empty_slot = i;
        } else if (addr == pointer_list[i].addr) {
            WsbTraceAlways(OLESTR("AddPointer: address already in list: %lx (<%ls>, line: <%ld>\n"),
                    (ULONG)addr, (OLECHAR *)filename, index);
            status = FALSE;
            break;
        }
    }

    if (i == pointer_list_count) {
        //  Not in list.  Is the list full?
        if (-1 == empty_slot && POINTER_LIST_SIZE == pointer_list_count) {
            WsbTraceAlways(OLESTR("AddPointer: pointer list is full: %lx\n"),
                    (ULONG)addr);
            status = FALSE;
        } else if (-1 == empty_slot) {
            pointer_list_count++;
        } else {
            i = empty_slot;
        }
    }

    if (status) {
        pointer_list[i].addr = addr;
        pointer_list[i].size = size;
        pointer_list[i].index = index;
        pointer_list[i].filename = filename;
        pointer_list[i].linenum = linenum;
        pointer_data[POINTER_DATA_CURRENT].count++;
        pointer_data[POINTER_DATA_CURRENT].size += size;
        if (pointer_data[POINTER_DATA_CURRENT].count > pointer_data[POINTER_DATA_MAX].count) {
            pointer_data[POINTER_DATA_MAX].count = pointer_data[POINTER_DATA_CURRENT].count;
        }
        if (pointer_data[POINTER_DATA_CURRENT].size > pointer_data[POINTER_DATA_MAX].size) {
            pointer_data[POINTER_DATA_MAX].size = pointer_data[POINTER_DATA_CURRENT].size;
        }
        pointer_data[POINTER_DATA_CUMULATIVE].count++;
        pointer_data[POINTER_DATA_CUMULATIVE].size += size;
        pointer_list[i].order = pointer_data[POINTER_DATA_CUMULATIVE].count;
    }

    return(status);
}

//  GuidToObjectName - convert a guid to an object name
static OLECHAR* GuidToObjectName(const GUID& guid)
{
    HRESULT           hr = S_OK;
    int               i;
    OLECHAR *         name = NULL;

    try {
        //  Need to do conversions from string to Guid?
        if (NULL == object_name_table[0].pGuid) {
            i = 0;
            while (object_name_table[i].guid_string) {
                GUID * pg = new GUID;

                WsbAffirmHr(WsbGuidFromString(object_name_table[i].guid_string, 
                        pg));
                object_name_table[i].pGuid = pg;
                i++;
            }
        }

        //  See if this Guid is in the name table
        i = 0;
        while (object_name_table[i].guid_string) {
            if (guid == *object_name_table[i].pGuid) {
                name = object_name_table[i].name;
                break;
            }
            i++;
        }
    } WsbCatch(hr);

    return(name);
}

//  SubPointer - remove a pointer from the pointer list
//    Return FALSE on failure (pointer is not in list or index doesn't match)
static BOOL SubPointer(const void* addr, int index)
{
    int    i;
    BOOL   status = TRUE;

    for (i = 0; i < pointer_list_count; i++) {
        if (addr == pointer_list[i].addr) {
            break;
        }
    }

    if (i == pointer_list_count) {
        WsbTraceAlways(OLESTR("SubPointer: pointer not found in list: %lx\n"),
                (ULONG)addr);
        status = FALSE;
    } else if (index != pointer_list[i].index) {
        WsbTraceAlways(OLESTR("SubPointer: type index doesn't match for pointer: %lx\n"),
                 (ULONG)addr);
        WsbTraceAlways(OLESTR(", original type index = %d, new type index = %d\n"),
                pointer_list[i].index, index);
        status = FALSE;
    }

    if (status) {
        pointer_list[i].addr = NULL;
        pointer_data[POINTER_DATA_CURRENT].count--;
        pointer_data[POINTER_DATA_CURRENT].size -= pointer_list[i].size;
    }

    return(status);
}



HRESULT WsbObjectAdd(
    const GUID &   guid,
    const void *   addr
)
/*++

Routine Description:

    Add another object to the object table

Arguments:

  guid       - Guid for the object type

  addr       - Memory address of object

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;

#if defined(CRT_DEBUG_MEMORY)
    //  Set CRT debug flag
    static BOOL first = TRUE;
    if (first) {
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );

        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

        // Set the new state for the flag
        _CrtSetDbgFlag( tmpFlag );  
    }
#endif

    try {
        int  i;

        //  Reserve the first entry for non-objects and table overflow
        if (0 == object_table_count) {
            object_table[0].guid = GUID_NULL;
            object_table[0].count = 0;
            object_table[0].total_count = 0;
            object_table[0].max_count = 0;
            object_table_count = 1;
        }

        //  Check in object type is already in table
        for (i = 0; i < object_table_count; i++) {
            if (guid == object_table[i].guid) break;
        }
        
        //  Add a new entry if not (and there is room)
        if (i == object_table_count && i < OBJECT_TABLE_SIZE) {
        // WsbTraceAlways(OLESTR("WsbObjectAdd: new object, guid = %ls\n"),
        //    WsbGuidAsString(guid));
#if defined(CRT_DEBUG_MEMORY)
        WsbTraceAlways(OLESTR("WsbObjectAdd: _CrtCheckMemory = %ls\n"),
            WsbBoolAsString(_CrtCheckMemory()));
#endif
            object_table[i].guid = guid;
            object_table[i].count = 0;
            object_table[i].total_count = 0;
            object_table[i].max_count = 0;
            object_table_count++;
        } else if (OBJECT_TABLE_SIZE == i) {
            //  Use the first entry for everything else
            i = 0;
        }
        object_table[i].count++;
        object_table[i].total_count++;
        if (object_table[i].count > object_table[i].max_count) {
            object_table[i].max_count = object_table[i].count;
        }

        //  Add to pointer list
        AddPointer(addr, 0, i, NULL, 0);

    } WsbCatch(hr);

    return(hr);
}


HRESULT WsbObjectSub(
    const GUID &   guid,
    const void *   addr
)
/*++

Routine Description:

    Subtract an object from the object table

Arguments:

  guid       - Guid for the object type

  addr       - Memory address of object

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;

    try {
        int  i;

        //  Find the object type in table
        for (i = 0; i < object_table_count; i++) {
            if (guid == object_table[i].guid) {
                //  Allow count to go negative since this could indicate a problem
                object_table[i].count--;

                //  Remove from pointer list
                SubPointer(addr, i);
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT WsbObjectTracePointers(
    ULONG flags
)
/*++

Routine Description:

    Dump the pointer list information to the trace file.

Arguments:

  flags  - WSB_OTP_ flags 

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;

    try {
        int   i;
        OLECHAR string[300];

        //  Dump the current sequence number
        if (flags & WSB_OTP_SEQUENCE) {
            WsbTraceAlways(OLESTR("WsbObjectTracePointers: current sequence number = %ld\n"),
                    pointer_data[POINTER_DATA_CUMULATIVE].count);
        }

        //  Dump statistics
        if (flags & WSB_OTP_STATISTICS) {
            WsbTraceAlways(OLESTR("WsbObjectTracePointers: count, size\n"));
            WsbTraceAlways(OLESTR("  Current    %8ld %12ls\n"), 
                    pointer_data[POINTER_DATA_CURRENT].count,
                    WsbLonglongAsString(pointer_data[POINTER_DATA_CURRENT].size));
            WsbTraceAlways(OLESTR("  Maximum    %8ld %12ls\n"), 
                    pointer_data[POINTER_DATA_MAX].count,
                    WsbLonglongAsString(pointer_data[POINTER_DATA_MAX].size));
            WsbTraceAlways(OLESTR("  Cumulative %8ld %12ls\n"), 
                    pointer_data[POINTER_DATA_CUMULATIVE].count,
                    WsbLonglongAsString(pointer_data[POINTER_DATA_CUMULATIVE].size));
        }

        //  Dump non-NULL pointers
        if (flags & WSB_OTP_ALLOCATED) {
            WsbTraceAlways(OLESTR("WsbObjectTracePointers: allocated memory list (addr, size, order, name/GUID/file):\n"));
            for (i = 0; i < pointer_list_count; i++) {
                if (pointer_list[i].addr) {
                    GUID         guid = GUID_NULL;
                    int          index;
                    OLECHAR *    name = NULL;
                    OLECHAR *    pstr = NULL;

                    index = pointer_list[i].index;
                    if (index > 0 && index < object_table_count) {
                        guid = object_table[index].guid;
                        name = GuidToObjectName(guid);
                    }
                    if (0 == index) {
                        wsprintf(string, OLESTR("%hs(%d)"), pointer_list[i].filename,
                                pointer_list[i].linenum);
                        pstr = string;
                    } else if (name) {
                        pstr = name;
                    } else {
                        wcscpy(string, WsbGuidAsString(guid));
                        pstr = string;
                    }
                    WsbTraceAlways(OLESTR("  %8lx %8ld %8ld %ls\n"), pointer_list[i].addr,
                            pointer_list[i].size, pointer_list[i].order, pstr);
                }
            }
        }

#if defined(CRT_DEBUG_MEMORY)
        WsbTraceAlways(OLESTR("WsbObjectTrace: calling _CrtMemCheckpoint\n"));
        _CrtMemCheckpoint(&CrtMemState);
        WsbTraceAlways(OLESTR("WsbObjectTrace: MemState.lHighWaterCount = %ld, TotalCount = %ld\n"),
                        CrtMemState.lHighWaterCount, CrtMemState.lTotalCount);
        WsbTraceAlways(OLESTR("WsbObjectTrace: MemState.blocks count & size\n"));
        WsbTraceAlways(OLESTR("  FREE   %4ld %6ld\n"), CrtMemState.lCounts[_FREE_BLOCK],
                CrtMemState.lSizes[_FREE_BLOCK]);
        WsbTraceAlways(OLESTR("  NORMAL %4ld %6ld\n"), CrtMemState.lCounts[_NORMAL_BLOCK],
                CrtMemState.lSizes[_NORMAL_BLOCK]);
        WsbTraceAlways(OLESTR("  CRT    %4ld %6ld\n"), CrtMemState.lCounts[_CRT_BLOCK],
                CrtMemState.lSizes[_CRT_BLOCK]);
        WsbTraceAlways(OLESTR("  IGNORE %4ld %6ld\n"), CrtMemState.lCounts[_IGNORE_BLOCK],
                CrtMemState.lSizes[_IGNORE_BLOCK]);
        WsbTraceAlways(OLESTR("  CLIENT %4ld %6ld\n"), CrtMemState.lCounts[_CLIENT_BLOCK],
                CrtMemState.lSizes[_CLIENT_BLOCK]);

//        WsbTraceAlways(OLESTR("WsbObjectTrace: calling _CrtMemDumpStatistics\n"));
//        _CrtMemDumpStatistics(&CrtMemState);
//        _CrtDumpMemoryLeaks();
#endif

    } WsbCatch(hr);

    return(hr);
}


HRESULT WsbObjectTraceTypes(
    void
)
/*++

Routine Description:

    Dump the object table information to the trace file.

Arguments:

  None.

Return Value:

  S_OK      - Success

--*/
{
    HRESULT           hr = S_OK;

    try {
        int  i;

        WsbTraceAlways(OLESTR("WsbObjectTraceTypes: object table (GUID, total count, max count, current count, name):\n"));
        //  Find the object type in table
        for (i = 0; i < object_table_count; i++) {
            OLECHAR *    name;

            name = GuidToObjectName(object_table[i].guid);
            WsbTraceAlways(OLESTR("  %ls %6ld %5ld %5ld  %ls\n"), WsbGuidAsString(object_table[i].guid),
                    object_table[i].total_count, object_table[i].max_count, 
                    object_table[i].count, (name ? name : OLESTR("")));
        }

    } WsbCatch(hr);

    return(hr);
}


LPVOID WsbMemAlloc(ULONG cb, const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for CoTaskAlloc.

--*/
{
    LPVOID p;

    p = CoTaskMemAlloc(cb);
    if (p) {
        AddPointer(p, cb, 0, filename, linenum);
    }
    return(p);
}


void   WsbMemFree(LPVOID pv, const char *, int)
/*++

Routine Description:

    Debug tracking replacement for CoTaskFree.

--*/
{
    if (pv) {
        SubPointer(pv, 0);
    }
    CoTaskMemFree(pv);
}


LPVOID WsbMemRealloc(LPVOID pv, ULONG cb, const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for CoTaskRealloc.

--*/
{
    LPVOID p;

    p = CoTaskMemRealloc(pv, cb);
    if (p) {
        if (pv) {
            SubPointer(pv, 0);
        }
        AddPointer(p, cb, 0, filename, linenum);
    }
    return(p);
}


BSTR    WsbSysAllocString(const OLECHAR FAR * sz, 
        const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for SysAllocString

--*/
{
    BSTR b;

    b = SysAllocString(sz);
    if (b) {
        AddPointer(b, SysStringByteLen(b), 0, filename, linenum);
    }
    return(b);
}


BSTR    WsbSysAllocStringLen(const OLECHAR FAR * sz, 
        unsigned int cc, const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for SysAllocStringLen

--*/
{
    BSTR b;

    b = SysAllocStringLen(sz, cc);
    if (b) {
        AddPointer(b, SysStringByteLen(b), 0, filename, linenum);
    }
    return(b);
}


void WsbSysFreeString(BSTR bs, const char *, int)
/*++

Routine Description:

    Debug tracking replacement for SysFreeString

--*/
{
    if (bs) {
        SubPointer(bs, 0);
    }
    SysFreeString(bs);
}


HRESULT WsbSysReallocString(BSTR FAR * pb, const OLECHAR FAR * sz, 
        const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for SysReallocString

--*/
{
    HRESULT hr;

    if (*pb) {
        SubPointer(*pb, 0);
    }
    hr = SysReAllocString(pb, sz);
    if (*pb) {
        AddPointer(*pb, SysStringByteLen(*pb), 0, filename, linenum);
    }
    return(hr);
}


HRESULT WsbSysReallocStringLen(BSTR FAR * pb, 
        const OLECHAR FAR * sz, unsigned int cc, const char * filename, int linenum)
/*++

Routine Description:

    Debug tracking replacement for SysStringLen

--*/
{
    HRESULT hr;

    if (*pb) {
        SubPointer(*pb, 0);
    }
    hr = SysReAllocStringLen(pb, sz, cc);
    if (*pb) {
        AddPointer(*pb, SysStringByteLen(*pb), 0, filename, linenum);
    }
    return(hr);
}

#endif // WSB_TRACK_MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbtrace.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbTrace.cpp

Abstract:

    These functions are used to provide an ability to trace the flow
    of the application for debugging purposes.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

    Brian Dodd      [brian]      09-May-1996  - Added event logging

--*/

#include "stdafx.h"
#include "stdio.h"

#undef WsbThrow
#define WsbThrow(hr)                    throw(hr)

#define WSB_INDENT_STRING       OLESTR("  ")
#define WSB_APP_EVENT_LOG       OLESTR("\\System32\\config\\AppEvent.evt")
#define WSB_APP_EVENT_LOG_BKUP  OLESTR("\\System32\\config\\AppEvent.bkp")
#define WSB_APP_EVENT_LOG_NAME  OLESTR("\\AppEvent.evt")
#define WSB_SYS_EVENT_LOG       OLESTR("\\System32\\config\\SysEvent.evt")
#define WSB_SYS_EVENT_LOG_BKUP  OLESTR("\\System32\\config\\SysEvent.bkp")
#define WSB_SYS_EVENT_LOG_NAME  OLESTR("\\SysEvent.evt")
#define WSB_RS_TRACE_FILES      OLESTR("Trace\\*.*")
#define WSB_RS_TRACE_PATH       OLESTR("Trace\\")

#define BOGUS_TLS_INDEX         0xFFFFFFFF

// Per-thread data:
typedef struct {
    ULONG TraceOffCount;  // Trace only if this is zero
    LONG  IndentLevel;
    char *LogModule;
    DWORD LogModuleLine;
    DWORD LogNTBuild;
    DWORD LogRSBuild;
} THREAD_DATA;

static DWORD TlsIndex = BOGUS_TLS_INDEX; // Per-thread data index

// The globals that control the tracing
LONGLONG            g_WsbTraceModules = WSB_TRACE_BIT_NONE;
IWsbTrace           *g_pWsbTrace = 0;
BOOL                g_WsbTraceEntryExit = TRUE;

// The globals that control the event logging and printing
WORD                g_WsbLogLevel = WSB_LOG_LEVEL_DEFAULT;
BOOL                g_WsbLogSnapShotOn = FALSE;
WORD                g_WsbLogSnapShotLevel = 0;
OLECHAR             g_pWsbLogSnapShotPath[250];
BOOL                g_WsbLogSnapShotResetTrace = FALSE;
WORD                g_WsbPrintLevel = WSB_LOG_LEVEL_DEFAULT;

//
// WsbTraceCount is a running count of the trace output count: normally we
// use the shared count among the processes, but if we can't get access to
// the shared var., we use this
//
LONG g_WsbTraceCount = 0;

// Helper function
static HRESULT OutputTraceString(ULONG indentLevel, OLECHAR* introString, 
        OLECHAR* format, va_list vaList);
static HRESULT GetThreadDataPointer(THREAD_DATA** ppTD);
static void SnapShotTraceAndEvent(  SYSTEMTIME      stime   );



void 
WsbTraceInit( 
    void 
    )

/*++

Routine Description:

    Initialize this trace module

Arguments:

    None.

Return Value:

    None.

--*/
{
    //  Get an index for the thread local storage
    TlsIndex = TlsAlloc();
}


void 
WsbTraceCleanupThread( 
    void 
    )

/*++

Routine Description:

    Cleanup information for this thread (which is going away)

Arguments:

    None.

Return Value:

    None.

--*/
{
    THREAD_DATA* pThreadData = NULL;

    if (BOGUS_TLS_INDEX != TlsIndex) {
        pThreadData = static_cast<THREAD_DATA*>(TlsGetValue(TlsIndex));
        if (pThreadData) {
            WsbFree(pThreadData);
            TlsSetValue(TlsIndex, NULL);
        }
    }
}


void
WsbTraceEnter(
    OLECHAR* methodName,
    OLECHAR* argString,
    ...
    )

/*++

Routine Description:

    This routine prints out trace information indicating that the
    method specified has been entered, and the values of its arguements
    (if supplied).

Arguments:

    methodName  - The name of the method that was entered.

    argString   - A printf style string indicating the number of
                  arguments and how they should be formatted.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    OLECHAR         tmpString[WSB_TRACE_BUFF_SIZE];
    va_list         vaList;

    try  {
        THREAD_DATA* pThreadData = NULL;

        WsbAffirmHr(GetThreadDataPointer(&pThreadData));

        // Make sure we are supposed to trace
        WsbAffirm( 0 != g_pWsbTrace, S_OK);
        WsbAffirm(0 == pThreadData->TraceOffCount, S_OK);

        // Identify the function.
        swprintf(tmpString, OLESTR("Enter <%ls> :  "), methodName);

        // Format & print out
        va_start(vaList, argString);
        WsbAffirmHr(OutputTraceString(pThreadData->IndentLevel, tmpString,
            argString, vaList));
        va_end(vaList);

        // Increment the indentation level
        pThreadData->IndentLevel++;

    } WsbCatch (hr);
}


void
WsbTraceExit(
    OLECHAR* methodName,
    OLECHAR* argString,
    ...
    )

/*++

Routine Description:

    This routine prints out trace information indicating that the
    method specified has been exitted, and the values it is returning
    (if supplied).

Arguments:

    methodName  - The name of the method that was exitted.

    argString   - A printf style string indicating the number of
                  arguments and how they should be formatted.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    OLECHAR         tmpString[WSB_TRACE_BUFF_SIZE];
    va_list         vaList;

    try  {
        THREAD_DATA* pThreadData = NULL;

        WsbAffirmHr(GetThreadDataPointer(&pThreadData));

        // Make sure we are supposed to trace
        WsbAffirm( 0 != g_pWsbTrace, S_OK);
        WsbAffirm(0 == pThreadData->TraceOffCount, S_OK);

        // Decrement the indentation level.
        if (pThreadData->IndentLevel > 0) {
            pThreadData->IndentLevel--;
        } else {
            g_pWsbTrace->Print(OLESTR("WARNING: Badly matched TraceIn/TraceOut\r\n"));
        }

        // Identify the function.
        swprintf(tmpString, OLESTR("Exit  <%ls> :  "), methodName);

        // Format & print out
        va_start(vaList, argString);
        WsbAffirmHr(OutputTraceString(pThreadData->IndentLevel, tmpString,
            argString, vaList));
        va_end(vaList);
        
    } WsbCatch( hr );
}


void
WsbTracef(
    OLECHAR* argString,
    ...
    )

/*++

Routine Description:

    This routine prints out trace information from a printf style string.
    A carriage return should be add to the format string if desired.

Arguments:

    argString   - A printf style string indicating the number of
                  arguments and how they should be formatted.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    va_list         vaList;

    try  {
        THREAD_DATA* pThreadData = NULL;

        WsbAffirmHr(GetThreadDataPointer(&pThreadData));

        // Make sure we are supposed to trace
        WsbAffirm( 0 != g_pWsbTrace, S_OK);
        WsbAffirm(0 == pThreadData->TraceOffCount, S_OK);

        // Format & print out
        va_start(vaList, argString);
        WsbAffirmHr(OutputTraceString(pThreadData->IndentLevel, NULL,
            argString, vaList));
        va_end(vaList);
        
    }  WsbCatch (hr);

}


void
WsbSetEventInfo(
    char *fileName,
    DWORD lineNo,
    DWORD ntBuild,
    DWORD rsBuild 
    )

/*++

Routine Description:

    This routine sets information used in logging events.

Arguments:

    fileName - The name of the module that logged the event.
    lineNo   - The source line number of the statement that logged the event
    ntBuild  - The NT Build version
    rsBuild  - The RS Build version

Return Value:

    None.

Notes:

    ntBuild, and rsBuild are passed in with each call to get the build version for
    the modules actually logging the event.

--*/
{
    THREAD_DATA* pThreadData = NULL;

    if (S_OK == GetThreadDataPointer(&pThreadData)) {
        pThreadData->LogModule = fileName;
        pThreadData->LogModuleLine = lineNo;
        pThreadData->LogNTBuild = ntBuild;
        pThreadData->LogRSBuild = rsBuild;
    }
}


void
WsbTraceAndLogEvent(
    DWORD       eventId,
    DWORD       dataSize,
    LPVOID      data,
    ...
    )

/*++

Routine Description:

    This routine writes a message into the system event log.  The message
    is also written to the application trace file.  

Arguments:

    eventId    - The message Id to log.
    dataSize   - Size of arbitrary data.
    data       - Arbitrary data buffer to display with the message.
    Inserts    - Message inserts that are merged with the message description specified by
                   eventId.  The number of inserts must match the number specified by the
                   message description.  The last insert must be NULL to indicate the
                   end of the insert list.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;

    try  {

        va_list         vaList;

        va_start(vaList, data);
        WsbTraceAndLogEventV( eventId, dataSize, data, &vaList );
        va_end(vaList);

    }
    WsbCatch( hr );

}


void
WsbTraceAndLogEventV(
    DWORD       eventId,
    DWORD       dataSize,
    LPVOID      data,
    va_list *   inserts
    )

/*++

Routine Description:

    This routine writes a message into the system event log.  The message
    is also written to the application trace file.  The file name and line number is appended 
    to the log data, if any.


Arguments:

    eventId    - The message Id to log.
    dataSize   - Size of arbitrary data.
    data       - Arbitrary data buffer to display with the message.
    inserts    - An array of message inserts that are merged with the message description
                   specified by eventId.  The number of inserts must match the number
                   specified by the message description.  The last insert must be NULL,
                   to indicate the end of the insert list.

Return Value:

    None.

--*/
{

    HRESULT         hr = S_OK;
    char            *newData = NULL, *fileName;
    DWORD           newDataSize=0;
    OLECHAR **      logString=0;
    WORD            count=0;
    SYSTEMTIME      stime;


    try  {

        WsbAssertPointer( inserts );

        WORD            logType;
        const OLECHAR * facilityName = 0;
        WORD            category = 0;
        va_list         vaList;
        BOOL            bLog;
        BOOL            bSnapShot;
        THREAD_DATA*    pThreadData = NULL;


        // Get space for the passed in data plus the file and line number.  If we fail to allocate
        // memory for this we just log the data they passed in (without file and line)
        GetThreadDataPointer(&pThreadData);
        if (pThreadData) {
            fileName = strrchr(pThreadData->LogModule, '\\');
        } else {
            fileName = NULL;
        }
        if (fileName) {
            fileName++;     // Point at just the source file name (no path)

            int len = strlen(fileName);

            newData = (char *) malloc(dataSize + len + 128);
            if (newData) {
                if (data) {
                    memcpy(newData, data, dataSize);
                }
                // Align the record data on even 8 byte boundary for viewing
                len = (len>8) ? 16 : 8;
                sprintf(&newData[dataSize], "%-*.*s@%7luNt%6luRs%6.6ls", len,
                        len, fileName, pThreadData->LogModuleLine, pThreadData->LogNTBuild, 
                        RsBuildVersionAsString(pThreadData->LogRSBuild)  );
                newDataSize = dataSize + strlen(&newData[dataSize]);
            }
        }

        //
        // Determine type of event
        //

        switch ( eventId & 0xc0000000 ) {
        case ERROR_SEVERITY_INFORMATIONAL:
            logType = EVENTLOG_INFORMATION_TYPE;
            bLog = (g_WsbLogLevel >= WSB_LOG_LEVEL_INFORMATION) ? TRUE : FALSE;
            bSnapShot = (g_WsbLogSnapShotLevel >= WSB_LOG_LEVEL_INFORMATION) ? TRUE : FALSE;
            break;
        case ERROR_SEVERITY_WARNING:
            logType = EVENTLOG_WARNING_TYPE;
            bLog = (g_WsbLogLevel >= WSB_LOG_LEVEL_WARNING) ? TRUE : FALSE;
            bSnapShot = (g_WsbLogSnapShotLevel >= WSB_LOG_LEVEL_WARNING) ? TRUE : FALSE;
            break;
        case ERROR_SEVERITY_ERROR:
            logType = EVENTLOG_ERROR_TYPE;
            bLog = (g_WsbLogLevel >= WSB_LOG_LEVEL_ERROR) ? TRUE : FALSE;
            bSnapShot = (g_WsbLogSnapShotLevel >= WSB_LOG_LEVEL_ERROR) ? TRUE : FALSE;
            break;
        default:
            logType = EVENTLOG_INFORMATION_TYPE;
            bLog = (g_WsbLogLevel >= WSB_LOG_LEVEL_COMMENT) ? TRUE : FALSE;
            bSnapShot = (g_WsbLogSnapShotLevel >= WSB_LOG_LEVEL_COMMENT) ? TRUE : FALSE;
            break;
        }

        WsbAffirm ( bLog, S_OK );

        WsbTracef(OLESTR("\r\n"));
        WsbTracef(OLESTR("!!!!! EVENT !!!!! - File: %hs @ Line: %d (%lu-%ls)\r\n"), 
                (pThreadData ? pThreadData->LogModule : ""), 
                (pThreadData ? pThreadData->LogModuleLine : 0), 
                (pThreadData ? pThreadData->LogNTBuild : 0), 
                RsBuildVersionAsString((pThreadData ? pThreadData->LogRSBuild : 0)) );

        //
        // Determine source facility and category of message
        //

        switch ( HRESULT_FACILITY( eventId ) ) {

        case WSB_FACILITY_PLATFORM:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_PLATFORM;
            break;

        case WSB_FACILITY_RMS:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_RMS;
            break;

        case WSB_FACILITY_HSMENG:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_HSMENG;
            break;

        case WSB_FACILITY_JOB:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_JOB;
            break;

        case WSB_FACILITY_HSMTSKMGR:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_HSMTSKMGR;
            break;

        case WSB_FACILITY_FSA:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_FSA;
            break;

        case WSB_FACILITY_GUI:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_GUI;
            break;

        case WSB_FACILITY_MOVER:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_MOVER;
            break;

        case WSB_FACILITY_LAUNCH:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_LAUNCH;
            break;

        case WSB_FACILITY_USERLINK:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            category = WSB_CATEGORY_USERLINK;
            break;

        case WSB_FACILITY_TEST:
            facilityName = WSB_FACILITY_TEST_NAME;
            category = WSB_CATEGORY_TEST;
            break;

        case HRESULT_FACILITY(FACILITY_NT_BIT):
            facilityName = WSB_FACILITY_NTDLL_NAME;
            eventId &= ~FACILITY_NT_BIT;
            break;
            
        default:
            facilityName = WSB_FACILITY_NTDLL_NAME;
            break;
        }

        //
        // Trace the message
        //

        if ( g_pWsbTrace ) {

            if ( facilityName ) {

                OLECHAR * messageText = 0;

                // NOTE: Positional parameters in the inserts are not processed.  These
                //       are done by ReportEvent() only.

                vaList = *inserts;
                HMODULE hModule;

                hModule = LoadLibraryEx( facilityName, NULL, LOAD_LIBRARY_AS_DATAFILE );
                if (hModule) {
                    FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                   hModule,
                                   eventId,
                                   MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                                   (LPTSTR) &messageText,
                                   0,
                                   &vaList );

                    if ( messageText ) {
                        WsbTracef( OLESTR("%ls"), messageText );  // Format messages come with \n
                        LocalFree( messageText );
                     } else {
                        WsbTracef( OLESTR("!!!!! EVENT !!!!! - Message <0x%08lx> could not be translated.\r\n"), eventId );
                     }
                     FreeLibrary(hModule);
                
                } else {
                        WsbTracef( OLESTR("!!!!! EVENT !!!!! - Could not load facility name DLL %ls. \r\n"), facilityName);
                }
           } else {
               WsbTracef( OLESTR("!!!!! EVENT !!!!! - Message File for <0x%08lx> could not be found.\r\n"), eventId );
           }
           if ( data && dataSize > 0 )
               WsbTraceBufferAsBytes( dataSize, data );
        }

        // Prepare arguments for ReportEvent

        // First count the number of arguments
        vaList = *inserts;
        for( count = 0; (va_arg( vaList, OLECHAR *)) != NULL; count++ );

        if ( count ) {
            OLECHAR*        tmpArg;

            // Allocate a array to hold the string arguments.

            //
            // IMPORTANT NOTE:  Don't try anything fancy here.  va_list is different
            //                  on various platforms.  We'll need to build the string
            //                  argument required by ReportEvent (too bad ReportEvent
            //                  doesn't take va_list like FormatMessage does.
            //
            logString = (OLECHAR **)malloc( count*sizeof(OLECHAR *) );
            WsbAffirmAlloc( logString );

            // load in the strings
            vaList = *inserts;
            for( count = 0; (tmpArg = va_arg( vaList, OLECHAR *)) != NULL; count++ ) {
                logString[count] = tmpArg;
            }
        }

        // Get a handle to the event source
        HANDLE hEventSource = RegisterEventSource(NULL, WSB_LOG_SOURCE_NAME );
        
        // Get the time in case we need to snap shot this event's logs and traces
        GetLocalTime(&stime);
        
        if (hEventSource != NULL) {
            // Write to event log
            DWORD recordDataSize = (newData) ? newDataSize : dataSize;
            LPVOID recordData = (newData) ? newData : data;
            
            if ( ReportEvent(hEventSource, logType, category, eventId, NULL, count, recordDataSize, (LPCTSTR *)&logString[0], recordData) ) {
                WsbTracef( OLESTR("!!!!! EVENT !!!!! - Event <0x%08lx> was logged.\r\n"), eventId );
                WsbTracef( OLESTR("\r\n") );
            } else {
                WsbTracef( OLESTR("!!!!! EVENT !!!!! - Event <0x%08lx> could not be logged due to the following error: %ls\r\n"), eventId, WsbHrAsString(HRESULT_FROM_WIN32(GetLastError())) );
                WsbTracef( OLESTR("\r\n") );
            }
            DeregisterEventSource(hEventSource);
        }
        
        try  {
            HRESULT hr2 = S_OK;
            // 
            // See if we are to take a snap shot of the event and trace logs when an event of this level is logged.
            //
            if ( (TRUE == bSnapShot) &&
                 (TRUE == g_WsbLogSnapShotOn) )  {
                    SnapShotTraceAndEvent(stime);
            }
        } WsbCatchAndDo(hr, hr=S_OK; );
        
    } WsbCatch( hr );

    if (newData) {
        free(newData);
    }

    if (logString) {
        free(logString);
    }

}


const OLECHAR*
WsbBoolAsString(
    BOOL boolean
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. TRUE, FALSE) for
    the value of the boolean supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    boolean     - A boolean value.

Return Value:

    A string representation of the value of the boolean.

--*/
{
    return(boolean ? OLESTR("TRUE") : OLESTR("FALSE"));
}


const OLECHAR*
WsbLongAsString(
    LONG inLong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    long supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    long        - A long value

Return Value:

    A string representation of the value of the GUID.

--*/
{
    static OLECHAR  defaultString[40];
    swprintf( defaultString, OLESTR("%ld"), inLong );
    return(defaultString);
}


const OLECHAR*
WsbFiletimeAsString(
    IN BOOL isRelative,
    IN FILETIME time
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    FILETIME supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    isRelatice  - A boolean that indicates whether the time is absolute (e.g 1/1/1987 ...)
                  or relative (e.g. 1 hour).

    time        - A FILETIME.

Return Value:

    A string representation of the value of the FILETIME.

--*/
{
    static OLECHAR  defaultString[80];
    OLECHAR*        tmpString = 0;
    HRESULT         hr;

    hr = WsbFTtoWCS(isRelative, time, &tmpString, sizeof(defaultString));
    if (hr == S_OK) {
        wcscpy(defaultString, tmpString);
    } else {
        wcscpy(defaultString, L"BADFILETIME");
    }
    WsbFree(tmpString);

    return(defaultString);
}


const OLECHAR*
WsbGuidAsString(
    GUID guid
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    GUID supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    guid        - A GUID.

Return Value:

    A string representation of the value of the GUID.

--*/
{
    static OLECHAR  defaultString[40];
    swprintf( defaultString, OLESTR("{%.8x-%.4x-%.4hx-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"),
        guid.Data1, (UINT)guid.Data2, (UINT)guid.Data3,
        (UINT) guid.Data4[0], (UINT) guid.Data4[1], 
        (UINT) guid.Data4[2], (UINT) guid.Data4[3], (UINT) guid.Data4[4], 
        (UINT) guid.Data4[5], (UINT) guid.Data4[6], (UINT) guid.Data4[7]);

    return(defaultString);
}


const OLECHAR*
WsbHrAsString(
    HRESULT hr
    )

/*++

Routine Description:

    This routine provides a string repesentation (e.g. S_OK, E_POINTER) for
    the value of the HRESULT supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    hr      - An HRESULT.

Return Value:

    A string representation of the value of the HRESULT.

--*/
{
    const OLECHAR *returnString = 0;
    const OLECHAR *facilityName = 0;
    const DWORD cSize = 1024;
    DWORD stringSize = (cSize - 20);
    static OLECHAR defaultString[cSize];
    DWORD   lastError;
    
    // Handle a few special cases which are not in the message table resource
    switch ( hr ) {

    case S_OK:
        returnString = OLESTR("Ok");        // This overloads Win32 NO_ERROR.
        break;

    case S_FALSE:
        returnString = OLESTR("False");     // This overloads Win32 ERROR_INVALID_FUNCTION
        break;

    default:
        break;
    }

    if ( 0 == returnString ) {

        returnString = defaultString;

        swprintf( defaultString, OLESTR("0x%08lx"), hr );

        //
        // First, try getting the message from the system 
        //
        if ( 0 == FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 hr,
                                 MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                                 defaultString,
                                 stringSize,
                                 NULL ) ) {

            lastError = GetLastError();     // For debugging

            // Next, try the module executing this code.

            if ( 0 == FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                     NULL,
                                     hr,
                                     MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                                     defaultString,
                                     stringSize,
                                     NULL ) ) {

                lastError = GetLastError();     // For debugging

                // Finally, try to identify the module based on the facility code

                switch ( HRESULT_FACILITY( hr ) ) {
                case WSB_FACILITY_PLATFORM:
                case WSB_FACILITY_RMS:
                case WSB_FACILITY_HSMENG:
                case WSB_FACILITY_JOB:
                case WSB_FACILITY_HSMTSKMGR:
                case WSB_FACILITY_FSA:
                case WSB_FACILITY_GUI:
                case WSB_FACILITY_MOVER:
                case WSB_FACILITY_LAUNCH:
                case WSB_FACILITY_USERLINK:
                    facilityName = WSB_FACILITY_PLATFORM_NAME;
                    break;

                case WSB_FACILITY_TEST:
                    facilityName = WSB_FACILITY_TEST_NAME;
                    break;

                case HRESULT_FACILITY(FACILITY_NT_BIT):
                    facilityName = WSB_FACILITY_NTDLL_NAME;
                    hr &= ~FACILITY_NT_BIT;
                    break;

                default:
                    facilityName = WSB_FACILITY_NTDLL_NAME;
                    break;
                }

                if ( facilityName ) {
                    HMODULE hModule;

                    hModule = LoadLibraryEx( facilityName, NULL, LOAD_LIBRARY_AS_DATAFILE );
                    if (hModule) {
                        FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                       hModule,
                                       hr,
                                       MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                                       defaultString,
                                       stringSize,
                                       NULL );
                        FreeLibrary(hModule);
                    } else {
                        WsbTracef( OLESTR("!!!!! EVENT !!!!! - Could not load facility name DLL %ls. \r\n"), facilityName);
                    }
                } 
            }
        }

        //
        // remove trailing \r\n ( this makes things nice for tracing and asserts )
        //
        if ( defaultString[ wcslen(defaultString)-1 ] == OLESTR('\n') ) {

            defaultString[ wcslen(defaultString)-1 ] = OLESTR('\0');

            if ( defaultString[ wcslen(defaultString)-1 ] == OLESTR('\r') ) {

                defaultString[ wcslen(defaultString)-1 ] = OLESTR('\0');
                swprintf( &defaultString[ wcslen(defaultString) ], OLESTR(" (0x%08lx)"), hr );

            }
        }
    }

    return ( returnString );
}


const OLECHAR*
WsbLonglongAsString(
    LONGLONG llong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    LONGLONG supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    llong - A LONGLONG value.

Return Value:

    A string representation of the value.

--*/
{
    static OLECHAR  defaultString[128];
    OLECHAR* ptr = &defaultString[0];
    
    WsbLLtoWCS(llong, &ptr, 128);
    return(defaultString);
}



const OLECHAR*
WsbStringAsString(
    OLECHAR* pStr
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    String supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    pStr - A string value.

Return Value:

    A string representation of the value.

--*/
{
    OLECHAR*        returnString;

    if (0 == pStr) {
        returnString = OLESTR("NULL");
    } else {
        returnString = pStr;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToBoolAsString(
    BOOL* pBool
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a BOOL supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    pBool       - A pointer to a BOOL or NULL.

Return Value:

    A string representation of the value of the BOOL or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;

    if (0 == pBool) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbBoolAsString(*pBool);
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToFiletimeAsString(
    IN BOOL isRelative,
    IN FILETIME *pTime
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    FILETIME supplied.
    
    NOTE: This method shares memory between subsequent calls of the function.

Arguments:

    iselatice  - A boolean that indicates whether the time is absolute (e.g 1/1/1987 ...)
                  or relative (e.g. 1 hour).

    pTime       - A pointer to a FILETIME.

Return Value:

    A string representation of the value of the FILETIME.

--*/
{
    OLECHAR*        returnString;

    if (0 == pTime) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbFiletimeAsString(isRelative, *pTime);
    }

    return(returnString);
}

const OLECHAR*
WsbPtrToGuidAsString(
    GUID* pGuid
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a GUID supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    pGuid       - A pointer to a GUID or NULL.

Return Value:

    A string representation of the value of the GUID or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;

    if (0 == pGuid) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbGuidAsString(*pGuid);
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToHrAsString(
    HRESULT * pHr
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a HRESULT supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    pHr     - A pointer to an HRESULT.

Return Value:

    A string representation of the value of the HRESULT.


--*/
{
    OLECHAR*        returnString;

    if (0 == pHr) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbHrAsString(*pHr);
    }

    return(returnString);
}

const OLECHAR*
WsbPtrToLonglongAsString(
    LONGLONG* pLlong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a LONGLONG supplied.
    
    NOTE: This method does not support localization of the strings.

Arguments:

    pLonglong   - A pointer to a LONGLONG or NULL.

Return Value:

    A string representation of the value of the LONGLONG or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;

    if (0 == pLlong) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbLonglongAsString(*pLlong);
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToLongAsString(
    LONG* pLong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a LONG supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pLong       - A pointer to a LONG or NULL.

Return Value:

    A string representation of the value of the LONG or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pLong) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%ld"), *pLong);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToShortAsString(
    SHORT* pShort
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a SHORT supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pShort      - A pointer to a SHORT or NULL.

Return Value:

    A string representation of the value of the SHORT or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pShort) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%d"), *pShort);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToByteAsString(
    BYTE* pByte
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a BYTE supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pByte       - A pointer to a BYTE or NULL.

Return Value:

    A string representation of the value of the BYTE or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pByte) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%d"), *pByte);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToStringAsString(
    OLECHAR** pString
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a string supplied.
    
    NOTE: This method does not support localization ofthe strings.

Arguments

    pString     - A pointer to a OLECHAR* or NULL.

Return Value:

    The string or "NULL" if the pointer was null.

--*/
{
    OLECHAR*        returnString;

    if( (0 == pString) || (0 == *pString) ) {
        returnString = OLESTR("NULL");
    } else {
        returnString = *pString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToUliAsString(
    ULARGE_INTEGER* pUli
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a ULARGE_INTEGER supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pUli        - A pointer to a ULARGE_INTEGER or NULL.

Return Value:

    A string representation of the value of the ULARGE_INTEGER or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;

    if (0 == pUli) {
        returnString = OLESTR("NULL");
    } else {
        returnString = (OLECHAR*) WsbLonglongAsString( pUli->QuadPart );
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToUlongAsString(
    ULONG* pUlong
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a ULONG supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pUlong      - A pointer to a ULONG or NULL.

Return Value:

    A string representation of the value of the ULONG or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pUlong) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%lu"), *pUlong);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToUshortAsString(
    USHORT* pUshort
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a USHORT supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pUshort     - A pointer to a USHORT or NULL.

Return Value:

    A string representation of the value of the USHORT or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == pUshort) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("%u"), *pUshort);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbPtrToPtrAsString(
    void** ppVoid
    )

/*++

Routine Description:

    This routine provides a string repesentation for the value of the
    pointer to a ULONG supplied.
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    pUlong      - A pointer to a ULONG or NULL.

Return Value:

    A string representation of the value of the ULONG or "NULL" if the
    pointer was null.

--*/
{
    OLECHAR*        returnString;
    static OLECHAR  defaultString[20];

    if (0 == ppVoid) {
        returnString = OLESTR("NULL");
    } else {
        swprintf(defaultString, OLESTR("0x%p"), *ppVoid);
        returnString = defaultString;
    }

    return(returnString);
}


const OLECHAR*
WsbAbbreviatePath(
    const OLECHAR* path,
    USHORT   length
    )

/*++

Routine Description:

    This routine condenses a path from it's original length to the requested
    length by chopping out it's middle characters
    
    NOTE: This method does not support localization of the strings, and
    shares memory between subsequent calls of the function.

Arguments:

    path        - A pointer to the path
    length      - The condensed path length including the \0

Return Value:

    A string representation of the value of the BYTE or "NULL" if the
    pointer was null.  This function also returns "NULL" if the length is less
    than 4 bytes.

--*/
{
    HRESULT                 hr = S_OK;
    OLECHAR*                returnString;
    static CWsbStringPtr    tmpString;

    returnString = OLESTR("ERROR");
    try  {
        //
        // Check to see if we have anything to work with
        //
        if ((0 == path) || (length < 4)) {
            returnString = OLESTR("NULL");
        } else {
            // 
            // Get enough space for the return
            //
            USHORT pathlen;
            pathlen = (USHORT)wcslen(path);
            hr = tmpString.Realloc(length);
            if (S_OK != hr)  {
                returnString = OLESTR("No memory");
                WsbAffirmHr(hr);
            }
            
            if (pathlen < length) {
                swprintf(tmpString, OLESTR("%s"), path);
            } else  {
                USHORT partlength = (USHORT) ( (length - 4) / 2 );
                wcsncpy(tmpString, path, partlength);
                tmpString[(int) partlength] = L'\0';
                wcscat(tmpString, OLESTR("..."));
                wcscat(tmpString, &(path[pathlen - partlength]));
            }
            returnString = tmpString;
        }
    }  WsbCatch(hr);

    return(returnString);
}


void WsbTraceBufferAsBytes(
    DWORD size,
    LPVOID data
    )
/*++

Routine Description:

    This routine traces an arbitrary size buffer of bytes in hex and asci.

    A similar routine could be written trace a buffer in words.

Arguments:

    size        - The size of buffer to trace.
    data        - The data to trace.

Return Value:

    None.

--*/
{
    HRESULT hr = S_OK;

    try {
        // Make sure we are supposed to trace
        WsbAffirm( 0 != g_pWsbTrace, S_OK);

        // Make sure we have something to trace
        WsbAssertPointer( data );

        CWsbStringPtr   traceString;
        char            *output;
        unsigned char   *bufferP = (unsigned char *)data;

        // IMPORTANT NOTE: Changing these may mean the last line processing need to be changed.
        char *beginAsci = "   [";
        char *endAsci   = "]";
        char *charFmt   = "%02x";
        char *addFmt    = "%04x:";
        char *between8  = "   ";
        char *between4  = "  ";

        char noPrintChar = 0x2e;

        const int ll = 16; // IMPORTANT NOTE: line length, a multiple of 8 - if this changes, the last line processing needs to be fixed.

        int lineCount = 0;

        output = (char *)malloc( (/*address*/6+/*data*/(ll*3)+/*asci*/4+ll+3/*between*/+7+1)*sizeof(char) );
        WsbAffirmAlloc( output );

        if ( size > 0 ) {
            unsigned long i, ii, j, k;
            long repeat;
            unsigned char c;

            for ( i = 0; i < size; i++ ) {
                if ( (0 == i % ll) && (i != 0) ) {
                    // print asci interpretation
                    sprintf( output, beginAsci );
                    traceString.Append(output);
                    for ( j = 0; j < ll; j++ ) {
                        c = bufferP[i-ll+j];
                        if ( c < ' ' || c > '~' ) {
                            c = noPrintChar;
                        }
                        sprintf( output, "%c", c );
                        traceString.Append(output);
                    }
                    sprintf( output, endAsci );
                    traceString.Append(output);
                    WsbTracef( OLESTR("%ls\n"), (WCHAR *) traceString );
                    lineCount++;
                    // now check if the next line is the same as the one just printed
                    repeat = 0;
                    ii = i;
                    while ( (0 == memcmp( &bufferP[ii-ll], &bufferP[ii], ll )) && (ii+ll < size) ) {
                        repeat++;
                        ii += ll;
                    }
                    if ( repeat > 1 ) {
                        sprintf( output, "        previous line repeats %ld times", repeat);
                        traceString = output;
                        WsbTracef( OLESTR("%ls\n"), (WCHAR *) traceString );
                        lineCount++;
                        i = ii;
                    }
                }
                if ( 0 == i % ll ) {
                    // print address
                    sprintf( output, addFmt, i );
                    traceString = output;
                }

                // add alignment spacing
                if ( (0 == (i + 8) % ll) ) {
                    sprintf( output, between8 );
                    traceString.Append(output);
                }
                else if ( 0 == i % 4 ) {
                    sprintf( output, between4 );
                    traceString.Append(output);
                }
                else {
                    sprintf( output, " " );
                    traceString.Append(output);
                }
                // print byte in hex
                sprintf( output, charFmt, bufferP[i] );
                traceString.Append(output);
            }

            // handle the last line; i allways > 0 here
            // NOTE: This is only good for upto 16 chars per line.
            if ( i % ll ) {
                k = (ll - (i % ll)) * 3 + ( (i % ll) < 5 ? 1 : 0 )+ ( (i % ll) < 9 ? 2 : 0 )+ ( (i % ll) < 13 ? 1 : 0 );
                for ( j = 0; j < k ; j++ ) {
                    sprintf( output, " ");
                    traceString.Append(output);
                }
            }
            k = (i % ll) ? (i % ll) : ll ;
            sprintf( output, beginAsci );
            traceString.Append(output);
            for ( j = 0; j < k; j++ ) {
                c = bufferP[i-k+j];
                if ( c < ' ' || c > '~' ) {
                    c = noPrintChar;
                }
                sprintf( output, "%c", c );
                traceString.Append(output);
            }
            sprintf( output, endAsci); lineCount++;
            traceString.Append(output);
            WsbTracef( OLESTR("%ls\n"), (WCHAR *) traceString );
        }

    }
    WsbCatch( hr );
}


void 
WsbTraceTerminate( 
    void 
    )

/*++

Routine Description:

    Terminate (cleanup) this module because the process is ending

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (BOGUS_TLS_INDEX != TlsIndex) {
        TlsFree(TlsIndex);
        TlsIndex = BOGUS_TLS_INDEX;
    }
}


ULONG 
WsbTraceThreadOff( 
    void 
    )

/*++

Routine Description:

    Increment the trace-off count for this thread

Arguments:

    None.

Return Value:

    The final trace-off count.

--*/
{
    ULONG count = 0;
    THREAD_DATA* pThreadData = NULL;

    if (S_OK == GetThreadDataPointer(&pThreadData)) {
        count = ++(pThreadData->TraceOffCount);
    }
    return(count);
}


ULONG 
WsbTraceThreadOffCount( 
    void 
    )

/*++

Routine Description:

    Return the current trace-off count for this thread

Arguments:

    None.

Return Value:

    The current trace-off count.

--*/
{
    ULONG count = 0;
    THREAD_DATA* pThreadData = NULL;

    if (S_OK == GetThreadDataPointer(&pThreadData)) {
        count = pThreadData->TraceOffCount;
    }
    return(count);
}


ULONG 
WsbTraceThreadOn( 
    void 
    )

/*++

Routine Description:

    Decrement the trace-off count for this thread

Arguments:

    None.

Return Value:

    The final trace-off count.

--*/
{
    ULONG count = 0;
    THREAD_DATA* pThreadData = NULL;

    if (S_OK == GetThreadDataPointer(&pThreadData)) {
        if (0 < pThreadData->TraceOffCount) {
            pThreadData->TraceOffCount--;
        }
        count = pThreadData->TraceOffCount;
    }
    return(count);
}


static HRESULT 
OutputTraceString(
    IN ULONG indentLevel, 
    IN OLECHAR* introString, 
    IN OLECHAR* format,
    IN va_list vaList
)

/*++

Routine Description:

    Build and output the trace string.

Arguments:

    indentLevel - Count of indentation strings to output

    introString - String to add before variable list

    vaList      - Variable list to format

Return Value:

    The data pointer.

--*/
{
    HRESULT         hr = S_OK;
    OLECHAR         traceString[WSB_TRACE_BUFF_SIZE];

    try  {
        LONG  incSize;
        LONG  traceSize = 0;

        // Initialize the string
        swprintf(traceString, OLESTR(""));
        
        // Add indentation
        incSize = wcslen(WSB_INDENT_STRING);
        for(ULONG level = 0; level < indentLevel; level++) {
            if ((traceSize + incSize) < WSB_TRACE_BUFF_SIZE) {
                wcscat(traceString, WSB_INDENT_STRING);
                traceSize += incSize;
            }
        }

        // Add the intro string
        if (introString) {
            incSize = wcslen(introString);
        } else {
            incSize = 0;
        }
        if (incSize && ((traceSize + incSize) < WSB_TRACE_BUFF_SIZE)) {
            wcscat(traceString, introString);
            traceSize += incSize;
        }

        // Format the arguments (leave room for EOL and EOS)
        incSize = _vsnwprintf(&traceString[traceSize], 
                (WSB_TRACE_BUFF_SIZE - traceSize - 3), format, vaList);
        if (incSize < 0) {
            // This means we filled the buffer and would have overflowed
            // Need to add EOS
            traceString[WSB_TRACE_BUFF_SIZE - 3] = OLECHAR('\0');
            traceSize = WSB_TRACE_BUFF_SIZE - 3;
        } else {
            traceSize += incSize;
        }

        // Add EOL if needed
        if (introString) {
            wcscat(&traceString[traceSize], OLESTR("\r\n"));
        }
        
        WsbAffirmHr(g_pWsbTrace->Print(traceString));

    } WsbCatch (hr);

    return(hr);
}



static HRESULT
GetThreadDataPointer(
    OUT THREAD_DATA** ppTD
    )

/*++

Routine Description:

    Return a pointer to the data specific to the current thread.  This
    function will allocate space for the thread data (and initialize it)
    if needed.

Arguments:

    ppTD  - Pointer to pointer to thread data.

Return Value:

    The data pointer.

--*/
{
    HRESULT      hr = E_FAIL;
    THREAD_DATA* pThreadData = NULL;

    //  Make sure the TLS index is valid
    if (BOGUS_TLS_INDEX != TlsIndex) {

        //  Try to get the data pointer for this thread
        pThreadData = static_cast<THREAD_DATA*>(TlsGetValue(TlsIndex));

        if (pThreadData) {
            hr = S_OK;
        } else {
            //  Allocate data for this thread yet
            pThreadData = static_cast<THREAD_DATA*>(WsbAlloc(sizeof(THREAD_DATA)));
            if (pThreadData) {
                if (TlsSetValue(TlsIndex, pThreadData)) {
                    //  Initialize the data for this thread
                    pThreadData->TraceOffCount = 0;
                    pThreadData->IndentLevel = 0;
                    pThreadData->LogModule = NULL;
                    pThreadData->LogModuleLine = 0;
                    pThreadData->LogNTBuild = 0;
                    pThreadData->LogRSBuild = 0;
                    hr = S_OK;
                } else {
                    //  TlsSetValue failed!
                    WsbFree(pThreadData);
                    pThreadData = NULL;
                }
            }
        }
    }

    *ppTD = pThreadData;

    return(hr);
}


static void
SnapShotTraceAndEvent(
    SYSTEMTIME      stime
    )

/*++

Routine Description:

    This routine saves the trace files and event logs

Arguments:


Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;

    try  {

        OLECHAR                         dataString[256];
        OLECHAR                         tmpString[50];
        OLECHAR                         mutexName[50] = L"WsbTraceSnapShotMutex";
        DWORD                           sizeGot;
        HANDLE                          mutexHandle = INVALID_HANDLE_VALUE;

        //
        // The level is one to snap shot and snap shot is on.  Now make sure there is a
        // path specified where we are to copy the logs
        // 
        WsbAffirm(0 != g_pWsbLogSnapShotPath, E_POINTER);
        WsbAffirm(0 != wcslen(g_pWsbLogSnapShotPath), E_POINTER);

        //
        // Get the system root string from the registry
        //
        WsbAffirmHr(WsbGetRegistryValueString(NULL, WSB_CURRENT_VERSION_REGISTRY_KEY, WSB_SYSTEM_ROOT_REGISTRY_VALUE, dataString, 256, &sizeGot));

        CWsbStringPtr   snapShotSubDir;
        CWsbStringPtr   snapShotFile;
        snapShotSubDir = g_pWsbLogSnapShotPath;
        //
        // Make sure there is a "\" at the end of the path
        //
        int len;
        len = wcslen(snapShotSubDir);
        if (snapShotSubDir[len] != '\\')  {
            snapShotSubDir.Append(L"\\");
        }

        // Build the path to the subdirectory that will contain the logs from the input path
        // and the time of the event.
        swprintf(tmpString, OLESTR("%2.02u.%2.02u-%2.2u.%2.2u.%2.2u.%3.3u"),
                stime.wMonth, stime.wDay,
                stime.wHour, stime.wMinute,
                stime.wSecond, stime.wMilliseconds); 
        snapShotSubDir.Append(tmpString);
        
        //
        // Make sure the subdirectory can be created
        //
        WsbAffirmHr(WsbCreateAllDirectories(snapShotSubDir));

//
//      We need to synchronize around the creating of the 
//      event backup files and copying them.  Since all three
//      services will access this code, use a mutex to 
//      synchronize them.
        mutexHandle = CreateMutex(NULL, TRUE, mutexName);
        if (mutexHandle)  {
            //
            // Copy the event logs
            // First back them up and then copy the backup file.
            //
            HANDLE eventLogHandle = INVALID_HANDLE_VALUE;
            try  {
                CWsbStringPtr computerName;
                CWsbStringPtr logName;
                
                WsbAffirmHr( WsbGetComputerName( computerName ) );
                
                //
                // Open the application event log and back it up
                //
                logName = dataString;
                logName.Append(WSB_APP_EVENT_LOG);
                eventLogHandle = OpenEventLog((LPCTSTR)computerName, (LPCTSTR)logName);
                if (INVALID_HANDLE_VALUE != eventLogHandle)  {
                    logName = dataString;
                    logName.Append(WSB_APP_EVENT_LOG_BKUP);
                    DeleteFile(logName);
                    WsbAffirmStatus(BackupEventLog(eventLogHandle, (LPCTSTR)logName));
                    WsbAffirmStatus(CloseEventLog(eventLogHandle));
                    snapShotFile = snapShotSubDir;
                    snapShotFile.Append(WSB_APP_EVENT_LOG_NAME);
                    //
                    // Now copy the backup file
                    //
                    WsbAffirmStatus(CopyFile(logName, snapShotFile, FALSE));
                }
                
                //
                // Open the system event log and back it up
                //
                logName = dataString;
                logName.Append(WSB_SYS_EVENT_LOG);
                eventLogHandle = OpenEventLog((LPCTSTR)computerName, (LPCTSTR)logName);
                if (INVALID_HANDLE_VALUE != eventLogHandle)  {
                    logName = dataString;
                    logName.Append(WSB_SYS_EVENT_LOG_BKUP);
                    DeleteFile(logName);
                    WsbAffirmStatus(BackupEventLog(eventLogHandle, (LPCTSTR)logName));
                    WsbAffirmStatus(CloseEventLog(eventLogHandle));
                    snapShotFile = snapShotSubDir;
                    snapShotFile.Append(WSB_SYS_EVENT_LOG_NAME);
                    //
                    // Now copy the backup file
                    //
                    WsbAffirmStatus(CopyFile(logName, snapShotFile, FALSE));
                }
                
                
            } WsbCatchAndDo(hr,if (INVALID_HANDLE_VALUE != eventLogHandle)  {
                CloseEventLog(eventLogHandle);}; hr = S_OK; );
            (void)ReleaseMutex(mutexHandle);
        }

        // 
        // Copy the trace files if there are any
        //
        try  {
            WIN32_FIND_DATA findData;
            HANDLE          handle;
            CWsbStringPtr   traceFile;
            CWsbStringPtr   searchString;
            BOOL            foundFile;
            //               
            // Find the file(s)
            //
            WsbAffirmHr(WsbGetMetaDataPath(searchString));
            searchString.Append(WSB_RS_TRACE_FILES);
            handle = FindFirstFile(searchString, &findData);
            snapShotFile = snapShotSubDir;
            snapShotFile.Append(L"\\");
            WsbAffirmHr(WsbGetMetaDataPath(traceFile));
            traceFile.Append(WSB_RS_TRACE_PATH);
            WsbAffirmHr(snapShotFile.Append((OLECHAR *)(findData.cFileName)));
            WsbAffirmHr(traceFile.Append((OLECHAR *)(findData.cFileName)));

            // If we found a file, then remember the scan handle and
            // return the scan item.  
            foundFile = TRUE;
            while ((INVALID_HANDLE_VALUE != handle) && (foundFile == TRUE))  {
                if ((FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes) != FILE_ATTRIBUTE_DIRECTORY) {
                    WsbAffirmStatus(CopyFile(traceFile, snapShotFile, FALSE));
                }    
                foundFile = FindNextFile(handle, &findData);
                snapShotFile = snapShotSubDir;
                snapShotFile.Append(L"\\");
                WsbAffirmHr(WsbGetMetaDataPath(traceFile));
                traceFile.Append(WSB_RS_TRACE_PATH);
                WsbAffirmHr(snapShotFile.Append((OLECHAR *)(findData.cFileName)));
                WsbAffirmHr(traceFile.Append((OLECHAR *)(findData.cFileName)));
            }
            
        } WsbCatchAndDo(hr, hr = S_OK; );
    }
    WsbCatch( hr );

}

#include "winnls.h"
#include "resource.h"

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen);

const int pwOrders[] = {IDS_WSB_BYTES, IDS_WSB_ORDERKB, IDS_WSB_ORDERMB,
                          IDS_WSB_ORDERGB, IDS_WSB_ORDERTB, IDS_WSB_ORDERPB, IDS_WSB_ORDEREB};


HRESULT WsbShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
/*++

Routine Description:

    Converts numbers into sort formats
        532     -> 523 bytes
        1340    -> 1.3KB
        23506   -> 23.5KB
                -> 2.4MB
                -> 5.2GB

Arguments:

Return Value:

Note:

    This code is cloned from MS source /shell/shelldll/util.c - AHB

--*/
{

    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];
    HMODULE hModule;

    if (dw64 < 1000) {
        wsprintf(szTemp, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, 10);
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = (TCHAR)( TEXT('0') + 3 - wLen );
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    hModule = LoadLibraryEx(WSB_FACILITY_PLATFORM_NAME, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hModule) {
        LoadString(hModule,
                  pwOrders[i], 
                  szOrder, 
                  ARRAYSIZE(szOrder));
        wsprintf(szBuf, szOrder, (LPTSTR)szTemp);
        FreeLibrary(hModule);
    }

    return S_OK;
}


LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, int nResLen)
/*++

Routine Description:

    Takes a DWORD add commas etc to it and puts the result in the buffer

Arguments:

Return Value:

Note:

    This code is cloned from MS source /shell/shelldll/util.c - AHB

--*/
{
    TCHAR  szTemp[20];  // more than enough for a DWORD
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = _tcstol(szSep, NULL, 10);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, TEXT("%lu"), dw);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, nResLen) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

void
WsbTraceAndPrint(
    DWORD       eventId,
    ...
    )

/*++

Routine Description:

    This routine writes a message into standard output.  The message
    is also written to the application trace file.  

Arguments:

    eventId    - The message Id to log.
    Inserts    - Message inserts that are merged with the message description specified by
                   eventId.  The number of inserts must match the number specified by the
                   message description.  The last insert must be NULL to indicate the
                   end of the insert list.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;

    try  {
        va_list         vaList;

        va_start(vaList, eventId);
        WsbTraceAndPrintV(eventId, &vaList );
        va_end(vaList);

    } WsbCatch( hr );
}


void
WsbTraceAndPrintV(
    DWORD       eventId,
    va_list *   inserts
    )

/*++

Routine Description:

    This routine writes a message into standard output.  The message
    is also written to the application trace file.  

Arguments:

    eventId    - The message Id to log.
    inserts    - An array of message inserts that are merged with the message description
                   specified by eventId.  The number of inserts must match the number
                   specified by the message description.  The last insert must be NULL,
                   to indicate the end of the insert list.

Return Value:

    None.

--*/
{

    HRESULT         hr = S_OK;

    try  {

        WsbAssertPointer( inserts );

        const OLECHAR * facilityName = 0;
        BOOL            bPrint;
        OLECHAR * messageText = 0;

        //
        // Determine type of event
        //
        switch ( eventId & 0xc0000000 ) {
        case ERROR_SEVERITY_INFORMATIONAL:
            bPrint = (g_WsbPrintLevel >= WSB_LOG_LEVEL_INFORMATION) ? TRUE : FALSE;
            break;
        case ERROR_SEVERITY_WARNING:
            bPrint = (g_WsbPrintLevel >= WSB_LOG_LEVEL_WARNING) ? TRUE : FALSE;
            break;
        case ERROR_SEVERITY_ERROR:
            bPrint = (g_WsbPrintLevel >= WSB_LOG_LEVEL_ERROR) ? TRUE : FALSE;
            break;
        default:
            bPrint = (g_WsbPrintLevel >= WSB_LOG_LEVEL_COMMENT) ? TRUE : FALSE;
            break;
        }

        WsbAffirm (bPrint, S_OK);

        //
        // Determine source facility of message
        //
        switch ( HRESULT_FACILITY( eventId ) ) {

        case WSB_FACILITY_PLATFORM:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_RMS:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_HSMENG:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_JOB:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_HSMTSKMGR:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_FSA:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_GUI:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_MOVER:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_LAUNCH:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_USERLINK:
            facilityName = WSB_FACILITY_PLATFORM_NAME;
            break;

        case WSB_FACILITY_CLI:
            facilityName = WSB_FACILITY_CLI_NAME;
            break;

        case WSB_FACILITY_TEST:
            facilityName = WSB_FACILITY_TEST_NAME;
            break;

        case HRESULT_FACILITY(FACILITY_NT_BIT):
            facilityName = WSB_FACILITY_NTDLL_NAME;
            eventId &= ~FACILITY_NT_BIT;
            break;
            
        default:
            facilityName = WSB_FACILITY_NTDLL_NAME;
            break;
        }

        if ( facilityName ) {

            HMODULE hModule;

            hModule = LoadLibraryEx( facilityName, NULL, LOAD_LIBRARY_AS_DATAFILE );

            if (hModule) {
            // 
            // Load and format the message
            //
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           hModule,
                           eventId,
                           MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                           (LPTSTR) &messageText,
                           0,
                           inserts);

            if ( messageText ) {
                //
                // Print the message
                //
                wprintf( messageText );  // Format messages come with \n
                                         // TEMPORARY: Should we convert here using WideCharToMultiByte ???
                //
                // Trace the message
                //
                if ( g_pWsbTrace ) {
                    WsbTracef( OLESTR("!!!!! PRINT - Event <0x%08lx> is printed\n"), eventId );
                    WsbTracef( OLESTR("%ls"), messageText );  // Format messages come with \n
                }

                LocalFree( messageText );

            } else {
                if ( g_pWsbTrace ) {
                    WsbTracef( OLESTR("!!!!! PRINT !!!!! - Message <0x%08lx> could not be translated.\r\n"), eventId );
                }
            }
            FreeLibrary(hModule);
          }  else {
             WsbTracef( OLESTR("!!!!! EVENT !!!!! - Could not load facility name DLL %ls. \r\n"), facilityName);
          }
        } else {
            if ( g_pWsbTrace ) {
                WsbTracef( OLESTR("!!!!! PRINT !!!!! - Message File for <0x%08lx> could not be found.\r\n"), eventId );
            }
        }

    } WsbCatch( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbulong.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbulong.h

Abstract:

    This component is an object representations of the ULONG standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBULONG_
#define _WSBULONG_

/*++

Class Name:
    
    CWsbUlong

Class Description:

    An object representations of the ULONG standard type. It
    is both persistable and collectable.

--*/

class CWsbUlong : 
    public CWsbObject,
    public IWsbUlong,
    public CComCoClass<CWsbUlong,&CLSID_CWsbUlong>
{
public:
    CWsbUlong() {}
BEGIN_COM_MAP(CWsbUlong)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbUlong)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbUlong)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbUlong)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbUlong
public:
    STDMETHOD(CompareToUlong)(ULONG value, SHORT* pResult);
    STDMETHOD(CompareToIUlong)(IWsbUlong* pUlong, SHORT* pResult);
    STDMETHOD(GetUlong)(ULONG* pValue);
    STDMETHOD(SetUlong)(ULONG value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    ULONG           m_value;
};

#endif // _WSBULONG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbulong.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbulong.cpp

Abstract:

    This component is an object representations of the ULONG standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbulong.h"


HRESULT
CWsbUlong::CompareToUlong(
    IN ULONG value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbUlong::CompareToUlong
    
--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbUlong::CompareToUlong"), OLESTR("value = <%ld>"), value);

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbUlong::CompareToUlong"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbUlong::CompareToIUlong(
    IN IWsbUlong* pUlong,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbUlong::CompareToIUlong

--*/
{
    HRESULT     hr = E_FAIL;
    ULONG       value;

    WsbTraceIn(OLESTR("CWsbUlong::CompareToIUlong"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUlong, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pUlong->GetUlong(&value));
        hr = CompareToUlong(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::CompareToIUlong"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbUlong::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbUlong*  pUlong;

    WsbTraceIn(OLESTR("CWsbUlong::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbUlong interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbUlong, (void**) &pUlong));
        hr = CompareToIUlong(pUlong, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbUlong::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = 0;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbUlong::GetUlong(
    OUT ULONG* pValue
    )

/*++

Implements:

  IWsbUlong::GetUlong

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::GetUlong"), OLESTR(""));

    try {

        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::GetUlong"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbUlong::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbUlong;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbUlong::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(ULONG);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbUlong::Load(
    IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));      

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::Load"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);

    return(hr);
}


HRESULT
CWsbUlong::Save(
    IStream* pStream,
    BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUlong::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));     

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbUlong::SetUlong(
    ULONG value
    )

/*++

Implements:

  IWsbUlong::SetUlong

--*/
{
    WsbTraceIn(OLESTR("CWsbUlong::SetUlong"), OLESTR("value = <%ld>"), value);

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbUlong::SetUlong"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbUlong::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbUlong>      pUlong1;
    CComPtr<IWsbUlong>      pUlong2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    ULONG                   value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbUlong::Test"), OLESTR(""));

    try {

        // Get the pUlong interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbUlong*) this)->QueryInterface(IID_IWsbUlong, (void**) &pUlong1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pUlong1->SetUlong(0xffffffff));
                WsbAffirmHr(pUlong1->GetUlong(&value));
                WsbAssert(value == 0xffffffff, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbUlong, NULL, CLSCTX_ALL, IID_IWsbUlong, (void**) &pUlong2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong2->GetUlong(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(767));
                    WsbAffirmHr(pUlong2->SetUlong(767));
                    WsbAssert(pUlong1->IsEqual(pUlong2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(767));
                    WsbAffirmHr(pUlong2->SetUlong(65000));
                    WsbAssert(pUlong1->IsEqual(pUlong2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(900));
                    WsbAffirmHr(pUlong2->SetUlong(900));
                    WsbAssert((pUlong1->CompareTo(pUlong2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(500));
                    WsbAffirmHr(pUlong2->SetUlong(1000));
                    WsbAssert((pUlong1->CompareTo(pUlong2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->SetUlong(75000));
                    WsbAffirmHr(pUlong2->SetUlong(20000));
                    WsbAssert((pUlong1->CompareTo(pUlong2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pUlong1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pUlong2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pUlong2->SetUlong(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbUlong.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pUlong1->SetUlong(888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbUlong.tst"), 0));
                        WsbAssert(pUlong1->CompareToUlong(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUlong::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbtrc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbtrc.cpp

Abstract:

    This component is a trace object.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

    Brian Dodd      [brian]      09-May-1996  - Added event logging

--*/

#include "stdafx.h"
#include "time.h"

#undef WsbThrow
#define WsbThrow(hr)                    throw(hr)
#include "wsbtrc.h"

// Local data
static WCHAR message[1024];  // Space for formatting a message


HRESULT 
CWsbTrace::FinalConstruct( 
    void 
    )
/*++

Implements:

    IWsbTrace::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
    try  {
        // Set up global values     
        g_pWsbTrace = 0;
        g_WsbTraceModules = WSB_TRACE_BIT_NONE;

        // Establish Base object
        WsbAffirmHr(CComObjectRoot::FinalConstruct() );

        // Initialize member data
        m_TraceOn = FALSE;
        m_TraceSettings = WSB_TRACE_BIT_NONE;
        m_TraceFileName = OLESTR("");
        m_TraceOutput = WSB_TRACE_OUT_NONE;
        m_CommitEachEntry = FALSE;
        m_TimeStamp = FALSE;
        m_TraceCount = FALSE;
        m_TraceThreadId = FALSE;
        m_TraceFilePointer = INVALID_HANDLE_VALUE;
        m_WrapMode = FALSE;
        m_RegistrySetting = OLESTR("");
        m_TraceEntryExit = g_WsbTraceEntryExit;
        m_LogLevel = g_WsbLogLevel;
        m_TraceFileCopyName = OLESTR("");
        m_TraceMultipleFilePattern = OLESTR("");
        m_TraceMultipleFileCount = 0;
        m_TraceCountHandle = NULL;
        m_pTraceCountGlobal = NULL; 
    
    } WsbCatch( hr );
    
    
    return( hr );
}       


void 
CWsbTrace::FinalRelease( 
    void 
    )
/*++

Implements:

    IWsbTrace::FinalRelease

--*/
{
    HRESULT     hr = S_OK;
    
    // Stop Trace
    StopTrace();

    // Free base class    
    //
    CComObjectRoot::FinalRelease( );
}       


HRESULT 
CWsbTrace::StartTrace( 
    void 
    )
/*++

Implements:

  IWsbTrace::StartTrace

--*/
{
    HRESULT     hr = S_OK;

    try  {

        if (g_pWsbTrace == 0)  {
            //
            // Set global variable for quick checking
            //
            WsbAffirmHr(((IUnknown*)(IWsbTrace *)this)->QueryInterface(IID_IWsbTrace, (void**) &g_pWsbTrace));
            //
            // We don't want the reference count bumped for this global so release it here.
            g_pWsbTrace->Release();
        }


        //
        // Get hold of the trace count
        //
        if (m_pTraceCountGlobal == NULL) {

            m_pTraceCountGlobal = &g_WsbTraceCount;

            m_TraceCountHandle = CreateFileMapping(INVALID_HANDLE_VALUE,
                                                   NULL,
                                                   PAGE_READWRITE,
                                                   0,
                                                   sizeof(ULONG),
                                                   L"Global\\RemoteStorageTraceCountPrivate"
                                                  );
           if (m_TraceCountHandle == NULL) {
                 if (GetLastError() == ERROR_ALREADY_EXISTS) {
                     //  
                     // Already open, just get hold of the mapping
                     //
                    m_TraceCountHandle = OpenFileMapping(FILE_MAP_WRITE,
                                                         FALSE,
                                                         L"Global\\RemoteStorageTraceCountPrivate");
                 }  else {
                   swprintf( message, OLESTR("CWsbTrace::StartTrace: CreateFileMapping failed %d\n"),   GetLastError());
                    g_pWsbTrace->Print(message);
                }
           }           

           if (m_TraceCountHandle != NULL) {
                m_pTraceCountGlobal = (PLONG) MapViewOfFile(m_TraceCountHandle,
                                                            FILE_MAP_WRITE,
                                                            0,
                                                            0,
                                                            sizeof(ULONG));
                if (!m_pTraceCountGlobal) {
                     CloseHandle(m_TraceCountHandle);
                     m_pTraceCountGlobal = &g_WsbTraceCount;
                     m_TraceCountHandle = NULL;
                     swprintf( message, OLESTR("CWsbTrace::StartTrace: MapViewOfFile failed %d\n"),   GetLastError());
                     g_pWsbTrace->Print(message);
                }
           }  
        }
        
        //
        // Set local variable to remember the state 
        //
        m_TraceOn = TRUE;

        //
        //  If there is a file name defined and file tracing is on
        //  Create/open the trace file.
        //
        try  {
            
            if ((m_TraceOutput & WSB_TRACE_OUT_FILE)  &&
                    (wcslen(m_TraceFileName) != 0) ) {
                DWORD  attributes;
                DWORD  bytesReturned;
                USHORT inBuffer = COMPRESSION_FORMAT_DEFAULT;
                DWORD  last_error = 0;

                //
                // If the main file is open, close it.
                //
                if (INVALID_HANDLE_VALUE != m_TraceFilePointer)  {
                     CloseHandle(m_TraceFilePointer);
                     m_TraceFilePointer = INVALID_HANDLE_VALUE;
                }

                //  Adjust the file name (for multiple trace files)
                AdjustFileNames();

                //
                // If there is a copy file specified, copy to it
                //
                if (m_TraceOutput & WSB_TRACE_OUT_FILE_COPY) {
                    if (!MoveFileEx(m_TraceFileName, m_TraceFileCopyName, 
                        (MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH))) {
                        
                        // If copy fails, keep going
                        last_error = GetLastError();
                        swprintf( message, OLESTR("CWsbTrace::StartTrace: MoveFileEx failed:%ld\r\n"), 
                                last_error);
                        g_pWsbTrace->Print(message);
                    }
                }

                //  Open/create the trace file                
                if (m_CommitEachEntry) {
                    attributes = FILE_FLAG_WRITE_THROUGH;
                } else {
                    attributes = FILE_ATTRIBUTE_NORMAL;
                }
                m_TraceFilePointer = CreateFile(m_TraceFileName, 
                        GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                        CREATE_ALWAYS, attributes, NULL);
                if (INVALID_HANDLE_VALUE == m_TraceFilePointer) {
                    last_error = GetLastError();
                    swprintf( message, OLESTR("CWsbTrace::StartTrace: CreateFile failed:%ld\r\n"), 
                            last_error);
                    g_pWsbTrace->Print(message);
                    WsbThrow(E_FAIL);
                }

                //  Make the trace file compressed (if possible)
                if (0 == DeviceIoControl(m_TraceFilePointer, FSCTL_SET_COMPRESSION, 
                        &inBuffer, sizeof(inBuffer), 0, 0, &bytesReturned, 0)) {
                    // Failed to make file compressed -- not a fatal error
                    last_error = GetLastError();
                    swprintf( message, 
                            OLESTR("CWsbTrace::StartTrace: DeviceIoControl(COMPRESSION) failed:%ld\r\n"), 
                            last_error);
                    g_pWsbTrace->Print(message);
                }
            }
        } WsbCatch( hr );

        swprintf( message, OLESTR("Trace Started (%d-%ls)\r\n"), 
                VER_PRODUCTBUILD, RsBuildVersionAsString(RS_BUILD_VERSION));
        WsbAffirmHr(g_pWsbTrace->Print(message));
        
    }  WsbCatch (hr); 
    
    
    return(hr);
}       
    

HRESULT  
CWsbTrace::StopTrace( 
    void 
    )
/*++

Implements:

  IWsbTrace::StopTrace

--*/
{
    HRESULT     hr = S_OK;

    try  {
        
        //
        // Set global variable for quick checking
        //          
        if (g_pWsbTrace != 0) {
            g_pWsbTrace->Print(OLESTR("Trace Stopped\r\n"));
            //
            // Don't release here.
            //
            //g_pWsbTrace->Release();
            g_pWsbTrace = 0;
        }
        
        //
        // Set local variable to remember the state 
        //
        m_TraceOn = FALSE;
        
        //
        // Close the file handle
        //
        if (m_TraceFilePointer != INVALID_HANDLE_VALUE) {
            CloseHandle(m_TraceFilePointer);
            m_TraceFilePointer = INVALID_HANDLE_VALUE;
        }

        if (m_TraceCountHandle != NULL) {
            BOOL b;

            CloseHandle(m_TraceCountHandle);
            m_TraceCountHandle = NULL;
            //
            // We should have a macro to assert without 
            // throwing HR's
            // After one is added, a good assert here would be:
            // ASSERT(m_pTraceCountGlobal != NULL);
            //
            b = UnmapViewOfFile(m_pTraceCountGlobal);
            //
            // And another here would be:
            // ASSERT(b);
            //
            m_pTraceCountGlobal = NULL;
        }
        
    }  WsbCatch (hr); 

    return(hr);
}       


HRESULT 
CWsbTrace::AdjustFileNames( 
    void
    )
/*++

Routine Description:

    Make sure trace flags are set correctly and parse file names if we
    haven't already.  If we're doing multiple trace files (instead of 
    wrapping), adjust the trace and copy file names.

Arguments:

    None.

Return Value:

    S_OK - Success

--*/
{
    HRESULT         hr = S_OK;

    try  {
        //  If we haven't yet, parse file names & set flags.
        if (!(m_TraceOutput & WSB_TRACE_OUT_FLAGS_SET)) {
            OLECHAR       *pc_original;
            OLECHAR       *pc_bslash;
            CWsbStringPtr str_temp(m_TraceFileName);

            //  Reset flags & file info
            m_TraceOutput &= ~WSB_TRACE_OUT_MULTIPLE_FILES;
            m_TraceOutput &= ~WSB_TRACE_OUT_FILE_COPY;
            m_TraceFileDir = "";
            m_TraceMultipleFilePattern = "";
            m_TraceFileCopyDir = "";

            //  Parse the trace file name.  One or more '*'s means we should 
            //  do multiple trace files.  The number of '*'s indicates 
            //  how many digits to use for the file count.  Separate the
            //  directory from the file name.
            pc_bslash = wcsrchr(str_temp, OLECHAR('\\'));

            if (pc_bslash) {

                *pc_bslash = OLECHAR('\0');

                //  Get the trace directory
                m_TraceFileDir = str_temp;
                m_TraceFileDir.Append("\\");

                //  Point to the file name (which may contain a pattern)
                pc_bslash++;
            } else {
                //  No directory specified
                pc_bslash = static_cast<OLECHAR *>(str_temp);
            }

            //  Get the file name
            m_TraceMultipleFilePattern = pc_bslash;

            //  Look for '*'s in the file name
            pc_original = wcschr(pc_bslash, OLECHAR('*'));

            //  Convert a file pattern for use in sprintf
            if (pc_original) {
                OLECHAR       format[16];
                OLECHAR       *pc_copy;
                int           star_count = 0;

                //  Count *'s
                while (OLECHAR('*') == *pc_original) {
                    star_count++;
                    pc_original++;
                }

                //  Create file name pattern: replace '*'s with printf
                //  type format specification (e.g. "%3.3d")
                pc_copy = wcschr(m_TraceMultipleFilePattern, OLECHAR('*'));
                WsbAffirm(pc_copy, E_FAIL);
                *pc_copy = OLECHAR('\0');

                swprintf(format, OLESTR("%%%d.%dd"), star_count, star_count);
                m_TraceMultipleFilePattern.Append(format);
                m_TraceMultipleFilePattern.Append(pc_original);

                //  Set multiple flag
                m_TraceOutput |= WSB_TRACE_OUT_MULTIPLE_FILES;
            }

            //  If we're doing file copies, set the flag.
            if (wcslen(m_TraceFileCopyName)) {
                m_TraceOutput |= WSB_TRACE_OUT_FILE_COPY;

                //  Get the copy directory
                str_temp = m_TraceFileCopyName;
                pc_bslash = wcsrchr(str_temp, OLECHAR('\\'));
                if (pc_bslash) {
                    *pc_bslash = OLECHAR('\0');
                    m_TraceFileCopyDir = str_temp;
                    m_TraceFileCopyDir.Append("\\");

                    //  Point to the copy file name
                    pc_bslash++;
                } else {
                    pc_bslash = static_cast<OLECHAR *>(str_temp);
                }

                //  If we're not doing multiple trace files, make sure
                //  we have a copy file name.  (If we are doing multiple
                //  trace files, the copy file name is create below.)
                if (!(m_TraceOutput & WSB_TRACE_OUT_MULTIPLE_FILES) &&
                        0 == wcslen(pc_bslash)) {
                    m_TraceFileCopyName = m_TraceFileCopyDir;
                    m_TraceFileCopyName.Append(m_TraceMultipleFilePattern);
                }
            }

            //  Increment file count and indicate flags are set
            m_TraceMultipleFileCount++;
            m_TraceOutput |= WSB_TRACE_OUT_FLAGS_SET;
        }

        //  If we have a file pattern, create the new actual file names
        if (m_TraceOutput & WSB_TRACE_OUT_MULTIPLE_FILES) {
            OLECHAR newName[256];

            //  Create the file name from the pattern and the file count
            wsprintf(newName, m_TraceMultipleFilePattern, 
                    m_TraceMultipleFileCount);

            //  Combine trace directory and file name
            m_TraceFileName = m_TraceFileDir;
            m_TraceFileName.Append(newName);

            //  Create a new trace file copy name also
            if (m_TraceOutput & WSB_TRACE_OUT_FILE_COPY) {
                m_TraceFileCopyName = m_TraceFileCopyDir;
                m_TraceFileCopyName.Append(newName);
            }
        }    
    } WsbCatch( hr );
    
    return( hr );
}       
    

HRESULT  
CWsbTrace::SetTraceOn(  
    LONGLONG traceElement 
    )
/*++

Implements:

  IWsbTrace::SetTraceOn

--*/
{
    HRESULT     hr = S_OK;
    
    //
    // Turn on the global trace bits for easy checking
    //
    g_WsbTraceModules = g_WsbTraceModules | traceElement;
    
    //
    // Turn on the local trace bits
    //
    m_TraceSettings = g_WsbTraceModules;
    
    return( hr );
}       
    

HRESULT  
CWsbTrace::SetTraceOff( 
    LONGLONG traceElement 
    )
/*++

Implements:

  IWsbTrace::SetTraceOff

--*/
{
    HRESULT     hr = S_OK;
    //
    // Turn off the global trace bits for easy checking
    //
    g_WsbTraceModules = g_WsbTraceModules & (~traceElement);
    
    //
    // Turn on the local trace bits
    //
    m_TraceSettings = g_WsbTraceModules;
    
    return( hr );
}       

HRESULT  
CWsbTrace::GetTraceSettings( 
    LONGLONG *pTraceElements 
    )
/*++

Implements:

  IWsbTrace::GetTraceSettings

--*/
{
    HRESULT     hr = S_OK;
    
    try 
    {
        WsbAffirm(pTraceElements != 0, E_POINTER);
        *pTraceElements = g_WsbTraceModules;
        
    } WsbCatch( hr );
    
    return( hr );
}       
    

HRESULT  
CWsbTrace::GetTraceSetting( 
    LONGLONG traceElement, 
    BOOL     *pOn )
/*++

Implements:

  IWsbTrace::GetTraceSetting

--*/
{
    HRESULT     hr = S_OK;
    
    //
    // Find the bit and return TRUE if it is set,
    // otherwise return FALSE
    //
    try 
    {
        WsbAffirm(pOn != 0, E_POINTER);
        *pOn = FALSE;
        if ((g_WsbTraceModules & traceElement) == traceElement)  {
            *pOn = TRUE;
        }
    } WsbCatch( hr );
    
    return( hr );
}       

HRESULT  
CWsbTrace::DirectOutput( 
    ULONG output 
    )
/*++

Implements:

  IWsbTrace::DirectOutput

--*/
{
    HRESULT     hr = S_OK;
    
    m_TraceOutput = output;
    
    return( hr );
}       

HRESULT  
CWsbTrace::SetTraceFileControls( 
    OLECHAR     *pTraceFileName,
    BOOL        commitEachEntry,
    LONGLONG    maxTraceFileSize,
    OLECHAR     *pTraceFileCopyName 
    )
/*++

Implements:

  IWsbTrace::SetTraceFileControls

--*/
{
    HRESULT     hr = S_OK;
    try  {
        if (pTraceFileName)  {
            m_TraceFileName = pTraceFileName;
            m_TraceOutput &= ~WSB_TRACE_OUT_FLAGS_SET;
        }
        m_CommitEachEntry = commitEachEntry;
        m_MaxTraceFileSize = maxTraceFileSize;
        if (pTraceFileCopyName)  {
            m_TraceFileCopyName = pTraceFileCopyName;
            m_TraceOutput &= ~WSB_TRACE_OUT_FLAGS_SET;
        }
    
    } WsbCatch( hr );
    
    
    return( hr );
}       


HRESULT  
CWsbTrace::GetTraceFileControls( 
    OLECHAR     **ppTraceFileName,
    BOOL        *pCommitEachEntry,
    LONGLONG    *pMaxTraceFileSize,
    OLECHAR     **ppTraceFileCopyName
    )
/*++

Implements:

  IWsbTrace::GetTraceFileControls

--*/
{
    HRESULT     hr = S_OK;
    
    try  {
        if (ppTraceFileName) {
            CWsbStringPtr fileName;

            fileName = m_TraceFileName;
            fileName.GiveTo(ppTraceFileName);
        }

        if (pCommitEachEntry) {
            *pCommitEachEntry = m_CommitEachEntry;
        }

        if (pMaxTraceFileSize) {
            *pMaxTraceFileSize = m_MaxTraceFileSize;
        }
        
        if (ppTraceFileCopyName) {
            CWsbStringPtr fileCopyName;

            fileCopyName = m_TraceFileCopyName;
            fileCopyName.GiveTo(ppTraceFileCopyName);
        }
        
    } WsbCatch( hr );
    
    return( hr );
}       


HRESULT 
CWsbTrace::Print( 
    OLECHAR *traceString
    )
/*++

Implements:

  IWsbTrace::Print

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   outString;
    DWORD           threadId;
    OLECHAR         tmpString[50];

    try  {
        //
        // Add the timeStamp if it is requested
        //
        
        if (m_TimeStamp) {
            SYSTEMTIME      stime;

            GetLocalTime(&stime);
            swprintf(tmpString, OLESTR("%2.02u/%2.02u %2.2u:%2.2u:%2.2u.%3.3u "),
                    stime.wMonth, stime.wDay,
                    stime.wHour, stime.wMinute,
                    stime.wSecond, stime.wMilliseconds); 

            outString.Append(tmpString);
            outString.Append(" ");
        }     
        
        //
        // Add the trace count if requested
        //
        if (m_TraceCount) {
            OLECHAR         tmpString[50];

            swprintf(tmpString, OLESTR("%8.8lX"), *(m_pTraceCountGlobal));
            outString.Append(tmpString);
            InterlockedIncrement(m_pTraceCountGlobal);
            outString.Append(" ");
        }    

        //
        // Add the thread ID if requested
        //
        if (m_TraceThreadId) {
            threadId = GetCurrentThreadId();
            if (threadId < 0x0000FFFF) {
                swprintf(tmpString, OLESTR("%4.4lX"), threadId);
            } else  {
                swprintf(tmpString, OLESTR("%8.8lX"), threadId);
            }
            
            outString.Append(tmpString);
            outString.Append(" ");
        }
        
        outString.Append(traceString);
        //
        // Make sure no one else writes when we do
        //               
        Lock();
        try {
            if ((m_TraceOutput & WSB_TRACE_OUT_DEBUG_SCREEN) == WSB_TRACE_OUT_DEBUG_SCREEN)  {
                //
                // Write to debug console
                //
                OutputDebugString(outString);
            }
            if ((m_TraceOutput & WSB_TRACE_OUT_STDOUT) == WSB_TRACE_OUT_STDOUT)  {
                //
                // Write the string to the local console
                //
                wprintf(L"%ls", (WCHAR *) outString);
            }
            if ((m_TraceOutput & WSB_TRACE_OUT_FILE) == WSB_TRACE_OUT_FILE)  {
                //
                // Make sure the file exists, etc. 
                //
                if (m_TraceFilePointer != INVALID_HANDLE_VALUE) {
                    //
                    // Write the string to the trace file
                    //
                    WsbAffirmHr(Write(outString));
                    
                    //
                    // See if we have used our space
                    //
                    WsbAffirmHr(WrapTraceFile());
                }
            }
        } WsbCatch( hr );

        Unlock();
    
    } WsbCatch( hr );
    
    return( hr );
}       


HRESULT 
CWsbTrace::WrapTraceFile( 
    void
    )
/*++

Implements:

  IWsbTrace::WrapTraceFile

--*/
{
    HRESULT         hr = S_OK;
    static BOOL     stopping = FALSE;
    
    try  {
        LARGE_INTEGER offset;

        //
        // Find out where we are writing to the file
        //
        offset.HighPart = 0;
        offset.LowPart = SetFilePointer(m_TraceFilePointer, 0, &offset.HighPart, FILE_CURRENT);
        WsbAffirm(0xFFFFFFFF != offset.LowPart || NO_ERROR == GetLastError(), E_FAIL);

        //
        // See if we are past the max size desired
        //
        if (!stopping && offset.QuadPart >= m_MaxTraceFileSize) {

            // If we are doing multiple files, close this one and
            // open a new one
            if (m_TraceOutput & WSB_TRACE_OUT_MULTIPLE_FILES) {
                
                // Close the current trace file
                stopping = TRUE;
                StopTrace();

                // Increment the file count
                m_TraceMultipleFileCount++;

                // Create a new trace file
                StartTrace();
                stopping = FALSE;

            // otherwise go into wrap mode
            } else {
                // We have gone too far so start back at the top and indicating we are wrapping.
                offset.HighPart = 0;
                offset.LowPart = SetFilePointer(m_TraceFilePointer, 0, &offset.HighPart, FILE_BEGIN);
                WsbAffirm(0xFFFFFFFF != offset.LowPart || NO_ERROR == GetLastError(), E_FAIL);
                m_WrapMode = TRUE;
            }
        }

        if (m_WrapMode) {
            // Save where we are in the file
            offset.LowPart = SetFilePointer(m_TraceFilePointer, 0, &offset.HighPart, FILE_CURRENT);
            WsbAffirm(0xFFFFFFFF != offset.LowPart || NO_ERROR == GetLastError(), E_FAIL);
            
            // Write the wrap line
            WsbAffirmHr(Write(OLESTR("!!! TRACE WRAPPED !!!\r\n")));

            /* Go back to offset before wrap line saved                         */
            offset.LowPart = SetFilePointer(m_TraceFilePointer, offset.LowPart, 
                    &offset.HighPart, FILE_BEGIN);
            WsbAffirm(0xFFFFFFFF != offset.LowPart || NO_ERROR == GetLastError(), E_FAIL);
            
        }

    } WsbCatch( hr );
    
    return( hr );
}       

HRESULT  
CWsbTrace::SetOutputFormat( 
    BOOL    timeStamp,
    BOOL    traceCount,
    BOOL    traceThreadId
    )
/*++

Implements:

  IWsbTrace::SetOutputFormat

--*/
{
    HRESULT     hr = S_OK;
    try  {
        m_TimeStamp = timeStamp;
        m_TraceCount = traceCount;
        m_TraceThreadId = traceThreadId;
    
    } WsbCatch( hr );
    
    
    return( hr );
}       

HRESULT  
CWsbTrace::GetOutputFormat( 
    BOOL    *pTimeStamp,
    BOOL    *pTraceCount,
    BOOL    *pTraceThreadId
    )
/*++

Implements:

  IWsbTrace::GetOutputFormat

--*/
{
    HRESULT     hr = S_OK;
    try  {
        WsbAffirm(0 != pTimeStamp, E_POINTER);
        WsbAffirm(0 != pTraceCount, E_POINTER);
        WsbAffirm(0 != pTraceThreadId, E_POINTER);
        *pTimeStamp = m_TimeStamp;
        *pTraceCount = m_TraceCount;
        *pTraceThreadId = m_TraceThreadId;
    } WsbCatch( hr );
    
    
    return( hr );
}       

HRESULT 
CWsbTrace::GetRegistryEntry( 
    OLECHAR **pRegistryEntry 
    )
/*++

Implements:

  IWsbTrace::GetRegistryEntry

--*/
{
    HRESULT     hr = S_OK;

    try  {
        WsbAffirm(0 != pRegistryEntry, E_POINTER);

        CWsbStringPtr   entry;
        entry = m_RegistrySetting;
        WsbAffirmHr(entry.GiveTo(pRegistryEntry));
    } WsbCatch( hr );
    
    
    return( hr );
}       

HRESULT 
CWsbTrace::SetRegistryEntry( 
    OLECHAR *registryEntry 
    )
/*++

Implements:

  IWsbTrace::SetRegistryEntry

--*/
{
    HRESULT     hr = S_OK;

    m_RegistrySetting = registryEntry;
    
    return( hr );
}       

HRESULT 
CWsbTrace::LoadFromRegistry( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadFromRegistry

--*/
{
    HRESULT     hr = S_OK;

    try {
        if (wcslen(m_RegistrySetting) > 0) {
            WsbAffirmHr(WsbEnsureRegistryKeyExists (NULL, m_RegistrySetting));
            WsbAffirmHr(LoadFileSettings());
            WsbAffirmHr(LoadTraceSettings());
            WsbAffirmHr(LoadOutputDestinations());
            WsbAffirmHr(LoadFormat());
            WsbAffirmHr(LoadStart());
        } else  {
         hr = E_FAIL;
        }
    } WsbCatch( hr );

    
    return( hr );
}       


HRESULT 
CWsbTrace::LoadFileSettings( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadFileSettings

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD           sizeGot;
        OLECHAR         dataString[512];
        OLECHAR         *stopString;
        CWsbStringPtr   l_TraceFileName=L"Trace";
        LONGLONG        l_TraceFileSize=0;
        BOOL            l_TraceCommit=FALSE;
        CWsbStringPtr   l_TraceFileCopyName;

        //
        // Get the values
        //
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_FILE_NAME,
                                            dataString, 512, &sizeGot);
        if (hr == S_OK) {
            l_TraceFileName = dataString;
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_FILE_MAX_SIZE,
                                            dataString, 512, &sizeGot);
        if (hr == S_OK) {
            l_TraceFileSize = wcstoul( dataString,  &stopString, 10 );
        }
        
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_FILE_COMMIT,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            if (0 == wcstoul(dataString,  &stopString, 10)) {
                l_TraceCommit = FALSE;
            } else {
                l_TraceCommit = TRUE;
            }
        }
        
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_FILE_COPY_NAME,
                                            dataString, 512, &sizeGot);
        if (hr == S_OK) {
            l_TraceFileCopyName = dataString;
        }
        
        hr = S_OK;
        WsbAffirmHr(SetTraceFileControls(l_TraceFileName, l_TraceCommit, 
                l_TraceFileSize, l_TraceFileCopyName));

    } WsbCatch( hr );

    
    return( hr );
}       

HRESULT 
CWsbTrace::LoadTraceSettings( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadTraceSettings

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD           sizeGot;
        OLECHAR         dataString[100];
        OLECHAR         *stopString;
        BOOL            value = FALSE;
        LONG            number = 0;
        LONGLONG        l_TraceSettings = WSB_TRACE_BIT_NONE;
        BOOL            l_TraceEntryExit = TRUE;
        WORD            w_LogLevel = WSB_LOG_LEVEL_DEFAULT;
        BOOL            b_SnapShotOn = FALSE;
        WORD            w_SnapShotLevel = 0; 
        CWsbStringPtr   p_SnapShotPath = L"SnapShotPath";
        BOOL            b_SnapShotResetTrace = FALSE;
        

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_PLATFORM,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_PLATFORM;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_RMS,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_RMS;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_SEG,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_SEG;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_META,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_META;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_HSMENG,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_HSMENG;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_HSMSERV,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_HSMSERV;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_JOB,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_JOB;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_HSMTSKMGR,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_HSMTSKMGR;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_FSA,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_FSA;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_DATAMIGRATER,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_DATAMIGRATER;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_DATARECALLER,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_DATARECALLER;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_DATAVERIFIER,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_DATAVERIFIER;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_UI,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_UI;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_ENTRY_EXIT,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value == FALSE)  {
                l_TraceEntryExit = FALSE;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_DATAMOVER,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_DATAMOVER;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_HSMCONN,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_HSMCONN;
            }
        }
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_IDB,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_IDB;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_COPYMEDIA,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_COPYMEDIA;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_DO_PERSISTENCE,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceSettings |= WSB_TRACE_BIT_PERSISTENCE;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_LEVEL,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            w_LogLevel = (WORD)wcstoul( dataString,  &stopString, 10 ); // No conversion returns zero!
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_SNAP_SHOT_ON,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            b_SnapShotOn = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }
        
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_SNAP_SHOT_LEVEL,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            w_SnapShotLevel = (WORD) wcstoul( dataString,  &stopString, 10 );
        }
        
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_SNAP_SHOT_PATH,
                                            dataString, 512, &sizeGot);
        if (hr == S_OK) {
            p_SnapShotPath = dataString;
        }
        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_LOG_SNAP_SHOT_RESET_TRACE,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            b_SnapShotResetTrace = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }
        hr = S_OK;
        WsbAffirmHr(SetTraceSettings(l_TraceSettings));
        WsbAffirmHr(SetTraceEntryExit(l_TraceEntryExit));
        WsbAffirmHr(SetLogLevel(w_LogLevel));
        WsbAffirmHr(SetLogSnapShot(b_SnapShotOn, w_SnapShotLevel, 
                                   p_SnapShotPath, b_SnapShotResetTrace ));

    } WsbCatch( hr );

    return( hr );
}       

HRESULT 
CWsbTrace::LoadOutputDestinations( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadOutputDestinations

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD   sizeGot;
        OLECHAR dataString[100];
        OLECHAR *stopString;
        BOOL    value = FALSE;
        ULONG   l_TraceOutput = WSB_TRACE_OUT_NONE;

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_TO_STDOUT,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceOutput = l_TraceOutput | WSB_TRACE_OUT_STDOUT;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_TO_DEBUG,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceOutput = l_TraceOutput | WSB_TRACE_OUT_DEBUG_SCREEN;
            }
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_TO_FILE,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                l_TraceOutput = l_TraceOutput | WSB_TRACE_OUT_FILE;
            }

        }

        hr = S_OK;
        WsbAffirmHr(DirectOutput(l_TraceOutput));

    } WsbCatch( hr );

    
    return( hr );
}       

HRESULT 
CWsbTrace::LoadFormat( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadFormat

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD   sizeGot;
        OLECHAR dataString[100];
        OLECHAR *stopString;
        BOOL    countValue = FALSE;
        BOOL    timeValue = FALSE;
        BOOL    threadValue = FALSE;

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_COUNT,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            countValue = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_TIMESTAMP,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            timeValue = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_THREADID,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            threadValue = (BOOL) wcstoul( dataString,  &stopString, 10 );
        }

        hr = S_OK;
        WsbAffirmHr(SetOutputFormat(timeValue, countValue, threadValue));
    } WsbCatch( hr );

    
    return( hr );
}       

HRESULT 
CWsbTrace::SetTraceEntryExit( 
    BOOL traceEntryExit
    )
/*++

Implements:

  IWsbTrace::SetTraceEntryExit

--*/
{
    HRESULT     hr = S_OK;

    g_WsbTraceEntryExit = traceEntryExit;
    m_TraceEntryExit = traceEntryExit;

    
    return( hr );
}       

HRESULT 
CWsbTrace::GetTraceEntryExit( 
    BOOL *pTraceEntryExit
    )
/*++

Implements:

  IWsbTrace::GetTraceEntryExit

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pTraceEntryExit, E_POINTER);
        *pTraceEntryExit = m_TraceEntryExit;
    } WsbCatch( hr );

    
    return( hr );
}


HRESULT 
CWsbTrace::SetLogLevel( 
    WORD logLevel
    )
/*++

Implements:

  IWsbTrace::SetLogLevel

--*/
{
    HRESULT     hr = S_OK;

    g_WsbLogLevel = logLevel;
    m_LogLevel = logLevel;

    
    return( hr );
}


HRESULT 
CWsbTrace::GetLogLevel( 
    WORD *pLogLevel
    )
/*++

Implements:

  IWsbTrace::GetLogLevel

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pLogLevel, E_POINTER);
        *pLogLevel = m_LogLevel;
    } WsbCatch( hr );

    
    return( hr );
}   


HRESULT 
CWsbTrace::SetLogSnapShot( 
    BOOL            on,
    WORD            level,
    OLECHAR         *snapShotPath,
    BOOL            resetTrace
    )
/*++

Implements:

  IWsbTrace::SetLogSnapShot

--*/
{
    HRESULT     hr = S_OK;

    g_WsbLogSnapShotOn = on;
    g_WsbLogSnapShotLevel = level;
    if (snapShotPath != 0)  {
        wcscpy(g_pWsbLogSnapShotPath, snapShotPath);
    }
    g_WsbLogSnapShotResetTrace = resetTrace;
    
    return( hr );
}


HRESULT 
CWsbTrace::GetLogSnapShot( 
    BOOL            *pOn,
    WORD            *pLevel,
    OLECHAR         **pSnapShotPath,
    BOOL            *pResetTrace
    )
/*++

Implements:

  IWsbTrace::GetLogSnapShot

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pOn, E_POINTER);
        WsbAssert(0 != pLevel, E_POINTER);
        WsbAssert(0 != pSnapShotPath, E_POINTER);
        WsbAssert(0 != pResetTrace, E_POINTER);
        
        *pOn = g_WsbLogSnapShotOn;
        
        CWsbStringPtr path;
        path = g_pWsbLogSnapShotPath;
        path.GiveTo(pSnapShotPath);
        
        *pLevel = g_WsbLogSnapShotLevel;
        *pResetTrace = g_WsbLogSnapShotResetTrace;
        
        
    } WsbCatch( hr );

    
    return( hr );
}   


HRESULT 
CWsbTrace::LoadStart( 
    void
    )
/*++

Implements:

  IWsbTrace::LoadStart

--*/
{
    HRESULT     hr = S_OK;

    try {
        DWORD   sizeGot;
        OLECHAR dataString[100];
        OLECHAR *stopString;
        BOOL    value = FALSE;

        hr = WsbGetRegistryValueString(NULL, m_RegistrySetting, WSB_TRACE_ON,
                                            dataString, 100, &sizeGot);
        if (hr == S_OK) {
            value = (BOOL) wcstoul( dataString,  &stopString, 10 );
            if (value)  {
                StartTrace();               
            } else  {
                StopTrace();
            }
        }

        hr = S_OK;
    } WsbCatch( hr );

    
    return( hr );
}       


//  Write - write a WCHAR string to the output file as multibyte chars.
HRESULT 
CWsbTrace::Write( 
    OLECHAR *pString
    )
{
    HRESULT         hr = S_OK;
    const int       safe_size = 1024;
    static char     buf[safe_size + 16];

    try  {
        int nbytes;
        int nchars_todo;
        int nchars_remaining;
        OLECHAR *pSource;
        OLECHAR *pTest;
        BOOL needToAddReturn = FALSE;
        CWsbStringPtr   endOfLine("\r\n");

        //  Get the total number of chars. in the string
        pSource = pString;
        nchars_remaining = wcslen(pSource);
        pTest = (pString + nchars_remaining - 1);
        //
        // Make sure that if this is a terminating line
        // that it is a \r\n termination not just a
        // \n.
        //
        if (*pTest == '\n') {
            pTest--;
            if (*pTest != '\r')  {
                needToAddReturn = TRUE;
                nchars_remaining--;
            }
        }

        //  Loop until all chars. are written
        while (nchars_remaining) {
            DWORD bytesWritten;

            if (nchars_remaining * sizeof(OLECHAR) > safe_size) {
                nchars_todo = safe_size / sizeof(OLECHAR);
            } else {
                nchars_todo = nchars_remaining;
            }

            //  Convert characters from wide to narrow
            do {
                nbytes = wcstombs(buf, pSource, nchars_todo);
                if (nbytes <= 0) {

                    // Hit a bad character; try fewer characters
                    nchars_todo /= 2;
                    if (0 == nchars_todo) {

                        // Skip the next character
                        nchars_todo = 1;
                        nbytes = 1;
                        buf[0] = '?';
                    }
                }
            } while (nbytes <= 0);

            WsbAffirm(WriteFile(m_TraceFilePointer, buf, nbytes, 
                    &bytesWritten, NULL), E_FAIL);
            WsbAffirm(static_cast<int>(bytesWritten) == nbytes, E_FAIL);
            nchars_remaining -= nchars_todo;
            pSource += nchars_todo;
        }
        
        if (needToAddReturn)  {
            DWORD bytesWritten;

            nbytes = wcstombs(buf, (OLECHAR *)endOfLine, 2);
            WsbAffirm(nbytes > 0, E_FAIL);
            WsbAffirm(WriteFile(m_TraceFilePointer, buf, nbytes, 
                    &bytesWritten, NULL), E_FAIL);
            WsbAffirm(static_cast<int>(bytesWritten) == nbytes, E_FAIL);
            
        }
    
    } WsbCatch( hr );
    
    return( hr );
}       


HRESULT  
CWsbTrace::SetTraceSettings( 
    LONGLONG traceElements 
    )
/*++

Implements:

  IWsbTrace::SetTraceSettings

--*/
{
    HRESULT     hr = S_OK;
    
    try 
    {
        
        g_WsbTraceModules = traceElements;
        m_TraceSettings = g_WsbTraceModules;
        
    } WsbCatch( hr );
    
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbushrt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbushrt.h

Abstract:

    This component is an object representations of the USHORT standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"

#ifndef _WSBUSHRT_
#define _WSBUSHRT_

/*++

Class Name:
    
    CWsbUshort

Class Description:

    An object representations of the USHORT standard type. It
    is both persistable and collectable.

--*/

class CWsbUshort : 
    public CWsbObject,
    public IWsbUshort,
    public CComCoClass<CWsbUshort,&CLSID_CWsbUshort>
{
public:
    CWsbUshort() {}
BEGIN_COM_MAP(CWsbUshort)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbUshort)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbUshort)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbUshort)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbUshort
public:
    STDMETHOD(CompareToUshort)(USHORT value, SHORT* pResult);
    STDMETHOD(CompareToIUshort)(IWsbUshort* pUshort, SHORT* pResult);
    STDMETHOD(GetUshort)(USHORT* pValue);
    STDMETHOD(SetUshort)(USHORT value);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    USHORT          m_value;
};

#endif // _WSBUSHRT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbushrt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbushrt.cpp

Abstract:

    This component is an object representations of the USHORT standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsbushrt.h"


HRESULT
CWsbUshort::CompareToUshort(
    IN USHORT value,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbUshort::CompareToUshort

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result;

    WsbTraceIn(OLESTR("CWsbUshort::CompareToUshort"), OLESTR("value = <%ld>"), value);

    // Compare the values.
    if (m_value == value) {
        result = 0;
    }
    else if (m_value > value) {
        result = 1;
    }
    else {
        result = -1;
    }

    // If the aren't equal, then return false.
    if (result != 0) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

    // If they asked for the relative value back, then return it to them.
    if (pResult != NULL) {
        *pResult = result;
    }

    WsbTraceOut(OLESTR("CWsbUshort::CompareToUshort"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), result);

    return(hr);
}


HRESULT
CWsbUshort::CompareToIUshort(
    IN IWsbUshort* pUshort,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbUshort::CompareToIShort

--*/
{
    HRESULT     hr = E_FAIL;
    USHORT      value;

    WsbTraceIn(OLESTR("CWsbUshort::CompareToIUshort"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUshort, E_POINTER);

        // Get it's value and compare them.
        WsbAffirmHr(pUshort->GetUshort(&value));
        hr = CompareToUshort(value, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::CompareToIUshort"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbUshort::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    IWsbUshort* pUshort;

    WsbTraceIn(OLESTR("CWsbUshort::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbUshort interface to get the value of the object.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbUshort, (void**) &pUshort));
        hr = CompareToIUshort(pUshort, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CWsbUshort::FinalConstruct(
    void
    )

/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
        
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = 0;

    } WsbCatch(hr);

    return(hr);
}
    

HRESULT
CWsbUshort::GetUshort(
    OUT USHORT* pValue
    )

/*++

Implements:

  IWsbUshort::GetUshort

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::GetUshort"), OLESTR(""));

    try {

        WsbAssert(0 != pValue, E_POINTER);
        *pValue = m_value;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::GetUshort"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}


HRESULT
CWsbUshort::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbUshort;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbUshort::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::GetSizeMax"), OLESTR(""));

    try {
        
        WsbAssert(0 != pcbSize, E_POINTER);
        pcbSize->QuadPart = WsbPersistSizeOf(USHORT);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CWsbUshort::Load(
    IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::Load"), OLESTR(""));

    try {
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_value));      

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::Load"), OLESTR("hr = <%ls>, value = <%ld>"), WsbHrAsString(hr), m_value);

    return(hr);
}


HRESULT
CWsbUshort::Save(
    IStream* pStream,
    BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbUshort::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAffirmHr(WsbSaveToStream(pStream, m_value));     

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbUshort::SetUshort(
    USHORT value
    )

/*++

Implements:

  IWsbUshort::SetUshort

--*/
{
    WsbTraceIn(OLESTR("CWsbUshort::SetUshort"), OLESTR("value = <%ld>"), value);

    m_isDirty = TRUE;
    m_value = value;

    WsbTraceOut(OLESTR("CWsbUshort::SetUshort"), OLESTR(""));

    return(S_OK);
}


HRESULT
CWsbUshort::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbUshort>     pUshort1;
    CComPtr<IWsbUshort>     pUshort2;
//  CComPtr<IPersistFile>   pFile1;
//  CComPtr<IPersistFile>   pFile2;
    USHORT                  value;
    SHORT                   result;

    WsbTraceIn(OLESTR("CWsbUshort::Test"), OLESTR(""));

    try {

        // Get the pUshort interface.
        hr = S_OK;
        try {
            WsbAffirmHr(((IUnknown*) (IWsbUshort*) this)->QueryInterface(IID_IWsbUshort, (void**) &pUshort1));

            // Set the bool to a value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAffirmHr(pUshort1->SetUshort(65000));
                WsbAffirmHr(pUshort1->GetUshort(&value));
                WsbAssert(value == 65000, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }


            // Create another instance and test the comparisson methods:
            try {
                WsbAffirmHr(CoCreateInstance(CLSID_CWsbUshort, NULL, CLSCTX_ALL, IID_IWsbUshort, (void**) &pUshort2));
            
                // Check the default values.
                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort2->GetUshort(&value));
                    WsbAssert(value == 0, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                // IsEqual()
                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(767));
                    WsbAffirmHr(pUshort2->SetUshort(767));
                    WsbAssert(pUshort1->IsEqual(pUshort2) == S_OK, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(767));
                    WsbAffirmHr(pUshort2->SetUshort(167));
                    WsbAssert(pUshort1->IsEqual(pUshort2) == S_FALSE, E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
                
                
                // CompareTo()
                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(900));
                    WsbAffirmHr(pUshort2->SetUshort(900));
                    WsbAssert((pUshort1->CompareTo(pUshort2, &result) == S_OK) && (0 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(900));
                    WsbAffirmHr(pUshort2->SetUshort(1400));
                    WsbAssert((pUshort1->CompareTo(pUshort2, &result) == S_FALSE) && (-1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }


                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->SetUshort(15000));
                    WsbAffirmHr(pUshort2->SetUshort(10000));
                    WsbAssert((pUshort1->CompareTo(pUshort2, &result) == S_FALSE) && (1 == result), E_FAIL);
                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }

#ifdef BOOL_PERSIST_FILE
// TODO?  Open the file and convert it to a stream?
                // Try out the persistence stuff.
                hr = S_OK;
                try {
                    WsbAffirmHr(pUshort1->QueryInterface(IID_IPersistFile, (void**) &pFile1));
                    WsbAffirmHr(pUshort2->QueryInterface(IID_IPersistFile, (void**) &pFile2));

                    // The item should be dirty.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pUshort2->SetUshort(777));
                        WsbAssert(pFile2->IsDirty() == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }
                    
                    
                    // Save the item, and remember.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pFile2->Save(OLESTR("c:\\WsbTests\\WsbUshort.tst"), TRUE));
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }


                    // It shouldn't be dirty.
                    hr = S_OK;
                    try {
                        WsbAssert(pFile2->IsDirty() == S_FALSE, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                    
                    // Try reading it in to another object.
                    hr = S_OK;
                    try {
                        WsbAffirmHr(pUshort1->SetUshort(888));
                        WsbAffirmHr(pFile1->Load(OLESTR("c:\\WsbTests\\WsbUshort.tst"), 0));
                        WsbAssert(pUshort1->CompareToUshort(777, NULL) == S_OK, E_FAIL);
                    } WsbCatch(hr);

                    if (hr == S_OK) {
                        (*passed)++;
                    } else {
                        (*failed)++;
                    }

                } WsbCatch(hr);

                if (hr == S_OK) {
                    (*passed)++;
                } else {
                    (*failed)++;
                }
#endif
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }
        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }


        // Tally up the results
        if (*failed) {
            hr = S_FALSE;
        } else {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbUshort::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbusn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    WsbUsn.cpp

Abstract:

    Functions to manipulate the USN journal and USN records on a file

Author:

    Rick Winter [rick]  11-17-97

Revision History:

--*/

#include "stdafx.h"

#define HSM_FILE_CHANGED  (USN_REASON_DATA_OVERWRITE | USN_REASON_DATA_EXTEND | USN_REASON_DATA_TRUNCATION | USN_REASON_FILE_DELETE)

//  Local functions
static HANDLE OpenVol(OLECHAR* volName);



HRESULT
WsbCheckUsnJournalForChanges(
    OLECHAR*    volName,
    LONGLONG    FileId,
    LONGLONG    StartUsn,
    LONGLONG    StopUsn,
    BOOL*       pChanged
    )  

/*++

Routine Description:

    Check the USN Journal for changes to the unnamed data stream for this
    file between the given USNs.

Arguments:

    volName  -  Volume name

    FileId   -  File ID of file

    StartUsn -  USN to start at in journal

    StopUsn  -  USN to stop at in journal

    pChanged -  Pointer to result: TRUE for change

Return Value:

    S_OK   - success

--*/
{
    ULONGLONG               Buffer[1024];
    HRESULT                 hr = S_OK;
    IO_STATUS_BLOCK         Iosb;
    USN                     NextUsn;
    NTSTATUS                Status;
    READ_USN_JOURNAL_DATA   ReadUsnJournalData;
    DWORD                   ReturnedByteCount;
    ULONGLONG               usnId;
    PUSN_RECORD             pUsnRecord;
    HANDLE                  volHandle = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("WsbCheckUsnJournalForChanges"), 
            OLESTR("volName = %ls, FileId = %I64x, StartUsn = %I64d, StopUsn = %I64d"),
            volName, FileId, StartUsn, StopUsn);

    try {
        WsbAffirmPointer(pChanged);
        *pChanged = FALSE;
        volHandle = OpenVol(volName);
        WsbAffirmHandle(volHandle);

        //  Get the journal ID
        WsbAffirmHr(WsbGetUsnJournalId(volName, &usnId));

        //  Set up read info
        NextUsn = StartUsn;
        ReadUsnJournalData.UsnJournalID = usnId;
        ReadUsnJournalData.ReasonMask = HSM_FILE_CHANGED;
        ReadUsnJournalData.ReturnOnlyOnClose = TRUE;
        ReadUsnJournalData.Timeout = 0;          // ????
        ReadUsnJournalData.BytesToWaitFor = 0;   // ??????

        //  Loop through journal entries
        while (!*pChanged) {

            ReadUsnJournalData.StartUsn = NextUsn;
            Status = NtFsControlFile( volHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &Iosb,
                                      FSCTL_READ_USN_JOURNAL,
                                      &ReadUsnJournalData,
                                      sizeof(ReadUsnJournalData),
                                      &Buffer,
                                      sizeof(Buffer) );

            if (NT_SUCCESS(Status)) {
                Status = Iosb.Status;
            }

            if (Status == STATUS_JOURNAL_ENTRY_DELETED)  {
                WsbTrace(OLESTR("WsbCheckUsnJournalForChanges: StartUsn has been deleted\n"));
            }
            WsbAffirmNtStatus(Status);

            ReturnedByteCount = (DWORD)Iosb.Information;
            WsbTrace(OLESTR("WsbCheckUsnJournalForChanges: bytes read = %u\n"), ReturnedByteCount);

            //  Get the next USN start point & and the first
            //  journal entry
            NextUsn = *(USN *)&Buffer;
            pUsnRecord = (PUSN_RECORD)((PCHAR)&Buffer + sizeof(USN));
            ReturnedByteCount -= sizeof(USN);

            //  Make sure we actually got some entries
            if (0 == ReturnedByteCount) {
                WsbTrace(OLESTR("WsbCheckUsnJournalForChanges: no entries, exiting loop\n"), ReturnedByteCount);
                break;
            }

            //  Loop over entries in this buffer
            while (ReturnedByteCount != 0) {
                WsbAffirm(pUsnRecord->RecordLength <= ReturnedByteCount, E_FAIL);

                //  Skip the first record and check for match on File Id
                //  (Also skip entries that we created)
                if (pUsnRecord->Usn > StartUsn && 
                        USN_SOURCE_DATA_MANAGEMENT != pUsnRecord->SourceInfo &&
                        pUsnRecord->FileReferenceNumber == static_cast<ULONGLONG>(FileId)) {
                    WsbTrace(OLESTR("WsbCheckUsnJournalForChanges: found change record\n"));
                    WsbTrace(OLESTR( "    Reason: %08lx\n"), pUsnRecord->Reason);
                    *pChanged = TRUE;
                    break;
                }

                ReturnedByteCount -= pUsnRecord->RecordLength;
                pUsnRecord = (PUSN_RECORD)((PCHAR)pUsnRecord + pUsnRecord->RecordLength);
            }

            //  Make sure we're making progress
            WsbAffirm(NextUsn > ReadUsnJournalData.StartUsn, E_FAIL);

        }


    } WsbCatch( hr );

    if (INVALID_HANDLE_VALUE != volHandle) {
        CloseHandle(volHandle);
    }

    WsbTraceOut(OLESTR("WsbCheckUsnJournalForChanges"), OLESTR("Hr = <%ls>, Changed = %ls"),
            WsbHrAsString(hr), WsbBoolAsString(*pChanged));

    return( hr );
}


HRESULT
WsbGetUsnFromFileHandle(
    IN  HANDLE    hFile,
    IN  BOOL      ForceClose,
    OUT LONGLONG* pFileUsn
    )

/*++

Routine Description:

    Get the current USN Journal number for the open file.

Arguments:

    hFile    - Handle to the open file

    pFileUsn - Pointer to File USN to be returned.

Return Value:

    S_OK   - success

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("WsbGetUsnFromFileHandle"), OLESTR(""));

    try {
        char                      buffer[4096];
        IO_STATUS_BLOCK           IoStatusBlock;
        PUSN_RECORD               pUsnInfo;

        WsbAffirm(pFileUsn, E_POINTER);
        *pFileUsn = 0;

        if (TRUE == ForceClose)  {
            //  Get the internal information
            WsbAffirmNtStatus(NtFsControlFile( hFile,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       FSCTL_WRITE_USN_CLOSE_RECORD,
                                       NULL,
                                       0,
                                       buffer,
                                       sizeof(buffer)));
        }

        //  Get the internal information
        WsbAffirmNtStatus(NtFsControlFile( hFile,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   FSCTL_READ_FILE_USN_DATA,
                                   NULL,
                                   0,
                                   buffer,
                                   sizeof(buffer)));

        pUsnInfo = (PUSN_RECORD) buffer;

        WsbTrace(OLESTR("WsbGetUsnFromFileHandle, Usn record version number is %u\n"),
            pUsnInfo->MajorVersion);

        //  Check the version
        WsbAffirm(pUsnInfo->MajorVersion == 2, WSB_E_INVALID_DATA);

        //  Get the USN
        *pFileUsn = pUsnInfo->Usn;

    } WsbCatchAndDo(hr,
        WsbTrace(OLESTR("WsbGetUsnFromFileHandle, GetLastError = %lx\n"),
            GetLastError());
    );

    WsbTraceOut(OLESTR("WsbGetUsnFromFileHandle"), OLESTR("Hr = <%ls>, FileUsn = %I64d"),
            WsbHrAsString(hr), *pFileUsn);

    return(hr);
}


HRESULT
WsbMarkUsnSource(
    HANDLE          changeHandle,
    OLECHAR*        volName
    )  

/*++

Routine Description:

    Mark the source of file changes for this handle as data management.  This lets
    others, such as content indexing, know that the changes do not affect file content.

Arguments:

    changeHandle    - Handle to the open file

    volName         - Volume name (d:\)

Return Value:

    S_OK   - success

--*/
{
    HRESULT             hr = S_OK;
    HANDLE              volHandle = INVALID_HANDLE_VALUE;
    NTSTATUS            ntStatus;
    MARK_HANDLE_INFO    sInfo;
    IO_STATUS_BLOCK     IoStatusBlock;

    try {
        volHandle = OpenVol(volName);
        WsbAffirmHandle(volHandle);

        sInfo.UsnSourceInfo = USN_SOURCE_DATA_MANAGEMENT;
        sInfo.VolumeHandle = volHandle;
        sInfo.HandleInfo = 0;
        ntStatus = NtFsControlFile( changeHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   FSCTL_MARK_HANDLE,
                                   &sInfo,
                                   sizeof(MARK_HANDLE_INFO),
                                   NULL,
                                   0);

        WsbAffirmNtStatus(ntStatus);

        CloseHandle(volHandle);
        volHandle = INVALID_HANDLE_VALUE;

    } WsbCatch( hr );


    if (INVALID_HANDLE_VALUE != volHandle) {
        CloseHandle(volHandle);
    }

    return( hr );
}



HRESULT
WsbCreateUsnJournal(
    OLECHAR*        volName,
    ULONGLONG       usnSize
    )  

/*++

Routine Description:

    Create the USN journal for the given volume.

Arguments:

    volName -   Volume name (d:\)

    usnSize -   Max size of journal

Return Value:

    S_OK   - success


--*/
{
    HRESULT             hr = S_OK;
    HANDLE              volHandle = INVALID_HANDLE_VALUE;
    NTSTATUS            ntStatus;
    IO_STATUS_BLOCK     IoStatusBlock;
    CREATE_USN_JOURNAL_DATA CreateUsnJournalData;

    WsbTraceIn(OLESTR("WsbCreateUsnJournal"), OLESTR("volName = %ls, Size = %I64d"),
            volName, usnSize);

    try {
        volHandle = OpenVol(volName);
        WsbAffirmHandle(volHandle);

        CreateUsnJournalData.MaximumSize = usnSize;
        CreateUsnJournalData.AllocationDelta = usnSize / 32;

        ntStatus = NtFsControlFile( volHandle,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatusBlock,
                                        FSCTL_CREATE_USN_JOURNAL,
                                        &CreateUsnJournalData,
                                        sizeof(CreateUsnJournalData),
                                        NULL,
                                        0);
        WsbTrace(OLESTR("WsbCreateUsnJournal: ntStatus = %lx, iosb.Status = %lx\n"),
                ntStatus, IoStatusBlock.Status);

        if (STATUS_DISK_FULL == ntStatus) {
            WsbThrow(WSB_E_USNJ_CREATE_DISK_FULL);
        } else if (!NT_SUCCESS(ntStatus)) {
            WsbThrow(WSB_E_USNJ_CREATE);
        }

        WsbAffirmNtStatus(ntStatus);

    } WsbCatch( hr );


    if (INVALID_HANDLE_VALUE != volHandle) {
        CloseHandle(volHandle);
    }

    WsbTraceOut(OLESTR("WsbCreateUsnJournal"), OLESTR("Hr = <%ls>"),
            WsbHrAsString(hr));

    return( hr );
}




HRESULT
WsbGetUsnJournalId(
    OLECHAR*        volName,
    ULONGLONG*      usnId
    )  

/*++

Routine Description:

    Get the current USN Journal ID

Arguments:

    volName -   Volume name (d:\)

    usnId   -   Id is returned here.

Return Value:

    S_OK   - success

--*/
{
    HRESULT             hr = S_OK;
    HANDLE              volHandle = INVALID_HANDLE_VALUE;
    NTSTATUS            ntStatus;
    IO_STATUS_BLOCK     IoStatusBlock;
    USN_JOURNAL_DATA    usnData;

    WsbTraceIn(OLESTR("WsbGetUsnJournalId"), OLESTR("volName = %ls"), volName);

    try {
        WsbAffirmPointer(usnId);
        volHandle = OpenVol(volName);
        WsbAffirmHandle(volHandle);
                
        *usnId = (ULONGLONG) 0;
        ntStatus = NtFsControlFile( volHandle,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatusBlock,
                                        FSCTL_QUERY_USN_JOURNAL,
                                        NULL,
                                        0,
                                        &usnData,
                                        sizeof(usnData));

        WsbTrace(OLESTR("WsbGetUsnJournalId: ntStatus = %lx, iosb.Status = %lx\n"),
                ntStatus, IoStatusBlock.Status);

        if (STATUS_JOURNAL_NOT_ACTIVE == ntStatus) {
            WsbThrow(WSB_E_NOTFOUND);
        }

        WsbAffirmNtStatus(ntStatus);
        
        *usnId = usnData.UsnJournalID;

    } WsbCatch( hr );


    if (INVALID_HANDLE_VALUE != volHandle) {
        CloseHandle(volHandle);
    }

    WsbTraceOut(OLESTR("WsbGetUsnJournalId"), OLESTR("Hr = <%ls>, id = %I64x"),
            WsbHrAsString(hr), *usnId);

    return( hr );
}


//  Local functions
static HANDLE OpenVol(OLECHAR* volName)
{
    HRESULT             hr = S_OK;
    HANDLE              volHandle = INVALID_HANDLE_VALUE;
    CWsbStringPtr       name;
    WCHAR               *vPtr;

    try {
        name = volName;

        if (name == NULL) {
            WsbThrow(E_OUTOFMEMORY);
        }

        if (name[1] == L':') {
            swprintf((OLECHAR*) name, L"%2.2s", volName);
        } else {
            //
            // Must be a volume without a drive letter
            // Move to end of PNPVolumeName...

            vPtr = name;
            vPtr = wcsrchr(vPtr, L'\\');
            if (NULL != vPtr) {
                *vPtr = L'\0';
            }
        }

        WsbAffirmHr(name.Prepend(OLESTR("\\\\.\\")));
        WsbAffirmHandle(volHandle = CreateFile( name,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL ));

    } WsbCatchAndDo( hr,

        if (INVALID_HANDLE_VALUE != volHandle) {
            CloseHandle(volHandle);
        }
        volHandle = INVALID_HANDLE_VALUE;
    )
    return(volHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\cachesup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CacheSup.c

Abstract:

    This module provides an interface with the cache manager.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"
#include <ntdddisk.h>
#include <NtIoLogc.h>
#include <elfmsg.h>

//
//  The debug trace level
//

#define Dbg                             (DEBUG_TRACE_CACHE_SUP)

//
//  Following is used to generate a sequence number when the cache manager
//  gives us a page of zeroes.  Otherwise all of the sequence numbers will
//  be 1.
//

USHORT LfsUsaSeqNumber;

BOOLEAN
LfsIsRestartPageHeaderValid (
    IN LONGLONG FileOffset,
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    OUT PBOOLEAN LogPacked
    );

BOOLEAN
LfsIsRestartAreaValid (
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    IN BOOLEAN LogPacked
    );

BOOLEAN
LfsIsClientAreaValid (
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    IN BOOLEAN LogPacked,
    IN BOOLEAN UsaError
    );

VOID
LfsFindFirstIo (
    IN PLFCB Lfcb,
    IN PLBCB TargetLbcb,
    IN PLBCB FirstLbcb,
    OUT PLBCB *NextLbcb,
    OUT PLONGLONG FileOffset,
    OUT PBOOLEAN ContainsLastEntry,
    OUT PBOOLEAN LfsRestart,
    OUT PBOOLEAN UseTailCopy,
    OUT PULONG IoBlocks
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsCopyReadLogRecord)
#pragma alloc_text(PAGE, LfsFindFirstIo)
#pragma alloc_text(PAGE, LfsFlushLfcb)
#pragma alloc_text(PAGE, LfsIsClientAreaValid)
#pragma alloc_text(PAGE, LfsIsRestartAreaValid)
#pragma alloc_text(PAGE, LfsIsRestartPageHeaderValid)
#pragma alloc_text(PAGE, LfsPinOrMapData)
#pragma alloc_text(PAGE, LfsPinOrMapLogRecordHeader)
#pragma alloc_text(PAGE, LfsReadRestart)
#endif


NTSTATUS
LfsPinOrMapData (
    IN PLFCB Lfcb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN BOOLEAN PinData,
    IN BOOLEAN AllowErrors,
    IN BOOLEAN IgnoreUsaErrors,
    OUT PBOOLEAN UsaError,
    OUT PVOID *Buffer,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine will pin or map a portion of the log file.

Arguments:

    Lfcb - This is the file control block for the log file.

    FileOffset - This is the offset of the log page to pin.

    Length - This is the length of the data to access.

    PinData - Boolean indicating if we are to pin or map this data.

    AllowErrors - This boolean indicates whether we should raise on an
        I/O error or return on an I/O error.

    IgnoreUsaErrors - Boolean indicating whether we will raise on Usa
        errors.

    UsaError - Address to store whether the Usa had an error.

    Buffer - This is the address to store the address of the data.

    Bcb - This is the Bcb for this operation.

Return Value:

    NTSTATUS - The result of the I/O.

--*/

{
    volatile NTSTATUS Status;
    ULONG Signature;
    BOOLEAN Result = FALSE;

    Status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsPinReadLogPage:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "FileOffset (Low)  -> %08lx\n", FileOffset.HighPart );
    DebugTrace(  0, Dbg, "FileOffset (High) -> %08lx\n", FileOffset.LowPart );
    DebugTrace(  0, Dbg, "Length            -> %08lx\n", Length );
    DebugTrace(  0, Dbg, "PinData           -> %04x\n", PinData );
    DebugTrace(  0, Dbg, "AllowErrors       -> %08x\n", AllowErrors );
    DebugTrace(  0, Dbg, "IgnoreUsaErrors   -> %04x\n", IgnoreUsaErrors );

    if (FileOffset + Length > Lfcb->FileSize) {
        ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Use a try-except to catch cache manager errors.
        //

        try {

            //
            //  We call the cache to perform the work.
            //

            if (PinData) {

                Result = CcPinRead( Lfcb->FileObject,
                                    (PLARGE_INTEGER)&FileOffset,
                                    Length,
                                    TRUE,
                                    Bcb,
                                    Buffer );

            } else {

                Result = CcMapData( Lfcb->FileObject,
                                    (PLARGE_INTEGER)&FileOffset,
                                    Length,
                                    TRUE,
                                    Bcb,
                                    Buffer );
            }

            //
            //  Capture the signature now while we are within the
            //  exception filter.
            //

            Signature = *((PULONG) *Buffer);

        } except( LfsExceptionFilter( GetExceptionInformation() )) {

            Status = GetExceptionCode();
            if (Result) {
                CcUnpinData( *Bcb );
                *Bcb = NULL;
            }
        }

        *UsaError = FALSE;

        //
        //  If an error occurred, we raise the status.
        //

        if (!NT_SUCCESS( Status )) {

            if (!AllowErrors) {

                DebugTrace( 0, Dbg, "Read on log page failed -> %08lx\n", Status );
                ExRaiseStatus( Status );
            }

            //
            //  Check that the update sequence array for this
            //  page is valid.
            //

        } else if (Signature == LFS_SIGNATURE_BAD_USA_ULONG) {

            //
            //  If we don't allow errors, raise an error status.
            //

            if (!IgnoreUsaErrors) {

                DebugTrace( 0, Dbg, "Usa error on log page\n", 0 );
                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            *UsaError = TRUE;
        }

    } finally {

        DebugUnwind( LfsPinOrMapData );

        DebugTrace(  0, Dbg, "Buffer    -> %08lx\n", *Buffer );
        DebugTrace(  0, Dbg, "Bcb       -> %08lx\n", *Bcb );

        DebugTrace( -1, Dbg, "LfsPinOrMapData:  Exit -> %08lx\n", Status );
    }

    return Status;
}


VOID
LfsPinOrMapLogRecordHeader (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN BOOLEAN PinData,
    IN BOOLEAN IgnoreUsaErrors,
    OUT PBOOLEAN UsaError,
    OUT PLFS_RECORD_HEADER *RecordHeader,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine will pin or map a log record for read access.

Arguments:

    Lfcb - This is the file control block for the log file.

    Lsn - This is the Lsn whose header should be pinned.

    PinData - Boolean indicating if we are to pin or map this data.

    IgnoreUsaErrors - Boolean indicating whether we will raise on Usa
        errors.

    UsaError - Address to store whether the Usa had an error.

    RecordHeader - This is the address to store the address of the pinned data.

    Bcb - This is the Bcb for this pin operation.

Return Value:

    None.

--*/

{
    PLFS_RECORD_PAGE_HEADER LogPageHeader;
    LONGLONG LogPage;
    ULONG PageOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsPinOrMapLogRecordHeader:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb       -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lsn (Low)  -> %08lx\n", Lsn.HighPart );
    DebugTrace(  0, Dbg, "Lsn (High) -> %08lx\n", Lsn.LowPart );
    DebugTrace(  0, Dbg, "PinData           -> %04x\n", PinData );
    DebugTrace(  0, Dbg, "IgnoreUsaErrors   -> %04x\n", IgnoreUsaErrors );

    //
    //  Compute the log page and the offset of the log record header
    //  in the log page.
    //

    LfsTruncateLsnToLogPage( Lfcb, Lsn, &LogPage );
    PageOffset = LfsLsnToPageOffset( Lfcb, Lsn );

    //
    //  Call the cache manager to pin the page.
    //

    LfsPinOrMapData( Lfcb,
                     LogPage,
                     (ULONG)Lfcb->LogPageSize,
                     PinData,
                     FALSE,
                     IgnoreUsaErrors,
                     UsaError,
                     (PVOID *) &LogPageHeader,
                     Bcb );

    //
    //  The actual offset we need is at PageOffset from the start of the page.
    //

    *RecordHeader = Add2Ptr( LogPageHeader, PageOffset, PLFS_RECORD_HEADER );

    DebugTrace(  0, Dbg, "Record Header -> %08lx\n", *RecordHeader );
    DebugTrace(  0, Dbg, "Bcb           -> %08lx\n", *Bcb );

    DebugTrace( -1, Dbg, "LfsPinOrMapLogRecordHeader:  Exit\n", 0 );

    return;
}


VOID
LfsCopyReadLogRecord (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_HEADER RecordHeader,
    OUT PVOID Buffer
    )

/*++

Routine Description:

    This routines copies a log record from the file to a buffer.  The log
    record may span several log pages and may even wrap in the file.

Arguments:

    Lfcb - A pointer to the control block for the log file.

    RecordHeader - Pointer to the log record header for this log record.

    Buffer - Pointer to the buffer to store the log record.

Return Value:

    None.

--*/

{
    PBCB Bcb = NULL;
    BOOLEAN UsaError;

    PLFS_RECORD_PAGE_HEADER PageHeader;

    LONGLONG LogPageFileOffset;
    ULONG LogPageOffset;

    ULONG RemainingTransferBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsCopyReadLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb           -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "RecordHeader   -> %08lx\n", RecordHeader );
    DebugTrace(  0, Dbg, "Buffer         -> %08lx\n", Buffer );

    //
    //  We find the file offset of the log page containing the start of
    //  this log record, the offset within the page to start the transfer from,
    //  the number of bytes to transfer on this page and the starting
    //  position in the buffer to begin the transfer to.
    //

    LfsTruncateLsnToLogPage( Lfcb, RecordHeader->ThisLsn, &LogPageFileOffset );
    LogPageOffset = LfsLsnToPageOffset( Lfcb, RecordHeader->ThisLsn ) + Lfcb->RecordHeaderLength;

    RemainingTransferBytes = RecordHeader->ClientDataLength;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  While there are more bytes to transfer, we continue to attempt to
        //  perform the read.
        //

        while (TRUE) {

            ULONG RemainingPageBytes;

            BOOLEAN Wrapped;

            RemainingPageBytes = (ULONG)Lfcb->LogPageSize - LogPageOffset;

            //
            //  We compute the number of bytes to read from this log page and
            //  call the cache package to perform the transfer.
            //

            if (RemainingTransferBytes <= RemainingPageBytes) {

                RemainingPageBytes = RemainingTransferBytes;
            }

            RemainingTransferBytes -= RemainingPageBytes;

            //
            //  Unpin any previous buffer.
            //

            if (Bcb != NULL) {

                CcUnpinData( Bcb );
                Bcb = NULL;
            }

            LfsPinOrMapData( Lfcb,
                             LogPageFileOffset,
                             (ULONG)Lfcb->LogPageSize,
                             FALSE,
                             FALSE,
                             TRUE,
                             &UsaError,
                             (PVOID *) &PageHeader,
                             &Bcb );

            //
            //  The last Lsn on this page better be greater or equal to the Lsn we
            //  are copying.
            //

            if ( PageHeader->Copy.LastLsn.QuadPart < RecordHeader->ThisLsn.QuadPart ) {

                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            RtlCopyMemory( Buffer,
                           Add2Ptr( PageHeader, LogPageOffset, PVOID ),
                           RemainingPageBytes );

            //
            //  If there are no more bytes to transfer, we exit the loop.
            //

            if (RemainingTransferBytes == 0) {

                //
                //  Our log record better not span this page.
                //

                if (!FlagOn( PageHeader->Flags, LOG_PAGE_LOG_RECORD_END )

                    || (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
                        && ( RecordHeader->ThisLsn.QuadPart > PageHeader->Header.Packed.LastEndLsn.QuadPart ))) {

                    ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
                }

                break;
            }

            //
            //  If the page header indicates that the log record ended on this page,
            //  this is a disk corrupt condition.  For a packed page it means
            //  that the last Lsn and the last Ending Lsn are the same.
            //

            if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

                //
                //  If there is no spanning log record this is an error.
                //

                if (( PageHeader->Copy.LastLsn.QuadPart == PageHeader->Header.Packed.LastEndLsn.QuadPart )

                    || ( RecordHeader->ThisLsn.QuadPart > PageHeader->Copy.LastLsn.QuadPart )) {

                    ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
                }

                //
                //  For an unpacked page it simply means that the page
                //  contains the end of a log record.
                //

            } else if (FlagOn( PageHeader->Flags, LOG_PAGE_LOG_RECORD_END )) {

                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            //
            //  We find the start of the next log page and the offset within
            //  that page to start transferring bytes.
            //

            LfsNextLogPageOffset( Lfcb,
                                  LogPageFileOffset,
                                  &LogPageFileOffset,
                                  &Wrapped );

            LogPageOffset = (ULONG)Lfcb->LogPageDataOffset;

            //
            //  We also adjust our pointer in the user's buffer to transfer
            //  the next block to.
            //

            Buffer = Add2Ptr( Buffer, RemainingPageBytes, PVOID );
        }

    } finally {

        //
        //  Unpin any previous buffer.
        //

        if (Bcb != NULL) {

            CcUnpinData( Bcb );
            Bcb = NULL;
        }

        DebugTrace( -1, Dbg, "LfsCopyReadLogRecord:  Exit\n", 0 );
    }

    return;
}



BOOLEAN
LfsProtectRestOfDirtyPage (
    IN PLFCB Lfcb,
    IN LONGLONG FileOffset,
    IN LONG Length,
    OUT PBCB * MapPageBcb
    )

/*++

Routine Description:

    This routine is called to scan for any other lfs pages within the current
    system page and protect during the flush by adding to the dirtypage list
    and unpinning them. On x86 system page == lfs page size so this is a no-op.
    Caller should pre-check page sizes and only call when they are not equal

Arguments:

    Lfcb - This is the file control block for the log file.

    CurrentLbcb - This is the block which is needed to be flushed to disk - if null
                  we're tail copying.

    FileOffset - actual flush offset

    Length - actual flush length

    MapPageBcb - Outputted bcb covering the system page


Return Value:

    TRUE if any other pages were found that needed to be protected

--*/

{
    LONGLONG NextOffset;
    LONGLONG BaseOffset;
    PLIST_ENTRY Links;
    PLBCB TailLbcb;
    PVOID MapPage;
    LONG Index = 0;
    BOOLEAN ChangedPages = FALSE;

    BaseOffset = FileOffset + Length;
    NextOffset = ((BaseOffset - 1 ) & ~(PAGE_SIZE - 1)) + PAGE_SIZE;


    LfsAcquireLfcb( Lfcb );

    //
    //  Start by looking through the Lbcbs on the active queue.
    //  Note: restart pages have no bcbs so we don't need to don't anything
    //  for them
    //

    Links = Lfcb->LbcbActive.Flink;
    while (Links != &Lfcb->LbcbActive) {

        TailLbcb = CONTAINING_RECORD( Links,
                                      LBCB,
                                      ActiveLinks );

        if ((TailLbcb->FileOffset >= BaseOffset) &&
            (TailLbcb->FileOffset < NextOffset) &&
            (TailLbcb->LogPageBcb)) {

            Lfcb->DirtyLbcb[Index] = TailLbcb;
            Index++;
            CcUnpinDataForThread( TailLbcb->LogPageBcb,
                                  TailLbcb->ResourceThread );
            TailLbcb->LogPageBcb = NULL;
            ChangedPages = TRUE;
        }
        Links = Links->Flink;
    }


    Links = Lfcb->LbcbWorkque.Flink;
    while (Links != &Lfcb->LbcbWorkque) {

        TailLbcb = CONTAINING_RECORD( Links,
                                      LBCB,
                                      WorkqueLinks );

        if ((TailLbcb->FileOffset >= BaseOffset) &&
            (TailLbcb->FileOffset < NextOffset) &&
            (!FlagOn( TailLbcb->Flags, LBCB_ON_ACTIVE_QUEUE )) &&
            (TailLbcb->LogPageBcb)) {

            Lfcb->DirtyLbcb[Index] = TailLbcb;
            Index++;
            CcUnpinDataForThread( TailLbcb->LogPageBcb,
                                  TailLbcb->ResourceThread );
            TailLbcb->LogPageBcb = NULL;
            ChangedPages = TRUE;
        }
        Links = Links->Flink;
    }

    //
    //  If we found an Lbcb then unpin the page temporarily.
    //  Other users will have to detect this is not pinned.
    //

    if (ChangedPages) {

        //
        //  Go ahead and map this page to keep the virtual address
        //  valid.
        //

        BaseOffset = NextOffset - PAGE_SIZE;

        CcMapData( Lfcb->FileObject,
                   (PLARGE_INTEGER) &BaseOffset,
                   (ULONG) PAGE_SIZE,
                   TRUE,
                   MapPageBcb,
                   &MapPage );
    }

    LfsReleaseLfcb( Lfcb );

    return ChangedPages;
}



VOID
LfsRestoreRestOfDirtyPage (
    IN PLFCB Lfcb,
    IN PBCB  MapPageBcb
    )

/*++

Routine Description:


Arguments:

    Lfcb - This is the file control block for the log file.

    MapPageBcb - BCB covering the system page which will be unpinned

Return Value:

    None.

--*/

{
    ULONG Index;
    ULONG Bound = PAGE_SIZE / (ULONG)(Lfcb->LogPageSize);

    for (Index=0; Index < Bound && Lfcb->DirtyLbcb[Index] != NULL; Index++) {

        LfsPreparePinWriteData( Lfcb,
                                Lfcb->DirtyLbcb[Index]->FileOffset,
                                (ULONG) Lfcb->LogPageSize,
                                TRUE,
                                &Lfcb->DirtyLbcb[Index]->PageHeader,
                                &Lfcb->DirtyLbcb[Index]->LogPageBcb );

        CcSetBcbOwnerPointer( Lfcb->DirtyLbcb[Index]->LogPageBcb, (PVOID) Lfcb->DirtyLbcb[Index]->ResourceThread );
        Lfcb->DirtyLbcb[Index] = NULL;

    }

    CcUnpinData( MapPageBcb );
    MapPageBcb = NULL;
}



VOID
LfsFlushLfcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    )

/*++

Routine Description:

    This routine is called to flush the current Lbcbs in on the Lfcb
    work queue.  It will flush up to the I/O which contains the desired
    Lbcb.

Arguments:

    Lfcb - This is the file control block for the log file.

    Lbcb - This is the block which is needed to be flushed to disk.

Return Value:

    None.

--*/

{
    PLBCB FirstLbcb;
    PLBCB ThisLbcb;
    PLBCB NextLbcb;

    PLBCB TargetLbcb;
    PULONG Signature;

    LONGLONG FileOffset;
    ULONG Length;

    BOOLEAN ValidLastLsn = FALSE;

    BOOLEAN ContainsLastEntry = FALSE;
    BOOLEAN LfsRestart;
    BOOLEAN UseTailCopy;
    BOOLEAN ProtectedPages = FALSE;

    ULONG IoBlocks;
    ULONG NewLfcbFlags = 0;

    PBCB MapPageBcb = NULL;

    LSN LastLsn;

    IO_STATUS_BLOCK Iosb;

    PBCB PageBcb = NULL;
    NTSTATUS FailedFlushStatus = STATUS_SUCCESS;
    LONGLONG FailedFlushOffset;

    KEVENT Event;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFlushLfcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );

    //
    //  We'd absolutely hate for this to happen on a read only volume.
    //

    ASSERT(!(BooleanFlagOn( Lfcb->Flags, LFCB_READ_ONLY )));

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there are no elements on the list, we are done.
        //

        if (IsListEmpty( &Lfcb->LbcbWorkque )) {

            leave;
        }

        KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

        //
        //  Mark the Lfcb as Io in progress.
        //

        Lfcb->LfsIoState = LfsClientThreadIo;
        Lfcb->LfsIoThread = ExGetCurrentResourceThread();

        //
        //  Remember the first Lbcb in the list.
        //

        FirstLbcb = CONTAINING_RECORD( Lfcb->LbcbWorkque.Flink,
                                       LBCB,
                                       WorkqueLinks );

        //
        //  We continue looping and performing I/o for as long as possible.
        //

        while (!ContainsLastEntry) {

            //
            //  Reset the notify event for all of the waiting threads.
            //

            KeClearEvent( &Lfcb->Sync->Event );

            //
            //  Find the block of Lbcb's that make up the first I/O, remembering
            //  how many there are.  Also remember if this I/O contains the
            //  last element on the list when we were called.
            //

            LfsFindFirstIo( Lfcb,
                            Lbcb,
                            FirstLbcb,
                            &NextLbcb,
                            &FileOffset,
                            &ContainsLastEntry,
                            &LfsRestart,
                            &UseTailCopy,
                            &IoBlocks );

            Length = IoBlocks * (ULONG) Lfcb->LogPageSize;
            if (UseTailCopy) {

                TargetLbcb = Lfcb->ActiveTail;
                Lfcb->ActiveTail = Lfcb->PrevTail;
                Lfcb->PrevTail = TargetLbcb;

                FileOffset = TargetLbcb->FileOffset;

            } else {

                TargetLbcb = FirstLbcb;
            }

            //
            //  Give up the Lfcb unless we are looking at an active page.
            //

            if (!UseTailCopy) {

                LfsReleaseLfcb( Lfcb );
            }

            //
            //  If this I/O involves the Lfs restart area, write it to the
            //  cache pages.
            //

            if (LfsRestart) {

                PLFS_RESTART_PAGE_HEADER RestartPage;

                ASSERT( !UseTailCopy && IoBlocks == 1);

                //
                //  Build the partial mdl to describe this lfs restart page from the permanently
                //  mapped piece of the log
                //

                RestartPage = Add2Ptr( Lfcb->LogHeadBuffer, FileOffset, PLFS_RESTART_PAGE_HEADER );
                IoBuildPartialMdl( Lfcb->LogHeadMdl, Lfcb->LogHeadPartialMdl, RestartPage, (ULONG)Lfcb->LogPageSize );

                //
                //  Initialize the restart page header.
                //

                Signature = (PULONG) &RestartPage->MultiSectorHeader.Signature;

                *Signature = LFS_SIGNATURE_RESTART_PAGE_ULONG;
                RestartPage->ChkDskLsn = LfsLi0;

                RestartPage->MultiSectorHeader.UpdateSequenceArrayOffset
                = Lfcb->RestartUsaOffset;

                RestartPage->MultiSectorHeader.UpdateSequenceArraySize
                = Lfcb->UsaArraySize;

                //
                //  Maintain the illusion that all systems have log page == system page
                //  on disk so we can migrate disks between different platforms
                //

                RestartPage->SystemPageSize = (ULONG)Lfcb->LogPageSize;
                RestartPage->LogPageSize = (ULONG)Lfcb->LogPageSize;

                RestartPage->RestartOffset = (USHORT) Lfcb->RestartDataOffset;
                RestartPage->MajorVersion = Lfcb->MajorVersion;
                RestartPage->MinorVersion = Lfcb->MinorVersion;

                //
                //  If the Lfcb indicates that the file has wrapped, then clear the
                //  first pass flag in the restart area.
                //

                if (FlagOn( Lfcb->Flags, LFCB_LOG_WRAPPED )) {

                    ClearFlag( ((PLFS_RESTART_AREA) FirstLbcb->PageHeader)->Flags, RESTART_SINGLE_PAGE_IO );
                    SetFlag( Lfcb->Flags, LFCB_MULTIPLE_PAGE_IO );
                }

                //
                //  Write the page header into the page and mark the page dirty.
                //

                RtlCopyMemory( Add2Ptr( RestartPage, Lfcb->RestartDataOffset, PVOID ),
                               FirstLbcb->PageHeader,
                               (ULONG)FirstLbcb->Length );

                LastLsn = FirstLbcb->LastLsn;
                ValidLastLsn = TRUE;

#ifdef LFS_CLUSTER_CHECK
                //
                //  Update the Lsn range on the disk.
                //

                *(Add2Ptr( RestartPage, 0xe00 - sizeof( ULONG ), PULONG )) = Lfcb->LsnRangeIndex + 1;
                *(Add2Ptr( RestartPage, 0xe00 + (sizeof( LSN ) * Lfcb->LsnRangeIndex * 2), PLSN )) = Lfcb->LsnAtMount;
                *(Add2Ptr( RestartPage, 0xe00 + (sizeof( LSN ) * (Lfcb->LsnRangeIndex * 2 + 1)), PLSN )) = Lfcb->LastFlushedLsn;

#endif
                //
                //  Use a system page size as the length we need to flush.
                //

                Length = (ULONG)Lfcb->LogPageSize;

                //
                //  Otherwise these are log record pages
                //

            } else {

                PLFS_RECORD_PAGE_HEADER RecordPageHeader;
                ULONG Count;

                //
                //  Mark the last Lsn fields for the page headers and each
                //  page's position in the transfer.  Also unpin all of the
                //  log pages.
                //


                ASSERT( UseTailCopy || FirstLbcb->FileOffset == FileOffset );

                ThisLbcb = FirstLbcb;

                for (Count=1; Count <= IoBlocks; Count++) {

                    if (UseTailCopy) {

                        //
                        //  Build the partial mdl to describe the tail (pin/pong) page
                        //  from the permanently mapped section of the log
                        //

                        RecordPageHeader = Add2Ptr( Lfcb->LogHeadBuffer, TargetLbcb->FileOffset, PLFS_RECORD_PAGE_HEADER );
                        IoBuildPartialMdl( Lfcb->LogHeadMdl, Lfcb->LogHeadPartialMdl, RecordPageHeader, (ULONG)Lfcb->LogPageSize );

                        //
                        //  Store the file offset of the real page in the header.
                        //  Also set the flag indicating the page is a tail copy.
                        //

                        RtlCopyMemory( RecordPageHeader,
                                       ThisLbcb->PageHeader,
                                       (ULONG)Lfcb->LogPageSize );

                        RecordPageHeader->Copy.FileOffset = ThisLbcb->FileOffset;

                    } else {

                        PUSHORT SeqNumber;

                        RecordPageHeader = (PLFS_RECORD_PAGE_HEADER) ThisLbcb->PageHeader;

                        //
                        //  If the sequence number is zero then this is probably a
                        //  page of zeroes produced by the cache manager.  In order
                        //  to insure that we don't have the same sequence number
                        //  on each page we will seed the sequence number.
                        //

                        SeqNumber = Add2Ptr( RecordPageHeader,
                                             Lfcb->LogRecordUsaOffset,
                                             PUSHORT );

                        if (*SeqNumber == 0) {

                            *SeqNumber = LfsUsaSeqNumber;
                            LfsUsaSeqNumber += 1;
                        }
                    }

                    //
                    //  We update all of fields as yet not updated.
                    //

                    RecordPageHeader->PagePosition = (USHORT) Count;
                    RecordPageHeader->PageCount = (USHORT) IoBlocks;

                    //
                    //  We set up the update sequence array for this structure.
                    //

                    Signature = (PULONG) &RecordPageHeader->MultiSectorHeader.Signature;
                    *Signature = LFS_SIGNATURE_RECORD_PAGE_ULONG;

                    RecordPageHeader->MultiSectorHeader.UpdateSequenceArrayOffset = Lfcb->LogRecordUsaOffset;
                    RecordPageHeader->MultiSectorHeader.UpdateSequenceArraySize = Lfcb->UsaArraySize;

                    //
                    //  Make sure the modified bit gets set in the pfn database.  The
                    //  cache manager should do this even for files we told him not to
                    //  lazy write.
                    //

                    if (!UseTailCopy) {

                        CcSetDirtyPinnedData( ThisLbcb->LogPageBcb, NULL );

                        //
                        //  We unpin any buffers pinned on this page.
                        //

                        CcUnpinDataForThread( ThisLbcb->LogPageBcb, ThisLbcb->ResourceThread );
                    }

                    //
                    //  Remember the last lsn and its length if this is the final
                    //  page of an Lsn.
                    //

                    if (FlagOn( ThisLbcb->Flags, LOG_PAGE_LOG_RECORD_END )) {

                        LastLsn = ThisLbcb->LastEndLsn;
                        ValidLastLsn = TRUE;
                    }

                    //
                    //  Otherwise move to the next entry.
                    //

                    ThisLbcb = CONTAINING_RECORD( ThisLbcb->WorkqueLinks.Flink,
                                                  LBCB,
                                                  WorkqueLinks );
                }
            }

            //
            //  Remember the range we are flushing and find the second half of a page
            //  if necessary.
            //

            Lfcb->UserWriteData->FileOffset = FileOffset;
            Lfcb->UserWriteData->Length = Length;

            //
            //  We are flushing log records.  If the current request does not end on
            //  a system page boundary then check if there is another page in
            //  memory that we are concerned with. For tail copies the current lbcb
            //  is not relevant we're actually writing to a ping pong page so don't pass it
            //

            if ( Lfcb->LogPageSize != PAGE_SIZE ) {
                ProtectedPages = LfsProtectRestOfDirtyPage( Lfcb, FileOffset, Length, &MapPageBcb );
            }

            //
            //  For the loghead pages (2 lfs restart pages and 2 ping pong pages
            //  explicitly flush them down using the partial mdl we built
            //  The regular cc logic w/ UserWriteData  that pares the write down
            //  to the correct offsets works here as well
            //

            if (LfsRestart || UseTailCopy) {

                NTSTATUS Status;

                ASSERT( IoBlocks == 1 );

                Status = IoSynchronousPageWrite( Lfcb->FileObject,
                                                 Lfcb->LogHeadPartialMdl,
                                                 (PLARGE_INTEGER)&FileOffset,
                                                 &Event,
                                                 &Iosb );

                if (Status == STATUS_PENDING) {
                    Status = KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
                }

                if (!NT_SUCCESS( Status ) || !NT_SUCCESS( Iosb.Status)) {

                    //
                    //  Record status if we haven't failed already and continue on
                    //

                    if (NT_SUCCESS( FailedFlushStatus )) {
                        if (!NT_SUCCESS( Status )) {
                            FailedFlushStatus = Status;
                        } else if (!NT_SUCCESS( Iosb.Status )) {
                            FailedFlushStatus = Iosb.Status;
                        }
                        FailedFlushOffset = FileOffset;

#ifdef LFS_CLUSTER_CHECK
                        //
                        //  Remember this to figure out naggin cluster problems.
                        //

                        if ((Status == STATUS_DEVICE_OFF_LINE) ||
                            (Iosb.Status == STATUS_DEVICE_OFF_LINE)) {

                            SetFlag( Lfcb->Flags, LFCB_DEVICE_OFFLINE_SEEN );
                        }

                        //
                        //  Remember all errors.
                        //

                        SetFlag( Lfcb->Flags, LFCB_FLUSH_FAILED );
#endif
                    }

#ifdef LFS_CLUSTER_CHECK
                } else if (Iosb.Information != 0) {

                    //
                    //  Once OFFLINE, always OFFLINE.
                    //

                    ASSERT( !FlagOn( Lfcb->Flags, LFCB_DEVICE_OFFLINE_SEEN ));

                    //
                    //  Catch the first write after a failed IO.
                    //

                    if (LfsTestBreakOnAnyError &&
                        FlagOn( Lfcb->Flags, LFCB_FLUSH_FAILED )) {

                        ASSERT( !LfsTestBreakOnAnyError ||
                                !FlagOn( Lfcb->Flags, LFCB_FLUSH_FAILED ));

                        ClearFlag( Lfcb->Flags, LFCB_FLUSH_FAILED );
                    }
#endif
                }

                //
                //  Recover the state of any partial pages we protected above.
                //

                if (ProtectedPages) {
                    LfsRestoreRestOfDirtyPage( Lfcb, MapPageBcb );
                    ProtectedPages = FALSE;
                }

            } else {

                //
                //  This is a normal log page so flush through the cache
                //

                CcFlushCache( Lfcb->FileObject->SectionObjectPointer,
                              (PLARGE_INTEGER)&FileOffset,
                              Length,
                              &Iosb );

                //
                //  Recover the state of any partial pages we protected above before retrying.
                //

                if (ProtectedPages) {
                    LfsRestoreRestOfDirtyPage( Lfcb, MapPageBcb );
                    ProtectedPages = FALSE;
                }

                if (!NT_SUCCESS( Iosb.Status )) {

                    LONG BytesRemaining = (LONG) Length;

                    //
                    //  If we get an error then try each individual page.
                    //

                    while (BytesRemaining > 0) {

                        //
                        //  Remember the range we are flushing and find the second half of a page
                        //  if necessary.
                        //

                        ASSERT( Length >= Lfcb->LogPageSize );

                        Lfcb->UserWriteData->FileOffset = FileOffset;
                        Lfcb->UserWriteData->Length = (ULONG)Lfcb->LogPageSize;

                        //
                        //  We are flushing log records.  If the current request does not end on
                        //  a system page boundary then check if there is another page in
                        //  memory that we are concerned with.
                        //

                        if ( Lfcb->LogPageSize != PAGE_SIZE ) {
                            ProtectedPages = LfsProtectRestOfDirtyPage( Lfcb, FileOffset, Length, &MapPageBcb );
                        }

                        CcFlushCache( Lfcb->FileObject->SectionObjectPointer,
                                      (PLARGE_INTEGER)&FileOffset,
                                      (ULONG)Lfcb->LogPageSize,
                                      &Iosb );

                        //
                        //  Recover the state of any partial page first.
                        //

                        if (ProtectedPages) {
                            LfsRestoreRestOfDirtyPage( Lfcb, MapPageBcb );
                            ProtectedPages = FALSE;
                        }

                        if (!NT_SUCCESS( Iosb.Status )) {

                            if (NT_SUCCESS( FailedFlushStatus )) {
                                FailedFlushStatus = Iosb.Status;
                                FailedFlushOffset = FileOffset;
#ifdef LFS_CLUSTER_CHECK
                                //
                                //  Remember this to figure out naggin cluster problems.
                                //

                                if (FailedFlushStatus == STATUS_DEVICE_OFF_LINE) {

                                    SetFlag( Lfcb->Flags, LFCB_DEVICE_OFFLINE_SEEN );
                                }

                                //
                                //  Remember all errors.
                                //

                                SetFlag( Lfcb->Flags, LFCB_FLUSH_FAILED );
#endif
                            }
#ifdef LFS_CLUSTER_CHECK
                        } else if (Iosb.Information != 0) {

                            //
                            //  Once OFFLINE, always OFFLINE.
                            //

                            ASSERT( !FlagOn( Lfcb->Flags, LFCB_DEVICE_OFFLINE_SEEN ));

                            //
                            //  Catch the first write after a failed IO.
                            //

                            if (LfsTestBreakOnAnyError &&
                                FlagOn( Lfcb->Flags, LFCB_FLUSH_FAILED )) {

                                ASSERT( !LfsTestBreakOnAnyError ||
                                        !FlagOn( Lfcb->Flags, LFCB_FLUSH_FAILED ));

                                ClearFlag( Lfcb->Flags, LFCB_FLUSH_FAILED );
                            }
#endif
                        }
                        BytesRemaining -= (LONG)Lfcb->LogPageSize;
                        FileOffset = FileOffset + Lfcb->LogPageSize;
                    }
                }
            }

            //
            //  Reacquire the Lfcb, remembering that we have it.
            //

            if (!UseTailCopy) {

                LfsAcquireLfcb( Lfcb );
            }

            //
            //  Update the last flushed Lsn value if this isn't a
            //  restart write.
            //

            if (!LfsRestart) {

                if (ValidLastLsn) {

                    Lfcb->LastFlushedLsn = LastLsn;
                }

                //
                //  Remember the Lsn we assigned to this restart area.
                //

            } else {

                Lfcb->LastFlushedRestartLsn = LastLsn;

                //
                //  Clear any neccessary flags on a successful operation.
                //

                if (NT_SUCCESS( FailedFlushStatus )) {

                    ClearFlag( Lfcb->Flags, NewLfcbFlags );
                    NewLfcbFlags = 0;
                }

                //
                //  If this is the first write of a restart area and we have
                //  updated the LogOpenCount then update the field in the Lfcb.
                //

                if (NT_SUCCESS( Iosb.Status ) &&
                    (Lfcb->CurrentOpenLogCount != ((PLFS_RESTART_AREA) FirstLbcb->PageHeader)->RestartOpenLogCount)) {

                    Lfcb->CurrentOpenLogCount = ((PLFS_RESTART_AREA) FirstLbcb->PageHeader)->RestartOpenLogCount;
                }
            }

            //
            //  Walk through all the Lbcb's we flushed, deallocating the Lbcbs.
            //

            if (!UseTailCopy) {

                PLBCB TempLbcb;

                for (ThisLbcb = FirstLbcb; IoBlocks > 0; IoBlocks -= 1) {

                    //
                    //  Remember the next entry on the list.
                    //

                    TempLbcb = CONTAINING_RECORD( ThisLbcb->WorkqueLinks.Flink,
                                                  LBCB,
                                                  WorkqueLinks );

                    //
                    //  Remove it from the LbcbWorkque queue.
                    //

                    RemoveEntryList( &ThisLbcb->WorkqueLinks );

                    //
                    //  Deallocate the structure.
                    //

                    LfsDeallocateLbcb( Lfcb, ThisLbcb );
                    ThisLbcb = TempLbcb;
                }
            }

            //
            //  If we flushed the Lbcb we were interested in, we are done.
            //  We will signal all waiting threads regardless
            //

            KeSetEvent( &Lfcb->Sync->Event, 0, FALSE );

            //
            //  Remember the starting Lbcb for the next I/O.
            //

            FirstLbcb = NextLbcb;
        }

    } finally {

        DebugUnwind( LfsFlushLfcb );

        ASSERT( !ProtectedPages );

        //
        //  Show that there is no Io in progress.
        //

        Lfcb->LfsIoState = LfsNoIoInProgress;
        Lfcb->LfsIoThread = 0;

        //
        //  Make sure we didn't leave any pages pinned.
        //

        if (PageBcb != NULL) {

            CcUnpinData( PageBcb );
        }

        DebugTrace( -1, Dbg, "LfsFlushLfcb:  Exit\n", 0 );
    }

    //
    //  If the Io failed at some point, we log the error in the eventlog if possible
    //  and note it in the lfs restart area
    //

    if (!NT_SUCCESS( FailedFlushStatus )) {

        PIO_ERROR_LOG_PACKET ErrorLogEntry;

        //
        //  Note failure in restart area
        //

        Lfcb->RestartArea->LastFailedFlushOffset = FailedFlushOffset;
        Lfcb->RestartArea->LastFailedFlushStatus = FailedFlushStatus;
        Lfcb->RestartArea->LastFailedFlushLsn = Lfcb->LastFlushedLsn;

        if (Lfcb->ErrorLogPacket != NULL) {
            ErrorLogEntry = Lfcb->ErrorLogPacket;
            Lfcb->ErrorLogPacket = NULL;
        } else {
            ErrorLogEntry = IoAllocateErrorLogEntry( Lfcb->FileObject->DeviceObject, ERROR_LOG_MAXIMUM_SIZE );
        }

        if (ErrorLogEntry != NULL) {
            ErrorLogEntry->EventCategory = ELF_CATEGORY_DISK;
            ErrorLogEntry->ErrorCode = IO_WARNING_LOG_FLUSH_FAILED;
            ErrorLogEntry->FinalStatus = FailedFlushStatus;

            IoWriteErrorLogEntry( ErrorLogEntry );
        }
    }

    //
    //  Try to preallocate another log packet if we don't have one already
    //

    if (Lfcb->ErrorLogPacket == NULL) {
        Lfcb->ErrorLogPacket = IoAllocateErrorLogEntry( Lfcb->FileObject->DeviceObject, ERROR_LOG_MAXIMUM_SIZE );
    }

    return;
}


BOOLEAN
LfsReadRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN BOOLEAN FirstRestart,
    OUT PLONGLONG RestartPageOffset,
    OUT PLFS_RESTART_PAGE_HEADER *RestartPage,
    OUT PBCB *RestartPageBcb,
    OUT PBOOLEAN ChkdskWasRun,
    OUT PBOOLEAN ValidPage,
    OUT PBOOLEAN UninitializedFile,
    OUT PBOOLEAN LogPacked,
    OUT PLSN LastLsn
    )

/*++

Routine Description:

    This routine will walk through 512 blocks of the file looking for a
    valid restart page header.  It will stop the first time we find
    a valid page header.

Arguments:

    Lfcb - This is the Lfcb for the log file.

    FileSize - Size in bytes for the log file.

    FirstRestart - Indicates if we are looking for the first valid
        restart area.

    RestartPageOffset - This is the location to store the offset in the
        file where the log page was found.

    RestartPage - This is the location to store the address of the
        pinned restart page.

    RestartPageBcb - This is the location to store the Bcb for this
        cache pin operation.

    ChkdskWasRun - Address to store whether checkdisk was run on this volume.

    ValidPage - Address to store whether there was valid data on this page.

    UninitializedFile - Address to store whether this is an uninitialized
        log file.  Return value only valid if for the first restart area.

    LogPacked - Address to store whether the log file is packed.

    LastLsn - Address to store the last Lsn for this restart page.  It will be the
        chkdsk value if checkdisk was run.  Otherwise it is the LastFlushedLsn
        for this restart page.

Return Value:

    BOOLEAN - TRUE if a restart area was found, FALSE otherwise.

--*/

{
    ULONG FileOffsetIncrement;
    LONGLONG FileOffset;

    PLFS_RESTART_AREA RestartArea;

    NTSTATUS Status;

    PLFS_RESTART_PAGE_HEADER ThisPage;
    PBCB ThisPageBcb = NULL;

    BOOLEAN FoundRestart = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadRestart:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb   -> %08lx\n", Lfcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    *UninitializedFile = TRUE;
    *ValidPage = FALSE;
    *ChkdskWasRun = FALSE;
    *LogPacked = FALSE;

    try {

        //
        //  Determine which restart area we are looking for.
        //

        if (FirstRestart) {

            FileOffset = 0;
            FileOffsetIncrement = SEQUENCE_NUMBER_STRIDE;

        } else {

            FileOffset = SEQUENCE_NUMBER_STRIDE;
            FileOffsetIncrement = 0;
        }

        //
        //  We loop up to 16 pages  until we succeed, pin a log record page
        //  or exhaust the number of possible tries.
        //

        while ( FileOffset < min( FileSize, 16 * PAGE_SIZE )) {

            ULONG Signature;
            BOOLEAN UsaError;

            if (ThisPageBcb != NULL) {

                CcUnpinData( ThisPageBcb );
                ThisPageBcb = NULL;
            }

            //
            //  Attempt to pin a page header at the current offset.
            //

            Status = LfsPinOrMapData( Lfcb,
                                      FileOffset,
                                      SEQUENCE_NUMBER_STRIDE,
                                      TRUE,
                                      TRUE,
                                      TRUE,
                                      &UsaError,
                                      (PVOID *)&ThisPage,
                                      &ThisPageBcb );

            //
            //
            //  If we succeeded, we look at the 4 byte signature.
            //

            if (NT_SUCCESS( Status )) {

                Signature = *((PULONG) &ThisPage->MultiSectorHeader.Signature);

                //
                //  If the signature is a log record page, we will exit.
                //

                if (Signature == LFS_SIGNATURE_RECORD_PAGE_ULONG) {

                    *UninitializedFile = FALSE;
                    break;
                }

                //
                //  Continue analyzing the page if the signature is chkdsk or
                //  a restart page.
                //

                if (Signature == LFS_SIGNATURE_MODIFIED_ULONG
                    || Signature == LFS_SIGNATURE_RESTART_PAGE_ULONG) {

                    *UninitializedFile = FALSE;

                    //
                    //  Remember where we found this page.
                    //

                    *RestartPageOffset = FileOffset;

                    //
                    //  Let's check the restart area if this is a valid page.
                    //

                    if (LfsIsRestartPageHeaderValid( FileOffset,
                                                     ThisPage,
                                                     LogPacked )

                        && LfsIsRestartAreaValid( ThisPage, *LogPacked )) {

                        //
                        //  We have a valid restart page header and restart area.
                        //  If chkdsk was run or we have no clients then
                        //  we have no more checking to do.
                        //

                        RestartArea = Add2Ptr( ThisPage,
                                               ThisPage->RestartOffset,
                                               PLFS_RESTART_AREA );

                        if (Signature == LFS_SIGNATURE_RESTART_PAGE_ULONG
                            && RestartArea->ClientInUseList != LFS_NO_CLIENT) {

                            //
                            //  Pin the entire restart area if we didn't have an earlier
                            //

                            CcUnpinData( ThisPageBcb );
                            ThisPageBcb = NULL;

                            Status = LfsPinOrMapData( Lfcb,
                                                      FileOffset,
                                                      ThisPage->SystemPageSize,
                                                      TRUE,
                                                      TRUE,
                                                      TRUE,
                                                      &UsaError,
                                                      (PVOID *)&ThisPage,
                                                      &ThisPageBcb );

                            if (NT_SUCCESS( Status )
                                && LfsIsClientAreaValid( ThisPage, *LogPacked, UsaError )) {

                                *ValidPage = TRUE;

                                RestartArea = Add2Ptr( ThisPage,
                                                       ThisPage->RestartOffset,
                                                       PLFS_RESTART_AREA );
                            }

                        } else {

                            *ValidPage = TRUE;
                        }
                    }

                    //
                    //  If chkdsk was run then update the caller's values and return.
                    //

                    if (Signature == LFS_SIGNATURE_MODIFIED_ULONG) {

                        *ChkdskWasRun = TRUE;

                        *LastLsn = ThisPage->ChkDskLsn;

                        FoundRestart = TRUE;

                        *RestartPageBcb = ThisPageBcb;
                        *RestartPage = ThisPage;

                        ThisPageBcb = NULL;
                        break;
                    }

                    //
                    //  If we have a valid page then copy the values we need from it.
                    //

                    if (*ValidPage) {

                        *LastLsn = RestartArea->CurrentLsn;

                        FoundRestart = TRUE;

                        *RestartPageBcb = ThisPageBcb;
                        *RestartPage = ThisPage;

                        ThisPageBcb = NULL;
                        break;
                    }

                    //
                    //  Remember if the signature does not indicate uninitialized file.
                    //

                } else if (Signature != LFS_SIGNATURE_UNINITIALIZED_ULONG) {

                    *UninitializedFile = FALSE;
                }
            }

            //
            //  Move to the next possible log page.
            //

            FileOffset = FileOffset << 1;

            (ULONG)FileOffset += FileOffsetIncrement;

            FileOffsetIncrement = 0;
        }

    } finally {

        DebugUnwind( LfsReadRestart );

        //
        //  Unpin the log pages if pinned.
        //

        if (ThisPageBcb != NULL) {

            CcUnpinData( ThisPageBcb );
        }

        DebugTrace(  0, Dbg, "RestartPageAddress (Low)  -> %08lx\n", RestartPageAddress->LowPart );
        DebugTrace(  0, Dbg, "RestartPageAddress (High) -> %08lx\n", RestartPageAddress->HighPart );
        DebugTrace(  0, Dbg, "FirstRestartPage          -> %08lx\n", *FirstRestartPage );
        DebugTrace( -1, Dbg, "LfsReadRestart:  Exit\n", 0 );
    }

    return FoundRestart;
}


//
//  Local support routine
//

BOOLEAN
LfsIsRestartPageHeaderValid (
    IN LONGLONG FileOffset,
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    OUT PBOOLEAN LogPacked
    )

/*++

Routine Description:

    This routine is called to verify that the candidate for a restart page
    has no corrupt values in the page header.  It verifies that the restart and
    system page size have only one bit set and are at least the value of
    the update sequence array stride.

Arguments:

    FileOffset - This is the offset in the file of the restart area to examine.
        If this offset is not 0, then it should match the system page size.

    PageHeader - This is the page to examine.

    LogPacked - Address to store whether the log file is packed.

Return Value:

    BOOLEAN - TRUE if there is no corruption in the pool header values.
              FALSE otherwise.

--*/

{
    ULONG SystemPage;
    ULONG LogPageSize;
    ULONG Mask;
    ULONG BitCount;

    USHORT EndOfUsa;

    PAGED_CODE();

    *LogPacked = FALSE;

    //
    //  Copy the values from the page header into the local variables.
    //

    SystemPage = PageHeader->SystemPageSize;
    LogPageSize = PageHeader->LogPageSize;

    //
    //  The system page and log page sizes must be greater or equal to the
    //  update sequence stride.
    //

    if (SystemPage < SEQUENCE_NUMBER_STRIDE
        || LogPageSize < SEQUENCE_NUMBER_STRIDE) {

        return FALSE;
    }

    //
    //  Now we check that the Log page and system page are multiples of two.
    //  They should only have a single bit set.
    //

    for (Mask = 1, BitCount = 0; Mask != 0; Mask = Mask << 1) {

        if (Mask & LogPageSize) {

            BitCount += 1;
        }
    }

    //
    //  If the bit count isn't 1, return false.
    //

    if (BitCount != 1) {

        return FALSE;
    }

    //
    //  Now do the system page size.
    //

    for (Mask = 1, BitCount = 0; Mask != 0; Mask = Mask << 1) {

        if (Mask & SystemPage) {

            BitCount += 1;
        }
    }

    //
    //  If the bit count isn't 1, return false.
    //

    if (BitCount != 1) {

        return FALSE;
    }

    //
    //  Check that if the file offset isn't 0, it is the system page size.
    //

    if (( FileOffset != 0 )
        && ((ULONG)FileOffset != SystemPage)) {

        return FALSE;
    }

    //
    //  We only support major version numbers 0.x and 1.x
    //
    //  Version number beyond 1.0 mean the log file is packed.
    //

    if (PageHeader->MajorVersion != 0
        && PageHeader->MajorVersion != 1) {

        return FALSE;
    }

    //
    //  Check that the restart area offset is within the system page and that
    //  the restart length field will fit within the system page size.
    //

    if (QuadAlign( PageHeader->RestartOffset ) != PageHeader->RestartOffset
        || PageHeader->RestartOffset > (USHORT) PageHeader->SystemPageSize) {

        return FALSE;
    }

    //
    //  Check that the restart offset will lie beyond the Usa Array for this page.
    //

    EndOfUsa = (USHORT) (UpdateSequenceArraySize( PageHeader->SystemPageSize )
                         * sizeof( UPDATE_SEQUENCE_NUMBER ));

    EndOfUsa += PageHeader->MultiSectorHeader.UpdateSequenceArrayOffset;

    if (PageHeader->RestartOffset < EndOfUsa) {

        return FALSE;
    }

    //
    //  Check if the log pages are packed.
    //

    if (PageHeader->MajorVersion == 1
        && PageHeader->MinorVersion > 0) {

        *LogPacked = TRUE;
    }

    //
    //  Otherwise the page header is valid.
    //

    return TRUE;
}


//
//  Local support routine
//

BOOLEAN
LfsIsRestartAreaValid (
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    IN BOOLEAN LogPacked
    )

/*++

Routine Description:

    This routine is called to verify that the restart area attached to the
    log page header is valid.  The restart values must be contained within
    the first Usa stride of the file.  This is so we can restart successfully
    after chkdsk.

Arguments:

    PageHeader - This is the page to examine.

    LogPacked - Indicates if the log file is packed.

Return Value:

    BOOLEAN - TRUE if there is no corruption in the restart area values.
              FALSE otherwise.

--*/

{
    PLFS_RESTART_AREA RestartArea;
    ULONG OffsetInRestart;
    ULONG SeqNumberBits;

    LONGLONG FileSize;

    PAGED_CODE();

    //
    //  The basic part of the restart area must fit into the first stride of
    //  the page.  This will allow chkdsk to work even if there are Usa errors.
    //

    OffsetInRestart = FIELD_OFFSET( LFS_RESTART_AREA, FileSize );

    if ((PageHeader->RestartOffset + OffsetInRestart) > FIRST_STRIDE) {

        return FALSE;
    }

    RestartArea = Add2Ptr( PageHeader, PageHeader->RestartOffset, PLFS_RESTART_AREA );

    //
    //  Everything in the restart area except the actual client array must also
    //  be in the first stride.  If the structure is packed, then we can use
    //  a field in the restart area for the client offset.
    //

    if (LogPacked) {

        OffsetInRestart = RestartArea->ClientArrayOffset;

    } else {

        //
        //  We shouldn't see any of the older disks now.
        //

        OffsetInRestart = FIELD_OFFSET( LFS_OLD_RESTART_AREA, LogClientArray );
    }

    if (QuadAlign( OffsetInRestart ) != OffsetInRestart
        || (PageHeader->RestartOffset + OffsetInRestart) > FIRST_STRIDE) {

        return FALSE;
    }

    //
    //  The full size of the restart area must fit in the system page specified by
    //  the page header.  We compute the size of the restart area by calculating
    //  the space needed by all clients.  We also check the given size of the
    //  restart area.
    //

    OffsetInRestart += (RestartArea->LogClients * sizeof( LFS_CLIENT_RECORD ));

    if (OffsetInRestart > PageHeader->SystemPageSize ) {

        return FALSE;
    }

    //
    //  If the log is packed, then check the restart length field and whether
    //  the entire restart area is contained in that length.
    //

    if (LogPacked
        && ((ULONG) (PageHeader->RestartOffset + RestartArea->RestartAreaLength) > PageHeader->SystemPageSize
            || OffsetInRestart > RestartArea->RestartAreaLength)) {

        return FALSE;
    }

    //
    //  As a final check make sure that the in use list and the free list are either
    //  empty or point to a valid client.
    //

    if ((RestartArea->ClientFreeList != LFS_NO_CLIENT
         && RestartArea->ClientFreeList >= RestartArea->LogClients)

        || (RestartArea->ClientInUseList != LFS_NO_CLIENT
            && RestartArea->ClientInUseList >= RestartArea->LogClients)) {

        return FALSE;
    }

    //
    //  Make sure the sequence number bits match the log file size.
    //

    FileSize = RestartArea->FileSize;

    for (SeqNumberBits = 0;
        ( FileSize != 0 );
        SeqNumberBits += 1,
        FileSize = ((ULONGLONG)(FileSize)) >> 1 ) {
    }

    SeqNumberBits = (sizeof( LSN ) * 8) + 3 - SeqNumberBits;

    if (SeqNumberBits != RestartArea->SeqNumberBits) {

        return FALSE;
    }

    //
    //  We will check the fields that apply only to a packed log file.
    //

    if (LogPacked) {

        //
        //  The log page data offset and record header length must be
        //  quad-aligned.
        //

        if ((QuadAlign( RestartArea->LogPageDataOffset ) != RestartArea->LogPageDataOffset ) ||
            (QuadAlign( RestartArea->RecordHeaderLength ) != RestartArea->RecordHeaderLength )) {

            return FALSE;
        }
    }

    return TRUE;
}


//
//  Local support routine
//

BOOLEAN
LfsIsClientAreaValid (
    IN PLFS_RESTART_PAGE_HEADER PageHeader,
    IN BOOLEAN LogPacked,
    IN BOOLEAN UsaError
    )

/*++

Routine Description:

    This routine is called to verify that the client array is valid.  We test
    if the client lists are correctly chained.  If the entire restart area is
    within the first Usa stride, we will ignore any Usa errors.

Arguments:

    PageHeader - This is the page to examine.

    LogPacked - Indicates if the log file is packed.

    UsaError - There was a Usa error in reading the full page.

Return Value:

    BOOLEAN - TRUE if there is no corruption in client array values.
              FALSE otherwise.

--*/

{
    PLFS_RESTART_AREA RestartArea;
    USHORT ThisClientIndex;
    USHORT ClientCount;

    PLFS_CLIENT_RECORD ClientArray;
    PLFS_CLIENT_RECORD ThisClient;

    ULONG LoopCount;

    PAGED_CODE();

    RestartArea = Add2Ptr( PageHeader, PageHeader->RestartOffset, PLFS_RESTART_AREA );

    //
    //  If there was a Usa error and the restart area isn't contained in the
    //  first Usa stride, then we have an error.
    //

    if (UsaError
        && (RestartArea->RestartAreaLength + PageHeader->RestartOffset) > FIRST_STRIDE) {

        return FALSE;
    }

    //
    //  Find the start of the client array.
    //

    if (LogPacked) {

        ClientArray = Add2Ptr( RestartArea,
                               RestartArea->ClientArrayOffset,
                               PLFS_CLIENT_RECORD );

    } else {

        //
        //  Handle the case where the offset of the client array is fixed.
        //

        ClientArray = Add2Ptr( RestartArea,
                               FIELD_OFFSET( LFS_OLD_RESTART_AREA,
                                             LogClientArray ),
                               PLFS_CLIENT_RECORD );
    }

    //
    //  Start with the free list.  Check that all the clients are valid and
    //  that there isn't a cycle.  Do the in-use list on the second pass.
    //

    ThisClientIndex = RestartArea->ClientFreeList;

    LoopCount = 2;

    do {

        BOOLEAN FirstClient;

        FirstClient = TRUE;

        ClientCount = RestartArea->LogClients;

        while (ThisClientIndex != LFS_NO_CLIENT) {

            //
            //  If the client count is zero then we must have hit a loop.
            //  If the client index is greater or equal to the log client
            //  count then the list is corrupt.
            //

            if (ClientCount == 0
                || ThisClientIndex >= RestartArea->LogClients) {

                return FALSE;
            }

            ClientCount -= 1;

            ThisClient = ClientArray + ThisClientIndex;
            ThisClientIndex = ThisClient->NextClient;

            //
            //  If this is the first client, then the previous value
            //  should indicate no client.
            //

            if (FirstClient) {

                FirstClient = FALSE;

                if (ThisClient->PrevClient != LFS_NO_CLIENT) {

                    return FALSE;
                }
            }
        }

        ThisClientIndex = RestartArea->ClientInUseList;

    } while (--LoopCount);

    //
    //  The client list is valid.
    //

    return TRUE;
}


//
//  Local support routine.
//

VOID
LfsFindFirstIo (
    IN PLFCB Lfcb,
    IN PLBCB TargetLbcb,
    IN PLBCB FirstLbcb,
    OUT PLBCB *NextLbcb,
    OUT PLONGLONG FileOffset,
    OUT PBOOLEAN ContainsLastEntry,
    OUT PBOOLEAN LfsRestart,
    OUT PBOOLEAN UseTailCopy,
    OUT PULONG IoBlocks
    )

/*++

Routine Description:

    This routine walks through the linked Lbcb's for a Lfcb and groups
    as many of them as can be grouped into a single I/O transfer.
    It updates pointers to indicate the file offset and length of the
    transfer, whether the I/O includes a particular Lbcb, whether the
    transfer is a restart area or a log record page and the number of
    Lbcb's included in the transfer.  We only flush a single log page
    if we are passing through the file for the first time.

Arguments:

    Lfcb - This is the file control block for the log file.

    TargetLbcb - This is the Lbcb that the caller wants to have included in
        the transfer.

    FirstLbcb - This is the first Lbcb to look at in the list.

    NextLbcb - This is the Lbcb to look at first on the next call to this
        routine.

    FileOffset - Supplies the address where we store the offset in the
        log file of this transfer.

    ContainsLastEntry - Supplies the address where we store whether this
        I/O includes the 'LastEntry' Lbcb.

    LfsRestart - Supplies the address where we store whether this transfer
        is a Lfs restart area.

    UseTailCopy - Supplies the address where we store whether we should
        use of page for a copy of the end of the log file.

    IoBlocks - Supplies the address where we store the number of Lbcb's
        for this transfer.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindFirstIo:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );

    //
    //  Initialize the file offset, length and io blocks values.
    //  Also assume the last entry is not contained here.
    //  Also assume we have no next Lbcb.
    //

    *FileOffset = FirstLbcb->FileOffset;
    *IoBlocks = 1;

    *LfsRestart = FALSE;
    *UseTailCopy = FALSE;

    *NextLbcb = NULL;

    //
    //  Check if we have found the desired Lbcb.  We reject the match
    //  if the Lbcb indicates that we should flush the copy first.
    //

    if (FirstLbcb == TargetLbcb
        && !FlagOn( TargetLbcb->LbcbFlags, LBCB_FLUSH_COPY )) {

        *ContainsLastEntry = TRUE;

    } else {

        *ContainsLastEntry = FALSE;
    }

    //
    //  Check if this is a restart block or if we are passing through the log
    //  file for the first time or if this Lbcb is still in the active queue.
    //  If not, then group as many of the Lbcb's as can be part of a single Io.
    //

    if (LfsLbcbIsRestart( FirstLbcb )) {

        *LfsRestart = TRUE;

    } else if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
               && (FlagOn( FirstLbcb->LbcbFlags, LBCB_FLUSH_COPY | LBCB_ON_ACTIVE_QUEUE ))) {

        *UseTailCopy = TRUE;

        //
        //  If we haven't found the last entry then we want to resume from
        //  this same Lbcb if we flushed a copy otherwise we will want to
        //  go to the next Lbcb.
        //

        if (FlagOn( FirstLbcb->LbcbFlags, LBCB_FLUSH_COPY )) {

            *NextLbcb = FirstLbcb;
            ClearFlag( FirstLbcb->LbcbFlags, LBCB_FLUSH_COPY );
        }

    } else if (FlagOn( Lfcb->Flags, LFCB_MULTIPLE_PAGE_IO )) {

        PLBCB EndOfPageLbcb = NULL;
        ULONG EndOfPageIoBlocks;

        //
        //  We loop until there are no more blocks or they aren't
        //  contiguous in the file or we have found an entry on the
        //  active queue or we found an entry where we want to explicitly
        //  flush a copy first.
        //

        while ((FirstLbcb->WorkqueLinks.Flink != &Lfcb->LbcbWorkque) &&
               !FlagOn( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE )) {

            LONGLONG ExpectedFileOffset;
            PLBCB TempLbcb;

            //
            //  Get the next Lbcb.
            //

            TempLbcb = CONTAINING_RECORD( FirstLbcb->WorkqueLinks.Flink,
                                          LBCB,
                                          WorkqueLinks );

            //
            //  Break out of the loop if the file offset is not the
            //  expected value or the next entry is on the active queue.
            //

            ExpectedFileOffset = FirstLbcb->FileOffset + Lfcb->LogPageSize;

            //
            //  We want to stop at this point if the next Lbcb is not
            //  the expected offset or we are packing the log file and
            //  the next Lbcb is on the active queue or we want to write
            //  a copy of the data before this page goes out.
            //

            if ((TempLbcb->FileOffset != ExpectedFileOffset) ||
                (FlagOn( Lfcb->Flags, LFCB_PACK_LOG ) &&
                 FlagOn( TempLbcb->LbcbFlags, LBCB_FLUSH_COPY | LBCB_ON_ACTIVE_QUEUE))) {

                //
                //  Use the Lbcb at the end of a page if possible.
                //

                if (EndOfPageLbcb != NULL) {

                    FirstLbcb = EndOfPageLbcb;
                    *IoBlocks = EndOfPageIoBlocks;
                }

                break;
            }

            //
            //  We can add this to our I/o.  Increment the Io blocks
            //  and length of the transfer.  Also check if this entry
            //  is the Last Entry specified by the caller.
            //

            *IoBlocks += 1;

            if (TempLbcb == TargetLbcb ) {

                *ContainsLastEntry = TRUE;
            }

            //
            //  Check if this Lbcb is at the end of a system page.
            //

            if (*ContainsLastEntry &&
                (PAGE_SIZE != (ULONG) Lfcb->LogPageSize) &&
                !FlagOn( ((ULONG) TempLbcb->FileOffset + (ULONG) Lfcb->LogPageSize),
                         PAGE_SIZE - 1 )) {

                EndOfPageLbcb = TempLbcb;
                EndOfPageIoBlocks = *IoBlocks;
            }

            //
            //  Use this entry as the current entry.
            //

            FirstLbcb = TempLbcb;
        }
    }

    //
    //  If the current Lbcb is on the active queue and we aren't using
    //  a tail copy, then remove this from the active queue.  If this
    //  not our target and removing this will cause us to swallow up
    //  part of our reserved quota then back up one Lbcb.
    //

    if (!(*UseTailCopy) && FlagOn( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE )) {

        if (Lfcb->CurrentAvailable < Lfcb->TotalUndoCommitment) {

            //
            //  Move back one file record.
            //

            *IoBlocks -= 1;
            *NextLbcb = FirstLbcb;

            //
            //  Otherwise remove it from the active queue.
            //

        } else {

            ClearFlag( FirstLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );
            RemoveEntryList( &FirstLbcb->ActiveLinks );
        }
    }

    //
    //  If we haven't found the Lbcb to restart from we will just use the
    //  next Lbcb after the last one found.
    //

    if (*NextLbcb == NULL) {

        *NextLbcb = CONTAINING_RECORD( FirstLbcb->WorkqueLinks.Flink,
                                       LBCB,
                                       WorkqueLinks );
    }

    DebugTrace(  0, Dbg, "File Offset (Low)     -> %08lx\n", FileOffset->LowPart );
    DebugTrace(  0, Dbg, "File Offset (High)    -> %08lx\n", FileOffset->HighPart );
    DebugTrace(  0, Dbg, "Contains Last Entry   -> %08x\n", *ContainsLastEntry );
    DebugTrace(  0, Dbg, "LfsRestart            -> %08x\n", *LfsRestart );
    DebugTrace(  0, Dbg, "IoBlocks              -> %08lx\n", *IoBlocks );
    DebugTrace( -1, Dbg, "LfsFindFirstIo:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbvar.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    wsbvar.cpp

Abstract:

    This class is a wrapper for the VARIANT structure, providing
    conversion and cleanup automatically. Current supported types
    for conversion are OLECHAR * (BSTR), IUnknown / IDispatch, and
    GUID. GUIDs are represented internally as strings.

Author:

    Rohde Wakefield          [rohde]   21-Jan-1997

Revision History:

--*/


#include "stdafx.h"
#include "wsb.h"


//
// OLECHAR (wide-character) methods
//

CWsbVariant::CWsbVariant ( const OLECHAR * string )
{
    Init ( );

    if ( 0 != ( bstrVal = WsbAllocString ( string ) ) )
        vt = VT_BSTR;
}

CWsbVariant & CWsbVariant::operator = ( const OLECHAR * string )
{
    Clear ( );

    if ( 0 != ( bstrVal = WsbAllocString ( string ) ) )
        vt = VT_BSTR;

    return ( *this );
}

CWsbVariant::operator OLECHAR * ( )
{
    if ( VT_BSTR != vt )
        VariantChangeType ( this, this, 0, VT_BSTR );

    return ( VT_BSTR == vt ) ? bstrVal : 0;
}


//
// COM Interface methods
//

CWsbVariant::CWsbVariant ( IUnknown * pUnk )
{
    Init ( );

    if ( 0 != pUnk ) {

        punkVal = pUnk;
        punkVal->AddRef ( );
        vt = VT_UNKNOWN;

    }
}

CWsbVariant::CWsbVariant ( IDispatch * pDisp )
{
    Init ( );

    if ( 0 != pDisp ) {

        pdispVal = pDisp;
        pdispVal->AddRef ( );
        vt = VT_DISPATCH;

    }
}

CWsbVariant::operator IUnknown * ( )
{
    //
    // Ok to return IDispatch as IUnknown since it
    // derives from IUnknown
    //

    if ( IsInterface ( ) )
        return punkVal;

    return 0;
}

CWsbVariant::operator IDispatch * ( )
{
    if ( IsDispatch ( ) ) {

        return pdispVal;

    }

    if ( IsInterface ( ) ) {

        IDispatch * pDisp;
        if ( SUCCEEDED ( punkVal->QueryInterface ( IID_IDispatch, (void**)&pDisp ) ) ) {

            punkVal->Release ( );
            pdispVal = pDisp;
            vt = VT_DISPATCH;

            return ( pdispVal );
        }

    }

    return 0;
}

CWsbVariant & CWsbVariant::operator = ( IUnknown * pUnk )
{
    Clear ( );

    vt = VT_UNKNOWN;

    punkVal = pUnk;
    punkVal->AddRef ( );

    return ( *this );
}

CWsbVariant & CWsbVariant::operator = ( IDispatch * pDisp )
{
    Clear ( );

    vt = VT_DISPATCH;

    pdispVal = pDisp;
    pdispVal->AddRef ( );

    return ( *this );
}


//
// Methods to work with GUIDs
//

CWsbVariant::CWsbVariant ( REFGUID rguid )
{
    Init ( );

    *this = rguid;
}

CWsbVariant & CWsbVariant::operator = ( REFGUID rguid )
{
    Clear ( );

    if ( 0 != ( bstrVal = WsbAllocStringLen( 0, WSB_GUID_STRING_SIZE ) ) ) {

        if ( SUCCEEDED ( WsbStringFromGuid ( rguid, bstrVal ) ) ) {

            vt = VT_BSTR;

        }

    }

    return ( *this );
}

CWsbVariant::operator GUID ()
{
    
    GUID guid;

    WsbGuidFromString ( (const OLECHAR *)*this, &guid ); 

    return guid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\lfsdata.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LfsData.c

Abstract:

    This module declares the global data used by the Logging File Service.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

//
//  The global Lfs data record
//

LFS_DATA LfsData;

//
//  Various large integer constants.
//

LARGE_INTEGER LfsLi0 = {0x00000000, 0x00000000};
LARGE_INTEGER LfsLi1 = {0x00000001, 0x00000000};

//
//  The following Lsn will never occur in a file, it is used to indicate
//  a non-lsn.
//

LSN LfsZeroLsn = {0x00000000, 0x00000000};

#ifdef LFSDBG

LONG LfsDebugTraceLevel = 0x0000000F;
LONG LfsDebugTraceIndent = 0;

#endif // LFSDBG

#ifdef LFS_CLUSTER_CHECK

//
//  Check for gaps in the log.
//

BOOLEAN LfsTestBreakOnAnyError = TRUE;
BOOLEAN LfsTestCheckLbcb = TRUE;
#endif


LONG
LfsExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It indicates that we should handle
    the exception or bug check the system.

Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

#ifdef NTFS_RESTART
    ASSERT( (ExceptionCode != STATUS_DISK_CORRUPT_ERROR) &&
            (ExceptionCode != STATUS_FILE_CORRUPT_ERROR) );
#endif

    //if (ExceptionCode != STATUS_LOG_FILE_FULL) {
    //
    //    DbgPrint("Status not LOGFILE FULL, ExceptionPointers = %08lx\n", ExceptionPointer);
    //    DbgBreakPoint();
    //}

    if (!FsRtlIsNtstatusExpected( ExceptionCode )) {

        return EXCEPTION_CONTINUE_SEARCH;

    } else {

        return EXCEPTION_EXECUTE_HANDLER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\lbcbsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LbcbSup.c

Abstract:

    This module provides support for manipulating log buffer control blocks.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LBCB_SUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsFlushLbcb)
#pragma alloc_text(PAGE, LfsFlushToLsnPriv)
#pragma alloc_text(PAGE, LfsGetLbcb)
#endif


VOID
LfsFlushLbcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    )

/*++

Routine Description:

    This routine is called to make sure the data within an Lbcb makes it out
    to disk.  The Lbcb must either already be in the workque or it must be
    a restart Lbcb.

Arguments:

    Lfcb - This is the file control block for the log file.

    Lbcb - This is the Lbcb to flush.

Return Value:

    None.

--*/

{
    LSN LastLsn;
    PLSN FlushedLsn;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFlushLbcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb      -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lbcb      -> %08lx\n", Lbcb );

    LastLsn = Lbcb->LastEndLsn;

    //
    //  If this is a restart area we use the restart counter in the
    //  Lfcb.  Otherwise we can use the LastFlushedLsn value in the
    //  Lfcb.  This way we can determine that the Lbcb that interests
    //  us has made it out to disk.
    //

    if (LfsLbcbIsRestart( Lbcb )) {

        FlushedLsn = &Lfcb->LastFlushedRestartLsn;

    } else {

        FlushedLsn = &Lfcb->LastFlushedLsn;
    }

    //
    //  We loop here until the desired Lsn has made it to disk.
    //  If we are able to do the I/O, we will perform it.
    //

    do {

        //
        //
        //  If we can do the Io, call down to flush the Lfcb.
        //

        if (Lfcb->LfsIoState == LfsNoIoInProgress) {

            LfsFlushLfcb( Lfcb, Lbcb );

            break;
        }

        //
        //  Otherwise we release the Lfcb and immediately wait on the event.
        //

        Lfcb->Waiters += 1;

        LfsReleaseLfcb( Lfcb );

        KeWaitForSingleObject( &Lfcb->Sync->Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        LfsAcquireLfcb( Lfcb );
        Lfcb->Waiters -= 1;

    } while ( LastLsn.QuadPart > FlushedLsn->QuadPart );

    DebugTrace( -1, Dbg, "LfsFlushLbcb:  Exit\n", 0 );
    return;
}


VOID
LfsFlushToLsnPriv (
    IN PLFCB Lfcb,
    IN LSN Lsn
    )

/*++

Routine Description:

    This routine is the worker routine which performs the work of flushing
    a particular Lsn to disk.  This routine is always called with the
    Lfcb acquired.  This routines makes no guarantee about whether the Lfcb
    is acquired on exit.

Arguments:

    Lfcb - This is the file control block for the log file.

    Lsn - This is the Lsn to flush to disk.

Return Value:

    None.

--*/

{
    BOOLEAN UseLastRecordLbcb = FALSE;
    PLBCB LastRecordLbcb = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFlushToLsnPriv:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn.LowPart );
    DebugTrace(  0, Dbg, "Lsn (High)    -> %08lx\n", Lsn.HighPart );

    //
    //  We check if the Lsn is in the valid range.  Raising an
    //  exception if not.
    //

    if (Lsn.QuadPart > Lfcb->RestartArea->CurrentLsn.QuadPart) {

        UseLastRecordLbcb = TRUE;
    }

    //
    //  If the Lsn has already been flushed we are done.
    //  Otherwise we need to look through the workqueues and the
    //  active queue.
    //

    if (Lsn.QuadPart > Lfcb->LastFlushedLsn.QuadPart) {

        PLIST_ENTRY ThisEntry;
        PLBCB ThisLbcb;

        //
        //  Check the workqueue first.  We are looking for the last
        //  buffer block of a log page block which contains this
        //  Lsn.
        //

        ThisEntry = Lfcb->LbcbWorkque.Flink;

        //
        //  We keep looping.
        //

        while (TRUE) {

            ThisLbcb = CONTAINING_RECORD( ThisEntry,
                                          LBCB,
                                          WorkqueLinks );

            //
            //  We pass over any restart areas.  We also skip any
            //  Lbcb's which do not contain the end of a log record.
            //

            if (!LfsLbcbIsRestart( ThisLbcb )
                && FlagOn( ThisLbcb->Flags, LOG_PAGE_LOG_RECORD_END )) {

                LastRecordLbcb = ThisLbcb;

                //
                //  If the last complete Lsn in this Lbcb is greater or equal
                //  to the desired Lsn, we exit the loop.
                //

                if (ThisLbcb->LastEndLsn.QuadPart >= Lsn.QuadPart) {

                    break;
                }
            }

            //
            //  Otherwise move to the next Lbcb.
            //

            ThisEntry = ThisEntry->Flink;

            //
            //  If we have reached the end of the list then break out.  We
            //  were given an Lsn which is larger than any flushed Lsn so
            //  we will just flush to the end of the log file.
            //

            if (ThisEntry == &Lfcb->LbcbWorkque) {

                if (UseLastRecordLbcb) {

                    ThisLbcb = LastRecordLbcb;
                }

                break;
            }
        }

        if (ThisLbcb != NULL) {

            //
            //  If we are not supporting a packed log file and this Lbcb is from
            //  the active queue, we need to check that losing the tail of the
            //  will not swallow up any of our reserved space.
            //

            if (!FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
                && FlagOn( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE )) {

                LONGLONG CurrentAvail;
                LONGLONG UnusedBytes;

                //
                //  Find the unused bytes.
                //

                UnusedBytes = 0;

                LfsCurrentAvailSpace( Lfcb,
                                      &CurrentAvail,
                                      (PULONG)&UnusedBytes );

                CurrentAvail = CurrentAvail - Lfcb->TotalUndoCommitment;

                if (UnusedBytes > CurrentAvail) {

                    DebugTrace( -1, Dbg, "Have to preserve these bytes for possible aborts\n", 0 );

                    ExRaiseStatus( STATUS_LOG_FILE_FULL );
                }

                //
                //  We want to make sure we don't write any more data into this
                //  page.  Remove this from the active queue.
                //

                RemoveEntryList( &ThisLbcb->ActiveLinks );
                ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );
            }

            //
            //  We now have the Lbcb we want to flush to disk.
            //

            LfsFlushLbcb( Lfcb, ThisLbcb );
        }
    }

    DebugTrace( -1, Dbg, "LfsFlushToLsnPriv:  Exit\n", 0 );

    return;
}


PLBCB
LfsGetLbcb (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This routine is called to add a Lbcb to the active queue.

Arguments:

    Lfcb - This is the file control block for the log file.

Return Value:

    PLBCB - Pointer to the Lbcb allocated.

--*/

{
    PLBCB Lbcb = NULL;
    PVOID PageHeader;
    PBCB PageHeaderBcb = NULL;

    BOOLEAN WrappedOrUsaError;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsGetLbcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb      -> %08lx\n", Lfcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Pin the desired record page.
        //

        LfsPreparePinWriteData( Lfcb,
                                Lfcb->NextLogPage,
                                (ULONG)Lfcb->LogPageSize,
                                FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL ),
                                &PageHeader,
                                &PageHeaderBcb );

#ifdef LFS_CLUSTER_CHECK
        //
        //  Check the page to see if there is already data on this page with the current sequence
        //  number.  Useful to track cases where ntfs didn't find the correct end of the log or
        //  where the cluster service has the volume mounted twice.
        //

        if (LfsTestCheckLbcb &&
            *((PULONG) PageHeader) == LFS_SIGNATURE_RECORD_PAGE_ULONG) {

            LSN LastLsn = ((PLFS_RECORD_PAGE_HEADER) PageHeader)->Copy.LastLsn;

            //
            //  This is not an exhaustive test but should be sufficient to catch the typical case.
            //

            ASSERT( FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL ) ||
                    (LfsLsnToSeqNumber( Lfcb, LastLsn ) < (ULONGLONG) Lfcb->SeqNumber) ||
                    (Lfcb->NextLogPage == Lfcb->FirstLogPage) );
        }
#endif

        //
        //  Put our signature into the page so we won't fail if we
        //  see a previous 'BAAD' signature.
        //

        *((PULONG) PageHeader) = LFS_SIGNATURE_RECORD_PAGE_ULONG;

        //
        //  Now allocate an Lbcb.
        //

        LfsAllocateLbcb( Lfcb, &Lbcb );

        //
        //  If we are at the beginning of the file we test that the
        //  sequence number won't wrap to 0.
        //

        if (!FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL )
            && ( Lfcb->NextLogPage == Lfcb->FirstLogPage )) {

            Lfcb->SeqNumber = Lfcb->SeqNumber + 1;

            //
            //  If the sequence number is going from 0 to 1, then
            //  this is the first time the log file has wrapped.  We want
            //  to remember this because it means that we can now do
            //  large spiral writes.
            //

            if (Int64ShllMod32( Lfcb->SeqNumber, Lfcb->FileDataBits ) == 0) {

                DebugTrace( 0, Dbg, "Log sequence number about to wrap:  Lfcb -> %08lx\n", Lfcb );
                KeBugCheckEx( FILE_SYSTEM, 4, 0, 0, 0 );
            }

            //
            //  If this number is greater or equal to  the wrap sequence number in
            //  the Lfcb, set the wrap flag in the Lbcb.
            //

            if (!FlagOn( Lfcb->Flags, LFCB_LOG_WRAPPED )
                && ( Lfcb->SeqNumber >= Lfcb->SeqNumberForWrap )) {

                SetFlag( Lbcb->LbcbFlags, LBCB_LOG_WRAPPED );
                SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
            }
        }

        //
        //  Now initialize the rest of the Lbcb fields.
        //

        Lbcb->FileOffset = Lfcb->NextLogPage;
        Lbcb->SeqNumber = Lfcb->SeqNumber;
        Lbcb->BufferOffset = Lfcb->LogPageDataOffset;

        //
        //  Store the next page in the Lfcb.
        //

        LfsNextLogPageOffset( Lfcb,
                              Lfcb->NextLogPage,
                              &Lfcb->NextLogPage,
                              &WrappedOrUsaError );

        Lbcb->Length = Lfcb->LogPageSize;
        Lbcb->PageHeader = PageHeader;
        Lbcb->LogPageBcb = PageHeaderBcb;

        Lbcb->ResourceThread = ExGetCurrentResourceThread();
        Lbcb->ResourceThread = (ERESOURCE_THREAD) ((ULONG) Lbcb->ResourceThread | 3);

        //
        //  If we are reusing a previous page then set a flag in
        //  the Lbcb to indicate that we should flush a copy
        //  first.
        //

        if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL )) {

            SetFlag( Lbcb->LbcbFlags, LBCB_FLUSH_COPY );
            ClearFlag( Lfcb->Flags, LFCB_REUSE_TAIL );

            (ULONG)Lbcb->BufferOffset = Lfcb->ReusePageOffset;

            Lbcb->Flags = ((PLFS_RECORD_PAGE_HEADER) PageHeader)->Flags;
            Lbcb->LastLsn = ((PLFS_RECORD_PAGE_HEADER) PageHeader)->Copy.LastLsn;
            Lbcb->LastEndLsn = ((PLFS_RECORD_PAGE_HEADER) PageHeader)->Header.Packed.LastEndLsn;
        }

        //
        //  Put the Lbcb on the active queue
        //

        InsertTailList( &Lfcb->LbcbActive, &Lbcb->ActiveLinks );

        SetFlag( Lbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );

        //
        //  Now that we have succeeded, set the owner thread to Thread + 1 so the resource
        //  package will know not to peek in this thread.  It may be deallocated before
        //  we release the Bcb during flush.
        //

        CcSetBcbOwnerPointer( Lbcb->LogPageBcb, (PVOID) Lbcb->ResourceThread );

    } finally {

        DebugUnwind( LfsGetLbcb );

        //
        //  If an error occurred, we need to clean up any blocks which
        //  have not been added to the active queue.
        //

        if (AbnormalTermination()) {

            if (Lbcb != NULL) {

                LfsDeallocateLbcb( Lfcb, Lbcb );
                Lbcb = NULL;
            }

            //
            //  Unpin the system page if pinned.
            //

            if (PageHeaderBcb != NULL) {

                CcUnpinData( PageHeaderBcb );
            }
        }

        DebugTrace( -1, Dbg, "LfsGetLbcb:  Exit\n", 0 );
    }

    return Lbcb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\wsb\wsbvol.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wsbvol.cpp

Abstract:

    Definitions for volume support routines

Author:

    Ran Kalach [rankala] 27, January 2000

Revision History:

--*/


#include <stdafx.h>
#include <wsbvol.h>

// Internal functions
static HRESULT FindMountPoint(IN PWSTR enumName, IN PWSTR volumeName, OUT PWSTR firstMountPoint, IN ULONG maxSize);

HRESULT
WsbGetFirstMountPoint(
    IN PWSTR volumeName, 
    OUT PWSTR firstMountPoint, 
    IN ULONG maxSize
)

/*++

Routine Description:

    Find one Mount Point path (if exists) for the given volume

Arguments:

    volumeName      - The volume name to search mount path for. 
                      It should have the \\?\volume{GUID}\  format
    firstMountPoint - Buffer for the output mount point path
    maxSize         - Buffer size

Return Value:

    S_OK            - If at least one Mount Point is found

--*/
{
    HRESULT                     hr = S_FALSE;
    WCHAR                       name[10];
    UCHAR                       driveLetter;

    WCHAR                       tempName[MAX_PATH];
    WCHAR                       driveName[10];
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;
    IO_STATUS_BLOCK             StatusBlock;
    HANDLE                      hDrive = NULL ;
    NTSTATUS                    status;

    WsbTraceIn(OLESTR("WsbGetFirstMountPoint"), OLESTR("volume name = <%ls>"), volumeName);

    name[1] = ':';
    name[2] = '\\';
    name[3] = 0;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[5] = ':';
    driveName[6] = 0;

    for (driveLetter = L'C'; driveLetter <= L'Z'; driveLetter++) {
        name[0] = driveLetter;

        // Exclude network drives
        if (! GetVolumeNameForVolumeMountPoint(name, tempName, MAX_PATH)) {
            continue;
        }

        // Verify that the drive is not removable or floppy, 
        //  this is required to avoid popups when the drive is empty
        driveName[4] = driveLetter;
        hDrive = CreateFile(driveName,
                        FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0);
        if (hDrive == INVALID_HANDLE_VALUE) {
            // Can't open it - won't search on it
            WsbTrace(OLESTR("WsbGetFirstMountPoint: Could not open volume %ls, status = %lu - Skipping it!\n"), driveName, GetLastError());
            continue;
        }

        status = NtQueryVolumeInformationFile(hDrive,
                        &StatusBlock,
                        (PVOID) &DeviceInfo,
                        sizeof(FILE_FS_DEVICE_INFORMATION),
                        FileFsDeviceInformation);
        if (!NT_SUCCESS(status)) {
            // Can't query it - won't search on it
            WsbTrace(OLESTR("WsbGetFirstMountPoint: Could not query information for volume %ls, status = %ld - Skipping it!\n"), driveName, (LONG)status);
            CloseHandle(hDrive);
            continue;
        }

        if ((DeviceInfo.Characteristics & FILE_FLOPPY_DISKETTE) || (DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA)) { 
            // Skip removable/floppy drives
            WsbTrace(OLESTR("WsbGetFirstMountPoint: Skipping removable/floppy volume %ls\n"), driveName);
            CloseHandle(hDrive);
            continue;
        }
        CloseHandle(hDrive);
        WsbTrace(OLESTR("WsbGetFirstMountPoint: Checking mount points on volume %ls\n"), driveName);

        // Check mount points on drive
        hr = FindMountPoint(name, volumeName, firstMountPoint, maxSize);
        if (S_OK == hr) {
            // Looking for only one mount point
            break;
        }
    }

    WsbTraceOut(OLESTR("WsbGetFirstMountPoint"), OLESTR("hr = <%ls> mount point = <%ls>"), WsbHrAsString(hr), firstMountPoint);

    return hr;
}

HRESULT
FindMountPoint(
    IN PWSTR enumName, 
    IN PWSTR volumeName, 
    OUT PWSTR firstMountPoint, 
    IN ULONG maxSize
)

/*++

Routine Description:

    Find one Mount Point path (if exists) for the given volume on the given enumeration-volume

Arguments:

    enumName        - Volume to enumerate, i.e. search for a mount point on it 
                      which corresponds to the given volume
    volumeName      - The volume name to search mount path for. 
                      It should have the \\?\volume{GUID}\  format
    firstMountPoint - Buffer for the output mount point path
    maxSize         - Buffer size

Comments:
    Avoid the standard HSM try-catch paradigm for performance, especially since this
    function is recursive

Return Value:

    S_OK            - if at least one Mount Point is found
    S_FALSE         - Otherwise

--*/
{
    HANDLE  hEnum;
    WCHAR   *enumVolumeName = NULL;
    WCHAR   *volumeMountPoint = NULL;
    WCHAR   *mountPointPath = NULL;

    WCHAR   c1, c2;
    WCHAR   *linkName1 = NULL;
    WCHAR   *linkName2 = NULL;

    HRESULT hr = S_OK;

    enumVolumeName = (WCHAR*)WsbAlloc(MAX_PATH * sizeof(WCHAR));
    if (NULL == enumVolumeName) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    volumeMountPoint = (WCHAR*)WsbAlloc(maxSize * sizeof(WCHAR));
    if (NULL == volumeMountPoint) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    mountPointPath = (WCHAR*)WsbAlloc((maxSize + wcslen(enumName)) * sizeof(WCHAR));
    if (NULL == mountPointPath) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (! GetVolumeNameForVolumeMountPoint(enumName, enumVolumeName, MAX_PATH)) {
        DWORD dwErr = GetLastError();               
        hr = HRESULT_FROM_WIN32(dwErr);    
        goto exit;
    }

    if (!wcscmp(enumVolumeName, volumeName)) {
        // The volume to enumerate on is the one we are looking for
        wcscpy(firstMountPoint, enumName);
        hr = S_OK;
        goto exit;
    } else {
        linkName1 = (WCHAR*)WsbAlloc((maxSize * 2) * sizeof(WCHAR));
        if (NULL == linkName1) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        linkName2 = (WCHAR*)WsbAlloc((maxSize * 2) * sizeof(WCHAR));
        if (NULL == linkName1) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        c1 = enumVolumeName[48];
        c2 = volumeName[48];
        enumVolumeName[48] = 0;
        volumeName[48] = 0;

        if (QueryDosDevice(&enumVolumeName[4], linkName1, maxSize*2) &&
            QueryDosDevice(&volumeName[4], linkName2, maxSize*2)) {
    
            if (!wcscmp(linkName1, linkName2)) {
                wcscpy(firstMountPoint, enumName);
                enumVolumeName[48] = c1;
                volumeName[48] = c2;
                hr = S_OK;
                goto exit;
            }
        }

        enumVolumeName[48] = c1;
        volumeName[48] = c2;
    }

    hEnum = FindFirstVolumeMountPoint(enumVolumeName, volumeMountPoint, maxSize);
    if (hEnum == INVALID_HANDLE_VALUE) {
        hr = S_FALSE;
        goto exit;
    }

    for (;;) {
        wcscpy(mountPointPath, enumName);
        wcscat(mountPointPath, volumeMountPoint);

        // Enumerate on the mount path we found
        hr = FindMountPoint(mountPointPath, volumeName, firstMountPoint, maxSize);
        if (S_OK == hr) {
            // Found one mount point path, no need to continue
            FindVolumeMountPointClose(hEnum);
            goto exit;
        }

        if (! FindNextVolumeMountPoint(hEnum, volumeMountPoint, maxSize)) {
            FindVolumeMountPointClose(hEnum);
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    if (enumVolumeName) {
        WsbFree(enumVolumeName);
    }
    if (volumeMountPoint) {
        WsbFree(volumeMountPoint);
    }
    if (mountPointPath) {
        WsbFree(mountPointPath);
    }
    if (linkName1) {
        WsbFree(linkName1);
    }
    if (linkName2) {
        WsbFree(linkName2);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\lfsdisk.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsDisk.h

Abstract:

    This module defines the on-disk structures present in the log file.

Author:

    Brian Andrew    [BrianAn]   13-June-1991

Revision History:

IMPORTANT NOTE:

    The Log File Service will by used on systems that require that on-disk
    structures guarantee the natural alignment of all arithmetic quantities
    up to and including quad-word (64-bit) numbers.  Therefore, all Lfs
    on-disk structures are quad-word aligned, etc.

--*/

#ifndef _LFSDISK_
#define _LFSDISK_

#define MINIMUM_LFS_PAGES               0x00000030
#define MINIMUM_LFS_CLIENTS             1

//
//  The following macros are used to set and query with respect to the
//  update sequence arrays.
//

#define UpdateSequenceStructureSize( MSH )              \
    ((((PMULTI_SECTOR_HEADER) (MSH))->UpdateSequenceArraySize - 1) * SEQUENCE_NUMBER_STRIDE)

#define UpdateSequenceArraySize( STRUCT_SIZE )          \
    ((STRUCT_SIZE) / SEQUENCE_NUMBER_STRIDE + 1)

#define FIRST_STRIDE                                    \
    (SEQUENCE_NUMBER_STRIDE - sizeof( UPDATE_SEQUENCE_NUMBER ))


//
//  Log client ID.  This is used to uniquely identify a client for a
//  particular log file.
//

typedef struct _LFS_CLIENT_ID {

    USHORT SeqNumber;
    USHORT ClientIndex;

} LFS_CLIENT_ID, *PLFS_CLIENT_ID;


//
//  Log Record Header.  This is the header that begins every Log Record in
//  the log file.
//

typedef struct _LFS_RECORD_HEADER {

    //
    //  Log File Sequence Number of this log record.
    //

    LSN ThisLsn;

    //
    //  The following fields are used to back link Lsn's.  The ClientPrevious
    //  and ClientUndoNextLsn fields are used by a client to link his log
    //  records.
    //

    LSN ClientPreviousLsn;
    LSN ClientUndoNextLsn;

    //
    //  The following field is the size of data area for this record.  The
    //  log record header will be padded if necessary to fill to a 64-bit
    //  boundary, so the client data will begin on a 64-bit boundary to
    //  insure that all of his data is 64-bit aligned.  The below value
    //  has not been padded to 64 bits however.
    //

    ULONG ClientDataLength;

    //
    //  Client ID.  This identifies the owner of this log record.  The owner
    //  is uniquely identified by his offset in the client array and the
    //  sequence number associated with that client record.
    //

    LFS_CLIENT_ID ClientId;

    //
    //  This the Log Record type.  This could be a commit protocol record,
    //  a client restart area or a client update record.
    //

    LFS_RECORD_TYPE RecordType;

    //
    //  Transaction ID.  This is used externally by a client (Transaction
    //  Manager) to group log file entries.
    //

    TRANSACTION_ID TransactionId;

    //
    //  Log record flags.
    //

    USHORT Flags;

    //
    //  Alignment field.
    //

    USHORT AlignWord;

} LFS_RECORD_HEADER, *PLFS_RECORD_HEADER;

#define LOG_RECORD_MULTI_PAGE           (0x0001)

#define LFS_RECORD_HEADER_SIZE          QuadAlign( sizeof( LFS_RECORD_HEADER ))


//
//  Following are the version specific fields in the record page header.
//

typedef struct _LFS_UNPACKED_RECORD_PAGE {

    //
    //  This gives us the offset of the free space in the page.
    //

    USHORT NextRecordOffset;

    USHORT WordAlign;

    //
    //  Reserved.  The following array is reserved for possible future use.
    //

    USHORT Reserved;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_UNPACKED_RECORD_PAGE, *PLFS_UNPACKED_RECORD_PAGE;

typedef struct _LFS_PACKED_RECORD_PAGE {

    //
    //  This gives us the offset of the free space in the page.
    //

    USHORT NextRecordOffset;

    USHORT WordAlign;

    ULONG DWordAlign;

    //
    //  The following is the Lsn for the last log record which ends on the page.
    //

    LSN LastEndLsn;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_PACKED_RECORD_PAGE, *PLFS_PACKED_RECORD_PAGE;


//
//  Log Record Page Header.  This structure is present at the beginning of each
//  log file page in the client record section.
//

typedef struct _LFS_RECORD_PAGE_HEADER {

    //
    //  Cache multisector protection header.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;

    union {

        //
        //  Highest Lsn in this log file page.  This field is only for
        //  regular log pages.
        //

        LSN LastLsn;

        //
        //  Log file offset.  This is for the tail copies and indicates the
        //  location in the file where the original lays.  In this case the
        //  LastLsn field above can be obtained from the last ending Lsn
        //  field in the PACKED_RECORD_PAGE structure.
        //

        LONGLONG FileOffset;

    } Copy;

    //
    //  Page Header Flags.  These are the same flags that are stored in the
    //  Lbcb->Flags field.
    //
    //      LOG_PAGE_LOG_RECORD_END     -   Page contains the end of a log record
    //

    ULONG Flags;

    //
    //  I/O Page Position.  The following fields are used to determine
    //  where this log page resides within a Lfs I/O transfer.
    //

    USHORT PageCount;
    USHORT PagePosition;

    //
    //  The following is the difference between version 1.1 and earlier.
    //

    union {

        LFS_UNPACKED_RECORD_PAGE Unpacked;
        LFS_PACKED_RECORD_PAGE Packed;

    } Header;

} LFS_RECORD_PAGE_HEADER, *PLFS_RECORD_PAGE_HEADER;

#define LOG_PAGE_LOG_RECORD_END             (0x00000001)

#define LFS_UNPACKED_RECORD_PAGE_HEADER_SIZE        (                               \
    FIELD_OFFSET( LFS_RECORD_PAGE_HEADER, Header.Unpacked.UpdateSequenceArray )     \
)

#define LFS_PACKED_RECORD_PAGE_HEADER_SIZE          (                               \
    FIELD_OFFSET( LFS_RECORD_PAGE_HEADER, Header.Packed.UpdateSequenceArray )       \
)


//
//  Log Restart Page Header.  This structure is at the head of the restart
//  areas in a log file.
//

typedef struct _LFS_RESTART_PAGE_HEADER {

    //
    //  Cache multisector protection header.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;

    //
    //  This is the last Lsn found by checkdisk for this volume.
    //

    LSN ChkDskLsn;

    //
    //  System page size.  This is the page size of the system which
    //  initialized the log file.  Unless the log file has been gracefully
    //  shutdown (there are no clients with restart areas), it is a fatal
    //  error to attempt to write to a log file on a system with a differen
    //  page size.
    //

    ULONG SystemPageSize;

    //
    //  Log Page Size.  This is the log page size used for this log file.
    //  The entire Lfs restart area must fit on a single log page.
    //

    ULONG LogPageSize;

    //
    //  Lfs restart area offset.  This is the offset from the start of this
    //  structure to the Lfs restart area.
    //

    USHORT RestartOffset;

    //
    //  The indicates major and minor versions.  Note that the pre-release versions
    //  have -1 in both positions.  Major version 0 indicates the transition
    //  from Beta to USA support.
    //
    //      Major Version
    //
    //          -1      Beta Version
    //           0      Transition
    //           1      Update sequence support.
    //

    SHORT MinorVersion;
    SHORT MajorVersion;

    //
    //  Update Sequence Array.  Used to protect the page block.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;

} LFS_RESTART_PAGE_HEADER, *PLFS_RESTART_PAGE_HEADER;

#define LFS_RESTART_PAGE_HEADER_SIZE    (                           \
    FIELD_OFFSET( LFS_RESTART_PAGE_HEADER, UpdateSequenceArray )    \
)

//
//  Id strings for the page headers.
//

#define LFS_SIGNATURE_RESTART_PAGE          "RSTR"
#define LFS_SIGNATURE_RESTART_PAGE_ULONG    0x52545352
#define LFS_SIGNATURE_RECORD_PAGE           "RCRD"
#define LFS_SIGNATURE_RECORD_PAGE_ULONG     0x44524352
#define LFS_SIGNATURE_BAD_USA               "BAAD"
#define LFS_SIGNATURE_BAD_USA_ULONG         0x44414142
#define LFS_SIGNATURE_MODIFIED              "CHKD"
#define LFS_SIGNATURE_MODIFIED_ULONG        0x444b4843
#define LFS_SIGNATURE_UNINITIALIZED         "\377\377\377\377"
#define LFS_SIGNATURE_UNINITIALIZED_ULONG   0xffffffff


//
//  Log Client Record.  A log client record exists for each client user of
//  the log file.  One of these is in each Lfs restart area.
//

#define LFS_NO_CLIENT                           0xffff
#define LFS_CLIENT_NAME_MAX                     64

typedef struct _LFS_CLIENT_RECORD {

    //
    //  Oldest Lsn.  This is the oldest Lsn that this client requires to
    //  be in the log file.
    //

    LSN OldestLsn;

    //
    //  Client Restart Lsn.  This is the Lsn of the latest client restart
    //  area written to the disk.  A reserved Lsn will indicate that no
    //  restart area exists for this client.
    //

    LSN ClientRestartLsn;

    //
    //
    //  Previous/Next client area.  These are the indexes into an array of
    //  Log Client Records for the previous and next client records.
    //

    USHORT PrevClient;
    USHORT NextClient;

    //
    //  Sequence Number.  Incremented whenever this record is reused.  This
    //  will happen whenever a client opens (reopens) the log file and has
    //  no current restart area.

    USHORT SeqNumber;

    //
    //  Alignment field.
    //

    USHORT AlignWord;

    //
    //  Align the entire record.
    //

    ULONG AlignDWord;

    //
    //  The following fields are used to describe the client name.  A client
    //  name consists of at most 32 Unicode character (64 bytes).  The Log
    //  file service will treat client names as case sensitive.
    //

    ULONG ClientNameLength;

    WCHAR ClientName[LFS_CLIENT_NAME_MAX];

} LFS_CLIENT_RECORD, *PLFS_CLIENT_RECORD;


//
//  Lfs Restart Area.  Two copies of these will exist at the beginning of the
//  log file.
//

typedef struct _LFS_RESTART_AREA {

    //
    //  Current Lsn.  This is periodic snapshot of the current logical end of
    //  log file to facilitate restart.
    //

    LSN CurrentLsn;

    //
    //  Number of Clients.  This is the maximum number of clients supported
    //  for this log file.
    //

    USHORT LogClients;

    //
    //  The following are indexes into the client record arrays.  The client
    //  records are linked into two lists.  A free list of client records and
    //  an in-use list of records.
    //

    USHORT ClientFreeList;
    USHORT ClientInUseList;

    //
    //  Flag field.
    //
    //      RESTART_SINGLE_PAGE_IO      All log pages written 1 by 1
    //      LFS_CLEAN_SHUTDOWN
    //

    USHORT Flags;

    //
    //  The following is the number of bits to use for the sequence number.
    //

    ULONG SeqNumberBits;

    //
    //  Length of this restart area.
    //

    USHORT RestartAreaLength;

    //
    //  Offset from the start of this structure to the client array.
    //  Ignored in versions prior to 1.1
    //

    USHORT ClientArrayOffset;

    //
    //  Usable log file size.  We will stop sharing the value in the page header.
    //

    LONGLONG FileSize;

    //
    //  DataLength of last Lsn.  This doesn't include the length of
    //  the Lfs header.
    //

    ULONG LastLsnDataLength;

    //
    //  The following apply to log pages.  This is the log page data offset and
    //  the length of the log record header.  Ignored in versions prior to 1.1
    //

    USHORT RecordHeaderLength;
    USHORT LogPageDataOffset;

    //
    //  Log file open count.  Used to determine if there has been a change to the disk.
    //

    ULONG RestartOpenLogCount;

    //
    //   Track log flush failures
    // 
    
    ULONG LastFailedFlushStatus;
    LONGLONG LastFailedFlushOffset;
    LSN LastFailedFlushLsn;

    //
    //  Keep this structure quadword aligned.
    //

    //
    //  Client data.
    //

    LFS_CLIENT_RECORD LogClientArray[1];

} LFS_RESTART_AREA, *PLFS_RESTART_AREA;

#define RESTART_SINGLE_PAGE_IO              (0x0001)
#define LFS_CLEAN_SHUTDOWN                  (0x0002)

#define LFS_RESTART_AREA_SIZE       (FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray ))

//
//  Remember the old size of the restart area when accessing older disks.
//

typedef struct _LFS_OLD_RESTART_AREA {

    //
    //  Current Lsn.  This is periodic snapshot of the current logical end of
    //  log file to facilitate restart.
    //

    LSN CurrentLsn;

    //
    //  Number of Clients.  This is the maximum number of clients supported
    //  for this log file.
    //

    USHORT LogClients;

    //
    //  The following are indexes into the client record arrays.  The client
    //  records are linked into two lists.  A free list of client records and
    //  an in-use list of records.
    //

    USHORT ClientFreeList;
    USHORT ClientInUseList;

    //
    //  Flag field.
    //
    //      RESTART_SINGLE_PAGE_IO      All log pages written 1 by 1
    //

    USHORT Flags;

    //
    //  The following is the number of bits to use for the sequence number.
    //

    ULONG SeqNumberBits;

    //
    //  Length of this restart area.
    //

    USHORT RestartAreaLength;

    //
    //  Offset from the start of this structure to the client array.
    //  Ignored in versions prior to 1.1
    //

    USHORT ClientArrayOffset;

    //
    //  Usable log file size.  We will stop sharing the value in the page header.
    //

    LONGLONG FileSize;

    //
    //  DataLength of last Lsn.  This doesn't include the length of
    //  the Lfs header.
    //

    ULONG LastLsnDataLength;

    //
    //  The following apply to log pages.  This is the log page data offset and
    //  the length of the log record header.  Ignored in versions prior to 1.1
    //

    USHORT RecordHeaderLength;
    USHORT LogPageDataOffset;

    //
    //  Client data.
    //

    LFS_CLIENT_RECORD LogClientArray[1];

} LFS_OLD_RESTART_AREA, *PLFS_OLD_RESTART_AREA;
#endif // _LFSDISK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\lfsdata.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsData.c

Abstract:

    This module declares the global data used by the Log File Service.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#ifndef _LFSDATA_
#define _LFSDATA_

//
//  The global Lfs data record
//

extern LFS_DATA LfsData;

//
//  Various large integer constants.
//

#define LfsMaximumFileSize (0x0000000100000000)

extern LARGE_INTEGER LfsLi0;
extern LARGE_INTEGER LfsLi1;

//
//  The following Lsn is used as a starting point in the file.
//

extern LSN LfsStartingLsn;

#ifdef LFS_CLUSTER_CHECK

//
//  Check for gaps in the log.
//

extern BOOLEAN LfsTestBreakOnAnyError;
extern BOOLEAN LfsTestCheckLbcb;
#endif

//
//  Turn on pseudo-asserts if NTFS_FREE_ASSERTS is defined.
//

#if !DBG
#ifdef NTFS_FREE_ASSERTS
#undef ASSERT
#undef ASSERTMSG
#define ASSERT(exp)        if (!(exp)) { extern PBOOLEAN KdDebuggerEnabled; DbgPrint("%s:%d %s\n",__FILE__,__LINE__,#exp); if (*KdDebuggerEnabled) { DbgBreakPoint(); } }
#define ASSERTMSG(msg,exp) if (!(exp)) { extern PBOOLEAN KdDebuggerEnabled; DbgPrint("%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp); if (*KdDebuggerEnabled) { DbgBreakPoint(); } }
#endif
#endif

//
//  The global Lfs debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bug check)
//
//      0x00000001      Error conditions
//      0x00000002      Debug hooks
//      0x00000004      Catch exceptions before completing Irp
//      0x00000008      Unwinding during error conditions
//
//      0x00000010      Lfs initialization
//      0x00000020      Lfs query log records
//      0x00000040      Lfs write log records
//      0x00000080      Lfs registry routines
//
//      0x00000100      Lfs worker thread routines
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000      Log page support routines
//      0x00002000      Lsn support routines
//      0x00004000      Miscellaneous support routines
//      0x00008000      Support routines for cache operations
//
//      0x00010000      Structure support routines
//      0x00020000      Verify/validate support routines
//      0x00040000      Synchronization routines
//      0x00080000      Log buffer support routines
//
//      0x00100000      Support routines for manipulating log records
//      0x00200000      Support routines for manipulation lfs restart areas
//      0x00400000      Support routines for client restart operations
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000
//      0x08000000
//
//      0x10000000
//      0x20000000
//      0x40000000
//      0x80000000
//

#ifdef LFSDBG

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS          (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_UNWIND               (0x00000008)
#define DEBUG_TRACE_INITIALIZATION       (0x00000010)
#define DEBUG_TRACE_QUERY                (0x00000020)
#define DEBUG_TRACE_WRITE                (0x00000040)
#define DEBUG_TRACE_RESTART              (0x00000080)
#define DEBUG_TRACE_REGISTRY             (0x00000100)
#define DEBUG_TRACE_WORKER               (0x00000200)
#define DEBUG_TRACE_0x00000400           (0x00000400)
#define DEBUG_TRACE_0x00000800           (0x00000800)
#define DEBUG_TRACE_LOG_PAGE_SUP         (0x00001000)
#define DEBUG_TRACE_LSN_SUP              (0x00002000)
#define DEBUG_TRACE_MISC_SUP             (0x00004000)
#define DEBUG_TRACE_CACHE_SUP            (0x00008000)
#define DEBUG_TRACE_STRUC_SUP            (0x00010000)
#define DEBUG_TRACE_VERIFY_SUP           (0x00020000)
#define DEBUG_TRACE_SYNCH_SUP            (0x00040000)
#define DEBUG_TRACE_LBCB_SUP             (0x00080000)
#define DEBUG_TRACE_LOG_RECORD_SUP       (0x00100000)
#define DEBUG_TRACE_RESTART_SUP          (0x00200000)
#define DEBUG_TRACE_0x00400000           (0x00400000)
#define DEBUG_TRACE_0x00800000           (0x00800000)
#define DEBUG_TRACE_0x01000000           (0x01000000)
#define DEBUG_TRACE_0x02000000           (0x02000000)
#define DEBUG_TRACE_0x04000000           (0x04000000)
#define DEBUG_TRACE_0x08000000           (0x08000000)
#define DEBUG_TRACE_0x10000000           (0x10000000)
#define DEBUG_TRACE_0x20000000           (0x20000000)
#define DEBUG_TRACE_0x40000000           (0x40000000)
#define DEBUG_TRACE_0x80000000           (0x80000000)

extern LONG LfsDebugTraceLevel;
extern LONG LfsDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                      \
    LONG _i;                                                \
    if (((LEVEL) == 0) || (LfsDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                   \
        DbgPrint("%08lx:",_i);                              \
        if ((INDENT) < 0) {                                 \
            LfsDebugTraceIndent += (INDENT);                \
        }                                                   \
        if (LfsDebugTraceIndent < 0) {                      \
            LfsDebugTraceIndent = 0;                        \
        }                                                   \
        for (_i = 0; _i < LfsDebugTraceIndent; _i += 1) {   \
            DbgPrint(" ");                                  \
        }                                                   \
        DbgPrint(X,Y);                                      \
        if ((INDENT) > 0) {                                 \
            LfsDebugTraceIndent += (INDENT);                \
        }                                                   \
    }                                                       \
}

#define DebugDump(STR,LEVEL,PTR) {                          \
    ULONG _i;                                               \
    VOID LfsDump();                                         \
    if (((LEVEL) == 0) || (LfsDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                   \
        DbgPrint("%08lx:",_i);                              \
        DbgPrint(STR);                                      \
        if (PTR != NULL) {LfsDump(PTR);}                    \
        DbgBreakPoint();                                    \
    }                                                       \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                             \
        DebugTrace(0, DEBUG_TRACE_UNWIND, #X ", Abnormal termination.\n", 0); \
    }                                                                         \
}

#define DebugDoit(X)                     {X;}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}
#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define DebugDoit(X)                     {NOTHING;}

#endif // LFSDBG

#endif // _LFSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\lfsstruc.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Log File Service.

Author:

    Brian Andrew    [BrianAn]   13-June-1991

Revision History:

--*/

#ifndef _LFSSTRUC_
#define _LFSSTRUC_

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module


//
//  Log Enumeration Block.  A pointer to this structure is returned to the user
//  when a client is reading a particular set of log records from the log
//  file.
//

typedef struct _LEB {

    //
    //  The type and size of this record (must be LFS_NTC_LEB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Log record header.  This is the mapped log record header and bcb
    //  for the record header of the current Lsn.
    //

    struct _LFS_RECORD_HEADER *RecordHeader;
    PBCB RecordHeaderBcb;

    //
    //  Context Mode.  This is the mode governing the log record lookup.  We
    //  can look backwards via the ClientUndoNextLsn or ClientPreviousLsn.
    //  We can also look forwards by walking through all the log records and
    //  comparing ClientId fields.
    //

    LFS_CONTEXT_MODE ContextMode;

    //
    //  Client Id.  This is the client ID for the log records being returned.
    //

    LFS_CLIENT_ID ClientId;

    //
    //  Log record pointer.  This is the address returned to the user as the
    //  log record referred to by CurrentLsn.  If we allocated a buffer to
    //  hold the record, we need to deallocate it as necessary.
    //
    //  This field is either the actual mapped log record or a pointer to
    //  an auxilary buffer allocated by the Lfs.
    //

    PVOID CurrentLogRecord;
    BOOLEAN AuxilaryBuffer;

} LEB, *PLEB;


//
//  Lfcb synchronization.  This is the synchronization structure used by the Lfcb.
//

typedef struct _LFCB_SYNC {

    //
    //  Principal Lfcb Resource.
    //

    ERESOURCE Resource;

    //
    //  Notification Event.  This event is set to the Signalled state when
    //  pages are flushed to the cache file.  Any waiters will then check
    //  to see if the Lsn they're waiting for made it to disk.
    //

    KEVENT Event;

    //
    //  User Count.  Number of clients using this structure.  We will deallocate
    //  when all clients are gone.
    //

    ULONG UserCount;

    //
    //  Mutant to guard Leb spare list
    //

    FAST_MUTEX SpareListMutex;

} LFCB_SYNC, *PLFCB_SYNC;


//
//  Log Client Structure.  The Lfs allocates one of these for each active
//  client.  The address of this structure will be returned to the user
//  as a log handle.
//

typedef struct _LCH {

    //
    //  The type and size of this record (must be LFS_NTC_LCH)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Links for all the client handles on an Lfcb.
    //

    LIST_ENTRY LchLinks;

    //
    //  Log File Control Block.  This is the log file for this log handle.
    //

    struct _LFCB *Lfcb;

    //
    //  Client Id.  This refers to the client record for this client in the
    //  Lfs restart area.
    //

    LFS_CLIENT_ID ClientId;

    //
    //  The following is the number of bytes this client has asked to
    //  have reserved in the log file.  It includes the space
    //  for the log record headers.
    //

    LONGLONG ClientUndoCommitment;

    //
    //  Byte offset in the client array.
    //

    ULONG ClientArrayByteOffset;

    //
    //  Pointer to the resource in the Lfcb.  We access the resource with
    //  this pointer for the times when the lfcb has been deleted.
    //

    PLFCB_SYNC Sync;

} LCH, *PLCH;


//
//  Log Buffer Control Block.  A buffer control block is associated with
//  each of the log buffers.  They are used to serialize access to the
//  log file.
//

typedef struct _LBCB {

    //
    //  The type and size of this record (must be LFS_NTC_LBCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Buffer Block Links.  These fields are used to link the buffer blocks
    //  together.
    //

    LIST_ENTRY WorkqueLinks;
    LIST_ENTRY ActiveLinks;

    //
    //  Log file position and length.  This is the location in the log file to write
    //  out this buffer.
    //

    LONGLONG FileOffset;
    LONGLONG Length;

    //
    //  Sequence number.  This is the sequence number for log records which
    //  begin on this page.
    //

    LONGLONG SeqNumber;

    //
    //  Next Offset.  This is the next offset to write a log record in the
    //  this log page.  Stored as a large integer to facilitate large
    //  integer operations.
    //

    LONGLONG BufferOffset;

    //
    //  Buffer.  This field points to the buffer containing the log page
    //  for this block.  For a log record page this is a pointer to
    //  a pinned cache buffer, for a log restart page, this is a pointer
    //  to an auxilary buffer.
    //

    PVOID PageHeader;

    //
    //  Bcb for Log Page Block.  This is the Bcb for the pinned data.
    //  If this buffer block describes an Lfs restart area, this field is NULL.
    //

    PBCB LogPageBcb;

    //
    //  Last Lsn.  This is the Lsn for the last log record on this page.  We delay
    //  writing it until the page is flushed, storing it here instead.
    //

    LSN LastLsn;

    //
    //  Last complete Lsn.  This is the Lsn for the last log record which ends
    //  on this page.
    //

    LSN LastEndLsn;

    //
    //  Page Flags.  These are the flags associated with this log page.
    //  We store them in the Lbcb until the page is written.  They flags
    //  to use are the same as in the log record page header.
    //
    //      LOG_PAGE_LOG_RECORD_END     -   Page contains the end of a log record
    //      LOG_PAGE_PACKED             -   Page contains packed log records
    //      LOG_PAGE_TAIL_COPY          -   Page is a copy of the log file end
    //

    ULONG Flags;

    //
    //  Lbcb flags.  These are flags used to describe this Lbcb.
    //
    //      LBCB_LOG_WRAPPED            -   Lbcb has wrapped the log file
    //      LBCB_ON_ACTIVE_QUEUE        -   Lbcb is on the active queue
    //      LBCB_NOT_EMPTY              -   Page has existing log record
    //      LBCB_FLUSH_COPY             -   Write copy of this page first
    //      LBCB_RESTART_LBCB           -   This Lbcb contains a restart page
    //

    ULONG LbcbFlags;

    //
    //  This is the thread which has locked the log page.
    //

    ERESOURCE_THREAD ResourceThread;

} LBCB, *PLBCB;

#define LBCB_LOG_WRAPPED                        (0x00000001)
#define LBCB_ON_ACTIVE_QUEUE                    (0x00000002)
#define LBCB_NOT_EMPTY                          (0x00000004)
#define LBCB_FLUSH_COPY                         (0x00000008)
#define LBCB_RESTART_LBCB                       (0x00000020)


//
//  Log file data.  This data structure is used on a per-log file basis.
//

typedef enum _LFS_IO_STATE {

    LfsNoIoInProgress = 0,
    LfsClientThreadIo

} LFS_IO_STATE;

typedef struct _LFCB {

    //
    //  The type and size of this record (must be LFS_NTC_LFCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Lfcb Links.  The following links the file control blocks to the
    //  global data structure.
    //

    LIST_ENTRY LfcbLinks;

    //
    //  Lch Links.  The following links all of the handles for the Lfcb.
    //

    LIST_ENTRY LchLinks;

    //
    //
    //  File Object.  This is the file object for the log file.
    //

    PFILE_OBJECT FileObject;

    //
    //  Log File Size.  This is the size of the log file.
    //  The second value is the size proposed by this open.
    //

    LONGLONG FileSize;

    //
    //  Log page size, masks and shift count to do multiplication and division
    //  of log pages.
    //

    LONGLONG  LogPageSize;
    ULONG LogPageMask;
    LONG LogPageInverseMask;
    ULONG LogPageShift;

    //
    //  First log page.  This is the offset in the file of the first
    //  log page with log records.
    //

    LONGLONG FirstLogPage;

    //
    //  Next log page offset.  This is the offset of the next log page to use.
    //  If we are reusing this page we store the offset to begin with.
    //

    LONGLONG NextLogPage;
    ULONG ReusePageOffset;

    //
    //  Data Offset.  This is the offset within a log page of the data that
    //  appears on that page.  This will be the actual restart data for
    //  an Lfs restart page, or the beginning of log record data for a log
    //  record page.
    //

    ULONG RestartDataOffset;
    LONGLONG LogPageDataOffset;

    //
    //  Data Size.  This is the amount of data that may be stored on a
    //  log page.  It is included here because it is frequently used.  It
    //  is simply the log page size minus the data offset.
    //

    ULONG RestartDataSize;
    LONGLONG LogPageDataSize;

    //
    //  Record header size.  This is the size to use for the record headers
    //  when reading the log file.
    //

    USHORT RecordHeaderLength;

    //
    //  Sequence number.  This is the number of times we have cycled through
    //  the log file.  The wrap sequence number is used to confirm that we
    //  have gone through the entire file at least once.  When we write a
    //  log record page for an Lsn with this sequence number, then we have
    //  cycled through the file.
    //

    LONGLONG SeqNumber;
    LONGLONG SeqNumberForWrap;
    ULONG SeqNumberBits;
    ULONG FileDataBits;

    //
    //  Buffer Block Links.  The following links the buffer blocks for this
    //  log file.
    //

    LIST_ENTRY LbcbWorkque;
    LIST_ENTRY LbcbActive;

    PLBCB ActiveTail;
    PLBCB PrevTail;

    //
    //  The enumerated type indicates if there is an active write for
    //  this log file and whether it is being done by an Lfs or
    //  client thread.
    //

    LFS_IO_STATE LfsIoState;

    //
    //  Current Restart Area.  The following is the in-memory image of the
    //  next restart area.  We also store a pointer to the client data
    //  array in the restart area.  The client array offset is from the start of
    //  the restart area.
    //

    PLFS_RESTART_AREA RestartArea;
    PLFS_CLIENT_RECORD ClientArray;
    USHORT ClientArrayOffset;
    USHORT ClientNameOffset;

    //
    //  Restart Area size.  This is the usable size of the restart area.
    //

    ULONG RestartAreaSize;
    USHORT LogClients;

    //
    //  Initial Restart area.  If true, then the in-memory restart area is to
    //  be written to the first position on the disk.
    //

    BOOLEAN InitialRestartArea;

    //
    //  The following pseudo Lsn's are used to track when restart areas
    //  are flushed to the disk.
    //

    LSN NextRestartLsn;
    LSN LastFlushedRestartLsn;

    //
    //  The following is the earliest Lsn we will guarantee is still in the
    //  log file.
    //

    LSN OldestLsn;

    //
    //  The following is the file offset of the oldest Lsn in the system.
    //  We redundantly store it in this form since we will be constantly
    //  checking if a new log record will write over part of the file
    //  we are trying to maintain.
    //

    LONGLONG OldestLsnOffset;

    //
    //  Last Flushed Lsn.  The following is the last Lsn guaranteed to
    //  be flushed to the disk.
    //

    LSN LastFlushedLsn;

    //
    //
    //  The following fields are used to track current usage in the log file.
    //
    //      TotalAvailable - is the total number of bytes available for
    //          log records.  It is the number of log pages times the
    //          data size of each page.
    //
    //      TotalAvailInPages - is the total number of bytes in the log
    //          pages for log records.  This is TotalAvailable without
    //          subtracting the size of the page headers.
    //
    //      TotalUndoCommitment - is the number of bytes reserved for
    //          possible abort operations.  This includes space for
    //          log record headers as well.
    //
    //      MaxCurrentAvail - is the maximum available in all pages
    //          subtracting the page header and any reserved tail.
    //
    //      CurrentAvailable - is the total number of bytes available in
    //          unused pages in the log file.
    //
    //      ReservedLogPageSize - is the number of bytes on a page available
    //          for reservation.
    //

    LONGLONG TotalAvailable;
    LONGLONG TotalAvailInPages;
    LONGLONG TotalUndoCommitment;
    LONGLONG MaxCurrentAvail;
    LONGLONG CurrentAvailable;

    LONGLONG ReservedLogPageSize;

    //
    //  The following fields are used to store information about the
    //  update sequence arrays.
    //

    USHORT RestartUsaOffset;
    USHORT UsaArraySize;

    USHORT LogRecordUsaOffset;

    //
    //  Major and minor version numbers.
    //

    SHORT MajorVersion;
    SHORT MinorVersion;

    //
    //  Log File Flags.
    //
    //      LFCB_LOG_WRAPPED        -   We found an Lbcb which wraps the log file
    //      LFCB_MULTIPLE_PAGE_IO   -   Write multiple pages if possible
    //      LFCB_NO_LAST_LSN        -   There are no log records to return
    //      LFCB_PACK_LOG           -   Pack the records into the pages
    //      LFCB_REUSE_TAIL         -   We will be reusing the tail of the log file after restart
    //      LFCB_NO_OLDEST_LSN      -   There is no oldest page being reserved
    //

    ULONG Flags;

    //
    //  The following are the spare Lbcb's for the volume and a field with
    //  the count for these.
    //

    ULONG SpareLbcbCount;
    LIST_ENTRY SpareLbcbList;

    //
    //  The following are sparse LEB's to be used rather than having to allocate
    //  then when reading log records
    //

    ULONG SpareLebCount;
    LIST_ENTRY SpareLebList;

    //
    //  The following structure synchronizes access to this structure.
    //

    PLFCB_SYNC Sync;

    //
    //  Count of waiters wanting access to flush the Lfcb.
    //

    ULONG Waiters;

    //
    //  On-disk value for OpenLogCount.  This is the value we will stuff into
    //  the client handles.
    //

    ULONG CurrentOpenLogCount;

    //
    //  Maintain the flush range for this file.
    //

    PLFS_WRITE_DATA UserWriteData;

    ERESOURCE_THREAD LfsIoThread;

    //
    //  Buffer and mdls which hold down the first 4 pages at the head of the log
    //  this includes the lfs restart areas and the ping pong pages. The partial mdl
    //  is used to pin pieces of the total buffer
    //

    PMDL LogHeadMdl;
    PMDL LogHeadPartialMdl;
    PVOID LogHeadBuffer;

    //
    //  preallocated error log packet for use logging errors to the eventlog
    //

    PIO_ERROR_LOG_PACKET ErrorLogPacket;

#ifdef LFS_CLUSTER_CHECK
    LSN LsnAtMount;
    ULONG LsnRangeIndex;
#endif

    //
    //  Embedded array with enough space for SYSTEM PAGE / LOG PAGE SIZE
    //  used to facilitate flushing partial system pages
    //

    PLBCB DirtyLbcb[0];

} LFCB, *PLFCB;

#define LFCB_LOG_WRAPPED                (0x00000001)
#define LFCB_MULTIPLE_PAGE_IO           (0x00000002)
#define LFCB_NO_LAST_LSN                (0x00000004)
#define LFCB_PACK_LOG                   (0x00000008)
#define LFCB_REUSE_TAIL                 (0x00000010)
#define LFCB_NO_OLDEST_LSN              (0x00000020)
#define LFCB_LOG_FILE_CORRUPT           (0x00000040)
#define LFCB_FINAL_SHUTDOWN             (0x00000080)
#define LFCB_READ_FIRST_RESTART         (0x00000100)
#define LFCB_READ_SECOND_RESTART        (0x00000200)
#define LFCB_READ_ONLY                  (0x00000400)

#ifdef LFS_CLUSTER_CHECK
#define LFCB_DEVICE_OFFLINE_SEEN        (0x80000000)
#define LFCB_FLUSH_FAILED               (0x40000000)
#endif

#define LFCB_RESERVE_LBCB_COUNT         (5)
#define LFCB_MAX_LBCB_COUNT             (25)

#define LFCB_RESERVE_LEB_COUNT          (5)
#define LFCB_MAX_LEB_COUNT              (25)


//
//  Global Log Data.  The following structure has only one instance and
//  maintains global information for the entire logging service.
//

typedef struct _LFS_DATA {

    //
    //  The type and size of this record (must be LFS_NTC_DATA)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field links all of the Log File Control Blocks for
    //  the logging system.
    //

    LIST_ENTRY LfcbLinks;

    //
    //  Flag field.
    //

    ULONG Flags;

    //
    //  The following mutex controls access to this structure.
    //

    FAST_MUTEX LfsDataLock;

    //
    //  Allocated buffers for reading spanning log records in low memory case.
    //  Flags indicate which buffers owned.
    //      LFS_BUFFER1_OWNED
    //      LFS_BUFFER2_OWNED
    //

    PVOID Buffer1;
    PVOID Buffer2;
    ERESOURCE_THREAD BufferOwner;
    ULONG BufferFlags;

    FAST_MUTEX BufferLock;
    KEVENT BufferNotification;

} LFS_DATA, *PLFS_DATA;

#define LFS_DATA_INIT_FAILED                (0x00000001)
#define LFS_DATA_INITIALIZED                (0x00000002)

#define LFS_BUFFER1_OWNED                   (0x00000001)
#define LFS_BUFFER2_OWNED                   (0x00000002)

#define LFS_BUFFER_SIZE                     (0x10000)
#endif // _LFSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\lfsprocs.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LfsProcs.h

Abstract:

    This module defines all of the globally used procedures in the Log
    File Service.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#ifndef _LFSPROCS_
#define _LFSPROCS_

#include <ntifs.h>
#include <string.h>
#include <lfs.h>

#include "nodetype.h"
#include "LfsDisk.h"
#include "LfsStruc.h"
#include "LfsData.h"

//
//  Tag all of our allocations if tagging is turned on
//

#undef FsRtlAllocatePool
#undef FsRtlAllocatePoolWithQuota

#define FsRtlAllocatePool(a,b) FsRtlAllocatePoolWithTag(a,b,' sfL')
#define FsRtlAllocatePoolWithQuota(a,b) FsRtlAllocatePoolWithQuotaTag(a,b,' sfL')

#define LfsAllocatePoolNoRaise(a,b)         ExAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)
#define LfsAllocatePool(a,b)                ExAllocatePoolWithTag(((a) | POOL_RAISE_IF_ALLOCATION_FAILURE),(b),MODULE_POOL_TAG)
#define LfsFreePool(pv)                     ExFreePool(pv)

#ifndef INLINE
// definition of inline
#define INLINE __inline
#endif


//
//  The following routines provide an interface with the cache package.
//  They are contained in 'CacheSup.c'.
//

NTSTATUS
LfsPinOrMapData (
    IN PLFCB Lfcb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN BOOLEAN PinData,
    IN BOOLEAN AllowErrors,
    IN BOOLEAN IgnoreUsaErrors,
    OUT PBOOLEAN UsaError,
    OUT PVOID *Buffer,
    OUT PBCB *Bcb
    );

//
//  VOID
//  LfsPreparePinWriteData (
//      IN PLFCB Lfcb,
//      IN LONGLONG FileOffset,
//      IN ULONG Length,
//      IN LOGICAL ReadFromDisk,
//      OUT PVOID *Buffer,
//      OUT PBCB *Bcb
//      );
//

#ifdef LFS_CLUSTER_CHECK
#define LfsPreparePinWriteData(L,FO,LEN,R,BUF,B) {          \
    LONGLONG _LocalFileOffset = (FO);                       \
    CcPinRead( (L)->FileObject,                             \
               (PLARGE_INTEGER)&_LocalFileOffset,           \
               (LEN),                                       \
               TRUE,                                        \
               (B),                                         \
               (BUF) );                                     \
}
#else
#define LfsPreparePinWriteData(L,FO,LEN,R,BUF,B) {              \
    LONGLONG _LocalFileOffset = (FO);                           \
    if (R) {                                                    \
        CcPinRead( (L)->FileObject,                             \
                   (PLARGE_INTEGER)&_LocalFileOffset,           \
                   (LEN),                                       \
                   TRUE,                                        \
                   (B),                                         \
                   (BUF) );                                     \
    } else {                                                    \
        CcPreparePinWrite( (L)->FileObject,                     \
                           (PLARGE_INTEGER)&_LocalFileOffset,   \
                           (LEN),                               \
                           FALSE,                               \
                           TRUE,                                \
                           (B),                                 \
                           (BUF) );                             \
    }                                                           \
}
#endif

VOID
LfsPinOrMapLogRecordHeader (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN BOOLEAN PinData,
    IN BOOLEAN IgnoreUsaErrors,
    OUT PBOOLEAN UsaError,
    OUT PLFS_RECORD_HEADER *RecordHeader,
    OUT PBCB *Bcb
    );

VOID
LfsCopyReadLogRecord (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_HEADER RecordHeader,
    OUT PVOID Buffer
    );

VOID
LfsFlushLfcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    );

BOOLEAN
LfsReadRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN BOOLEAN FirstRestart,
    OUT PLONGLONG RestartPageOffset,
    OUT PLFS_RESTART_PAGE_HEADER *RestartPage,
    OUT PBCB *RestartPageBcb,
    OUT PBOOLEAN ChkdskWasRun,
    OUT PBOOLEAN ValidPage,
    OUT PBOOLEAN UninitializedFile,
    OUT PBOOLEAN LogPacked,
    OUT PLSN LastLsn
    );


//
//  The following routines manipulate buffer control blocks.  They are
//  contained in 'LbcbSup.c'
//

VOID
LfsFlushLbcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    );

VOID
LfsFlushToLsnPriv (
    IN PLFCB Lfcb,
    IN LSN Lsn
    );

PLBCB
LfsGetLbcb (
    IN PLFCB Lfcb
    );


//
//  The following routines are in LfsData.c
//

LONG
LfsExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    );


//
//  Log page support routines.  The following routines manipulate and
//  modify log pages.  They are contained in 'LogPgSup.c'
//

//
//  VOID
//  LfsTruncateOffsetToLogPage (
//      IN PLFCB Lfcb,
//      IN LONGLONG LargeInt,
//      OUT PLONGLONG Result
//      );
//
//  ULONG
//  LfsLogPageOffset (
//      IN PLFCB Lfcb,
//      IN ULONG Integer
//      );
//

#define LfsTruncateOffsetToLogPage(LFCB,LI,OUTLI)       \
    *(OUTLI) = LI;                                      \
    *((PULONG)(OUTLI)) &= (LFCB)->LogPageInverseMask

#define LfsLogPageOffset(LFCB,INT)                      \
    (INT & (LFCB)->LogPageMask)

VOID
LfsNextLogPageOffset (
    IN PLFCB Lfcb,
    IN LONGLONG CurrentLogPageOffset,
    OUT PLONGLONG NextLogPageOffset,
    OUT PBOOLEAN Wrapped
    );

PVOID
LfsAllocateSpanningBuffer (
    IN PLFCB Lfcb,
    IN ULONG Length
    );

VOID
LfsFreeSpanningBuffer (
    IN PVOID Buffer
    );


//
//  The following routines provide support for dealing with log records.  They
//  are contained in 'LogRcSup.c'
//

BOOLEAN
LfsWriteLogRecordIntoLogPage (
    IN PLFCB Lfcb,
    IN PLCH Lch,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId OPTIONAL,
    IN LSN ClientUndoNextLsn OPTIONAL,
    IN LSN ClientPreviousLsn OPTIONAL,
    IN LONG UndoRequirement,
    IN BOOLEAN ForceToDisk,
    OUT PLSN Lsn
    );


//
//  Lsn support routines.  The following routines provide support for
//  manipulating Lsn values.  They are contained in 'LsnSup.c'
//

//
//  LSN
//  LfsFileOffsetToLsn (
//      IN PLFCB Lfcb,
//      IN LONGLONG FileOffset,
//      IN LONGLONG SequenceNumber
//      );
//
//  BOOLEAN
//  LfsIsLsnInFile (
//      IN PLFCB Lfcb,
//      IN LSN Lsn
//      );
//
//  LSN
//  LfsComputeLsnFromLbcb (
//      IN PLFCB Lfcb,
//      IN PLBCB Lbcb
//      );
//
//  VOID
//  LfsTruncateLsnToLogPage (
//      IN PLFCB Lfcb,
//      IN LSN Lsn,
//      OUT PLONGLONG FileOffset
//      );
//
//  LONGLONG
//  LfsLsnToFileOffset (
//      IN PLFCB Lfcb,
//      IN LSN Lsn
//      );
//
//  LONGLONG
//  LfsLsnToSeqNumber (
//      IN PLFCB Lfcb,
//      IN LSN Lsn
//      );
//
//  ULONG
//  LfsLsnToPageOffset (
//      IN PLFCB Lfcb,
//      IN LSN Lsn
//      );
//

#define LfsFileOffsetToLsn(LFCB,FO,SN) (                                        \
    (((ULONGLONG)(FO)) >> 3) + Int64ShllMod32((SN), (LFCB)->FileDataBits)                                \
)

#define LfsIsLsnInFile(LFCB,LSN)                                                \
    (/*xxGeq*/( (LSN).QuadPart >= ((LFCB)->OldestLsn).QuadPart )                                          \
     && /*xxLeq*/( (LSN).QuadPart <= ((LFCB)->RestartArea->CurrentLsn).QuadPart ))

#define LfsComputeLsnFromLbcb(LFCB,LBCB) (                                              \
    LfsFileOffsetToLsn( LFCB,                                                           \
                        (LBCB)->FileOffset + (LBCB)->BufferOffset,    \
                        (LBCB)->SeqNumber )                                    \
)

#define LfsTruncateLsnToLogPage(LFCB,LSN,FO) {                                  \
    *(FO) = LfsLsnToFileOffset( LFCB, LSN );                                    \
    *((PULONG)(FO)) &= (LFCB)->LogPageInverseMask;                                \
}

#define LfsLsnToFileOffset(LFCB,LSN)                                            \
    /*xxShr*/( ((ULONGLONG)/*xxShl*/( (LSN).QuadPart << (LFCB)->SeqNumberBits )) >> ((LFCB)->SeqNumberBits - 3) )

#define LfsLsnToSeqNumber(LFCB,LSN)                                             \
    /*xxShr*/Int64ShrlMod32( ((ULONGLONG)(LSN).QuadPart), (LFCB)->FileDataBits )

#define LfsLsnToPageOffset(LFCB,LSN)                                            \
    LfsLogPageOffset( LFCB, (LSN).LowPart << 3 )

VOID
LfsLsnFinalOffset (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN ULONG DataLength,
    OUT PLONGLONG FinalOffset
    );

BOOLEAN
LfsFindNextLsn (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_HEADER RecordHeader,
    OUT PLSN Lsn
    );


//
//  The following routines support the Lfs restart areas.  They are contained
//  in 'RstrtSup.c'
//

VOID
LfsWriteLfsRestart (
    IN PLFCB Lfcb,
    IN ULONG ThisRestartSize,
    IN BOOLEAN WaitForIo
    );

VOID
LfsFindOldestClientLsn (
    IN PLFS_RESTART_AREA RestartArea,
    IN PLFS_CLIENT_RECORD ClientArray,
    OUT PLSN OldestLsn
    );


//
//  The following routines are used for managing the structures allocated
//  by us.  They are contained in 'StrucSup.c'
//

PLFCB
LfsAllocateLfcb (
    IN ULONG LogPageSize,
    IN LONGLONG FileSize
    );


VOID
LfsDeallocateLfcb (
    IN PLFCB Lfcb,
    IN BOOLEAN CompleteTeardown
    );

VOID
LfsAllocateLbcb (
    IN PLFCB Lfcb,
    OUT PLBCB *Lbcb
    );

VOID
LfsDeallocateLbcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    );

VOID
LfsAllocateLeb (
    IN PLFCB Lfcb,
    OUT PLEB *NewLeb
    );

VOID
LfsDeallocateLeb (
    IN PLFCB Lfcb,
    IN PLEB Leb
    );

VOID
LfsReadPage (
    IN PLFCB Lfcb,
    IN PLARGE_INTEGER Offset,
    OUT PMDL *Mdl,
    OUT PVOID *Buffer
    );

//
//  VOID
//  LfsInitializeLeb (
//      IN PLEB Leb,
//      IN LFS_CLIENT_ID ClientId,
//      IN LFS_CONTEXT_MODE ContextMode
//      );
//
//
//  VOID
//  LfsAllocateLch (
//      OUT PLCH *Lch
//      );
//
//  VOID
//  LfsDeallocateLch (
//      IN PLCH Lch
//      );
//
//  VOID
//  LfsAllocateRestartArea (
//      OUT PLFS_RESTART_AREA *RestartArea,
//      ULONG Size
//      );
//
//  VOID
//  LfsDeallocateRestartArea (
//      IN PLFS_RESTART_AREA RestartArea
//      );
//
//  BOOLEAN
//  LfsLbcbIsRestart (
//      IN PLBCB Lbcb
//      );
//

#define LfsInitializeLeb(LEB,ID,MODE)                           \
    (LEB)->ClientId = ID;                                       \
    (LEB)->ContextMode = MODE


#define LfsAllocateLch(NEW)     {                               \
    *(NEW) = FsRtlAllocatePool( PagedPool, sizeof( LCH ));      \
    RtlZeroMemory( (*NEW), sizeof( LCH ));                      \
    (*(NEW))->NodeTypeCode = LFS_NTC_LCH;                       \
    (*(NEW))->NodeByteSize = sizeof( LCH );                     \
}

#define LfsDeallocateLch(LCH)                                   \
    ExFreePool( LCH )

#define LfsAllocateRestartArea(RS,SIZE)                         \
    *(RS) = FsRtlAllocatePool( PagedPool, (SIZE) );             \
    RtlZeroMemory( *(RS), (SIZE) )

#define LfsDeallocateRestartArea(RS)                            \
    ExFreePool( RS )

#define LfsLbcbIsRestart(LBCB)                                  \
    (FlagOn( (LBCB)->LbcbFlags, LBCB_RESTART_LBCB ))


//
//  The following routines provide synchronization support for the Lfs
//  shared structures.  They are contained in 'SyncSup.c'
//

//
//  VOID
//  LfsAcquireLfsData (
//      );
//
//  VOID
//  LfsReleaseLfsData (
//      );
//
//  VOID
//  LfsAcquireLfcb (
//      IN PLFCB Lfcb
//      );
//
//  VOID
//  LfsReleaseLfcb (
//      IN PLFCB Lfcb
//      );
//
//  VOID
//  LfsAcquireLch (
//      IN PLCH Lch
//      );
//
//  VOID
//  LfsReleaseLfcb (
//      IN PLCH Lch
//      );
//

#define LfsAcquireLfsData()                                 \
    ExAcquireFastMutex( &LfsData.LfsDataLock )

#define LfsReleaseLfsData()                                 \
    ExReleaseFastMutex( &LfsData.LfsDataLock )

#define LfsAcquireBufferLock()                              \
    ExAcquireFastMutex( &LfsData.BufferLock )

#define LfsReleaseBufferLock()                              \
    ExReleaseFastMutex( &LfsData.BufferLock )

#define LfsWaitForBufferNotification()                      \
    KeWaitForSingleObject( &LfsData.BufferNotification,     \
                           Executive,                       \
                           KernelMode,                      \
                           FALSE,                           \
                           NULL )

#define LfsNotifyBufferWaiters()                            \
    KeSetEvent( &LfsData.BufferNotification, 0, FALSE )

#define LfsBlockBufferWaiters()                             \
    KeClearEvent( &LfsData.BufferNotification )

INLINE
VOID
LfsAcquireLfcb (
    IN PLFCB Lfcb
    )
{
    ExAcquireResourceExclusiveLite( &Lfcb->Sync->Resource, TRUE );
}

INLINE
VOID
LfsReleaseLfcb (
    IN PLFCB Lfcb
    )
{
    if (Lfcb->Sync->Resource.OwnerThreads[0].OwnerThread == ExGetCurrentResourceThread()) {
        ExReleaseResourceLite( &Lfcb->Sync->Resource );
    }
}

INLINE
VOID
LfsAcquireLch (
    IN PLCH Lch
    )
{
    ExAcquireResourceExclusiveLite( &(Lch->Sync->Resource), TRUE );
}

INLINE
VOID
LfsReleaseLch (
    IN PLCH Lch
    )
{
    if (Lch->Sync->Resource.OwnerThreads[0].OwnerThread == ExGetCurrentResourceThread()) {
        ExReleaseResourceLite( &Lch->Sync->Resource );
    }
}



//
//  The following routines are used to check various structures for validity
//  and comparability.  They are contained in 'VerfySup.c'.
//

VOID
LfsCurrentAvailSpace (
    IN PLFCB Lfcb,
    OUT PLONGLONG CurrentAvailSpace,
    OUT PULONG CurrentPageBytes
    );

BOOLEAN
LfsVerifyLogSpaceAvail (
    IN PLFCB Lfcb,
    IN PLCH Lch,
    IN ULONG RemainingLogBytes,
    IN LONG UndoRequirement,
    IN BOOLEAN ForceToDisk
    );

VOID
LfsFindCurrentAvail (
    IN PLFCB Lfcb
    );

BOOLEAN
LfsCheckSubsequentLogPage (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_PAGE_HEADER RecordPageHeader,
    IN LONGLONG LogFileOffset,
    IN LONGLONG SequenceNumber
    );


//
//  VOID
//  LfsValidateLch (
//      IN PLCH Lch
//      );
//
//  VOID
//  LfsValidateClientId (
//      IN PLFCB Lfcb,
//      IN PLCH Lch
//      );
//
//  BOOLEAN
//  LfsVerifyClientLsnInRange (
//      IN PLFCB Lfcb,
//      IN PLFS_CLIENT_RECORD ClientRecord,
//      IN LSN Lsn
//      );
//
//  BOOLEAN
//  LfsClientIdMatch (
//      IN PLFS_CLIENT_ID ClientA,
//      IN PLFS_CLIENT_ID ClientB
//      )
//
//  VOID
//  LfsValidateLeb (
//      IN PLFS_CONTEXT_BLOCK Leb,
//      IN PLCH Lch
//      )
//

#define LfsValidateLch(LCH)                                     \
    if ((LCH) == NULL                                           \
        || (LCH)->NodeTypeCode != LFS_NTC_LCH                   \
        || ((LCH)->Lfcb != NULL                                 \
            && (LCH)->Lfcb->NodeTypeCode != LFS_NTC_LFCB)) {    \
                                                                \
        ExRaiseStatus( STATUS_ACCESS_DENIED );                  \
    }

#define LfsValidateClientId(LFCB,LCH)                                   \
    if ((LCH)->ClientId.ClientIndex >= (LFCB)->RestartArea->LogClients  \
        || (LCH)->ClientId.SeqNumber                                    \
           != Add2Ptr( Lfcb->ClientArray,                               \
                       (LCH)->ClientArrayByteOffset,                    \
                       PLFS_CLIENT_RECORD )->SeqNumber) {               \
        ExRaiseStatus( STATUS_ACCESS_DENIED );                          \
    }

#define LfsVerifyClientLsnInRange(LFCB,CLIENT,LSN)                      \
    (/*xxGeq*/( (LSN).QuadPart >= ((CLIENT)->OldestLsn).QuadPart )                                  \
     && /*xxLeq*/( (LSN).QuadPart <= ((LFCB)->RestartArea->CurrentLsn).QuadPart )                   \
     && /*xxNeqZero*/( (LSN).QuadPart != 0 ))

#define LfsClientIdMatch(CLIENT_A,CLIENT_B)                             \
    ((BOOLEAN) ((CLIENT_A)->SeqNumber == (CLIENT_B)->SeqNumber          \
                && (CLIENT_A)->ClientIndex == (CLIENT_B)->ClientIndex))

#define LfsValidateLeb(LEB,LCH)                                         \
    if (LEB == NULL                                                     \
        || (LEB)->NodeTypeCode != LFS_NTC_LEB                           \
        || !LfsClientIdMatch( &(LEB)->ClientId, &(LCH)->ClientId )) {   \
        ExRaiseStatus( STATUS_ACCESS_DENIED );                          \
    }


//
//  Miscellaneous support routines
//

//
//      ULONG
//      FlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      BOOLEAN
//      BooleanFlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      SetFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      ClearFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (    \
//    (BOOLEAN)(((F) & (SF)) != 0) \
//)
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  This macro will up a 64 bit value to the next quad align boundary.
//

#define LiQuadAlign(LI,OUT)   {         \
    *(OUT) = /*xxAdd*/( (LI) + 7 );       \
    *((PULONG)(OUT)) &= 0xfffffff8;       \
}

//
//      CAST
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          IN (CAST)
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define Add2Ptr(PTR,INC,CAST) ((CAST)((PUCHAR)(PTR) + (INC)))

#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG_PTR)(OFFSET) - (ULONG_PTR)(BASE)))


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

#endif // _LFSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\logpgsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LogPgSup.c

Abstract:

    This module implements support for manipulating log pages.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOG_PAGE_SUP)

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('PsfL')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsAllocateSpanningBuffer)
#pragma alloc_text(PAGE, LfsFreeSpanningBuffer)
#pragma alloc_text(PAGE, LfsNextLogPageOffset)
#endif


VOID
LfsNextLogPageOffset (
    IN PLFCB Lfcb,
    IN LONGLONG CurrentLogPageOffset,
    OUT PLONGLONG NextLogPageOffset,
    OUT PBOOLEAN Wrapped
    )

/*++

Routine Description:

    This routine will compute the offset in the log file of the next log
    page.

Arguments:

    Lfcb - This is the file control block for the log file.

    CurrentLogPageOffset - This is the file offset of the current log page.

    NextLogPageOffset - Address to store the next log page to use.

    Wrapped - This is a pointer to a boolean variable that, if present,
              we use to indicate whether we wrapped in the log file.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsNextLogPageOffset:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb                          ->  %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "CurrentLogPageOffset (Low)    ->  %08lx\n", CurrentLogPageOffset.LowPart );
    DebugTrace(  0, Dbg, "CurrentLogPageOffset (High)   ->  %08lx\n", CurrentLogPageOffset.HighPart );
    DebugTrace(  0, Dbg, "Wrapped                       ->  %08lx\n", Wrapped );

    //
    //  We add the log page size to the current log offset.
    //

    LfsTruncateOffsetToLogPage( Lfcb, CurrentLogPageOffset, &CurrentLogPageOffset );
    *NextLogPageOffset = CurrentLogPageOffset + Lfcb->LogPageSize;                                                     //**** xxAdd( CurrentLogPageOffset, Lfcb->LogPageSize );

    //
    //  If the result is larger than the file, we use the first page offset
    //  in the file.
    //

    if ( *NextLogPageOffset >= Lfcb->FileSize ) {                                                                      //**** xxGeq( *NextLogPageOffset, Lfcb->FileSize )

        *NextLogPageOffset = Lfcb->FirstLogPage;

        *Wrapped = TRUE;

    } else {

        *Wrapped = FALSE;
    }

    DebugTrace(  0, Dbg, "NextLogPageOffset (Low)    ->  %08lx\n", NextLogPageOffset->LowPart );
    DebugTrace(  0, Dbg, "NextLogPageOffset (High)   ->  %08lx\n", NextLogPageOffset->HighPart );
    DebugTrace(  0, Dbg, "Wrapped                    ->  %08x\n", *Wrapped );
    DebugTrace( -1, Dbg, "LfsNextLogPageOffset:  Exit\n", 0 );

    return;
}


PVOID
LfsAllocateSpanningBuffer (
    IN PLFCB Lfcb,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is called to allocate a spare buffer to read a file record
    which spans a log page.  We will first try to allocate one.  If that
    fails we will use one of the existing spare buffers.  If that fails then
    we will raise.

Arguments:

    Lfcb - This is the file control block for the log file.

    Length - Length of the buffer required.

Return Value:

    PVOID - Pointer to the buffer to use for reading the log record.
        May be either from pool or from the auxilary buffer pool.

--*/

{
    PVOID NewBuffer = NULL;
    ERESOURCE_THREAD Thread;
    BOOLEAN Wait = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsAllocateSpanningBuffer:  Entered\n", 0 );

    //
    //  Loop while we don't have a buffer.  First try to get our reserved buffer
    //  without waiting.  Then try to allocate a buffer.  Finally wait for the reserved
    //  buffer as the final alternative.
    //

    do {

        //
        //  Skip the reserved buffer if the request is larger than we can read into it.
        //

        if (Length <= LFS_BUFFER_SIZE) {

            //
            //  If this thread already owns one buffer it can get the second directly.
            //

            Thread = ExGetCurrentResourceThread();

            if (Thread == LfsData.BufferOwner) {

                if (!FlagOn( LfsData.BufferFlags, LFS_BUFFER1_OWNED )) {

                    SetFlag( LfsData.BufferFlags, LFS_BUFFER1_OWNED );
                    NewBuffer = LfsData.Buffer1;
                    break;

                } else if (!FlagOn( LfsData.BufferFlags, LFS_BUFFER2_OWNED )) {

                    SetFlag( LfsData.BufferFlags, LFS_BUFFER2_OWNED );
                    NewBuffer = LfsData.Buffer2;
                    break;

                } else if (Wait) {

                    //
                    //  This shouldn't happen but handle anyway.
                    //

                    DebugTrace( -1, Dbg, "LfsAllocateSpanningBuffer:  Exit\n", 0 );
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

            //
            //  Otherwise acquire the buffer lock and check the state of the buffers.
            //

            } else {

                BOOLEAN LfcbOwned = TRUE;

                while (TRUE) {

                    LfsAcquireBufferLock();

                    //
                    //  Check to see if the buffers are available.  No
                    //  need to drop the Lfcb in the typical case.
                    //

                    if (LfsData.BufferOwner == (ERESOURCE_THREAD) NULL) {

                        ASSERT( !FlagOn( LfsData.BufferFlags, LFS_BUFFER1_OWNED | LFS_BUFFER2_OWNED ));
                        NewBuffer = LfsData.Buffer1;
                        LfsData.BufferOwner = Thread;
                        SetFlag( LfsData.BufferFlags, LFS_BUFFER1_OWNED );
                        LfsBlockBufferWaiters();
                        
                        //
                        //  Reacquire the Lfcb if needed.
                        //

                        if (!LfcbOwned) { 

                            LfsAcquireLfcb( Lfcb );
                        }

                        //
                        //  Break out.
                        //

                        LfsReleaseBufferLock();
                        break;
                    }

                    //
                    //  Release the Lfcb and wait on the notification for the buffers.
                    //

                    if (Wait) {

                        if (LfcbOwned) { 
                            LfsReleaseLfcb( Lfcb );
                            LfcbOwned = FALSE;
                        }

                        LfsReleaseBufferLock();
                        LfsWaitForBufferNotification();

                    } else {

                        //
                        //  Go ahead and try to allocate a buffer from pool next.
                        //

                        LfsReleaseBufferLock();
                        break;
                    }
                }
            }

        //
        //  Raise if we already tried the allocate path.
        //

        } else if (Wait) {

            DebugTrace( -1, Dbg, "LfsAllocateSpanningBuffer:  Exit\n", 0 );
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Try pool if we didn't get a buffer above.
        //

        if (NewBuffer == NULL) {

            //
            //  Try pool next but don't let this fail on pool allocation.
            //

            NewBuffer = LfsAllocatePoolNoRaise( PagedPool, Length );
        }

        //
        //  Wait on the next pass through the loop.
        //

        Wait = TRUE;

    } while (NewBuffer == NULL);

    DebugTrace( -1, Dbg, "LfsAllocateSpanningBuffer:  Exit\n", 0 );
    return NewBuffer;
}

VOID
LfsFreeSpanningBuffer (
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine is called to free a buffer used to read a log record
    which spans pages.  We will check if it is one of our special buffers
    and deal with synchronization in that case.

Arguments:

    Buffer - Buffer to free.

Return Value:

    None.

--*/

{
    ERESOURCE_THREAD Thread;
    ULONG BufferFlag;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFreeSpanningBuffer:  Entered\n", 0 );

    //
    //  Check if either buffer1 or buffer2 are being freed.
    //

    if (Buffer == LfsData.Buffer1) {

        BufferFlag = LFS_BUFFER1_OWNED;
        goto ReservedBuffers;

    } else if (Buffer == LfsData.Buffer2) {

        BufferFlag = LFS_BUFFER2_OWNED;

ReservedBuffers:

        //
        //  Acquire the buffer lock and clear the correct flag.
        //

        LfsAcquireBufferLock();
        ClearFlag( LfsData.BufferFlags, BufferFlag );

        //
        //  If no buffers owned then signal the waiters.
        //

        if (!FlagOn( LfsData.BufferFlags, LFS_BUFFER1_OWNED | LFS_BUFFER2_OWNED )) {

            LfsData.BufferOwner = (ERESOURCE_THREAD) NULL;
            LfsNotifyBufferWaiters();
        }

        LfsReleaseBufferLock();

    } else {

        //
        //  Simply free the buffer.
        //

        LfsFreePool( Buffer );
    }

    DebugTrace( -1, Dbg, "LfsFreeSpanningBuffer:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\lsnsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LsnSup.c

Abstract:

    This module implements support for manipulating Lsn's.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LSN_SUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsFindNextLsn)
#pragma alloc_text(PAGE, LfsLsnFinalOffset)
#endif


VOID
LfsLsnFinalOffset (
    IN PLFCB Lfcb,
    IN LSN Lsn,
    IN ULONG DataLength,
    OUT PLONGLONG FinalOffset
    )

/*++

Routine Description:

    This routine will compute the final offset of the last byte of the log
    record.  It does this by computing how many bytes are on the current
    page and then computing how many more pages will be needed.

Arguments:

    Lfcb - This is the file control block for the log file.

    Lsn - This is the log record being considered.

    DataLength - This is the length of the data for this log record.  We will add the
        header length here.

    FinalOffset - Address to store the result.

Return Value:

    None.

--*/

{
    ULONG RemainingPageBytes;
    ULONG PageOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsLsnFinalOffset:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          ->  %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lsn (Low)     ->  %08lx\n", Lsn.LowPart );
    DebugTrace(  0, Dbg, "Lsn (High)    ->  %08lx\n", Lsn.HighPart );
    DebugTrace(  0, Dbg, "DataLength    ->  %08lx\n", DataLength );

    //
    //  We compute the starting log page file offset, the number of bytes
    //  remaining in the current log page and the position on this page
    //  before any data bytes.
    //

    LfsTruncateLsnToLogPage( Lfcb, Lsn, FinalOffset );

    PageOffset = LfsLsnToPageOffset( Lfcb, Lsn );

    RemainingPageBytes = (ULONG)Lfcb->LogPageSize - PageOffset;

    PageOffset -= 1;

    //
    //  Add the length of the header.
    //

    DataLength += Lfcb->RecordHeaderLength;

    //
    //  If this Lsn is contained in this log page we are done.
    //  Otherwise we need to walk through several log pages.
    //

    if (DataLength > RemainingPageBytes) {

        DataLength -= RemainingPageBytes;

        RemainingPageBytes = (ULONG)Lfcb->LogPageDataSize;

        PageOffset = (ULONG)Lfcb->LogPageDataOffset - 1;

        while (TRUE) {

            BOOLEAN Wrapped;

            LfsNextLogPageOffset( Lfcb, *FinalOffset, FinalOffset, &Wrapped );

            //
            //  We are done if the remaining bytes fit on this page.
            //

            if (DataLength <= RemainingPageBytes) {

                break;
            }

            DataLength -= RemainingPageBytes;
        }
    }

    //
    //  We add the remaining bytes to our starting position on this page
    //  and then add that value to the file offset of this log page.
    //

    *(PULONG)FinalOffset += (DataLength + PageOffset);

    DebugTrace(  0, Dbg, "FinalOffset (Low)     ->  %08lx\n", LogPageFileOffset.LowPart );
    DebugTrace(  0, Dbg, "FinalOffset (High)    ->  %08lx\n", LogPageFileOffset.HighPart );
    DebugTrace( -1, Dbg, "LfsLsnFinalOffset:  Exit\n", 0 );

    return;
}


BOOLEAN
LfsFindNextLsn (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_HEADER RecordHeader,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine takes as a starting point the log record header of an
    Lsn in the log file.  It searches for the next Lsn in the file and
    returns that value in the 'Lsn' argument.  The boolean return value
    indicates whether there is another Lsn in the file.

Arguments:

    Lfcb - This is the file control block for the log file.

    RecordHeader - This is the log record for the Lsn starting point.

    Lsn - This supplies the address to store the next Lsn, if found.

Return Value:

    BOOLEAN - Indicates whether the next Lsn was found.

--*/

{
    BOOLEAN FoundNextLsn;

    LONGLONG LsnOffset;
    LONGLONG EndOfLogRecord;
    LONGLONG LogHeaderOffset;

    LONGLONG SequenceNumber;

    PLFS_RECORD_PAGE_HEADER LogRecordPage;
    PBCB LogRecordPageBcb;
    BOOLEAN UsaError;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindNextLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Record Header -> %08lx\n", RecordHeader );

    LogRecordPageBcb = NULL;
    FoundNextLsn = FALSE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Find the file offset of the log page which contains the end
        //  of the log record for this Lsn.
        //

        LsnOffset = LfsLsnToFileOffset( Lfcb, RecordHeader->ThisLsn );

        LfsLsnFinalOffset( Lfcb,
                           RecordHeader->ThisLsn,
                           RecordHeader->ClientDataLength,
                           &EndOfLogRecord );

        LfsTruncateOffsetToLogPage( Lfcb, EndOfLogRecord, &LogHeaderOffset );

        //
        //  Remember the sequence number for this page.
        //

        SequenceNumber = LfsLsnToSeqNumber( Lfcb, RecordHeader->ThisLsn );

        //
        //  Remember if we wrapped.
        //

        if ( EndOfLogRecord <= LsnOffset ) {                                                                           //**** xxLeq( EndOfLogRecord, LsnOffset )

            SequenceNumber = SequenceNumber + 1;                                                                       //**** xxAdd( SequenceNumber, LfsLi1 );
        }

        //
        //  Pin the log page header for this page.
        //

        LfsPinOrMapData( Lfcb,
                         LogHeaderOffset,
                         (ULONG)Lfcb->LogPageSize,
                         FALSE,
                         FALSE,
                         FALSE,
                         &UsaError,
                         (PVOID *)&LogRecordPage,
                         &LogRecordPageBcb );

        //
        //  If the Lsn we were given was not the last Lsn on this page, then
        //  the starting offset for the next Lsn is on a quad word boundary
        //  following the last file offset for the current Lsn.  Otherwise
        //  the file offset is the start of the data on the next page.
        //

        if ( RecordHeader->ThisLsn.QuadPart == LogRecordPage->Copy.LastLsn.QuadPart ) {                                //**** xxEql( RecordHeader->ThisLsn, LogRecordPage->Copy.LastLsn )

            BOOLEAN Wrapped;

            LfsNextLogPageOffset( Lfcb,
                                  LogHeaderOffset,
                                  &LogHeaderOffset,
                                  &Wrapped );

            LsnOffset = LogHeaderOffset + Lfcb->LogPageDataOffset;                                                     //**** xxAdd( LogHeaderOffset, Lfcb->LogPageDataOffset );

            //
            //  If we wrapped, we need to increment the sequence number.
            //

            if (Wrapped) {

                SequenceNumber = SequenceNumber + 1;                                                                   //**** xxAdd( SequenceNumber, LfsLi1 );
            }

        } else {

            LiQuadAlign( EndOfLogRecord, &LsnOffset );
        }

        //
        //  Compute the Lsn based on the file offset and the sequence count.
        //

        Lsn->QuadPart = LfsFileOffsetToLsn( Lfcb, LsnOffset, SequenceNumber );

        //
        //  If this Lsn is within the legal range for the file, we return TRUE.
        //  Otherwise FALSE indicates that there are no more Lsn's.
        //

        if (LfsIsLsnInFile( Lfcb, *Lsn )) {

            FoundNextLsn = TRUE;
        }

    } finally {

        DebugUnwind( LfsFindNextLsn );

        //
        //  Unpin the log page header if held.
        //

        if (LogRecordPageBcb != NULL) {

            CcUnpinData( LogRecordPageBcb );
        }

        DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsFindNextLsn:  Exit -> %08x\n", FoundNextLsn );
    }

    return FoundNextLsn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\logrcsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    LogRcSup.c

Abstract:

    This module implements support for dealing with log records, both
    writing and recovering them.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOG_RECORD_SUP)

VOID
LfsPrepareLfcbForLogRecord (
    IN OUT PLFCB Lfcb,
    IN ULONG RemainingLogBytes
    );

VOID
LfsTransferLogBytes (
    IN PLBCB Lbcb,
    IN OUT PLFS_WRITE_ENTRY *ThisWriteEntry,
    IN OUT PCHAR *CurrentBuffer,
    IN OUT PULONG CurrentByteCount,
    IN OUT PULONG PadBytes,
    IN OUT PULONG RemainingPageBytes,
    IN OUT PULONG RemainingLogBytes
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsPrepareLfcbForLogRecord)
#pragma alloc_text(PAGE, LfsTransferLogBytes)
#pragma alloc_text(PAGE, LfsWriteLogRecordIntoLogPage)
#endif


BOOLEAN
LfsWriteLogRecordIntoLogPage (
    IN PLFCB Lfcb,
    IN PLCH Lch,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId OPTIONAL,
    IN LSN ClientUndoNextLsn OPTIONAL,
    IN LSN ClientPreviousLsn OPTIONAL,
    IN LONG UndoRequirement,
    IN BOOLEAN ForceToDisk,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called to write a log record into the log file
    using the cache manager.  If there is room in the current log
    page it is added to that.  Otherwise we allocate a new log page
    and write the log record header for this log page.  We then
    write the log record into the remaining bytes of this page and
    into any subsequent pages if needed.

Arguments:

    Lfcb - File control block for this log file.

    Lch - This is the client handle, we may update the undo space for this
          client.

    NumberOfWriteEntries - Number of components of the log record.

    WriteEntries - Pointer to an array of write entries.

    UndoRequirement - Signed value indicating the requirement to write
                      an abort log record for this log record.  A negative
                      value indicates that this is the abort record.

    RecordType - The Lfs-defined type of this log record.

    TransactionId - Pointer to the transaction structure containing the
                    Id for transaction containing this operation.

    ClientUndoNextLsn - This is the Lsn provided by the client for use
                        in his restart.  Will be the zero Lsn for
                        a restart log record.

    ClientPreviousLsn - This is the Lsn provided by the client for use
                        in his restart.  Will the the zero Lsn for a
                        restart log record.

    UndoRequirement - This is the data size for the undo record for
                      this log record.

    ForceToDisk - Indicates if this log record will be flushed immediately
                  to disk.

    Lsn - A pointer to store the Lsn for this log record.

Return Value:

    BOOLEAN - Advisory, TRUE indicates that less than 1/4 of the log file is
        available.

--*/

{
    PLFS_WRITE_ENTRY ThisWriteEntry;

    ULONG RemainingLogBytes;
    ULONG OriginalLogBytes;

    ULONG RemainingPageBytes;
    ULONG HeaderAdjust;

    PLBCB ThisLbcb;

    LSN NextLsn;

    PLFS_RECORD_HEADER RecordHeader;

    PCHAR CurrentBuffer;
    ULONG CurrentByteCount;
    ULONG PadBytes;

    BOOLEAN LogFileFull = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsWriteLogRecordIntoLogPage:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb                      -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Lch                       -> %08lx\n", Lch );
    DebugTrace(  0, Dbg, "Number of Write Entries   -> %08lx\n", NumberOfWriteEntries );
    DebugTrace(  0, Dbg, "Write Entries             -> %08lx\n", WriteEntries );
    DebugTrace(  0, Dbg, "Record Type               -> %08lx\n", RecordType );
    DebugTrace(  0, Dbg, "Transaction Id            -> %08lx\n", TransactionId );
    DebugTrace(  0, Dbg, "ClientUndoNextLsn (Low)   -> %08lx\n", ClientUndoNextLsn.LowPart );
    DebugTrace(  0, Dbg, "ClientUndoNextLsn (High)  -> %08lx\n", ClientUndoNextLsn.HighPart );
    DebugTrace(  0, Dbg, "ClientPreviousLsn (Low)   -> %08lx\n", ClientPreviousLsn.LowPart );
    DebugTrace(  0, Dbg, "ClientPreviousLsn (High)  -> %08lx\n", ClientPreviousLsn.HighPart );
    DebugTrace(  0, Dbg, "UndoRequirement           -> %08lx\n", UndoRequirement );
    DebugTrace(  0, Dbg, "ForceToDisk               -> %04x\n", ForceToDisk );

    //
    //  We'd absolutely hate for this to happen on a read only volume.
    //

    ASSERT(!(FlagOn( Lfcb->Flags, LFCB_READ_ONLY )));

    //
    //  We compute the size of this log record.
    //

    ThisWriteEntry = WriteEntries;

    RemainingLogBytes = 0;

    while (NumberOfWriteEntries--) {

        RemainingLogBytes += QuadAlign( ThisWriteEntry->ByteLength );

        ThisWriteEntry++;
    }

    OriginalLogBytes = RemainingLogBytes;

    ThisWriteEntry = WriteEntries;

    //
    //  Loop until we have the Lbcb and we know it is not part of
    //  a partial page transfer.  We need to make sure we have
    //  a Bcb for this page.
    //

    while (TRUE) {

        LogFileFull = LfsVerifyLogSpaceAvail( Lfcb,
                                              Lch,
                                              RemainingLogBytes,
                                              UndoRequirement,
                                              ForceToDisk );

        //
        //  We update the Lfcb so that we can start putting the log record into
        //  the top of the Lbcb active list.
        //

        LfsPrepareLfcbForLogRecord( Lfcb,
                                    RemainingLogBytes + Lfcb->RecordHeaderLength );

        ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                      LBCB,
                                      ActiveLinks );

#ifdef BENL_DBG
        ASSERT( ThisLbcb->BufferOffset < 0x1000 );
#endif

        //
        //  If there is a Bcb then we are golden.
        //

        if (ThisLbcb->LogPageBcb != NULL) { break; }

        //
        //  Otherwise we want to drop the Lfcb and wait for the IO to complete.
        //

        Lfcb->Waiters += 1;

        LfsReleaseLfcb( Lfcb );

        KeWaitForSingleObject( &Lfcb->Sync->Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        LfsAcquireLfcb( Lfcb );
        Lfcb->Waiters -= 1;
    }

    RemainingPageBytes = (ULONG)Lfcb->LogPageSize - (ULONG)ThisLbcb->BufferOffset;

    //
    //  Compute the Lsn starting in the next log buffer.
    //

    NextLsn.QuadPart = LfsComputeLsnFromLbcb( Lfcb, ThisLbcb );

    //
    //  We get a pointer to the log record header and the start of the
    //  log record in the pinned buffer.
    //

    RecordHeader = Add2Ptr( ThisLbcb->PageHeader,
                            (ULONG)ThisLbcb->BufferOffset,
                            PLFS_RECORD_HEADER );

    //
    //  We update the record header.
    //

    //
    //  Zero out the structure initially.
    //

    RtlZeroMemory( RecordHeader, Lfcb->RecordHeaderLength );

    //
    //  Update all the fields.
    //

    RecordHeader->ThisLsn = NextLsn;
    RecordHeader->ClientPreviousLsn = ClientPreviousLsn;
    RecordHeader->ClientUndoNextLsn = ClientUndoNextLsn;

    if (TransactionId != NULL) {
        RecordHeader->TransactionId = *TransactionId;
    }

    RecordHeader->ClientDataLength = RemainingLogBytes;
    RecordHeader->ClientId = Lch->ClientId;
    RecordHeader->RecordType = RecordType;

    //
    //  Check if this is a multi-page record.
    //

    if (RemainingLogBytes + Lfcb->RecordHeaderLength > RemainingPageBytes) {

        SetFlag( RecordHeader->Flags, LOG_RECORD_MULTI_PAGE );
    }

    RemainingPageBytes -= Lfcb->RecordHeaderLength;

    //
    //  Update the buffer position in the Lbcb
    //

    (ULONG)ThisLbcb->BufferOffset += Lfcb->RecordHeaderLength;
    HeaderAdjust = Lfcb->RecordHeaderLength;

    //
    //  Remember the values in the current write entry.
    //

    CurrentBuffer = ThisWriteEntry->Buffer;
    CurrentByteCount = ThisWriteEntry->ByteLength;

    PadBytes = (8 - (CurrentByteCount & ~(0xfffffff8))) & ~(0xfffffff8);

    //
    //  Continue to transfer bytes until all the client's data has
    //  been transferred.
    //

    while (RemainingLogBytes != 0) {

        PLFS_RECORD_PAGE_HEADER PageHeader;

        PageHeader = (PLFS_RECORD_PAGE_HEADER) ThisLbcb->PageHeader;

        //
        //  If the Lbcb is empty and we are about to store data into it we
        //  subtract the data size of the page from the available space.
        //  Update all the information we want to put in the header.
        //

        if (!FlagOn( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY )) {

            //
            //  We subtract this page from the available pages only if
            //  we are at the beginning of the page.  Otherwise this
            //  could be a reuse page.  In that case it has already
            //  been subtracted.
            //

            if ((ULONG)ThisLbcb->BufferOffset - HeaderAdjust == (ULONG)Lfcb->LogPageDataOffset) {


                Lfcb->CurrentAvailable = Lfcb->CurrentAvailable - Lfcb->ReservedLogPageSize;                           //**** xxSub( Lfcb->CurrentAvailable, Lfcb->ReservedLogPageSize );
            }

            InsertTailList( &Lfcb->LbcbWorkque, &ThisLbcb->WorkqueLinks );
            SetFlag( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY );
        }

        HeaderAdjust = 0;

        //
        //  Compute the number of transfer bytes.  Update the remaining
        //  page bytes, remaining log bytes and position in the write
        //  buffer array.  This routine also copies the bytes into the buffer.
        //

        LfsTransferLogBytes( ThisLbcb,
                             &ThisWriteEntry,
                             &CurrentBuffer,
                             &CurrentByteCount,
                             &PadBytes,
                             &RemainingPageBytes,
                             &RemainingLogBytes );

        //
        //  This log record ends on this page.  Update the fields for the
        //  ending Lsn.
        //

        if (RemainingLogBytes == 0) {

            SetFlag( ThisLbcb->Flags, LOG_PAGE_LOG_RECORD_END );
            ThisLbcb->LastEndLsn = NextLsn;

            if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

                PageHeader->Header.Packed.LastEndLsn = NextLsn;
                PageHeader->Header.Packed.NextRecordOffset = (USHORT)ThisLbcb->BufferOffset;
            }
        }

        //
        //  We are done with this page, update the fields in the page header.
        //

        if (RemainingPageBytes == 0
            || RemainingLogBytes == 0) {

            //
            //  We are done with this page.  Update the Lbcb and page header.
            //

            ThisLbcb->LastLsn = NextLsn;
            PageHeader->Copy.LastLsn = NextLsn;
            PageHeader->Flags = ThisLbcb->Flags;

            //
            //  We can't put any more log records on this page.  Remove
            //  it from the active queue.
            //

            if (RemainingPageBytes < Lfcb->RecordHeaderLength) {

                RemoveHeadList( &Lfcb->LbcbActive );
                ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );

                //
                //  If there are more log bytes then get the next Lbcb.
                //

                if (RemainingLogBytes != 0) {

                    ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                                  LBCB,
                                                  ActiveLinks );

                    RemainingPageBytes = (ULONG)Lfcb->LogPageSize
                                         - (ULONG)ThisLbcb->BufferOffset;
                }
            }
        }
    }

    *Lsn = NextLsn;

    Lfcb->RestartArea->CurrentLsn = NextLsn;

    Lfcb->RestartArea->LastLsnDataLength = OriginalLogBytes;

    ClearFlag( Lfcb->Flags, LFCB_NO_LAST_LSN );

    DebugTrace(  0, Dbg, "Lsn (Low)   -> %08lx\n", Lsn->LowPart );
    DebugTrace(  0, Dbg, "Lsn (High)  -> %08lx\n", Lsn->HighPart );
    DebugTrace( -1, Dbg, "LfsWriteLogRecordIntoLogPage:  Exit\n", 0 );

    return LogFileFull;
}


//
//  Local support routine.
//

VOID
LfsPrepareLfcbForLogRecord (
    IN OUT PLFCB Lfcb,
    IN ULONG RemainingLogBytes
    )

/*++

Routine Description:

    This routine is called to insure that the Lfcb has a Lbcb in the
    active queue to perform the next log record transfer.
    This condition is met when there is a least one buffer block and
    the log record data will fit entirely on this page or this buffer
    block contains no other data in the unpacked case.  For the packed
    case we just need to make sure that there are sufficient Lbcb's.

Arguments:

    Lfcb - File control block for this log file.

    RemainingLogBytes - The number of bytes remaining for this log record.

Return Value:

    None

--*/

{
    PLBCB ThisLbcb;
    ULONG RemainingPageBytes;
    PLIST_ENTRY LbcbLinks;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsPrepareLfcbForLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "RemainingLogBytes -> %08lx\n", RemainingLogBytes );

    //
    //  If there is no Lbcb in the active queue, we don't check it for size.
    //

    if (!IsListEmpty( &Lfcb->LbcbActive )) {

        //
        //  If the log record won't fit in the remaining bytes of this page,
        //  we queue this log buffer.
        //

        ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                      LBCB,
                                      ActiveLinks );

        RemainingPageBytes = (ULONG)Lfcb->LogPageSize
                             - (ULONG)ThisLbcb->BufferOffset;

        //
        //  This log page won't do if the remaining bytes won't hold the data
        //  unless this is the first log record in the page or we are packing
        //  the log file.
        //

        if (RemainingLogBytes > RemainingPageBytes
            && !FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
            && (ULONG)ThisLbcb->BufferOffset != (ULONG)Lfcb->LogPageDataOffset) {

            RemoveHeadList( &Lfcb->LbcbActive );
            ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );
        }
    }

    //
    //  We now make sure we can allocate enough Lbcb's for all of the log pages
    //  we will need.  We now include the bytes for the log record reader.
    //

    LbcbLinks = Lfcb->LbcbActive.Flink;

    while (TRUE) {

        //
        //  If the Lbcb link we have is the head of the list, we will need another
        //  Lbcb.
        //

        if (LbcbLinks == &Lfcb->LbcbActive) {

            ThisLbcb = LfsGetLbcb( Lfcb );

        } else {

            ThisLbcb = CONTAINING_RECORD( LbcbLinks,
                                          LBCB,
                                          ActiveLinks );
        }

        //
        //  Remember the bytes remaining on this page.  This will always be quad
        //  aligned.
        //

        RemainingPageBytes = (ULONG)Lfcb->LogPageSize - (ULONG)ThisLbcb->BufferOffset;

        if (RemainingPageBytes >= RemainingLogBytes) {

            break;
        }

        //
        //  Move to the next log record.
        //

        RemainingLogBytes -= RemainingPageBytes;

        LbcbLinks = ThisLbcb->ActiveLinks.Flink;
    }

    DebugTrace( -1, Dbg, "LfsPrepareLfcbForLogRecord:  Exit\n", 0 );

    return;
}


VOID
LfsTransferLogBytes (
    IN PLBCB Lbcb,
    IN OUT PLFS_WRITE_ENTRY *ThisWriteEntry,
    IN OUT PCHAR *CurrentBuffer,
    IN OUT PULONG CurrentByteCount,
    IN OUT PULONG PadBytes,
    IN OUT PULONG RemainingPageBytes,
    IN OUT PULONG RemainingLogBytes
    )

/*++

Routine Description:

    This routine is called to transfer the next block of bytes into
    a log page.  It is given a pointer to the current position in the
    current Lfs write entry and the number of bytes remaining on that
    log page.  It will transfer as many of the client's bytes from the
    current buffer that will fit and update various pointers.

Arguments:

    Lbcb - This is the buffer block for this log page.

    ThisWriteEntry - This is a pointer to a pointer to the current Lfs
                     write entry.

    CurrentBuffer - This is a pointer to a pointer to the current position
                    in the current write entry buffer.  If this points to a NULL
                    value it means to put zero bytes into the log.

    CurrentByteCount - This is a pointer to the number of bytes remaining
                       in the current buffer.

    PadBytes - This is a pointer to the number of padding byes for
        this write entry.

    RemainingPageBytes - This is pointer to the number of bytes remaining
                         in this page.

    RemainingLogBytes - This is the number of bytes remaining to transfer
                        for this log record.

Return Value:

    None

--*/

{
    PCHAR CurrentLogPagePosition;
    PCHAR CurrentClientPosition;

    ULONG TransferBytes;
    ULONG ThisPadBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsTransferLogBytes:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lbcb                      -> %08lx\n", Lbcb );
    DebugTrace(  0, Dbg, "ThisWriteEntry            -> %08lx\n", *ThisWriteEntry );
    DebugTrace(  0, Dbg, "CurrentBuffer             -> %08lx\n", *CurrentBuffer );
    DebugTrace(  0, Dbg, "CurrentByteCount          -> %08lx\n", *CurrentByteCount );
    DebugTrace(  0, Dbg, "RemainingPageBytes        -> %08lx\n", *RemainingPageBytes );
    DebugTrace(  0, Dbg, "RemainingLogBytes         -> %08lx\n", *RemainingLogBytes );

    //
    //  Remember the current client buffer position and current position
    //  in log page.
    //

    CurrentLogPagePosition = Add2Ptr( Lbcb->PageHeader, (ULONG)Lbcb->BufferOffset, PCHAR );
    CurrentClientPosition = *CurrentBuffer;

    //
    //  The limiting factor is either the number of bytes remaining in a
    //  write entry or the number remaining in the log page.
    //

    if (*CurrentByteCount <= *RemainingPageBytes) {

        TransferBytes = *CurrentByteCount;

        ThisPadBytes = *PadBytes;

        if (*RemainingLogBytes != (*CurrentByteCount + *PadBytes) ) {

            (*ThisWriteEntry)++;

            *CurrentBuffer = (*ThisWriteEntry)->Buffer;
            *CurrentByteCount = (*ThisWriteEntry)->ByteLength;

            *PadBytes = (8 - (*CurrentByteCount & ~(0xfffffff8))) & ~(0xfffffff8);
        }

    } else {

        TransferBytes = *RemainingPageBytes;

        ThisPadBytes = 0;

        *CurrentByteCount -= TransferBytes;

        if (*CurrentBuffer != NULL) {

            *CurrentBuffer += TransferBytes;
        }
    }

    //
    //  Transfer the requested bytes.
    //

    if (CurrentClientPosition != NULL) {

        RtlCopyMemory( CurrentLogPagePosition, CurrentClientPosition, TransferBytes );

    } else {

        RtlZeroMemory( CurrentLogPagePosition, TransferBytes );
    }

    //
    //  Reduce the remaining page and log bytes by the transfer amount and
    //  move forward in the log page.
    //

    *RemainingLogBytes -= (TransferBytes + ThisPadBytes);
    *RemainingPageBytes -= (TransferBytes + ThisPadBytes);

    (ULONG)Lbcb->BufferOffset += (TransferBytes + ThisPadBytes);

    DebugTrace( -1, Dbg, "LfsTransferLogBytes:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\querylog.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    QueryLog.c

Abstract:

    This module implements the user routines which query for log records
    in a log file.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_QUERY)

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('QsfL')

VOID
LfsFindLogRecord (
    IN PLFCB Lfcb,
    IN OUT PLEB Leb,
    IN LSN Lsn,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    );

BOOLEAN
LfsFindClientNextLsn (
    IN PLFCB Lfcb,
    IN PLEB Leb,
    OUT PLSN Lsn
    );

BOOLEAN
LfsSearchForwardByClient (
    IN PLFCB Lfcb,
    IN OUT PLEB Leb,
    OUT PLSN Lsn
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsFindClientNextLsn)
#pragma alloc_text(PAGE, LfsFindLogRecord)
#pragma alloc_text(PAGE, LfsQueryLastLsn)
#pragma alloc_text(PAGE, LfsReadLogRecord)
#pragma alloc_text(PAGE, LfsReadNextLogRecord)
#pragma alloc_text(PAGE, LfsSearchForwardByClient)
#pragma alloc_text(PAGE, LfsTerminateLogQuery)
#endif


VOID
LfsReadLogRecord (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN FirstLsn,
    IN LFS_CONTEXT_MODE ContextMode,
    OUT PLFS_LOG_CONTEXT Context,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine initiates the query operation.  It returns the log record
    in question and a context structure used by the Lfs to return related
    log records.  The caller specifies what mode of query to use.  He may
    walk backwards through the file by Undo records or all records for
    this client linked through the previous Lsn fields.  He may also look
    forwards through the file for all records for the issuing client.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    FirstLsn - Starting record for this query operation.

    ContextMode - Method of query.

    Context - Supplies the address to store a pointer to the Lfs created
              context structure.

    RecordType - Supplies the address to store the record type of this
                 log record.

    TransactionId - Supplies the address to store the transaction Id of
                    this log record.

    UndoNextLsn - Supplies the address to store the Undo Next Lsn for this
                  log record.

    PreviousLsn - Supplies the address to store the Previous Lsn for this
                  log record.

    BufferLength - This is the length of the log data.

    Buffer - This is a pointer to the start of the log data.

Return Value:

    None

--*/

{
    PLFS_CLIENT_RECORD ClientRecord;

    PLCH Lch;

    PLFCB Lfcb;

    PLEB Leb = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle        -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "First Lsn (Low)   -> %08lx\n", FirstLsn.LowPart );
    DebugTrace(  0, Dbg, "First Lsn (High)  -> %08lx\n", FirstLsn.HighPart );
    DebugTrace(  0, Dbg, "Context Mode      -> %08lx\n", ContextMode );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the context mode is valid.
    //

    switch (ContextMode) {

    case LfsContextUndoNext :
    case LfsContextPrevious :
    case LfsContextForward :

        break;

    default:

        DebugTrace( 0, Dbg, "Invalid context mode -> %08x\n", ContextMode );
        ExRaiseStatus( STATUS_INVALID_PARAMETER );
    }

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-except to catch errors.
    //

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Check that the given Lsn is in the legal range for this client.
        //

        ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                Lch->ClientArrayByteOffset,
                                PLFS_CLIENT_RECORD );

        if (!LfsVerifyClientLsnInRange( Lfcb, ClientRecord, FirstLsn )) {

            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  We can give up the Lfcb as we know the Lsn is within the file.
        //

        LfsReleaseLch( Lch );

        //
        //  Allocate and initialize an enumeration structure.
        //

        LfsAllocateLeb( Lfcb, &Leb );

        LfsInitializeLeb( Leb,
                          Lch->ClientId,
                          ContextMode );

        //
        //  Find the log record indicated by the given Lsn.
        //

        LfsFindLogRecord( Lfcb,
                          Leb,
                          FirstLsn,
                          RecordType,
                          TransactionId,
                          UndoNextLsn,
                          PreviousLsn,
                          BufferLength,
                          Buffer );

        //
        //  Update the client's arguments.
        //

        *Context = Leb;
        Leb = NULL;

    } finally {

        DebugUnwind( LfsReadLogRecord );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        //
        //  Deallocate the enumeration block if an error occurred.
        //

        if (Leb != NULL) {

            LfsDeallocateLeb( Lfcb, Leb );
        }

        DebugTrace(  0, Dbg, "Context       -> %08lx\n", *Context );
        DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
        DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", *Buffer );
        DebugTrace( -1, Dbg, "LfsReadLogRecord:  Exit\n", 0 );
    }

    return;
}


BOOLEAN
LfsReadNextLogRecord (
    IN LFS_LOG_HANDLE LogHandle,
    IN OUT LFS_LOG_CONTEXT Context,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PLSN Lsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called to continue a query operation.  The Lfs uses
    private information stored in the enumeration structure to determine the
    next log record to return to the caller.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    Context - Supplies the address to store a pointer to the Lfs created
              enumeration structure.

    Lsn - Lsn for this log record.

    RecordType - Supplies the address to store the record type of this
                 log record.

    TransactionId - Supplies the address to store the transaction Id of
                    this log record.

    UndoNextLsn - Supplies the address to store the Undo Next Lsn for this
                  log record.

    PreviousLsn - Supplies the address to store the Previous Lsn for this
                  log record.

    BufferLength - This is the length of the log data.

    Buffer - This is a pointer to the start of the log data.

Return Value:

    None

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    PLEB Leb;

    BOOLEAN FoundNextLsn;

    BOOLEAN UnwindRememberLebFields;
    PBCB UnwindRecordHeaderBcb;
    PLFS_RECORD_HEADER UnwindRecordHeader;
    PVOID UnwindCurrentLogRecord;
    BOOLEAN UnwindAuxilaryBuffer;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadNextLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Context       -> %08lx\n", Context );

    FoundNextLsn = FALSE;

    UnwindRememberLebFields = FALSE;

    Lch = (PLCH) LogHandle;
    Leb = (PLEB) Context;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Check that the enumeration structure is valid.
        //

        LfsValidateLeb( Leb, Lch );

        //
        //  Remember any enumeration fields to be overwritten.
        //

        UnwindRememberLebFields = TRUE;

        UnwindRecordHeaderBcb = Leb->RecordHeaderBcb;
        Leb->RecordHeaderBcb = NULL;

        UnwindRecordHeader = Leb->RecordHeader;
        UnwindCurrentLogRecord = Leb->CurrentLogRecord;

        UnwindAuxilaryBuffer = Leb->AuxilaryBuffer;
        Leb->AuxilaryBuffer = FALSE;

        //
        //  Find the next Lsn number based on the current Lsn number in
        //  the enumeration block.
        //

        if (LfsFindClientNextLsn( Lfcb, Leb, Lsn )) {

            //
            //  We can give up the Lfcb as we know the Lsn is within the file.
            //

            LfsReleaseLfcb( Lfcb );

            //
            //  Cleanup the enumeration block so we can do the next search.
            //

            Leb->CurrentLogRecord = NULL;
            Leb->AuxilaryBuffer = FALSE;

            //
            //  Perform the work of getting the log record.
            //

            LfsFindLogRecord( Lfcb,
                              Leb,
                              *Lsn,
                              RecordType,
                              TransactionId,
                              UndoNextLsn,
                              PreviousLsn,
                              BufferLength,
                              Buffer );

            FoundNextLsn = TRUE;
        }

    } finally {

        DebugUnwind( LfsReadNextLogRecord );

        //
        //  If we exited due to an error, we have to restore the enumeration
        //  block.
        //

        if (UnwindRememberLebFields) {

            if (AbnormalTermination()) {

                //
                //  If the record header in the enumeration block is not
                //  the same as we started with.  Then we unpin that
                //  data.
                //

                if (Leb->RecordHeaderBcb != NULL) {

                    CcUnpinData( Leb->RecordHeaderBcb );

                }

                if (Leb->CurrentLogRecord != NULL
                    && Leb->AuxilaryBuffer == TRUE) {

                    LfsFreeSpanningBuffer( Leb->CurrentLogRecord );
                }

                Leb->RecordHeaderBcb = UnwindRecordHeaderBcb;
                Leb->RecordHeader = UnwindRecordHeader;
                Leb->CurrentLogRecord = UnwindCurrentLogRecord;
                Leb->AuxilaryBuffer = UnwindAuxilaryBuffer;

            //
            //  Otherwise, if we have successfully found the next Lsn,
            //  we free up any resources being held from the previous search.
            //

            } else if (FoundNextLsn ) {

                if (UnwindRecordHeaderBcb != NULL) {

                    CcUnpinData( UnwindRecordHeaderBcb );
                }

                if (UnwindCurrentLogRecord != NULL
                    && UnwindAuxilaryBuffer == TRUE) {

                    LfsFreeSpanningBuffer( UnwindCurrentLogRecord );
                }

            //
            //  Restore the Bcb and auxilary buffer field for the final
            //  cleanup.
            //

            } else {

                if (UnwindRecordHeaderBcb != NULL) {

                    if (Leb->RecordHeaderBcb != NULL) {

                        CcUnpinData( UnwindRecordHeaderBcb );

                    } else {

                        Leb->RecordHeaderBcb = UnwindRecordHeaderBcb;
                    }
                }

                if (UnwindAuxilaryBuffer) {

                    if (Leb->CurrentLogRecord == UnwindCurrentLogRecord) {

                        Leb->AuxilaryBuffer = TRUE;

                    } else {

                        LfsFreeSpanningBuffer( UnwindCurrentLogRecord );
                    }
                }
            }
        }

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
        DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", *Buffer );
        DebugTrace( -1, Dbg, "LfsReadNextLogRecord:  Exit\n", 0 );
    }
    return FoundNextLsn;
}


VOID
LfsTerminateLogQuery (
    IN LFS_LOG_HANDLE LogHandle,
    IN LFS_LOG_CONTEXT Context
    )

/*++

Routine Description:

    This routine is called when a client has completed his query operation
    and wishes to deallocate any resources acquired by the Lfs to
    perform the log file query.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    Context - Supplies the address to store a pointer to the Lfs created
              enumeration structure.

Return Value:

    None

--*/

{
    PLCH Lch;
    PLEB Leb;

    PLFCB Lfcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsTerminateLogQuery:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Context       -> %08lx\n", Context );

    Lch = (PLCH) LogHandle;
    Leb = (PLEB) Context;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            try_return( NOTHING );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Check that the enumeration structure is valid.
        //

        LfsValidateLeb( Leb, Lch );

        //
        //  Deallocate the enumeration block.
        //

        LfsDeallocateLeb( Lfcb, Leb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( LfsTerminateLogQuery );

        //
        //  Release the Lfcb if acquired.
        //

        LfsReleaseLch( Lch );

        DebugTrace( -1, Dbg, "LfsTerminateLogQuery:  Exit\n", 0 );
    }

    return;
}


LSN
LfsQueryLastLsn (
    IN LFS_LOG_HANDLE LogHandle
    )

/*++

Routine Description:

    This routine will return the most recent Lsn for this log record.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

Return Value:

    LSN - This is the last Lsn assigned in this log file.

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    LSN LastLsn;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsQueryLastLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Copy the last Lsn out of the Lfcb.  If the last Lsn is
        //  does not correspond to a log record, we will return the
        //  zero Lsn.
        //

        if (FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN )) {

            LastLsn = LfsZeroLsn;

        } else {

            LastLsn = Lfcb->RestartArea->CurrentLsn;
        }

    } finally {

        DebugUnwind( LfsQueryLastLsn );

        //
        //  Release the Lfcb if acquired.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Last Lsn (Low)    -> %08lx\n", LastLsn.LowPart );
        DebugTrace(  0, Dbg, "Last Lsn (High)   -> %08lx\n", LastLsn.HighPart );
        DebugTrace( -1, Dbg, "LfsQueryLastLsn:  Exit\n", 0 );
    }

    return LastLsn;
}


//
//  Local support routine.
//

VOID
LfsFindLogRecord (
    IN PLFCB Lfcb,
    IN OUT PLEB Leb,
    IN LSN Lsn,
    OUT PLFS_RECORD_TYPE RecordType,
    OUT TRANSACTION_ID *TransactionId,
    OUT PLSN UndoNextLsn,
    OUT PLSN PreviousLsn,
    OUT PULONG BufferLength,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called recover a log record for a client.

Arguments:

    Lfcb - Log file control block for this file.

    Leb - Pointer to the enumeration block to update.

    Lsn - This is the Lsn for the log record.

    RecordType - Supplies the address to store the record type of this
                 log record.

    TransactionId - Supplies the address to store the transaction Id of
                    this log record.

    UndoNextLsn - Supplies the address to store the Undo Next Lsn for this
                  log record.

    PreviousLsn - Supplies the address to store the Previous Lsn for this
                  log record.

    BufferLength - Pointer to address to store the length in bytes of the
                   log record.

    Buffer - Pointer to store the address where the log record data begins.

Return Value:

    None

--*/

{
    PCHAR NewBuffer;
    BOOLEAN UsaError;
    LONGLONG LogRecordLength;
    ULONG PageOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindLogRecord:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Enumeration Block -> %08lx\n", Leb );
    DebugTrace(  0, Dbg, "Lsn (Low)         -> %08lx\n", Lsn.LowPart );

    NewBuffer = NULL;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Map the record header for this Lsn if we haven't already.
        //

        if (Leb->RecordHeader == NULL) {

            LfsPinOrMapLogRecordHeader( Lfcb,
                                        Lsn,
                                        FALSE,
                                        FALSE,
                                        &UsaError,
                                        &Leb->RecordHeader,
                                        &Leb->RecordHeaderBcb );
        }

        //
        //  We now have the log record desired.  If the Lsn in the
        //  log record doesn't match the desired Lsn then the disk is
        //  corrupt.
        //

        if ( Lsn.QuadPart != Leb->RecordHeader->ThisLsn.QuadPart ) {                                                   //**** xxNeq( Lsn, Leb->RecordHeader->ThisLsn )

            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  Check that the length field isn't greater than the total available space
        //  in the log file.
        //

        LogRecordLength = Leb->RecordHeader->ClientDataLength + Lfcb->RecordHeaderLength;                              //**** xxFromUlong( Leb->RecordHeader->ClientDataLength + Lfcb->RecordHeaderLength );

        if ( LogRecordLength >= Lfcb->TotalAvailable ) {                                                               //**** xxGeq( LogRecordLength, Lfcb->TotalAvailable )

            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  If the entire log record is on this log page, put a pointer to
        //  the log record in the enumeration block.
        //

        if (!FlagOn( Leb->RecordHeader->Flags, LOG_RECORD_MULTI_PAGE )) {

            //
            //  If client size indicates that we have to go beyond the end of the current
            //  page, we raise an error.
            //

            PageOffset = LfsLsnToPageOffset( Lfcb, Lsn );

            if ((PageOffset + Leb->RecordHeader->ClientDataLength + Lfcb->RecordHeaderLength)
                > (ULONG)Lfcb->LogPageSize) {

                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            Leb->CurrentLogRecord = Add2Ptr( Leb->RecordHeader, LFS_RECORD_HEADER_SIZE, PVOID );
            Leb->AuxilaryBuffer = FALSE;

        //
        //  Else we copy the data and remember that we allocated a buffer.
        //

        } else {

            NewBuffer = LfsAllocateSpanningBuffer( Lfcb, Leb->RecordHeader->ClientDataLength );

            //
            //  Copy the data into the buffer returned.
            //

            LfsCopyReadLogRecord( Lfcb,
                                  Leb->RecordHeader,
                                  NewBuffer );

            Leb->CurrentLogRecord = NewBuffer;

            Leb->AuxilaryBuffer = TRUE;

            NewBuffer = NULL;
        }

        //
        //  We need to update the caller's parameters and the enumeration block.
        //

        *RecordType = Leb->RecordHeader->RecordType;
        *TransactionId = Leb->RecordHeader->TransactionId;

        *UndoNextLsn = Leb->RecordHeader->ClientUndoNextLsn;
        *PreviousLsn = Leb->RecordHeader->ClientPreviousLsn;

        *Buffer = Leb->CurrentLogRecord;
        *BufferLength = Leb->RecordHeader->ClientDataLength;

    } finally {

        DebugUnwind( LfsFindLogRecord );

        //
        //  If an error occurred we unpin the record header and the log
        //  We also free the buffer if allocated by us.
        //

        if (NewBuffer != NULL) {

            LfsFreeSpanningBuffer( NewBuffer );
        }

        DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
        DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", *Buffer );
        DebugTrace( -1, Dbg, "LfsFindLogRecord:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine.
//

BOOLEAN
LfsFindClientNextLsn (
    IN PLFCB Lfcb,
    IN PLEB Leb,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine will attempt to find the next Lsn to return to a client
    based on the context mode.

Arguments:

    Lfcb - File control block for this log file.

    Leb - Pointer to the enumeration block for this query operation.

    Lsn - Pointer to store the Lsn found (if any)

Return Value:

    BOOLEAN - TRUE if an Lsn is found, FALSE otherwise.

--*/

{
    LSN NextLsn;
    BOOLEAN NextLsnFound;

    PLFS_CLIENT_RECORD ClientRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindClientNextLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Leb  -> %08lx\n", Leb );

    ClientRecord = Lfcb->ClientArray + Leb->ClientId.ClientIndex;

    //
    //  The enumeration block has the last Lsn returned.  If the user wanted
    //  one of the Lsn's in that log header then our job is simple.
    //

    switch (Leb->ContextMode) {

    case LfsContextUndoNext:
    case LfsContextPrevious:

        NextLsn = (Leb->ContextMode == LfsContextUndoNext
                   ? Leb->RecordHeader->ClientUndoNextLsn
                   : Leb->RecordHeader->ClientPreviousLsn);

        if ( NextLsn.QuadPart == 0 ) {                                                                                 //**** xxEqlZero( NextLsn )

            NextLsnFound = FALSE;

        } else if (LfsVerifyClientLsnInRange( Lfcb, ClientRecord, NextLsn )) {

            BOOLEAN UsaError;

            LfsPinOrMapLogRecordHeader( Lfcb,
                                        NextLsn,
                                        FALSE,
                                        FALSE,
                                        &UsaError,
                                        &Leb->RecordHeader,
                                        &Leb->RecordHeaderBcb );

            NextLsnFound = TRUE;

        } else {

            NextLsnFound = FALSE;
        }

        break;

    case LfsContextForward:

        //
        //  We search forward for the next log record for this client.
        //

        NextLsnFound = LfsSearchForwardByClient( Lfcb, Leb, &NextLsn );
        break;

    default:

        NextLsnFound = FALSE;
        break;
    }

    if (NextLsnFound) {

        *Lsn = NextLsn;
    }

    DebugTrace(  0, Dbg, "NextLsn (Low)     -> %08lx\n", NextLsn.LowPart );
    DebugTrace(  0, Dbg, "NextLsn (High)    -> %08lx\n", NextLsn.HighPart );
    DebugTrace( -1, Dbg, "LfsFindClientNextLsn:  Exit -> %08x\n", NextLsnFound );

    return NextLsnFound;
}


//
//  Local support routine.
//

BOOLEAN
LfsSearchForwardByClient (
    IN PLFCB Lfcb,
    IN OUT PLEB Leb,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine will attempt to find the next Lsn for this client by searching
    forward in the file, looking for a match.

Arguments:

    Lfcb - Pointer to the file control block for this log file.

    Leb - Pointer to the enumeration block for this query operation.

    Lsn - Points to the location to store the next Lsn if found.

Return Value:

    BOOLEAN - TRUE if another Lsn for this client is found.  FALSE otherwise.

--*/

{
    PLFS_RECORD_HEADER CurrentRecordHeader;
    PBCB CurrentBcb;

    BOOLEAN FoundNextLsn;

    LSN CurrentLsn;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsSearchForwardByClient:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Leb  -> %08lx\n", Leb );

    //
    //  The log record header is in the log enumeration
    //  block.  We set the current Bcb to NULL so that we don't
    //  unpin the log record in the enumeration block until we're sure
    //  of success.
    //

    CurrentRecordHeader = Leb->RecordHeader;

    CurrentBcb = NULL;

    //
    //  We use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We assume we won't find another Lsn.
        //

        FoundNextLsn = FALSE;

        //
        //  Loop as long as another Lsn can be found.
        //

        while (LfsFindNextLsn( Lfcb, CurrentRecordHeader, &CurrentLsn )) {

            BOOLEAN UsaError;

            //
            //  Unpin the previous log record header.
            //

            if (CurrentBcb != NULL) {

                CcUnpinData( CurrentBcb );
                CurrentBcb = NULL;
            }

            //
            //  Pin the log record header for this Lsn.
            //

            LfsPinOrMapLogRecordHeader( Lfcb,
                                        CurrentLsn,
                                        FALSE,
                                        FALSE,
                                        &UsaError,
                                        &CurrentRecordHeader,
                                        &CurrentBcb );

            //
            //  If the client values match, then we update the
            //  enumeration block and exit.
            //

            if (LfsClientIdMatch( &CurrentRecordHeader->ClientId,
                                  &Leb->ClientId )
                && CurrentRecordHeader->RecordType == LfsClientRecord) {

                //
                //  We remember this one.
                //

                Leb->RecordHeader = CurrentRecordHeader;
                Leb->RecordHeaderBcb = CurrentBcb;

                CurrentBcb = NULL;
                FoundNextLsn = TRUE;

                *Lsn = CurrentLsn;
                break;
            }
        }

    } finally {

        DebugUnwind( LfsSearchForwardByClient );

        //
        //  Unpin any log record headers still pinned for no reason.
        //

        if (CurrentBcb != NULL) {

            CcUnpinData( CurrentBcb );
        }

        DebugTrace(  0, Dbg, "NextLsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "NextLsn (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsSearchForwardByClient:  Exit -> %08x\n", FoundNextLsn );
    }

    return FoundNextLsn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\restart.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Restart.c

Abstract:

    This module implements the routines which access the client restart
    areas.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RESTART)

VOID
LfsSetBaseLsnPriv (
    IN PLFCB Lfcb,
    IN PLFS_CLIENT_RECORD ClientRecord,
    IN LSN BaseLsn
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsReadRestartArea)
#pragma alloc_text(PAGE, LfsSetBaseLsn)
#pragma alloc_text(PAGE, LfsSetBaseLsnPriv)
#pragma alloc_text(PAGE, LfsWriteRestartArea)
#endif


NTSTATUS
LfsReadRestartArea (
    IN LFS_LOG_HANDLE LogHandle,
    IN OUT PULONG BufferLength,
    IN PVOID Buffer,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called by the client when he wishes to read his restart
    area in the log file.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    BufferLength - On entry it is the length of the user buffer.  On exit
                   it is the size of the data stored in the buffer.

    Buffer - Pointer to the buffer where the client restart data is to be
             copied.

    Lsn - This is the Lsn for client restart area.

Return Value:

    None

--*/

{
    BOOLEAN UsaError;

    PLCH Lch;

    PLFS_CLIENT_RECORD ClientRecord;

    PLFS_RECORD_HEADER RecordHeader;
    PBCB RecordHeaderBcb;

    PLFCB Lfcb;
    NTSTATUS RetStatus = STATUS_SUCCESS;


    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadRestartArea:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
    DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", Buffer );

    RecordHeaderBcb = NULL;

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                Lch->ClientArrayByteOffset,
                                PLFS_CLIENT_RECORD );

        //
        //  If the client doesn't have a restart area, go ahead and exit
        //  now.
        //

        if (ClientRecord->ClientRestartLsn.QuadPart == 0) {

            //
            //  We show there is no restart area by returning a length
            //  of zero.  We also set the Lsn value to zero so that
            //  we can catch it if the user tries to use the Lsn.
            //

            DebugTrace( 0, Dbg, "No client restart area exists\n", 0 );

            *BufferLength = 0;
            *Lsn = LfsZeroLsn;

            try_return( NOTHING );
        }

        //
        //  Release the Lfcb as we won't be modifying any fields in it.
        //

        LfsReleaseLfcb( Lfcb );

        //
        //  Pin the log record for this Lsn.
        //

        LfsPinOrMapLogRecordHeader( Lfcb,
                                    ClientRecord->ClientRestartLsn,
                                    FALSE,
                                    FALSE,
                                    &UsaError,
                                    &RecordHeader,
                                    &RecordHeaderBcb );

        //
        //  If the Lsn values don't match, then the disk is corrupt.
        //

        if (ClientRecord->ClientRestartLsn.QuadPart != RecordHeader->ThisLsn.QuadPart) {

            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }


        //
        //  Check that the user's buffer is big enough to hold the restart
        //  data.  We raise an error status for this error.
        //

        if (RecordHeader->ClientDataLength > *BufferLength) {

            DebugTrace( 0, Dbg, "Client buffer is too small\n", 0 );
            *BufferLength = RecordHeader->ClientDataLength;
            *Lsn = LfsZeroLsn;
            try_return( RetStatus = STATUS_BUFFER_TOO_SMALL );
        }


        //
        //  Use the cache manager to copy the data into the user's buffer.
        //

        LfsCopyReadLogRecord( Lfcb,
                              RecordHeader,
                              Buffer );

        //
        //  Pass the length and the Lsn of the restart area back to the
        //  caller.
        //

        *BufferLength = RecordHeader->ClientDataLength;
        *Lsn = RecordHeader->ThisLsn;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( LfsReadRestartArea );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        //
        //  Unpin the log record header for the client restart if pinned.
        //

        if (RecordHeaderBcb != NULL) {

            CcUnpinData( RecordHeaderBcb );
        }

        DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", *BufferLength );
        DebugTrace( -1, Dbg, "LfsReadRestartArea:  Exit\n", 0 );
    }

    return RetStatus;
}


VOID
LfsWriteRestartArea (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG BufferLength,
    IN PVOID Buffer,
    IN LOGICAL CleanShutdown,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called by the client to write a restart area to the
    disk.  This routine will not return to the caller until the client
    restart area and all prior Lsn's have been flushed and the Lfs
    restart area on the disk has been updated.

    On return, all log records up to and including 'Lsn' have been flushed
    to the disk.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this client.

    BufferLength - On entry it is the length of the user buffer.

    Buffer - Pointer to the buffer where the client restart data resides.

    CleanShutdown - Logical indicating that the caller won't need to run
        restart from this restart area.  Lfs can set the CLEAN_SHUTDOWN flag
        in its restart area as an indication for 3rd party utilities that
        it is safe to party on the drive.

    Lsn - This is the Lsn for this write operation.  On input, this will be the
        new Base Lsn for this client.

          ****  This was used to prevent adding an interface change to
                the Beta release.

Return Value:

    None

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    PLFS_CLIENT_RECORD ClientRecord;

    LFS_WRITE_ENTRY WriteEntry;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsWriteRestartArea:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Buffer Length -> %08lx\n", BufferLength );
    DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", Buffer );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  If the clean shutdown flag is currently set and this caller
        //  will run restart out of this record then clear the bit on
        //  disk first.
        //

        if (FlagOn( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN ) &&
            !CleanShutdown) {

            ClearFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
        }

        //
        //  Capture the client record after possibly updating above when writing
        //  the lfs restart areas
        //   

        ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                Lch->ClientArrayByteOffset,
                                PLFS_CLIENT_RECORD );

        //
        //  Go ahead and update the Base Lsn in the client area if the value
        //  given is not zero.
        //

        if (Lsn->QuadPart != 0) {

            LfsSetBaseLsnPriv( Lfcb,
                               ClientRecord,
                               *Lsn );
        }

        //
        //  Write this restart area as a log record into a log page.
        //

        WriteEntry.Buffer = Buffer;
        WriteEntry.ByteLength = BufferLength;

        LfsWriteLogRecordIntoLogPage( Lfcb,
                                      Lch,
                                      1,
                                      &WriteEntry,
                                      LfsClientRestart,
                                      NULL,
                                      LfsZeroLsn,
                                      LfsZeroLsn,
                                      0,
                                      TRUE,
                                      Lsn );

        //
        //  Update the restart area for the client.
        //

        ClientRecord->ClientRestartLsn = *Lsn;

        //
        //  Write the restart area to the disk.
        //

        if (CleanShutdown) {

            SetFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );

        } else {

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
        }

    } finally {

        DebugUnwind( LfsWriteRestartArea );

        //
        //  Release the log file control block if still held.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Lsn (Low)     -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Log (High)    -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsWriteRestartArea:  Exit\n", 0 );
    }
    return;
}


VOID
LfsSetBaseLsn (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN BaseLsn
    )

/*++

Routine Description:

    This routine is called by the client to notify the log service of the
    oldest Lsn he expects to need during restart.  The Lfs is allowed to
    reuse any part of the circular log file which logically precedes
    this Lsn.  A client may only specify a Lsn which follows the previous
    Lsn specified by this client.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    BaseLsn - This is the oldest Lsn the client may require during a
              restart.

Return Value:

    None

--*/

{
    volatile NTSTATUS Status = STATUS_SUCCESS;

    PLCH Lch;

    PLFCB Lfcb;

    PLFS_CLIENT_RECORD ClientRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsSetBaseLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle        -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Base Lsn (Low)    -> %08lx\n", BaseLsn.LowPart );
    DebugTrace(  0, Dbg, "Base Lsn (High)   -> %08lx\n", BaseLsn.HighPart );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-except to catch errors.
    //

    try {

        //
        //  Use a try-finally to facilitate cleanup.
        //

        try {

            //
            //  Acquire the log file control block for this log file.
            //

            LfsAcquireLch( Lch );
            Lfcb = Lch->Lfcb;

            //
            //  If the Log file has been closed then refuse access.
            //

            if (Lfcb == NULL) {

                ExRaiseStatus( STATUS_ACCESS_DENIED );
            }

            //
            //  Check that the client Id is valid.
            //

            LfsValidateClientId( Lfcb, Lch );

            ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                    Lch->ClientArrayByteOffset,
                                    PLFS_CLIENT_RECORD );

            //
            //  We simply call the worker routine to advance the base lsn.
            //  If we moved forward in the file, we will put our restart area in the
            //  queue.
            //

            LfsSetBaseLsnPriv( Lfcb,
                               ClientRecord,
                               BaseLsn );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );

        } finally {

            DebugUnwind( LfsSetBaseLsn );

            //
            //  Release the log file control block if held.
            //

            LfsReleaseLch( Lch );

            DebugTrace( -1, Dbg, "LfsSetBaseLsn:  Exit\n", 0 );
        }

    } except (LfsExceptionFilter( GetExceptionInformation() )) {

        Status = GetExceptionCode();
    }

    if (Status != STATUS_SUCCESS) {

        ExRaiseStatus( Status );
    }

    return;
}


//
//  Local support routine
//

VOID
LfsSetBaseLsnPriv (
    IN PLFCB Lfcb,
    IN PLFS_CLIENT_RECORD ClientRecord,
    IN LSN BaseLsn
    )

/*++

Routine Description:

    This worker routine is called internally by Lfs to modify the
    oldest Lsn a client expects to need during restart.  The Lfs is allowed to
    reuse any part of the circular log file which logically precedes
    this Lsn.  A client may only specify a Lsn which follows the previous
    Lsn specified by this client.

Arguments:

    Lfcb - Log context block for this file.

    ClientRecord - For the client whose base Lsn is being modified.

    BaseLsn - This is the oldest Lsn the client may require during a
              restart.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsSetBaseLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Base Lsn (Low)    -> %08lx\n", BaseLsn.LowPart );
    DebugTrace(  0, Dbg, "Base Lsn (High)   -> %08lx\n", BaseLsn.HighPart );

    //
    //  We only proceed if the client is moving forward in the file.
    //

    if (BaseLsn.QuadPart > Lfcb->OldestLsn.QuadPart) {

        if (BaseLsn.QuadPart > ClientRecord->OldestLsn.QuadPart) {

            ClientRecord->OldestLsn = BaseLsn;
        }

        Lfcb->OldestLsn = BaseLsn;

        //
        //  We walk through all the active clients and find the new
        //  oldest Lsn for the log file.
        //

        LfsFindOldestClientLsn( Lfcb->RestartArea,
                                Lfcb->ClientArray,
                                &Lfcb->OldestLsn );

        Lfcb->OldestLsnOffset = LfsLsnToFileOffset( Lfcb, Lfcb->OldestLsn );
        ClearFlag( Lfcb->Flags, LFCB_NO_OLDEST_LSN );

        LfsFindCurrentAvail( Lfcb );
    }

    DebugTrace( -1, Dbg, "LfsSetBaseLsnPriv:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\rstrtsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    RstrtSup.c

Abstract:

    This module implements support for dealing with the Lfs restart area.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RESTART_SUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsFindOldestClientLsn)
#pragma alloc_text(PAGE, LfsWriteLfsRestart)
#endif


VOID
LfsWriteLfsRestart (
    IN PLFCB Lfcb,
    IN ULONG ThisRestartSize,
    IN BOOLEAN WaitForIo
    )

/*++

Routine Description:

    This routine puts the Lfs restart area on the queue of operations to
    write to the file.  We do this by allocating a second restart area
    and attaching it to the Lfcb.  We also allocate a buffer control
    block to use for this write.  We look at the WaitForIo boolean to
    determine whether this thread can perform the I/O.  This also indicates
    whether this thread gives up the Lfcb.

Arguments:

    Lfcb - A pointer to the log file control block for this operation.

    ThisRestartSize - This is the size to use for the restart area.

    WaitForIo - Indicates if this thread is to perform the work.

Return Value:

    None.

--*/

{
    PLBCB NewLbcb = NULL;
    PLFS_RESTART_AREA NewRestart = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsWriteLfsRestart:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Write Chkdsk  -> %04x\n", WriteChkdsk );
    DebugTrace(  0, Dbg, "Restart Size  -> %08lx\n", ThisRestartSize );
    DebugTrace(  0, Dbg, "WaitForIo     -> %08lx\n", WaitForIo );

    //
    //  We'd absolutely hate for this to happen on a read only volume.
    //

    ASSERT(!(FlagOn( Lfcb->Flags, LFCB_READ_ONLY )));

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        PLBCB ActiveLbcb;

        //
        //  We allocate another restart area and
        //  copy the current area into it.  Attach the new area to the Lfcb.
        //

        LfsAllocateRestartArea( &NewRestart, ThisRestartSize );

        //
        //  We allocate a Lbcb structure and update the values to
        //  reflect this restart area.
        //

        LfsAllocateLbcb( Lfcb, &NewLbcb );
        SetFlag( NewLbcb->LbcbFlags, LBCB_RESTART_LBCB );

        //
        //  If this is the second page, then add a page to the offset.
        //

        if (!Lfcb->InitialRestartArea) {

            NewLbcb->FileOffset = Lfcb->LogPageSize + NewLbcb->FileOffset;
        }

        (ULONG)NewLbcb->Length = ThisRestartSize;

        NewLbcb->PageHeader = (PVOID) Lfcb->RestartArea;

        //
        //  Lets put the current lsn in the Lbcb.
        //

        NewLbcb->LastEndLsn = NewLbcb->LastLsn = Lfcb->NextRestartLsn;
        Lfcb->NextRestartLsn.QuadPart = 1 + Lfcb->NextRestartLsn.QuadPart;

        //
        //  Copy the existing restart area into the new area.
        //

        RtlCopyMemory( NewRestart, Lfcb->RestartArea, ThisRestartSize );
        Lfcb->RestartArea = NewRestart;

        Lfcb->ClientArray = Add2Ptr( NewRestart, Lfcb->ClientArrayOffset, PLFS_CLIENT_RECORD );

        NewRestart = NULL;

        //
        //  Update the Lfcb to indicate that the other restart area
        //  on the disk is to be used.
        //

        Lfcb->InitialRestartArea = !Lfcb->InitialRestartArea;

        //
        //  Add this Lbcb to the end of the workque and flush to that point.
        //

        InsertTailList( &Lfcb->LbcbWorkque, &NewLbcb->WorkqueLinks );

        //
        //  If we don't support a packed log file then we need to make
        //  sure that all file records written out ahead of this
        //  restart area make it out to disk and we don't add anything
        //  to this page.
        //

        if (!FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
            && !IsListEmpty( &Lfcb->LbcbActive )) {

            ActiveLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                            LBCB,
                                            ActiveLinks );

            if (FlagOn( ActiveLbcb->LbcbFlags, LBCB_NOT_EMPTY )) {

                RemoveEntryList( &ActiveLbcb->ActiveLinks );
                ClearFlag( ActiveLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );
            }
        }

        if (WaitForIo) {

            LfsFlushLbcb( Lfcb, NewLbcb );
        }

    } finally {

        DebugUnwind( LfsWriteLfsRestart );

        if (NewRestart != NULL) {

            ExFreePool( NewRestart );
        }

        DebugTrace( -1, Dbg, "LfsWriteLfsRestart:  Exit\n", 0 );
    }

    return;
}


VOID
LfsFindOldestClientLsn (
    IN PLFS_RESTART_AREA RestartArea,
    IN PLFS_CLIENT_RECORD ClientArray,
    OUT PLSN OldestLsn
    )

/*++

Routine Description:

    This routine walks through the active clients to determine the oldest
    Lsn the system must maintain.

Arguments:

    RestartArea - This is the Restart Area to examine.

    ClientArray - This is the start of the client data array.

    OldestLsn - We store the oldest Lsn we find in this value.  It is
        initialized with a starting value, we won't return a more recent
        Lsn.

Return Value:

    None.

--*/

{
    USHORT NextClient;

    PLFS_CLIENT_RECORD ClientBlock;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindOldestClientLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "RestartArea       -> %08lx\n", RestartArea );
    DebugTrace(  0, Dbg, "Base Lsn (Low)    -> %08lx\n", BaseLsn.LowPart );
    DebugTrace(  0, Dbg, "Base Lsn (High)   -> %08lx\n", BaseLsn.HighPart );

    //
    //  Take the first client off the in use list.
    //

    NextClient = RestartArea->ClientInUseList;

    //
    //  While there are more clients, compare their oldest Lsn with the
    //  current oldest.
    //

    while (NextClient != LFS_NO_CLIENT) {

        ClientBlock = ClientArray + NextClient;

        //
        //  We ignore this block if it's oldest Lsn is 0.
        //

        if (( ClientBlock->OldestLsn.QuadPart != 0 )
            && ( ClientBlock->OldestLsn.QuadPart < OldestLsn->QuadPart )) {

            *OldestLsn = ClientBlock->OldestLsn;
        }

        //
        //  Try the next client block.
        //

        NextClient = ClientBlock->NextClient;
    }

    DebugTrace(  0, Dbg, "OldestLsn (Low)   -> %08lx\n", BaseLsn.LowPart );
    DebugTrace(  0, Dbg, "OldestLsn (High)  -> %08lx\n", BaseLsn.HighPart );
    DebugTrace( -1, Dbg, "LfsFindOldestClientLsn:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\nodetype.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                       ((NODE_TYPE_CODE)0x0000)

#define LFS_NTC_LEB                         ((NODE_TYPE_CODE)0x800)
#define LFS_NTC_LCH                         ((NODE_TYPE_CODE)0x801)
#define LFS_NTC_LBCB                        ((NODE_TYPE_CODE)0x802)
#define LFS_NTC_LFCB                        ((NODE_TYPE_CODE)0x803)
#define LFS_NTC_DATA                        ((NODE_TYPE_CODE)0x804)

typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\strucsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module provides support routines for creation and deletion
    of Lfs structures.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUC_SUP)

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('SsfL')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsAllocateLbcb)
#pragma alloc_text(PAGE, LfsAllocateLfcb)
#pragma alloc_text(PAGE, LfsDeallocateLbcb)
#pragma alloc_text(PAGE, LfsDeallocateLfcb)
#pragma alloc_text(PAGE, LfsAllocateLeb)
#pragma alloc_text(PAGE, LfsDeallocateLeb)
#pragma alloc_text(PAGE, LfsReadPage)
#endif


PLFCB
LfsAllocateLfcb (
    IN ULONG LogPageSize,
    IN LONGLONG FileSize
    )

/*++

Routine Description:

    This routine allocates and initializes a log file control block.

Arguments:

    LogPageSize - lfs log file page size
    
    FileSize - Initial file size

Return Value:

    PLFCB - A pointer to the log file control block just
                              allocated and initialized.

--*/

{
    PLFCB Lfcb = NULL;
    ULONG Count;
    PLBCB NextLbcb;
    PLEB  NextLeb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsAllocateLfcb:  Entered\n", 0 );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Allocate and zero the structure for the Lfcb.
        //

        ASSERT( LogPageSize <= PAGE_SIZE );

        Lfcb = LfsAllocatePool( PagedPool, sizeof( LFCB ) + sizeof( PLBCB ) * (PAGE_SIZE / LogPageSize) );

        //
        //  Zero out the structure initially.
        //

        RtlZeroMemory( Lfcb, sizeof( LFCB ) + sizeof( PLBCB ) * (PAGE_SIZE / LogPageSize));

        //
        //  Initialize the log file control block.
        //

        Lfcb->NodeTypeCode = LFS_NTC_LFCB;
        Lfcb->NodeByteSize = sizeof( LFCB );

        //
        //  Initialize the client links.
        //

        InitializeListHead( &Lfcb->LchLinks );

        //
        //  Initialize the Lbcb links.
        //

        InitializeListHead( &Lfcb->LbcbWorkque );
        InitializeListHead( &Lfcb->LbcbActive );

        //
        //  Initialize and allocate the spare Lbcb queue.
        //

        InitializeListHead( &Lfcb->SpareLbcbList );

        for (Count = 0; Count < LFCB_RESERVE_LBCB_COUNT; Count++) {

            NextLbcb = ExAllocatePoolWithTag( PagedPool, sizeof( LBCB ), ' sfL' );

            if (NextLbcb != NULL) {

                InsertHeadList( &Lfcb->SpareLbcbList, (PLIST_ENTRY) NextLbcb );
                Lfcb->SpareLbcbCount += 1;
            }
        }

        //
        //  Initialize and allocate the spare Leb queue.
        //

        InitializeListHead( &Lfcb->SpareLebList );

        for (Count = 0; Count < LFCB_RESERVE_LEB_COUNT; Count++)  {

            NextLeb = ExAllocatePoolWithTag( PagedPool, sizeof( LEB ), ' sfL' );

            if (NextLeb != NULL) {

                InsertHeadList( &Lfcb->SpareLebList, (PLIST_ENTRY) NextLeb );
                Lfcb->SpareLebCount += 1;
            }
        }

        //
        //  Allocate the Lfcb synchronization event.
        //

        Lfcb->Sync = LfsAllocatePool( NonPagedPool, sizeof( LFCB_SYNC ));

        ExInitializeResourceLite( &Lfcb->Sync->Resource );

        //
        //  Initialize the pseudo Lsn for the restart Lbcb's
        //

        Lfcb->NextRestartLsn = LfsLi1;

        //
        //  Initialize the event to the signalled state.
        //

        KeInitializeEvent( &Lfcb->Sync->Event, NotificationEvent, TRUE );

        Lfcb->Sync->UserCount = 0;

        //
        //  Initialize the spare list mutex
        //

        ExInitializeFastMutex( &(Lfcb->Sync->SpareListMutex) );

        Lfcb->FileSize = FileSize;

    } finally {

        DebugUnwind( LfsAllocateFileControlBlock );

        if (AbnormalTermination() && (Lfcb != NULL)) {

            LfsDeallocateLfcb( Lfcb, TRUE );
            Lfcb = NULL;
        }

        DebugTrace( -1, Dbg, "LfsAllocateLfcb:  Exit -> %08lx\n", Lfcb );
    }

    return Lfcb;
}


VOID
LfsDeallocateLfcb (
    IN PLFCB Lfcb,
    IN BOOLEAN CompleteTeardown
    )

/*++

Routine Description:

    This routine releases the resources associated with a log file control
    block.

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    CompleteTeardown - Indicates if we are to completely remove this Lfcb.

Return Value:

    None

--*/

{
    PLBCB NextLbcb;
    PLEB  NextLeb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsDeallocateLfcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb  -> %08lx\n", Lfcb );

    //
    //  Check that there are no buffer blocks.
    //

    ASSERT( IsListEmpty( &Lfcb->LbcbActive ));
    ASSERT( IsListEmpty( &Lfcb->LbcbWorkque ));

    //
    //  Check that we have no clients.
    //

    ASSERT( IsListEmpty( &Lfcb->LchLinks ));

    //
    //  If there is a restart area we deallocate it.
    //

    if (Lfcb->RestartArea != NULL) {

        LfsDeallocateRestartArea( Lfcb->RestartArea );
    }

    //
    //  If there are any of the tail Lbcb's, deallocate them now.
    //

    if (Lfcb->ActiveTail != NULL) {

        LfsDeallocateLbcb( Lfcb, Lfcb->ActiveTail );
        Lfcb->ActiveTail = NULL;
    }

    if (Lfcb->PrevTail != NULL) {

        LfsDeallocateLbcb( Lfcb, Lfcb->PrevTail );
        Lfcb->PrevTail = NULL;
    }

    //
    //  Only do the following if we are to remove the Lfcb completely.
    //

    if (CompleteTeardown) {

        //
        //  If there is a resource structure we deallocate it.
        //

        if (Lfcb->Sync != NULL) {

#ifdef BENL_DBG
            KdPrint(( "LFS: lfcb teardown: 0x%x 0x%x\n", Lfcb, Lfcb->Sync ));
#endif

            ExDeleteResourceLite( &Lfcb->Sync->Resource );

            ExFreePool( Lfcb->Sync );
        }
    }

    //
    //  Deallocate all of the spare Lbcb's.
    //

    while (!IsListEmpty( &Lfcb->SpareLbcbList )) {

        NextLbcb = (PLBCB) Lfcb->SpareLbcbList.Flink;

        RemoveHeadList( &Lfcb->SpareLbcbList );

        ExFreePool( NextLbcb );
    }

    //
    //  Deallocate all of the spare Leb's.
    //

    while (!IsListEmpty( &Lfcb->SpareLebList )) {

        NextLeb = (PLEB) Lfcb->SpareLebList.Flink;

        RemoveHeadList( &Lfcb->SpareLebList );

        ExFreePool( NextLeb );
    }

    //
    //  Cleanup the log head mdls and buffer
    //

    if (Lfcb->LogHeadBuffer) {
        LfsFreePool( Lfcb->LogHeadBuffer );
    }
    if (Lfcb->LogHeadPartialMdl) {
        IoFreeMdl( Lfcb->LogHeadPartialMdl );
    }
    if (Lfcb->LogHeadMdl) {
        IoFreeMdl( Lfcb->LogHeadMdl );
    }

    if (Lfcb->ErrorLogPacket) {
        IoFreeErrorLogEntry( Lfcb->ErrorLogPacket );
        Lfcb->ErrorLogPacket = NULL;
    }

    //
    //  Discard the Lfcb structure.
    //

    ExFreePool( Lfcb );

    DebugTrace( -1, Dbg, "LfsDeallocateLfcb:  Exit\n", 0 );
    return;
}


VOID
LfsAllocateLbcb (
    IN PLFCB Lfcb,
    OUT PLBCB *Lbcb
    )

/*++

Routine Description:

    This routine will allocate the next Lbcb.  If the pool allocation fails
    we will look at the private queue of Lbcb's.

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Lbcb - Address to store the allocated Lbcb.

Return Value:

    None

--*/

{
    PLBCB NewLbcb = NULL;

    PAGED_CODE();

    //
    //  If there are enough entries on the look-aside list then get one from
    //  there.
    //

    if (Lfcb->SpareLbcbCount > LFCB_RESERVE_LBCB_COUNT) {

        NewLbcb = (PLBCB) Lfcb->SpareLbcbList.Flink;

        Lfcb->SpareLbcbCount -= 1;
        RemoveHeadList( &Lfcb->SpareLbcbList );

    //
    //  Otherwise try to allocate from pool.
    //

    } else {

        NewLbcb = ExAllocatePoolWithTag( PagedPool, sizeof( LBCB ), ' sfL' );
    }

    //
    //  If we didn't get one then look at the look-aside list.
    //

    if (NewLbcb == NULL) {

        if (Lfcb->SpareLbcbCount != 0) {

            NewLbcb = (PLBCB) Lfcb->SpareLbcbList.Flink;

            Lfcb->SpareLbcbCount -= 1;
            RemoveHeadList( &Lfcb->SpareLbcbList );

        } else {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
    }

    //
    //  Initialize the structure.
    //

    RtlZeroMemory( NewLbcb, sizeof( LBCB ));
    NewLbcb->NodeTypeCode = LFS_NTC_LBCB;
    NewLbcb->NodeByteSize = sizeof( LBCB );

    //
    //  Return it to the user.
    //

    *Lbcb = NewLbcb;
    return;
}


VOID
LfsDeallocateLbcb (
    IN PLFCB Lfcb,
    IN PLBCB Lbcb
    )

/*++

Routine Description:

    This routine will deallocate the Lbcb.  If we need one for the look-aside
    list we will put it there.

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Lbcb - This is the Lbcb to deallocate.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Deallocate any restart area attached to this Lbcb.
    //

    if (FlagOn( Lbcb->LbcbFlags, LBCB_RESTART_LBCB ) &&
        (Lbcb->PageHeader != NULL)) {

        LfsDeallocateRestartArea( Lbcb->PageHeader );
    }

    //
    //  Put this in the Lbcb queue if it is short.
    //

    if (Lfcb->SpareLbcbCount < LFCB_MAX_LBCB_COUNT) {

        InsertHeadList( &Lfcb->SpareLbcbList, (PLIST_ENTRY) Lbcb );
        Lfcb->SpareLbcbCount += 1;

    //
    //  Otherwise just free the pool block.
    //

    } else {

        ExFreePool( Lbcb );
    }

    return;
}



VOID
LfsAllocateLeb (
    IN PLFCB Lfcb,
    OUT PLEB *NewLeb
    )
/*++

Routine Description:

    This routine will allocate an Leb. If the pool fails we will fall back
    on our spare list. A failure then will result in an exception

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Leb - This will contain the new Leb

Return Value:

    None

--*/
{

    ExAcquireFastMutex( &(Lfcb->Sync->SpareListMutex) );

    try {

        *NewLeb = NULL;
        if (Lfcb->SpareLebCount < LFCB_RESERVE_LEB_COUNT) {
            (*NewLeb) = ExAllocatePoolWithTag( PagedPool, sizeof( LEB ), ' sfL' );
        }

        if ((*NewLeb) == NULL) {
            if (Lfcb->SpareLebCount > 0) {
                *NewLeb = (PLEB) Lfcb->SpareLebList.Flink;
                Lfcb->SpareLebCount -= 1;
                RemoveHeadList( &Lfcb->SpareLebList );
            } else {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }
        }

        RtlZeroMemory( (*NewLeb), sizeof( LEB ) );
        (*NewLeb)->NodeTypeCode = LFS_NTC_LEB;
        (*NewLeb)->NodeByteSize = sizeof( LEB );

    } finally {
        ExReleaseFastMutex( &(Lfcb->Sync->SpareListMutex) );
    }
}



VOID
LfsDeallocateLeb (
    IN PLFCB Lfcb,
    IN PLEB Leb
    )
/*++

Routine Description:

    This routine will deallocate an Leb. We'll cache the old Leb if there
    aren't too many already on the spare list

Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Leb - This will contain the Leb to release

Return Value:

    None

--*/

{
    if (Leb->RecordHeaderBcb != NULL) {
        CcUnpinData( Leb->RecordHeaderBcb );
    }
    if ((Leb->CurrentLogRecord != NULL) && Leb->AuxilaryBuffer) {
        LfsFreeSpanningBuffer( Leb->CurrentLogRecord );
    }

    ExAcquireFastMutex( &(Lfcb->Sync->SpareListMutex) );

    try {
        if (Lfcb->SpareLebCount < LFCB_MAX_LEB_COUNT) {
            InsertHeadList( &Lfcb->SpareLebList, (PLIST_ENTRY) Leb );
            Lfcb->SpareLebCount += 1;
        } else {
            ExFreePool( Leb );
        }
    } finally {
        ExReleaseFastMutex( &(Lfcb->Sync->SpareListMutex) );
    }
}


VOID
LfsReadPage (
    IN PLFCB Lfcb,
    IN PLARGE_INTEGER Offset,
    OUT PMDL *Mdl,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    Directly pages in a page off the disk - the cache manager interfaces (LfsPinOrMapPage)
    may come from the cache. This wil raise if memory can't be allocated and used for
    verification purposes


Arguments:

    Lfcb - Supplies a pointer to the log file control block.

    Offset - offset of page to pagein from the logfile

    Mdl - On success the mdl that describes the mdl - it must be deallocated via
          IoFreeMdl

    Buffer - On output an allocated buffer that holds the data from the page - it
          must be freed using ExFreePool

Return Value:

    None

--*/
{
    IO_STATUS_BLOCK Iosb;
    KEVENT Event;
    NTSTATUS Status;

    PAGED_CODE();

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Allocate buffer / mdl and page in the restart page from disk
    //

    *Buffer = LfsAllocatePool( NonPagedPool, (ULONG)Lfcb->LogPageSize );
    *Mdl = IoAllocateMdl( *Buffer,
                          (ULONG)Lfcb->LogPageSize,
                          FALSE,
                          FALSE,
                          NULL );

    if (*Mdl == NULL) {
        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    MmBuildMdlForNonPagedPool( *Mdl );

    //
    //  We own the LFCB sync exclusively and there is only a main resource for the logfile
    //  so we don't need to preacquire any resources before doing the page read
    //

    Status = IoPageRead( Lfcb->FileObject, *Mdl, Offset, &Event, &Iosb );
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event,
                               WrPageIn,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER)NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\sysinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    SysInit.c

Abstract:

    This module implements the Log File Service initialization.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_INITIALIZATION)

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('IsfL')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsInitializeLogFileService)
#endif

extern USHORT LfsUsaSeqNumber;


BOOLEAN
LfsInitializeLogFileService (
    )

/*++

Routine Description:

    This routine must be called during system initialization before the
    first call to logging service, to allow the Log File Service to initialize
    its global data structures.  This routine has no dependencies on other
    system components being initialized.

    This routine will initialize the global structures used by the logging
    service and start the Lfs worker thread.

Arguments:

    None

Return Value:

    TRUE if initialization was successful

--*/

{
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsInitializeLogFileService:  Enter\n", 0 );

    //
    //  If the structure has already been initialized then we can return
    //  immediately.
    //

    if (LfsData.NodeTypeCode == LFS_NTC_DATA
        && LfsData.NodeByteSize == sizeof( LFS_DATA )
        && FlagOn( LfsData.Flags, LFS_DATA_INITIALIZED )) {

        DebugTrace( -1, Dbg, "LfsInitializeLogFileService:  Exit  ->  %01x\n", TRUE );

        return TRUE;
    }

    //
    //  Zero out the structure initially.
    //

    RtlZeroMemory( &LfsData, sizeof( LFS_DATA ));

    //
    //  Assume the operation will fail.
    //

    LfsData.Flags = LFS_DATA_INIT_FAILED;

    //
    //  Initialize the global structure for Lfs.
    //

    LfsData.NodeTypeCode = LFS_NTC_DATA;
    LfsData.NodeByteSize = sizeof( LFS_DATA );

    InitializeListHead( &LfsData.LfcbLinks );

    //
    //  Initialize the synchronization objects.
    //

    ExInitializeFastMutex( &LfsData.LfsDataLock );

    //
    //  Initialize the buffer allocation.  System will be robust enough to tolerate
    //  allocation failures.
    //

    ExInitializeFastMutex( &LfsData.BufferLock );
    KeInitializeEvent( &LfsData.BufferNotification, NotificationEvent, TRUE );
    LfsData.Buffer1 = LfsAllocatePoolNoRaise( PagedPool, LFS_BUFFER_SIZE );

    if (LfsData.Buffer1 == NULL) {

        return FALSE;
    }

    LfsData.Buffer2 = LfsAllocatePoolNoRaise( PagedPool, LFS_BUFFER_SIZE );

    //
    //  Make sure we got both.
    //

    if (LfsData.Buffer2 == NULL) {

        LfsFreePool( LfsData.Buffer1 );
        LfsData.Buffer1 = NULL;
        return FALSE;
    }

    //
    //  Initialization has been successful.
    //

    ClearFlag( LfsData.Flags, LFS_DATA_INIT_FAILED );
    SetFlag( LfsData.Flags, LFS_DATA_INITIALIZED );

    //
    //  Get a random number as a seed for the Usa sequence numbers.  Use the lower
    //  bits of the current time.
    //

    KeQuerySystemTime( &CurrentTime );
    LfsUsaSeqNumber = (USHORT) CurrentTime.LowPart;

    DebugTrace( -1, Dbg, "LfsInitializeLogFileService:  Exit  ->  %01x\n", TRUE );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\registry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Registry.c

Abstract:

    This module implements the routines which clients use to register
    themselves with the Log File Service.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_REGISTRY)
#define MODULE_POOL_TAG ('rsfL')

PLFCB
LfsRestartLogFile (
    IN PFILE_OBJECT LogFile,
    IN USHORT MaximumClients,
    IN ULONG LogPageSize OPTIONAL,
    IN LONGLONG FileSize,
    IN OUT PLFS_INFO LfsInfo,
    OUT PLFS_WRITE_DATA WriteData
    );

VOID
LfsNormalizeBasicLogFile (
    IN OUT PLONGLONG FileSize,
    IN OUT PULONG LogPageSize,
    IN OUT PUSHORT LogClients,
    IN BOOLEAN UseDefaultLogPage
    );

VOID
LfsUpdateLfcbFromPgHeader (
    IN PLFCB Lfcb,
    IN ULONG LogPageSize,
    IN SHORT MajorVersion,
    IN SHORT MinorVersion,
    IN BOOLEAN PackLog
    );

VOID
LfsUpdateLfcbFromNoRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN LSN LastLsn,
    IN ULONG LogClients,
    IN ULONG OpenLogCount,
    IN BOOLEAN LogFileWrapped,
    IN BOOLEAN UseMultiplePageIo
    );

VOID
LfsUpdateLfcbFromRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN PLFS_RESTART_AREA RestartArea,
    IN USHORT RestartOffset
    );

VOID
LfsUpdateRestartAreaFromLfcb (
    IN PLFCB Lfcb,
    IN PLFS_RESTART_AREA RestartArea
    );

VOID
LfsInitializeLogFilePriv (
    IN PLFCB Lfcb,
    IN BOOLEAN ForceRestartToDisk,
    IN ULONG RestartAreaSize,
    IN LONGLONG StartOffsetForClear,
    IN BOOLEAN ClearLogFile
    );

VOID
LfsFindLastLsn (
    IN OUT PLFCB Lfcb
    );

VOID
LfsFlushLogPage (
    IN PLFCB Lfcb,
    PVOID LogPage,
    IN LONGLONG FileOffset,
    OUT PBCB *Bcb
    );

VOID
LfsRemoveClientFromList (
    IN PLFS_CLIENT_RECORD ClientArray,
    IN PLFS_CLIENT_RECORD ClientRecord,
    IN PUSHORT ListHead
    );

VOID
LfsAddClientToList (
    IN PLFS_CLIENT_RECORD ClientArray,
    IN USHORT ClientIndex,
    IN PUSHORT ListHead
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsAddClientToList)
#pragma alloc_text(PAGE, LfsCheckSubsequentLogPage)
#pragma alloc_text(PAGE, LfsCloseLogFile)
#pragma alloc_text(PAGE, LfsDeleteLogHandle)
#pragma alloc_text(PAGE, LfsFindLastLsn)
#pragma alloc_text(PAGE, LfsFlushLogPage)
#pragma alloc_text(PAGE, LfsInitializeLogFilePriv)
#pragma alloc_text(PAGE, LfsNormalizeBasicLogFile)
#pragma alloc_text(PAGE, LfsOpenLogFile)
#pragma alloc_text(PAGE, LfsReadLogFileInformation)
#pragma alloc_text(PAGE, LfsRemoveClientFromList)
#pragma alloc_text(PAGE, LfsResetUndoTotal)
#pragma alloc_text(PAGE, LfsRestartLogFile)
#pragma alloc_text(PAGE, LfsUpdateLfcbFromRestart)
#pragma alloc_text(PAGE, LfsUpdateLfcbFromNoRestart)
#pragma alloc_text(PAGE, LfsUpdateLfcbFromPgHeader)
#pragma alloc_text(PAGE, LfsUpdateRestartAreaFromLfcb)
#pragma alloc_text(PAGE, LfsVerifyLogFile)
#endif


ULONG
LfsOpenLogFile (
    IN PFILE_OBJECT LogFile,
    IN UNICODE_STRING ClientName,
    IN USHORT MaximumClients,
    IN ULONG LogPageSize OPTIONAL,
    IN LONGLONG FileSize,
    IN OUT PLFS_INFO LfsInfo,
    OUT PLFS_LOG_HANDLE LogHandle,
    OUT PLFS_WRITE_DATA WriteData
    )

/*++

Routine Description:

    This routine is called when a client wishes to register with logging
    service.  This can be a reregistration (i.e. restart after a crash)
    or an initial registration.  There can be no other active clients
    with the same name.  The Log Handle returned is then used for any
    subsequent access by this client.

    If an Lfs restart has not been done on the log file, it will be done
    at this time.

Arguments:

    LogFile - A file object for a file previously initialized for use
              as a log file.

    ClientName - This unicode string is used to uniquely identify clients
                 of the logging service.  A case-sensitive comparison is
                 used to check this name against active clients of the
                 log file.

    MaximumClients - The maximum number of clients if the log file has
                     never been initialized.

    LogPageSize - This is the recommeded size for the log page.

    FileSize - This is the size of the log file.

    LfsInfo - On entry, indicates the log file state the user may
        know about.  On exit, indicates the log file state that Lfs
        knows about.  This is a conduit for Lfs to communicate with its
        clients.

    LogHandle - The address to store the identifier the logging service
                will use to identify this client in all other Lfs calls.

    WriteData - Pointer to WRITE_DATA in caller's data structure.

Return Value:

    ULONG - Amount to add to reservation value for header for log record.

--*/

{
    PLIST_ENTRY Link;
    PLFCB ThisLfcb = NULL;
    PLFCB NewLfcb = NULL;

    USHORT ThisClient;
    PLFS_CLIENT_RECORD ClientRecord;

    PLCH Lch = NULL;

    ULONG ReservedHeader;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsOpenLogFile:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log File          -> %08lx\n", LogFile );
    DebugTrace(  0, Dbg, "Client Name       -> %08lx\n", &ClientName );
    DebugTrace(  0, Dbg, "Maximum Clients   -> %04x\n", MaximumClients );
    DebugTrace(  0, Dbg, "Log Page Size     -> %08lx\n", LogPageSize );
    DebugTrace(  0, Dbg, "File Size (Low)   -> %08lx\n", FileSize.LowPart );
    DebugTrace(  0, Dbg, "File Size (High)  -> %08lx\n", FileSize.HighPart );

    //
    //  Check that the client name length is a legal length.
    //

    if (ClientName.Length > LFS_CLIENT_NAME_MAX) {

        DebugTrace(  0, Dbg, "Illegal name length for client\n", 0 );
        DebugTrace( -1, Dbg, "LfsOpenLogFile:  Exit\n", 0 );
        ExRaiseStatus( STATUS_INVALID_PARAMETER );
    }


    //
    //  Aqcuire the global data.
    //

    LfsAcquireLfsData();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Walk through the list searching for this file object.
        //

        Link = LfsData.LfcbLinks.Flink;

        while (Link != &LfsData.LfcbLinks) {

            ThisLfcb = CONTAINING_RECORD( Link, LFCB, LfcbLinks );

            if (ThisLfcb->FileObject == LogFile) {

                DebugTrace( 0, Dbg, "Found matching log file\n", 0 );
                break;
            }

            Link = Link->Flink;
        }

        //
        //  If the log file doesn't exist, create an Lfcb and perform an
        //  Lfs restart.
        //

        if (Link == &LfsData.LfcbLinks) {

            //
            //  Call the Cache Manager to disable read ahead and write behind;
            //  we flush the log file explicitly.
            //

            CcSetAdditionalCacheAttributes( LogFile, TRUE, TRUE );

            //
            //  Perform Lfs restart on this file object.
            //

            ThisLfcb = NewLfcb = LfsRestartLogFile( LogFile,
                                                    MaximumClients,
                                                    LogPageSize,
                                                    FileSize,
                                                    LfsInfo,
                                                    WriteData );

            //
            //  Insert this Lfcb into the global list.
            //

            InsertHeadList( &LfsData.LfcbLinks, &ThisLfcb->LfcbLinks );
        }

        //
        //  At this point we have the log file control block for the file
        //  object given us.  We first check whether the log file is fatally
        //  corrupt.
        //

        if (FlagOn( ThisLfcb->Flags, LFCB_LOG_FILE_CORRUPT )) {

            //
            //  We leave the in-memory data alone and raise an error if
            //  anyone attempts to access this file.
            //

            DebugTrace( 0, Dbg, "The Lfcb is corrupt\n", 0 );
            ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  Search through and look for a client match.
        //

        ThisClient = ThisLfcb->RestartArea->ClientInUseList;

        while (ThisClient != LFS_NO_CLIENT) {

            ClientRecord = ThisLfcb->ClientArray + ThisClient;

            if (ClientRecord->ClientNameLength == (ULONG) ClientName.Length
                && RtlCompareMemory( ClientRecord->ClientName,
                                     ClientName.Buffer,
                                     ClientName.Length ) == (ULONG) ClientName.Length) {

                DebugTrace( 0, Dbg, "Matching client name found\n", 0 );
                break;
            }

            ThisClient = ClientRecord->NextClient;
        }

        //
        //  Allocate an Lch structure and link it into the Lfcb.
        //

        LfsAllocateLch( &Lch );
        InsertTailList( &ThisLfcb->LchLinks, &Lch->LchLinks );

        //
        //  Initialize the client handle with the data from the Lfcb.
        //

        Lch->Lfcb = ThisLfcb;
        Lch->Sync = ThisLfcb->Sync;
        Lch->Sync->UserCount += 1;

        //
        //  If a match isn't found, take a client block off the free list
        //  if available.
        //

        if (ThisClient == LFS_NO_CLIENT) {

            //
            //  Raise an error status if out of client blocks.
            //

            ThisClient = ThisLfcb->RestartArea->ClientFreeList;

            if (ThisClient == LFS_NO_CLIENT) {

                DebugTrace( 0, Dbg, "No free client records available\n", 0 );
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            //  Initialize the client block.
            //

            ClientRecord = ThisLfcb->ClientArray + ThisClient;

            LfsRemoveClientFromList( ThisLfcb->ClientArray,
                                     ClientRecord,
                                     &ThisLfcb->RestartArea->ClientFreeList );

            ClientRecord->ClientRestartLsn = LfsZeroLsn;
            ClientRecord->OldestLsn = ThisLfcb->OldestLsn;
            ClientRecord->ClientNameLength = ClientName.Length;
            RtlCopyMemory( ClientRecord->ClientName,
                           ClientName.Buffer,
                           ClientName.Length );

            //
            //  Add it to the in use list.
            //

            LfsAddClientToList( ThisLfcb->ClientArray,
                                ThisClient,
                                &ThisLfcb->RestartArea->ClientInUseList );
        }

        //
        //  Update the client handle with the client block information.
        //

        Lch->ClientId.SeqNumber = ClientRecord->SeqNumber;
        Lch->ClientId.ClientIndex = ThisClient;

        Lch->ClientArrayByteOffset = PtrOffset( ThisLfcb->ClientArray,
                                                ClientRecord );

        *LogHandle = (LFS_LOG_HANDLE) Lch;

    } finally {

        DebugUnwind( LfsOpenLogFile );

        //
        //  If the Lfcb has been acquired, we release it now.
        //

        if (ThisLfcb != NULL) {

            //
            //  Pass information back to our caller for the number
            //  of bytes to add to the reserved amount for a
            //  log header.
            //

            ReservedHeader = ThisLfcb->RecordHeaderLength;
            if (FlagOn( ThisLfcb->Flags, LFCB_PACK_LOG )) {

                ReservedHeader *= 2;
            }

            LfsReleaseLfcb( ThisLfcb );
        }

        //
        //  If there is an error then deallocate the Lch and any new Lfcb.
        //

        if (AbnormalTermination()) {

            if (Lch != NULL) {

                LfsDeallocateLch( Lch );
                ThisLfcb->Sync->UserCount -= 1;
            }

            if (NewLfcb != NULL) {

                LfsDeallocateLfcb( NewLfcb, TRUE );
            }
        }

        //
        //  Always free the global.
        //

        LfsReleaseLfsData();

        DebugTrace(  0, Dbg, "Log Handle    -> %08ln\n", *LogHandle );
        DebugTrace( -1, Dbg, "LfsOpenLogFile:  Exit\n", 0 );
    }

    return ReservedHeader;
}


VOID
LfsCloseLogFile (
    IN LFS_LOG_HANDLE LogHandle
    )

/*++

Routine Description:

    This routine is called when a client detaches itself from the log
    file.  On return, all prior references to this client in the log
    file are inaccessible.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

Return Value:

    None

--*/

{
    volatile NTSTATUS Status = STATUS_SUCCESS;

    PLCH Lch;

    PLFCB Lfcb;

    USHORT ClientIndex;
    PLFS_CLIENT_RECORD ClientRecord;

    BOOLEAN FlushRestart;
    BOOLEAN ExitLoop;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsCloseLogFile:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "LogHandle  ->  %08lx\n", LogHandle );

    Lch = (PLCH) LogHandle;

    //
    //  Enclose this in a loop.  We will loop as long as there are waiters or there is an IO
    //  in progress.
    //

    while (TRUE) {

        //
        //  Always assume we exit the loop.
        //

        ExitLoop = TRUE;

        //
        //  Check that the structure is a valid log handle structure.
        //

        LfsValidateLch( Lch );

        //
        //  Protect this entry point with a try-except.
        //

        try {

            //
            //  Use a try-finally to facilitate cleanup.
            //

            //
            //  Acquire the global data block and the log file control block.
            //

            LfsAcquireLfsData();

            try {

                PLBCB ThisLbcb;

                LfsAcquireLch( Lch );

                Lfcb = Lch->Lfcb;

                //
                //  If the Log file has been closed then return immediately.
                //

                if (Lfcb == NULL) {

                    try_return( NOTHING );
                }

                //
                //  Check that there are no waiters or IO in progress before proceeding.
                //

                if ((Lfcb->Waiters != 0) ||
                    (Lfcb->LfsIoState != LfsNoIoInProgress)) {

                    ExitLoop = FALSE;
                    Lfcb->Waiters += 1;
                    try_return( NOTHING );
                }

                //
                //  Check that the client Id is valid.
                //

                LfsValidateClientId( Lfcb, Lch );

                ClientRecord = Add2Ptr( Lfcb->ClientArray,
                                        Lch->ClientArrayByteOffset,
                                        PLFS_CLIENT_RECORD );

                //
                //  Remember if this client wrote a restart area.
                //

                FlushRestart = (BOOLEAN) ( LfsZeroLsn.QuadPart != ClientRecord->ClientRestartLsn.QuadPart );

                //
                //  Set the flag to indicate we are at the final close.
                //

                SetFlag( Lfcb->Flags, LFCB_FINAL_SHUTDOWN );

                //
                //  Walk through the active queue and remove any Lbcb's with
                //  data from that queue.  That will allow them to get out to disk.
                //

                while (!IsListEmpty( &Lfcb->LbcbActive )) {

                    ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                                  LBCB,
                                                  ActiveLinks );

                    RemoveEntryList( &ThisLbcb->ActiveLinks );
                    ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );

                    //
                    //  If this page has some new entries, allow it to
                    //  be flushed to disk elsewhere.  Otherwise deallocate it
                    //  here. We set LBCB_NOT_EMPTY when we first put data into
                    //  the page and add it to  the workqueue.
                    //

                    if (!FlagOn( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY )) {

                        ASSERT( NULL == ThisLbcb->WorkqueLinks.Flink );

                        if (ThisLbcb->LogPageBcb != NULL) {

                            CcUnpinDataForThread( ThisLbcb->LogPageBcb,
                                                  ThisLbcb->ResourceThread );
                        }

                        LfsDeallocateLbcb( Lfcb, ThisLbcb );
                    }
                }

                //
                //  It's possible that we have the two restart areas in the workque.
                //  They can be removed and the memory deallocated if we have no
                //  more clients.
                //
                //  We skip this action if the there is Io in progress or the user
                //  had a restart area.
                //

                if ((Lfcb->LfsIoState == LfsNoIoInProgress) && !FlushRestart) {

                    PLIST_ENTRY Links;

                    //
                    //  Now walk through the workque list looking for a non-restart
                    //  entry.
                    //

                    Links = Lfcb->LbcbWorkque.Flink;

                    //
                    //  We don't expect to see any workitems queued on readonly volumes.
                    //

                    ASSERT(!BooleanFlagOn( Lfcb->Flags, LFCB_READ_ONLY ) ||
                            (Links == &Lfcb->LbcbWorkque));

                    while (Links != &Lfcb->LbcbWorkque) {

                        ThisLbcb = CONTAINING_RECORD( Links,
                                                      LBCB,
                                                      WorkqueLinks );

                        //
                        //  If this is not a restart area, we exit and remember that
                        //  we need to flush the restart areas.
                        //

                        if (!LfsLbcbIsRestart( ThisLbcb )) {

                            FlushRestart = TRUE;
                            break;
                        }

                        Links = Links->Flink;
                    }

                    //
                    //  If we are still not to flush the restart areas remove
                    //  all of the restart areas from the queue.
                    //

                    if (!FlushRestart) {

                        while (!IsListEmpty( &Lfcb->LbcbWorkque)) {

                            ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbWorkque.Blink,
                                                          LBCB,
                                                          WorkqueLinks );

                            RemoveEntryList( &ThisLbcb->WorkqueLinks );
                            LfsDeallocateLbcb( Lfcb, ThisLbcb );
                        }
                    }

                } else {

                    FlushRestart = TRUE;
                }

                //
                //  Flush the new restart area if we need to.
                //

                if (FlushRestart && (!FlagOn( Lfcb->Flags, LFCB_READ_ONLY ))) {

                    SetFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

                    LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
                    LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
                }
#ifdef SUPW_DBG
                if (FlushRestart && FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) {
                    DbgPrint("INFO: Not writing restart areas in CloseLog for READONLY lfcb %8lx (ok)\n", Lfcb);
                }
#endif

                //
                //  Clear the Lfcb pointer in the client handle.
                //

                Lch->Lfcb = NULL;
                RemoveEntryList( &Lch->LchLinks );

                //
                //  If there are no active clients, we can remove this log file
                //  control block from the active queue.
                //

                RemoveEntryList( &Lfcb->LfcbLinks );
                LfsDeallocateLfcb( Lfcb, FALSE );


            try_exit:  NOTHING;
            } finally {

                DebugUnwind( LfsCloseLogFile );

                //
                //   Release the log file control block if held.
                //

                LfsReleaseLch( Lch );

                //
                //  Release the global data block if held.
                //

                LfsReleaseLfsData();

                DebugTrace( -1, Dbg, "LfsCloseLogFile:  Exit\n", 0 );
            }

        } except (LfsExceptionFilter( GetExceptionInformation() )) {

            Status = GetExceptionCode();
        }

        //
        //  Test if we want to exit the loop now.
        //

        if (ExitLoop) { break; }

        //
        //  Wait for the io to complete.
        //

        KeWaitForSingleObject( &Lfcb->Sync->Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        LfsAcquireLfcb( Lfcb );
        Lfcb->Waiters -= 1;
        LfsReleaseLfcb( Lfcb );
    }

    //
    //  We always let this operation succeed.
    //

    return;
}

VOID
LfsDeleteLogHandle (
    IN LFS_LOG_HANDLE LogHandle
    )

/*++

Routine Description:

    This routine is called when a client is tearing down the last of
    his volume structures.  There will be no more references to this
    handle.  If it is the last handle for the log file then we will
    deallocate the Sync structure as well.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

Return Value:

    None

--*/

{
    PLCH Lch;

    PAGED_CODE();

    //
    //  If the log handle is null then return immediately.
    //

    Lch = (PLCH) LogHandle;

    if ((Lch == NULL) ||
        (Lch->NodeTypeCode != LFS_NTC_LCH)) {

        return;
    }

    //
    //  Ignore all errors from now on.
    //

    try {

        LfsAcquireLch( Lch );

        Lch->Sync->UserCount -= 1;

        //
        //  If we are the last user then deallocate the sync structure.
        //

        if (Lch->Sync->UserCount == 0) {

            ExDeleteResourceLite( &Lch->Sync->Resource );
            ExFreePool( Lch->Sync );
            Lch->Sync = NULL;
            if (Lch->Lfcb) {
                Lch->Lfcb->Sync = NULL;
            }

        } else {

            LfsReleaseLch( Lch );
        }

        LfsDeallocateLch( Lch );

    } except (LfsExceptionFilter( GetExceptionInformation() )) {

        NOTHING;
    }

    return;
}


VOID
LfsReadLogFileInformation (
    IN LFS_LOG_HANDLE LogHandle,
    IN PLOG_FILE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine returns information about the current state of the log
    file, primarily to aid the client perform its checkpoint processing.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    Buffer - Pointer to buffer to return the log file information.

    Length - On input this is the length of the user's buffer.  On output,
             it is the amount of data stored by the Lfs in the buffer.

Return Value:

    None

--*/

{
    PLCH Lch;
    PLFCB Lfcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsReadLogFileInformation:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle    -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Buffer        -> %08lx\n", Buffer );
    DebugTrace(  0, Dbg, "Length        -> %08lx\n", *Length );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then return immediately.
        //

        if (Lfcb == NULL) {

            try_return( *Length = 0 );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  The buffer better be large enough.
        //

        if (*Length >= sizeof( LOG_FILE_INFORMATION )) {

            PLOG_FILE_INFORMATION Information;
            LONGLONG CurrentAvail;
            ULONG UnusedBytes;

            LfsCurrentAvailSpace( Lfcb,
                                  &CurrentAvail,
                                  &UnusedBytes );

            //
            //  Cast a pointer to the buffer and fill in the
            //  data.
            //

            Information = (PLOG_FILE_INFORMATION) Buffer;

            Information->TotalAvailable = Lfcb->TotalAvailable;
            Information->CurrentAvailable =  CurrentAvail;
            Information->TotalUndoCommitment = Lfcb->TotalUndoCommitment;
            Information->ClientUndoCommitment = Lch->ClientUndoCommitment;

            Information->OldestLsn = Lfcb->OldestLsn;
            Information->LastFlushedLsn = Lfcb->LastFlushedLsn;
            Information->LastLsn = Lfcb->RestartArea->CurrentLsn;

            *Length = sizeof( LOG_FILE_INFORMATION );

        } else {

            *Length = 0;
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( LfsReadLogFileInformation );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace( -1, Dbg, "LfsReadLogFileInformation:  Exit\n", 0 );
    }

    return;
}


BOOLEAN
LfsVerifyLogFile (
    IN LFS_LOG_HANDLE LogHandle,
    IN PVOID LogFileHeader,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is called by a client to verify that the volume has not been removed
    from the system and then reattached.  We will verify the log file open count on
    disk matches the value in the user's handle.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    LogFileHeader - Pointer to start of log file.

    Length - Number bytes returned with the read.

Return Value:

    BOOLEAN - TRUE if the log file has not been altered externally, FALSE if we
        fail for any reason.

--*/

{
    BOOLEAN ValidLogFile = FALSE;
    PLCH Lch;
    PLFCB Lfcb;

    PLFS_RESTART_PAGE_HEADER RestartPage = LogFileHeader;

    PAGED_CODE();

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    if ((Lch == NULL) ||
        (Lch->NodeTypeCode != LFS_NTC_LCH) ||
        ((Lch->Lfcb != NULL) &&
         (Lch->Lfcb->NodeTypeCode != LFS_NTC_LFCB))) {

        return FALSE;
    }

    //
    //  Acquire the log file control block for this log file.
    //

    LfsAcquireLch( Lch );
    Lfcb = Lch->Lfcb;

    //
    //  If the Log file has been closed then return immediately.
    //

    if (Lfcb == NULL) {

        LfsReleaseLch( Lch );
        return FALSE;
    }

    //
    //  Check that we have at least one page and that the page is valid.
    //

    if ((Length >= (ULONG) Lfcb->LogPageSize) &&
        (*((PULONG) RestartPage) == LFS_SIGNATURE_RESTART_PAGE_ULONG) &&
        ((RestartPage->RestartOffset + sizeof( LFS_RESTART_AREA )) < (ULONG) Lfcb->LogPageSize) &&
        ((Add2Ptr( RestartPage, RestartPage->RestartOffset, PLFS_RESTART_AREA ))->RestartOpenLogCount == Lfcb->CurrentOpenLogCount)) {

        ValidLogFile = TRUE;
    }

    LfsReleaseLfcb( Lfcb );
    return ValidLogFile;
}


VOID
LfsResetUndoTotal (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberRecords,
    IN LONG ResetTotal
    )

/*++

Routine Description:

    This routine is called to adjust the undo commitment for this client.
    If the reset total is positive, then we absolutely set the
    reserve value for the client using this as the basis.  If the value
    is negative, we will adjust the current value for the client.

    To adjust the values in the Lfcb, we first return the Undo commitment
    in the handle and then adjust by the values passed in.

    To adjust the value in the client handle, we simply set it if
    the reset value is positive, adjust it if the value is negative.

    For a packed log file we just reserve the space requested.  We
    have already taken into account the loss of the tail of each page.
    For an unpacked log file we double each value.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    NumberRecords - This is the number of records we should assume the
                    reset total covers.  We allow an Lfs header for
                    each one.

    ResetTotal - This is the amount to adjust (or set) the undo
                 commitment.

Return Value:

    None

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    LONGLONG AdjustedUndoTotal;
    LONG LfsHeaderBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsResetUndoTotal:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle        -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Number Records    -> %08lx\n", NumberRecords );
    DebugTrace(  0, Dbg, "ResetTotal        -> %08lx\n", ResetTotal );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  Compute the adjusted reset total.  Start by computing the
        //  bytes needed for the Lfs log headers.  Add (or subtract) this
        //  from the reset total and multiply by 2 (only if not packing the
        //  log).
        //

        LfsHeaderBytes = NumberRecords * Lfcb->RecordHeaderLength;
        LfsHeaderBytes *= 2;

        if (!FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

            ResetTotal *= 2;
        }

        //
        //  If the reset total is positive, add the header bytes.
        //

        if (ResetTotal > 0) {

            //
            //  Subtract the client's current value from the TotalUndo
            //  commit if he is setting his value exactly.
            //

            Lfcb->TotalUndoCommitment = Lfcb->TotalUndoCommitment - Lch->ClientUndoCommitment;

            //
            //  We can clear the values in the user's handle at this
            //  time.
            //

            Lch->ClientUndoCommitment = 0;


            ResetTotal += LfsHeaderBytes;

        //
        //  Otherwise subtract the value for the header bytes.
        //

        } else {

            ResetTotal -= LfsHeaderBytes;
        }

        //
        //  Now we adjust the Lfcb and Lch values by the adjustment amount.
        //

        AdjustedUndoTotal = ResetTotal;

        Lfcb->TotalUndoCommitment = Lfcb->TotalUndoCommitment + AdjustedUndoTotal;

        Lch->ClientUndoCommitment = Lch->ClientUndoCommitment + AdjustedUndoTotal;

    } finally {

        DebugUnwind( LfsResetUndoTotal );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace( -1, Dbg, "LfsResetUndoTotal:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine.
//

PLFCB
LfsRestartLogFile (
    IN PFILE_OBJECT LogFile,
    IN USHORT MaximumClients,
    IN ULONG LogPageSize OPTIONAL,
    IN LONGLONG FileSize,
    IN OUT PLFS_INFO LfsInfo,
    OUT PLFS_WRITE_DATA WriteData
    )

/*++

Routine Description:

    This routine is called to process an existing log file when it opened
    for the first time on a running system.  We walk through the beginning
    of the file looking for a valid restart area.  Once we have a restart
    area, we can find the next restart area and determine which is the
    most recent.  The data in the restart area will tell us if the system
    has been gracefully shutdown and whether the log file in its current
    state can run on the current system.

    If the file is usable, we perform any necessary initialization on the
    file to prepare it for operation.

Arguments:

    LogFile - This is the file to use as a log file.

    MaximumClients - This is the maximum number of clients that will be
                     active in the log file at any one time.

    LogPageSize - If specified (not 0), this is the recommended size of
                  the log page.  Lfs will use this as a guide in
                  determining the log page size.

    FileSize - This is the available size of the log file.

    LfsInfo - On entry, indicates the log file state the user may
        know about.  On exit, indicates the log file state that Lfs
        knows about.  This is a conduit for Lfs to communicate with its
        clients.

    WriteData - Pointer to WRITE_DATA in caller's data structure.

Return Value:

    PLFCB - A pointer to an initialized Lfcb to use for
                              this log file.

--*/

{
    PLFCB ThisLfcb = NULL;
    PLFS_RESTART_AREA RestartArea = NULL;
    PLFS_RESTART_AREA DiskRestartArea;

    BOOLEAN UninitializedFile;

    LONGLONG OriginalFileSize = FileSize;
    LONGLONG FirstRestartOffset;
    PLFS_RESTART_PAGE_HEADER FirstRestartPage;
    BOOLEAN FirstChkdskWasRun;
    BOOLEAN FirstValidPage;
    BOOLEAN FirstLogPacked;
    LSN FirstRestartLastLsn;

    PBCB FirstRestartPageBcb = NULL;
    PBCB SecondRestartPageBcb = NULL;

    BOOLEAN PackLogFile = TRUE;
    BOOLEAN UseDefaultLogPage = FALSE;
    LARGE_INTEGER CurrentTime;

    BOOLEAN ForceRestartToDisk = FALSE;
    BOOLEAN ClearLogFile = FALSE;
    LONGLONG StartOffsetForClear = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsRestartLogFile:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "LogFile    -> %08lx\n", LogFile );
    DebugTrace(  0, Dbg, "Maximum Clients   -> %04x\n", MaximumClients );
    DebugTrace(  0, Dbg, "Log Page Size     -> %08lx\n", LogPageSize );
    DebugTrace(  0, Dbg, "File Size (Low)   -> %08lx\n", FileSize.LowPart );
    DebugTrace(  0, Dbg, "File Size (High)  -> %08lx\n", FileSize.HighPart );
    DebugTrace(  0, Dbg, "Pack Log           -> %04x\n", *LfsInfo );

    //
    //  Remember if we are to pack the log file.  Once a log file has
    //  been packed we will attempt to keep it that way.
    //

    ASSERT( LfsInfo->LfsClientInfo >= LfsPackLog );


    if (LogPageSize == 0) {
        UseDefaultLogPage = TRUE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Normalize the values passed in with this call.
        //

        LfsNormalizeBasicLogFile( &FileSize,
                                  &LogPageSize,
                                  &MaximumClients,
                                  UseDefaultLogPage );

        //
        //  Allocate an Lfcb to use for this file.
        //

        ThisLfcb = LfsAllocateLfcb( LogPageSize, FileSize );

        //
        //  Acquire the Lfcb and store it in the global queue.
        //

        LfsAcquireLfcb( ThisLfcb );

        //
        //  Remember this log file in the Lfcb.
        //

        ThisLfcb->FileObject = LogFile;

        SetFlag( ThisLfcb->Flags,
                 (LFCB_READ_FIRST_RESTART |
                  LFCB_READ_SECOND_RESTART) );

        if (LfsInfo->ReadOnly) {

            SetFlag( ThisLfcb->Flags, LFCB_READ_ONLY );
        }

        //
        //  Look for a restart area on the disk.
        //

        if (!LfsInfo->BadRestart &&
            LfsReadRestart( ThisLfcb,
                            FileSize,
                            TRUE,
                            &FirstRestartOffset,
                            &FirstRestartPage,
                            &FirstRestartPageBcb,
                            &FirstChkdskWasRun,
                            &FirstValidPage,
                            &UninitializedFile,
                            &FirstLogPacked,
                            &FirstRestartLastLsn )) {

            BOOLEAN DoubleRestart;

            LONGLONG SecondRestartOffset;
            PLFS_RESTART_PAGE_HEADER SecondRestartPage;
            BOOLEAN SecondChkdskWasRun;
            BOOLEAN SecondValidPage;
            BOOLEAN SecondLogPacked;
            LSN SecondRestartLastLsn;

            //
            //  If the restart offset above wasn't zero then we
            //  won't look for a second restart.
            //

            if (FirstRestartOffset == 0) {

                ClearFlag( ThisLfcb->Flags, LFCB_READ_FIRST_RESTART );

                DoubleRestart = LfsReadRestart( ThisLfcb,
                                                FileSize,
                                                FALSE,
                                                &SecondRestartOffset,
                                                &SecondRestartPage,
                                                &SecondRestartPageBcb,
                                                &SecondChkdskWasRun,
                                                &SecondValidPage,
                                                &UninitializedFile,
                                                &SecondLogPacked,
                                                &SecondRestartLastLsn );

                if (DoubleRestart) {

                    ClearFlag( ThisLfcb->Flags, LFCB_READ_SECOND_RESTART );
                }

            } else {

                ClearFlag( ThisLfcb->Flags, LFCB_READ_SECOND_RESTART );
                DoubleRestart = FALSE;
            }

            //
            //  Determine which restart area to use.
            //

            if (DoubleRestart
                && (SecondRestartLastLsn.QuadPart > FirstRestartLastLsn.QuadPart)) {

                BOOLEAN UseSecondPage = TRUE;
                PULONG SecondPage;
                PBCB SecondPageBcb = NULL;
                BOOLEAN UsaError;

                //
                //  In a very strange case we could have crashed on a system with
                //  a different page size and then run chkdsk on the new system.
                //  The second restart page may not have the chkdsk signature in
                //  that case but could have a higher final Lsn.
                //  We want to ignore the second restart area in that case.
                //

                if (FirstChkdskWasRun &&
                    (SecondRestartOffset != PAGE_SIZE)) {

                    if (NT_SUCCESS( LfsPinOrMapData( ThisLfcb,
                                                     PAGE_SIZE,
                                                     PAGE_SIZE,
                                                     FALSE,
                                                     TRUE,
                                                     TRUE,
                                                     &UsaError,
                                                     &SecondPage,
                                                     &SecondPageBcb )) &&
                        (*SecondPage == LFS_SIGNATURE_MODIFIED_ULONG)) {

                        UseSecondPage = FALSE;
                    }

                    if (SecondPageBcb != NULL) {

                        CcUnpinData( SecondPageBcb );
                    }
                }

                if (UseSecondPage) {

                    FirstRestartOffset = SecondRestartOffset;
                    FirstRestartPage = SecondRestartPage;
                    FirstChkdskWasRun = SecondChkdskWasRun;
                    FirstValidPage = SecondValidPage;
                    FirstLogPacked = SecondLogPacked;
                    FirstRestartLastLsn = SecondRestartLastLsn;
                }

            }

#ifdef LFS_CLUSTER_CHECK
            //
            //  Capture the current position out of the page.
            //

            ThisLfcb->LsnRangeIndex = *(Add2Ptr( FirstRestartPage, 0xe00 - sizeof( ULONG ), PULONG ));

            if (ThisLfcb->LsnRangeIndex >= 0x20) {

                ThisLfcb->LsnRangeIndex = 0;
            }
#endif
            //
            //  If the restart area is at offset 0, we want to write
            //  the second restart area out first.
            //

            if (FirstRestartOffset != 0) {

                ThisLfcb->InitialRestartArea = TRUE;
            }

            //
            //  If we have a valid page then grab a pointer to the restart area.
            //

            if (FirstValidPage) {

                DiskRestartArea = Add2Ptr( FirstRestartPage, FirstRestartPage->RestartOffset, PLFS_RESTART_AREA );
            }

            //
            //  If checkdisk was run or there are no active clients,
            //  then we will begin at the start of the log file.
            //

            if (FirstChkdskWasRun
                || DiskRestartArea->ClientInUseList == LFS_NO_CLIENT) {

                //
                //  Default version is 1.1.
                //

                SHORT MajorVersion = 1;
                SHORT MinorVersion = 1;

                BOOLEAN LogFileWrapped = FALSE;
                BOOLEAN UseMultiplePageIo = FALSE;

                //
                //  We want to do a complete initialization
                //

                ForceRestartToDisk = TRUE;
                ClearLogFile = TRUE;
                StartOffsetForClear = LogPageSize * 2;

                //
                //  Do some checks based on whether we have a valid log page.
                //

                if (FirstValidPage) {

                    CurrentTime.LowPart = DiskRestartArea->RestartOpenLogCount;

                    //
                    //  If the restart page size isn't changing then we want to
                    //  check how much work we need to do.
                    //

                    if (LogPageSize == FirstRestartPage->SystemPageSize) {

                        //
                        //  If the file size is changing we want to remember
                        //  at which point we want to start clearing the file.
                        //

                        if (FileSize > DiskRestartArea->FileSize) {

                            StartOffsetForClear = DiskRestartArea->FileSize;

                        } else {

                            if (!FlagOn( DiskRestartArea->Flags, RESTART_SINGLE_PAGE_IO )) {

                                UseMultiplePageIo = TRUE;
                                LogFileWrapped = TRUE;
                            }

                            //
                            //  If the page is valid we don't need to clear the log
                            //  file or force the data to disk.
                            //

                            ForceRestartToDisk = FALSE;
                            ClearLogFile = FALSE;
                        }
                    }

                } else {

                    KeQuerySystemTime( &CurrentTime );
                }

                //
                //  Initialize our Lfcb for the current log page values.
                //

                LfsUpdateLfcbFromPgHeader( ThisLfcb,
                                           LogPageSize,
                                           MajorVersion,
                                           MinorVersion,
                                           PackLogFile );

                LfsUpdateLfcbFromNoRestart( ThisLfcb,
                                            FileSize,
                                            FirstRestartLastLsn,
                                            MaximumClients,
                                            CurrentTime.LowPart,
                                            LogFileWrapped,
                                            UseMultiplePageIo );

                LfsAllocateRestartArea( &RestartArea, ThisLfcb->RestartDataSize );

                LfsUpdateRestartAreaFromLfcb( ThisLfcb, RestartArea );

                ThisLfcb->RestartArea = RestartArea;
                ThisLfcb->ClientArray = Add2Ptr( RestartArea,
                                                 ThisLfcb->ClientArrayOffset,
                                                 PLFS_CLIENT_RECORD );
                RestartArea = NULL;

                //
                //  Unpin any pages pinned here.
                //

                if (FirstRestartPageBcb != NULL) {

                    CcUnpinData( FirstRestartPageBcb );
                    FirstRestartPageBcb = NULL;
                }

                if (SecondRestartPageBcb != NULL) {

                    CcUnpinData( SecondRestartPageBcb );
                    SecondRestartPageBcb = NULL;
                }

                //
                //  Now update the caller's WRITE_DATA structure.
                //

                ThisLfcb->UserWriteData = WriteData;
                WriteData->LfsStructureSize = LogPageSize;
                WriteData->Lfcb = ThisLfcb;

                //
                //  If we are doing a read only mount and we need to
                //  write restart areas to disk, we are hosed.
                //

                if (LfsInfo->ReadOnly && ForceRestartToDisk) {

                    ASSERTMSG("INFO: ReadOnly Mount, Cant write restart. Raising\n", FALSE);
                    ExRaiseStatus( STATUS_MEDIA_WRITE_PROTECTED );
                }

            //
            //  If the log page or the system page sizes have changed,
            //  we can't use the log file.  We must use the system
            //  page size instead of the default size if there is not
            //  a clean shutdown.
            //

            } else {

                if (LogPageSize != FirstRestartPage->SystemPageSize) {

                    FileSize = OriginalFileSize;
                    LfsNormalizeBasicLogFile( &FileSize,
                                              &LogPageSize,
                                              &MaximumClients,
                                              (BOOLEAN) (FirstRestartPage->SystemPageSize == LFS_DEFAULT_LOG_PAGE_SIZE) );
                }

                if ((LogPageSize != FirstRestartPage->SystemPageSize) ||
                    (LogPageSize != FirstRestartPage->LogPageSize)) {

                    DebugTrace( 0, Dbg, "Page size mismatch\n", 0 );
                    ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );

                //
                //  Otherwise we have a restart area to deal with.
                //

                } else {

                    //
                    //  We preserve the packed status from the disk.
                    //

                    PackLogFile = FirstLogPacked;

                    //
                    //  Update the Lfcb from the values in the restart area
                    //  page header and the active restart page.
                    //

                    LfsUpdateLfcbFromPgHeader( ThisLfcb,
                                               LogPageSize,
                                               FirstRestartPage->MajorVersion,
                                               FirstRestartPage->MinorVersion,
                                               FirstLogPacked );

                    LfsUpdateLfcbFromRestart( ThisLfcb,
                                              FileSize,
                                              DiskRestartArea,
                                              FirstRestartPage->RestartOffset );

                    //
                    //  Now allocate a restart area.
                    //

                    LfsAllocateRestartArea( &RestartArea, ThisLfcb->RestartDataSize );

                    //
                    //  We may need to grow the restart area to allow room for the open
                    //  log file count.
                    //

                    if (ThisLfcb->ClientArrayOffset == FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray )) {

                        RtlCopyMemory( RestartArea, DiskRestartArea, ThisLfcb->RestartAreaSize );

                    } else {

                        LARGE_INTEGER CurrentTime;

                        //
                        //  Copy the start of the restart area over.
                        //

                        RtlCopyMemory( RestartArea, DiskRestartArea, ThisLfcb->ClientArrayOffset );

                        //
                        //  Now copy over the client data to its new location.
                        //

                        RtlCopyMemory( RestartArea->LogClientArray,
                                       Add2Ptr( DiskRestartArea, ThisLfcb->ClientArrayOffset, PVOID ),
                                       DiskRestartArea->RestartAreaLength - ThisLfcb->ClientArrayOffset );

                        //
                        //  Update the system open count.
                        //

                        KeQuerySystemTime( &CurrentTime );

                        ThisLfcb->CurrentOpenLogCount =
                        RestartArea->RestartOpenLogCount = CurrentTime.LowPart;

                        //
                        //  Now update the numbers in the Lfcb and restart area.
                        //

                        ThisLfcb->ClientArrayOffset = FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray );
                        ThisLfcb->RestartAreaSize = ThisLfcb->ClientArrayOffset
                                                    + (sizeof( LFS_CLIENT_RECORD ) * ThisLfcb->LogClients );

                        RestartArea->ClientArrayOffset = ThisLfcb->ClientArrayOffset;
                        RestartArea->RestartAreaLength = (USHORT) ThisLfcb->RestartAreaSize;
                    }

                    //
                    //  clear the clean shutdown flag from on disk
                    //

                    ClearFlag( RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

                    //
                    //  Update the log file open count.
                    //

                    RestartArea->RestartOpenLogCount += 1;

                    ThisLfcb->RestartArea = RestartArea;

                    ThisLfcb->ClientArray = Add2Ptr( RestartArea, ThisLfcb->ClientArrayOffset, PLFS_CLIENT_RECORD );
                    RestartArea = NULL;

                    //
                    //  Unpin any pages pinned here.
                    //

                    if (FirstRestartPageBcb != NULL) {

                        CcUnpinData( FirstRestartPageBcb );
                        FirstRestartPageBcb = NULL;
                    }

                    if (SecondRestartPageBcb != NULL) {

                        CcUnpinData( SecondRestartPageBcb );
                        SecondRestartPageBcb = NULL;
                    }

                    //
                    //  update the caller's WRITE_DATA structure before finding
                    //  last LSN which may flush a log page.
                    //

                    ThisLfcb->UserWriteData = WriteData;
                    WriteData->LfsStructureSize = LogPageSize;
                    WriteData->Lfcb = ThisLfcb;

                    //
                    //  Now we need to walk through looking for the last
                    //  Lsn.
                    //

                    LfsFindLastLsn( ThisLfcb );

                    //
                    //  Recalculate the available pages in the Lfcb.
                    //

                    LfsFindCurrentAvail( ThisLfcb );

                    //
                    //  Remember which restart area to write out first.
                    //

                    if (FirstRestartOffset != 0) {

                        ThisLfcb->InitialRestartArea = TRUE;
                    }
                }
            }

#ifdef LFS_CLUSTER_CHECK

            if (FirstValidPage) {

                //
                //  Copy the tail of the page to the restart area.
                //

                RtlCopyMemory( Add2Ptr( ThisLfcb->RestartArea,
                                        0xe00 - sizeof( ULONG ) - ThisLfcb->RestartDataOffset,
                                        PVOID ),
                               Add2Ptr( FirstRestartPage,
                                        0xe00 - sizeof( ULONG ),
                                        PVOID ),
                               0x200 + sizeof( ULONG ));

                DiskRestartArea = Add2Ptr( FirstRestartPage, FirstRestartPage->RestartOffset, PLFS_RESTART_AREA );
            }
#endif

        //
        //  If the file is uninitialized, we will initialized it with new
        //  restart areas.  We can move to version 1.0 where we use
        //  update sequence array support but don't have to force the values
        //  to disk.
        //

        } else {


            //
            //  Need to determine if we are in restart.
            //  If so, treat the file as if it is not initialized.
            //

            if (!UninitializedFile && !LfsInfo->InRestart) {

                //
                //  We didn't find a restart area but the file is not initialized.
                //  This is a corrupt disk.
                //

                DebugTrace( 0, Dbg, "Log file has no restart area\n", 0 );
                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
            }

            //
            //  We need to fail the mount if the media is readonly.
            //

            if (LfsInfo->ReadOnly) {

                ExRaiseStatus( STATUS_MEDIA_WRITE_PROTECTED );
            }

            //
            //  We go to a packed system if possible.
            //

            LfsUpdateLfcbFromPgHeader( ThisLfcb,
                                       LogPageSize,
                                       1,
                                       1,
                                       PackLogFile );

            KeQuerySystemTime( &CurrentTime );
            LfsUpdateLfcbFromNoRestart( ThisLfcb,
                                        FileSize,
                                        LfsLi0,
                                        MaximumClients,
                                        CurrentTime.LowPart,
                                        FALSE,
                                        FALSE );

            LfsAllocateRestartArea( &RestartArea, ThisLfcb->RestartDataSize );

            LfsUpdateRestartAreaFromLfcb( ThisLfcb, RestartArea );

            ThisLfcb->RestartArea = RestartArea;
            ThisLfcb->ClientArray = Add2Ptr( RestartArea, ThisLfcb->ClientArrayOffset, PLFS_CLIENT_RECORD );

            ThisLfcb->InitialRestartArea = TRUE;
            RestartArea = NULL;

            //
            //  update the caller's WRITE_DATA structure.
            //

            ThisLfcb->UserWriteData = WriteData;
            WriteData->LfsStructureSize = LogPageSize;
            WriteData->Lfcb = ThisLfcb;
        }

        //
        //  Common initialization for all cases
        //

        //
        //  Allocate buffer for the first 4 pages - this includes the 2 restart pages and the 2
        //  ping - pong pages
        //

        ThisLfcb->LogHeadBuffer = LfsAllocatePool( NonPagedPool, (ULONG)(ThisLfcb->LogPageSize * 4) );
        ThisLfcb->LogHeadMdl = IoAllocateMdl( ThisLfcb->LogHeadBuffer,
                                              (ULONG)(ThisLfcb->LogPageSize * 4),
                                              FALSE,
                                              FALSE,
                                              NULL );

        if (ThisLfcb->LogHeadMdl == NULL) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        ThisLfcb->LogHeadPartialMdl = IoAllocateMdl( ThisLfcb->LogHeadBuffer,
                                              (ULONG)(ThisLfcb->LogPageSize),
                                              FALSE,
                                              FALSE,
                                              NULL );

        if (ThisLfcb->LogHeadPartialMdl == NULL) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        MmBuildMdlForNonPagedPool( ThisLfcb->LogHeadMdl );
        ThisLfcb->ErrorLogPacket = IoAllocateErrorLogEntry( ThisLfcb->FileObject->DeviceObject,  ERROR_LOG_MAXIMUM_SIZE );

        //
        //  Put both restart areas in the queue to be flushed but don't
        //  force them to disk.
        //

        if (!LfsInfo->ReadOnly) {
            LfsInitializeLogFilePriv( ThisLfcb,
                                      ForceRestartToDisk,
                                      ThisLfcb->RestartDataSize,
                                      StartOffsetForClear,
                                      ClearLogFile );
        }

    } finally {

        DebugUnwind( LfsRestartLogFile );

        //
        //  Free the Lfcb if allocated.
        //

        if (ThisLfcb != NULL) {

            LfsReleaseLfcb( ThisLfcb );

            //
            //  Free the Lfcb and Restart areas in the event of an error.
            //

            if (AbnormalTermination()) {

                LfsDeallocateLfcb( ThisLfcb, TRUE );

                if (RestartArea != NULL) {

                    LfsDeallocateRestartArea( RestartArea );
                }
            }
        }

        if (FirstRestartPageBcb != NULL) {

            CcUnpinData( FirstRestartPageBcb );
        }

        if (SecondRestartPageBcb != NULL) {

            CcUnpinData( SecondRestartPageBcb );
        }

        DebugTrace( -1, Dbg, "LfsRestartLogFile:  Exit\n", 0 );
    }

    //
    //  Indicate whether the log is packed.
    //

    if (PackLogFile
        && LfsInfo->LfsClientInfo < LfsPackLog) {

        LfsInfo->LfsClientInfo = LfsPackLog;
    }

#ifdef LFS_CLUSTER_CHECK
    ThisLfcb->LsnAtMount = ThisLfcb->LastFlushedLsn;
#endif

    return ThisLfcb;
}


//
//  Local support routine
//

VOID
LfsNormalizeBasicLogFile (
    IN OUT PLONGLONG FileSize,
    IN OUT PULONG LogPageSize,
    IN OUT PUSHORT LogClients,
    IN BOOLEAN UseDefaultLogPage
    )

/*++

Routine Description:

    This routine is called to normalize the values which describe the
    log file.  It will make the log page a multiple of the system page.
    Finally we make sure the file size ends on a log page boundary.

    On input all of the parameters have the requested values, on return
    they have the values to use.

Arguments:

    FileSize - Stated size of the log file.

    LogPageSize - Suggested size for the log page.

    LogClients - Requested number of log clients.

    UseDefaultLogPage - Indicates if we should use the hardwired log page size or base
        it on the system page size.

Return Value:

    None.

--*/

{
    ULONG LocalLogPageSize;
    LONGLONG RestartPageBytes;
    LONGLONG LogPages;

    USHORT MaximumClients;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsNormalizeBasicLogFile:  Entered\n", 0 );

    if (!UseDefaultLogPage) {
        if (*LogPageSize == 0) {
            *LogPageSize = PAGE_SIZE;
        }
    } else {
        *LogPageSize = LFS_DEFAULT_LOG_PAGE_SIZE;
    }

    //
    //  If the log file is greater than the maximum log file size, we
    //  set the log file size to the maximum size.
    //

    if (*FileSize > LfsMaximumFileSize) {

        *FileSize = LfsMaximumFileSize;
    }

    //
    //  We round the file size down to a system page boundary.  This
    //  may also change if we allow non-system page sized log pages.
    //

    *(PULONG)FileSize &= ~(*LogPageSize - 1);

    //
    //  There better be at least 2 restart pages.
    //

    RestartPageBytes = 2 * *LogPageSize;

    if (*FileSize <= RestartPageBytes) {

        DebugTrace(  0, Dbg, "Log file is too small\n", 0 );
        DebugTrace( -1, Dbg, "LfsValidateBasicLogFile:  Abnormal Exit\n", 0 );

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Now compute the number of log pages.
    //

    LogPages = *FileSize - RestartPageBytes;
    LocalLogPageSize = *LogPageSize >> 1;

    while (LocalLogPageSize) {

        LocalLogPageSize = LocalLogPageSize >> 1;
        LogPages = ((ULONGLONG)(LogPages)) >> 1;
    }

    //
    //  If there aren't enough log pages then raise an error condition.
    //

    if (((PLARGE_INTEGER)&LogPages)->HighPart == 0
        && (ULONG)LogPages < MINIMUM_LFS_PAGES) {

        DebugTrace(  0, Dbg, "Not enough log pages -> %08lx\n", LogPages.LowPart );
        DebugTrace( -1, Dbg, "LfsValidateBasicLogFile:  Abnormal Exit\n", 0 );

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Now we compute the amount of space available for log clients.
    //  We will limit the clients to half of the restart system page.
    //

    MaximumClients = (USHORT) ((*LogPageSize / 2) / sizeof( LFS_CLIENT_RECORD ));

    if (*LogClients == 0) {

        *LogClients = 1;

    } else if (*LogClients > MaximumClients) {

        *LogClients = MaximumClients;
    }

    DebugTrace( -1, Dbg, "LfsNormalizeBasicLogFile:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

VOID
LfsUpdateLfcbFromPgHeader (
    IN PLFCB Lfcb,
    IN ULONG LogPageSize,
    IN SHORT MajorVersion,
    IN SHORT MinorVersion,
    IN BOOLEAN PackLog
    )

/*++

Routine Description:

    This routine updates the values in the Lfcb which depend on values in the
    restart page header.

Arguments:

    Lfcb - Log file control block to update.

    LogPageSize - Log page size to use.

    MajorVersion - Major version number for Lfs.

    MinorVersion - Minor version number for Lfs.

    PackLog - Indicates if we are packing the log file.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsUpdateLfcbFromPgHeader:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "System Page Size  -> %08lx\n", SystemPageSize );
    DebugTrace(  0, Dbg, "Log Page Size     -> %08lx\n", LogPageSize );
    DebugTrace(  0, Dbg, "Major Version     -> %04x\n", MajorVersion );
    DebugTrace(  0, Dbg, "Minor Version     -> %04x\n", MinorVersion );

    //
    //  Do the same for the log pages.
    //

    Lfcb->LogPageSize = LogPageSize;
    Lfcb->LogPageMask = LogPageSize - 1;
    Lfcb->LogPageInverseMask = ~Lfcb->LogPageMask;

    Lfcb->LogPageShift = 0;

    while (TRUE) {

        LogPageSize = LogPageSize >> 1;

        if (LogPageSize == 0) {

            break;
        }

        Lfcb->LogPageShift += 1;
    }

    //
    //  If we are packing the log file then the first log page is page
    //  4 (in log pages).  Otherwise it is page 2.  Use the PackLog value to determine the
    //  Usa values.
    //


    if (PackLog) {

        Lfcb->FirstLogPage = Lfcb->LogPageSize << 2;
        Lfcb->LogRecordUsaOffset = (USHORT) LFS_PACKED_RECORD_PAGE_HEADER_SIZE;
        SetFlag( Lfcb->Flags, LFCB_PACK_LOG );

    } else {

        Lfcb->FirstLogPage = Lfcb->LogPageSize << 1;
        Lfcb->LogRecordUsaOffset = (USHORT) LFS_UNPACKED_RECORD_PAGE_HEADER_SIZE;
    }

    //
    //  Remember the values for the version numbers.
    //

    Lfcb->MajorVersion = MajorVersion;
    Lfcb->MinorVersion = MinorVersion;

    //
    //  Compute the offsets for the update sequence arrays.
    //

    Lfcb->RestartUsaOffset = LFS_RESTART_PAGE_HEADER_SIZE;
    Lfcb->UsaArraySize = (USHORT) UpdateSequenceArraySize( (ULONG)Lfcb->LogPageSize );

    DebugTrace( -1, Dbg, "LfsUpdateLfcbFromPgHeader:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

VOID
LfsUpdateLfcbFromNoRestart (
    IN PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN LSN LastLsn,
    IN ULONG LogClients,
    IN ULONG OpenLogCount,
    IN BOOLEAN LogFileWrapped,
    IN BOOLEAN UseMultiplePageIo
    )

/*++

Routine Description:

    This routine updates the values in the Lfcb in cases when we don't have a
    restart area to use.

Arguments:

    Lfcb - Log file control block to update.

    FileSize - Log file size.  This is the usable size of the log file.  It has
        already been adjusted to the log page size.

    LastLsn - This is the last Lsn to use for the disk.

    LogClients - This is the number of clients supported.

    OpenLogCount - This is the current count of opens for this log file.

    LogFileWrapped - Indicates if the log file has wrapped.

    UseMultiplePageIo - Indicates if we should be using large i/o transfers.

Return Value:

    None.

--*/

{
    ULONG Count;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsUpdateLfcbFromNoRestart:  Entered\n", 0 );

    Lfcb->FileSize = FileSize;

    //
    //  We can compute the number of bits needed for the file size by shifting
    //  until the size is 0.  We then can subtract 3 bits to account for
    //  quadaligning all file offsets for log records.
    //

    for (Count = 0;
         ( FileSize != 0 );
         Count += 1,
         FileSize = ((ULONGLONG)(FileSize)) >> 1) {
    }

    Lfcb->FileDataBits = Count - 3;

    Lfcb->SeqNumberBits = (sizeof( LSN ) * 8) - Lfcb->FileDataBits;

    //
    //  We get a starting sequence number from the given Lsn.
    //  We add 2 to this for our starting sequence number.
    //

    Lfcb->SeqNumber = LfsLsnToSeqNumber( Lfcb, LastLsn ) + 2;

    Lfcb->SeqNumberForWrap = Lfcb->SeqNumber + 1;

    Lfcb->NextLogPage = Lfcb->FirstLogPage;

    SetFlag( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_NO_OLDEST_LSN );

    //
    //  The oldest Lsn is contructed from the sequence number.
    //

    Lfcb->OldestLsn.QuadPart = LfsFileOffsetToLsn( Lfcb, 0, Lfcb->SeqNumber );
    Lfcb->OldestLsnOffset = 0;

    Lfcb->LastFlushedLsn = Lfcb->OldestLsn;

    //
    //  Set the correct flags for the I/O and indicate if we have wrapped.
    //

    if (LogFileWrapped) {

        SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
    }

    if (UseMultiplePageIo) {

        SetFlag( Lfcb->Flags, LFCB_MULTIPLE_PAGE_IO );
    }

    //
    //  Compute the Log page values.
    //

    (ULONG)Lfcb->LogPageDataOffset = QuadAlign( Lfcb->LogRecordUsaOffset + (sizeof( UPDATE_SEQUENCE_NUMBER ) * Lfcb->UsaArraySize) );

    Lfcb->LogPageDataSize = Lfcb->LogPageSize - Lfcb->LogPageDataOffset;
    Lfcb->RecordHeaderLength = LFS_RECORD_HEADER_SIZE;

    if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

        //
        //  Allocate the Lbcb for the tail of the packed log file.
        //

        LfsAllocateLbcb( Lfcb, &Lfcb->PrevTail );
        Lfcb->PrevTail->FileOffset = Lfcb->FirstLogPage - Lfcb->LogPageSize;

        LfsAllocateLbcb( Lfcb, &Lfcb->ActiveTail );
        Lfcb->ActiveTail->FileOffset = Lfcb->PrevTail->FileOffset - Lfcb->LogPageSize;

        //
        //  Remember the different page sizes for reservation.
        //

        (ULONG)Lfcb->ReservedLogPageSize = (ULONG)Lfcb->LogPageDataSize - Lfcb->RecordHeaderLength;

    } else {

        (ULONG)Lfcb->ReservedLogPageSize = (ULONG)Lfcb->LogPageDataSize;
    }

    //
    //  Compute the restart page values.
    //

    Lfcb->RestartDataOffset = QuadAlign( LFS_RESTART_PAGE_HEADER_SIZE + (sizeof( UPDATE_SEQUENCE_NUMBER ) * Lfcb->UsaArraySize) );

    Lfcb->RestartDataSize = (ULONG)Lfcb->LogPageSize - Lfcb->RestartDataOffset;

    Lfcb->LogClients = (USHORT) LogClients;

    Lfcb->ClientArrayOffset = FIELD_OFFSET( LFS_RESTART_AREA, LogClientArray );

    Lfcb->RestartAreaSize = Lfcb->ClientArrayOffset
                            + (sizeof( LFS_CLIENT_RECORD ) * Lfcb->LogClients );

    Lfcb->CurrentOpenLogCount = OpenLogCount;

    //
    //  The total available log file space is the number of log file pages times
    //  the space available on each page.
    //

    Lfcb->TotalAvailInPages = Lfcb->FileSize - Lfcb->FirstLogPage;
    Lfcb->TotalAvailable = Int64ShrlMod32(((ULONGLONG)(Lfcb->TotalAvailInPages)), Lfcb->LogPageShift);

    //
    //  If the log file is packed we assume that we can't use the end of the
    //  page less than the file record size.  Then we won't need to reserve more
    //  than the caller asks for.
    //

    Lfcb->MaxCurrentAvail = Lfcb->TotalAvailable * (ULONG)Lfcb->ReservedLogPageSize;

    Lfcb->TotalAvailable = Lfcb->TotalAvailable * (ULONG)Lfcb->LogPageDataSize;

    Lfcb->CurrentAvailable = Lfcb->MaxCurrentAvail;

    DebugTrace( -1, Dbg, "LfsUpdateLfcbFromNoRestart:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
LfsUpdateLfcbFromRestart (
    IN OUT PLFCB Lfcb,
    IN LONGLONG FileSize,
    IN PLFS_RESTART_AREA RestartArea,
    IN USHORT RestartOffset
    )

/*++

Routine Description:

    This routine updates the values in the Lfcb based on data in the
    restart area.

Arguments:

    Lfcb - Log file control block to update.

    RestartArea - Restart area to use to update the Lfcb.

    RestartOffset - This is the offset to the restart area in the restart page.

Return Value:

    None.

--*/

{
    LONGLONG LsnFileOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsUpdateLfcbFromRestartArea:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb          -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "RestartArea   -> %08lx\n", RestartArea );

    //
    //  Never set the filesize bigger than the actual filesize
    //  on clean shutdowns use the real size - on non clean shutdowns
    //  let the filesize shrink but not expand - we're stuck the the file data bits
    //  until the next boot when we can adjust it for the new size
    //

    if (FlagOn( RestartArea->Flags, LFS_CLEAN_SHUTDOWN)) {
        Lfcb->FileSize = FileSize;
    } else {
        Lfcb->FileSize = min( FileSize, RestartArea->FileSize );
    }

    //
    //  We get the sequence number bits from the restart area and compute the
    //  file data bits.
    //

    Lfcb->SeqNumberBits = RestartArea->SeqNumberBits;
    Lfcb->FileDataBits = (sizeof( LSN ) * 8) - Lfcb->SeqNumberBits;

    //
    //  We look at the last flushed Lsn to determine the current sequence count and
    //  the next log page to examine.
    //

    Lfcb->LastFlushedLsn = RestartArea->CurrentLsn;

    Lfcb->SeqNumber = LfsLsnToSeqNumber( Lfcb, Lfcb->LastFlushedLsn );
    Lfcb->SeqNumberForWrap = Lfcb->SeqNumber + 1;

    //
    //  The restart area size depends on the number of clients and whether the
    //  the file is packed.
    //

    Lfcb->LogClients = RestartArea->LogClients;

    //
    //  Compute the restart page values from the restart offset.
    //

    Lfcb->RestartDataOffset = RestartOffset;
    Lfcb->RestartDataSize = (ULONG)Lfcb->LogPageSize - RestartOffset;

    //
    //  For a packed log file we can find the following values in the restart
    //  area.  Otherwise we compute them from the current structure sizes.
    //

    if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

        Lfcb->RecordHeaderLength = RestartArea->RecordHeaderLength;

        Lfcb->ClientArrayOffset = RestartArea->ClientArrayOffset;

        Lfcb->RestartAreaSize = RestartArea->RestartAreaLength;

        (ULONG)Lfcb->LogPageDataOffset = RestartArea->LogPageDataOffset;
        Lfcb->LogPageDataSize = Lfcb->LogPageSize - Lfcb->LogPageDataOffset;

        //
        //  For packed files we allocate the tail Lbcbs.
        //

        LfsAllocateLbcb( Lfcb, &Lfcb->PrevTail );
        Lfcb->PrevTail->FileOffset = Lfcb->FirstLogPage - Lfcb->LogPageSize;

        LfsAllocateLbcb( Lfcb, &Lfcb->ActiveTail );
        Lfcb->ActiveTail->FileOffset = Lfcb->PrevTail->FileOffset - Lfcb->LogPageSize;

        //
        //  Remember the different page sizes for reservation.
        //

        (ULONG)Lfcb->ReservedLogPageSize = (ULONG)Lfcb->LogPageDataSize - Lfcb->RecordHeaderLength;

    } else {

        Lfcb->RecordHeaderLength = LFS_RECORD_HEADER_SIZE;
        Lfcb->ClientArrayOffset = FIELD_OFFSET( LFS_OLD_RESTART_AREA, LogClientArray );

        Lfcb->RestartAreaSize = Lfcb->ClientArrayOffset
                                + (sizeof( LFS_CLIENT_RECORD ) * Lfcb->LogClients);

        (ULONG)Lfcb->LogPageDataOffset = QuadAlign( Lfcb->LogRecordUsaOffset + (sizeof( UPDATE_SEQUENCE_NUMBER ) * Lfcb->UsaArraySize) );

        Lfcb->LogPageDataSize = Lfcb->LogPageSize - Lfcb->LogPageDataOffset;

        (ULONG)Lfcb->ReservedLogPageSize = (ULONG)Lfcb->LogPageDataSize;
    }

    //
    //  If the current last flushed Lsn offset is before the first log page
    //  then this is a pseudo Lsn.
    //

    LsnFileOffset = LfsLsnToFileOffset( Lfcb, Lfcb->LastFlushedLsn );

    if ( LsnFileOffset < Lfcb->FirstLogPage ) {

        SetFlag( Lfcb->Flags, LFCB_NO_LAST_LSN );
        Lfcb->NextLogPage = Lfcb->FirstLogPage;

    //
    //  Otherwise look at the last Lsn to determine where it ends in the file.
    //

    } else {

        LONGLONG LsnFinalOffset;
        BOOLEAN Wrapped;

        ULONG DataLength;
        ULONG RemainingPageBytes;

        DataLength = RestartArea->LastLsnDataLength;

        //
        //  Find the end of this log record.
        //

        LfsLsnFinalOffset( Lfcb,
                           Lfcb->LastFlushedLsn,
                           DataLength,
                           &LsnFinalOffset );

        //
        //  If we wrapped in the file then increment the sequence number.
        //

        if ( LsnFinalOffset <= LsnFileOffset ) {

            Lfcb->SeqNumber = 1 + Lfcb->SeqNumber;

            SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
        }

        //
        //  Now compute the next log page to use.  If we are packing the log file
        //  we will attempt to use the same page.
        //

        LfsTruncateOffsetToLogPage( Lfcb, LsnFinalOffset, &LsnFileOffset );

        RemainingPageBytes = (ULONG)Lfcb->LogPageSize
                             - ((((ULONG)LsnFinalOffset) & Lfcb->LogPageMask) + 1);

        //
        //  If we are packing the log file and we can fit another log record on the
        //  page, move back a page in the log file.
        //

        if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )
            && (RemainingPageBytes >= Lfcb->RecordHeaderLength)) {

            SetFlag( Lfcb->Flags, LFCB_REUSE_TAIL );
            Lfcb->NextLogPage = LsnFileOffset;
            Lfcb->ReusePageOffset = (ULONG)Lfcb->LogPageSize - RemainingPageBytes;

        } else {

            LfsNextLogPageOffset( Lfcb, LsnFileOffset, &Lfcb->NextLogPage, &Wrapped );
        }
    }

    //
    //  Find the oldest client Lsn.  Use the last flushed Lsn as a starting point.
    //

    Lfcb->OldestLsn = Lfcb->LastFlushedLsn;

    LfsFindOldestClientLsn( RestartArea,
                            Add2Ptr( RestartArea, Lfcb->ClientArrayOffset, PLFS_CLIENT_RECORD ),
                            &Lfcb->OldestLsn );

    Lfcb->OldestLsnOffset = LfsLsnToFileOffset( Lfcb, Lfcb->OldestLsn );

    //
    //  If there is no oldest client Lsn, then update the flag in the Lfcb.
    //

    if ( Lfcb->OldestLsnOffset < Lfcb->FirstLogPage ) {

        SetFlag( Lfcb->Flags, LFCB_NO_OLDEST_LSN );
    }

    //
    //  We need to determine the flags for the Lfcb.  These flags let us know
    //  if we wrapped in the file and if we are using multiple page I/O.
    //

    if (!FlagOn( RestartArea->Flags, RESTART_SINGLE_PAGE_IO )) {

        SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED | LFCB_MULTIPLE_PAGE_IO );
    }

    //
    //  Remember the current open log count from the disk.  We may be plucking random data out
    //  of the client area if the restart area hasn't been grown yet but we will detect that
    //  elsewhere.
    //

    Lfcb->CurrentOpenLogCount = RestartArea->RestartOpenLogCount;

    //
    //  The total available log file space is the number of log file pages times
    //  the space available on each page.
    //

    Lfcb->TotalAvailInPages = Lfcb->FileSize - Lfcb->FirstLogPage;

    Lfcb->TotalAvailable = Int64ShrlMod32(((ULONGLONG)(Lfcb->TotalAvailInPages)), Lfcb->LogPageShift);

    //
    //  If the log file is packed we assume that we can't use the end of the
    //  page less than the file record size.  Then we won't need to reserve more
    //  than the caller asks for.
    //

    Lfcb->MaxCurrentAvail = Lfcb->TotalAvailable * (ULONG)Lfcb->ReservedLogPageSize;

    Lfcb->TotalAvailable = Lfcb->TotalAvailable * (ULONG)Lfcb->LogPageDataSize;

    LfsFindCurrentAvail( Lfcb );

    DebugTrace( -1, Dbg, "LfsUpdateLfcbFromRestartArea:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

VOID
LfsUpdateRestartAreaFromLfcb (
    IN PLFCB Lfcb,
    IN PLFS_RESTART_AREA RestartArea
    )

/*++

Routine Description:

    This routine is called to update a restart area from the values stored
    in the Lfcb.  This is typically done in a case where we won't use
    any of the current values in the restart area.

Arguments:

    Lfcb - Log file control block.

    RestartArea - Restart area to update.

Return Value:

    None.

--*/

{
    PLFS_CLIENT_RECORD Client;
    USHORT ClientIndex;
    USHORT PrevClient = LFS_NO_CLIENT;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsUpdateRestartAreaFromLfcb:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08lx\n", Lfcb );

    //
    //  We can copy most of the fields directly out of Lfcb.
    //

    RestartArea->CurrentLsn = Lfcb->LastFlushedLsn;
    RestartArea->LogClients = Lfcb->LogClients;

    if (!FlagOn( Lfcb->Flags, LFCB_MULTIPLE_PAGE_IO )) {

        SetFlag( RestartArea->Flags, RESTART_SINGLE_PAGE_IO );
    }

    RestartArea->SeqNumberBits = Lfcb->SeqNumberBits;

    RestartArea->FileSize = Lfcb->FileSize;
    RestartArea->LastLsnDataLength = 0;
    RestartArea->ClientArrayOffset = Lfcb->ClientArrayOffset;
    RestartArea->RestartAreaLength = (USHORT) Lfcb->RestartAreaSize;

    RestartArea->RecordHeaderLength = Lfcb->RecordHeaderLength;
    RestartArea->LogPageDataOffset = (USHORT)Lfcb->LogPageDataOffset;

    //
    //  We set the in use list as empty and the free list as containing
    //  all of the client entries.
    //

    RestartArea->ClientInUseList = LFS_NO_CLIENT;
    RestartArea->ClientFreeList = 0;

    for (ClientIndex = 1,
         Client = Add2Ptr( RestartArea, Lfcb->ClientArrayOffset, PLFS_CLIENT_RECORD );
         ClientIndex < Lfcb->LogClients;
         ClientIndex += 1,
         Client++) {

        Client->PrevClient = PrevClient;
        Client->NextClient = ClientIndex;

        PrevClient = ClientIndex - 1;
    }

    //
    //  We're now at the last client.
    //

    Client->PrevClient = PrevClient;
    Client->NextClient = LFS_NO_CLIENT;

    //
    //  Use the current value out of the Lfcb to stamp this usage of the log file.
    //

    RestartArea->RestartOpenLogCount = Lfcb->CurrentOpenLogCount + 1;

    DebugTrace( -1, Dbg, "LfsUpdateRestartAreaFromLfcb:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
LfsInitializeLogFilePriv (
    IN PLFCB Lfcb,
    IN BOOLEAN ForceRestartToDisk,
    IN ULONG RestartAreaSize,
    IN LONGLONG StartOffsetForClear,
    IN BOOLEAN ClearLogFile
    )

/*++

Routine Description:

    This routine is our internal routine for initializing a log file.
    This can be the case where we are updating the log file for
    update sequence array, or differing page size or new log file size.

Arguments:

    Lfcb - This is the Lfcb for this log file.  It should already have
        the version number information stored.

    ForceRestartToDisk - Indicates that we want to actually force restart
        areas to disk instead of simply queueing them to the start of the
        workqueue.

    RestartAreaSize - This is the size for the restart areas.  This may
        be larger than the size in the Lfcb because we may be clearing
        stale data out of the file.

    StartOffsetForClear - If we are clearing the file we want to uninitialize
        from this point.

    ClearLogFile - Indicates if we want to uninitialize the log file to
        remove stale data.  This is done specifically when changing
        system page sizes.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsInitializeLogFilePriv:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb                  -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "Force Restart         -> %04x\n", ForceRestartToDisk );
    DebugTrace(  0, Dbg, "RestartAreaSize       -> %08lx\n", RestartAreaSize );
    DebugTrace(  0, Dbg, "StartOffset (Low)     -> %08lx\n", StartOffsetForClear.LowPart );
    DebugTrace(  0, Dbg, "StartOffset (High)    -> %08lx\n", StartOffsetForClear.HighPart );
    DebugTrace(  0, Dbg, "Clear Log File        -> %04x\n", ClearLogFile );

    //
    //  We start by queueing the restart areas.
    //

    LfsWriteLfsRestart( Lfcb,
                        RestartAreaSize,
                        FALSE );

    LfsWriteLfsRestart( Lfcb,
                        RestartAreaSize,
                        ForceRestartToDisk );

    //
    //  If we are to clear the log file, we write all 0xff into the
    //  log pages beginning at the log page offset.
    //

    if (ClearLogFile) {

        PCHAR LogPage;
        PBCB LogPageBcb = NULL;

        try {

            while ( StartOffsetForClear < Lfcb->FileSize ) {

                BOOLEAN UsaError;

                //
                //  We'll do the best we can and ignore all errors.
                //

                if (NT_SUCCESS( LfsPinOrMapData( Lfcb,
                                                 StartOffsetForClear,
                                                 (ULONG)Lfcb->LogPageSize,
                                                 TRUE,
                                                 FALSE,
                                                 TRUE,
                                                 &UsaError,
                                                 (PVOID *) &LogPage,
                                                 &LogPageBcb ))) {

                    RtlFillMemoryUlong( (PVOID)LogPage,
                                        (ULONG)Lfcb->LogPageSize,
                                        LFS_SIGNATURE_UNINITIALIZED_ULONG );

                    LfsFlushLogPage( Lfcb,
                                     LogPage,
                                     StartOffsetForClear,
                                     &LogPageBcb );

                    StartOffsetForClear = Lfcb->LogPageSize + StartOffsetForClear;
                }
            }

        } finally {

            if (LogPageBcb != NULL) {

                CcUnpinData( LogPageBcb );
            }
        }
    }

    DebugTrace( -1, Dbg, "LfsInitializeLogFilePriv:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
LfsFindLastLsn (
    IN OUT PLFCB Lfcb
    )

/*++

Routine Description:

    This routine walks through the log pages for a file, searching for the
    last log page written to the file.  It updates the Lfcb and the current
    restart area as well.

    We proceed in the following manner.

        1 - Walk through and find all of the log pages successfully
            flushed to disk.  This search terminates when either we find
            an error or when we find a previous page on the disk.

        2 - For the error case above, we want to insure that the error found
            was due to a system crash and that there are no complete I/O
            transfers after the bad region.

        3 - We will look at the 2 pages with the tail copies if the log file
            is packed to check on pages with errors.

    At the end of this routine we will repair the log file by copying the tail
    copies back to their correct location in the log file.

Arguments:

    Lfcb - Log file control block for this log file.

Return Value:

    None.

--*/

{
    USHORT PageCount;
    USHORT PagePosition;

    LONGLONG CurrentLogPageOffset;
    LONGLONG NextLogPageOffset;

    LSN LastKnownLsn;

    BOOLEAN Wrapped;
    BOOLEAN WrappedLogFile = FALSE;

    LONGLONG ExpectedSeqNumber;

    LONGLONG FirstPartialIo;
    ULONG PartialIoCount = 0;

    PLFS_RECORD_PAGE_HEADER LogPageHeader;
    PBCB LogPageHeaderBcb = NULL;

    PLFS_RECORD_PAGE_HEADER TestPageHeader;
    PBCB TestPageHeaderBcb = NULL;

    LONGLONG FirstTailFileOffset;
    PLFS_RECORD_PAGE_HEADER FirstTailPage;
    LONGLONG FirstTailOffset = 0;
    PBCB FirstTailPageBcb = NULL;

    LONGLONG SecondTailFileOffset;
    PLFS_RECORD_PAGE_HEADER SecondTailPage;
    LONGLONG SecondTailOffset = 0;
    PBCB SecondTailPageBcb = NULL;

    PLFS_RECORD_PAGE_HEADER TailPage;

    BOOLEAN UsaError;
    BOOLEAN ReplacePage = FALSE;
    BOOLEAN ValidFile = FALSE;

    BOOLEAN InitialReusePage = FALSE;

    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindLastLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb  -> %08lx\n", Lfcb );

    //
    //  The page count and page position are from the last page
    //  sucessfully read.  Initialize these to indicate the
    //  'previous' transfer was complete.
    //

    PageCount = 1;
    PagePosition = 1;

    //
    //  We have the current Lsn in the restart area.  This is the last
    //  Lsn on a log page.  We compute the next file offset and sequence
    //  number.
    //

    CurrentLogPageOffset = Lfcb->NextLogPage;

    //
    //  If the next log page is the first log page in the file and
    //  the last Lsn represented a log record, then remember that we
    //  have wrapped in the log file.
    //

    if (( CurrentLogPageOffset == Lfcb->FirstLogPage )
        && !FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL )) {

        ExpectedSeqNumber = Lfcb->SeqNumber + 1;
        WrappedLogFile = TRUE;

    } else {

        ExpectedSeqNumber = Lfcb->SeqNumber;
    }

    //
    //  If we are going to try to reuse the tail of the last known
    //  page, then remember the last Lsn on this page.
    //

    if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL )) {

        LastKnownLsn = Lfcb->LastFlushedLsn;

        //
        //  There are some special conditions allowed for this page when
        //  we read it.  It could be either the first or last of the transfer.
        //  It may also have a tail copy.
        //

        InitialReusePage = TRUE;

    } else {

        LastKnownLsn = LfsLi0;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If this is a packed log file, let's pin the two tail copy pages.
        //

        if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

            //
            //  Start with the second page.
            //

            SecondTailFileOffset = Lfcb->FirstLogPage - Lfcb->LogPageSize;

            if (NT_SUCCESS( LfsPinOrMapData( Lfcb,
                                             SecondTailFileOffset,
                                             (ULONG)Lfcb->LogPageSize,
                                             TRUE,
                                             TRUE,
                                             TRUE,
                                             &UsaError,
                                             &SecondTailPage,
                                             &SecondTailPageBcb ))) {

                //
                //  If this isn't a valid page then ignore it.
                //

                if (UsaError
                    || *((PULONG) &SecondTailPage->MultiSectorHeader.Signature) != LFS_SIGNATURE_RECORD_PAGE_ULONG) {

                    CcUnpinData( SecondTailPageBcb );
                    SecondTailPageBcb = SecondTailPage = NULL;

                } else {

                    SecondTailOffset = SecondTailPage->Copy.FileOffset;
                }

            } else if (SecondTailPageBcb != NULL) {

                CcUnpinData( SecondTailPageBcb );
                SecondTailPageBcb = SecondTailPage = NULL;
            }

            FirstTailFileOffset = SecondTailFileOffset - Lfcb->LogPageSize;

            //
            //  Now try the first.
            //

            if (NT_SUCCESS( LfsPinOrMapData( Lfcb,
                                             FirstTailFileOffset,
                                             (ULONG)Lfcb->LogPageSize,
                                             TRUE,
                                             TRUE,
                                             TRUE,
                                             &UsaError,
                                             &FirstTailPage,
                                             &FirstTailPageBcb ))) {

                //
                //  If this isn't a valid page then ignore it.
                //

                if (UsaError
                    || *((PULONG) &FirstTailPage->MultiSectorHeader.Signature) != LFS_SIGNATURE_RECORD_PAGE_ULONG) {

                    CcUnpinData( FirstTailPageBcb );
                    FirstTailPageBcb = FirstTailPage = NULL;

                } else {

                    FirstTailOffset = FirstTailPage->Copy.FileOffset;
                }

            } else if (FirstTailPageBcb != NULL) {

                CcUnpinData( FirstTailPageBcb );
                FirstTailPageBcb = FirstTailPage = NULL;
            }
        }

        //
        //  We continue walking through the file, log page by log page looking
        //  for the end of the data transferred.  The loop below looks for
        //  a log page which contains the end of a log record.  Each time a
        //  log record is successfully read from the disk, we update our in-memory
        //  structures to reflect this.  We exit this loop when we are at a point
        //  where we don't want to find any subsequent pages.  This occurs when
        //
        //      - we get an I/O error reading a page
        //      - we get a Usa error reading a page
        //      - we have a tail copy with more recent data than contained on the page
        //

        while (TRUE) {

            LONGLONG ActualSeqNumber;
            TailPage = NULL;

            //
            //  Pin the next log page, allowing errors.
            //

            Status = LfsPinOrMapData( Lfcb,
                                      CurrentLogPageOffset,
                                      (ULONG)Lfcb->LogPageSize,
                                      TRUE,
                                      TRUE,
                                      TRUE,
                                      &UsaError,
                                      (PVOID *) &LogPageHeader,
                                      &LogPageHeaderBcb );

            //
            //  Compute the next log page offset in the file.
            //

            LfsNextLogPageOffset( Lfcb,
                                  CurrentLogPageOffset,
                                  &NextLogPageOffset,
                                  &Wrapped );

            //
            //  If we are at the expected first page of a transfer
            //  check to see if either tail copy is at this offset.
            //  If this page is the last page of a transfer, check
            //  if we wrote a subsequent tail copy.
            //

            if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG ) &&
                ((PageCount == PagePosition) ||
                 (PageCount == PagePosition + 1))) {

                //
                //  Check if the offset matches either the first or second
                //  tail copy.  It is possible it will match both.
                //

                if (CurrentLogPageOffset == FirstTailOffset) {

                    TailPage = FirstTailPage;
                }

                if (CurrentLogPageOffset == SecondTailOffset) {

                    //
                    //  If we already matched on the first page then
                    //  check the ending Lsn's.
                    //

                    if ((TailPage == NULL) ||
                        (SecondTailPage->Header.Packed.LastEndLsn.QuadPart >
                         FirstTailPage->Header.Packed.LastEndLsn.QuadPart )) {

                        TailPage = SecondTailPage;
                    }
                }

                //
                //  If we have a candidate for a tail copy, check and see if it is
                //  in the expected pass through the file.  For that to be true we
                //  must be at the first page of an I/O block. Also the last Lsn on the
                //  copy page must match the last known flushed Lsn or the sequence
                //  number on the page must be the expected sequence number.
                //

                if (TailPage) {

                    if (LastKnownLsn.QuadPart < TailPage->Header.Packed.LastEndLsn.QuadPart) {

                        ActualSeqNumber = LfsLsnToSeqNumber( Lfcb, TailPage->Header.Packed.LastEndLsn );

                        //
                        //  If the sequence number is not expected, then don't use the tail
                        //  copy.
                        //

                        if (ExpectedSeqNumber != ActualSeqNumber) {

                            TailPage = NULL;
                        }

                    //
                    //  If the last Lsn is greater than the one on this page
                    //  then forget this tail.
                    //

                    } else if (LastKnownLsn.QuadPart > TailPage->Header.Packed.LastEndLsn.QuadPart) {

                        TailPage = NULL;
                    }
                }
            }

            //
            //  If we have an error on the current page, we will break out of
            //  this loop.
            //

            if (!NT_SUCCESS( Status ) || UsaError) {

                break;
            }

            //
            //  If the last Lsn on this page doesn't match the previous
            //  known last Lsn or the sequence number is not expected
            //  we are done.
            //

            ActualSeqNumber = LfsLsnToSeqNumber( Lfcb,
                                                 LogPageHeader->Copy.LastLsn );

            if ((LastKnownLsn.QuadPart != LogPageHeader->Copy.LastLsn.QuadPart) &&
                (ActualSeqNumber != ExpectedSeqNumber)) {

                break;
            }

            //
            //  Check that the page position and page count values are correct.
            //  If this is the first page of a transfer the position must be
            //  1 and the count will be unknown.
            //

            if (PageCount == PagePosition) {

                //
                //  If the current page is the first page we are looking at
                //  and we are reusing this page then it can be either the
                //  first or last page of a transfer.  Otherwise it can only
                //  be the first.
                //

                if ((LogPageHeader->PagePosition != 1) &&
                    (!InitialReusePage ||
                     (LogPageHeader->PagePosition != LogPageHeader->PageCount))) {

                    break;
                }

            //
            //  The page position better be 1 more than the last page position
            //  and the page count better match.
            //

            } else if ((LogPageHeader->PageCount != PageCount) ||
                       (LogPageHeader->PagePosition != PagePosition + 1)) {

                break;
            }

            //
            //  We have a valid page in the file and may have a valid page in
            //  the tail copy area.  If the tail page was written after
            //  the page in the file then break out of the loop.
            //

            if (TailPage &&
                (TailPage->Header.Packed.LastEndLsn.QuadPart >= LogPageHeader->Copy.LastLsn.QuadPart)) {

                //
                //  Remember if we will replace the page.
                //

                ReplacePage = TRUE;
                break;
            }

            TailPage = NULL;

            //
            //  The log page is expected.  If this contains the end of
            //  some log record we can update some fields in the Lfcb.
            //

            if (FlagOn( LogPageHeader->Flags, LOG_PAGE_LOG_RECORD_END )) {

                //
                //  Since we have read this page we know the Lfcb sequence
                //  number is the same as our expected value.  We also
                //  assume we will not reuse the tail.
                //

                Lfcb->SeqNumber = ExpectedSeqNumber;
                ClearFlag( Lfcb->Flags, LFCB_REUSE_TAIL );

                if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

                    Lfcb->LastFlushedLsn = LogPageHeader->Header.Packed.LastEndLsn;

                    //
                    //  If there is room on this page for another header then
                    //  remember we want to reuse the page.
                    //

                    if (Lfcb->RecordHeaderLength <=
                        ((ULONG)Lfcb->LogPageSize - LogPageHeader->Header.Packed.NextRecordOffset )) {

                        SetFlag( Lfcb->Flags, LFCB_REUSE_TAIL );
                        Lfcb->ReusePageOffset = LogPageHeader->Header.Packed.NextRecordOffset;
                    }

                } else {

                    Lfcb->LastFlushedLsn = LogPageHeader->Copy.LastLsn;
                }

                Lfcb->RestartArea->CurrentLsn = Lfcb->LastFlushedLsn;

                ClearFlag( Lfcb->Flags, LFCB_NO_LAST_LSN );

                //
                //  If we may try to reuse the current page then use
                //  that as the next page offset.  Otherwise move to the
                //  next page in the file.
                //

                if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL )) {

                    Lfcb->NextLogPage = CurrentLogPageOffset;

                } else {

                    Lfcb->NextLogPage = NextLogPageOffset;
                }

                //
                //  If we wrapped the log file, then we set the bit indicating so.
                //

                if (WrappedLogFile) {

                    SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
                }
            }

            //
            //  Remember the last page count and position.  Also remember
            //  the last known lsn.
            //

            PageCount = LogPageHeader->PageCount;
            PagePosition = LogPageHeader->PagePosition;
            LastKnownLsn = LogPageHeader->Copy.LastLsn;

            //
            //  If we are wrapping to the beginning of the file then update
            //  the expected sequence number.
            //

            if (Wrapped) {

                ExpectedSeqNumber = ExpectedSeqNumber + 1;
                WrappedLogFile = TRUE;
            }

            CurrentLogPageOffset = NextLogPageOffset;

            //
            //  Unpin the last log page pinned.
            //

            CcUnpinData( LogPageHeaderBcb );
            LogPageHeaderBcb = NULL;

            InitialReusePage = FALSE;
        }

        //
        //  At this point we expect that there will be no more new pages in
        //  the log file.  We could have had an error of some sort on the most recent
        //  page or we may have found a tail copy for the current page.
        //  If the error occurred on the last Io to the file then
        //  this log file is useful.  Otherwise the log file can't be used.
        //

        //
        //  If we have a tail copy page then update the values in the
        //  Lfcb and restart area.
        //

        if (TailPage != NULL) {

            //
            //  Since we have read this page we know the Lfcb sequence
            //  number is the same as our expected value.
            //

            Lfcb->SeqNumber = ExpectedSeqNumber;

            Lfcb->LastFlushedLsn = TailPage->Header.Packed.LastEndLsn;

            Lfcb->RestartArea->CurrentLsn = Lfcb->LastFlushedLsn;

            ClearFlag( Lfcb->Flags, LFCB_NO_LAST_LSN );

            //
            //  If there is room on this page for another header then
            //  remember we want to reuse the page.
            //

            if (((ULONG)Lfcb->LogPageSize - TailPage->Header.Packed.NextRecordOffset )
                >= Lfcb->RecordHeaderLength) {

                SetFlag( Lfcb->Flags, LFCB_REUSE_TAIL );
                Lfcb->NextLogPage = CurrentLogPageOffset;
                Lfcb->ReusePageOffset = TailPage->Header.Packed.NextRecordOffset;

            } else {

                ClearFlag( Lfcb->Flags, LFCB_REUSE_TAIL );
                Lfcb->NextLogPage = NextLogPageOffset;
            }

            //
            //  If we wrapped the log file, then we set the bit indicating so.
            //

            if (WrappedLogFile) {

                SetFlag( Lfcb->Flags, LFCB_LOG_WRAPPED );
            }
        }

        //
        //  Remember that the partial IO will start at the next page.
        //

        FirstPartialIo = NextLogPageOffset;

        //
        //  If the next page is the first page of the file then update
        //  the sequence number for log records which begin on the next
        //  page.
        //

        if (Wrapped) {

            ExpectedSeqNumber = ExpectedSeqNumber + 1;
        }

        //
        //  If we know the length of the transfer containing the page we stopped
        //  on we can just go to the page following the transfer and check
        //  the sequence number.  If we replaced the page then we have already
        //  modified the numbers.  If we know that only single pages were written
        //  to disk then we will munge the numbers now.  If we were in the
        //  middle of a multi-page I/O then the numbers are already set up.
        //

        //
        //  If we have a tail copy or are performing single page I/O
        //  we can immediately look at the next page.
        //

        if (ReplacePage ||
            FlagOn( Lfcb->RestartArea->Flags, RESTART_SINGLE_PAGE_IO )) {

            //
            //  Fudge the counts to show that we don't need swallow any pages.
            //

            PageCount = 2;
            PagePosition = 1;

        //
        //  If the counts match it means the current page should be the first
        //  page of a transfer.  We need to walk forward enough to guarantee
        //  that there was no subsequent transfer that made it out to disk.
        //

        } else if (PagePosition == PageCount) {

            USHORT CurrentPosition;

            //
            //  If the next page causes us to wrap to the beginning of the log
            //  file then we know which page to check next.
            //

            if (Wrapped) {

                //
                //  Fudge the counts to show that we don't need swallow any pages.
                //

                PageCount = 2;
                PagePosition = 1;

            //
            //  Walk forward looking for a page which is from a different IO transfer
            //  from the page we failed on.
            //

            } else {

                //
                //  We need to find a log page we know is not part of the log
                //  page which caused the original error.
                //
                //  Maintain the count within the current transfer.
                //

                CurrentPosition = 2;

                do {

                    //
                    //  We walk through the file, reading log pages.  If we find
                    //  a readable log page that must lie in a subsequent Io block,
                    //  we exit.
                    //

                    if (TestPageHeaderBcb != NULL) {

                        CcUnpinData( TestPageHeaderBcb );
                        TestPageHeaderBcb = NULL;
                    }

                    Status = LfsPinOrMapData( Lfcb,
                                              NextLogPageOffset,
                                              (ULONG)Lfcb->LogPageSize,
                                              TRUE,
                                              TRUE,
                                              TRUE,
                                              &UsaError,
                                              (PVOID *) &TestPageHeader,
                                              &TestPageHeaderBcb );

                    //
                    //  If we get a USA error then assume that we correctly
                    //  found the end of the original transfer.
                    //

                    if (UsaError) {

                        ValidFile = TRUE;
                        break;

                    //
                    //  If we were able to read the page, we examine it to see
                    //  if it is in the same or different Io block.
                    //

                    } else if (NT_SUCCESS( Status )) {

                        //
                        //  If this page is part of the error causing I/O, we will
                        //  use the transfer length to determine the page to
                        //  read for a subsequent error.
                        //

                        if (TestPageHeader->PagePosition == CurrentPosition
                            && LfsCheckSubsequentLogPage( Lfcb,
                                                          TestPageHeader,
                                                          NextLogPageOffset,
                                                          ExpectedSeqNumber )) {

                            PageCount = TestPageHeader->PageCount + 1;
                            PagePosition = TestPageHeader->PagePosition;

                            break;

                        //
                        //  We found know the Io causing the error didn't
                        //  complete.  So we have no more checks to do.
                        //

                        } else {

                            ValidFile = TRUE;
                            break;
                        }

                    //
                    //  Try the next page.
                    //

                    } else {

                        //
                        //  Move to the next log page.
                        //

                        LfsNextLogPageOffset( Lfcb,
                                              NextLogPageOffset,
                                              &NextLogPageOffset,
                                              &Wrapped );

                        //
                        //  If the file wrapped then initialize the page count
                        //  and position so that we will not skip over any
                        //  pages in the final verification below.
                        //

                        if (Wrapped) {

                            ExpectedSeqNumber = ExpectedSeqNumber + 1;

                            PageCount = 2;
                            PagePosition = 1;
                        }

                        CurrentPosition += 1;
                    }

                    //
                    //  This is one more page we will want to uninitialize.
                    //

                    PartialIoCount += 1;

                } while( !Wrapped );
            }
        }

        //
        //  If we are unsure whether the file is valid then we will have
        //  the count and position in the current transfer.  We will walk through
        //  this transfer and read the subsequent page.
        //

        if (!ValidFile) {

            ULONG RemainingPages;

            //
            //  Skip over the remaining pages in this transfer.
            //

            RemainingPages = (PageCount - PagePosition) - 1;

            PartialIoCount += RemainingPages;

            while (RemainingPages--) {

                LfsNextLogPageOffset( Lfcb,
                                      NextLogPageOffset,
                                      &NextLogPageOffset,
                                      &Wrapped );

                if (Wrapped) {

                    ExpectedSeqNumber = ExpectedSeqNumber + 1;
                }
            }

            //
            //  Call our routine to check this log page.
            //

            if (TestPageHeaderBcb != NULL) {

                CcUnpinData( TestPageHeaderBcb );
                TestPageHeaderBcb = NULL;
            }

            Status = LfsPinOrMapData( Lfcb,
                                      NextLogPageOffset,
                                      (ULONG)Lfcb->LogPageSize,
                                      TRUE,
                                      TRUE,
                                      TRUE,
                                      &UsaError,
                                      (PVOID *) &TestPageHeader,
                                      &TestPageHeaderBcb );

            if (NT_SUCCESS( Status )
                && !UsaError) {

                if (LfsCheckSubsequentLogPage( Lfcb,
                                               TestPageHeader,
                                               NextLogPageOffset,
                                               ExpectedSeqNumber )) {

                    DebugTrace( 0, Dbg, "Log file is fatally flawed\n", 0 );
                    ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
                }
            }

            ValidFile = TRUE;
        }

        //
        //  Make sure the current page is unpinned.
        //

        if (LogPageHeaderBcb != NULL) {

            CcUnpinData( LogPageHeaderBcb );
            LogPageHeaderBcb = NULL;
        }

#ifdef SUPW_DBG
        if ((TailPage != NULL) && FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) {
            DbgPrint("INFO: TailPage isn't getting written because of READ-ONLY (ok)\n");
        }

        if (PartialIoCount && FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) {
            DbgPrint("INFO: PartialIoCount = 0x%x, not writing because of READ-ONLY (ok)\n");
        }
#endif

        //
        //  We have a valid file.  The Lfcb is initialized to the point where
        //  the last log record was found.  We possibly have a copy of the
        //  last page in the log file stored as a copy.  Or we could just have
        //  a page that we would like to reuse the end of.
        //

        if (!FlagOn( Lfcb->Flags, LFCB_READ_ONLY )) {

            if (TailPage != NULL) {

                //
                //  We will pin the correct page and copy the data from this
                //  page into it.  We will then flush it out to disk.
                //

                LfsPinOrMapData( Lfcb,
                                 TailPage->Copy.FileOffset,
                                 (ULONG)Lfcb->LogPageSize,
                                 TRUE,
                                 FALSE,
                                 TRUE,
                                 &UsaError,
                                 (PVOID *) &LogPageHeader,
                                 &LogPageHeaderBcb );

                RtlCopyMemory( LogPageHeader,
                               TailPage,
                               (ULONG)Lfcb->LogPageSize );

                //
                //  Fill in last flushed lsn value flush the page.
                //

                LogPageHeader->Copy.LastLsn = TailPage->Header.Packed.LastEndLsn;

                LfsFlushLogPage( Lfcb,
                                 LogPageHeader,
                                 TailPage->Copy.FileOffset,
                                 &LogPageHeaderBcb );
            }

            //
            //  We also want to write over any partial I/O so it doesn't cause
            //  us problems on a subsequent restart.  We have the starting offset
            //  and the number of blocks.  We will simply write a Baad signature into
            //  each of these pages.  Any subsequent reads will have a Usa error.
            //

            while (PartialIoCount--) {

                //
                //  Make sure the current page is unpinned.
                //

                if (LogPageHeaderBcb != NULL) {

                    CcUnpinData( LogPageHeaderBcb );
                    LogPageHeaderBcb = NULL;
                }

                if (NT_SUCCESS( LfsPinOrMapData( Lfcb,
                                                 FirstPartialIo,
                                                 (ULONG)Lfcb->LogPageSize,
                                                 TRUE,
                                                 TRUE,
                                                 TRUE,
                                                 &UsaError,
                                                 (PVOID *) &LogPageHeader,
                                                 &LogPageHeaderBcb ))) {

                    //
                    //  Just store a the usa array header in the multi-section
                    //  header.
                    //

                    *((PULONG) &LogPageHeader->MultiSectorHeader.Signature) = LFS_SIGNATURE_BAD_USA_ULONG;

                    LfsFlushLogPage( Lfcb,
                                     LogPageHeader,
                                     FirstPartialIo,
                                     &LogPageHeaderBcb );
                }

                LfsNextLogPageOffset( Lfcb,
                                      FirstPartialIo,
                                      &FirstPartialIo,
                                      &Wrapped );
            }
        }

        //
        //  We used to invalidate any tail pages we reused, now we let them
        //  be recopied every restart even if we fail a little later
        //

    } finally {

        DebugUnwind( LfsFindLastLsn );

        //
        //  Unpin the tail pages is pinned.
        //

        if (SecondTailPageBcb != NULL) {

            CcUnpinData( SecondTailPageBcb );
        }

        if (FirstTailPageBcb != NULL) {

            CcUnpinData( FirstTailPageBcb );
        }

        //
        //  Unpin the log page header if neccessary.
        //

        if (LogPageHeaderBcb != NULL) {

            CcUnpinData( LogPageHeaderBcb );
        }

        if (TestPageHeaderBcb != NULL) {

            CcUnpinData( TestPageHeaderBcb );
        }

        DebugTrace( -1, Dbg, "LfsFindLastLsn:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine.
//

BOOLEAN
LfsCheckSubsequentLogPage (
    IN PLFCB Lfcb,
    IN PLFS_RECORD_PAGE_HEADER RecordPageHeader,
    IN LONGLONG LogFileOffset,
    IN LONGLONG SequenceNumber
    )

/*++

Routine Description:

    This routine is called to check that a particular log page could not
    have been written after a prior Io transfer.  What we are looking for
    is the start of a transfer which was written after an Io which we
    we cannot read from during restart.  The presence of an additional
    Io means that we cannot guarantee that we can recover all of the
    restart data for the disk.  This makes the disk unrecoverable.

    We are given the sequence number of the Lsn that would occur on this page
    (if it is not part of an Log record which spans the end of a file).
    If we haven't wrapped the file and find an Lsn whose
    sequence number matches this, then we have an error.  If we have
    wrapped the file, and the sequence number in the Lsn in the
    first log page is
    written subsequent to a previous failing Io.

Arguments:

    Lfcb - Log file control block for this log file.

    RecordPageHeader - This is the header of a log page to check.

    LogFileOffset - This is the offset in the log file of this page.

    SequenceNumber - This is the sequence number that this log page should
                     not have.  This will be the sequence number for
                     any log records which begin on this page if written
                     after the page that failed.

Return Value:

    BOOLEAN - TRUE if this log page was written after some previous page,
              FALSE otherwise.

--*/

{
    BOOLEAN IsSubsequent;

    LSN Lsn;
    LONGLONG LsnSeqNumber;
    LONGLONG SeqNumberMinus1;
    LONGLONG LogPageFileOffset;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsCheckSubsequentLogPage:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb                  -> %08lx\n", Lfcb );
    DebugTrace(  0, Dbg, "RecordPageHeader      -> %08lx\n", RecordPageHeader );
    DebugTrace(  0, Dbg, "LogFileOffset (Low)   -> %08lx\n", LogFileOffset.LowPart );
    DebugTrace(  0, Dbg, "LogFileOffset (High)  -> %08lx\n", LogFileOffset.HighPart );
    DebugTrace(  0, Dbg, "SequenceNumber (Low)  -> %08lx\n", SequenceNumber.LowPart );
    DebugTrace(  0, Dbg, "SequenceNumber (High) -> %08lx\n", SequenceNumber.HighPart );

    //
    //  If the page header is either 0 or -1 then we say this page was not written
    //  after some previous page.
    //

    if (*((PULONG) RecordPageHeader->MultiSectorHeader.Signature) == LFS_SIGNATURE_UNINITIALIZED_ULONG
        || *((PULONG) RecordPageHeader->MultiSectorHeader.Signature) == 0) {

        DebugTrace( -1, Dbg, "LfsCheckSubsequentLogPage:  Exit -> %08x\n", FALSE );
        return FALSE;
    }

    //
    //  If the last Lsn on the page occurs was
    //  written after the page that caused the original error.  Then we
    //  have a fatal error.
    //

    Lsn = RecordPageHeader->Copy.LastLsn;

    LfsTruncateLsnToLogPage( Lfcb, Lsn, &LogPageFileOffset );
    LsnSeqNumber = LfsLsnToSeqNumber( Lfcb, Lsn );

    SeqNumberMinus1 = SequenceNumber - 1;

    //
    //  If the sequence number for the Lsn in the page is equal or greater than
    //  Lsn we expect, then this is a subsequent write.
    //

    if ( LsnSeqNumber >= SequenceNumber ) {

        IsSubsequent = TRUE;

    //
    //  If this page is the start of the file and the sequence number is 1 less
    //  than we expect and the Lsn indicates that we wrapped the file, then it
    //  is also part of a subsequent io.
    //
    //  The following test checks
    //
    //      1 - The sequence number for the Lsn is from the previous pass
    //          through the file.
    //      2 - We are at the first page in the file.
    //      3 - The log record didn't begin on the current page.
    //

    } else if (( LsnSeqNumber == SeqNumberMinus1 )
               && ( Lfcb->FirstLogPage == LogFileOffset )
               && ( LogFileOffset != LogPageFileOffset )) {

        IsSubsequent = TRUE;

    } else {

        IsSubsequent = FALSE;
    }

    DebugTrace( -1, Dbg, "LfsCheckSubsequentLogPage:  Exit -> %08x\n", IsSubsequent );

    return IsSubsequent;
}


//
//  Local support routine
//

VOID
LfsFlushLogPage (
    IN PLFCB Lfcb,
    PVOID LogPage,
    IN LONGLONG FileOffset,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine is called to write a single log page to the log file.  We will
    mark it dirty in the cache, unpin it and call our flush routine.

Arguments:

    Lfcb - Log file control block for this log file.

    LogPage - Pointer to the log page in the cache.

    FileOffset - Offset of the page in the stream.

    Bcb - Address of the Bcb pointer for the cache.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We'd absolutely hate for this to happen on a read only volume.
    //

    ASSERT(!(FlagOn( Lfcb->Flags, LFCB_READ_ONLY )));

    //
    //  Set the page dirty and unpin it.
    //

    CcSetDirtyPinnedData( *Bcb, NULL );
    CcUnpinData( *Bcb );
    *Bcb = NULL;

    //
    //  Now flush the data.
    //

    Lfcb->UserWriteData->FileOffset = FileOffset;
    Lfcb->UserWriteData->Length = (ULONG) Lfcb->LogPageSize;

    CcFlushCache( Lfcb->FileObject->SectionObjectPointer,
                  (PLARGE_INTEGER) &FileOffset,
                  (ULONG) Lfcb->LogPageSize,
                  NULL );

    return;
}


//
//  Local support routine.
//

VOID
LfsRemoveClientFromList (
    PLFS_CLIENT_RECORD ClientArray,
    PLFS_CLIENT_RECORD ClientRecord,
    IN PUSHORT ListHead
    )

/*++

Routine Description:

    This routine is called to remove a client record from a client record
    list in an Lfs restart area.

Arguments:

    ClientArray - Base of client records in restart area.

    ClientRecord - A pointer to the record to add.

    ListHead - A pointer to the beginning of the list.  This points to a
               USHORT which is the value of the first element in the list.

Return Value:

    None.

--*/

{
    PLFS_CLIENT_RECORD TempClientRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsRemoveClientFromList:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Client Array  -> %08lx\n", ClientArray );
    DebugTrace(  0, Dbg, "Client Record -> %08lx\n", ClientRecord );
    DebugTrace(  0, Dbg, "List Head     -> %08lx\n", ListHead );

    //
    //  If this is the first element in the list, then the head of the list
    //  points to the element after this record.
    //

    if (ClientRecord->PrevClient == LFS_NO_CLIENT) {

        DebugTrace( 0, Dbg, "Element is first element in the list\n", 0 );
        *ListHead = ClientRecord->NextClient;

    //
    //  Otherwise the previous element points to the next element.
    //

    } else {

        TempClientRecord = ClientArray + ClientRecord->PrevClient;
        TempClientRecord->NextClient = ClientRecord->NextClient;
    }

    //
    //  If this is not the last element in the list, the previous element
    //  becomes the last element.
    //

    if (ClientRecord->NextClient != LFS_NO_CLIENT) {

        TempClientRecord = ClientArray + ClientRecord->NextClient;
        TempClientRecord->PrevClient = ClientRecord->PrevClient;
    }

    DebugTrace( -1, Dbg, "LfsRemoveClientFromList:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
LfsAddClientToList (
    IN PLFS_CLIENT_RECORD ClientArray,
    IN USHORT ClientIndex,
    IN PUSHORT ListHead
    )

/*++

Routine Description:

    This routine is called to add a client record to the start of a list.

Arguments:

    ClientArray - This is the base of the client record.

    ClientIndex - The index for the record to add.

    ListHead - A pointer to the beginning of the list.  This points to a
               USHORT which is the value of the first element in the list.

Return Value:

    None.

--*/

{
    PLFS_CLIENT_RECORD ClientRecord;
    PLFS_CLIENT_RECORD TempClientRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsAddClientToList:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Client Array  -> %08lx\n", ClientArray );
    DebugTrace(  0, Dbg, "Client Index  -> %04x\n", ClientIndex );
    DebugTrace(  0, Dbg, "List Head     -> %08lx\n", ListHead );

    ClientRecord = ClientArray + ClientIndex;

    //
    //  This element will become the first element on the list.
    //

    ClientRecord->PrevClient = LFS_NO_CLIENT;

    //
    //  The next element for this record is the previous head of the list.
    //

    ClientRecord->NextClient = *ListHead;

    //
    //  If there is at least one element currently on the list, we point
    //  the first element to this new record.
    //

    if (*ListHead != LFS_NO_CLIENT) {

        TempClientRecord = ClientArray + *ListHead;
        TempClientRecord->PrevClient = ClientIndex;
    }

    //
    //  This index is now the head of the list.
    //

    *ListHead = ClientIndex;

    DebugTrace( -1, Dbg, "LfsAddClientToList:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=lfs

TARGETNAME=lfs
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..;..\..\..\ntos\inc;$(IFSKIT_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_NTDRIVER_

!IFDEF BUILD_FOR_3_51
C_DEFINES= $(C_DEFINES) -D_NTIFS_
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX



SOURCES=..\CacheSup.c  \
        ..\LbcbSup.c   \
        ..\LfsData.c   \
        ..\LogPgSup.c  \
        ..\LogRcSup.c  \
        ..\LsnSup.c    \
        ..\QueryLog.c  \
        ..\Registry.c  \
        ..\Restart.c   \
        ..\RstrtSup.c  \
        ..\StrucSup.c  \
        ..\SysInit.c   \
        ..\VerfySup.c  \
        ..\Write.c

PRECOMPILED_INCLUDE=..\lfsprocs.h
PRECOMPILED_PCH=lfsprocs.pch
PRECOMPILED_OBJ=lfsprocs.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\verfysup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements consistency checking and structure comparisions
    on Lfs structures.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

#ifdef LFS_RAISE
BOOLEAN LfsRaiseFull = FALSE;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsCurrentAvailSpace)
#pragma alloc_text(PAGE, LfsFindCurrentAvail)
#pragma alloc_text(PAGE, LfsVerifyLogSpaceAvail)
#endif


VOID
LfsCurrentAvailSpace (
    IN PLFCB Lfcb,
    OUT PLONGLONG CurrentAvailSpace,
    OUT PULONG CurrentPageBytes
    )

/*++

Routine Description:

    This routine is called to determine the available log space in the log file.
    It returns the total number of free bytes and the number available on the
    active page if present.  The total free bytes will reflect all of the empty
    pages as well as the number in the active page.

Arguments:

    Lfcb - Lfcb for this log file.

    CurrentAvailSpace - This is the number of bytes available for log
                        records.

    CurrentPageBytes - This is the number of bytes remaining on the
                       current log page.

Return Value:

    None.

--*/

{
    *CurrentPageBytes = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsCurrentAvailSpace:  Entered\n", 0 );

    //
    //  Get the total number from the Lfcb.
    //

    *CurrentAvailSpace = Lfcb->CurrentAvailable;

    //
    //  We now look to see if there are any bytes available on the Lbcb in
    //  the active queue.  We can add this to the bytes available in the
    //  log pages and also give this back to the caller.
    //

    if (!IsListEmpty( &Lfcb->LbcbActive )) {

        PLBCB ThisLbcb;

        ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                      LBCB,
                                      ActiveLinks );

        //
        //  If the page is not empty or the page is empty but this is a
        //  restart page then add the remaining bytes on this page.
        //

        if (FlagOn( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY | LBCB_FLUSH_COPY )) {

            *CurrentPageBytes = (ULONG)Lfcb->LogPageSize - (ULONG)ThisLbcb->BufferOffset;

            *CurrentAvailSpace = *CurrentAvailSpace + *CurrentPageBytes;                                               //**** xxAdd( *CurrentAvailSpace, xxFromUlong( *CurrentPageBytes ));
        }
    }

    DebugTrace( +1, Dbg, "LfsCurrentAvailSpace:  Exit\n", 0 );

    return;
}


BOOLEAN
LfsVerifyLogSpaceAvail (
    IN PLFCB Lfcb,
    IN PLCH Lch,
    IN ULONG RemainingLogBytes,
    IN LONG UndoRequirement,
    IN BOOLEAN ForceToDisk
    )

/*++

Routine Description:

    This routine is called to verify that we may write this log record into the
    log file.  We want to always leave room for each transaction to abort.

    We determine how much space the current log record will take and the
    worst case for its undo operation.  If this space is available we
    update the corresponding values in the Lfcb and Lch for bookkeeping.
    Otherwise we raise a status indicating that the log file is full.

    The disk usage is different for the packed and unpacked cases.  Make the
    following adjustments after finding the total available and amount still
    remaining on the last active page,

    Packed Case:

        Size needed for log record is data size plus header size.

        Undo requirement is the undo data size plus the header size.
            We have already taken into account the end of the pages
            except for the current page.

        Add the log record size to the undo requirement to get the
            log file usage.  Compare this number with the actual available
            space (Available - CommittedUndo).  If the space is not
            available, then raise LOG_FILE_FULL.  Must take into account
            any unused bytes at the end of the current page.

    Unpacked Case:

        Size needed is initially header size plus data size.

        If the log record can't begin on the current page then
            add the bytes being thrown away to the log record size.

        If the page is being forced to disk then add any remaining
            bytes on the last page.  To the bytes being used.

        Undo requirement is twice the sum of the header size and
            undo size.  We double the requested size since the log
            record will always fit on a page.  This can be a
            positive or negative number.

        Add the log record usage to the undo usage to get the log file
            usage.  Compare this number with the actual available
            space (Available - CommittedUndo).  If the space is not
            available, then raise LOG_FILE_FULL.

Arguments:

    Lfcb - Lfcb for this log file.

    Lch - Client handle

    RemainingLogBytes - Number of bytes for the current log record

    UndoRequirement - User's requirement for the undo record.

    ForceToDisk - Indicates if this log record will be flushed to disk.

Return Value:

    BOOLEAN - Advisory, indicates that there is less than 1/4 of the log file available.

--*/

{
    ULONG CurrentLogRecordSize;
    ULONG LogRecordStart;
    ULONG TailBytes;

    LONGLONG CurrentAvailSpace;
    ULONG CurrentPageBytes;

    LONGLONG LogFileUsage;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsVerifyLogSpaceAvail:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08x\n", Lfcb );
    DebugTrace(  0, Dbg, "Lch               -> %08lx\n", Lch );
    DebugTrace(  0, Dbg, "RemainingLogBytes -> %08lx\n", RemainingLogBytes );
    DebugTrace(  0, Dbg, "UndoRequirement   -> %08lx\n", UndoRequirement );
    DebugTrace(  0, Dbg, "ForceToDisk       -> %04x\n", ForceToDisk );

    //
    //  Start by collecting the current data on the file.
    //

    LfsCurrentAvailSpace( Lfcb,
                          &CurrentAvailSpace,
                          &CurrentPageBytes );

    //
    //  We compute the amount of space needed for the current log record by
    //  adding up the following:
    //
    //      Space at end of current log page which won't be used.
    //      Size of header for log record.
    //      Size of client data in log record.
    //      Size of wasted portion of log page if this is forced to disk.
    //

    //
    //  Start with the size of the header and the client data.
    //

    CurrentLogRecordSize = RemainingLogBytes + Lfcb->RecordHeaderLength;

    //
    //  If the log is packed and there are bytes on the current page we need
    //  to take into account any bytes at the end of the page which won't
    //  be used.  This will happen if the log record spills into the end of
    //  the log page but doesn't use up the page.  If the remaining bytes are
    //  less than a record header size we must throw them away.
    //

    if (FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

        if (CurrentPageBytes != 0
            && CurrentLogRecordSize < CurrentPageBytes
            && (CurrentPageBytes - CurrentLogRecordSize) < Lfcb->RecordHeaderLength) {

            CurrentLogRecordSize += (CurrentPageBytes - CurrentLogRecordSize);
        }

    //
    //  If this is the unpacked case we need to check for bytes being thrown away
    //  on the current page or the last page.
    //

    } else {

        //
        //  If there is an active Lbcb, we need to add any bytes that
        //  would be thrown away at the end.
        //

        if (CurrentPageBytes != 0) {

            //
            //  We won't use this log page unless the new log record will fit or
            //  unless this is the first log record in the page.
            //

            if ((CurrentPageBytes != (ULONG)Lfcb->LogPageDataSize)
                && (CurrentLogRecordSize > CurrentPageBytes)) {

                CurrentLogRecordSize += CurrentPageBytes;

                //
                //  Remember that we will start this log record at the first
                //  byte in the data portion of a page.
                //

                LogRecordStart = 0;

            //
            //  Otherwise this will start at the current offset into the
            //  data portion of the log page.
            //

            } else {

                LogRecordStart = (ULONG)Lfcb->LogPageDataSize - CurrentPageBytes;
            }

        //
        //  If there was no Lbcb, then we know that we will start at the first
        //  byte of the data portion.
        //

        } else {

            LogRecordStart = 0;
        }

        //
        //  We always assume that we will use up the rest of the bytes on the last page
        //  in computing whether the log record will fit in the available space.  We
        //  only subtract that space from the available space if this is a force write.
        //

        if (ForceToDisk) {

            //
            //  We take into account where we start on a log page and continue
            //  to subtract log pages until we know the amount on the last
            //  page.
            //

            TailBytes = RemainingLogBytes + Lfcb->RecordHeaderLength + LogRecordStart;

            while (TailBytes > (ULONG)Lfcb->LogPageDataSize) {

                TailBytes -= (ULONG)Lfcb->LogPageDataSize;
            }

            TailBytes = (ULONG)Lfcb->LogPageDataSize - TailBytes;

            CurrentLogRecordSize += TailBytes;
        }
    }

    //
    //  We now know the number of bytes needed for the current log page.
    //  Next we compute the number of bytes being reserved by UndoRequirement.
    //  If the UndoRequirement is positive, we will add to the amount reserved
    //  in the log file.  If it is negative, we will subtract from the amount
    //  reserved in the log file.
    //

    //
    //  When we have an actual reserve amount, we convert it to positive
    //  and then reserve twice the space required to hold the data and
    //  its header (up to the maximum of a single page.
    //

    if (UndoRequirement != 0) {

        if (!FlagOn( Lfcb->Flags, LFCB_PACK_LOG )) {

            UndoRequirement *= 2;
        }

        if (UndoRequirement < 0) {

            UndoRequirement -= (2 * Lfcb->RecordHeaderLength);
        } else {

            UndoRequirement += (2 * Lfcb->RecordHeaderLength);
        }
    }

    //
    //  Now compute the net log file usage.  The result may be positive or
    //  negative.
    //

    LogFileUsage = ((LONG) CurrentLogRecordSize)  + UndoRequirement;                                                   //**** xxFromLong( ((LONG) CurrentLogRecordSize)  + UndoRequirement );

    //
    //  The actual available space is the CurrentAvail minus the reserved
    //  undo value in the Lfcb.
    //

    CurrentAvailSpace = CurrentAvailSpace - Lfcb->TotalUndoCommitment;                                                 //**** xxSub( CurrentAvailSpace, Lfcb->TotalUndoCommitment );

    //
    //  If this log file usage is greater than the available log file space
    //  then we raise a status code.
    //

#ifdef LFS_RAISE
    if (LfsRaiseFull) {

        LfsRaiseFull = FALSE;
        DebugTrace( -1, Dbg, "LfsVerifyLogSpaceAvail:  About to raise\n", 0 );
        ExRaiseStatus( STATUS_LOG_FILE_FULL );
    }
#endif

    if (LogFileUsage > CurrentAvailSpace) {

        DebugTrace( -1, Dbg, "LfsVerifyLogSpaceAvail:  About to raise\n", 0 );
        ExRaiseStatus( STATUS_LOG_FILE_FULL );
    }

    Lfcb->TotalUndoCommitment = Lfcb->TotalUndoCommitment + UndoRequirement;                                           //**** xxAdd( Lfcb->TotalUndoCommitment, xxFromLong( UndoRequirement ));

    Lch->ClientUndoCommitment = Lch->ClientUndoCommitment + UndoRequirement;                                           //**** xxAdd( Lch->ClientUndoCommitment, xxFromLong( UndoRequirement ));

    DebugTrace( -1, Dbg, "LfsVerifyLogSpaceAvail:  Exit\n", 0 );

    //
    //  Now check if the log file is almost used up.
    //

    if ((CurrentAvailSpace - LogFileUsage) < (Lfcb->TotalAvailable >> 2)) {

        return TRUE;
    }

    return FALSE;
}


VOID
LfsFindCurrentAvail (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This routine is called to calculate the number of bytes available for log
    records which are in completely empty log record pages.  It ignores any
    partial pages in the active work queue and ignores any page which is
    going to be reused.

Arguments:

    Lfcb - Lfcb for this log file.

Return Value:

    None.

--*/

{
    LONGLONG OldestPageOffset;
    LONGLONG NextFreePageOffset;
    LONGLONG FreeBytes;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFindCurrentAvail:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Lfcb              -> %08x\n", Lfcb );

    //
    //  If there is a last lsn in the restart area then we know
    //  that we will have to compute the free range.
    //

    if (!FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN )) {

        //
        //  If there is no oldest Lsn then start at the
        //  first page of the file.
        //

        if (FlagOn( Lfcb->Flags, LFCB_NO_OLDEST_LSN )) {

            OldestPageOffset = Lfcb->FirstLogPage;

        } else {

            LfsTruncateOffsetToLogPage( Lfcb,
                                        Lfcb->OldestLsnOffset,
                                        &OldestPageOffset );
        }

        //
        //  We will use the next log page offset to compute the
        //  next free page.  If we are going to reuse this page
        //  go to the next page,  if we are at the first page then
        //  use the end of the file.
        //

        if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL )) {

            NextFreePageOffset = Lfcb->NextLogPage + Lfcb->LogPageSize;                                                //**** xxAdd( Lfcb->NextLogPage, Lfcb->LogPageSize );

        } else if ( Lfcb->NextLogPage == Lfcb->FirstLogPage ) {                                                        //**** xxEql( Lfcb->NextLogPage, Lfcb->FirstLogPage )

            NextFreePageOffset = Lfcb->FileSize;

        } else {

            NextFreePageOffset = Lfcb->NextLogPage;
        }

        //
        //  If the two offsets are the same then there is no available space.
        //

        if ( OldestPageOffset == NextFreePageOffset ) {                                                                //**** xxEql( OldestPageOffset, NextFreePageOffset )

            Lfcb->CurrentAvailable = 0;

        } else {

            //
            //  If the free offset follows the oldest offset then subtract
            //  this range from the total available pages.
            //

            if ( OldestPageOffset < NextFreePageOffset ) {                                                             //**** xxLtr( OldestPageOffset, NextFreePageOffset )

                FreeBytes = Lfcb->TotalAvailInPages - ( NextFreePageOffset - OldestPageOffset );                       //**** xxSub( Lfcb->TotalAvailInPages, xxSub( NextFreePageOffset, OldestPageOffset ));

            } else {

                FreeBytes = OldestPageOffset - NextFreePageOffset;                                                     //**** xxSub( OldestPageOffset, NextFreePageOffset );
            }

            //
            //  We now have the total bytes in the pages available.  We
            //  now have to subtract the size of the page header to get
            //  the total available bytes.
            //
            //  We will convert the bytes to pages and then multiple
            //  by the data size of each page.
            //

            FreeBytes = Int64ShrlMod32(((ULONGLONG)(FreeBytes)), Lfcb->LogPageShift);

            Lfcb->CurrentAvailable = FreeBytes * (ULONG)Lfcb->ReservedLogPageSize;                                     //**** xxXMul( FreeBytes, Lfcb->ReservedLogPageSize.LowPart );
        }

    //
    //  Otherwise the entire file is available.
    //

    } else {

        Lfcb->CurrentAvailable = Lfcb->MaxCurrentAvail;
    }

    DebugTrace( -1, Dbg, "LfsFindCurrentAvail:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\lfs\write.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the user routines which write log records into
    or flush portions of the log file.

Author:

    Brian Andrew    [BrianAn]   20-June-1991

Revision History:

--*/

#include "lfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#define LFS_PAGES_TO_VERIFY 10

VOID
LfsGetActiveLsnRangeInternal (
    IN PLFCB Lfcb,
    OUT PLSN OldestLsn,
    OUT PLSN NextLsn
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LfsCheckWriteRange)
#pragma alloc_text(PAGE, LfsFlushToLsn)
#pragma alloc_text(PAGE, LfsForceWrite)
#pragma alloc_text(PAGE, LfsGetActiveLsnRange)
#pragma alloc_text(PAGE, LfsGetActiveLsnRangeInternal)
#pragma alloc_text(PAGE, LfsWrite)
#endif


VOID
LfsGetActiveLsnRangeInternal (
    IN PLFCB Lfcb,
    OUT PLSN OldestLsn,
    OUT PLSN NextLsn
    )
/*++

Routine Description:

    Returns back the range that is active in the logfile from the oldest valid LSN to
    where the next active LSN will be.

Arguments:

    Lfcb - the logfile lfcb

    OldestLsn - returns the oldest active lsn

    NextLsn - returns the projected next lsn to be used

Return Value:

    None

--*/
{
    PLBCB ActiveLbcb;

    PAGED_CODE();

    //
    //  Calculate what the next LSN will be using the regular logic
    //  1) if there is no active lbcb then it will be the first offset on the next
    //     page (the seq. number will increment if it wraps)
    //  2) Otherwise its the Lsn contained in the top of the active lbcb list
    //

    if (!IsListEmpty( &Lfcb->LbcbActive )) {
        ActiveLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                        LBCB,
                                        ActiveLinks );
        NextLsn->QuadPart = LfsComputeLsnFromLbcb( Lfcb, ActiveLbcb );
    } else {

        if (FlagOn( Lfcb->Flags, LFCB_REUSE_TAIL)) {
            NextLsn->QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->NextLogPage + Lfcb->ReusePageOffset, Lfcb->SeqNumber );
        } else if (Lfcb->NextLogPage != Lfcb->FirstLogPage) {
            NextLsn->QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->NextLogPage + Lfcb->LogPageDataOffset, Lfcb->SeqNumber );
        } else {
            NextLsn->QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->NextLogPage + Lfcb->LogPageDataOffset, Lfcb->SeqNumber + 1 );
        }
    }

    OldestLsn->QuadPart = Lfcb->OldestLsn.QuadPart;
}


VOID
LfsGetActiveLsnRange (
    IN LFS_LOG_HANDLE LogHandle,
    OUT PLSN OldestLsn,
    OUT PLSN NextLsn
    )

/*++

Routine Description:

    Returns back the range that is active in the logfile from the oldest valid LSN to
    where the next active LSN will be. For external clients since it acquires the leb sync resource

Arguments:

    Lfcb - the logfile handle

    OldestLsn - returns the oldest active lsn

    NextLsn - returns the projected next lsn to be used

Return Value:

    None

--*/
{
    PLCH Lch;
    PLFCB Lfcb;

    PAGED_CODE();

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        LfsGetActiveLsnRangeInternal( Lfcb, OldestLsn, NextLsn );


    } finally {
        LfsReleaseLch( Lch );
    }
}


BOOLEAN
LfsWrite (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId OPTIONAL,
    IN LSN UndoNextLsn,
    IN LSN PreviousLsn,
    IN LONG UndoRequirement,
    IN ULONG Flags,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called by a client to write a log record to the log file.
    The log record is lazy written and is not guaranteed to be on the disk
    until a subsequent LfsForceWrie or LfsWriteRestartArea or until
    an LfsFlushtoLsn is issued withan Lsn greater-than or equal to the Lsn
    returned from this service.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    NumberOfWriteEntries - Number of components of the log record.

    WriteEntries - Pointer to an array of write entries.

    RecordType - Lfs defined type for this log record.

    TransactionId - Id value used to group log records by complete transaction.

    UndoNextLsn - Lsn of a previous log record which needs to be undone in
                  the event of a client restart.

    PreviousLsn - Lsn of the immediately previous log record for this client.

    Lsn - Lsn to be associated with this log record.

    UndoRequirement -

    Flags - if LFS_WRITE_FLAG_WRITE_AT_FRONT put this record at the front of the log and all
            records will continue from then on after it.

Return Value:

    BOOLEAN - Advisory, TRUE indicates that less than 1/4 of the log file is
        available.

--*/

{
    NTSTATUS Status;
    BOOLEAN LogFileFull = FALSE;
    PLCH Lch;

    PLFCB Lfcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsWrite:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle                -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "NumberOfWriteEntries      -> %08lx\n", NumberOfWriteEntries );
    DebugTrace(  0, Dbg, "WriteEntries              -> %08lx\n", WriteEntries );
    DebugTrace(  0, Dbg, "Record Type               -> %08lx\n", RecordType );
    DebugTrace(  0, Dbg, "Transaction Id            -> %08lx\n", TransactionId );
    DebugTrace(  0, Dbg, "UndoNextLsn (Low)         -> %08lx\n", UndoNextLsn.LowPart );
    DebugTrace(  0, Dbg, "UndoNextLsn (High)        -> %08lx\n", UndoNextLsn.HighPart );
    DebugTrace(  0, Dbg, "PreviousLsn (Low)         -> %08lx\n", PreviousLsn.LowPart );
    DebugTrace(  0, Dbg, "PreviousLsn (High)        -> %08lx\n", PreviousLsn.HighPart );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  If the clean shutdown flag is currently set then clear it
        //  before allowing more log records out.
        //

        if (FlagOn( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN )) {

            ClearFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
        }

        //
        //  Check for write at front flag - we can't write at front if we're about to
        //  reuse the last page or there is no last lsn - these conditions only occur
        //  right at mount (and only if the mount fails)
        //

        if (FlagOn( Flags, LFS_WRITE_FLAG_WRITE_AT_FRONT ) &&
            !FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL )) {

            LSN NextLsn;
            LSN NextBeyondLsn;
            LSN NextActiveLsn;
            LSN OldestLsn;
            ULONG Index;
            PVOID TestPageHeader = NULL;
            PMDL TestPageMdl = NULL;

            //
            //  Calculate the projected LSN for a write at the front and the page after it
            //

            NextLsn.QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->FirstLogPage + Lfcb->LogPageDataOffset, Lfcb->SeqNumber );
            NextBeyondLsn.QuadPart = LfsFileOffsetToLsn( Lfcb, Lfcb->FirstLogPage + Lfcb->LogPageDataOffset + Lfcb->LogPageSize, Lfcb->SeqNumber );

            LfsGetActiveLsnRangeInternal( Lfcb, &OldestLsn, &NextActiveLsn );

            //
            //  Test if calculated front LSN falls in active range
            //

#ifdef BENL_DBG
            KdPrint(( "LFS: NextLsn: 0x%I64x Oldest: 0x%I64x Current: 0x%I64x Computed: 0x%I64x\n", NextLsn,  Lfcb->OldestLsn, Lfcb->RestartArea->CurrentLsn, NextActiveLsn ));
#endif

            if ((NextBeyondLsn.QuadPart < OldestLsn.QuadPart) ||
                (NextLsn.QuadPart > NextActiveLsn.QuadPart)) {

                //
                //  Walk through the active queue and remove any Lbcb's with
                //  data from that queue.  This will lets us create new active lbcbs
                //

                while (!IsListEmpty( &Lfcb->LbcbActive )) {

                    PLBCB ThisLbcb;

                    ThisLbcb = CONTAINING_RECORD( Lfcb->LbcbActive.Flink,
                                                  LBCB,
                                                  ActiveLinks );

                    RemoveEntryList( &ThisLbcb->ActiveLinks );
                    ClearFlag( ThisLbcb->LbcbFlags, LBCB_ON_ACTIVE_QUEUE );

                    //
                    //  If this page has some new entries, allow it to
                    //  be flushed to disk elsewhere.  Otherwise deallocate it
                    //  here. We set LBCB_NOT_EMPTY when we first put data into
                    //  the page and add it to  the workqueue.
                    //

                    if (!FlagOn( ThisLbcb->LbcbFlags, LBCB_NOT_EMPTY )) {

                        ASSERT( NULL == ThisLbcb->WorkqueLinks.Flink );

                        if (ThisLbcb->LogPageBcb != NULL) {

                            CcUnpinDataForThread( ThisLbcb->LogPageBcb,
                                                  ThisLbcb->ResourceThread );
                        }

                        LfsDeallocateLbcb( Lfcb, ThisLbcb );
                    }
                }

                ASSERT( !FlagOn( Lfcb->Flags, LFCB_NO_LAST_LSN | LFCB_REUSE_TAIL ) );
                Lfcb->NextLogPage = Lfcb->FirstLogPage;

                //
                //   Do an extra verification step - to check for simultaneous writers in the log
                //   read the next 10 pages and confirm they have expected sequence numbers
                //

                try {

                    for (Index=0; Index < LFS_PAGES_TO_VERIFY; Index++) {
                        ULONG Signature;
                        LARGE_INTEGER Offset;

                        Offset.QuadPart =  Lfcb->FirstLogPage + Index * Lfcb->LogPageSize;

                        LfsReadPage( Lfcb, &Offset, &TestPageMdl, &TestPageHeader );
                        Signature = *((PULONG)TestPageHeader);
                        if (Signature != LFS_SIGNATURE_BAD_USA_ULONG) {
                            if (LfsCheckSubsequentLogPage( Lfcb,
                                                           TestPageHeader,
                                                           Lfcb->FirstLogPage + Index * Lfcb->LogPageSize,
                                                           Lfcb->SeqNumber + 1 )) {

                                DebugTrace( 0, Dbg, "Log file is fatally flawed\n", 0 );
                                ExRaiseStatus( STATUS_DISK_CORRUPT_ERROR );
                            }
                        }

                        //
                        //  Make sure the current page is unpinned.
                        //

                        if (TestPageMdl) {
                            IoFreeMdl( TestPageMdl );
                            TestPageMdl = NULL;
                        }
                        if (TestPageHeader) {
                            LfsFreePool( TestPageHeader );
                            TestPageHeader = NULL ;
                        }
                    }

                } finally {

                    if (TestPageMdl) {
                        IoFreeMdl( TestPageMdl );
                        TestPageMdl = NULL;
                    }
                    if (TestPageHeader) {
                        LfsFreePool( TestPageHeader );
                        TestPageHeader = NULL ;
                    }
                }
            }
        }

#ifdef BENL_DBG
        {
            LSN OldestLsn;
            LSN NextActiveLsn;

            LfsGetActiveLsnRangeInternal( Lfcb, &OldestLsn, &NextActiveLsn );
#endif

        //
        //  Write the log record.
        //

        LogFileFull = LfsWriteLogRecordIntoLogPage( Lfcb,
                                                    Lch,
                                                    NumberOfWriteEntries,
                                                    WriteEntries,
                                                    RecordType,
                                                    TransactionId,
                                                    UndoNextLsn,
                                                    PreviousLsn,
                                                    UndoRequirement,
                                                    FALSE,
                                                    Lsn );

#ifdef BENL_DBG
            ASSERT( Lsn->QuadPart = NextActiveLsn.QuadPart );
        }
#endif

    } finally {

        DebugUnwind( LfsWrite );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Lsn (Low)   -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)  -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsWrite:  Exit\n", 0 );
    }

    return LogFileFull;
}


BOOLEAN
LfsForceWrite (
    IN LFS_LOG_HANDLE LogHandle,
    IN ULONG NumberOfWriteEntries,
    IN PLFS_WRITE_ENTRY WriteEntries,
    IN LFS_RECORD_TYPE RecordType,
    IN TRANSACTION_ID *TransactionId,
    IN LSN UndoNextLsn,
    IN LSN PreviousLsn,
    IN LONG UndoRequirement,
    OUT PLSN Lsn
    )

/*++

Routine Description:

    This routine is called by a client to write a log record to the log file.
    This is idendical to LfsWrite except that on return the log record is
    guaranteed to be on disk.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    NumberOfWriteEntries - Number of components of the log record.

    WriteEntries - Pointer to an array of write entries.

    RecordType - Lfs defined type for this log record.

    TransactionId - Id value used to group log records by complete transaction.

    UndoNextLsn - Lsn of a previous log record which needs to be undone in
                  the event of a client restart.

    PreviousLsn - Lsn of the immediately previous log record for this client.

    Lsn - Lsn to be associated with this log record.

Return Value:

    BOOLEAN - Advisory, TRUE indicates that less than 1/4 of the log file is
        available.

--*/

{
    PLCH Lch;

    PLFCB Lfcb;
    BOOLEAN LogFileFull = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsForceWrite:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle                -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "NumberOfWriteEntries      -> %08lx\n", NumberOfWriteEntries );
    DebugTrace(  0, Dbg, "WriteEntries              -> %08lx\n", WriteEntries );
    DebugTrace(  0, Dbg, "Record Type               -> %08lx\n", RecordType );
    DebugTrace(  0, Dbg, "Transaction Id            -> %08lx\n", TransactionId );
    DebugTrace(  0, Dbg, "UndoNextLsn (Low)         -> %08lx\n", UndoNextLsn.LowPart );
    DebugTrace(  0, Dbg, "UndoNextLsn (High)        -> %08lx\n", UndoNextLsn.HighPart );
    DebugTrace(  0, Dbg, "PreviousLsn (Low)         -> %08lx\n", PreviousLsn.LowPart );
    DebugTrace(  0, Dbg, "PreviousLsn (High)        -> %08lx\n", PreviousLsn.HighPart );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the Log file has been closed then refuse access.
        //

        if (Lfcb == NULL) {

            ExRaiseStatus( STATUS_ACCESS_DENIED );
        }

        //
        //  Check that the client Id is valid.
        //

        LfsValidateClientId( Lfcb, Lch );

        //
        //  If the clean shutdown flag is currently set then clear it
        //  before allowing more log records out.
        //

        if (FlagOn( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN )) {

            ClearFlag( Lfcb->RestartArea->Flags, LFS_CLEAN_SHUTDOWN );

            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, FALSE );
            LfsWriteLfsRestart( Lfcb, Lfcb->RestartAreaSize, TRUE );
        }

        //
        //  Write the log record.
        //

        LogFileFull = LfsWriteLogRecordIntoLogPage( Lfcb,
                                                    Lch,
                                                    NumberOfWriteEntries,
                                                    WriteEntries,
                                                    RecordType,
                                                    TransactionId,
                                                    UndoNextLsn,
                                                    PreviousLsn,
                                                    UndoRequirement,
                                                    TRUE,
                                                    Lsn );

        //
        //  The call to add this lbcb to the workque is guaranteed to release
        //  the Lfcb if this thread may do the Io.
        //

        LfsFlushToLsnPriv( Lfcb, *Lsn );

    } finally {

        DebugUnwind( LfsForceWrite );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace(  0, Dbg, "Lsn (Low)   -> %08lx\n", Lsn->LowPart );
        DebugTrace(  0, Dbg, "Lsn (High)  -> %08lx\n", Lsn->HighPart );
        DebugTrace( -1, Dbg, "LfsForceWrite:  Exit\n", 0 );
    }
    return LogFileFull;
}


VOID
LfsFlushToLsn (
    IN LFS_LOG_HANDLE LogHandle,
    IN LSN Lsn
    )

/*++

Routine Description:

    This routine is called by a client to insure that all log records
    to a certain point have been flushed to the file.  This is done by
    checking if the desired Lsn has even been written at all.  If so we
    check if it has been flushed to the file.  If not, we simply write
    the current restart area to the disk.

Arguments:

    LogHandle - Pointer to private Lfs structure used to identify this
                client.

    Lsn - This is the Lsn that must be on the disk on return from this
          routine.

Return Value:

    None

--*/

{
    PLCH Lch;

    PLFCB Lfcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "LfsFlushToLsn:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Log Handle        -> %08lx\n", LogHandle );
    DebugTrace(  0, Dbg, "Lsn (Low)         -> %08lx\n", Lsn.LowPart );
    DebugTrace(  0, Dbg, "Lsn (High)        -> %08lx\n", Lsn.HighPart );

    Lch = (PLCH) LogHandle;

    //
    //  Check that the structure is a valid log handle structure.
    //

    LfsValidateLch( Lch );


    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the log file control block for this log file.
        //

        LfsAcquireLch( Lch );
        Lfcb = Lch->Lfcb;

        //
        //  If the log file has been closed we will assume the Lsn has been flushed.
        //

        if (Lfcb != NULL) {

            //
            //  Volumes mounted readonly ignore flush callbacks from lazy writer.
            //

            if (!FlagOn(Lfcb->Flags, LFCB_READ_ONLY)) {

                //
                //  Check that the client Id is valid.
                //

                LfsValidateClientId( Lfcb, Lch );

                //
                //  Call our common routine to perform the work.
                //

                LfsFlushToLsnPriv( Lfcb, Lsn );

            }
        }

    } finally {

        DebugUnwind( LfsFlushToLsn );

        //
        //  Release the log file control block if held.
        //

        LfsReleaseLch( Lch );

        DebugTrace( -1, Dbg, "LfsFlushToLsn:  Exit\n", 0 );
    }

    return;
}


VOID
LfsCheckWriteRange (
    IN PLFS_WRITE_DATA WriteData,
    IN OUT PLONGLONG FlushOffset,
    IN OUT PULONG FlushLength
    )

/*++

Routine Description:

    This routine is called Ntfs to Lfs when a flush occurs.  This will give Lfs a chance
    to trim the amount of the flush.  Lfs can then use a 4K log record page size
    for all systems (Intel and Alpha).

    This routine will trim the size of the IO request to the value stored in the
    Lfcb for this volume.  We will also redirty the second half of the page if
    we have begun writing log records into it.

Arguments:

    WriteData - This is the data in the user's data structure which is maintained
        by Lfs to describe the current writes.

    FlushOffset - On input this is the start of the flush passed to Ntfs from MM.
        On output this is the start of the actual range to flush.

    FlushLength - On input this is the length of the flush from the given FlushOffset.
        On output this is the length of the flush from the possibly modified FlushOffset.

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    PLFCB Lfcb;
    PLFCB NextLfcb;
    ULONG Range;
    ULONG Index;


    PAGED_CODE();

    //
    //  Find the correct Lfcb for this request.
    //

    Lfcb = WriteData->Lfcb;

    //
    //  Trim the write if not a system page size.
    //

    if (Lfcb->LogPageSize != PAGE_SIZE) {

        //
        //  Check if we are trimming before the write.
        //

        if (*FlushOffset < WriteData->FileOffset) {

            *FlushLength -= (ULONG) (WriteData->FileOffset - *FlushOffset);
            *FlushOffset = WriteData->FileOffset;
        }

        //
        //  Check that we aren't flushing too much.
        //

        if (*FlushOffset + *FlushLength > WriteData->FileOffset + WriteData->Length) {

            *FlushLength = (ULONG) (WriteData->FileOffset + WriteData->Length - *FlushOffset);
        }

        //
        //  Finally check if we have to redirty a page.
        //

        Range = (ULONG)PAGE_SIZE / (ULONG)Lfcb->LogPageSize;

        for (Index=0; Index < Range; Index++) {
            if (Lfcb->DirtyLbcb[Index] &&
                Lfcb->DirtyLbcb[Index]->FileOffset >= *FlushLength + *FlushOffset) {

                *((PULONG) (Lfcb->DirtyLbcb[Index]->PageHeader)) = LFS_SIGNATURE_RECORD_PAGE_ULONG;
            }

        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements the file close routine for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    18-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonClose (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsCloseVcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
MsCloseRootDcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
MsCloseCcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PCCB Ccb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
MsCloseFcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCloseCcb )
#pragma alloc_text( PAGE, MsCloseFcb )
#pragma alloc_text( PAGE, MsCloseRootDcb )
#pragma alloc_text( PAGE, MsCloseVcb )
#pragma alloc_text( PAGE, MsCommonClose )
#pragma alloc_text( PAGE, MsFsdClose )
#endif

NTSTATUS
MsFsdClose (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCloseFile API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdClose\n", 0);

    //
    // Call the common close routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonClose( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to our caller.
    //

    DebugTrace(-1, Dbg, "MsFsdClose -> %08lx\n", status );
    return status;
}

NTSTATUS
MsCommonClose (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for closing a file.

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID fsContext, fsContext2;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonClose...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG)Irp);

    //
    // Decode the file object to figure out who we are.
    //

    if (MsDecodeFileObject( irpSp->FileObject,
                            &fsContext,
                            &fsContext2 ) == NTC_UNDEFINED) {
        //
        // FCB and CCB nodes got marked inactive on cleanup. Reference them manualy.
        //
        MsReferenceNode( ((PNODE_HEADER)(fsContext)) );
    }


    //
    // Ignore the return code from MsDecode.  Parse the fsContext
    // to decide how to process the close IRP.
    //

    switch ( NodeType( fsContext ) ) {

    case MSFS_NTC_VCB:

        status = MsCloseVcb( MsfsDeviceObject,
                             Irp,
                             (PVCB)fsContext,
                             irpSp->FileObject );

        //
        // Release the reference to the VCB obtained from MsDecodeFileObject.
        //

        MsDereferenceVcb( (PVCB)fsContext );
        break;

    case MSFS_NTC_ROOT_DCB:

        status = MsCloseRootDcb( MsfsDeviceObject,
                                 Irp,
                                 (PROOT_DCB)fsContext,
                                 (PROOT_DCB_CCB)fsContext2,
                                 irpSp->FileObject );
        //
        // Release the reference to the root DCB obtained from
        // MsDecodeFileObject.
        //

        MsDereferenceRootDcb( (PROOT_DCB)fsContext );
        break;

    case MSFS_NTC_FCB:

        status = MsCloseFcb( MsfsDeviceObject,
                             Irp,
                             (PFCB)fsContext,
                             irpSp->FileObject );
        //
        // Release the reference to the FCB obtained from MsDecodeFileObject.
        //

        MsDereferenceFcb( (PFCB)fsContext );
        break;

    case MSFS_NTC_CCB:

        status = MsCloseCcb( MsfsDeviceObject,
                             Irp,
                             (PCCB)fsContext,
                             irpSp->FileObject );
        //
        // Release the reference to the CCB obtained from MsDecodeFileObject.
        //

        MsDereferenceCcb( (PCCB)fsContext );
        break;

#ifdef MSDBG
    default:

        //
        // This is not one of ours.
        //

        KeBugCheck( MAILSLOT_FILE_SYSTEM );
        break;
#endif

    }


    //
    // Complete the close IRP.
    //

    MsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "MsCommonClose -> %08lx\n", status);
    return status;
}


NTSTATUS
MsCloseVcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine closes the a file object that had opened the file system.

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the IRP associate with the close.  This procedure
        completes the IRP.

    Vcb - Supplies the VCB for the mailslot file system.

    FileObject - Supplies the file object being closed.

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCloseVcb, Vcb = %08lx\n", (ULONG)Vcb);


    //
    // Clear the referenced pointer to the VCB in the file object
    // and derefence the VCB.
    //

    ASSERT ( FileObject->FsContext == Vcb );

    MsSetFileObject( FileObject, NULL, NULL );
    MsDereferenceVcb( Vcb );

    //
    // Return to the caller.
    //

    return STATUS_SUCCESS;
}


NTSTATUS
MsCloseRootDcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine closes a file object that had opened the root directory

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the Irp associated with the close.  This procedure
        completes the Irp.

    RootDcb - Supplies the RootDcb for the mailslot file system.

    Ccb - Supplies the ccb.

    FileObject - Supplies the file object being closed

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCloseRootDcb, RootDcb = %08lx\n", (ULONG)RootDcb);


    //
    // Clear the file object pointers.
    //

    MsSetFileObject( FileObject, NULL, NULL );

    //
    // Drop the reference to the root DCB CCB. It should be deleted at this point.
    //

    MsDereferenceCcb( (PCCB)Ccb );

    //
    // Return to the caller.
    //

    return STATUS_SUCCESS;
}


NTSTATUS
MsCloseCcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PCCB Ccb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    The routine closes a file object belonging the the client side of
    a mailslot file.

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the Irp associated with the close,  The irp either
        get completed here or is enqueued in the data queue to be completed
        later.

    Ccb - Supplies the ccb for the mailslot being closed.

    FileObject - Supplies the caller file object that is being closed.

Return Value:

    NTSTATUS - An appropriate completion status.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCloseCcb...\n", 0);

    status = STATUS_SUCCESS;

    //
    // Clear the file object pointers and delete the open
    // reference to the CCB.
    //

    MsSetFileObject( FileObject, NULL, NULL );
    MsDereferenceCcb( Ccb ); // Close the Ccb


    return status;

}


NTSTATUS
MsCloseFcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    The routine closes a server side file object that opened a mailslot.

Arguments:

    MsfsDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the Irp associated with the close,  The irp either
        get completed here or is enqueued in the data queue to be completed
        later

    Ccb - Supplies the ccb for the mailslot being closed

    FileObject - Supplies the caller file object that is being closed

Return Value:

    NTSTATUS - An appropriate completion status.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCloseCcb...\n", 0);

    status = STATUS_SUCCESS;

    //
    // The root directory has changed, complete any notify requests.
    //

    MsCheckForNotify( Fcb->ParentDcb, TRUE, STATUS_SUCCESS );

    //
    //  Clear the FsContext pointer in the file object.  This
    //  indicates that the file is in the closing state.  Finally
    //  delete the open reference to the FCB.
    //

    MsSetFileObject( FileObject, NULL, NULL );
    MsDereferenceFcb( Fcb ); // Close the Fcb


    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements the file cleanup routine for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    23-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonCleanup (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsCleanupCcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PCCB Ccb
    );

NTSTATUS
MsCleanupFcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
MsCleanupRootDcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb
    );

NTSTATUS
MsCleanupVcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCleanupCcb )
#pragma alloc_text( PAGE, MsCleanupFcb )
#pragma alloc_text( PAGE, MsCleanupRootDcb )
#pragma alloc_text( PAGE, MsCleanupVcb )
#pragma alloc_text( PAGE, MsCommonCleanup )
#pragma alloc_text( PAGE, MsFsdCleanup )
#pragma alloc_text( PAGE, MsCancelTimer )
#endif

NTSTATUS
MsFsdCleanup (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCleanupFile API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdCleanup\n", 0);

    //
    // Call the common cleanup routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonCleanup( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to our caller.
    //

    DebugTrace(-1, Dbg, "MsFsdCleanup -> %08lx\n", status );
    return status;
}

NTSTATUS
MsCommonCleanup (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleaning up a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    NODE_TYPE_CODE nodeTypeCode;
    PVOID fsContext, fsContext2;
    PVCB vcb;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsFsdCleanup\n", 0);
    DebugTrace( 0, Dbg, "MsfsDeviceObject = %08lx\n", (ULONG)MsfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG)irpSp->FileObject);



    //
    // Get the a referenced pointer to the node. If this is a CCB close and the FCB is already closed
    // then the node type comes back as undefined. We still want to cleanup in this case.
    // Cleanup for the CCB in this case is removing it from the FCB chain and removing share options. We
    // could do without this cleanup but it would look stange to have a corrupted chain in this case
    // (it does not harm as its never traversed again).
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        MsReferenceNode( ((PNODE_HEADER)(fsContext)) );
    }

    //
    // Get the VCB we are trying to access.
    //

    vcb = &MsfsDeviceObject->Vcb;

    //
    // Acquire exclusive access to the VCB.
    //

    MsAcquireExclusiveVcb( vcb );

    try {

        //
        // Decide how to handle this IRP.
        //

        switch (NodeType( fsContext ) ) {

        case MSFS_NTC_FCB:       // Cleanup a server handle to a mailslot file

            status = MsCleanupFcb( MsfsDeviceObject,
                                   Irp,
                                   (PFCB)fsContext);

            MsDereferenceFcb( (PFCB)fsContext );
            break;

        case MSFS_NTC_CCB:       // Cleanup a client handle to a mailslot file

            status = MsCleanupCcb( MsfsDeviceObject,
                                   Irp,
                                   (PCCB)fsContext);

            MsDereferenceCcb( (PCCB)fsContext );
            break;

        case MSFS_NTC_VCB:       // Cleanup MSFS

            status = MsCleanupVcb( MsfsDeviceObject,
                                   Irp,
                                   (PVCB)fsContext);

            MsDereferenceVcb( (PVCB)fsContext );
            break;

        case MSFS_NTC_ROOT_DCB:  // Cleanup root directory

            status = MsCleanupRootDcb( MsfsDeviceObject,
                                       Irp,
                                       (PROOT_DCB)fsContext,
                                       (PROOT_DCB_CCB)fsContext2);

            MsDereferenceRootDcb( (PROOT_DCB)fsContext );
            break;

    #ifdef MSDBG
        default:

            //
            // This is not one of ours.
            //

            KeBugCheck( MAILSLOT_FILE_SYSTEM );
            break;
    #endif

        }


    } finally {

        MsReleaseVcb( vcb );

        status = STATUS_SUCCESS;
        MsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "MsCommonCleanup -> %08lx\n", status);

    }

    DebugTrace(-1, Dbg, "MsCommonCleanup -> %08lx\n", status);
    return status;
}


NTSTATUS
MsCleanupCcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PCCB Ccb
    )

/*++

Routine Description:

    The routine cleans up a CCB.

Arguments:

    MsfsDeviceObject - A pointer the the mailslot file system device object.

    Irp - Supplies the IRP associated with the cleanup.

    Ccb - Supplies the CCB for the mailslot to clean up.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS status;
    PFCB fcb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCleanupCcb...\n", 0);

    //
    // Get a pointer to the FCB.
    //

    fcb = Ccb->Fcb;

    //
    // Acquire exclusive access to the FCB
    //

    MsAcquireExclusiveFcb( fcb );

    //
    // Set the CCB to closing and remove this CCB from the active list. This CCB may already be
    // closed if the FCB was closed first so don't check this. We still want the chain maintained.
    //

    Ccb->Header.NodeState = NodeStateClosing;
    RemoveEntryList( &Ccb->CcbLinks );          // Protected by the FCB lock since this is the FCB CCB chain

    MsReleaseFcb( fcb );

    //
    // Cleanup the share access.
    //

    ASSERT (MsIsAcquiredExclusiveVcb(fcb->Vcb));
    IoRemoveShareAccess( Ccb->FileObject, &fcb->ShareAccess );


    //
    // And return to our caller
    //

    status = STATUS_SUCCESS;
    return status;
}

VOID
MsCancelTimer (
    IN PDATA_ENTRY DataEntry
    )

/*++

Routine Description:

    The routine cancels the timer and if possible frees up a work block

Arguments:
    DataEntry - Block that needs to be checked for a timer

Return Value:

    None

--*/
{
    PWORK_CONTEXT WorkContext;
    //
    // There was a timer on this read operation.  Attempt
    // to cancel the operation.  If the cancel operation
    // is successful, then we must cleanup after the operation.
    // If it was unsuccessful the timer DPC will run, and
    // will eventually cleanup.
    //


    WorkContext = DataEntry->TimeoutWorkContext;
    if (WorkContext == NULL) {
       //
       // No timeout for this request, its already been canceled or its running
       //
       return;
    }

    //
    // Nobody else should touch this now. either this routine will free this memory or the
    // timer is running at it will free the memory.
    //
    DataEntry->TimeoutWorkContext = NULL;

    if (KeCancelTimer( &WorkContext->Timer ) ) {

        //
        // Release the reference to the FCB.
        //

        MsDereferenceFcb( WorkContext->Fcb );

        //
        // Free the memory from the work context, the time
        // and the DPC.
        //

        IoFreeWorkItem (WorkContext->WorkItem);
        ExFreePool( WorkContext );

    } else {
        //
        // Time code is active. Break the link between the timer block and the IRP
        //
        WorkContext->Irp = NULL;
    }
}



NTSTATUS
MsCleanupFcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine cleans up an FCB.  All outstanding i/o on the file
    object are completed with an error status.

Arguments:

    MsfsDeviceObject - A pointer the the mailslot file system device object.

    Irp - Supplies the IRP associated with the cleanup.

    Fcb - Supplies the FCB for the mailslot to clean up.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS status;
    PDATA_QUEUE dataQueue;
    PDATA_ENTRY dataEntry;
    PLIST_ENTRY listEntry;
    PIRP oldIrp;
    PCCB ccb;
    PWORK_CONTEXT workContext;
    PKTIMER timer;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCleanupFcb, Fcb = %08lx\n", (ULONG)Fcb);


    status = STATUS_SUCCESS;

    //
    // Wipe out the name of the FCB from the prefix table and the parent DCB.
    //
    MsRemoveFcbName( Fcb );

    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( Fcb );


    try {


        //
        // Complete all outstanding I/O on this FCB.
        //

        dataQueue = &Fcb->DataQueue;
        dataQueue->QueueState = -1;

        for (listEntry = MsGetNextDataQueueEntry( dataQueue );
             !MsIsDataQueueEmpty(dataQueue);
             listEntry = MsGetNextDataQueueEntry( dataQueue ) ) {

             //
             // This is an outstanding I/O request on this FCB.
             // Remove it from our queue and complete the request
             // if one is outstanding.
             //

             dataEntry = CONTAINING_RECORD( listEntry, DATA_ENTRY, ListEntry );


             oldIrp = MsRemoveDataQueueEntry( dataQueue, dataEntry );

             if (oldIrp != NULL) {

                 DebugTrace(0, Dbg, "Completing IRP %08lx\n", (ULONG)oldIrp );
                 MsCompleteRequest( oldIrp, STATUS_FILE_FORCED_CLOSED );

             }

        }

        //
        // Now cleanup all the CCB's on this FCB, to ensure that new
        // write IRP will not be processed.
        //


        listEntry = Fcb->Specific.Fcb.CcbQueue.Flink;

        while( listEntry != &Fcb->Specific.Fcb.CcbQueue ) {

            ccb = (PCCB)CONTAINING_RECORD( listEntry, CCB, CcbLinks );

            ccb->Header.NodeState = NodeStateClosing;

            //
            // Get the next CCB on this FCB.
            //

            listEntry = listEntry->Flink;
        }

        //
        // Cleanup the share access.
        //

        ASSERT (MsIsAcquiredExclusiveVcb(Fcb->Vcb));
        IoRemoveShareAccess( Fcb->FileObject, &Fcb->ShareAccess);

        //
        // Mark the FCB closing.
        //

        Fcb->Header.NodeState = NodeStateClosing;

   } finally {

        MsReleaseFcb( Fcb );
        DebugTrace(-1, Dbg, "MsCloseFcb -> %08lx\n", status);
    }

    //
    // Return to the caller.
    //

    return status;

}


NTSTATUS
MsCleanupRootDcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb
    )

/*++

Routine Description:

    This routine cleans up a Root DCB.

Arguments:

    MsfsDeviceObject - A pointer the the mailslot file system device object.

    Irp - Supplies the IRP associated with the cleanup.

    RootDcb - Supplies the root dcb for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCleanupRootDcb...\n", 0);



    status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Now acquire exclusive access to the Vcb.
    //

    MsAcquireExclusiveVcb( RootDcb->Vcb );

    //
    // clear any active notify requests
    //
    MsFlushNotifyForFile (RootDcb, irpSp->FileObject);

    //
    // Remove share access
    //
    IoRemoveShareAccess( irpSp->FileObject,
                         &RootDcb->ShareAccess );

    //
    // Mark the DCB CCB closing.
    //

    Ccb->Header.NodeState = NodeStateClosing;

    MsReleaseVcb( RootDcb->Vcb );

    DebugTrace(-1, Dbg, "MsCleanupRootDcb -> %08lx\n", status);

    //
    // Return to the caller.
    //

    return status;
}


NTSTATUS
MsCleanupVcb (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb
    )

/*++

Routine Description:

    The routine cleans up a VCB.

Arguments:

    MsfsDeviceObject - A pointer the the mailslot file system device object.

    Irp - Supplies the IRP associated with the cleanup.

    Vcb - Supplies the VCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCleanupVcb...\n", 0);


    status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Now acquire exclusive access to the Vcb
    //

    MsAcquireExclusiveVcb( Vcb );

    IoRemoveShareAccess( irpSp->FileObject,
                             &Vcb->ShareAccess );

    MsReleaseVcb( Vcb );

    DebugTrace(-1, Dbg, "MsCleanupVcb -> %08lx\n", status);

    //
    //  And return to our caller
    //

    return status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\createms.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    createms.c

Abstract:

    This module implements the file create mailslot routine for MSFS called
    by the dispatch driver.

Author:

    Manny Weiser (mannyw)    17-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE_MAILSLOT)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonCreateMailslot (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

IO_STATUS_BLOCK
MsCreateMailslot (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN UNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN ULONG MailslotQuota,
    IN ULONG MaximumMessageSize,
    IN LARGE_INTEGER ReadTimeout,
    IN PEPROCESS CreatorProcess,
    IN PACCESS_STATE AccessState
    );

BOOLEAN
MsIsNameValid (
    PUNICODE_STRING Name
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonCreateMailslot )
#pragma alloc_text( PAGE, MsCreateMailslot )
#pragma alloc_text( PAGE, MsFsdCreateMailslot )
#pragma alloc_text( PAGE, MsIsNameValid )
#endif



NTSTATUS
MsFsdCreateMailslot (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateMailslotFile
    API call.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdCreateMailslot\n", 0);

    //
    //  Call the common create routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonCreateMailslot( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdCreateMailslot -> %08lx\n", status );
    return status;
}

NTSTATUS
MsCommonCreateMailslot (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating a mailslot.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PFILE_OBJECT fileObject;
    PFILE_OBJECT relatedFileObject;
    UNICODE_STRING fileName;
    ACCESS_MASK desiredAccess;
    ULONG options;
    USHORT shareAccess;
    PMAILSLOT_CREATE_PARAMETERS parameters;
    ULONG mailslotQuota;
    ULONG maximumMessageSize;
    PEPROCESS creatorProcess;
    LARGE_INTEGER readTimeout;

    BOOLEAN caseInsensitive = TRUE; //**** Make all searches case insensitive

    PVCB vcb;
    PFCB fcb;

    ULONG createDisposition;
    UNICODE_STRING remainingPart;

    PAGED_CODE();

    //
    // Make local copies of the input parameters to make things easier.
    //

    irpSp                = IoGetCurrentIrpStackLocation( Irp );
    fileObject           = irpSp->FileObject;
    relatedFileObject    = irpSp->FileObject->RelatedFileObject;
    fileName             = *(PUNICODE_STRING)&irpSp->FileObject->FileName;
    desiredAccess        = irpSp->Parameters.CreateMailslot.SecurityContext->DesiredAccess;
    options              = irpSp->Parameters.CreateMailslot.Options;
    shareAccess          = irpSp->Parameters.CreateMailslot.ShareAccess;
    parameters           = irpSp->Parameters.CreateMailslot.Parameters;
    mailslotQuota        = parameters->MailslotQuota;
    maximumMessageSize   = parameters->MaximumMessageSize;

    if (parameters->TimeoutSpecified) {
        readTimeout = parameters->ReadTimeout;
    } else {
        readTimeout.QuadPart = -1;
    }

    creatorProcess       = IoGetRequestorProcess( Irp );

    DebugTrace(+1, Dbg, "MsCommonCreateMailslot\n", 0 );
    DebugTrace( 0, Dbg, "MsfsDeviceObject     = %08lx\n", (ULONG)MsfsDeviceObject );
    DebugTrace( 0, Dbg, "Irp                  = %08lx\n", (ULONG)Irp );
    DebugTrace( 0, Dbg, "FileObject           = %08lx\n", (ULONG)fileObject );
    DebugTrace( 0, Dbg, "RelatedFileObject    = %08lx\n", (ULONG)relatedFileObject );
    DebugTrace( 0, Dbg, "FileName             = %wZ\n",   (ULONG)&fileName );
    DebugTrace( 0, Dbg, "DesiredAccess        = %08lx\n", desiredAccess );
    DebugTrace( 0, Dbg, "Options              = %08lx\n", options );
    DebugTrace( 0, Dbg, "ShareAccess          = %08lx\n", shareAccess );
    DebugTrace( 0, Dbg, "Parameters           = %08lx\n", (ULONG)parameters );
    DebugTrace( 0, Dbg, "MailslotQuota        = %08lx\n", mailslotQuota );
    DebugTrace( 0, Dbg, "MaximumMesssageSize  = %08lx\n", maximumMessageSize );
    DebugTrace( 0, Dbg, "CreatorProcess       = %08lx\n", (ULONG)creatorProcess );

    //
    // Get the VCB we are trying to access and extract the
    // create disposition.
    //

    vcb = &MsfsDeviceObject->Vcb;
    createDisposition = (options >> 24) & 0x000000ff;

    //
    // Acquire exclusive access to the VCB.
    //

    MsAcquireExclusiveVcb( vcb );

    try {

        //
        // If there is a related file object then this is a relative open
        // and it better be the root DCB.  Both the then and the else clause
        // return an FCB.
        //

        if (relatedFileObject != NULL) {

            PDCB dcb;

            dcb = relatedFileObject->FsContext;

            if (NodeType(dcb) != MSFS_NTC_ROOT_DCB ||
                fileName.Length < sizeof( WCHAR ) || fileName.Buffer[0] == L'\\') {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( status = STATUS_OBJECT_NAME_INVALID );
            }

            status = MsFindRelativePrefix( dcb,
                                           &fileName,
                                           caseInsensitive,
                                           &remainingPart,
                                           &fcb );
            if (!NT_SUCCESS (status)) {
                try_return( NOTHING );
            }

        } else {

            //
            // The only nonrelative name we allow are of the form
            // "\mailslot-name".
            //

            if ((fileName.Length <= sizeof( WCHAR )) || (fileName.Buffer[0] != L'\\')) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( status = STATUS_OBJECT_NAME_INVALID );
            }

            fcb = MsFindPrefix(
                    vcb,
                    &fileName,
                    caseInsensitive,
                    &remainingPart
                    );

        }

        //
        // If the remaining name is empty then we better have an FCB
        // otherwise we were given a illegal object name.
        //

        if (remainingPart.Length == 0) {

            if (fcb->Header.NodeTypeCode == MSFS_NTC_FCB) {

                DebugTrace(0,
                           Dbg,
                           "Attempt to create an existing mailslot, "
                               "Fcb = %08lx\n",
                           (ULONG)fcb );

                status = STATUS_OBJECT_NAME_COLLISION;

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);
                status = STATUS_OBJECT_NAME_INVALID;

            }

        } else {

            //
            // The remaining name is not empty so we better have the root DCB
            // and then have a valid object path.
            //

            if ( fcb->Header.NodeTypeCode == MSFS_NTC_ROOT_DCB  &&
                 MsIsNameValid( &remainingPart ) ) {

                DebugTrace(0,
                           Dbg,
                           "Create new mailslot, Fcb = %08lx\n",
                           (ULONG)fcb );

                Irp->IoStatus = MsCreateMailslot(
                                    fcb,
                                    fileObject,
                                    fileName,
                                    desiredAccess,
                                    createDisposition,
                                    shareAccess,
                                    mailslotQuota,
                                    maximumMessageSize,
                                    readTimeout,
                                    creatorProcess,
                                    irpSp->Parameters.CreateMailslot.SecurityContext->AccessState
                                    );

                status = Irp->IoStatus.Status;

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);
                status = STATUS_OBJECT_NAME_INVALID;

            }
        }


    try_exit: NOTHING;
    } finally {

        MsReleaseVcb( vcb );

        //
        // Complete the IRP and return to the caller.
        //

        MsCompleteRequest( Irp, status );
    }

    DebugTrace(-1, Dbg, "MsCommonCreateMailslot -> %08lx\n", status);
    return status;
}


IO_STATUS_BLOCK
MsCreateMailslot (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN UNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN ULONG MailslotQuota,
    IN ULONG MaximumMessageSize,
    IN LARGE_INTEGER ReadTimeout,
    IN PEPROCESS CreatorProcess,
    IN PACCESS_STATE AccessState
    )

/*++

Routine Description:

    This routine performs the operation for creating a new mailslot
    Fcb.  This routine does not complete any IRP, it preforms its
    function and then returns an iosb.

Arguments:

    RootDcb - Supplies the root dcb where this is going to be added.

    FileObject - Supplies the file object associated with the mailslot.

    FileName - Supplies the name of the mailslot (not qualified i.e.,
        simply "mailslot-name" and not "\mailslot-name".

    DesiredAccess - Supplies the caller's desired access.

    CreateDisposition - Supplies the caller's create disposition flags.

    ShareAccess - Supplies the caller specified share access.

    MailslotQuota - Supplies the mailslot quota amount.

    MaximumMessageSize - Supplies the size of the largest message that
        can be written to this mailslot.

    CreatorProcess - Supplies the process creating the mailslot.

Return Value:

    IO_STATUS_BLOCK - Returns the status of the operation.

--*/

{

    IO_STATUS_BLOCK iosb={0};
    PFCB fcb;
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateMailslot\n", 0 );

    //
    //  Check the parameters that must be supplied for a mailslot
    //

    if (CreateDisposition == FILE_OPEN) {
        iosb.Status = STATUS_OBJECT_NAME_NOT_FOUND;
        return iosb;
    }

    //
    // Create a new FCB for the mailslot.
    //
    status = MsCreateFcb( RootDcb->Vcb,
                          RootDcb,
                          &FileName,
                          CreatorProcess,
                          MailslotQuota,
                          MaximumMessageSize,
                          &fcb );

    if (!NT_SUCCESS (status)) {
        iosb.Status = status;
        return iosb;
    }

    fcb->Specific.Fcb.ReadTimeout = ReadTimeout;

    //
    //  Set the security descriptor in the Fcb
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    status = SeAssignSecurity( NULL,
                               AccessState->SecurityDescriptor,
                               &fcb->SecurityDescriptor,
                               FALSE,
                               &AccessState->SubjectSecurityContext,
                               IoGetFileObjectGenericMapping(),
                               PagedPool );

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    if (!NT_SUCCESS(status)) {

        DebugTrace(0, Dbg, "Error calling SeAssignSecurity\n", 0 );

        MsRemoveFcbName( fcb );
        MsDereferenceFcb( fcb );
        iosb.Status = status;
        return iosb;
    }

    //
    // Set the new share access.
    //
    ASSERT (MsIsAcquiredExclusiveVcb(fcb->Vcb));
    IoSetShareAccess( DesiredAccess,
                      ShareAccess,
                      FileObject,
                      &fcb->ShareAccess );

    //
    // Set the file object back pointers and our pointer to the
    // server file object.
    //

    MsSetFileObject( FileObject, fcb, NULL );

    fcb->FileObject = FileObject;

    //
    // Update the FCB timestamps.
    //

    KeQuerySystemTime( &fcb->Specific.Fcb.CreationTime );
    fcb->Specific.Fcb.LastModificationTime = fcb->Specific.Fcb.CreationTime;
    fcb->Specific.Fcb.LastAccessTime = fcb->Specific.Fcb.CreationTime;
    fcb->Specific.Fcb.LastChangeTime = fcb->Specific.Fcb.CreationTime;

    //
    // Set the return status.
    //

    iosb.Status = STATUS_SUCCESS;
    iosb.Information = FILE_CREATED;

    //
    // The root directory has changed.  Complete any notify change
    // directory requests.
    //

    MsCheckForNotify( fcb->ParentDcb, TRUE, STATUS_SUCCESS );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateMailslot -> %08lx\n", iosb.Status);
    return iosb;
}

BOOLEAN
MsIsNameValid (
    PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine tests for illegal characters in a name.  The same character
    set as Npfs/Ntfs is used.  Also preceding backslashes, wildcards, and
    path names are not allowed.

Arguments:

    Name - The name to search for illegal characters

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

--*/

{
    ULONG i;
    WCHAR Char = L'\\';

    PAGED_CODE();
    for (i=0; i < Name->Length / sizeof(WCHAR); i += 1) {

        Char = Name->Buffer[i];

        if ( (Char <= 0xff) && (Char != L'\\') &&
             !FsRtlIsAnsiCharacterLegalNtfs(Char, FALSE) ) {

            return FALSE;
        }
    }

    //
    // If the last char of the name was slash, we have an illegal name
    //
    return (Char != L'\\');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\datasup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DataSup.c

Abstract:

    This module implements the mailslot data queue support functions.

Author:

    Manny Weiser (mannyw)    9-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DATASUP)

//
// Local declarations
//

VOID
MsSetCancelRoutine(
    IN PIRP Irp
    );

//
//  The following macro is used to dump a data queue
//

#define DumpDataQueue(S,P) {                                   \
    ULONG MsDumpDataQueue(IN ULONG Level, IN PDATA_QUEUE Ptr); \
    DebugTrace(0,Dbg,S,0);                                     \
    DebugTrace(0,Dbg,"", MsDumpDataQueue(Dbg,P));              \
}


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsAddDataQueueEntry )
#pragma alloc_text( PAGE, MsInitializeDataQueue )
#pragma alloc_text( PAGE, MsRemoveDataQueueEntry )
#pragma alloc_text( PAGE, MsUninitializeDataQueue )
#pragma alloc_text( PAGE, MsSetCancelRoutine )
#pragma alloc_text( PAGE, MsResetCancelRoutine )
#pragma alloc_text( PAGE, MsRemoveDataQueueIrp )
#endif

#if 0
NOT PAGEABLE -- MsCancelDataQueueIrp

#endif


NTSTATUS
MsInitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN PEPROCESS Process,
    IN ULONG Quota,
    IN ULONG MaximumMessageSize
    )

/*++

Routine Description:

    This routine initializes a new data queue.  The indicated quota is taken
    from the process and not returned until the data queue is uninitialized.

Arguments:

    DataQueue - Supplies the data queue to be initialized.

    Process - Supplies a pointer to the process creating the mailslot.

    Quota - Supplies the quota to assign to the data queue.

    MaximumMessageSize - The size of the largest message that can be
        written to the data queue.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsInitializeDataQueue, DataQueue = %08lx\n", (ULONG)DataQueue);

    //
    // Get the process's quota, if we can't get it then this call will
    // raise status.
    //

    Status = PsChargeProcessPagedPoolQuota (Process, Quota);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ObReferenceObject( Process );

    //
    // Initialize the data queue structure.
    //

    DataQueue->BytesInQueue       = 0;
    DataQueue->EntriesInQueue     = 0;
    DataQueue->QueueState         = Empty;
    DataQueue->MaximumMessageSize = MaximumMessageSize;
    DataQueue->Quota              = Quota;
    DataQueue->QuotaUsed          = 0;
    InitializeListHead( &DataQueue->DataEntryList );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsInitializeDataQueue -> VOID\n", 0);
    return STATUS_SUCCESS;
}


VOID
MsUninitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN PEPROCESS Process
    )

/*++

Routine Description:

    This routine uninitializes a data queue.  The previously debited quota
    is returned to the process.

Arguments:

    DataQueue - Supplies the data queue being uninitialized

    Process - Supplies a pointer to the process who created the mailslot

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsUninitializeDataQueue, DataQueue = %08lx\n", (ULONG)DataQueue);

    //
    //  Assert that the queue is empty
    //

    ASSERT( IsListEmpty(&DataQueue->DataEntryList) );
    ASSERT( DataQueue->BytesInQueue   == 0);
    ASSERT( DataQueue->EntriesInQueue == 0);
    ASSERT( DataQueue->QuotaUsed      == 0);

    //
    //  Return all of our quota back to the process
    //

    PsReturnProcessPagedPoolQuota (Process, DataQueue->Quota);
    ObDereferenceObject (Process);

    //
    // For safety's sake, zero out the data queue structure.
    //

    RtlZeroMemory (DataQueue, sizeof (DATA_QUEUE));

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsUnininializeDataQueue -> VOID\n", 0);
    return;
}


NTSTATUS
MsAddDataQueueEntry (
    IN  PDATA_QUEUE DataQueue,
    IN  QUEUE_STATE Who,
    IN  ULONG DataSize,
    IN  PIRP Irp,
    IN  PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function adds a new data entry to the of the data queue.
    Entries are always appended to the queue.  If necessary this
    function will allocate a data entry buffer, or use space in
    the IRP.

    The different actions we are perform are based on the type and who
    parameters and quota requirements.


    Who == ReadEntries

        +----------+                      - Allocate Data Entry from IRP
        |Irp       |     +-----------+
        |BufferedIo|<----|Buffered   |    - Allocate New System buffer
        |DeallBu...|     |EitherQuota|
        +----------+     +-----------+    - Reference and modify Irp to
          |      |         |                do Buffered I/O, Deallocate
          v      |         v                buffer, and have I/O completion
        +------+ +------>+------+           copy the buffer (Input operation)
        |User  |         |System|
        |Buffer|         |Buffer|
        +------+         +------+

    Who == WriteEntries && Quota Available

        +----------+                      - Allocate Data Entry from Quota
        |Irp       |     +-----------+
        |          |     |Buffered   |    - Allocate New System buffer
        |          |     |Quota      |
        +----------+     +-----------+    - Copy data from User buffer to
          |                |                system buffer
          v                v
        +------+         +------+         - Complete IRP
        |User  |..copy..>|System|
        |Buffer|         |Buffer|
        +------+         +------+

    Who == WriteEntries && Quota Not Available

        +----------+                     - Allocate Data Entry from Irp
        |Irp       |     +-----------+
        |BufferedIo|<----|Buffered   |   - Allocate New System buffer
        |DeallBuff |     |UserQuota  |
        +----------+     +-----------+   - Reference and modify Irp to use
          |      |         |               the new system buffer, do Buffered
          v      |         v               I/O, and Deallocate buffer
        +------+ +------>+------+
        |User  |         |System|        - Copy data from User buffer to
        |Buffer|..copy..>|Buffer|          system buffer
        +------+         +------+


Arguments:

    DataQueue - Supplies the Data queue being modified.

    Who - Indicates if this is the reader or writer that is adding to the
        mailslot.

    DataSize - Indicates the size of the data buffer needed to represent
        this entry.

    Irp - Supplies a pointer to the IRP responsible for this entry.

Return Value:

    PDATA_ENTRY - Returns a pointer to the newly added data entry.

--*/

{
    PDATA_ENTRY dataEntry;
    PLIST_ENTRY previousEntry;
    PFCB fcb;
    ULONG TotalSize;
    NTSTATUS status;

    PAGED_CODE( );

    DebugTrace(+1, Dbg, "MsAddDataQueueEntry, DataQueue = %08lx\n", (ULONG)DataQueue);

    ASSERT( DataQueue->QueueState != -1 );

    Irp->IoStatus.Information = 0;

    if (Who == ReadEntries) {

        //
        // Allocate a data entry from the IRP, and allocate a new
        // system buffer.
        //

        dataEntry = (PDATA_ENTRY)IoGetNextIrpStackLocation( Irp );

        dataEntry->DataPointer = NULL;
        dataEntry->Irp = Irp;
        dataEntry->DataSize = DataSize;
        dataEntry->TimeoutWorkContext = WorkContext;

        //
        // Check to see if the mailslot has enough quota left to
        // allocate the system buffer.
        //

        if ((DataQueue->Quota - DataQueue->QuotaUsed) >= DataSize) {

            //
            // Use the mailslot quota to allocate pool for the request.
            //

            if (DataSize) {
                dataEntry->DataPointer = MsAllocatePagedPoolCold( DataSize,
                                                                  'rFsM' );
                if (dataEntry->DataPointer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            DataQueue->QuotaUsed += DataSize;

            dataEntry->From = MailslotQuota;


        } else {

            //
            // Use the caller's quota to allocate pool for the request.
            //

            if (DataSize) {
                dataEntry->DataPointer = MsAllocatePagedPoolWithQuotaCold( DataSize,
                                                                           'rFsM' );
                if (dataEntry->DataPointer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            dataEntry->From = UserQuota;

        }

        //
        // Modify the IRP to be buffered I/O, deallocate the buffer, copy
        // the buffer on completion, and to reference the new system
        // buffer.
        //

        Irp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
        Irp->AssociatedIrp.SystemBuffer = dataEntry->DataPointer;
        if (Irp->AssociatedIrp.SystemBuffer) {
            Irp->Flags |= IRP_DEALLOCATE_BUFFER;
        }

        Irp->IoStatus.Pointer = DataQueue;
        status = STATUS_PENDING;


    } else {

        //
        // This is a writer entry.
        //

        //
        // If there is enough quota left in the mailslot then we will
        // allocate the data entry and data buffer from the mailslot
        // quota.
        //
        TotalSize = sizeof(DATA_ENTRY) + DataSize;
        if (TotalSize < sizeof(DATA_ENTRY)) {
            return STATUS_INVALID_PARAMETER;
        }

        if ((DataQueue->Quota - DataQueue->QuotaUsed) >= TotalSize) {

            //
            // Allocate the data buffer using the mailslot quota.
            //

            dataEntry = MsAllocatePagedPool( TotalSize, 'dFsM' );
            if (dataEntry == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            dataEntry->DataPointer = (PVOID) (dataEntry + 1);

            DataQueue->QuotaUsed += TotalSize;

            dataEntry->From = MailslotQuota;

        } else {

            //
            // There isn't enough quota in the mailslot.  Use the
            // caller's quota.
            //

            dataEntry = MsAllocatePagedPoolWithQuota( TotalSize, 'dFsM' );
            if (dataEntry == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            dataEntry->DataPointer = (PVOID) (dataEntry + 1);

            dataEntry->From = UserQuota;

        }
        dataEntry->Irp = NULL;
        dataEntry->DataSize = DataSize;
        dataEntry->TimeoutWorkContext = NULL;

        //
        // Copy the user buffer to the new system buffer, update the FCB
        // timestamps and complete the IRP.
        //

        try {

            RtlCopyMemory (dataEntry->DataPointer, Irp->UserBuffer, DataSize);

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            // Only need to free the writers case as the readers get the buffer freed on I/O
            // completion.
            //
            if (Who == WriteEntries) {
                MsFreePool ( dataEntry );
            }

            return GetExceptionCode (); // Watch out. Could be a guard page violation thats a warning!
        }

        fcb = CONTAINING_RECORD( DataQueue, FCB, DataQueue );
        KeQuerySystemTime( &fcb->Specific.Fcb.LastModificationTime );

        Irp->IoStatus.Information = DataSize;
        status = STATUS_SUCCESS;

    } // else (writer entry)

    //
    // Now data entry points to a new data entry to add to the data queue
    // Check if the queue is empty otherwise we will add this entry to
    // the end of the queue.
    //

#if DBG
    if ( IsListEmpty( &DataQueue->DataEntryList ) ) {

        ASSERT( DataQueue->QueueState     == Empty );
        ASSERT( DataQueue->BytesInQueue   == 0);
        ASSERT( DataQueue->EntriesInQueue == 0);

    } else {

        ASSERT( DataQueue->QueueState == Who );

    }

#endif

    DataQueue->QueueState     = Who;

    //
    // Only cound written bytes and messages in the queue. This makes sense because we return
    // this value as the end of file position. GetMailslotInfo needs EntriesInQueue to
    // ignore reads.
    //
    if (Who == WriteEntries) {
        DataQueue->BytesInQueue   += dataEntry->DataSize;
        DataQueue->EntriesInQueue += 1;
    }

    //
    // Insert the new entry at the appropriate place in the data queue.
    //

    InsertTailList( &DataQueue->DataEntryList, &dataEntry->ListEntry );

    WorkContext = dataEntry->TimeoutWorkContext;
    if ( WorkContext) {
        KeSetTimer( &WorkContext->Timer,
                    WorkContext->Fcb->Specific.Fcb.ReadTimeout,
                    &WorkContext->Dpc );
    }

    if (Who == ReadEntries) {
        MsSetCancelRoutine( Irp );  // this fakes a call to cancel if we are already canceled
    }


    //
    // Return to the caller.
    //

    DumpDataQueue( "After AddDataQueueEntry\n", DataQueue );
    DebugTrace(-1, Dbg, "MsAddDataQueueEntry -> %08lx\n", (ULONG)dataEntry);

    return status;
}


PIRP
MsRemoveDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN PDATA_ENTRY DataEntry
    )

/*++

Routine Description:

    This routine removes the specified data entry from the indicated
    data queue, and possibly returns the IRP associated with the entry if
    it wasn't already completed.

    If the data entry we are removing indicates buffered I/O then we also
    need to deallocate the data buffer besides the data entry but only
    if the IRP is null.  Note that the data entry might be stored in an IRP.
    If it is then we are going to return the IRP it is stored in.

Arguments:

    DataEntry - Supplies a pointer to the data entry to remove.

Return Value:

    PIRP - Possibly returns a pointer to an IRP.

--*/

{
    FROM from;
    PIRP irp;
    ULONG dataSize;
    PVOID dataPointer;

    PAGED_CODE( );

    DebugTrace(+1, Dbg, "MsRemoveDataQueueEntry, DataEntry = %08lx\n", (ULONG)DataEntry);
    DebugTrace( 0, Dbg, "DataQueue = %08lx\n", (ULONG)DataQueue);

    //
    // Remove the data entry from the queue and update the count of
    // data entries in the queue.
    //

    RemoveEntryList( &DataEntry->ListEntry );
    //
    // If the queue is now empty then we need to fix the queue
    // state.
    //

    if (IsListEmpty( &DataQueue->DataEntryList ) ) {
        DataQueue->QueueState = Empty;
    }

    //
    // Capture some of the fields from the data entry to make our
    // other references a little easier.
    //

    from = DataEntry->From;
    dataSize = DataEntry->DataSize;


    if (from == MailslotQuota) {
        DataQueue->QuotaUsed -= dataSize;
    }
    //
    // Get the IRP for this block if there is one
    //

    irp = DataEntry->Irp;
    if (irp) {
        //
        // Cancel the timer associated with this if there is one
        //
        MsCancelTimer (DataEntry);
        irp = MsResetCancelRoutine( irp );
        if ( irp == NULL ) {

            //
            // cancel is active. Let it know that we already did partial cleanup.
            // It just has to complete the IRP.
            //
            DataEntry->ListEntry.Flink = NULL;
        }

    } else {

        DataQueue->BytesInQueue -= DataEntry->DataSize;

        //
        // Free the data entry for a write request. This is part of the IRP for a read request.
        //
        ExFreePool( DataEntry );

        if (from == MailslotQuota) {
            DataQueue->QuotaUsed -= sizeof(DATA_ENTRY);
        }

        DataQueue->EntriesInQueue--;
#if DBG
        if (DataQueue->EntriesInQueue == 0) {
            ASSERT (DataQueue->QueueState == Empty);
            ASSERT (DataQueue->BytesInQueue == 0);
            ASSERT (IsListEmpty( &DataQueue->DataEntryList ));
            ASSERT (DataQueue->QuotaUsed == 0);
        }
#endif
    }


    //
    // Return to the caller.
    //

    DumpDataQueue( "After RemoveDataQueueEntry\n", DataQueue );
    DebugTrace(-1, Dbg, "MsRemoveDataQueueEntry -> %08lx\n", (ULONG)irp);

    return irp;
}


VOID
MsRemoveDataQueueIrp (
    IN PIRP Irp,
    IN PDATA_QUEUE DataQueue
    )
/*++

Routine Description:

    This routine removes an IRP from its data queue.

Requirements:

    The FCB for this data queue MUST be exclusively locked.

Arguments:

    Irp - Supplies the Irp being removed.

    DataQueue - A pointer to the data queue structure where we expect
            to find the IRP.

Return Value:

    Returns whether or not we actually dequeued the IRP.

--*/

{
    PDATA_ENTRY dataEntry;
    PLIST_ENTRY listEntry, nextListEntry;
    PWORK_CONTEXT workContext;
    PKTIMER timer;
    BOOLEAN foundIrp = FALSE;

    dataEntry = (PDATA_ENTRY)IoGetNextIrpStackLocation( Irp );

    //
    // This is the cancel path. If a completion path has already removed this IRP then return now.
    // The timer will have been canceled, counts adjusted etc.
    //
    if (dataEntry->ListEntry.Flink == NULL) {
       return;
    }
    //
    // remove this entry from the list.
    //
    RemoveEntryList (&dataEntry->ListEntry);

    MsCancelTimer (dataEntry);

    //
    // If the queue is now empty then we need to fix the queue
    // state.
    //

    //
    // Check if we need to return mailslot quota. The DATA_ENTRY was part of the IRP so we didn't
    // get charged for that
    //

    if ( dataEntry->From == MailslotQuota ) {
        DataQueue->QuotaUsed -= dataEntry->DataSize;
    }

    if (IsListEmpty( &DataQueue->DataEntryList ) ) {

        DataQueue->QueueState = Empty;

        ASSERT (DataQueue->BytesInQueue == 0);
        ASSERT (DataQueue->QuotaUsed == 0);
        ASSERT (DataQueue->EntriesInQueue == 0);
    }



    //
    //  And return to our caller
    //

    return;

} // MsRemoveDataQueueIrp


VOID
MsCancelDataQueueIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an IRP saved in a
    data queue

Arguments:

    DeviceObject - Device object associated with IRP or NULL if called directly by this driver

    Irp - Supplies the Irp being cancelled.

Return Value:

    None.

--*/

{
    PFCB fcb;
    PDATA_QUEUE dataQueue;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT fileObject;


    //
    // This isn't strictly correct. IoCancelIrp can be called at Irql <= DISPATCH_LEVEL but
    // this code is assuming that the IRQL of the caller is <= APC_LEVEL.
    // If we are called inline we don't hold the cancel spinlock and we already own the FCB lock.
    //
    if (DeviceObject != NULL) {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpSp->FileObject;

    dataQueue = (PDATA_QUEUE)Irp->IoStatus.Pointer;


    fcb = CONTAINING_RECORD( dataQueue, FCB, DataQueue );

    //
    //  Get exclusive access to the mailslot FCB so we can now do our work.
    //
    if (DeviceObject != NULL) {
        FsRtlEnterFileSystem ();
        MsAcquireExclusiveFcb( fcb );
    }

    MsRemoveDataQueueIrp( Irp, dataQueue );

    if (DeviceObject != NULL) {
        MsReleaseFcb( fcb );
        FsRtlExitFileSystem ();
    }


    MsCompleteRequest( Irp, STATUS_CANCELLED );
    //
    //  And return to our caller
    //

    return;

} // MsCancelDataQueueIrp

PIRP
MsResetCancelRoutine(
    IN PIRP Irp
    )

/*++

Routine Description:

    Stub to null out the cancel routine.

Arguments:

    Irp - Supplies the Irp whose cancel routine is to be nulled out.

Return Value:

    None.

--*/
{
    if ( IoSetCancelRoutine( Irp, NULL ) != NULL ) {
       return Irp;
    } else {
       return NULL;
    }

} // MsResetCancelRoutine

VOID
MsSetCancelRoutine(
    IN PIRP Irp
    )

/*++

Routine Description:

    Stub to set the cancel routine.  If the irp has already been cancelled,
    the cancel routine is called.

Arguments:

    Irp - Supplies the Irp whose cancel routine is to be set.

Return Value:

    None.

--*/
{
    IoMarkIrpPending( Irp ); // top level always returns STATUS_PENDING if we get this far

    IoSetCancelRoutine( Irp, MsCancelDataQueueIrp );
    if ( Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL ) {
        //
        // The IRP was canceled before we put our routine on. Fake a cancel call
        //
        
        MsCancelDataQueueIrp (NULL, Irp);
    }

    return;

} // MsSetCancelRoutine

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements the file create routine for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    16-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
// Local procedure prototypes
//

NTSTATUS
MsCommonCreate (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

IO_STATUS_BLOCK
MsCreateClientEnd(
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN PETHREAD UserThread
    );

IO_STATUS_BLOCK
MsOpenMailslotFileSystem (
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    );

IO_STATUS_BLOCK
MsOpenMailslotRootDirectory (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonCreate )
#pragma alloc_text( PAGE, MsCreateClientEnd )
#pragma alloc_text( PAGE, MsFsdCreate )
#pragma alloc_text( PAGE, MsOpenMailslotFileSystem )
#pragma alloc_text( PAGE, MsOpenMailslotRootDirectory )
#endif



NTSTATUS
MsFsdCreate (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the IRP.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdCreate\n", 0);

    //
    // Call the common create routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonCreate( MsfsDeviceObject, Irp );


    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdCreate -> %08lx\n", status );
    return status;
}

NTSTATUS
MsCommonCreate (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PFILE_OBJECT fileObject;
    PFILE_OBJECT relatedFileObject;
    UNICODE_STRING fileName;
    ACCESS_MASK desiredAccess;
    USHORT shareAccess;

    BOOLEAN caseInsensitive = TRUE; //**** Make all searches case insensitive

    PVCB vcb;
    PFCB fcb;

    UNICODE_STRING remainingPart;

    PAGED_CODE();

    //
    // Make local copies of our input parameters to make things easier.
    //

    irpSp             = IoGetCurrentIrpStackLocation( Irp );
    fileObject        = irpSp->FileObject;
    relatedFileObject = irpSp->FileObject->RelatedFileObject;
    fileName          = *(PUNICODE_STRING)&irpSp->FileObject->FileName;
    desiredAccess     = irpSp->Parameters.Create.SecurityContext->DesiredAccess;
    shareAccess       = irpSp->Parameters.Create.ShareAccess;

    DebugTrace(+1, Dbg, "MsCommonCreate\n", 0 );
    DebugTrace( 0, Dbg, "MsfsDeviceObject  = %08lx\n", (ULONG)MsfsDeviceObject );
    DebugTrace( 0, Dbg, "Irp               = %08lx\n", (ULONG)Irp );
    DebugTrace( 0, Dbg, "FileObject        = %08lx\n", (ULONG)fileObject );
    DebugTrace( 0, Dbg, "relatedFileObject = %08lx\n", (ULONG)relatedFileObject );
    DebugTrace( 0, Dbg, "FileName          = %wZ\n",   (ULONG)&fileName );
    DebugTrace( 0, Dbg, "DesiredAccess     = %08lx\n", desiredAccess );
    DebugTrace( 0, Dbg, "ShareAccess       = %08lx\n", shareAccess );

    //
    // Get the VCB we are trying to access.
    //

    vcb = &MsfsDeviceObject->Vcb;

    //
    // Acquire exclusive access to the VCB.
    //

    MsAcquireExclusiveVcb( vcb );

    try {

        //
        // Check if we are trying to open the mailslot file system
        // (i.e., the Vcb).
        //

        if ((fileName.Length == 0) &&
            ((relatedFileObject == NULL) || (
                NodeType(relatedFileObject->FsContext) == MSFS_NTC_VCB))) {

            DebugTrace(0, Dbg, "Open mailslot file system\n", 0);

            Irp->IoStatus = MsOpenMailslotFileSystem( vcb,
                                                      fileObject,
                                                      desiredAccess,
                                                      shareAccess );

            status = Irp->IoStatus.Status;
            try_return( NOTHING );
        }

        //
        // Check if we are trying to open the root directory.
        //

        if (((fileName.Length == sizeof(WCHAR)) &&
             (fileName.Buffer[0] == L'\\') &&
             (relatedFileObject == NULL))

                ||

            ((fileName.Length == 0) && (NodeType(
                    relatedFileObject->FsContext) == MSFS_NTC_ROOT_DCB))) {

            DebugTrace(0, Dbg, "Open root directory system\n", 0);

            Irp->IoStatus = MsOpenMailslotRootDirectory( vcb->RootDcb,
                                                         fileObject,
                                                         desiredAccess,
                                                         shareAccess );

            status = Irp->IoStatus.Status;
            try_return( NOTHING );
        }

        //
        // If there is a related file object then this is a relative open
        // and it better be the root DCB.  Both the then and the else clause
        // return an FCB.
        //

        if (relatedFileObject != NULL) {

            PDCB dcb;

            dcb = relatedFileObject->FsContext;

            if (NodeType(dcb) != MSFS_NTC_ROOT_DCB) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( status = STATUS_OBJECT_NAME_INVALID );
            }

            status = MsFindRelativePrefix( dcb,
                                           &fileName,
                                           caseInsensitive,
                                           &remainingPart,
                                           &fcb );
            if (!NT_SUCCESS (status)) {               
                try_return( NOTHING );
            }

        } else {

            //
            // The only nonrelative name we allow are of the form
            // "\mailslot-name".
            //

            if ((fileName.Length <= sizeof( WCHAR )) || (fileName.Buffer[0] != L'\\')) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( status = STATUS_OBJECT_NAME_INVALID );
            }

            fcb = MsFindPrefix( vcb,
                                &fileName,
                                caseInsensitive,
                                &remainingPart );
        }

        //
        //  If the remaining name is not empty then we have an error, either
        //  we have an illegal name or a non-existent name.
        //

        if (remainingPart.Length != 0) {

            if (fcb->Header.NodeTypeCode == MSFS_NTC_FCB) {

                //
                // We were given a name such as "\mailslot-name\another-name"
                //

                DebugTrace(0, Dbg, "Illegal object name\n", 0);
                status = STATUS_OBJECT_NAME_INVALID;

            } else {

                //
                // We were given a non-existent name
                //

                DebugTrace(0, Dbg, "non-existent name\n", 0);
                status = STATUS_OBJECT_NAME_NOT_FOUND;
            }

        } else {

            //
            // The remaining name is empty so we better have an FCB otherwise
            // we have an invalid object name.
            //

            if (fcb->Header.NodeTypeCode == MSFS_NTC_FCB) {

                DebugTrace(0,
                           Dbg,
                           "Create client end mailslot, Fcb = %08lx\n",
                           (ULONG)fcb );

                Irp->IoStatus = MsCreateClientEnd( fcb,
                                                   fileObject,
                                                   desiredAccess,
                                                   shareAccess,
                                                   irpSp->Parameters.Create.SecurityContext->AccessState,
                                                   Irp->RequestorMode,
                                                   Irp->Tail.Overlay.Thread
                                                   );
                status = Irp->IoStatus.Status;

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);
                status = STATUS_OBJECT_NAME_INVALID;

            }
        }


    try_exit: NOTHING;
    } finally {

        MsReleaseVcb( vcb );

        //
        // Complete the IRP and return to the caller.
        //

        MsCompleteRequest( Irp, status );
        DebugTrace(-1, Dbg, "MsCommonCreate -> %08lx\n", status);

    }

    return status;
}


IO_STATUS_BLOCK
MsCreateClientEnd (
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN PETHREAD UserThread
    )

/*++

Routine Description:

    This routine performs the operation for opening the client end of a
    mailslot.  This routine does not complete the IRP, it performs the
    function and then returns a status.

Arguments:

    Fcb - Supplies the FCB for the mailslot being accessed.

    FileObject - Supplies the file object associated with the client end.

    DesiredAccess - Supplies the caller's desired access.

    ShareAccess - Supplies the caller's share access.

Return Value:

    IO_STATUS_BLOCK - Returns the appropriate status for the operation

--*/

{
    IO_STATUS_BLOCK iosb;
    PCCB ccb;

    BOOLEAN accessGranted;
    ACCESS_MASK grantedAccess;
    UNICODE_STRING name;
    PPRIVILEGE_SET Privileges = NULL;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateClientEnd\n", 0 );

    try {

        //
        // Lock out mods to the FCB's security descriptor.
        //
        MsAcquireSharedFcb( Fcb );

        SeLockSubjectContext( &AccessState->SubjectSecurityContext );

        //
        //  First do an access check for the user against the Fcb
        //
        accessGranted = SeAccessCheck( Fcb->SecurityDescriptor,
                                       &AccessState->SubjectSecurityContext,
                                       TRUE,                        // Tokens are locked
                                       DesiredAccess,
                                       0,
                                       &Privileges,
                                       IoGetFileObjectGenericMapping(),
                                       RequestorMode,
                                       &grantedAccess,
                                       &iosb.Status );

        if (Privileges != NULL) {

              (VOID) SeAppendPrivileges(
                         AccessState,
                         Privileges
                         );

            SeFreePrivileges( Privileges );
        }

        if (accessGranted) {
            AccessState->PreviouslyGrantedAccess |= grantedAccess;
            AccessState->RemainingDesiredAccess &= ~(grantedAccess | MAXIMUM_ALLOWED);
        }

        RtlInitUnicodeString( &name, L"Mailslot" );

        SeOpenObjectAuditAlarm( &name,
                                NULL,
                                &FileObject->FileName,
                                Fcb->SecurityDescriptor,
                                AccessState,
                                FALSE,
                                accessGranted,
                                RequestorMode,
                                &AccessState->GenerateOnClose );


        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

        MsReleaseFcb( Fcb );

        if (!accessGranted) {

            DebugTrace(0, Dbg, "Access Denied\n", 0 );

            try_return( iosb.Status );
        }


        //
        // Now make sure our share access is okay.
        //
        ASSERT (MsIsAcquiredExclusiveVcb(Fcb->Vcb));
        if (!NT_SUCCESS(iosb.Status = IoCheckShareAccess( grantedAccess,
                                                          ShareAccess,
                                                          FileObject,
                                                          &Fcb->ShareAccess,
                                                          TRUE ))) {

            DebugTrace(0, Dbg, "Sharing violation\n", 0);

            try_return( NOTHING );

        }

        //
        // Create a CCB for this client.
        //

        iosb.Status = MsCreateCcb( Fcb, &ccb );
        if (!NT_SUCCESS (iosb.Status)) {

            IoRemoveShareAccess( FileObject, &Fcb->ShareAccess );

            try_return( iosb.Status);
        }
        

        //
        // Set the file object back pointers and our pointer to the
        // server file object.
        //

        MsSetFileObject( FileObject, ccb, NULL );

        ccb->FileObject = FileObject;

        //
        //  And set our return status
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;


    try_exit: NOTHING;
    } finally {

        DebugTrace(-1, Dbg, "MsCreateClientEnd -> %08lx\n", iosb.Status);

    }

    return iosb;
}


IO_STATUS_BLOCK
MsOpenMailslotFileSystem (
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    )

{
    IO_STATUS_BLOCK iosb = {0};

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsOpenMailslotFileSystem, Vcb = %p\n", Vcb);


    //
    //  Set the new share access
    //
    ASSERT (MsIsAcquiredExclusiveVcb(Vcb));
    if (NT_SUCCESS(iosb.Status = IoCheckShareAccess( DesiredAccess,
                                                     ShareAccess,
                                                     FileObject,
                                                     &Vcb->ShareAccess,
                                                     TRUE ))) {
        //
        // Supply the file object with a referenced pointer to the VCB.
        //

        MsReferenceVcb (Vcb);

        MsSetFileObject( FileObject, Vcb, NULL );

        //
        // Set the return status.
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;
    }


    DebugTrace(-1, Dbg, "MsOpenMailslotFileSystem -> Iosb.Status = %08lx\n", iosb.Status);

    //
    // Return to the caller.
    //

    return iosb;
}


IO_STATUS_BLOCK
MsOpenMailslotRootDirectory(
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    )

{
    IO_STATUS_BLOCK iosb = {0};
    PROOT_DCB_CCB ccb;

    PAGED_CODE();
    DebugTrace( +1,
                Dbg,
                "MsOpenMailslotRootDirectory, RootDcb = %08lx\n",
                (ULONG)RootDcb);

    try {

        //
        // Create a root DCB CCB
        //
        ccb = MsCreateRootDcbCcb (RootDcb, RootDcb->Vcb);

        if (ccb == NULL) {

            iosb.Status = STATUS_INSUFFICIENT_RESOURCES;
            try_return( NOTHING );

        }
        //
        // Set the new share access.
        //
        ASSERT (MsIsAcquiredExclusiveVcb(RootDcb->Vcb));
        if (!NT_SUCCESS(iosb.Status = IoCheckShareAccess(
                                          DesiredAccess,
                                          ShareAccess,
                                          FileObject,
                                          &RootDcb->ShareAccess,
                                          TRUE ))) {

            DebugTrace(0, Dbg, "bad share access\n", 0);

            //
            // Drop ccb
            //
            MsDereferenceCcb ((PCCB) ccb);

            try_return( NOTHING );
        }


        MsSetFileObject( FileObject, RootDcb, ccb );

        //
        // Set the return status.
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        DebugTrace(-1, Dbg, "MsOpenMailslotRootDirectory -> iosb.Status = %08lx\n", iosb.Status);
    }

    //
    // Return to the caller.
    //

    return iosb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\debug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements the debugging function for the mailslot file
    system.

Author:

    Manny Weiser (mannyw)    17-Jan-1991

Revision History:

--*/

#include "mailslot.h"
#include "stdio.h"


#ifdef MSDBG

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, _DebugTrace )
#endif

VOID
_DebugTrace(
    LONG Indent,
    ULONG Level,
    PSZ X,
    ULONG Y
    )

/*++

Routine Description:

    This routine display debugging information.

Arguments:

    Level - The debug level required to display this message.  If
        level is 0 the message is displayed regardless of the setting
        or the debug level

    Indent - Incremement or the current debug message indent

    X - 1st print parameter

    Y - 2nd print parameter

Return Value:

    None.

--*/

{
    LONG i;
    char printMask[100];

    PAGED_CODE();
    if ((Level == 0) || (MsDebugTraceLevel & Level)) {

        if (Indent < 0) {
            MsDebugTraceIndent += Indent;
        }

        if (MsDebugTraceIndent < 0) {
            MsDebugTraceIndent = 0;
        }

        sprintf( printMask, "%%08lx:%%.*s%s", X );

        i = (LONG)PsGetCurrentThread();
        DbgPrint( printMask, i, MsDebugTraceIndent, "", Y );
        if (Indent > 0) {
            MsDebugTraceIndent += Indent;
        }
    }
}
#endif // MSDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\dir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements the file directory routines for the mailslot
    file system by the dispatch driver.

Author:

    Manny Weiser (mannyw)     1-Feb-1991

Revision History:

--*/

#include "mailslot.h"

//
// Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIR)

NTSTATUS
MsCommonDirectoryControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsQueryDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    );

NTSTATUS
MsNotifyChangeDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonDirectoryControl )
#pragma alloc_text( PAGE, MsFsdDirectoryControl )
#pragma alloc_text( PAGE, MsQueryDirectory )
#endif

NTSTATUS
MsFsdDirectoryControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the FSD routine that handles directory control
    functions (i.e., query and notify).

Arguments:

    MsfsDeviceObject - Supplies the device object for the directory function.

    Irp - Supplies the IRP to process.

Return Value:

    NTSTATUS - The result status.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdDirectoryControl\n", 0);

    //
    // Call the common direcotry control routine.
    //
    FsRtlEnterFileSystem();

    status = MsCommonDirectoryControl( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();
    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdDirectoryControl -> %08lx\n", status );

    return status;
}

VOID
MsFlushNotifyForFile (
    IN PDCB Dcb,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine checks the notify queues of a DCB and completes any
    outstanding IRPS that match the given file object. This is used at cleanup time.


Arguments:

    Dcb - Supplies the DCB to check for outstanding notify IRPs.

    FileObject - File object that IRP must be associated with.

Return Value:

    None.

--*/
{
    PLIST_ENTRY Links;
    PIRP Irp;
    KIRQL OldIrql;
    PLIST_ENTRY Head;
    PIO_STACK_LOCATION IrpSp;
    LIST_ENTRY CompletionList;

    Head = &Dcb->Specific.Dcb.NotifyFullQueue;

    InitializeListHead (&CompletionList);

    KeAcquireSpinLock (&Dcb->Specific.Dcb.SpinLock, &OldIrql);

    Links = Head->Flink;
    while (1) {

        if (Links == Head) {
            //
            // We are at the end of this queue.
            //
            if (Head == &Dcb->Specific.Dcb.NotifyFullQueue) {
                Head = &Dcb->Specific.Dcb.NotifyPartialQueue;
                Links = Head->Flink;
                if (Links == Head) {
                   break;
                }
            } else {
               break;
            }
        }

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        // If this IRP is for the matching file object then remove and save for completion
        //
        if (IrpSp->FileObject == FileObject) {

            Links = Links->Flink;

            RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
            //
            // Remove cancel routine and detect if its already started running
            //
            if (IoSetCancelRoutine (Irp, NULL)) {
                //
                // Cancel isn't active and won't become active.
                //
                InsertTailList (&CompletionList, &Irp->Tail.Overlay.ListEntry);


            } else {
                //
                // Cancel is already active but is stalled before lock acquire. Initialize the
                // list head so the second remove is a noop. This is a rare case.
                //
                InitializeListHead (&Irp->Tail.Overlay.ListEntry);
            }
        } else {
            Links = Links->Flink;
        }

    }
    KeReleaseSpinLock (&Dcb->Specific.Dcb.SpinLock, OldIrql);

    while (!IsListEmpty (&CompletionList)) {

        Links = RemoveHeadList (&CompletionList);
        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );
        MsCompleteRequest( Irp, STATUS_CANCELLED );

    }

    return;
}


VOID
MsCheckForNotify (
    IN PDCB Dcb,
    IN BOOLEAN CheckAllOutstandingIrps,
    IN NTSTATUS FinalStatus
    )

/*++

Routine Description:

    This routine checks the notify queues of a DCB and completes any
    outstanding IRPS.

    Note that the caller of this procedure must guarantee that the DCB
    is acquired for exclusive access.

Arguments:

    Dcb - Supplies the DCB to check for outstanding notify IRPs.

    CheckAllOutstandingIrps - Indicates if only the NotifyFullQueue should be
        checked.  If TRUE then all notify queues are checked, and if FALSE
        then only the NotifyFullQueue is checked.

Return Value:

    None.

--*/

{
    PLIST_ENTRY links;
    PIRP irp;
    KIRQL OldIrql;
    PLIST_ENTRY Head;

    //
    // We'll always signal the notify full queue entries.  They want
    // to be notified if every any change is made to a directory.
    //

    Head = &Dcb->Specific.Dcb.NotifyFullQueue;

    KeAcquireSpinLock (&Dcb->Specific.Dcb.SpinLock, &OldIrql);

    while (1) {

        links = RemoveHeadList (Head);
        if (links == Head) {
            //
            // This queue is empty. See if we need to skip to another.
            //
            if (Head == &Dcb->Specific.Dcb.NotifyFullQueue && CheckAllOutstandingIrps) {
                Head = &Dcb->Specific.Dcb.NotifyPartialQueue;
                links = RemoveHeadList (Head);
                if (links == Head) {
                   break;
                }
            } else {
               break;
            }
        }
        //
        // Remove the Irp from the head of the queue, and complete it
        // with a success status.
        //

        irp = CONTAINING_RECORD( links, IRP, Tail.Overlay.ListEntry );

        //
        // Remove cancel routine and detect if its already started running
        //
        if (IoSetCancelRoutine (irp, NULL)) {
            //
            // Cancel isn't active and won't become active. Release the spinlock for the complete.
            //
            KeReleaseSpinLock (&Dcb->Specific.Dcb.SpinLock, OldIrql);

            MsCompleteRequest( irp, FinalStatus );

            KeAcquireSpinLock (&Dcb->Specific.Dcb.SpinLock, &OldIrql);
        } else {
            //
            // Cancel is already active but is stalled before lock acquire. Initialize the
            // list head so the second remove is a noop. This is a rare case.
            //
            InitializeListHead (&irp->Tail.Overlay.ListEntry);
        }
    }
    KeReleaseSpinLock (&Dcb->Specific.Dcb.SpinLock, OldIrql);

    return;
}


NTSTATUS
MsCommonDirectoryControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the common code for directory control functions.

Arguments:

    MsfsDeviceObject - Supplies the mailslot device object.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PROOT_DCB_CCB ccb;
    PROOT_DCB rootDcb;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "CommonDirectoryControl...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", (ULONG)Irp);

    //
    // Decode the file object to figure out who we are.  If the result
    // is not the root DCB then its an illegal parameter.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&rootDcb,
                                            (PVOID *)&ccb )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonDirectoryControl -> %08lx\n", status );
        return status;
    }

    if (nodeTypeCode != MSFS_NTC_ROOT_DCB) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);
        MsDereferenceNode( &rootDcb->Header );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "CommonDirectoryControl -> %08lx\n", status );
        return status;
    }

    //
    // Acquire exclusive access to the root DCB.
    //

    MsAcquireExclusiveFcb( (PFCB)rootDcb );

    //
    // Check if its been cleaned up yet.
    //
    status = MsVerifyDcbCcb (ccb);

    if (NT_SUCCESS (status)) {
        //
        // We know this is a directory control so we'll case on the
        // minor function, and call the appropriate work routines.
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DIRECTORY:

            status = MsQueryDirectory( rootDcb, ccb, Irp );
            break;

        case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

            status = MsNotifyChangeDirectory( rootDcb, ccb, Irp );
            break;

        default:

            //
            // For all other minor function codes we say they're invalid
            // and complete the request.
            //

            DebugTrace(0, DEBUG_TRACE_ERROR, "Invalid FS Control Minor Function Code %08lx\n", irpSp->MinorFunction);

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }


    MsReleaseFcb( (PFCB)rootDcb );

    MsDereferenceRootDcb( rootDcb );

    if (status != STATUS_PENDING) {
        MsCompleteRequest( Irp, status );
    }

    return status;
}


NTSTATUS
MsQueryDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the work routine for querying a directory.

Arugments:

    RootDcb - Supplies the dcb being queried

    Ccb - Supplies the context of the caller

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PUCHAR buffer;
    CLONG systemBufferLength;
    UNICODE_STRING fileName;
    ULONG fileIndex;
    FILE_INFORMATION_CLASS fileInformationClass;
    BOOLEAN restartScan;
    BOOLEAN returnSingleEntry;
    BOOLEAN indexSpecified;

#if 0
    UNICODE_STRING unicodeString;
    ULONG unicodeStringLength;
#endif
    BOOLEAN ansiStringAllocated = FALSE;

    static WCHAR star = L'*';

    BOOLEAN caseInsensitive = TRUE; //*** Make searches case insensitive

    ULONG currentIndex;

    ULONG lastEntry;
    ULONG nextEntry;

    PLIST_ENTRY links;
    PFCB fcb;

    PFILE_DIRECTORY_INFORMATION dirInfo;
    PFILE_NAMES_INFORMATION namesInfo;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsQueryDirectory\n", 0 );
    DebugTrace( 0, Dbg, "RootDcb              = %08lx\n", (ULONG)RootDcb);
    DebugTrace( 0, Dbg, "Ccb                  = %08lx\n", (ULONG)Ccb);
    DebugTrace( 0, Dbg, "SystemBuffer         = %08lx\n", (ULONG)Irp->AssociatedIrp.SystemBuffer);
    DebugTrace( 0, Dbg, "Length               = %08lx\n", irpSp->Parameters.QueryDirectory.Length);
    DebugTrace( 0, Dbg, "FileName             = %08lx\n", (ULONG)irpSp->Parameters.QueryDirectory.FileName);
    DebugTrace( 0, Dbg, "FileIndex            = %08lx\n", irpSp->Parameters.QueryDirectory.FileIndex);
    DebugTrace( 0, Dbg, "FileInformationClass = %08lx\n", irpSp->Parameters.QueryDirectory.FileInformationClass);
    DebugTrace( 0, Dbg, "RestartScan          = %08lx\n", FlagOn(irpSp->Flags, SL_RESTART_SCAN));
    DebugTrace( 0, Dbg, "ReturnSingleEntry    = %08lx\n", FlagOn(irpSp->Flags, SL_RETURN_SINGLE_ENTRY));
    DebugTrace( 0, Dbg, "IndexSpecified       = %08lx\n", FlagOn(irpSp->Flags, SL_INDEX_SPECIFIED));

    //
    // Make local copies of the input parameters.
    //

    systemBufferLength = irpSp->Parameters.QueryDirectory.Length;

    fileIndex = irpSp->Parameters.QueryDirectory.FileIndex;
    fileInformationClass =
            irpSp->Parameters.QueryDirectory.FileInformationClass;

    restartScan = FlagOn(irpSp->Flags, SL_RESTART_SCAN);
    indexSpecified = FlagOn(irpSp->Flags, SL_INDEX_SPECIFIED);
    returnSingleEntry = FlagOn(irpSp->Flags, SL_RETURN_SINGLE_ENTRY);

    if (irpSp->Parameters.QueryDirectory.FileName != NULL) {

        fileName = *(PUNICODE_STRING)irpSp->Parameters.QueryDirectory.FileName;

        //
        // Ensure that the name is reasonable
        //
        if( (fileName.Buffer == NULL && fileName.Length) ||
            FlagOn( fileName.Length, 1 ) ) {

            status = STATUS_OBJECT_NAME_INVALID;
            return status;
        }

    } else {

        fileName.Length = 0;
        fileName.Buffer = NULL;

    }

    //
    // Check if the CCB already has a query template attached.  If it
    // does not already have one then we either use the string we are
    // given or we attach our own containing "*"
    //

    if (Ccb->QueryTemplate == NULL) {

        //
        // This is our first time calling query directory so we need
        // to either set the query template to the user specified string
        // or to "*".
        //

        if (fileName.Buffer == NULL) {

            DebugTrace(0, Dbg, "Set template to *\n", 0);

            fileName.Length = sizeof( WCHAR );
            fileName.Buffer = &star;
        }

        DebugTrace(0, Dbg, "Set query template -> %wZ\n", (ULONG)&fileName);

        //
        // Allocate space for the query template.
        //

        Ccb->QueryTemplate = MsAllocatePagedPoolWithQuota ( sizeof(UNICODE_STRING) + fileName.Length,
                                                            'tFsM' );

        if (Ccb->QueryTemplate == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            return status;
        }

        //
        // Initialize the query template and copy over the string.
        //

        Ccb->QueryTemplate->Length = fileName.Length;
        Ccb->QueryTemplate->Buffer = (PWCH)((PSZ)Ccb->QueryTemplate + sizeof(UNICODE_STRING));

        RtlCopyMemory (Ccb->QueryTemplate->Buffer,
                       fileName.Buffer,
                       fileName.Length);


        //
        // Set the search to start at the beginning of the directory.
        //

        fileIndex = 0;

    } else {

        //
        // Check if we were given an index to start with or if we need to
        // restart the scan or if we should use the index that was saved in
        // the CCB.
        //

        if (restartScan) {

            fileIndex = 0;

        } else if (!indexSpecified) {

            fileIndex = Ccb->IndexOfLastCcbReturned + 1;
        }

    }


    //
    //  Now we are committed to completing the Irp, we do that in
    //  the finally clause of the following try.
    //

    try {

        ULONG baseLength;
        ULONG lengthAdded;
        BOOLEAN Match;

        //
        // Map the user buffer.
        //

        MsMapUserBuffer( Irp, KernelMode, (PVOID *)&buffer );

        //
        //  At this point we are about to enter our query loop.  We have
        //  already decided which Fcb index we need to return.  The variables
        //  LastEntry and NextEntry are used to index into the user buffer.
        //  LastEntry is the last entry we added to the user buffer, and
        //  NextEntry is the current one we're working on.  CurrentIndex
        //  is the Fcb index that we are looking at next.  Logically the
        //  way the loop works is as follows.
        //
        //  Scan all of the Fcb in the directory
        //
        //      if the Fcb matches the query template then
        //
        //          if the CurrentIndex is >= the FileIndex then
        //
        //              process this fcb, and decide if we should
        //              continue the main loop
        //
        //          end if
        //
        //          Increment the current index
        //
        //      end if
        //
        //  end scan
        //

        currentIndex = 0;

        lastEntry = 0;
        nextEntry =0;

        switch (fileInformationClass) {

        case FileDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                       FileName[0] );
            break;

        case FileFullDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                       FileName[0] );
            break;

        case FileNamesInformation:

            baseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                       FileName[0] );
            break;

        case FileBothDirectoryInformation:

            baseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                       FileName[0] );
            break;

        default:

            try_return( status = STATUS_INVALID_INFO_CLASS );
        }

        for (links = RootDcb->Specific.Dcb.ParentDcbQueue.Flink;
             links != &RootDcb->Specific.Dcb.ParentDcbQueue;
             links = links->Flink) {

            fcb = CONTAINING_RECORD(links, FCB, ParentDcbLinks);

            ASSERT(fcb->Header.NodeTypeCode == MSFS_NTC_FCB);

            DebugTrace(0, Dbg, "Top of Loop\n", 0);
            DebugTrace(0, Dbg, "Fcb          = %08lx\n", (ULONG)fcb);
            DebugTrace(0, Dbg, "CurrentIndex = %08lx\n", currentIndex);
            DebugTrace(0, Dbg, "FileIndex    = %08lx\n", fileIndex);
            DebugTrace(0, Dbg, "LastEntry    = %08lx\n", lastEntry);
            DebugTrace(0, Dbg, "NextEntry    = %08lx\n", nextEntry);

            //
            // Check if the Fcb represents a mailslot that is part of
            // our query template.
            //
            try {
                Match = FsRtlIsNameInExpression( Ccb->QueryTemplate,
                                                 &fcb->LastFileName,
                                                 caseInsensitive,
                                                 NULL );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                try_return (status = GetExceptionCode ());
            }

            if (Match) {

                //
                // The FCB is in the query template so now check if
                // this is the index we should start returning.
                //

                if (currentIndex >= fileIndex) {

                    //
                    // Yes it is one to return so case on the requested
                    // information class.
                    //

                    ULONG bytesToCopy;
                    ULONG bytesRemainingInBuffer;

                    //
                    //  Here are the rules concerning filling up the buffer:
                    //
                    //  1.  The Io system garentees that there will always be
                    //      enough room for at least one base record.
                    //
                    //  2.  If the full first record (including file name) cannot
                    //      fit, as much of the name as possible is copied and
                    //      STATUS_BUFFER_OVERFLOW is returned.
                    //
                    //  3.  If a subsequent record cannot completely fit into the
                    //      buffer, none of it (as in 0 bytes) is copied, and
                    //      STATUS_SUCCESS is returned.  A subsequent query will
                    //      pick up with this record.
                    //

                    bytesRemainingInBuffer = systemBufferLength - nextEntry;

                    if ( (nextEntry != 0) &&
                         ( (baseLength + fcb->LastFileName.Length >
                            bytesRemainingInBuffer) ||
                           (systemBufferLength < nextEntry) ) ) {

                        DebugTrace(0, Dbg, "Next entry won't fit\n", 0);

                        try_return( status = STATUS_SUCCESS );
                    }

                    ASSERT( bytesRemainingInBuffer >= baseLength );

                    //
                    //  See how much of the name we will be able to copy into
                    //  the system buffer.  This also dictates out return
                    //  value.
                    //

                    if ( baseLength + fcb->LastFileName.Length <=
                         bytesRemainingInBuffer ) {

                        bytesToCopy = fcb->LastFileName.Length;
                        status = STATUS_SUCCESS;

                    } else {

                        bytesToCopy = bytesRemainingInBuffer - baseLength;
                        status = STATUS_BUFFER_OVERFLOW;
                    }

                    //
                    //  Note how much of buffer we are consuming and zero
                    //  the base part of the structure.
                    //

                    lengthAdded = baseLength + bytesToCopy;

                    try {

                        RtlZeroMemory( &buffer[nextEntry], baseLength );


                        switch (fileInformationClass) {

                        case FileBothDirectoryInformation:

                            //
                            //  We don't need short name
                            //

                            DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                        case FileFullDirectoryInformation:

                            //
                            //  We don't use EaLength, so fill in nothing here.
                            //

                            DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                        case FileDirectoryInformation:

                            DebugTrace(0, Dbg, "Getting directory information\n", 0);

                            //
                            //  The eof indicates the number of instances and
                            //  allocation size is the maximum allowed
                            //

                            dirInfo = (PFILE_DIRECTORY_INFORMATION)&buffer[nextEntry];

                            dirInfo->FileAttributes = FILE_ATTRIBUTE_NORMAL;

                            dirInfo->CreationTime = fcb->Specific.Fcb.CreationTime;
                            dirInfo->LastAccessTime = fcb->Specific.Fcb.LastAccessTime;
                            dirInfo->LastWriteTime = fcb->Specific.Fcb.LastModificationTime;
                            dirInfo->ChangeTime = fcb->Specific.Fcb.LastChangeTime;

                            dirInfo->FileNameLength = fcb->LastFileName.Length;

                            break;

                        case FileNamesInformation:

                            DebugTrace(0, Dbg, "Getting names information\n", 0);


                            namesInfo = (PFILE_NAMES_INFORMATION)&buffer[nextEntry];

                            namesInfo->FileNameLength = fcb->LastFileName.Length;

                            break;

                        default:

                            KeBugCheck( MAILSLOT_FILE_SYSTEM );
                        }

                        RtlCopyMemory (&buffer[nextEntry + baseLength],
                                       fcb->LastFileName.Buffer,
                                       bytesToCopy);

                        //
                        //  Update the CCB to the index we've just used.
                        //

                        Ccb->IndexOfLastCcbReturned = currentIndex;

                        //
                        //  And indicate how much of the system buffer we have
                        //  currently used up.  We must compute this value before
                        //  we long align outselves for the next entry.
                        //

                        Irp->IoStatus.Information = nextEntry + lengthAdded;

                        //
                        //  Setup the previous next entry offset.
                        //

                        *((PULONG)(&buffer[lastEntry])) = nextEntry - lastEntry;

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        status = GetExceptionCode();
                        try_return( status );
                    }

                    //
                    //  Check if the last entry didn't completely fit
                    //

                    if ( status == STATUS_BUFFER_OVERFLOW ) {

                        try_return( NOTHING );
                    }

                    //
                    //  Check if we are only to return a single entry
                    //

                    if (returnSingleEntry) {

                        try_return( status = STATUS_SUCCESS );
                    }

                    //
                    //  Set ourselves up for the next iteration
                    //

                    lastEntry = nextEntry;
                    nextEntry += (ULONG)QuadAlign( lengthAdded );
                }

                //
                //  Increment the current index by one
                //

                currentIndex += 1;
            }
        }

        //
        // At this point we've scanned the entire list of FCBs so if
        // the NextEntry is zero then we haven't found anything so we
        // will return no more files, otherwise we return success.
        //

        if (nextEntry == 0) {
            status = STATUS_NO_MORE_FILES;
        } else {
            status = STATUS_SUCCESS;
        }

    try_exit: NOTHING;
    } finally {

        DebugTrace(-1, Dbg, "MsQueryDirectory -> %08lx\n", status);
    }

    return status;
}

VOID
MsNotifyChangeDirectoryCancel (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the cancel routine for the directory notify request.

Arugments:

    DeviceObject - Supplies the device object for the request being canceled.

    Irp - Supplies the Irp being canceled.

Return Value:

    None
--*/

{
    KIRQL OldIrql;
    PKSPIN_LOCK pSpinLock;

    //
    // First drop the cancel spinlock. We don't use this for this path
    //
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    //
    // Grab the spinlock address. Easier that tracing the pointers or assuming that there is
    // only one DCB
    //
    pSpinLock = Irp->Tail.Overlay.DriverContext[0];
    //
    // Acquire the spinlock protecting these queues.
    //
    KeAcquireSpinLock (pSpinLock, &OldIrql);

    //
    // Remove the entry from the list. We will always be in one of the lists or this entry has
    // been initializes as an empty list by one of the completion routines when it detected
    // this routine was active.
    //
    RemoveEntryList (&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock (pSpinLock, OldIrql);

    //
    // Complete the IRP
    //
    MsCompleteRequest( Irp, STATUS_CANCELLED );

    return;
}


NTSTATUS
MsNotifyChangeDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing the notify change directory.

Arugments:

    RootDcb - Supplies the DCB being queried.

    Ccb - Supplies the context of the caller.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - STATUS_PENDING or STATUS_CANCELLED

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS  Status;
    KIRQL OldIrql;
    PLIST_ENTRY Head;

    //
    // Get the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsNotifyChangeDirectory\n", 0 );
    DebugTrace( 0, Dbg, "RootDcb = %p", RootDcb);
    DebugTrace( 0, Dbg, "Ccb     = %p", Ccb);

    //
    //  Mark the Irp pending.
    //

    if (irpSp->Parameters.NotifyDirectory.CompletionFilter & (~FILE_NOTIFY_CHANGE_NAME)) {
        Head = &RootDcb->Specific.Dcb.NotifyFullQueue;
    } else {
        Head = &RootDcb->Specific.Dcb.NotifyPartialQueue;
    }
    //
    // Make it easy for the cancel routine to find this spinlock
    //
    Irp->Tail.Overlay.DriverContext[0] = &RootDcb->Specific.Dcb.SpinLock;
    //
    // Acquire the spinlock protecting these queues.
    //
    KeAcquireSpinLock (&RootDcb->Specific.Dcb.SpinLock, &OldIrql);
    IoSetCancelRoutine (Irp, MsNotifyChangeDirectoryCancel);
    //
    // See if the IRP was already canceled before we enabled cancelation
    //
    if (Irp->Cancel &&
        IoSetCancelRoutine (Irp, NULL) != NULL) {

       KeReleaseSpinLock (&RootDcb->Specific.Dcb.SpinLock, OldIrql);
       Status = STATUS_CANCELLED;

    } else {

       IoMarkIrpPending( Irp );
       InsertTailList( Head,
                       &Irp->Tail.Overlay.ListEntry );
       KeReleaseSpinLock (&RootDcb->Specific.Dcb.SpinLock, OldIrql);
       Status = STATUS_PENDING;

    }

    //
    // Return to our caller.
    //

    DebugTrace(-1, Dbg, "NotifyChangeDirectory status %X\n", Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\dpc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dpc.c

Abstract:

    This modules contains the set of functions in the mailslot file
    system that are callable at DPC level.

Author:

    Manny Weiser (mannyw)    28-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DPC)

#if 0
NOT PAGEABLE -- MsReadTimeoutHandler
#endif

VOID
MsReadTimeoutHandler (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is handles read timeouts.  It is called as a DPC whenever
    a read timer expires.
    *** Non-Pageable ***

Arguments:

    Dpc - A pointer to the DPC object.

    DeferredContext - A pointer to the data queue entry associated with
                      this timer.

    SystemArgument1, SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PWORK_CONTEXT workContext;

    Dpc, SystemArgument1, SystemArgument2; // prevent warnings

    //
    // Enqueue this packet to an ex worker thread.
    //

    workContext = DeferredContext;

    IoQueueWorkItem (workContext->WorkItem, MsTimeoutRead, CriticalWorkQueue, workContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\deviosup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    deviosup.c

Abstract:

    This module implements the memory locking routines for MSFS.

Author:

    Manny Weiser (mannyw)   05-Apr-1991

Revision History:

--*/

#include "mailslot.h"

//
// Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsMapUserBuffer )
#endif

VOID
MsMapUserBuffer (
    IN OUT PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *UserBuffer
    )

/*++

Routine Description:

    This routine obtains a usable virtual address for the user buffer
    for the current I/O request in the specified mode.

Arguments:

    Irp - Pointer to the Irp for the request.

    AccessMode - UserMode or KernelMode.

    UserBuffer - Returns pointer to mapped user buffer.

Return Value:

    None.

--*/

{
    AccessMode;
    PAGED_CODE();

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        *UserBuffer = Irp->UserBuffer;
        return;
    }

    //
    // Get a system virtual address for the buffer.
    //

    *UserBuffer = MmGetSystemAddressForMdl( Irp->MdlAddress );
    return;

} // MsMapUserBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\except.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    except.c

Abstract:

    This module declares the exception handling function used by the
    mailslot file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#include "mailslot.h"

#define Dbg             DEBUG_TRACE_CATCH_EXCEPTIONS
#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsExceptionFilter )
#pragma alloc_text( PAGE, MsProcessException )
#endif

LONG
MsExceptionFilter (
    IN NTSTATUS ExceptionCode
    )
{
    PAGED_CODE();
    DebugTrace(0, Dbg, "MsExceptionFilter %08lx\n", ExceptionCode);
    DebugDump("", Dbg, NULL );

    if (FsRtlIsNtstatusExpected( ExceptionCode )) {

        return EXCEPTION_EXECUTE_HANDLER;

    } else {

        return EXCEPTION_CONTINUE_SEARCH;
    }
}

NTSTATUS
MsProcessException (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )
{
    NTSTATUS FinalExceptionCode;

    PAGED_CODE();
    FinalExceptionCode = ExceptionCode;

    if (FsRtlIsNtstatusExpected( ExceptionCode )) {

        MsCompleteRequest( Irp, ExceptionCode );

    } else {

        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    return FinalExceptionCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\dumpsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dumpsup.c

Abstract:

    This module implements a collection of data structure dump routines
    for debugging the mailslot file system

Author:

    Manny Weiser (mannyw)    9-Jan-1991

Revision History:

--*/

#include "mailslot.h"

#ifdef MSDBG

VOID MsDumpDataQueue(IN ULONG Level, IN PDATA_QUEUE Ptr);
VOID MsDumpDataEntry(IN PDATA_ENTRY Ptr);

VOID MsDump(IN PVOID Ptr);
VOID MsDumpVcb(IN PVCB Ptr);
VOID MsDumpRootDcb(IN PROOT_DCB Ptr);
VOID MsDumpFcb(IN PFCB Ptr);
VOID MsDumpCcb(IN PCCB Ptr);
VOID MsDumpRootDcbCcb(IN PROOT_DCB_CCB Ptr);

ULONG MsDumpCurrentColumn;

#define DumpNewLine() { \
    DbgPrint("\n"); \
    MsDumpCurrentColumn = 1; \
}

#define DumpLabel(Label,Width) { \
    ULONG i; \
    CHAR _Str[20]; \
    for(i=0;i<2;i++) { _Str[i] = ' ';} \
    strncpy(&_Str[2],#Label,Width); \
    for(i=strlen(_Str);i<Width;i++) {_Str[i] = ' ';} \
    _Str[Width] = '\0'; \
    DbgPrint("%s", _Str); \
}

#define DumpField(Field) { \
    if ((MsDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    MsDumpCurrentColumn += 18 + 9 + 9; \
    DumpLabel(Field,18); \
    DbgPrint(":%8lx", Ptr->Field); \
    DbgPrint("         "); \
}

#define DumpHeader(Header) { \
    DumpField(Header.NodeTypeCode);   \
    DumpField(Header.NodeByteSize);   \
    DumpField(Header.NodeState);      \
    DumpField(Header.ReferenceCount); \
}

#define DumpListEntry(Links) { \
    if ((MsDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    MsDumpCurrentColumn += 18 + 9 + 9; \
    DumpLabel(Links,18); \
    DbgPrint(":%8lx", Ptr->Links.Flink); \
    DbgPrint(":%8lx", Ptr->Links.Blink); \
}

#define DumpName(Field,Width) { \
    ULONG i; \
    CHAR _String[256]; \
    if ((MsDumpCurrentColumn + 18 + Width) > 80) {DumpNewLine();} \
    MsDumpCurrentColumn += 18 + Width; \
    DumpLabel(Field,18); \
    for(i=0;i<Width;i++) {_String[i] = Ptr->Field[i];} \
    _String[Width] = '\0'; \
    DbgPrint("%s", _String); \
}

#define TestForNull(Name) { \
    if (Ptr == NULL) { \
        DbgPrint("%s - Cannot dump a NULL pointer\n", Name); \
        return; \
    } \
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsDump )
#pragma alloc_text( PAGE, MsDumpCcb )
#pragma alloc_text( PAGE, MsDumpDataEntry )
#pragma alloc_text( PAGE, MsDumpDataQueue )
#pragma alloc_text( PAGE, MsDumpFcb )
#pragma alloc_text( PAGE, MsDumpRootDcb )
#pragma alloc_text( PAGE, MsDumpRootDcbCcb )
#pragma alloc_text( PAGE, MsDumpVcb )
#endif


VOID MsDumpDataQueue (
    IN ULONG Level,
    IN PDATA_QUEUE Ptr
    )

{
    PLIST_ENTRY listEntry;
    PDATA_ENTRY dataEntry;

    PAGED_CODE();
    if ((Level != 0) && !(MsDebugTraceLevel & Level)) {
        return;
    }

    TestForNull   ("MsDumpDataQueue");

    DumpNewLine   ();
    DbgPrint       ("DataQueue@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (QueueState);
    DumpField     (BytesInQueue);
    DumpField     (EntriesInQueue);
    DumpField     (Quota);
    DumpField     (QuotaUsed);
    DumpField     (MaximumMessageSize);
    DumpField     (DataEntryList.Flink);
    DumpField     (DataEntryList.Blink);
    DumpNewLine   ();

    for (listEntry = Ptr->DataEntryList.Flink;
         listEntry != &Ptr->DataEntryList;
         listEntry = listEntry->Flink) {

        dataEntry = CONTAINING_RECORD(listEntry, DATA_ENTRY, ListEntry);
        MsDumpDataEntry( dataEntry );
    }

    return;
}


VOID MsDumpDataEntry (
    IN PDATA_ENTRY Ptr
    )

{
    PAGED_CODE();
    TestForNull   ("MsDumpDataEntry");

    DumpNewLine   ();
    DbgPrint       ("DataEntry@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (From);
    DumpField     (Irp);
    DumpField     (DataSize);
    DumpField     (DataPointer);
    DumpField     (TimeoutWorkContext);
    DumpNewLine   ();

    return;
}


VOID MsDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    PAGED_CODE();
    TestForNull("MsDump");

    //
    //  We'll switch on the node type code
    //

    switch (NodeType(Ptr)) {

    case MSFS_NTC_VCB:               MsDumpVcb(Ptr);             break;
    case MSFS_NTC_ROOT_DCB:          MsDumpRootDcb(Ptr);         break;
    case MSFS_NTC_FCB:               MsDumpFcb(Ptr);             break;
    case MSFS_NTC_CCB:               MsDumpCcb(Ptr);             break;
    case MSFS_NTC_ROOT_DCB_CCB:      MsDumpRootDcbCcb(Ptr);      break;

    default :
        DbgPrint("MsDump - Unknown Node type code %8lx\n", *((PNODE_TYPE_CODE)(Ptr)));
        break;
    }

    return;
}


VOID MsDumpVcb (
    IN PVCB Ptr
    )

/*++

Routine Description:

    Dump an Vcb structure

Arguments:

    Ptr - Supplies the Device record to be dumped

Return Value:

    None

--*/

{
    PAGED_CODE();
    TestForNull   ("MsDumpVcb");

    DumpNewLine   ();
    DbgPrint       ("Vcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpField     (RootDcb);
    DumpNewLine   ();

    MsDump        (Ptr->RootDcb);

    return;
}


VOID MsDumpRootDcb (
    IN PROOT_DCB Ptr
    )

/*++

Routine Description:

    Dump a root dcb structure

Arguments:

    Ptr - Supplies the Root Dcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    PAGED_CODE();
    TestForNull   ("MsDumpRootDcb");

    DumpNewLine   ();
    DbgPrint       ("RootDcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (Vcb);
    DumpField     (FileObject);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer, 32);
    DumpField     (LastFileName.Length);
    DumpField     (LastFileName.Buffer);
    DumpListEntry (Specific.Dcb.NotifyFullQueue);
    DumpListEntry (Specific.Dcb.NotifyPartialQueue);
    DumpListEntry (Specific.Dcb.ParentDcbQueue);
    DumpField     (CreatorProcess);
    DumpNewLine   ();

    for (Links = Ptr->Specific.Dcb.ParentDcbQueue.Flink;
         Links != &Ptr->Specific.Dcb.ParentDcbQueue;
         Links = Links->Flink) {
        MsDump(CONTAINING_RECORD(Links, FCB, ParentDcbLinks));
    }

    return;
}


VOID MsDumpFcb (
    IN PFCB Ptr
    )

/*++

Routine Description:

    Dump an Fcb structure

Arguments:

    Ptr - Supplies the Fcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    PAGED_CODE();
    TestForNull   ("MsDumpFcb");

    DumpNewLine   ();
    DbgPrint       ("Fcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (Vcb);
    DumpField     (FileObject);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer, 32);
    DumpField     (LastFileName.Length);
    DumpField     (LastFileName.Buffer);
    DumpListEntry (Specific.Fcb.CcbQueue);
    DumpField     (CreatorProcess);
    DumpNewLine   ();

    for (Links = Ptr->Specific.Fcb.CcbQueue.Flink;
         Links != &Ptr->Specific.Fcb.CcbQueue;
         Links = Links->Flink) {
        MsDump(CONTAINING_RECORD(Links, CCB, CcbLinks));
    }

    MsDumpDataQueue ( 0, &(Ptr->DataQueue) );

    return;
}


VOID MsDumpCcb (
    IN PCCB Ptr
    )

/*++

Routine Description:

    Dump a Ccb structure

Arguments:

    Ptr - Supplies the Ccb record to be dumped

Return Value:

    None

--*/

{
    PAGED_CODE();
    TestForNull   ("MsDumpCcb");

    DumpNewLine   ();
    DbgPrint       ("Ccb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpField     (Fcb);
    DumpField     (FileObject);
    DumpNewLine   ();

    return;
}


VOID MsDumpRootDcbCcb (
    IN PROOT_DCB_CCB Ptr
    )

/*++

Routine Description:

    Dump a Root Dcb Ccb structure

Arguments:

    Ptr - Supplies the Root Dcb Ccb record to be dumped

Return Value:

    None

--*/

{
    PAGED_CODE();
    TestForNull   ("MsDumpRootDcbCcb");

    DumpNewLine   ();
    DbgPrint       ("RootDcbCcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpHeader    (Header);
    DumpField     (IndexOfLastCcbReturned);
    DumpField     (QueryTemplate);
    DumpNewLine   ();

    return;
}

#endif // MSDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\filobsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    filobsup.c

Abstract:

    This module implements the mailslot file object support routines.

Author:

    Manny Weiser (mannyw)    10-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsDecodeFileObject )
#pragma alloc_text( PAGE, MsSetFileObject )
#endif

VOID
MsSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object.

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    FsContext - Supplies a pointer to either a ccb, fcb, vcb, or root_dcb
        structure.

    FsContext2 - Supplies a pointer to a root_dcb_ccb, or is null.

Return Value:

    None.

--*/

{
    NODE_TYPE_CODE nodeType;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsSetFileObject, FileObject = %08lx\n", (ULONG)FileObject );

    //
    // Set the fscontext fields of the file object.
    //

    FileObject->FsContext  = FsContext;
    FileObject->FsContext2 = FsContext2;

    //
    // Set the mailslot flag in the file object if necessary and return.
    //

    if (FsContext != NULL) {
        nodeType = NodeType(FsContext);

        if (nodeType == MSFS_NTC_CCB || nodeType == MSFS_NTC_FCB) {
            FileObject->Flags |= FO_MAILSLOT;
        }
    }

    DebugTrace(-1, Dbg, "MsSetFileObject -> VOID\n", 0);

    return;
}


NODE_TYPE_CODE
MsDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the mailslot file system and figures out what it really
    is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    FsContext - Receive the file object FsContext pointer

    FsContext2 - Receive the file object FsContext2 pointer


Return Value:

    NODE_TYPE_CODE - Returns the node type code for a Vcb, RootDcb, Ccb,
        or zero.

        Vcb - indicates that file object opens the mailslot driver.

        RootDcb - indicates that the file object is for the root directory.

        Ccb - indicates that the file object is for a mailslot file.

        Zero - indicates that the file object was for a mailslot file
            but has been closed.

--*/

{
    NODE_TYPE_CODE NodeTypeCode = NTC_UNDEFINED;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDecodeFileObject, FileObject = %08lx\n", (ULONG)FileObject);


    //
    // Read the fs FsContext fields of the file object, then reference
    // the block pointed at by the file object
    //

    *FsContext = FileObject->FsContext;
    *FsContext2 = FileObject->FsContext2;

    //
    // Acquire the global lock to protect the node reference counts.
    //

    MsAcquireGlobalLock();

    if ( ((PNODE_HEADER)(*FsContext))->NodeState != NodeStateActive ) {

        //
        // This node is shutting down.  Indicate this to the caller.
        //

        NodeTypeCode = NTC_UNDEFINED;

    } else {

        //
        // The node is active.  Supply a referenced pointer to the node.
        //

        NodeTypeCode = NodeType( *FsContext );
        MsReferenceNode( ((PNODE_HEADER)(*FsContext)) );

    }

    //
    // Release the global lock and return to the caller.
    //

    MsReleaseGlobalLock();

    DebugTrace(0,
               DEBUG_TRACE_REFCOUNT,
               "Referencing block %08lx\n",
               (ULONG)*FsContext);
    DebugTrace(0,
               DEBUG_TRACE_REFCOUNT,
               "    Reference count = %lx\n",
               ((PNODE_HEADER)(*FsContext))->ReferenceCount );

    DebugTrace(-1, Dbg, "MsDecodeFileObject -> %08lx\n", NodeTypeCode);

    return NodeTypeCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\fscontrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fscontrl.c

Abstract:

    This module implements the file file system control routines for MSFS
    called by the dispatch driver.

Author:

    Manny Weiser (mannyw)    25-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCONTROL)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonFsControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsPeek (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonFsControl )
#pragma alloc_text( PAGE, MsFsdFsControl )
#pragma alloc_text( PAGE, MsPeek )
#endif


NTSTATUS
MsFsdFsControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtFsControlFile API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdFsControl\n", 0);

    //
    // Call the common file system control function.
    //

    status = MsCommonFsControl( MsfsDeviceObject, Irp );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdFsControl -> %08lx\n", status );

    return status;
}

NTSTATUS
MsCommonFsControl (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for handling a file system control call.

Arguments:

    MsfsDeviceObject - A pointer to the mailslot file system device object.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonFileSystemControl\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "OutputBufferLength = %08lx\n", irpSp->Parameters.FileSystemControl.OutputBufferLength);
    DebugTrace( 0, Dbg, "InputBufferLength  = %08lx\n", irpSp->Parameters.FileSystemControl.InputBufferLength);
    DebugTrace( 0, Dbg, "FsControlCode      = %08lx\n", irpSp->Parameters.FileSystemControl.FsControlCode);

    //
    // Decide how to handle this IRP.  Call the appropriate worker function.
    //


    switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

    case FSCTL_MAILSLOT_PEEK:

        FsRtlEnterFileSystem();

        status = MsPeek( MsfsDeviceObject, Irp );

        FsRtlExitFileSystem();

        break;

    default:

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

    }


    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCommonFsControl -> %08lx\n", status);
    return status;
}


NTSTATUS
MsPeek (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles a mailslot peek call.

Arguments:

    MsfsDeviceObject - A pointer to the mailslot file system device object.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;

    PFILE_MAILSLOT_PEEK_BUFFER peekParamBuffer;
    ULONG peekParamLength;

    PVOID peekDataBuffer;
    ULONG peekDataLength;

    PDATA_QUEUE dataQueue;
    ULONG MessageLength;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsPeek\n", 0);

    //
    // Make local copies of the input parameters to make things easier.
    //

    peekParamBuffer = irpSp->Parameters.FileSystemControl.Type3InputBuffer;
    peekParamLength = irpSp->Parameters.FileSystemControl.InputBufferLength;

    peekDataBuffer = Irp->UserBuffer;
    peekDataLength = irpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    // Ensure that the supplied buffer is large enough for the peek
    // parameters.
    //

    if (peekParamLength <  sizeof( FILE_MAILSLOT_PEEK_BUFFER ) ) {

        DebugTrace(0, Dbg, "Output buffer is too small\n", 0);

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsPeek -> %08lx\n", status );
        return status;
    }

    //
    // If the requestor mode is user mode we need to probe the buffers.
    // We do not need to have an exception handler here because our top
    // level caller already has one that will complete the Irp with
    // the appropriate status if we access violate.
    //

    if (Irp->RequestorMode != KernelMode) {

        try {

            ProbeForWrite( peekParamBuffer, peekParamLength, sizeof(UCHAR) );
            ProbeForWrite( peekDataBuffer, peekDataLength, sizeof(UCHAR) );
            peekParamBuffer->ReadDataAvailable = 0;
            peekParamBuffer->NumberOfMessages = 0;
            peekParamBuffer->MessageLength = 0;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode ();
            MsCompleteRequest( Irp, status );
            return status;
        }

    }

    //
    // Decode the fil1e object.  If it returns NTC_UNDEFINED, then the
    // node is closing.  Otherwise we obtain a referenced pointer to
    // an FCB.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&fcb,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsPeek -> %08lx\n", status );
        return status;
    }

    //
    // Allow a peek operation only if this is a server side handle to
    // a mailslot file (i.e. the node type is FCB).
    //

    if (nodeTypeCode != MSFS_NTC_FCB) {

        DebugTrace(0, Dbg, "FileObject is not the correct type\n", 0);

        MsDereferenceNode( &fcb->Header );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsPeek -> %08lx\n", status );
        return status;
    }

    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( fcb );


    //
    // Ensure that this FCB still belongs to an active open mailslot.
    //

    status = MsVerifyFcb( fcb );

    if (NT_SUCCESS (status)) {

        //
        // Look for write data in the mailslot.
        //

        dataQueue = &fcb->DataQueue;

        if (!MsIsDataQueueWriters( dataQueue )) {

            //
            // There are no outstanding writes so leave all the zeros in there.
            //


        } else {

            //
            // There is write data for the peek.  Fill in the peek output
            // buffer.
            //


            Irp->IoStatus = MsReadDataQueue(
                                        dataQueue,
                                        Peek,
                                        peekDataBuffer,
                                        peekDataLength,
                                        &MessageLength
                                        );

            status = Irp->IoStatus.Status;

            if (NT_SUCCESS (status)) {
                try {
                    peekParamBuffer->ReadDataAvailable = dataQueue->BytesInQueue;
                    peekParamBuffer->NumberOfMessages = dataQueue->EntriesInQueue;
                    peekParamBuffer->MessageLength = MessageLength;

                } except (EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode ();
                }
            }

        }
    }

    MsReleaseFcb( fcb );

    //
    // Release the reference to the FCB.
    //

    MsDereferenceFcb( fcb );
    //
    // Finish up the fs control IRP.
    //

    MsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "MsPeek -> %08lx\n", status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the get / set file information routines for
    MSFS called by the dispatch driver.

Author:

     Manny Weiser (mannyw)    31-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonQueryInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
MsCommonSetInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

VOID
MsQueryBasicInfo (
    IN PFCB Fcb,
    IN PFILE_BASIC_INFORMATION Buffer
    );

VOID
MsQueryStandardInfo (
    IN PFCB Fcb,
    IN PFILE_STANDARD_INFORMATION Buffer
    );

VOID
MsQueryInternalInfo (
    IN PFCB Fcb,
    IN PFILE_INTERNAL_INFORMATION Buffer
    );

VOID
MsQueryEaInfo (
    IN PFILE_EA_INFORMATION Buffer
    );

NTSTATUS
MsQueryNameInfo (
    IN PFCB Fcb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
MsQueryPositionInfo (
    IN PFCB Fcb,
    IN PFILE_POSITION_INFORMATION Buffer
    );

VOID
MsQueryMailslotInfo (
    IN PFCB Fcb,
    IN PFILE_MAILSLOT_QUERY_INFORMATION Buffer
    );

NTSTATUS
MsSetBasicInfo (
    IN PFCB Fcb,
    IN PFILE_BASIC_INFORMATION Buffer
    );

NTSTATUS
MsSetMailslotInfo (
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_MAILSLOT_SET_INFORMATION Buffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonQueryInformation )
#pragma alloc_text( PAGE, MsCommonSetInformation )
#pragma alloc_text( PAGE, MsFsdQueryInformation )
#pragma alloc_text( PAGE, MsFsdSetInformation )
#pragma alloc_text( PAGE, MsQueryBasicInfo )
#pragma alloc_text( PAGE, MsQueryEaInfo )
#pragma alloc_text( PAGE, MsQueryInternalInfo )
#pragma alloc_text( PAGE, MsQueryMailslotInfo )
#pragma alloc_text( PAGE, MsQueryNameInfo )
#pragma alloc_text( PAGE, MsQueryPositionInfo )
#pragma alloc_text( PAGE, MsQueryStandardInfo )
#pragma alloc_text( PAGE, MsSetBasicInfo )
#pragma alloc_text( PAGE, MsSetMailslotInfo )
#endif


NTSTATUS
MsFsdQueryInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtQueryInformationFile API
    calls.

Arguments:

    MsfsDeviceObject - Supplies a pointer to the device object to use.

    Irp - Supplies a pointer to the Irp to process.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdQueryInformation\n", 0);

    //
    // Call the common query information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonQueryInformation( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdQueryInformation -> %08lx\n", status );

    return status;
}


NTSTATUS
MsFsdSetInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtSetInformationFile API
    calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdSetInformation\n", 0);

    //
    //  Call the common Set Information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonSetInformation( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdSetInformation -> %08lx\n", status );

    return status;
}


NTSTATUS
MsCommonQueryInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying information on a file.

Arguments:

    MsfsDeviceObject - The device object to use.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    FILE_INFORMATION_CLASS fileInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;

    PVOID fsContext, fsContext2;

    PFILE_ALL_INFORMATION AllInfo;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", irpSp->Parameters.QueryFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG)Irp->AssociatedIrp.SystemBuffer);

    //
    // Find out who are.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    // Decide how to handle this request.  A user can query information
    // on a DCB, ROOT_DCB, FCB, or CCB only.
    //

    switch (nodeTypeCode) {

    case MSFS_NTC_FCB:  // This is a server side handle to a mailslot file
    case MSFS_NTC_ROOT_DCB: // This is the MSFS root directory

        fcb = (PFCB)fsContext;
        break;

    default:           // This is an illegal file object to query

        DebugTrace(0, Dbg, "Node type code is not incorrect\n", 0);

        MsDereferenceNode( (PNODE_HEADER)fsContext );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.QueryFile.Length;
    fileInformationClass = irpSp->Parameters.QueryFile.FileInformationClass;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Now acquire shared access to the FCB
    //

    MsAcquireSharedFcb( fcb );

    try {

        //
        // Based on the information class we'll do different actions.  Each
        // of the procedure that we're calling fill up as much of the
        // buffer as possible and return the remaining length, and status
        // This is done so that we can use them to build up the
        // FileAllInformation request.  These procedures do not complete the
        // IRP, instead this procedure must complete the IRP.
        //

        status = STATUS_SUCCESS;

        switch (fileInformationClass) {

        case FileAllInformation:

            AllInfo = buffer;

            MsQueryBasicInfo( fcb, &AllInfo->BasicInformation );
            MsQueryStandardInfo( fcb, &AllInfo->StandardInformation );
            MsQueryInternalInfo( fcb, &AllInfo->InternalInformation );
            MsQueryEaInfo( &AllInfo->EaInformation );
            MsQueryPositionInfo( fcb, &AllInfo->PositionInformation );

            length -= FIELD_OFFSET( FILE_ALL_INFORMATION, NameInformation );

            status = MsQueryNameInfo( fcb, &AllInfo->NameInformation, &length );

            break;

        case FileBasicInformation:

            MsQueryBasicInfo( fcb, buffer );

            length -= sizeof( FILE_BASIC_INFORMATION );
            break;

        case FileStandardInformation:

            MsQueryStandardInfo( fcb, buffer );

            length -= sizeof( FILE_STANDARD_INFORMATION );
            break;

        case FileInternalInformation:

            MsQueryInternalInfo( fcb, buffer );

            length -= sizeof( FILE_INTERNAL_INFORMATION );
            break;

        case FileEaInformation:

            MsQueryEaInfo( buffer );

            length -= sizeof( FILE_EA_INFORMATION );
            break;

        case FilePositionInformation:

            MsQueryPositionInfo( fcb, buffer );

            length -= sizeof( FILE_POSITION_INFORMATION );

            break;

        case FileNameInformation:

            status = MsQueryNameInfo( fcb, buffer, &length );
            break;

        case FileMailslotQueryInformation:

            if( nodeTypeCode == MSFS_NTC_FCB ) {

                MsQueryMailslotInfo( fcb, buffer );
                length -= sizeof( FILE_MAILSLOT_QUERY_INFORMATION );

            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
        }


    } finally {

        MsReleaseFcb( fcb );
        MsDereferenceFcb( fcb );

        //
        // Set the information field to the number of bytes actually
        // filled in and then complete the request.
        //

        Irp->IoStatus.Information =
            irpSp->Parameters.QueryFile.Length - length;

        MsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
    }

    return status;
}


NTSTATUS
MsCommonSetInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for setting information on a mailslot file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    FILE_INFORMATION_CLASS fileInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;

    PAGED_CODE();

    //
    // Get the current Irp stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonSetInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.SetFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", irpSp->Parameters.SetFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG)Irp->AssociatedIrp.SystemBuffer);

    //
    // Get a pointer to the FCB and ensure that this is a server side
    // handler to a mailslot file.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&fcb,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "The mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonSetInformation -> %08lx\n", status );
        return status;
    }

    //
    //  Case on the type of the context, We can only set information
    //  on an FCB.
    //

    if (nodeTypeCode != MSFS_NTC_FCB) {

        MsDereferenceNode( &fcb->Header );
        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.SetFile.Length;
    fileInformationClass = irpSp->Parameters.SetFile.FileInformationClass;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( fcb );

    try {

        //
        // Based on the information class we'll do different actions. Each
        // procedure that we're calling will complete the request.
        //

        switch (fileInformationClass) {

        case FileBasicInformation:

            status = MsSetBasicInfo( fcb, buffer );
            break;

        case FileMailslotSetInformation:

            status = MsSetMailslotInfo( Irp, fcb, buffer );
            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
        }


        //
        // Directory information has changed.  Complete any notify change
        // directory requests.
        //

        MsCheckForNotify( fcb->ParentDcb, FALSE, STATUS_SUCCESS );

    } finally {

        MsReleaseFcb( fcb );
        MsDereferenceFcb( fcb );
        //
        // Complete the request.
        //

        MsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "MsCommonSetInformation -> %08lx\n", status);
    }

    return status;
}


VOID
MsQueryBasicInfo (
    IN PFCB Fcb,
    IN PFILE_BASIC_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query basic information operation.

Arguments:

    Fcb - Supplies a pointer the FCB of mailslot being queried.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryBasicInfo...\n", 0);


    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_BASIC_INFORMATION) );

    //
    // Set the various fields in the record. These times are not maintained for the root DCB0
    //

    if( Fcb->Header.NodeTypeCode == MSFS_NTC_FCB ) {
        Buffer->CreationTime = Fcb->Specific.Fcb.CreationTime;
        Buffer->LastAccessTime = Fcb->Specific.Fcb.LastAccessTime;
        Buffer->LastWriteTime = Fcb->Specific.Fcb.LastModificationTime;
        Buffer->ChangeTime = Fcb->Specific.Fcb.LastChangeTime;
    }

    Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;

    return;
}


VOID
MsQueryStandardInfo (
    IN PFCB Fcb,
    IN PFILE_STANDARD_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query standard information operation.

Arguments:

    Fcb - Supplies the FCB of the mailslot being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

Return Value:

    VOID

--*/

{
    PDATA_QUEUE dataQueue;

    PAGED_CODE();
    DebugTrace(0, Dbg, "MsQueryStandardInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_STANDARD_INFORMATION) );

    //
    // The allocation size is the amount of quota we've charged the mailslot
    // creator.
    //

    if( Fcb->Header.NodeTypeCode == MSFS_NTC_FCB ) {
        dataQueue = &Fcb->DataQueue;
        Buffer->AllocationSize.QuadPart = dataQueue->Quota;

        //
        // The EOF is the number of written bytes ready to be read from the
        // mailslot.
        //

        Buffer->EndOfFile.QuadPart = dataQueue->BytesInQueue;

        Buffer->Directory = FALSE;
    } else {
        Buffer->Directory = TRUE;
    }
    Buffer->NumberOfLinks = 1;
    Buffer->DeletePending = TRUE;

    return;
}


VOID
MsQueryInternalInfo (
    IN PFCB Fcb,
    IN PFILE_INTERNAL_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query internal information operation.

Arguments:

    Fcb - Supplies the FCB of the mailslot being queried.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryInternalInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_INTERNAL_INFORMATION) );

    //
    // Set the internal index number to be the address of the FCB.
    //

    Buffer->IndexNumber.QuadPart = (ULONG_PTR)Fcb;

    return;
}


VOID
MsQueryEaInfo (
    IN PFILE_EA_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query Ea information operation.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

Return Value:

    VOID - The result of this query

--*/

{
    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryEaInfo...\n", 0);

    //
    // Zero out the buffer.
    //

    RtlZeroMemory(Buffer, sizeof(FILE_EA_INFORMATION));

    return;
}


NTSTATUS
MsQueryNameInfo (
    IN PFCB Fcb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information operation.

Arguments:

    Fcb - Supplies the FCB of the mailslot to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies and receives the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    ULONG bytesToCopy;
    ULONG fileNameSize;

    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryNameInfo...\n", 0);

    //
    // See if the buffer is large enough, and decide how many bytes to copy.
    //

    *Length -= FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] );

    fileNameSize = Fcb->FullFileName.Length;

    if ( *Length >= fileNameSize ) {

        status = STATUS_SUCCESS;

        bytesToCopy = fileNameSize;

    } else {

        status = STATUS_BUFFER_OVERFLOW;

        bytesToCopy = *Length;
    }

    //
    // Copy over the file name and its length.
    //

    RtlCopyMemory (Buffer->FileName,
                   Fcb->FullFileName.Buffer,
                   bytesToCopy);

    Buffer->FileNameLength = bytesToCopy;

    *Length -= bytesToCopy;

    return status;
}


VOID
MsQueryPositionInfo (
    IN PFCB Fcb,
    IN PFILE_POSITION_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query position information operation.

Arguments:

    Fcb - Supplies the FCB of the mailslot being queried.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PDATA_QUEUE dataQueue;

    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryPositionInfo...\n", 0);

    //
    // The current byte offset is the number of bytes available to read
    // in the mailslot buffer.
    //

    if( Fcb->Header.NodeTypeCode == MSFS_NTC_FCB ) {
        dataQueue = &Fcb->DataQueue;

        Buffer->CurrentByteOffset.QuadPart = dataQueue->BytesInQueue;
    } else {
        Buffer->CurrentByteOffset.QuadPart = 0;
    }

    return;
}


VOID
MsQueryMailslotInfo (
    IN PFCB Fcb,
    IN PFILE_MAILSLOT_QUERY_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine performs the query mailslot information operation.

Arguments:

    Fcb - Supplies the Fcb of the mailslot to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

Return Value:

    VOID

--*/

{
    PDATA_QUEUE dataQueue;
    PDATA_ENTRY dataEntry;

    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryMailslotInfo...\n", 0);

    //
    // Set the fields in the record.
    //

    dataQueue = &Fcb->DataQueue;

    Buffer->MaximumMessageSize = dataQueue->MaximumMessageSize;
    Buffer->MailslotQuota = dataQueue->Quota;
    Buffer->MessagesAvailable = dataQueue->EntriesInQueue;

    Buffer->ReadTimeout = Fcb->Specific.Fcb.ReadTimeout;

    if ( dataQueue->EntriesInQueue == 0 ) {
        Buffer->NextMessageSize = MAILSLOT_NO_MESSAGE;
    } else {
        dataEntry = CONTAINING_RECORD( dataQueue->DataEntryList.Flink,
                                       DATA_ENTRY,
                                       ListEntry );

        Buffer->NextMessageSize = dataEntry->DataSize;
    }

    return;
}


NTSTATUS
MsSetBasicInfo (
    IN PFCB Fcb,
    IN PFILE_BASIC_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine sets the basic information for a mailslot.

Arguments:

    Fcb - Supplies the FCB for the mailslot being modified.

    Buffer - Supplies the buffer containing the data being set.

Return Value:

    NTSTATUS - Returns our completion status.

--*/

{
    PAGED_CODE();
    DebugTrace(0, Dbg, "SetBasicInfo...\n", 0);

    if (((PLARGE_INTEGER)&Buffer->CreationTime)->QuadPart != 0) {

        //
        //  Modify the creation time
        //

        Fcb->Specific.Fcb.CreationTime = Buffer->CreationTime;
    }

    if (((PLARGE_INTEGER)&Buffer->LastAccessTime)->QuadPart != 0) {

        //
        //  Modify the last access time
        //

        Fcb->Specific.Fcb.LastAccessTime = Buffer->LastAccessTime;
    }

    if (((PLARGE_INTEGER)&Buffer->LastWriteTime)->QuadPart != 0) {

        //
        //  Modify the last write time
        //

        Fcb->Specific.Fcb.LastModificationTime = Buffer->LastWriteTime;
    }

    if (((PLARGE_INTEGER)&Buffer->ChangeTime)->QuadPart != 0) {

        //
        //  Modify the change time
        //

        Fcb->Specific.Fcb.LastChangeTime = Buffer->ChangeTime;
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
MsSetMailslotInfo (
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_MAILSLOT_SET_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine sets the mailslot information for a mailslot.

Arguments:

    Irp - Pointer to an irp that contains the requestor's mode.

    Fcb - Supplies the FCB for the mailslot being modified.

    Buffer - Supplies the buffer containing the data being set.

Return Value:

    NTSTATUS - Returns our completion status.

--*/

{
    BOOLEAN fileUpdated;

    PAGED_CODE();
    DebugTrace(0, Dbg, "SetMaislotInfo...\n", 0);

    fileUpdated = FALSE;

    //
    // Check whether or not the DefaultTimeout parameter was specified.  If
    // so, then set it in the FCB.
    //

    if (ARGUMENT_PRESENT( Buffer->ReadTimeout )) {

        //
        // A read timeout parameter was specified.  Check to see whether
        // the caller's mode is kernel and if not capture the parameter inside
        // of a try...except clause.
        //

        if (Irp->RequestorMode != KernelMode) {
            try {
                ProbeForRead( Buffer->ReadTimeout,
                              sizeof( LARGE_INTEGER ),
                              sizeof( ULONG ) );

                Fcb->Specific.Fcb.ReadTimeout = *(Buffer->ReadTimeout);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Something went awry attempting to access the parameter.
                // Get the reason for the error and return it as the status
                // value from this service.
                //

                return GetExceptionCode();
            }
        } else {

            //
            // The caller's mode was kernel so simply store the parameter.
            //

            Fcb->Specific.Fcb.ReadTimeout = *(Buffer->ReadTimeout);
        }

        fileUpdated = TRUE;
    }

    //
    // Update the last change time, if necessary
    //

    if ( fileUpdated ) {
        KeQuerySystemTime( &Fcb->Specific.Fcb.LastChangeTime);
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\msdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msdata.c

Abstract:

    This module declares the global variable used by the mailslot
    file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#include "mailslot.h"

#ifdef MSDBG

//
// Debugging variables
//

LONG MsDebugTraceLevel;
LONG MsDebugTraceIndent;

#endif

//
// This lock protects access to reference counts.
//

PERESOURCE MsGlobalResource;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, MsInitializeData )
#pragma alloc_text( PAGE, MsUninitializeData )
#endif

NTSTATUS
MsInitializeData(
    VOID
    )

/*++

Routine Description:

    This function initializes all MSFS global data.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();
#ifdef MSDBG
    MsDebugTraceLevel = 0;
    MsDebugTraceIndent = 0;
#endif

    MsGlobalResource = MsAllocateNonPagedPool (sizeof(ERESOURCE), 'gFsM');

    if (MsGlobalResource == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeResourceLite ( MsGlobalResource );

    return STATUS_SUCCESS;
}

VOID
MsUninitializeData(
    VOID
    )
/*++

Routine Description:

    This function uninitializes all MSFS global data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ExDeleteResourceLite ( MsGlobalResource );

    ExFreePool ( MsGlobalResource );

    MsGlobalResource = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\msdata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msdata.h

Abstract:

    This module declares the global variables used by the mailslot
    file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSDATA_
#define _MSDATA_

extern LONG MsDebugTraceLevel;
extern LONG MsDebugTraceIndent;

#endif // _MSDATA_

extern PERESOURCE MsGlobalResource;
extern PERESOURCE MsPrefixTableResource;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\msconst.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msconst.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSCONST_
#define _MSCONST_

//
// Every major data structure in the file system is assigned a node
// type code.  This code is the first CSHORT in the structure and is
// followed by a CSHORT containing the size, in bytes, of the structure.
//

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)

#define MSFS_NTC_VCB                     ((NODE_TYPE_CODE)0x0601)
#define MSFS_NTC_ROOT_DCB                ((NODE_TYPE_CODE)0x0602)
#define MSFS_NTC_FCB                     ((NODE_TYPE_CODE)0x0604)
#define MSFS_NTC_CCB                     ((NODE_TYPE_CODE)0x0606)
#define MSFS_NTC_ROOT_DCB_CCB            ((NODE_TYPE_CODE)0x0608)

typedef CSHORT NODE_BYTE_SIZE;

//
// The name of the mailslot file system.
//

#define MSFS_NAME_STRING                 L"MSFS"

//
// Volume label
//
#define MSFS_VOLUME_LABEL                L"Mailslot"

//
// The default read timeout.  This is used if no timeout is specified
// when the mailslot is created.
//

#define DEFAULT_READ_TIMEOUT             { -1, -1 }

//
// The number of parameter bytes returned by a peek call.
//

#define PEEK_OUTPUT_PARAMETER_BYTES      \
            ((ULONG)FIELD_OFFSET(FILE_MAILSLOT_PEEK_BUFFER, Data[0]))

//
// The number of parameter bytes returned by a mailslot read call.
//

#define READ_OUTPUT_PARAMETER_BYTES      \
            ((ULONG)FIELD_OFFSET(FILE_MAILSLOT_READ_BUFFER, Data[0]))

//
// Access to the block header information.
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))


#endif // _MSCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\mailslot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mailslot.h

Abstract:

    This module is the main include file for the Mailslot File System.
    It includes other header files.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MAILSLOT_
#define _MAILSLOT_

#define _NTSRV_
#define _NTDDK_

//
// "System" include files
//

#include <ntos.h>
#include <string.h>
#include <fsrtl.h>

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

//
// Local, independent include files
//

#include "msconst.h"
#include "msdebug.h"
#include "msdata.h"

//
// Local, dependent include files (order is important)
//

#include "msstruc.h"
#include "msfunc.h"

#endif // def _MAILSLOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\msfunc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msfuncs.h

Abstract:

    This module defines all of the globally used procedures in the
    mailslot file system.  It also defines the functions that are
    implemented as macros.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSFUNCS_
#define _MSFUNCS_


//
// Internal mailslot data Structure Routines, implemented in strucsup.c.
// These routines maniuplate the in memory data structures.
//

NTSTATUS
MsInitializeData (
    VOID
    );

VOID
MsUninitializeData(
    VOID
    );

VOID
MsInitializeVcb (
    IN PVCB Vcb
    );

VOID
MsDeleteVcb (
    IN PVCB Vcb
    );

PROOT_DCB
MsCreateRootDcb (
    IN PVCB Vcb
    );

VOID
MsDeleteRootDcb (
    IN PROOT_DCB Dcb
    );

NTSTATUS
MsCreateFcb (
    IN  PVCB Vcb,
    IN  PDCB ParentDcb,
    IN  PUNICODE_STRING FileName,
    IN  PEPROCESS CreatorProcess,
    IN  ULONG MailslotQuota,
    IN  ULONG MaximumMessageSize,
    OUT PFCB *ppFcb
    );

VOID
MsDeleteFcb (
    IN PFCB Fcb
    );

NTSTATUS
MsCreateCcb (
    IN  PFCB Fcb,
    OUT PCCB *ppCcb
    );

PROOT_DCB_CCB
MsCreateRootDcbCcb (
    IN PROOT_DCB RootDcb,
    IN PVCB Vcb
    );

VOID
MsDeleteCcb (
    IN PCCB Ccb
    );

VOID
MsDereferenceNode (
    IN PNODE_HEADER NodeHeader
    );

VOID
MsDereferenceVcb (
    IN PVCB Vcb
    );

VOID
MsReferenceVcb (
    IN PVCB Vcb
    );

VOID
MsReferenceRootDcb (
    IN PROOT_DCB RootDcb
    );


VOID
MsDereferenceRootDcb (
    IN PROOT_DCB RootDcb
    );

VOID
MsDereferenceFcb (
    IN PFCB Fcb
    );

VOID
MsRemoveFcbName (
    IN PFCB Fcb
    );

VOID
MsDereferenceCcb (
    IN PCCB Ccb
    );


//
// Data queue support routines, implemented in DataSup.c
//

NTSTATUS
MsInitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN PEPROCESS Process,
    IN ULONG Quota,
    IN ULONG MaximumMessageSize
    );

VOID
MsUninitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN PEPROCESS Process
    );

NTSTATUS
MsAddDataQueueEntry (
    IN  PDATA_QUEUE DataQueue,
    IN  QUEUE_STATE Who,
    IN  ULONG DataSize,
    IN  PIRP Irp,
    IN  PWORK_CONTEXT WorkContext
    );

PIRP
MsRemoveDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN PDATA_ENTRY DataEntry
    );

VOID
MsRemoveDataQueueIrp (
    IN PIRP Irp,
    IN PDATA_QUEUE DataQueue
    );


//
// The follow routines provide common read/write data queue support
// for buffered read/write, and peek
//

IO_STATUS_BLOCK
MsReadDataQueue (                       // implemented in ReadSup.c
    IN PDATA_QUEUE ReadQueue,
    IN ENTRY_TYPE Operation,
    IN PUCHAR ReadBuffer,
    IN ULONG ReadLength,
    OUT PULONG MessageLength
    );

NTSTATUS
MsWriteDataQueue (                      // implemented in WriteSup.c
    IN PDATA_QUEUE WriteQueue,
    IN PUCHAR WriteBuffer,
    IN ULONG WriteLength
    );
extern
PIRP
MsResetCancelRoutine(
    IN PIRP Irp
    );


//
// Largest matching prefix searching routines, implemented in PrefxSup.c
//

PFCB
MsFindPrefix (
    IN PVCB Vcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart
    );

NTSTATUS
MsFindRelativePrefix (
    IN PDCB Dcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart,
    OUT PFCB *Fcb
    );


//
// The following routines are used to manipulate the fscontext fields of
// a file object, implemented in FilObSup.c
//

VOID
MsSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    );

NODE_TYPE_CODE
MsDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    );


//
// The following routines are used to manipulate the input buffers and are
// implemented in deviosup.c
//

VOID
MsMapUserBuffer (
    IN OUT PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    OUT PVOID *UserBuffer
    );


//
//  Miscellaneous support routines
//

//
// This is function is called at DPC level if a read timer expires.
//

VOID
MsReadTimeoutHandler(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// This macro returns TRUE if a flag in a set of flags is on and FALSE
// otherwise.
//

#ifdef FlagOn
#undef FlagOn
#endif

#define FlagOn(Flags,SingleFlag) (                          \
    (BOOLEAN)(((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )

//
// This macro takes a pointer (or ulong) and returns its rounded up word
// value.
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
// This macro takes a pointer (or ulong) and returns its rounded up longword
// value.
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
// This macro takes a pointer (or ulong) and returns its rounded up quadword
// value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
// The following types and macros are used to help unpack the packed and
// misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
// This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
// This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
// This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
// The following routines/macros are used for gaining shared and exclusive
// access to the global/vcb data structures.  The routines are implemented
// in ResrcSup.c.  There is a global resources that everyone tries to take
// out shared to do their work, with the exception of mount/dismount which
// take out the global resource exclusive.  All other resources only work
// on their individual item.  For example, an Fcb resource does not take out
// a Vcb resource.  But the way the file system is structured we know
// that when we are processing an Fcb other threads cannot be trying to remove
// or alter the Fcb, so we do not need to acquire the Vcb.
//
// The procedures/macros are:
//
//         Macro          Vcb     Fcb     Ccb     Subsequent macros
//
// AcquireExclusiveVcb    Read    None    None    ReleaseVcb
//                        Write
//
// AcquireSharedVcb       Read    None    None    ReleaseVcb
//
// AcquireExclusiveFcb    None    Read    None    ReleaseFcb
//                                Write
//
// AcquireSharedFcb       None    Read    None    ReleaseFcb
//
// AcquireExclusiveCcb    None    None    Read    ReleaseCcb
//                                        Write
//
// AcquireSharedCcb       None    None    Read    ReleaseCcb
//
// ReleaseVcb
//
// ReleaseFcb
//
// ReleaseCcb
//
//
// VOID
// MsAcquireExclusiveVcb (
//     IN PVCB Vcb
//     );
//
// VOID
// MsAcquireSharedVcb (
//     IN PVCB Vcb
//      );
//
// VOID
// MsAcquireExclusiveFcb (
//     IN PFCB Fcb
//     );
//
// VOID
// MsAcquireSharedFcb (
//     IN PFCB Fcb
//     );
//
// VOID
// MsAcquireExclusiveCcb (
//     IN PCCB Ccb
//     );
//
// VOID
// MsAcquireSharedCcb (
//     IN PCCB Ccb
//     );
//
// VOID
// MsReleaseVcb (
//     IN PVCB Vcb
//     );
//
// VOID
// MsReleaseFcb (
//     IN PFCB Fcb
//     );
//
// VOID
// MsReleaseCcb (
//     IN PCCB NonpagedCcb
//     );
//

#define MsAcquireGlobalLock() ((VOID)                          \
    ExAcquireResourceExclusiveLite( MsGlobalResource, TRUE )      \
)

#define MsReleaseGlobalLock() (                                \
    ExReleaseResourceLite( MsGlobalResource )                     \
)


#define MsAcquireExclusiveVcb(VCB) ((VOID)                     \
    ExAcquireResourceExclusiveLite( &(VCB)->Resource, TRUE )       \
)

#define MsAcquireSharedVcb(VCB) ((VOID)                        \
    ExAcquireResourceSharedLite( &(VCB)->Resource, TRUE )          \
)

#define MsIsAcquiredExclusiveVcb(VCB) ExIsResourceAcquiredExclusiveLite( &(VCB)->Resource )

#define MsAcquireExclusiveFcb(FCB) ((VOID)                     \
    ExAcquireResourceExclusiveLite( &(FCB)->Resource, TRUE )       \
)

#define MsAcquireSharedFcb(FCB) ((VOID)                        \
    ExAcquireResourceSharedLite( &(FCB)->Resource, TRUE )          \
)

#define MsReleaseVcb(VCB) {                                    \
    ExReleaseResourceLite( &((VCB)->Resource) );                   \
}

#define MsReleaseFcb(FCB) {                                    \
    ExReleaseResourceLite( &((FCB)->Resource) );                   \
}


//
// The FSD Level dispatch routines.   These routines are called by the
// I/O system via the dispatch table in the Driver Object.
//
// They each accept as input a pointer to a device object (actually most
// expect an msfs device object), and a pointer to the IRP.
//

NTSTATUS
MsFsdCreate (                           //  implemented in Create.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdCreateMailslot (                   //  implemented in Createms.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdClose (                            //  implemented in Close.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdRead (                             //  implemented in Read.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdWrite (                            //  implemented in Write.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdQueryInformation (                 //  implemented in FileInfo.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdSetInformation (                   //  implemented in FileInfo.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdQueryVolumeInformation (           //  implemented in VolInfo.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdCleanup (                          //  implemented in Cleanup.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

VOID
MsCancelTimer (                         //  implemented in Cleanup.c
    IN PDATA_ENTRY DataEntry
    );

NTSTATUS
MsFsdDirectoryControl (                 //  implemented in Dir.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdFsControl (                //  implemented in FsContrl.c
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdQuerySecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsFsdSetSecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );


//
// The node verification functions.  These functions verify that a node
// is still active.
//

NTSTATUS
MsVerifyFcb (
    IN PFCB Fcb
    );

NTSTATUS
MsVerifyCcb (
    IN PCCB Ccb
    );

NTSTATUS
MsVerifyDcbCcb (
    IN PROOT_DCB_CCB RootDcb
    );

//
// Miscellaneous routines.
//

VOID
MsTimeoutRead (                //  implemented in readsup.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
MsCheckForNotify (                      //  implemented in Dir.c
    IN PDCB Dcb,
    IN BOOLEAN CheckAllOutstandingIrps,
    IN NTSTATUS FinalStatus
    );

VOID
MsFlushNotifyForFile (                      //  implemented in Dir.c
    IN PDCB Dcb,
    IN PFILE_OBJECT FileObject
    );
//
// The following functions are used for MSFS exception handling
//

LONG
MsExceptionFilter (
    IN NTSTATUS ExceptionCode
    );

NTSTATUS
MsProcessException (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

//
// The following macro is used by the FSP and FSD routines to complete
// an IRP.
//

#define MsCompleteRequest(IRP,STATUS) {      \
    FsRtlCompleteRequest( (IRP), (STATUS) ); \
}

//
// Reference count macros.  These macro can be called only with
// MsGlobalResource held.
//

#define MsReferenceNode( nodeHeader )     (nodeHeader)->ReferenceCount++;

//
// Debugging functions.
//

#ifdef MSDBG

VOID
_DebugTrace(
    LONG Indent,
    ULONG Level,
    PSZ X,
    ULONG Y
    );

#endif

//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

//
// The following macros queries the state of data queues
//

//
// BOOLEAN
// MsIsDataQueueEmpty (
//     IN PDATA_QUEUE DataQueue
//     )
//
// Routine Description:
//
//     This routine indicates to the caller if the data queue is empty.
//
// Arguments:
//
//     DataQueue - Supplies a pointer to the data queue being queried
//
// Return Value:
//
//     BOOLEAN - TRUE if the queue is empty and FALSE otherwise.
//

#define MsIsDataQueueEmpty( _dataQueue )    \
    ((BOOLEAN) IsListEmpty(&(_dataQueue)->DataEntryList))

//
// BOOLEAN
// MsIsDataQueueReaders (
//     IN PDATA_QUEUE DataQueue
//     )
//
// Routine Description:
//
//     This routine indicates to the caller if the data queue is full of
//     read requests.
//
// Arguments:
//
//     DataQueue - Supplies a pointer to the data queue being queried
//
// Return Value:
//
//     BOOLEAN - TRUE if the queue contains read requests and FALSE otherwise
//

#define MsIsDataQueueReaders( _dataQueue )    \
    ((BOOLEAN) ((_dataQueue)->QueueState == ReadEntries))

//
// BOOLEAN
// MsIsDataQueueWriters (
//     IN PDATA_QUEUE DataQueue
//     )
//
// Routine Description:
//
//     This routine indicates to the caller if the data queue is full of
//     write requests.
//
// Arguments:
//
//     DataQueue - Supplies a pointer to the data queue being queried
//
// Return Value:
//
//     BOOLEAN - TRUE if the queue contains write requests and FALSE otherwise

#define MsIsDataQueueWriters( _dataQueue )    \
    ((BOOLEAN)((_dataQueue)->QueueState == WriteEntries))

//
// PLIST_ENTRY
// MsGetNextDataQueueEntry (
//     IN PDATA_QUEUE DataQueue
//     )
//
// Routine Description:
//
//     This routine will return a pointer to the next data queue entry in the
//     indicated data queue without changing any of the data queue.
//
// Arguments:
//
//     DataQueue - Supplies a pointer to the data queue being queried.
//
// Return Value:
//
//    PLIST_ENTRY - Returns a pointer to the next data queue entry.
//

#define MsGetNextDataQueueEntry( _dataQueue )   \
    (_dataQueue)->DataEntryList.Flink

#define MsIrpDataQueue(Irp) \
    ((Irp)->Tail.Overlay.DriverContext[0])

#define MsIrpChargedQuota(Irp) \
    ((Irp)->Tail.Overlay.DriverContext[1])

#define MsIrpWorkContext(Irp) \
    ((Irp)->Tail.Overlay.DriverContext[2])


//
// PVOID
// MsAllocatePagedPool (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define MsAllocatePagedPool( Size, Tag) \
    ExAllocatePoolWithTag( PagedPool, Size, Tag )

#define MsAllocatePagedPoolCold( Size, Tag) \
    ExAllocatePoolWithTag( (PagedPool|POOL_COLD_ALLOCATION), Size, Tag )

//
// PVOID
// MsAllocateNonPagedPool (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define MsAllocateNonPagedPool( Size, Tag) \
    ExAllocatePoolWithTag( NonPagedPool, Size, Tag )

//
// PVOID
// MsAllocatePagedPoolWithQuota (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to charged paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define MsAllocatePagedPoolWithQuota( Size, Tag) \
    ExAllocatePoolWithQuotaTag( PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, Size, Tag )

#define MsAllocatePagedPoolWithQuotaCold( Size, Tag) \
    ExAllocatePoolWithQuotaTag( PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE|POOL_COLD_ALLOCATION, Size, Tag )

//
// PVOID
// MsAllocateNonPagedPoolWithQuota (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a charged pointer to non-paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define MsAllocateNonPagedPoolWithQuota( Size, Tag) \
    ExAllocatePoolWithQuotaTag( NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, Size, Tag )


//
// VOID
// MsFreePool (
//    IN PVOID Mem)
//
// Routine Description:
//
//
//
// Arguments:
//
//     Mem - Memory to be freed
//
// Return Value:
//
//    None
//
#define MsFreePool(Mem) ExFreePool (Mem)


#endif // _MSFUNCS_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\msdebug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msdebug.c

Abstract:

    This module declares the debug functions used by the mailslot
    file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSDEBUG_
#define _MSDEBUG_

//
//  The mailslot debug levels:
//
//      0x00000000      Always gets printed (used when about to bug check)

#ifdef MSDBG

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS          (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_CREATE               (0x00000008)
#define DEBUG_TRACE_CLOSE                (0x00000010)
#define DEBUG_TRACE_READ                 (0x00000020)
#define DEBUG_TRACE_WRITE                (0x00000040)
#define DEBUG_TRACE_FILEINFO             (0x00000080)
#define DEBUG_TRACE_CLEANUP              (0x00000100)
#define DEBUG_TRACE_DIR                  (0x00000200)
#define DEBUG_TRACE_FSCONTROL            (0x00000400)
#define DEBUG_TRACE_CREATE_MAILSLOT      (0x00000800)
#define DEBUG_TRACE_SEINFO               (0x00001000)
#define DEBUG_TRACE_0x00002000           (0x00002000)
#define DEBUG_TRACE_0x00004000           (0x00004000)
#define DEBUG_TRACE_0x00008000           (0x00008000)
#define DEBUG_TRACE_0x00010000           (0x00010000)
#define DEBUG_TRACE_DEVIOSUP             (0x00020000)
#define DEBUG_TRACE_VERIFY               (0x00040000)
#define DEBUG_TRACE_WORK_QUEUE           (0x00080000)
#define DEBUG_TRACE_READSUP              (0x00100000)
#define DEBUG_TRACE_WRITESUP             (0x00200000)
#define DEBUG_TRACE_STATESUP             (0x00400000)
#define DEBUG_TRACE_FILOBSUP             (0x00800000)
#define DEBUG_TRACE_PREFXSUP             (0x01000000)
#define DEBUG_TRACE_CNTXTSUP             (0x02000000)
#define DEBUG_TRACE_DATASUP              (0x04000000)
#define DEBUG_TRACE_DPC                  (0x08000000)
#define DEBUG_TRACE_REFCOUNT             (0x10000000)
#define DEBUG_TRACE_STRUCSUP             (0x20000000)
#define DEBUG_TRACE_FSP_DISPATCHER       (0x40000000)
#define DEBUG_TRACE_FSP_DUMP             (0x80000000)

extern LONG MsDebugTraceLevel;
extern LONG MsDebugTraceIndent;

#define DebugDump(STR,LEVEL,PTR) {                         \
    ULONG _i;                                              \
    VOID MsDump(IN PVOID Ptr);                                         \
    if (((LEVEL) == 0) || (MsDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                  \
        DbgPrint("%08lx:",_i);                             \
        DbgPrint(STR);                                     \
        if (PTR != NULL) {MsDump(PTR);}                    \
        DbgBreakPoint();                                   \
    }                                                      \
}

#define DebugTrace(i,l,x,y)              _DebugTrace(i,l,x,(ULONG)y)

//
//  The following routine and macro is used to catch exceptions in
//  try except statements.  It allows us to catch the exception before
//  executing the exception handler.  The exception catcher procedure is
//  declared in msdata.c
//

LONG MsExceptionCatcher (IN PSZ String);

#define Exception(STR)                   (MsExceptionCatcher(STR))

#else

#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#define Exception(STR)                   (EXCEPTION_EXECUTE_HANDLER)

#define DebugTrace(I,L,X,Y)                              {NOTHING;}

#endif // MSDBG

#endif // _MSDEBUG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\msinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msinit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    mailslot file system.

Author:

    Manny Weiser (mannyw)    7-Jan-91

Revision History:

    Neill Clift (NeillC)     22-Jan-2000
    Major rework, Do raise exceptions, fix locking, fix cancel logic, fix validation and error handling.

--*/

#include "mailslot.h"
#include "zwapi.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MsfsUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, MsfsUnload )
#endif

PMSFS_DEVICE_OBJECT msfsDeviceObject = NULL;






NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the mailslot file system
    device driver.  This routine creates the device object for the mailslot
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Initialize MSFS global data.
    //

    status = MsInitializeData();
    if (!NT_SUCCESS (status)) {
        return status;
    }

    //
    // Set driver to be completely paged out.
    //
    MmPageEntireDriver(DriverEntry);

    //
    // Create the MSFS device object.
    //

    RtlInitUnicodeString( &nameString, L"\\Device\\Mailslot" );
    status = IoCreateDevice( DriverObject,
                             sizeof(MSFS_DEVICE_OBJECT)-sizeof(DEVICE_OBJECT),
                             &nameString,
                             FILE_DEVICE_MAILSLOT,
                             0,
                             FALSE,
                             &deviceObject );

    if (!NT_SUCCESS( status )) {

        MsUninitializeData();

        return status;
    }

    DriverObject->DriverUnload = MsfsUnload;
    //
    //  Now because we use the irp stack for storing a data entry we need
    //  to bump up the stack size in the device object we just created.
    //

    deviceObject->StackSize += 1;

    //
    // Note that because of the way data copying is done, we set neither
    // the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    // data is not buffered we may set up for Direct I/O by hand.
    //

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] =
        (PDRIVER_DISPATCH)MsFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_MAILSLOT] =
        (PDRIVER_DISPATCH)MsFsdCreateMailslot;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] =
        (PDRIVER_DISPATCH)MsFsdClose;
    DriverObject->MajorFunction[IRP_MJ_READ] =
        (PDRIVER_DISPATCH)MsFsdRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] =
        (PDRIVER_DISPATCH)MsFsdWrite;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] =
        (PDRIVER_DISPATCH)MsFsdQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] =
        (PDRIVER_DISPATCH)MsFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] =
        (PDRIVER_DISPATCH)MsFsdQueryVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] =
        (PDRIVER_DISPATCH)MsFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL] =
        (PDRIVER_DISPATCH)MsFsdDirectoryControl;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] =
        (PDRIVER_DISPATCH)MsFsdFsControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY] =
        (PDRIVER_DISPATCH)MsFsdQuerySecurityInfo;
    DriverObject->MajorFunction[IRP_MJ_SET_SECURITY] =
        (PDRIVER_DISPATCH)MsFsdSetSecurityInfo;

#ifdef _PNP_POWER_
    //
    // Mailslots should probably have a SetPower handler to ensure
    // that the driver is not powered down while a guarateed
    // mailslot delivery is in progress.   For now, we'll just
    // ignore this and let the machine set power.
    //

    deviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif


    //
    // Initialize stuff
    //

    msfsDeviceObject = (PMSFS_DEVICE_OBJECT)deviceObject;

    //
    // Now initialize the Vcb, and create the root dcb
    //

    MsInitializeVcb( &msfsDeviceObject->Vcb );

    //
    // Createt the root DCB
    //
    if (MsCreateRootDcb( &msfsDeviceObject->Vcb ) == NULL) {

        MsDereferenceVcb (&msfsDeviceObject->Vcb);
        IoDeleteDevice (&msfsDeviceObject->DeviceObject);
        MsUninitializeData();

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Return to the caller.
    //

    return( status );
}

VOID
MsfsUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++
      
Routine Description:
      
    This routine cleans up all of the memory associated with
    the driver.
      
Arguments:
      
    DriverObject    - Supplies the driver object controlling the device.
      
Return Value:
      
    None.
      
--*/
{
    UNICODE_STRING us;
    //
    // Remove the initial reference to the VCB. This should be the last.
    //
    ASSERT ( msfsDeviceObject->Vcb.Header.ReferenceCount == 1 );

    MsDereferenceVcb (&msfsDeviceObject->Vcb);

    RtlInitUnicodeString (&us, L"\\??\\MAILSLOT"); // Created by SMSS
    IoDeleteSymbolicLink (&us);

    //
    // Delete the device object
    //
    IoDeleteDevice (&msfsDeviceObject->DeviceObject);

    //
    // Release the globals
    //
    MsUninitializeData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the file read routine for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    15-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonRead (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsCreateWorkContext (
    PDEVICE_OBJECT DeviceObject,
    PLARGE_INTEGER Timeout,
    PFCB Fcb,
    PIRP Irp,
    PWORK_CONTEXT *ppWorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonRead )
#pragma alloc_text( PAGE, MsFsdRead )
#pragma alloc_text( PAGE, MsCreateWorkContext )
#endif

NTSTATUS
MsFsdRead (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtReadFile API calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdRead\n", 0);

    FsRtlEnterFileSystem();

    status = MsCommonRead( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdRead -> %08lx\n", status );

    return status;
}

NTSTATUS
MsCreateWorkContext (
    PDEVICE_OBJECT DeviceObject,
    PLARGE_INTEGER Timeout,
    PFCB Fcb,
    PIRP Irp,
    PWORK_CONTEXT *ppWorkContext
    )
/*++

Routine Description:

    This routine build a timeout work context.

Arguments:


Return Value:

    NTSTATUS - Status associated with the call

--*/
{
    PKTIMER Timer;
    PKDPC Dpc;
    PWORK_CONTEXT WorkContext;

    //
    // Allocate memory for the work context.
    //
    *ppWorkContext = NULL;

    WorkContext = MsAllocateNonPagedPoolWithQuota( sizeof(WORK_CONTEXT),
                                                   'wFsM' );
    if (WorkContext == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Timer = &WorkContext->Timer;
    Dpc = &WorkContext->Dpc;

    //
    // Fill in the work context structure.
    //

    WorkContext->Irp = Irp;
    WorkContext->Fcb = Fcb;

    WorkContext->WorkItem = IoAllocateWorkItem (DeviceObject);

    if (WorkContext->WorkItem == NULL) {
        MsFreePool (WorkContext);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Now set up a DPC and set the timer to the user specified
    // timeout.
    //

    KeInitializeTimer( Timer );
    KeInitializeDpc( Dpc, MsReadTimeoutHandler, WorkContext );

    MsAcquireGlobalLock();
    MsReferenceNode( &Fcb->Header );
    MsReleaseGlobalLock();

    *ppWorkContext = WorkContext;
    return STATUS_SUCCESS;
}


NTSTATUS
MsCommonRead (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for reading a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;

    PIRP readIrp;
    PUCHAR readBuffer;
    ULONG readLength;
    ULONG readRemaining;
    PDATA_QUEUE readQueue;
    ULONG messageLength;

    LARGE_INTEGER timeout;

    PWORK_CONTEXT workContext = NULL;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonRead\n", 0);
    DebugTrace( 0, Dbg, "MsfsDeviceObject = %08lx\n", (ULONG)MsfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG)irpSp->FileObject);

    //
    // Get the FCB and make sure that the file isn't closing.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&fcb,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonRead -> %08lx\n", status );
        return status;
    }

    //
    // Allow read operations only if this is a server side handle to
    // a mailslot file.
    //

    if (nodeTypeCode != MSFS_NTC_FCB) {

        DebugTrace(0, Dbg, "FileObject is not the correct type\n", 0);

        MsDereferenceNode( (PNODE_HEADER)fcb );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsCommonRead -> %08lx\n", status );
        return status;
    }

    //
    // Make local copies of the input parameters to make things easier, and
    // initialize the main variables that describe the read command.
    //

    readIrp        = Irp;
    readBuffer     = Irp->UserBuffer;
    readLength     = irpSp->Parameters.Read.Length;
    readRemaining  = readLength;

    readQueue = &fcb->DataQueue;


    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( fcb );


    //
    // Ensure that this FCB still belongs to an active open mailslot.
    //

    status = MsVerifyFcb( fcb );
    if (NT_SUCCESS (status)) {

        //
        // If the read queue does not contain any write entries
        // then we either need to queue this operation or
        // fail immediately.
        //

        if (!MsIsDataQueueWriters( readQueue )) {

            //
            // There are no outstanding writes.  If the read timeout is
            // non-zero queue the read IRP, otherwise fail it.
            //

            timeout = fcb->Specific.Fcb.ReadTimeout;

            if (timeout.HighPart == 0 && timeout.LowPart == 0) {

                DebugTrace(0, Dbg, "Failing read with 0 timeout\n", 0);

                status = STATUS_IO_TIMEOUT;

                DebugTrace(-1, Dbg, "MsCommonRead -> %08lx\n", status );

            } else {
                //
                // Create a timer block to time the request if we need to.
                //
                if ( timeout.QuadPart != -1 ) {
                    status = MsCreateWorkContext (&MsfsDeviceObject->DeviceObject,
                                                  &timeout,
                                                  fcb,
                                                  readIrp,
                                                  &workContext);
                }


                if (NT_SUCCESS (status)) {
                    status = MsAddDataQueueEntry( readQueue,
                                                  ReadEntries,
                                                  readLength,
                                                  readIrp,
                                                  workContext );
                }
            }

        } else {

            //
            // Otherwise we have a data on a queue that contains
            // one or more write entries.  Read the data and complete
            // the read IRP.
            //

            readIrp->IoStatus = MsReadDataQueue( readQueue,
                                                 Read,
                                                 readBuffer,
                                                 readLength,
                                                 &messageLength
                                                );

            status = readIrp->IoStatus.Status;

            //
            // Update the file last access time and finish up the read IRP.
            //

            if ( NT_SUCCESS( status ) ) {
                KeQuerySystemTime( &fcb->Specific.Fcb.LastAccessTime );
            }

        }
    }

    MsReleaseFcb( fcb );

    MsDereferenceFcb( fcb );

    if (status != STATUS_PENDING) {

        if (workContext) {
            MsDereferenceFcb ( fcb );
            IoFreeWorkItem (workContext->WorkItem);
            ExFreePool (workContext);
        }

        MsCompleteRequest( readIrp, status );
    }

    DebugTrace(-1, Dbg, "MsCommonRead -> %08lx\n", status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\seinfo.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    SeInfo.c

Abstract:

    This module implements the Security Information routines for MSFS
    There are two entry points MsFsdQueryInformation and
    MsFsdSetInformation.

Author:

    Manny Weiser     [mannyw]    19-Feb-1992

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SEINFO)

//
//  local procedure prototypes
//

NTSTATUS
MsCommonQuerySecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
MsCommonSetSecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonQuerySecurityInfo )
#pragma alloc_text( PAGE, MsCommonSetSecurityInfo )
#pragma alloc_text( PAGE, MsFsdQuerySecurityInfo )
#pragma alloc_text( PAGE, MsFsdSetSecurityInfo )
#endif

NTSTATUS
MsFsdQuerySecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the Query Security Information API
    calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdQuerySecurityInfo\n", 0);

    //
    // Call the common Query Information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonQuerySecurityInfo( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "MsFsdQuerySecurityInfo -> %08lx\n", status );

    return status;
}


NTSTATUS
MsFsdSetSecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the Set Security Information API
    calls.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdSetSecurityInfo\n", 0);

    //
    // Call the common Set Information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonSetSecurityInfo( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "MsFsdSetSecurityInfo -> %08lx\n", status );

    return status;
}

//
//  Internal support routine
//

NTSTATUS
MsCommonQuerySecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying security information.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonQuerySecurityInfo...\n", 0);
    DebugTrace( 0, Dbg, " Irp                   = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->SecurityInformation = %08lx\n", irpSp->Parameters.QuerySecurity.SecurityInformation);
    DebugTrace( 0, Dbg, " ->Length              = %08lx\n", irpSp->Parameters.QuerySecurity.Length);
    DebugTrace( 0, Dbg, " ->UserBuffer          = %08lx\n", Irp->UserBuffer);

    //
    // Get the Fcb and figure out who we are, and make sure we're not
    // disconnected.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fcb,
                                            &fsContext2 )) != MSFS_NTC_FCB) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        if (nodeTypeCode != NTC_UNDEFINED) {
            MsDereferenceNode( &fcb->Header );
        }

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    // Acquire exclusive access to the FCB.
    //

    MsAcquireSharedFcb( fcb );

    //
    //  Call the security routine to do the actual query
    //
    status = SeQuerySecurityDescriptorInfo( &irpSp->Parameters.QuerySecurity.SecurityInformation,
                                            Irp->UserBuffer,
                                            &irpSp->Parameters.QuerySecurity.Length,
                                            &fcb->SecurityDescriptor );

    MsReleaseFcb( fcb );

    MsDereferenceFcb( fcb );
    //
    // Finish up the IRP.
    //

    MsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "MsCommonQuerySecurityInfo -> %08lx\n", status );

    return status;
}


NTSTATUS
MsCommonSetSecurityInfo (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Setting security information.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    NODE_TYPE_CODE nodeTypeCode;
    PFCB fcb;
    PVOID fsContext2;
    PSECURITY_DESCRIPTOR OldSecurityDescriptor;

    PAGED_CODE();

    //
    // Get the current stack location
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonSetSecurityInfo...\n", 0);
    DebugTrace( 0, Dbg, " Irp                   = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->SecurityInformation = %08lx\n", irpSp->Parameters.SetSecurity.SecurityInformation);
    DebugTrace( 0, Dbg, " ->SecurityDescriptor  = %08lx\n", irpSp->Parameters.SetSecurity.SecurityDescriptor);

    //
    // Get the FCB and figure out who we are, and make sure we're not
    // disconnected.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fcb,
                                            &fsContext2 )) != MSFS_NTC_FCB) {

        DebugTrace(0, Dbg, "Invalid handle\n", 0);

        if (nodeTypeCode != NTC_UNDEFINED) {
            MsDereferenceNode( &fcb->Header );
        }
        MsCompleteRequest( Irp, STATUS_INVALID_HANDLE );
        status = STATUS_INVALID_HANDLE;

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    // Acquire exclusive access to the FCB
    //

    MsAcquireExclusiveFcb( fcb );

    //
    //  Call the security routine to do the actual set
    //

    OldSecurityDescriptor = fcb->SecurityDescriptor;

    status = SeSetSecurityDescriptorInfo( NULL,
                                          &irpSp->Parameters.SetSecurity.SecurityInformation,
                                          irpSp->Parameters.SetSecurity.SecurityDescriptor,
                                          &fcb->SecurityDescriptor,
                                          PagedPool,
                                          IoGetFileObjectGenericMapping() );

    if (NT_SUCCESS(status)) {
        ExFreePool( OldSecurityDescriptor );
    }

    MsReleaseFcb( fcb );
    MsDereferenceFcb( fcb );

    //
    // Finish up the IRP.
    //

    MsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "MsCommonSetSecurityInfo -> %08lx\n", status );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\readsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    readsup.c

Abstract:

    This module implements the read support routine.  This is a common
    read function that is called to do read and peek.

Author:

    Manny Weiser (mannyw)    15-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_READSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsReadDataQueue )
#pragma alloc_text( PAGE, MsTimeoutRead )
#endif

IO_STATUS_BLOCK
MsReadDataQueue (
    IN PDATA_QUEUE ReadQueue,
    IN ENTRY_TYPE Operation,
    IN PUCHAR ReadBuffer,
    IN ULONG ReadLength,
    OUT PULONG MessageLength
    )

/*++

Routine Description:

    This function reads data from the read queue and fills up the
    read buffer.  It will also dequeue the data entry if this is not
    a peek operation.

    It will only be called if there is at least one message to read.


Arguments:

    ReadQueue - Provides the read queue to examine.  Its state must
        already be set to WriteEntries.

    Operation - Indicates the type of operation to perform.  If the
        operation is Peek, the write data entry is not dequeued.

    ReadBuffer - Supplies a buffer to receive the data

    ReadLength - Supplies the length, in bytes, of ReadBuffer.

    MessageLength - Returns the full size of the message, even if the
        read buffer is not large enough to contain the entire message.

Return Value:

    IO_STATUS_BLOCK - Indicates the result of the operation.

--*/

{
    IO_STATUS_BLOCK iosb;

    PLIST_ENTRY listEntry;
    PDATA_ENTRY dataEntry;
    PFCB fcb;

    PUCHAR writeBuffer;
    ULONG writeLength;

    ULONG amountRead;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsReadDataQueue\n", 0);
    DebugTrace( 0, Dbg, "ReadQueue     = %08lx\n", (ULONG)ReadQueue);
    DebugTrace( 0, Dbg, "Operation     = %08lx\n", Operation);
    DebugTrace( 0, Dbg, "ReadBuffer    = %08lx\n", (ULONG)ReadBuffer);
    DebugTrace( 0, Dbg, "ReadLength    = %08lx\n", ReadLength);

    //
    // Read the first message out of the data queue.
    //

    iosb.Status = STATUS_SUCCESS;
    iosb.Information = 0;

    listEntry = MsGetNextDataQueueEntry( ReadQueue );
    ASSERT( listEntry != &ReadQueue->DataEntryList );

    dataEntry = CONTAINING_RECORD( listEntry, DATA_ENTRY, ListEntry );

    //
    // Calculate how much data is in this entry.
    //

    writeBuffer = dataEntry->DataPointer;
    writeLength = dataEntry->DataSize;

    DebugTrace(0, Dbg, "WriteBuffer    = %08lx\n", (ULONG)writeBuffer);
    DebugTrace(0, Dbg, "WriteLength    = %08lx\n", writeLength);

    //
    // Fail this operation, if it is a read and the buffer is not large
    // enough.
    //

    if (ReadLength < writeLength) {

        if (Operation != Peek) {
            iosb.Information = 0;
            iosb.Status = STATUS_BUFFER_TOO_SMALL;

            return iosb;
        }
        iosb.Status = STATUS_BUFFER_OVERFLOW;

        DebugTrace(0, Dbg, "Overflowed peek buffer\n", 0);

        amountRead = ReadLength;
    } else {
        amountRead = writeLength;
    }


    //
    // Copy data from the write buffer at write offset to the
    // read buffer by the mininum of write remaining or read length
    //
    // This copy may take an exception and thats why this call needs to be enclosed
    // in try/except.
    //

    try {

        RtlCopyMemory (ReadBuffer,
                       writeBuffer,
                       amountRead);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        iosb.Status = GetExceptionCode ();
        return iosb;

    }

    *MessageLength = dataEntry->DataSize;


    //
    // If write length is larger than read length, this must be an
    // overflowed peek.
    //

    if (writeLength <= ReadLength) {
        //
        // The write entry is done so remove it from the read
        // queue, if this is not a peek operation.  This might
        // also have an IRP that needs to be completed.
        //

        if (Operation != Peek) {

            PIRP writeIrp;

            if ((writeIrp = MsRemoveDataQueueEntry( ReadQueue,
                                                    dataEntry )) != NULL) {
                //
                // Writes don't get queued. This is an error
                //
                KeBugCheckEx( MAILSLOT_FILE_SYSTEM,
                              1,
                              (ULONG_PTR) writeIrp,
                              (ULONG_PTR) ReadQueue,
                              (ULONG_PTR) dataEntry );

            }
        }

        DebugTrace(0, Dbg, "Successful mailslot read\n", 0);

        //
        // Indicate success.
        //

        iosb.Status = STATUS_SUCCESS;
    }


    DebugTrace(0, Dbg, "Amount read = %08lx\n", amountRead);

    iosb.Information = amountRead;
    DebugTrace(-1, Dbg, "MsReadDataQueue -> iosb.Status = %08lx\n", iosb.Status);
    return iosb;
}


VOID
MsTimeoutRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine times out a read operation.  It gains exclusive
    access to the FCB, and searches the data queue of read operations.

    If the timed out read operation is not found, it is assumed that
    a write IRP completed the read after the time out DPC ran, but
    before this function could complete the read IRP.

Arguments:

    Context - a pointer to our WorkContext

Return Value:

    None.

--*/

{
    PDATA_QUEUE dataQueue;
    PLIST_ENTRY listEntry;
    PIRP queuedIrp;
    PDATA_ENTRY dataEntry;
    PWORK_CONTEXT workContext;
    PIRP irp;
    PFCB fcb;

    PAGED_CODE();

    //
    // Reference our local variables.
    //

    workContext = (PWORK_CONTEXT)Context;

    fcb = workContext->Fcb;

    dataQueue = &fcb->DataQueue;
    //
    // Acquire exclusive access to the FCB.  This must succeed.
    //

    MsAcquireExclusiveFcb( fcb );

    //
    // There are two cases to consider here. Either this timer is the first completion
    // event for this IRP or we werent but we started running before they could cancel the timer.
    // When the second case is detected the other thread NULL's out the IRP pointer.
    //
    irp = workContext->Irp;
    if (irp) {


        dataEntry = (PDATA_ENTRY)IoGetNextIrpStackLocation( irp );
        //
        // Nobody else should touch this once we release the lock.
        //
        dataEntry->TimeoutWorkContext = NULL;

        //
        // If cancel isn't active for the IRP.
        //

        irp = MsRemoveDataQueueEntry( dataQueue, dataEntry );
    }


    //
    // Release the FCB, and derefernce it.
    //

    MsReleaseFcb( fcb );
    MsDereferenceFcb( fcb );

    //
    // Free the work context and the work item. We have to do this unconditionaly
    // if we started running
    //
    IoFreeWorkItem (workContext->WorkItem);
    ExFreePool( workContext );

    if (irp != NULL) {
        DebugTrace(0, Dbg, "Completing IRP %p\n", irp );

        MsCompleteRequest( irp, STATUS_IO_TIMEOUT );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\msstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    msstruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the mailslot file system.

Author:

    Manny Weiser (mannyw)    7-Jan-1991

Revision History:

--*/

#ifndef _MSSTRUC_
#define _MSSTRUC_


//
// The VCB record is the top record in the mailslot file system in-memory
// data structure.  This structure must be allocated from non-paged pool
// and immediately follows (in memory) the Device object for the mailslot
// Structurally the layout of the data structure is as follows
//
//    +------------+
//    |MSDO        |
//    |            |
//    +------------+
//    |Vcb         |
//    |            |
//    |            |
//    +------------+
//        | ^
//        | |
//        | |
//        v |
//      +-------------+
//      |RootDcb      |
//      |             |<-+
//      +-------------+  |
//          :            |
//          :            |
//          :            |
//          v            |
//        +----------------+    +-------------------+
//        |Fcb             |    |Ccb                |
//        |                |<---|                   |
//        |                |    |                   |
//        +----------------+    +-------------------+
//                ^                       ^
//                |                       |
//           +---------+              +---------+
//           |Server FO|              |Client FO|
//           |         |              |         |
//           +---------+              +---------+
//
//
// Where there is only one VCB for the entire mailslot file system, and
// it contains a single pointer to the root DCB for the file system.  Off
// of the DCB is a queue of FCB's.  There is one FCB for every mailslot.
// There are also two additional CCB types for the VCB and the root DCB,
// and notify records for the notify change operations.
//
// A newly initialized mailslot file system only contains the VCB and
// the root DCB.  A new FCB is created when a new mailslot is created
// The file object for the creater (i.e., server end) points to the FCB
// and indicates that it is the server end.  When a user does an open on
// the mailslot its file object is set to point to a CCB which belongs
// to the FCB.
//
// A file object with a null pointer to the FsContext field is a closed or
// disconnected mailslot.
//


//
//  Each Fcb has a data queues for holding the outstanding
//  read/write requests.  The following type is used to determine
//  if the data queue contains read requests, write requests, or is empty.
//

typedef enum _QUEUE_STATE {
    ReadEntries,
    WriteEntries,
    Empty
} QUEUE_STATE;

//
// The node state.
//
// Currently only 2 states are defined.  When a node is created it's state
// is NodeStateActive.  When a cleanup IRP is processed, it set the node
// state of the corresponding node to NodeStateClosing.  Only the close
// IRP can get processed on this node.
//

typedef enum _NODE_STATE {
    NodeStateActive,
    NodeStateClosing
} NODE_STATE;

//
// The types of data entry there are.  Each corresponds to an IRP
// that can be added to a data queue.
//

typedef enum _ENTRY_TYPE {
    Read,
    ReadMailslot,
    Write,
    WriteMailslot,
    Peek
} ENTRY_TYPE;

//
// The data queue is a structure that contains the queue state, quota
// information, and the list head.  The quota information is used to
// maintain mailslot quota.
//

typedef struct _DATA_QUEUE {

    //
    // The current state of what is contained in this data queue,
    // how many bytes of read/write data there are, and how many individual
    // requests there are in the queue that contain data (includes
    // close or flush requests).
    //

    QUEUE_STATE QueueState;
    ULONG BytesInQueue;
    ULONG EntriesInQueue;

    //
    // The following two fields denote who much quota was reserved for
    // this mailslot and how much we've used up.  This is only
    // the creator quota and not the user quota.
    //

    ULONG Quota;
    ULONG QuotaUsed;


    //
    // The size of the largest message that can be written to
    // this data queue.
    //

    ULONG MaximumMessageSize;

    //
    // The queue of data entries.
    //

    LIST_ENTRY DataEntryList;


} DATA_QUEUE, *PDATA_QUEUE;

//
// The following type is used to denote where we got the memory for the
// data entry and possibly the data buffer.  We either got the memory
// from the mailslot quota, the user quota, or it is part of the next IRP
// stack location.
//

typedef enum _FROM {
    MailslotQuota,
    UserQuota,
    InIrp
} FROM;

//
// Each entry in the data queue is a data entry.  Processing an IRP
// has the potential of creating and inserting a new data entry.  If the
// memory for the entry is taken from the IRP we use the current stack
// location.
//

typedef struct _DATA_ENTRY {

    //
    // Where the data buffer came from
    //

    UCHAR From;
    CHAR Spare1;
    USHORT Spare2;

    //
    // The following field is how we connect into the queue of data entries
    //

    LIST_ENTRY ListEntry;

    //
    // The following field indicates if we still have an IRP associated
    // with this data entry that need to be completed when the remove
    // the data entry.  Note that if From is InIrp that this IRP field
    // must not be null.
    //

    PIRP Irp;

    //
    // The following two fields describe the size and location of the data
    // buffer described by this entry.  These fields are only used if the
    // type is buffered, and are ignored otherwise.
    //

    ULONG DataSize;
    PVOID DataPointer;

    //
    // Used for read data entries only.  A pointer to the work context
    // of the time out.
    //

    struct _WORK_CONTEXT *TimeoutWorkContext;

} DATA_ENTRY, *PDATA_ENTRY;



//
// The node header is used to manage standard nodes within MSFS.
//

typedef struct _NODE_HEADER {

    NODE_TYPE_CODE NodeTypeCode;  // The node type
    NODE_BYTE_SIZE NodeByteSize;  // The size of the node
    NODE_STATE NodeState;         // The current node state
    ULONG ReferenceCount;         // Number of active references to the node

} NODE_HEADER, *PNODE_HEADER;

typedef struct _VCB {

    NODE_HEADER Header;

    //
    // The filesystem name
    //

    UNICODE_STRING FileSystemName;

    //
    // The time we created the volume
    //
    LARGE_INTEGER CreationTime;

    //
    // A pointer to the root DCB for this volume
    //

    struct _FCB *RootDcb;

    //
    // A prefix table that is used for quick, prefix directed, lookup of
    // FCBs/DCBs that are part of this volume
    //

    UNICODE_PREFIX_TABLE PrefixTable;

    //
    // A resource variable to control access to the volume specific data
    // structures
    //

    ERESOURCE Resource;

    //
    // The following field is used to check share access people who want
    // to open the mailslot driver
    //

    SHARE_ACCESS ShareAccess;

} VCB, *PVCB;


//
// The Mailslot Device Object is an I/O system device object with
// additional workqueue parameters appended to the end.  There is only
// one of these records created for the entire system during system
// initialization.  The workqueue is used by the FSD to post requests to
// the filesystem.
//

typedef struct _MSFS_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    // This is the file system specific volume control block.
    //

    VCB Vcb;

} MSFS_DEVICE_OBJECT, *PMSFS_DEVICE_OBJECT;


//
// The Fcb/Dcb record corresponds to every opened mailslot and directory,
// and to every directory on an opened path.
//

typedef struct _FCB {

    //
    // Header.NodeTypeCode of this record (must be MSFS_NTC_FCB, or
    // MSFS_NTC_ROOT_DCB)
    //

    NODE_HEADER Header;

    //
    // The links for the queue of all fcbs for a specific DCB off of
    // Dcb.ParentDcbQueue.  For the root directory this queue is empty.
    //

    LIST_ENTRY ParentDcbLinks;

    //
    // A pointer to the Dcb that is the parent directory containing
    // this FCB.  If this record itself is the root dcb then this field
    // is null.
    //

    struct _FCB *ParentDcb;

    //
    // A pointer to the VCB containing this FCB.
    //

    PVCB Vcb;

    //
    // Back pointer to the server's file object.
    //

    PFILE_OBJECT FileObject;

    //
    // A pointer to the security descriptor for this mailslot.
    //

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // The following union is cased off of the node type code for the FCB.
    // is a seperate case for the directory versus file FCBs.
    //

    union {

        //
        // A Directory Control Block (DCB)
        //

        struct {

            //
            // A queue of the notify IRPs that will be completed when any
            // change is made to a file in the directory.  Queued using
            // the Tail.Overlay.ListEntry of the IRP.
            //

            LIST_ENTRY NotifyFullQueue;

            //
            // A queue of the notify IRPs that will be completed only if a
            // file is added, deleted, or renamed in the directory.  Queued
            // using the Tail.Overlay.ListEntry of the IRP.
            //

            LIST_ENTRY NotifyPartialQueue;

            //
            // A queue of all the FCBs/DCBs that are opened under this
            // DCB.
            //

            LIST_ENTRY ParentDcbQueue;


            //
            // Spinlock to protect the queues above that contain cancelable IRPs. We can't
            // synchronize with a resource because IoCancelIrp can be called at DISPATCH_LEVEL.
            //

            KSPIN_LOCK SpinLock;
        } Dcb;

        //
        // A File Control Block (FCB)
        //

        struct {

            //
            // The following field is a queue head for a list of CCBs
            // that are opened under us.
            //

            LIST_ENTRY CcbQueue;

            //
            // The default read timeout.  This is always a relative value.
            //

            LARGE_INTEGER ReadTimeout;

            //
            // File timestamps.
            //

            LARGE_INTEGER CreationTime;
            LARGE_INTEGER LastModificationTime;
            LARGE_INTEGER LastAccessTime;
            LARGE_INTEGER LastChangeTime;

        } Fcb;

    } Specific;

    //
    // The following field is used to check share access for
    // clients that want to open the file/directory.
    //

    SHARE_ACCESS ShareAccess;

    //
    // The following field is the fully qualified file name for this FCB/DCB
    // starting from the root of the volume, and last file name in the
    // fully qualified name.
    //

    UNICODE_STRING FullFileName;
    UNICODE_STRING LastFileName;

    //
    // The following field contains a prefix table entry that is used when
    // searching a volume for a name (or longest matching prefix)
    //

    UNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;


    //
    // The following field is used to remember the process that created this
    // mailslot.  It is needed to allocate quota and return quota.
    //

    PEPROCESS CreatorProcess;

    //
    // The following data queue is used to contain the buffered information
    // for the mailslot.
    //

    DATA_QUEUE DataQueue;

    //
    // A resource variable to control access to the File specific data
    // structures
    //

    ERESOURCE Resource;

} FCB, DCB, ROOT_DCB, *PFCB, *PDCB, *PROOT_DCB;



//
// The CCB record is allocated for every cliennt side open of a mailslot.
//

typedef struct _CCB {

    //
    // Header.NodeTypeCode of this record (must be MSFS_NTC_CCB).
    //

    NODE_HEADER Header;

    //
    // The following field is a list entry for the list of ccb that we
    // are a member of.
    //

    LIST_ENTRY CcbLinks;

    //
    // A pointer to the FCB, or VCB that we are tied to
    //

    PFCB Fcb;

    //
    // Pointers to the file object of the client has opened this file.
    //

    PFILE_OBJECT FileObject;

    //
    // A resource to control access to the CCB.
    //

    ERESOURCE Resource;

} CCB, *PCCB;


//
// The root DCB CCB record is allocated for every opened instance of the
// root dcb.  This record is pointed at by FsContext2.
//

typedef struct _ROOT_DCB_CCB {

    //
    // Header.NodeTypeCode of this record (must be MSFS_NTC_ROOT_DCB_CCB).
    //

    NODE_HEADER Header;

    //
    // A pointer to the VCB containing this CCB.
    //

    PVCB Vcb;

    //
    // Pointer to the DCB for this CCB
    //
    PROOT_DCB Dcb;

    //
    // The following field is a count of the last index returned
    // by query directory.
    //

    ULONG IndexOfLastCcbReturned;

    //
    // The following string is used as a query template for directory
    // query operations
    //

    PUNICODE_STRING QueryTemplate;

} ROOT_DCB_CCB, *PROOT_DCB_CCB;

//
// A work context contains the information needed to do read timeouts.
//

typedef struct _WORK_CONTEXT {

    //
    // Pointer to unload safe work item.
    //

    PIO_WORKITEM WorkItem;

    //
    // A pointer to the IRP for this operation.
    //

    PIRP Irp;

    //
    // A referenced pointer to the FCB that will process this operation.
    //

    PFCB Fcb;

    //
    // A timer and dpc tourine to accomplish the timeout.
    //

    KTIMER Timer;

    KDPC Dpc;

} WORK_CONTEXT, *PWORK_CONTEXT;

#endif // _MSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\prefxsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefxsup.c

Abstract:

    This module implements the mailslot prefix support routines

Author:

    Manny Weiser (mannyw)    10-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_PREFXSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsFindPrefix )
#pragma alloc_text( PAGE, MsFindRelativePrefix )
#endif

PFCB
MsFindPrefix (
    IN PVCB Vcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart
    )

/*++

Routine Description:

    This routine searches the FCBs/DCBs of a volume and locates the
    FCB/DCB with longest matching prefix for the given input string.  The
    search is relative to the root of the volume.  So all names must start
    with a "\".

Arguments:

    Vcb - Supplies the Vcb to search

    String - Supplies the input string to search for

    CaseInsensitive - Specifies if the search is to be done case sensitive
        (FALSE) or insensitive (TRUE)

    RemainingPart - Returns the string when the prefix no longer matches.
        For example, if the input string is "\alpha\beta" only matches the
        root directory then the remaining string is "alpha\beta".  If the
        same string matches a DCB for "\alpha" then the remaining string is
        "beta".

Return Value:

    PFCB - Returns a pointer to either an FCB or a DCB whichever is the
        longest matching prefix.

--*/

{
    PUNICODE_PREFIX_TABLE_ENTRY prefixTableEntry;
    PFCB fcb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFindPrefix, Vcb = %08lx\n", (ULONG)Vcb);
    DebugTrace( 0, Dbg, "  String = %wZ\n", (ULONG)String);

    //
    // Find the longest matching prefix. Make sure we hold the VCB lock here
    //

    ASSERT (MsIsAcquiredExclusiveVcb(Vcb));

    prefixTableEntry = RtlFindUnicodePrefix( &Vcb->PrefixTable,
                                             String,
                                             CaseInsensitive );

    //
    // If we didn't find one then it's an error.
    //

    if (prefixTableEntry == NULL) {
        DebugDump("Error looking up a prefix", 0, Vcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    //
    // Get a pointer to the FCB containing the prefix table entry.
    //

    fcb = CONTAINING_RECORD( prefixTableEntry, FCB, PrefixTableEntry );

    //
    // Tell the caller how many characters we were able to match.  We first
    // set the remaining part to the original string minus the matched
    // prefix, then we check if the remaining part starts with a backslash
    // and if it does then we remove the backslash from the remaining string.
    //

    RemainingPart->Length = String->Length - fcb->FullFileName.Length;
    RemainingPart->MaximumLength = RemainingPart->Length;
    RemainingPart->Buffer = (PWCH)((PCHAR)String->Buffer + fcb->FullFileName.Length);

    if ((RemainingPart->Length > 0) &&
        (RemainingPart->Buffer[0] == L'\\')) {

        RemainingPart->Length -= sizeof( WCHAR );
        RemainingPart->MaximumLength -= sizeof( WCHAR );
        RemainingPart->Buffer += sizeof( WCHAR );
    }

    DebugTrace(0, Dbg, "RemainingPart set to %wZ\n", (ULONG)RemainingPart);

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFindPrefix -> %08lx\n", (ULONG)fcb);

    return fcb;
}


NTSTATUS
MsFindRelativePrefix (
    IN PDCB Dcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart,
    OUT PFCB *ppFcb
    )

/*++

Routine Description:

    This routine searches the FCBs/DCBs of a volume and locates the
    FCB/DCB with longest matching prefix for the given input string.  The
    search is relative to a input DCB, and must not start with a leading "\"
    All searching is done case insensitive.

Arguments:

    Dcb - Supplies the Dcb to start searching from

    String - Supplies the input string to search for

    CaseInsensitive - Specifies if the search is to be done case sensitive
        (FALSE) or insensitive (TRUE)

    RemainingPart - Returns the index into the string when the prefix no
        longer matches.  For example, if the input string is "beta\gamma"
        and the input Dcb is for "\alpha" and we only match beta then
        the remaining string is "gamma".

Return Value:

    PFCB - Returns a pointer to either an FCB or a DCB whichever is the
        longest matching prefix.

--*/

{
    USHORT nameLength;
    USHORT MaxLength;
    PWCH name;

    UNICODE_STRING fullString;
    PWCH temp;

    PFCB fcb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFindRelativePrefix, Dcb = %08lx\n", (ULONG)Dcb);
    DebugTrace( 0, Dbg, "String = %08lx\n", (ULONG)String);


    ASSERT(NodeType(Dcb) == MSFS_NTC_ROOT_DCB);

    //
    // We first need to build the complete name and then do a relative
    // search from the root.
    //

    nameLength    = String->Length;
    name          = String->Buffer;

    MaxLength = nameLength + 2*sizeof(WCHAR);
    if (MaxLength < nameLength) {
        return STATUS_INVALID_PARAMETER;
    }

    temp = MsAllocatePagedPool( MaxLength, 'nFsM' );
    if (temp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    temp[0] = L'\\';
    RtlCopyMemory (&temp[1], name, nameLength);
    temp[(nameLength / sizeof(WCHAR)) + 1] = L'\0';

    fullString.Length = nameLength + sizeof (WCHAR);
    fullString.MaximumLength = MaxLength;
    fullString.Buffer = temp;

    //
    // Find the prefix relative to the volume.
    //

    fcb = MsFindPrefix( Dcb->Vcb,
                        &fullString,
                        CaseInsensitive,
                        RemainingPart );

    //
    // Now adjust the remaining part to take care of the relative
    // volume prefix.
    //

    MsFreePool (temp);

    RemainingPart->Buffer = (PWCH)((PCH)String->Buffer + String->Length -
                                        RemainingPart->Length);

    DebugTrace(0, Dbg, "RemainingPart set to %wZ\n", (ULONG)RemainingPart);

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFindRelativePrefix -> %08lx\n", (ULONG)fcb);

    *ppFcb = fcb;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\strucsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    strucsup.c

Abstract:

    This module implements the mailslot in-memory data structure
    manipulation routines.

Author:

    Manny Weiser (mannyw)    9-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, MsInitializeVcb )
#pragma alloc_text( INIT, MsCreateRootDcb )
#pragma alloc_text( PAGE, MsCreateCcb )
#pragma alloc_text( PAGE, MsCreateFcb )
#pragma alloc_text( PAGE, MsCreateRootDcbCcb )
#pragma alloc_text( PAGE, MsDeleteCcb )
#pragma alloc_text( PAGE, MsDeleteFcb )
#pragma alloc_text( PAGE, MsDeleteRootDcb )
#pragma alloc_text( PAGE, MsDeleteVcb )
#pragma alloc_text( PAGE, MsDereferenceCcb )
#pragma alloc_text( PAGE, MsDereferenceFcb )
#pragma alloc_text( PAGE, MsDereferenceNode )
#pragma alloc_text( PAGE, MsDereferenceRootDcb )
#pragma alloc_text( PAGE, MsDereferenceVcb )
#pragma alloc_text( PAGE, MsRemoveFcbName )
#pragma alloc_text( PAGE, MsReferenceVcb )
#pragma alloc_text( PAGE, MsReferenceRootDcb )
#endif

WCHAR FileSystemName[] = MSFS_NAME_STRING;

//
// !!! This module allocates all structures containing a resource from
//     non-paged pool.  The resources is the only field which must be
//     allocated from non-paged pool.  Consider allocating the resource
//     separately for greater efficiency.
//

VOID
MsInitializeVcb (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine initializes new Vcb record. The Vcb record "hangs" off the
    end of the Msfs device object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsInitializeVcb, Vcb = %08lx\n", (ULONG)Vcb);

    //
    // We start by first zeroing out all of the VCB, this will guarantee
    // that any stale data is wiped clean.
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    // Set the node type code, node byte size, and reference count.
    //

    Vcb->Header.NodeTypeCode = MSFS_NTC_VCB;
    Vcb->Header.NodeByteSize = sizeof(VCB);
    Vcb->Header.ReferenceCount = 1;
    Vcb->Header.NodeState = NodeStateActive;

    //
    // Initialize the Volume name
    //

    Vcb->FileSystemName.Buffer = FileSystemName;
    Vcb->FileSystemName.Length = sizeof( FileSystemName ) - sizeof( WCHAR );
    Vcb->FileSystemName.MaximumLength = sizeof( FileSystemName );

    //
    // Initialize the Prefix table
    //

    RtlInitializeUnicodePrefix( &Vcb->PrefixTable );

    //
    // Initialize the resource variable for the VCB.
    //

    ExInitializeResourceLite( &Vcb->Resource );

    //
    // Record creation time.
    //
    KeQuerySystemTime (&Vcb->CreationTime);
    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsInitializeVcb -> VOID\n", 0);

    return;
}


VOID
MsDeleteVcb (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine removes the VCB record from our in-memory data
    structures.  It also will remove all associated underlings
    (i.e., FCB records).

Arguments:

    Vcb - Supplies the Vcb to be removed

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDeleteVcb, Vcb = %08lx\n", (ULONG)Vcb);

    ASSERT (Vcb->Header.ReferenceCount == 0);

    //
    // Remove the Root Dcb
    //

    if (Vcb->RootDcb != NULL) {

        ASSERT (Vcb->RootDcb->Header.ReferenceCount == 1 );

        MsDereferenceRootDcb ( Vcb->RootDcb );
    }

    //
    // Uninitialize the resource variable for the VCB.
    //

    ExDeleteResourceLite( &Vcb->Resource );

    //
    // And zero out the Vcb, this will help ensure that any stale data is
    // wiped clean
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsDeleteVcb -> VOID\n", 0);

    return;
}


PROOT_DCB
MsCreateRootDcb (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new root DCB record
    into the in memory data structure.

Arguments:

    Vcb - Supplies the Vcb to associate the new DCB under

Return Value:

    PROOT_DCB - returns pointer to the newly allocated root DCB.

--*/

{
    PROOT_DCB rootDcb;
    PWCH Name;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateRootDcb, Vcb = %08lx\n", (ULONG)Vcb);

    //
    // Make sure we don't already have a root dcb for this vcb
    //

    rootDcb = Vcb->RootDcb;

    if (rootDcb != NULL) {
        DebugDump("Error trying to create multiple root dcbs\n", 0, Vcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    //
    // Allocate a new DCB and zero its fields.
    //

    rootDcb = MsAllocateNonPagedPool ( sizeof(DCB), 'DFsM' );
    if (rootDcb == NULL) {
        return NULL;
    }

    RtlZeroMemory( rootDcb, sizeof(DCB));

    //
    // Set the proper node type code, node byte size, and reference count.
    //

    rootDcb->Header.NodeTypeCode = MSFS_NTC_ROOT_DCB;
    rootDcb->Header.NodeByteSize = sizeof(ROOT_DCB);
    rootDcb->Header.ReferenceCount = 1;
    rootDcb->Header.NodeState = NodeStateActive;

    //
    // The root Dcb has an empty parent dcb links field
    //

    InitializeListHead( &rootDcb->ParentDcbLinks );


    //
    // Initialize the notify queues, and the parent dcb queue.
    //

    InitializeListHead( &rootDcb->Specific.Dcb.NotifyFullQueue );
    InitializeListHead( &rootDcb->Specific.Dcb.NotifyPartialQueue );
    InitializeListHead( &rootDcb->Specific.Dcb.ParentDcbQueue );

    //
    // Initizlize spinlock that protects IRP queues that conatin cancelable IRPs.
    //
    KeInitializeSpinLock (&rootDcb->Specific.Dcb.SpinLock);

    //
    // Set the full file name
    //

    Name = MsAllocatePagedPoolCold(2 * sizeof(WCHAR), 'DFsM' );
    if (Name == NULL) {
        ExFreePool (rootDcb);
        return NULL;
    }

    Name[0] = L'\\';
    Name[1] = L'\0';

    rootDcb->FullFileName.Buffer = Name;
    rootDcb->FullFileName.Length = sizeof (WCHAR);
    rootDcb->FullFileName.MaximumLength = 2*sizeof (WCHAR);

    rootDcb->LastFileName = rootDcb->FullFileName;


    //
    // Set the Vcb and give it a pointer to the new root DCB.
    //

    rootDcb->Vcb = Vcb;
    Vcb->RootDcb = rootDcb;
    //
    // Initialize the resource variable.
    //

    ExInitializeResourceLite( &(rootDcb->Resource) );

    //
    // Insert this DCB into the prefix table. No locks needed in initialization phase.
    //

    if (!RtlInsertUnicodePrefix( &Vcb->PrefixTable,
                                 &rootDcb->FullFileName,
                                 &rootDcb->PrefixTableEntry )) {

        DebugDump("Error trying to insert root dcb into prefix table\n", 0, Vcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateRootDcb -> %8lx\n", (ULONG)rootDcb);

    return rootDcb;
}


VOID
MsDeleteRootDcb (
    IN PROOT_DCB RootDcb
    )

/*++

Routine Description:

    This routine deallocates and removes the ROOT DCB record
    from our in-memory data structures.  It also will remove all
    associated underlings (i.e., Notify queues and child FCB records).

Arguments:

    RootDcb - Supplies the ROOT DCB to be removed

Return Value:

    None

--*/

{
    PLIST_ENTRY links;
    PIRP irp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDeleteRootDcb, RootDcb = %08lx\n", (ULONG)RootDcb);

    //
    // We can only delete this record if the reference count is zero.
    //

    if (RootDcb->Header.ReferenceCount != 0) {
        DebugDump("Error deleting RootDcb, Still Open\n", 0, RootDcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    ASSERT (IsListEmpty (&RootDcb->Specific.Dcb.NotifyFullQueue));
    ASSERT (IsListEmpty (&RootDcb->Specific.Dcb.NotifyPartialQueue));
    //
    // We can only be removed if the no other FCB have us referenced
    // as a their parent DCB.
    //

    if (!IsListEmpty(&RootDcb->Specific.Dcb.ParentDcbQueue)) {
        DebugDump("Error deleting RootDcb\n", 0, RootDcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }

    //
    // Remove the entry from the prefix table, and then remove the full
    // file name. No locks needed when unloading.
    //

    RtlRemoveUnicodePrefix( &RootDcb->Vcb->PrefixTable, &RootDcb->PrefixTableEntry );

    ExFreePool( RootDcb->FullFileName.Buffer );

    //
    // Free up the resource variable.
    //

    ExDeleteResourceLite( &(RootDcb->Resource) );

    //
    // Finally deallocate the DCB record.
    //

    ExFreePool( RootDcb );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsDeleteRootDcb -> VOID\n", 0);

    return;
}


NTSTATUS
MsCreateFcb (
    IN  PVCB Vcb,
    IN  PDCB ParentDcb,
    IN  PUNICODE_STRING FileName,
    IN  PEPROCESS CreatorProcess,
    IN  ULONG MailslotQuota,
    IN  ULONG MaximumMessageSize,
    OUT PFCB *ppFcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Fcb record into
    the in memory data structures.

Arguments:

    Vcb - Supplies the Vcb to associate the new FCB under.

    ParentDcb - Supplies the parent dcb that the new FCB is under.

    FileName - Supplies the file name of the file relative to the directory
        it's in (e.g., the file \config.sys is called "CONFIG.SYS" without
        the preceding backslash).

    CreatorProcess - Supplies a pointer to our creator process

    MailslotQuota - Supplies the initial quota

    MaximumMessageSize - Supplies the size of the largest message that
        can be written to the mailslot

    ppFcb - Returned allocated FCB

Return Value:

    NTSTATUS - status of operation

--*/

{
    PFCB fcb;
    PWCHAR Name;
    USHORT Length;
    USHORT MaxLength;
    NTSTATUS status;
    BOOLEAN AddBackSlash = FALSE;
    ULONG i;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateFcb\n", 0);


    Length = FileName->Length;
    MaxLength = Length + sizeof (UNICODE_NULL);

    //
    // Reject overflow or underflow cases.
    //
    if (Length < sizeof (WCHAR) || MaxLength < Length) {
        return STATUS_INVALID_PARAMETER;
    }

    if (FileName->Buffer[0] != '\\') {
        AddBackSlash = TRUE;
        MaxLength += sizeof (WCHAR);
        if (MaxLength < sizeof (WCHAR)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Allocate a new FCB record, and zero its fields.
    //
    fcb = MsAllocateNonPagedPoolWithQuota( sizeof(FCB), 'fFsM' );
    if (fcb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fcb, sizeof(FCB) );

    //
    // Set the proper node type code, node byte size, and reference count.
    //

    fcb->Header.NodeTypeCode = MSFS_NTC_FCB;
    fcb->Header.NodeByteSize = sizeof(FCB);
    fcb->Header.ReferenceCount = 1;
    fcb->Header.NodeState = NodeStateActive;

    //
    // Set the file name.
    //
    Name = MsAllocatePagedPoolWithQuotaCold( MaxLength, 'NFsM' );
    if (Name == NULL) {
        MsFreePool (fcb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    i = 0;
    if (AddBackSlash == TRUE) {
       Name[0] = '\\';
       i++;
    }
    RtlCopyMemory (&Name[i], FileName->Buffer, Length);
    *(PWCHAR)( (PCHAR)&Name[i] + Length ) = L'\0';

    //
    // Don't need to call RtlInitUnicodeString if we know the length already. Its just a waste.
    //
    fcb->FullFileName.Buffer = Name;
    fcb->FullFileName.Length = MaxLength - sizeof (WCHAR);
    fcb->FullFileName.MaximumLength = MaxLength;

    fcb->LastFileName.Buffer = Name + 1;
    fcb->LastFileName.Length = MaxLength - 2 * sizeof (WCHAR);
    fcb->LastFileName.MaximumLength = MaxLength - sizeof (WCHAR);

    //
    // Initialize the data queue. This charges the server process for the quota and can fail
    // because of that.
    //
    status = MsInitializeDataQueue( &fcb->DataQueue,
                                    CreatorProcess,
                                    MailslotQuota,
                                    MaximumMessageSize);
    if (!NT_SUCCESS (status)) {

        MsFreePool (fcb);
        MsFreePool (Name);

        return status;
    }
    
    //
    // Acquire exclusive access to the root DCB.
    //

    MsAcquireExclusiveFcb( (PFCB)ParentDcb );

    //
    // Insert this FCB into our parent DCB's queue.
    //
    InsertTailList( &ParentDcb->Specific.Dcb.ParentDcbQueue,
                    &fcb->ParentDcbLinks );

    MsReleaseFcb( (PFCB)ParentDcb );

    //
    // Initialize other FCB fields.
    //

    fcb->ParentDcb = ParentDcb;
    fcb->Vcb = Vcb;

    MsReferenceVcb (Vcb);

    fcb->CreatorProcess =  CreatorProcess;
    ExInitializeResourceLite( &(fcb->Resource) );

    //
    // Initialize the CCB queue.
    //

    InitializeListHead( &fcb->Specific.Fcb.CcbQueue );

    //
    // Insert this FCB into the prefix table.
    //

    ASSERT (MsIsAcquiredExclusiveVcb(Vcb));

    if (!RtlInsertUnicodePrefix( &Vcb->PrefixTable,
                                 &fcb->FullFileName,
                                 &fcb->PrefixTableEntry )) {

        //
        // We should not be able to get here because we already looked up the name and found
        // it was not there. A failure here is a fatal error.
        //
        DebugDump("Error trying to name into prefix table\n", 0, fcb);
        KeBugCheck( MAILSLOT_FILE_SYSTEM );
    }


    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateFcb -> %08lx\n", (ULONG)fcb);

    *ppFcb = fcb;
    return STATUS_SUCCESS;
}

VOID
MsRemoveFcbName (
    IN PFCB Fcb
    )
/*++

Routine Description:

    This routine removes the FCB's name from the prefix table and the root DCB. This is done at
    cleanup time and in a backout path of create.

Arguments:

    Fcb - Supplies the FCB to have its name removed

Return Value:

    None

--*/
{
    //
    // Remove the Fcb from the prefix table. Make sure we hold the VCB lock exclusive.
    //

    ASSERT (MsIsAcquiredExclusiveVcb(Fcb->Vcb));

    RtlRemoveUnicodePrefix( &Fcb->Vcb->PrefixTable, &Fcb->PrefixTableEntry );

    //
    // Acquire exclusive access to the root DCB.
    //

    MsAcquireExclusiveFcb( (PFCB) Fcb->ParentDcb );

    //
    // Remove the Fcb from our parent DCB's queue.
    //

    RemoveEntryList( &Fcb->ParentDcbLinks );

    MsReleaseFcb( (PFCB) Fcb->ParentDcb );
}


VOID
MsDeleteFcb (
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine deallocates and removes an FCB from our in-memory data
    structures.  It also will remove all associated underlings.

Arguments:

    Fcb - Supplies the FCB to be removed

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDeleteFcb, Fcb = %08lx\n", (ULONG)Fcb);

    //
    // Release the FCB reference to the VCB.
    //

    MsDereferenceVcb( Fcb->Vcb );

    ExFreePool( Fcb->FullFileName.Buffer );

    //
    // Free up the data queue.
    //

    MsUninitializeDataQueue(
        &Fcb->DataQueue,
        Fcb->CreatorProcess
        );

    //
    // If there is a security descriptor on the mailslot then deassign it
    //

    if (Fcb->SecurityDescriptor != NULL) {
        SeDeassignSecurity( &Fcb->SecurityDescriptor );
    }

    //
    //  Free up the resource variable.
    //

    ExDeleteResourceLite( &(Fcb->Resource) );

    //
    // Finally deallocate the FCB record.
    //

    ExFreePool( Fcb );

    //
    // Return to the caller
    //

    DebugTrace(-1, Dbg, "MsDeleteFcb -> VOID\n", 0);

    return;
}


NTSTATUS
MsCreateCcb (
    IN PFCB Fcb,
    OUT PCCB *ppCcb
    )

/*++

Routine Description:

    This routine creates a new CCB record.

Arguments:

    Fcb   - Supplies a pointer to the FCB to which we are attached.
    ppCcb - Output for the allocated CCB

Return Value:

    NTSTATUS for the operation

--*/

{
    PCCB ccb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateCcb\n", 0);

    ASSERT( Fcb->Header.NodeState == NodeStateActive );

    //
    //  Allocate a new CCB record and zero its fields.
    //

    ccb = MsAllocateNonPagedPoolWithQuota( sizeof(CCB), 'cFsM' );
    if (ccb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( ccb, sizeof(CCB) );

    //
    //  Set the proper node type code, node byte size, and reference count.
    //

    ccb->Header.NodeTypeCode = MSFS_NTC_CCB;
    ccb->Header.NodeByteSize = sizeof(CCB);
    ccb->Header.ReferenceCount = 1;
    ccb->Header.NodeState = NodeStateActive;

    //
    // Insert ourselves in the list of ccb for the fcb, and reference
    // the fcb.
    //

    MsAcquireExclusiveFcb( Fcb );
    InsertTailList( &Fcb->Specific.Fcb.CcbQueue, &ccb->CcbLinks );
    MsReleaseFcb( Fcb );

    ccb->Fcb = Fcb;
    MsAcquireGlobalLock();
    MsReferenceNode( &Fcb->Header );
    MsReleaseGlobalLock();

    //
    // Initialize the CCB's resource.
    //

    ExInitializeResourceLite( &ccb->Resource );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateCcb -> %08lx\n", (ULONG)ccb);

    *ppCcb = ccb;
    return STATUS_SUCCESS;
}


PROOT_DCB_CCB
MsCreateRootDcbCcb (
    IN PROOT_DCB RootDcb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates a new root DCB CCB record.

Arguments:

Return Value:

    PROOT_DCB_CCB - returns a pointer to the newly allocate ROOT_DCB_CCB

--*/

{
    PROOT_DCB_CCB ccb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsCreateRootDcbCcb\n", 0);

    //
    // Allocate a new root DCB CCB record, and zero it out.
    //

    ccb = MsAllocateNonPagedPoolWithQuota( sizeof(ROOT_DCB_CCB), 'CFsM' );

    if (ccb == NULL) {
        return NULL;
    }

    RtlZeroMemory( ccb, sizeof(ROOT_DCB_CCB) );

    //
    // Set the proper node type code, node byte size, and reference count.
    //

    ccb->Header.NodeTypeCode = MSFS_NTC_ROOT_DCB_CCB;
    ccb->Header.NodeByteSize = sizeof(ROOT_DCB_CCB);
    ccb->Header.ReferenceCount = 1;
    ccb->Header.NodeState = NodeStateActive;

    ccb->Vcb = Vcb;
    MsReferenceVcb (Vcb);

    ccb->Dcb = RootDcb;
    MsReferenceRootDcb (RootDcb);
    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsCreateRootDcbCcb -> %08lx\n", (ULONG)ccb);

    return ccb;
}


VOID
MsDeleteCcb (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine deallocates and removes the specified CCB record
    from the our in memory data structures.

Arguments:

    Ccb - Supplies the CCB to remove

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsDeleteCcb, Ccb = %08lx\n", (ULONG)Ccb);

    //
    // Case on the type of CCB we are deleting.
    //

    switch (Ccb->Header.NodeTypeCode) {

    case MSFS_NTC_CCB:

        MsDereferenceFcb( Ccb->Fcb );

        ExDeleteResourceLite( &Ccb->Resource );
        break;

    case MSFS_NTC_ROOT_DCB_CCB:

        MsDereferenceRootDcb ( ((PROOT_DCB_CCB)Ccb)->Dcb );

        MsDereferenceVcb ( ((PROOT_DCB_CCB)Ccb)->Vcb );

        if (((PROOT_DCB_CCB)Ccb)->QueryTemplate != NULL) {
            ExFreePool( ((PROOT_DCB_CCB)Ccb)->QueryTemplate );
        }
        break;
    }

    //
    // Deallocate the Ccb record.
    //

    ExFreePool( Ccb );

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsDeleteCcb -> VOID\n", 0);

    return;
}


VOID
MsReferenceVcb (
    IN PVCB Vcb
    )
/*++

Routine Description:

    This routine references a VCB block.  If the reference count reaches 2, the driver paging is restored
    to normal so that cancelation and DPC routines won't take pagefaults.

Arguments:

    Vcb - Supplies the VCB to reference

Return Value:

    None

--*/
{
    MsAcquireGlobalLock();
    MsReferenceNode( &Vcb->Header );
    if (Vcb->Header.ReferenceCount == 2) {
        //
        // Set the driver paging back to normal
        //
        MmResetDriverPaging(MsReferenceVcb);
    }
    MsReleaseGlobalLock();
}

VOID
MsReferenceRootDcb (
    IN PROOT_DCB RootDcb
    )
/*++

Routine Description:

    This routine references a root DCB block.  If the reference count reaches 2, a reference is placed on the
    VCB so that cancelation and DPC routines won't take pagefaults.

Arguments:

    Vcb - Supplies the VCB to reference

Return Value:

    None

--*/
{
    MsAcquireGlobalLock();
    MsReferenceNode( &RootDcb->Header );
    MsReleaseGlobalLock();
}



VOID
MsDereferenceVcb (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine dereferences a VCB block.  If the reference count
    reaches zero, the block is freed.

Arguments:

    Vcb - Supplies the VCB to dereference

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, DEBUG_TRACE_REFCOUNT, "MsDereferenceVcb, Vcb = %08lx\n", (ULONG)Vcb);

    //
    // Acquire the lock that protects the reference count.
    //

    MsAcquireGlobalLock();

    if ( --(Vcb->Header.ReferenceCount) == 0 ) {

        //
        // This was the last reference to the VCB.  Delete it now
        //

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Vcb->Header.ReferenceCount );

        MsReleaseGlobalLock();
        MsDeleteVcb( Vcb );

    } else {

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Vcb->Header.ReferenceCount );

        if (Vcb->Header.ReferenceCount == 1) {
            //
            // Set driver to be paged completely out
            //
            MmPageEntireDriver(MsDereferenceVcb);
        }

        MsReleaseGlobalLock();

    }

    DebugTrace(-1, DEBUG_TRACE_REFCOUNT, "MsDereferenceVcb -> VOID\n", 0);
    return;
}


VOID
MsDereferenceFcb (
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine dereferences a FCB block.
    If the reference count reaches zero, the block is freed.

Arguments:

    Fcb - Supplies the FCB to dereference.

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, DEBUG_TRACE_REFCOUNT, "MsDereferenceFcb, Fcb = %08lx\n", (ULONG)Fcb);

    //
    // Acquire the lock that protects the reference count.
    //

    MsAcquireGlobalLock();

    if ( --(Fcb->Header.ReferenceCount) == 0 ) {

        //
        // This was the last reference to the FCB.  Delete it now
        //

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Fcb->Header.ReferenceCount );

        MsReleaseGlobalLock();
        MsDeleteFcb( Fcb );

    } else {

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Fcb->Header.ReferenceCount );

        MsReleaseGlobalLock();

    }

    DebugTrace(-1, DEBUG_TRACE_REFCOUNT, "MsDereferenceFcb -> VOID\n", 0);
    return;
}


VOID
MsDereferenceCcb (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine dereferences a CCB block.  If the reference count
    reaches zero, the block is freed.

Arguments:

    Ccb - Supplies the Ccb to dereference

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, DEBUG_TRACE_REFCOUNT, "MsDereferenceCcb, Ccb = %08lx\n", (ULONG)Ccb);

    //
    // Acquire the lock that protects the reference count.
    //

    MsAcquireGlobalLock();

    if ( --(Ccb->Header.ReferenceCount) == 0 ) {

        //
        // This was the last reference to the Ccb.  Delete it now
        //

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Ccb->Header.ReferenceCount );

        MsReleaseGlobalLock();

        MsDeleteCcb( Ccb );

    } else {

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   Ccb->Header.ReferenceCount );

        MsReleaseGlobalLock();

    }

    DebugTrace(-1, DEBUG_TRACE_REFCOUNT, "MsDereferenceCcb -> VOID\n", 0);
    return;
}


VOID
MsDereferenceRootDcb (
    IN PROOT_DCB RootDcb
    )

/*++

Routine Description:

    This routine dereferences a ROOT_DCB block.  If the reference count
    reaches zero, the block is freed.

Arguments:

    RootDcb - Supplies the RootDcb to dereference

Return Value:

    None

--*/

{
    PAGED_CODE();
    DebugTrace(+1, DEBUG_TRACE_REFCOUNT, "MsDereferenceRootDcb, RootDcb = %08lx\n", (ULONG)RootDcb);

    //
    // Acquire the lock that protects the reference count.
    //

    MsAcquireGlobalLock();

    if ( --(RootDcb->Header.ReferenceCount) == 0 ) {

        //
        // This was the last reference to the RootDcb.  Delete it now
        //

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   RootDcb->Header.ReferenceCount );

        MsReleaseGlobalLock();
        MsDeleteRootDcb( RootDcb );

    } else {

        DebugTrace(0,
                   DEBUG_TRACE_REFCOUNT,
                   "Reference count = %lx\n",
                   RootDcb->Header.ReferenceCount );

        MsReleaseGlobalLock();

    }


    DebugTrace(-1, DEBUG_TRACE_REFCOUNT, "MsDereferenceRootDcb -> VOID\n", 0);
    return;
}


VOID
MsDereferenceNode (
    IN PNODE_HEADER NodeHeader
    )

/*++

Routine Description:

    This routine dereferences a generic mailslot block.  It figures out
    the type of block this is, and calls the appropriate worker function.

Arguments:

    NodeHeader - A pointer to a generic mailslot block header.

Return Value:

    None

--*/

{
    PAGED_CODE();
    switch ( NodeHeader->NodeTypeCode ) {

    case MSFS_NTC_VCB:
        MsDereferenceVcb( (PVCB)NodeHeader );
        break;

    case MSFS_NTC_ROOT_DCB:
        MsDereferenceRootDcb( (PROOT_DCB)NodeHeader );
        break;

    case MSFS_NTC_FCB:
        MsDereferenceFcb( (PFCB)NodeHeader );
        break;

    case MSFS_NTC_CCB:
    case MSFS_NTC_ROOT_DCB_CCB:
        MsDereferenceCcb( (PCCB)NodeHeader );
        break;

    default:

        //
        // This block is not one of ours.
        //

        KeBugCheck( MAILSLOT_FILE_SYSTEM );

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\tmscli.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tmscli.c

Abstract:

    User mode test program for the mailslot file system.

    This test program can be built from the command line using the
    command 'nmake UMTEST=tmscli'.

Author:

    Manny Weiser (mannyw)   17-Jan-1991

Revision History:

--*/

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>

//
// Local definitions
//

VOID
DisplayUsage(
    PSZ ProgramName
    );

BOOLEAN
NotifyChangeDirectoryTest(
    VOID
    );

BOOLEAN
QueryVolumeTest(
    VOID
    );

BOOLEAN
OpenMailslot(
    PSZ Name,
    PHANDLE Handle
    );


BOOLEAN
WriteTest(
    IN HANDLE Handle
    );

DisplayUnicode(
    IN WCHAR *UnicodeString,
    IN ULONG Length
    );

#define MESSAGE_SIZE    100L
#define MAILSLOT_SIZE   (10 * MESSAGE_SIZE)

char Buffer[MESSAGE_SIZE];

int
main(
    int argc,
    char *argv[]
    )
{
    HANDLE handle;
    int i;

    printf("\nStart %s...\n", argv[0]);

    for (i = 1; i < argc; i++) {

        switch ( *argv[i] ) {

        case 'h':
        case '?':
            DisplayUsage( argv[0] );
            break;

        case 'o':
            if ( !OpenMailslot( argv[i] + 1, &handle ) ) {
                return 3;
            }
            break;

        case 'n':
            if ( !NotifyChangeDirectoryTest() ) {
                return 3;
            }
            break;

        case 'c':
            printf( "Closing file\n" );
            NtClose( handle );
            break;

        case 'w':
            if (!WriteTest(handle)) {
                return 3;
            }
            break;

        case 'v':
            if (!QueryVolumeTest()) {
                return 3;
            }
            break;

        default:
            printf( "Unknown test ""%s"" skipped.\n", argv[i] );

        }
    }

    printf( "%s exiting\n", argv[0]);
    return 0;
}


BOOLEAN
NotifyChangeDirectoryTest(
    VOID
    )
{
    HANDLE rootDirHandle;
    UCHAR buffer[512];
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING nameString;
    NTSTATUS status;

    RtlInitUnicodeString( &nameString, L"\\Device\\Mailslot\\" );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to open mailslot directory \"%wZ\"\n", &nameString );

    status = NtOpenFile (
                &rootDirHandle,
                GENERIC_READ,
                &objectAttributes,
                &ioStatusBlock,
                0,
                0L
                );

    printf( "MSFS root dir open status = %lx\n", status );

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    status = NtNotifyChangeDirectoryFile(
                rootDirHandle,
                (HANDLE) NULL,
                (PIO_APC_ROUTINE) NULL,
                (PVOID) NULL,
                &ioStatusBlock,
                buffer,
                sizeof( buffer ),
                FILE_NOTIFY_CHANGE_NAME |
                FILE_NOTIFY_CHANGE_ATTRIBUTES |
                FILE_NOTIFY_CHANGE_SIZE |
                FILE_NOTIFY_CHANGE_LAST_WRITE |
                FILE_NOTIFY_CHANGE_LAST_ACCESS |
                FILE_NOTIFY_CHANGE_CREATION |
                FILE_NOTIFY_CHANGE_EA |
                FILE_NOTIFY_CHANGE_SECURITY,
                FALSE );

    printf("Notify change directory status = %lx\n", status );

    if ( !NT_SUCCESS( status )) {
        return FALSE;
    }

    status = NtWaitForSingleObject( rootDirHandle, TRUE, NULL );
    printf( "NtWaitForSingleObject returns %lx\n", status );

    status = ioStatusBlock.Status;
    printf( "Find notify final status = %d\n", status );

    return( (BOOLEAN)NT_SUCCESS( status ));
}


BOOLEAN
QueryVolumeTest(
    VOID
    )
{
    HANDLE fsHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFILE_FS_ATTRIBUTE_INFORMATION fsAttributeInfo;

    RtlInitUnicodeString( &nameString, L"\\Device\\Mailslot" );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to open mailslot fs \"%wZ\"\n", &nameString );

    status = NtOpenFile (
                &fsHandle,
                GENERIC_READ,
                &objectAttributes,
                &ioStatusBlock,
                0,
                0L
                );

    printf( "MSFS open status = %lx\n", status );

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    status = NtQueryVolumeInformationFile(
                fsHandle,
                &ioStatusBlock,
                Buffer,
                sizeof( Buffer ),
                FileFsAttributeInformation );

    printf("Query volume status = %lx\n", status );

    if ( !NT_SUCCESS( status )) {
        return FALSE;
    }

    status = ioStatusBlock.Status;
    printf( "Query volume final status = %d\n", status );

    fsAttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)Buffer;
    printf ("  FileSystemAttributes       = %lx\n",
              fsAttributeInfo->FileSystemAttributes);
    printf ("  MaximumComponentNameLength = %ld\n",
              fsAttributeInfo->MaximumComponentNameLength);
    printf ("  FileSystemNameLength       = %ld\n",
              fsAttributeInfo->FileSystemNameLength);

    printf ("  FileSystemName             = ");
    DisplayUnicode(fsAttributeInfo->FileSystemName,
                   fsAttributeInfo->FileSystemNameLength);
    putchar ('\n');

    return( (BOOLEAN)NT_SUCCESS( status ));
}

VOID
DisplayUsage(
    PSZ ProgramName
    )
{
    printf( "Usage: %s \\Device\\Mailslot\\Msname\n", ProgramName);
}


BOOLEAN
OpenMailslot(
    PSZ Name,
    PHANDLE Handle
    )
{
    STRING ansiString;
    UNICODE_STRING nameString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    RtlInitString(&ansiString, Name );
    RtlOemStringToUnicodeString(&nameString, &ansiString, TRUE);

    //
    //  Open the mailslot
    //

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to open mailslot \"%wZ\"\n", &nameString );

    status = NtOpenFile (
                Handle,
                FILE_WRITE_DATA | SYNCHRONIZE,
                &objectAttributes,
                &ioStatusBlock,
                FILE_SHARE_WRITE | FILE_SHARE_READ,
                0L
                );

    printf( "Status = %x\n", status );

    RtlFreeUnicodeString(&nameString);
    return ( (BOOLEAN) NT_SUCCESS( status ) );
}


BOOLEAN
WriteTest(
    IN HANDLE Handle
    )
{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    static ULONG messageNumber = 0;

    messageNumber++;
    sprintf( Buffer, "Sending message number %d\n", messageNumber);

    status = NtWriteFile (
                Handle,
                0L,
                NULL,
                NULL,
                &ioStatusBlock,
                Buffer,
                MESSAGE_SIZE,
                NULL,
                NULL);

    printf ("Write status = %lx\n", status );

    if (NT_SUCCESS(status)) {
        status = NtWaitForSingleObject( Handle, TRUE, NULL );
        printf( "NtWaitForSingleObject returns %lx\n", status );
        status = ioStatusBlock.Status;
    }

    printf( "NtWriteFileFinalStatus returns %lx\n", status );

    return ( (BOOLEAN)NT_SUCCESS( status ) );
}

DisplayUnicode(
    IN WCHAR *UnicodeString,
    IN ULONG Length
    )
{
    while (Length > 0) {
        putchar( (CHAR)*UnicodeString );
        UnicodeString++;
        Length -= 2;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\volinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the get / set volume information routines for
    MSFS called by the dispatch driver.

    Setting volume information is currently unimplemented in MSFS.

Author:

     Manny Weiser (mannyw)    31-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
// Local procedure prototypes.
//

NTSTATUS
MsCommonQueryVolumeInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MsQueryAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
MsQueryFsVolumeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
MsQueryFsSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
MsQueryFsFullSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

NTSTATUS
MsQueryFsDeviceInfo (
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonQueryVolumeInformation )
#pragma alloc_text( PAGE, MsFsdQueryVolumeInformation )
#pragma alloc_text( PAGE, MsQueryAttributeInfo )
#pragma alloc_text( PAGE, MsQueryFsVolumeInfo )
#pragma alloc_text( PAGE, MsQueryFsSizeInfo )
#pragma alloc_text( PAGE, MsQueryFsDeviceInfo )
#pragma alloc_text( PAGE, MsQueryFsFullSizeInfo )
#endif

NTSTATUS
MsFsdQueryVolumeInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtQueryVolumeInformationFile
    API calls.

Arguments:

    MsfsDeviceObject - Supplies a pointer to the device object to use.

    Irp - Supplies a pointer to the Irp to process.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdQueryVolumeInformation\n", 0);

    //
    // Call the common query volume information routine.
    //

    FsRtlEnterFileSystem();

    status = MsCommonQueryVolumeInformation( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdQueryVolumeInformation -> %08lx\n", status );

    return status;
}

NTSTATUS
MsCommonQueryVolumeInformation (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information.

Arguments:

    MsfsDeviceObject - The device object to use.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    ULONG length;
    ULONG bytesWritten = 0;
    FS_INFORMATION_CLASS fsInformationClass;
    PVOID buffer;

    NODE_TYPE_CODE nodeTypeCode;
    PVCB vcb;

    PVOID fsContext, fsContext2;

    PAGED_CODE();

    //
    // Get the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", irpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FsInformationClass = %08lx\n", irpSp->Parameters.QueryVolume.FsInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", (ULONG)Irp->AssociatedIrp.SystemBuffer);

    //
    // Find out who are.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            &fsContext,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Mailslot is disconnected from us\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonQueryInformation -> %08lx\n", status );
        return status;
    }

    //
    // Decide how to handle this request.  A user can query information
    // on a VCB only.
    //

    switch (nodeTypeCode) {

    case MSFS_NTC_VCB:

        vcb = (PVCB)fsContext;
        break;

    case MSFS_NTC_ROOT_DCB :

        //
        // Explorer calls us like this. Ship from the root dir to the volume.
        //
        vcb = (PVCB) ((PROOT_DCB_CCB)fsContext2)->Vcb;
        MsReferenceVcb (vcb);
        MsDereferenceRootDcb ((PROOT_DCB) fsContext);
        break;

    default:           // This is not a volume control block.

        DebugTrace(0, Dbg, "Node type code is not incorrect\n", 0);

        MsDereferenceNode( (PNODE_HEADER)fsContext );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1,
                   Dbg,
                   "MsCommonQueryVolumeInformation -> STATUS_INVALID_PARAMETER\n",
                    0);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make local copies of the input parameters.
    //

    length = irpSp->Parameters.QueryVolume.Length;
    fsInformationClass = irpSp->Parameters.QueryVolume.FsInformationClass;
    buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Now acquire shared access to the VCB
    //

    MsAcquireSharedVcb( vcb );

    try {

        //
        // Decide how to handle the request.
        //

        switch (fsInformationClass) {

        case FileFsAttributeInformation:

            status = MsQueryAttributeInfo( vcb, buffer, length, &bytesWritten );
            break;

        case FileFsVolumeInformation:

            status = MsQueryFsVolumeInfo( vcb, buffer, length, &bytesWritten );
            break;

        case FileFsSizeInformation:

            status = MsQueryFsSizeInfo( vcb, buffer, length, &bytesWritten );
            break;

        case FileFsFullSizeInformation:

            status = MsQueryFsFullSizeInfo( vcb, buffer, length, &bytesWritten );
            break;

        case FileFsDeviceInformation:

            status = MsQueryFsDeviceInfo( vcb, buffer, length, &bytesWritten );
            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            break;
        }


    } finally {

        MsReleaseVcb( vcb );

        MsDereferenceVcb( vcb );
        //
        // Set the information field to the number of bytes actually
        // filled in and then complete the request.
        //

        Irp->IoStatus.Information = bytesWritten;

        MsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "MsCommonQueryVolumeInformation -> %08lx\n", status );
    }

    return status;
}


NTSTATUS
MsQueryAttributeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine performs the query fs attribute information operation.

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(0, Dbg, "QueryFsAttributeInfo...\n", 0);

    //
    // See how many bytes of the file system name we can copy.
    //

    Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );


    if ( Length >= Vcb->FileSystemName.Length ) {

        status = STATUS_SUCCESS;

        *BytesWritten = Vcb->FileSystemName.Length;

    } else {

        status = STATUS_BUFFER_OVERFLOW;

        *BytesWritten = Length;
    }

    //
    // Fill in the attribute information.
    //

    Buffer->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES;
    Buffer->MaximumComponentNameLength = MAXIMUM_FILENAME_LENGTH;

    //
    // And copy over the file name and its length.
    //

    RtlCopyMemory (&Buffer->FileSystemName[0],
                   &Vcb->FileSystemName.Buffer[0],
                   *BytesWritten);

    Buffer->FileSystemNameLength = *BytesWritten;

    //
    // Now account for the fixed part of the structure
    //
    *BytesWritten += FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );

    return status;
}

NTSTATUS
MsQueryFsVolumeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{
    ULONG BytesToCopy;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    Buffer->VolumeCreationTime = Vcb->CreationTime;
    Buffer->VolumeSerialNumber = 0;

    Buffer->SupportsObjects = FALSE;

    Length -= FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] );
    //
    //  Check if the buffer we're given is long enough
    //

    BytesToCopy = sizeof (MSFS_VOLUME_LABEL) - sizeof (WCHAR);

    if (Length < BytesToCopy) {

        BytesToCopy = Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = BytesToCopy;

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->VolumeLabel[0],
                       MSFS_VOLUME_LABEL,
                       BytesToCopy );
    }

    *BytesWritten = FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] ) + BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    return Status;
}

NTSTATUS
MsQueryFsSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine implements the query size info call

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    Buffer->TotalAllocationUnits.QuadPart = 0;
    Buffer->AvailableAllocationUnits.QuadPart = 0;
    Buffer->SectorsPerAllocationUnit = 0;
    Buffer->BytesPerSector = 0;

    *BytesWritten = sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}

NTSTATUS
MsQueryFsFullSizeInfo (
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine implements the query full size info call

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    RtlZeroMemory( Buffer, sizeof(FILE_FS_FULL_SIZE_INFORMATION) );


    *BytesWritten = sizeof(FILE_FS_FULL_SIZE_INFORMATION);

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}

NTSTATUS
MsQueryFsDeviceInfo (
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    )

/*++

Routine Description:

    This routine implements the query size info call

Arguments:

    Vcb - Supplies the VCB to query.

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

    BytesWritten - Returns the number of bytes written to the buffer.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    Buffer->Characteristics = 0;
    Buffer->DeviceType = FILE_DEVICE_MAILSLOT;

    //
    //  Adjust the length variable
    //

    *BytesWritten = sizeof( FILE_FS_DEVICE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\writesup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    writesup.c

Abstract:

    This module implements the write support routine.  This is a common
    write function that is called by write and mailslot write.

Author:

    Manny Weiser (mannyw)   16-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsWriteDataQueue )
#endif

NTSTATUS
MsWriteDataQueue (
    IN PDATA_QUEUE WriteQueue,
    IN PUCHAR WriteBuffer,
    IN ULONG WriteLength
    )

/*++

Routine Description:

    This function writes data from the write buffer into read entries in
    the write queue.  It will also dequeue entries in the queue as necessary.


Arguments:

    WriteQueue - Provides the write queue to process.

    WriteBuffer - Provides the buffer from which to read the data.

    WriteLength  - Provides the length, in bytes, of WriteBuffer.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED if not all the data was written,
    other status codes as appropriate.

--*/

{
    NTSTATUS status;
    BOOLEAN result;

    PDATA_ENTRY dataEntry;
    PLIST_ENTRY listEntry;
    PFCB fcb;

    PUCHAR readBuffer;
    ULONG readLength;
    PIRP readIrp;
    NTSTATUS readStatus = STATUS_UNSUCCESSFUL;

    PWORK_CONTEXT workContext;
    PKTIMER timer;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsWriteDataQueue\n", 0);
    DebugTrace( 0, Dbg, "WriteQueue  = %08lx\n", (ULONG)WriteQueue);
    DebugTrace( 0, Dbg, "WriteBuffer = %08lx\n", (ULONG)WriteBuffer);
    DebugTrace( 0, Dbg, "WriteLength = %08lx\n", WriteLength);

    //
    // Now while the write queue has some read entries in it and
    // we have not successfully completed a read then we'll do the
    // following main loop.
    //

    status = STATUS_MORE_PROCESSING_REQUIRED;

    for (listEntry = MsGetNextDataQueueEntry( WriteQueue );

         (MsIsDataQueueReaders(WriteQueue) &&
          status == STATUS_MORE_PROCESSING_REQUIRED);

         listEntry = MsGetNextDataQueueEntry( WriteQueue )) {

        dataEntry = CONTAINING_RECORD( listEntry, DATA_ENTRY, ListEntry );
        readBuffer = dataEntry->DataPointer;
        readLength = dataEntry->DataSize;

        DebugTrace(0, Dbg, "Top of write loop...\n", 0);
        DebugTrace(0, Dbg, "ReadBuffer      = %08lx\n", (ULONG)readBuffer);
        DebugTrace(0, Dbg, "ReadLength      = %08lx\n", readLength);


        //
        // If the buffer for this read operation is large enough
        // copy the data.
        //

        if ( readLength >= WriteLength ) {

            //
            // Copy the data from the write buffer to the read buffer. This may take an exception
            // because its a raw user mode buffer
            //

            status = readStatus = STATUS_SUCCESS;

            try {

                RtlCopyMemory (readBuffer,
                               WriteBuffer,
                               WriteLength);

            } except (EXCEPTION_EXECUTE_HANDLER) {

                return GetExceptionCode ();

            }

        } else {

            //
            // This read buffer was overflowed.
            //

            WriteLength = 0;
            readStatus = STATUS_BUFFER_TOO_SMALL;

        }

        //
        // We are about to complete a read IRP, so dequeue it.
        //

        readIrp = MsRemoveDataQueueEntry( WriteQueue, dataEntry );
        if ( readIrp == NULL) {
           //
           // Cancel routine was already running for this IRP. Ignore it as it will be completed by
           // cancel code. Force the loop for the next read irp if there is one.
           //
           status = STATUS_MORE_PROCESSING_REQUIRED;
           continue;
        }
        //
        // Update the FCB last access time and complete the read request.
        //

        fcb = CONTAINING_RECORD( WriteQueue, FCB, DataQueue );
        if ( NT_SUCCESS( readStatus ) ) {
            KeQuerySystemTime( &fcb->Specific.Fcb.LastAccessTime );
        }

        readIrp->IoStatus.Information = WriteLength;
        MsCompleteRequest( readIrp, readStatus );

    }

    DebugTrace(0, Dbg, "Finished loop...\n", 0);

    //
    // At this point we've finished off all of the read entries in the
    // queue and we might not have written the write data.  If that
    // is the case then we'll set our result to FALSE otherwise we're
    // done so we'll return TRUE.
    //

    if ( status == STATUS_MORE_PROCESSING_REQUIRED ) {

        ASSERT( !MsIsDataQueueReaders( WriteQueue ));
    }

    DebugTrace(-1, Dbg, "MsWriteDataQueue -> %08lx\n", status);
    return status;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\tmsserv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tmsserv.c

Abstract:

    This module contains a user mode mailslot server test program.

    This test program can be built from the command line using the
    command 'nmake UMTEST=tmsserv'.

Author:

    Manny Weiser (mannyw)   11-Jan-91

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <ntioapi.h>

//
// Local definitions
//

BOOLEAN
CreateMailslot(
    PSZ Name,
    PHANDLE Handle
    );

BOOLEAN
QueryDirectoryTest(
    VOID
    );


BOOLEAN
QueryInfoTest(
    HANDLE Handle
    );

BOOLEAN
PeekTest(
    HANDLE Handle
    );

BOOLEAN
ReadTest(
    HANDLE Handle
    );

VOID
DisplayUsage(
    PSZ ProgramName
    );

VOID
DisplayTime(
    IN PLARGE_INTEGER
    );

DisplayUnicode(
    IN WCHAR *UnicodeString,
    IN ULONG Length
    );

#define MESSAGE_SIZE    100L
#define MAILSLOT_SIZE   (10 * MESSAGE_SIZE)

#define PEEK_PARAMETER_BYTES 16
#define READ_PARAMETER_BYTES 16
#define MAILSLOT_PARAMETER_BYTES 16    // Max of peek and read param bytes

char Buffer[1000];


int
main(argc, argv)

int argc;
char **argv;

{
    HANDLE handle;
    ULONG ms, time;
    LARGE_INTEGER delayTime;
    int i;

    if (argc < 2) {
        DisplayUsage(argv[0]);
        return 1;
    }

    if ( !CreateMailslot( argv[1], &handle ) ) {
        return 2;
    }

    for (i = 2; i < argc; i++) {

        switch ( *argv[i] ) {

        case 'r':
            if ( !ReadTest( handle ) ) {
                return 3;
            }
            break;

        case 'd':
            if ( !QueryDirectoryTest() ) {
                return 3;
            }
            break;

        case 'p':
            if ( !PeekTest( handle ) ) {
                return 3;
            }
            break;

        case 'q':
            if ( !QueryInfoTest( handle ) ) {
                return 3;
            }
            break;

        case 's':
            time = atoi( argv[i] + 1);

            printf( "%s: sleeping for %lu tenths of a second\n",
                      argv[0],
                      time );

            ms = time * 100;
            delayTime = LiNMul( ms, -10000 );
            NtDelayExecution( TRUE, (PLARGE_INTEGER)&delayTime );

            printf ("%s: awake\n", argv[0] );
            break;

        default:
            printf ("Unknown test ""%s""\n", argv[i] );
            break;

        }

    }

    printf( "Closing file\n" );
    NtClose( handle );

    printf( "%s exiting\n", argv[0] );
    return 0;
}


VOID
DisplayUsage(
    PSZ ProgramName
    )
{
    printf( "Usage: %s \\Device\\Mailslot\\Msname\n", ProgramName);
}


BOOLEAN
CreateMailslot(
    PSZ Name,
    PHANDLE Handle
    )
{
    NTSTATUS status;
    STRING ansiString;
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    LARGE_INTEGER readTimeout = { -1, -1 };  // Infinite read timeout

    RtlInitString(&ansiString, Name );
    RtlOemStringToUnicodeString(&nameString, &ansiString, TRUE);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to create mailslot \"%wZ\"\n", &nameString );

    status = NtCreateMailslotFile (
                Handle,
                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                &objectAttributes,
                &ioStatusBlock,
                0,
                0,
                MESSAGE_SIZE,
                &readTimeout
                );

    printf( "Open Status = %lx\n", status );
    RtlFreeUnicodeString(&nameString);

    return ( (BOOLEAN) NT_SUCCESS(status));
}

BOOLEAN
QueryDirectoryTest(
    VOID
    )
{
    HANDLE rootDirHandle;
    BOOLEAN done;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFILE_FULL_DIR_INFORMATION dirInfo;

    RtlInitUnicodeString(&nameString, L"\\Device\\Mailslot\\" );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    printf( "Attempting to open mailslot directory \"%wZ\"\n", &nameString );

    status = NtOpenFile (
                &rootDirHandle,
                GENERIC_READ,
                &objectAttributes,
                &ioStatusBlock,
                0,
                0L
                );

    RtlFreeUnicodeString(&nameString);
    printf( "MSFS root dir open status = %lx\n", status );

    status = NtQueryDirectoryFile(
                rootDirHandle,
                0,
                NULL,
                NULL,
                &ioStatusBlock,
                (PVOID)Buffer,
                sizeof(Buffer),
                FileFullDirectoryInformation,
                FALSE,
                NULL,
                FALSE );

    printf("Query directory status = %lx\n", status );
    printf("Query directory information %d\n", ioStatusBlock.Information );

    if ( NT_SUCCESS( status )) {
        done = FALSE;
        dirInfo = (PFILE_FULL_DIR_INFORMATION)Buffer;
    } else {
        done = TRUE;
    }


    while (!done) {
        printf ("NextEntry        = %d\n", dirInfo->NextEntryOffset);
        printf ("FileIndex        = %ld\n", dirInfo->FileIndex );
        printf ("CreationTime     = ");
        DisplayTime( &dirInfo->CreationTime );
        printf ("\nLastAccessTime   = ");
        DisplayTime( &dirInfo->LastAccessTime );
        printf ("\nLastWriteTime    = ");
        DisplayTime( &dirInfo->LastWriteTime );
        printf ("\nChangeTime       = ");
        DisplayTime( &dirInfo->ChangeTime );
        printf ("\nEnd of file      = %lx%08lx\n",
                dirInfo->EndOfFile.HighPart,
                dirInfo->EndOfFile.LowPart );
        printf ("Allocation size  = %lx%08lx\n",
                dirInfo->AllocationSize.HighPart,
                dirInfo->AllocationSize.LowPart );
        printf ("File attributes  = %x\n",  dirInfo->FileAttributes );
        printf ("File name length = %x\n", dirInfo->FileNameLength );
        printf ("EA size          = %x\n", dirInfo->EaSize );
        printf ("File Name        = ");
        DisplayUnicode( dirInfo->FileName, dirInfo->FileNameLength );
        printf ("\n\n");

        if (dirInfo->NextEntryOffset == 0) {
            done = TRUE;
        }

        dirInfo = (PFILE_FULL_DIR_INFORMATION)
                     ((PCHAR)dirInfo + dirInfo->NextEntryOffset);
    }

    return( (BOOLEAN)NT_SUCCESS( status ));
}


BOOLEAN
QueryInfoTest(
    HANDLE Handle
    )
{
    PFILE_BASIC_INFORMATION basicInfo;
    PFILE_STANDARD_INFORMATION standardInfo;
    PFILE_INTERNAL_INFORMATION internalInfo;
    PFILE_EA_INFORMATION eaInfo;
    PFILE_POSITION_INFORMATION positionInfo;
    PFILE_NAME_INFORMATION nameInfo;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    status = NtQueryInformationFile( Handle,
                                     &ioStatusBlock,
                                     Buffer,
                                     MESSAGE_SIZE,
                                     FileAllInformation );

    printf ("\nBasic Information:\n");

    basicInfo = (PFILE_BASIC_INFORMATION)Buffer;
    printf ("    Creation time:    " );
    DisplayTime( &basicInfo->CreationTime );
    printf ("\n    Last access time: " );
    DisplayTime( &basicInfo->LastAccessTime );
    printf ("\n    Last write time:  " );
    DisplayTime( &basicInfo->LastWriteTime );
    printf ("\n    Change time:      " );
    DisplayTime( &basicInfo->ChangeTime );
    printf ("\n");

    printf ("\nStandard Information:\n");

    standardInfo = (PFILE_STANDARD_INFORMATION)(basicInfo + 1);
    printf ("    Number of links: %ld\n", standardInfo->NumberOfLinks );
    printf ("    Delete pending : %ld\n", standardInfo->DeletePending );
    printf ("    Directory      : %ld\n", standardInfo->Directory );

    printf ("\nInternal Information:\n");

    internalInfo = (PFILE_INTERNAL_INFORMATION)(standardInfo + 1);
    printf ("    Index Number   : %ld\n", internalInfo->IndexNumber );

    printf ("\nEa Information:\n");

    eaInfo = (PFILE_EA_INFORMATION)(internalInfo + 1);
    printf ("    No ea info\n" );

    printf ("\nPosition Information:\n");

    positionInfo = (PFILE_POSITION_INFORMATION)(eaInfo+1);
    printf ("    Current offset: %ld\n", positionInfo->CurrentByteOffset );

    printf ("\nName Information:\n");

    nameInfo = (PFILE_NAME_INFORMATION)(positionInfo + 1);
    printf ("    File name length: %ld\n", nameInfo->FileNameLength );
    printf ("    File name       : ");
    DisplayUnicode( nameInfo->FileName, nameInfo->FileNameLength );
    putchar ('\n');

    return TRUE;
}

BOOLEAN
PeekTest(
    HANDLE Handle
    )
{
    FILE_MAILSLOT_PEEK_BUFFER mailslotPeekBuffer;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    status = NtFsControlFile (
                Handle,
                0L,
                NULL,
                NULL,
                &ioStatusBlock,
                FSCTL_MAILSLOT_PEEK,
                &mailslotPeekBuffer,
                sizeof(mailslotPeekBuffer),
                Buffer,
                MESSAGE_SIZE );

    printf( "    ReadDataAvailable = %lx\n", mailslotPeekBuffer.ReadDataAvailable );
    printf( "    NumberOfMessages  = %lx\n", mailslotPeekBuffer.NumberOfMessages);
    printf( "    MessageLength     = %lx\n", mailslotPeekBuffer.MessageLength);
    return ( (BOOLEAN) NT_SUCCESS( status ) );
}


BOOLEAN
ReadTest(
    HANDLE Handle
    )
{
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;

    status = NtReadFile(
                Handle,
                0L,
                NULL,
                NULL,
                &ioStatusBlock,
                Buffer,
                MESSAGE_SIZE,
                NULL,
                NULL);


    if (NT_SUCCESS(status)) {
        status = NtWaitForSingleObject( Handle, TRUE, NULL );
        printf( "NtWaitForSingleObject returns %lx\n", status );
        status = ioStatusBlock.Status;
    }

    printf( "NtReadFileFinalStatus returns %lx\n", status );

    if (NT_SUCCESS(status)) {
        printf ("message is ""%s""\n", Buffer );
    }

    return ( (BOOLEAN)NT_SUCCESS( status ) );
}
VOID
DisplayTime(
    IN PLARGE_INTEGER Time
    )

{
    TIME_FIELDS timeFields;

    RtlTimeToTimeFields( Time, &timeFields );

    printf("%02d/%02d/%04d @ %02d:%02d:%02d.%d",
           timeFields.Month,
           timeFields.Day,
           timeFields.Year,
           timeFields.Hour,
           timeFields.Minute,
           timeFields.Second,
           timeFields.Milliseconds );

}

DisplayUnicode(
    IN WCHAR *UnicodeString,
    IN ULONG Length
    )
{
    while (Length > 0) {
        putchar( (CHAR)*UnicodeString );
        UnicodeString++;
        Length -= 2;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the file write routines for MSFS called by the
    dispatch driver.

Author:

    Manny Weiser (mannyw)    16-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

//
// local procedure prototypes.
//

NTSTATUS
MsCommonWrite (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsCommonWrite )
#pragma alloc_text( PAGE, MsFsdWrite )
#endif

NTSTATUS
MsFsdWrite (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtWriteFile API call.

Arguments:

    MsfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsFsdWrite\n", 0);

    FsRtlEnterFileSystem();

    status = MsCommonWrite( MsfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    // Return to the caller.
    //

    DebugTrace(-1, Dbg, "MsFsdWrite -> %08lx\n", status );

    return status;
}

NTSTATUS
MsCommonWrite (
    IN PMSFS_DEVICE_OBJECT MsfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for writing to a mailslot file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    NODE_TYPE_CODE nodeTypeCode;
    PCCB ccb;
    PFCB fcb;
    PVOID fsContext2;

    PIRP writeIrp;
    PUCHAR writeBuffer;
    ULONG writeLength;
    PDATA_QUEUE writeQueue;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "MsCommonWrite\n", 0);
    DebugTrace( 0, Dbg, "MsfsDeviceObject = %08lx\n", (ULONG)MsfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG)irpSp->FileObject);

    //
    //  Get the CCB and make sure it isn't closing.
    //

    if ((nodeTypeCode = MsDecodeFileObject( irpSp->FileObject,
                                            (PVOID *)&ccb,
                                            &fsContext2 )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "The mailslot is disconnected\n", 0);

        MsCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED );
        status = STATUS_FILE_FORCED_CLOSED;

        DebugTrace(-1, Dbg, "MsCommonWrite -> %08lx\n", status );
        return status;
    }

    //
    // Allow write operations only to the client side of the mailslot.
    //

    if (nodeTypeCode != MSFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not the correct type", 0);
        MsDereferenceNode( &ccb->Header );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsCommonWrite -> %08lx\n", status );
        return status;

    }

    //
    // Get a pointer to the FCB for this CCB
    //

    fcb = ccb->Fcb;

    //
    // Make local copies of the input parameters to make things easier, and
    // initialize the main variables that describe the write command.
    //

    writeIrp = Irp;
    writeBuffer = Irp->UserBuffer;
    writeLength = irpSp->Parameters.Write.Length;

    writeIrp->IoStatus.Information = 0;
    writeQueue = &fcb->DataQueue;

    //
    // Make sure the write does not exceed the stated maximum.  If max is
    // zero, this means don't enforce.
    //

    if ( (writeQueue->MaximumMessageSize != 0) &&
         (writeLength > writeQueue->MaximumMessageSize) ) {

        DebugTrace(0, Dbg, "Write exceeds maximum message size", 0);
        MsDereferenceCcb( ccb );

        MsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "MsCommonWrite -> %08lx\n", status );
        return status;
    }

    //
    // Now acquire exclusive access to the FCB.
    //

    MsAcquireExclusiveFcb( fcb );


    //
    // Ensure that this CCB still belongs to an active open mailslot.
    //

    status = MsVerifyCcb( ccb );
    if (NT_SUCCESS (status)) {

        //
        // Now we'll call our common write data queue routine to
        // transfer data out of our write buffer into the data queue.
        // If the result of the call is FALSE then there were no queued
        // read operations and we must queue this write.
        //

        status = MsWriteDataQueue( writeQueue,
                                   writeBuffer,
                                   writeLength );


        if (status == STATUS_MORE_PROCESSING_REQUIRED)  {

            ASSERT( !MsIsDataQueueReaders( writeQueue ));

            DebugTrace(0, Dbg, "Add write to data queue\n", 0);

            //
            //  Add this write request to the write queue
            //

            status = MsAddDataQueueEntry( writeQueue,
                                          WriteEntries,
                                          writeLength,
                                          Irp,
                                          NULL );

        } else {

            DebugTrace(0, Dbg, "Complete the Write Irp\n", 0);


            //
            // Update the FCB last modification time.
            //
            if (NT_SUCCESS (status)) {
                writeIrp->IoStatus.Information = writeLength;
                KeQuerySystemTime( &fcb->Specific.Fcb.LastModificationTime );
            }
        }

    }

    MsReleaseFcb( fcb );

    MsDereferenceCcb( ccb );

    MsCompleteRequest( writeIrp, status );

    DebugTrace(-1, Dbg, "MsCommonWrite -> %08lx\n", status);

    return status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mailslot\verfysup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    verfysup.c

Abstract:

    This module implements the verify functions for MSFS.

Author:

    Manny Weiser (mannyw)    23-Jan-1991

Revision History:

--*/

#include "mailslot.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_VERIFY)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MsVerifyCcb )
#pragma alloc_text( PAGE, MsVerifyFcb )
#pragma alloc_text( PAGE, MsVerifyDcbCcb )
#endif


NTSTATUS
MsVerifyFcb (
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function verifies that an FCB is still active.  If it is active,
    the function  does nothing.  If it is inactive an error status is returned.

Arguments:

    PFCB - A pointer to the FCB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsVerifyFcb, Fcb = %08lx\n", (ULONG)Fcb);
    if ( Fcb->Header.NodeState != NodeStateActive ) {

        DebugTrace( 0, Dbg, "Fcb is not active\n", 0);
        return STATUS_FILE_INVALID;

    }

    DebugTrace(-1, Dbg, "MsVerifyFcb -> VOID\n", 0);
    return STATUS_SUCCESS;
}


NTSTATUS
MsVerifyCcb (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This function verifies that a CCB is still active.  If it is active,
    the function  does nothing.  If it is inactive an error status is raised.

Arguments:

    PCCB - A pointer to the CCB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsVerifyCcb, Ccb = %08lx\n", (ULONG)Ccb);
    if ( Ccb->Header.NodeState != NodeStateActive ) {

        DebugTrace( 0, Dbg, "Ccb is not active\n", 0);
        return STATUS_FILE_INVALID;

    }

    DebugTrace(-1, Dbg, "MsVerifyCcb -> VOID\n", 0);
    return STATUS_SUCCESS;
}

NTSTATUS
MsVerifyDcbCcb (
    IN PROOT_DCB_CCB Ccb
    )

/*++

Routine Description:

    This function verifies that a CCB is still active.  If it is active,
    the function  does nothing.  If it is inactive an error status is raised.

Arguments:

    PCCB - A pointer to the DCB CCB to verify.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MsVerifyCcb, Ccb = %08lx\n", (ULONG)Ccb);
    if ( Ccb->Header.NodeState != NodeStateActive ) {

        DebugTrace( 0, Dbg, "Ccb is not active\n", 0);
        return STATUS_FILE_INVALID;

    }

    DebugTrace(-1, Dbg, "MsVerifyCcb -> VOID\n", 0);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\attach.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       ATTACH.C
//
//  Contents:   This module contains routines for managing attached file
//              systems.
//
//  Functions:
//
//  History:    15 May 1992  PeterCo  Created.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "mupwml.h"

#define Dbg              (DEBUG_TRACE_ATTACH)

#ifdef ALLOC_PRAGMA

//
// The following are not pageable since they can be called at DPC level
//
// DfsVolumePassThrough
// DfsFilePassThrough
//

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsVolumePassThrough, public
//
//  Synopsis:   This is the main FSD routine that passes a request
//              on to an attached-to device, or to a redirected
//              file.
//
//  Arguments:  [DeviceObject] -- Supplies a pointer to the Dfs device
//                      object this request was aimed at.
//              [Irp] -- Supplies a pointer to the I/O request packet.
//
//  Returns:    [STATUS_INVALID_DEVICE_REQUEST] -- If the DeviceObject
//                      argument is of unknown type, or the type of file
//                      is invalid for the request being performed.
//
//              NT Status from calling the underlying file system that
//                      opened the file.
//
//--------------------------------------------------------------------

NTSTATUS
DfsVolumePassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;

    DfsDbgTrace(+1, Dbg, "DfsVolumePassThrough: Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    MUP_TRACE_HIGH(TRACE_IRP, DfsVolumePassThrough_Entry,
                   LOGPTR(DeviceObject)
                   LOGPTR(Irp)
                   LOGPTR(FileObject));

    DfsDbgTrace(0, Dbg, "DeviceObject    = %x\n", DeviceObject);
    DfsDbgTrace(0, Dbg, "Irp             = %x\n", Irp        );
    DfsDbgTrace(0, Dbg, "  MajorFunction = %x\n", IrpSp->MajorFunction );
    DfsDbgTrace(0, Dbg, "  MinorFunction = %x\n", IrpSp->MinorFunction );

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS && IrpSp->FileObject != NULL) {

        TYPE_OF_OPEN TypeOfOpen;
        PDFS_VCB Vcb;
        PDFS_FCB Fcb;

        TypeOfOpen = DfsDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb);

        DfsDbgTrace(0, Dbg, "Fcb = %08lx\n", Fcb);

        if (TypeOfOpen == RedirectedFileOpen) {

            //
            // Copy the stack from one to the next...
            //

            NextIrpSp = IoGetNextIrpStackLocation(Irp);

            (*NextIrpSp) = (*IrpSp);

            IoSetCompletionRoutine(Irp, NULL, NULL, FALSE, FALSE, FALSE);

            //
            //  ...and call the next device
            //

            Status = IoCallDriver( Fcb->TargetDevice, Irp );
            MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsVolumePassThrough_Error_IoCallDriver,
                                 LOGSTATUS(Status)
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject)
                                 LOGPTR(DeviceObject));

        } else {

            DfsDbgTrace(0, Dbg, "DfsVolumePassThrough: TypeOfOpen = %s\n",
                ((TypeOfOpen == UnopenedFileObject) ? "UnopenedFileObject":
                    (TypeOfOpen == LogicalRootDeviceOpen) ?
                        "LogicalRootDeviceOpen" : "???"));

            DfsDbgTrace(0, Dbg, "Irp             = %x\n", Irp);

            DfsDbgTrace(0, Dbg, " MajorFunction = %x\n", IrpSp->MajorFunction);

            DfsDbgTrace(0, Dbg, " MinorFunction = %x\n", IrpSp->MinorFunction);

            Status = STATUS_INVALID_DEVICE_REQUEST;
            MUP_TRACE_HIGH(ERROR, DfsVolumePassThrough_Error1, 
                           LOGSTATUS(Status)
                           LOGPTR(Irp)
                           LOGPTR(FileObject)
                           LOGPTR(DeviceObject));

            Irp->IoStatus.Status = Status;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);

        }

    } else {

        DfsDbgTrace(0, Dbg, "DfsVolumePassThrough: Unexpected Dev = %x\n",
                                DeviceObject);

        Status = STATUS_INVALID_DEVICE_REQUEST;

        MUP_TRACE_HIGH(ERROR, DfsVolumePassThrough_Error2, 
                       LOGSTATUS(Status)
                       LOGPTR(Irp)
                       LOGPTR(FileObject)
                       LOGPTR(DeviceObject));
        Irp->IoStatus.Status = Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DfsDbgTrace(-1, Dbg, "DfsVolumePassThrough: Exit -> %08lx\n", ULongToPtr(Status));

    MUP_TRACE_HIGH(TRACE_IRP, DfsVolumePassThrough_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(Irp)
                   LOGPTR(FileObject)
                   LOGPTR(DeviceObject));
    return Status;
}

//+-------------------------------------------------------------------
//
//  Function:   DfsFilePassThrough, public
//
//  Synopsis:   Like DfsVolumePassThrough, but used when the file object
//              has already been looked up, and the FCB for the file is
//              already known.  This is needed especially in close processing
//              to avoid a race between DfsLookupFcb (for a reused file object)
//              and DfsDetachFcb.
//
//  Arguments:  [pFcb] -- A pointer to an FCB for the file.
//              [Irp]  -- A pointer to the I/O request packet.
//
//  Returns:    NTSTATUS - the return value from IoCallDriver.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFilePassThrough(
    IN PDFS_FCB pFcb,
    IN PIRP Irp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;


    DfsDbgTrace(+1, Dbg, "DfsFilePassThrough: Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Copy the stack from one to the next...
    //

    NextIrpSp = IoGetNextIrpStackLocation(Irp);

    (*NextIrpSp) = (*IrpSp);

    IoSetCompletionRoutine(Irp, NULL, NULL, FALSE, FALSE, FALSE);

    //
    //  ...and call the next device
    //

    Status = IoCallDriver( pFcb->TargetDevice, Irp );

    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsFilePassThrough_Error_IoCallDriver,
                         LOGSTATUS(Status)
                         LOGPTR(Irp));
    DfsDbgTrace(-1, Dbg, "DfsFilePassThrough: Exit -> %08lx\n", ULongToPtr(Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements the file cleanup routine for MUP.

Author:

    Manny Weiser (mannyw)    28-Dec-1991

Revision History:

--*/

#include "mup.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  local procedure prototypes
//

NTSTATUS
MupCleanupVcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb
    );

NTSTATUS
MupCleanupFcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupCleanup )
#pragma alloc_text( PAGE, MupCleanupFcb )
#pragma alloc_text( PAGE, MupCleanupVcb )
#endif


NTSTATUS
MupCleanup (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the the cleanup IRP.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the Irp

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    BLOCK_TYPE blockType;
    PVOID fsContext, fsContext2;
    PFILE_OBJECT FileObject;

    MupDeviceObject;
    PAGED_CODE();
    

    if (MupEnableDfs) {
        if ((MupDeviceObject->DeviceObject.DeviceType == FILE_DEVICE_DFS) ||
                (MupDeviceObject->DeviceObject.DeviceType ==
                    FILE_DEVICE_DFS_FILE_SYSTEM)) {
            status = DfsFsdCleanup((PDEVICE_OBJECT) MupDeviceObject, Irp);
            return( status );
        }
    }


    FsRtlEnterFileSystem();

    try {

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        FileObject = irpSp->FileObject;
        MUP_TRACE_HIGH(TRACE_IRP, MupCleanup_Entry,
               LOGPTR(MupDeviceObject)
               LOGPTR(Irp)
               LOGPTR(FileObject));

        DebugTrace(+1, Dbg, "MupCleanup\n", 0);
        DebugTrace( 0, Dbg, "MupDeviceObject = %08lx\n", (ULONG)MupDeviceObject);
        DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG)Irp);
        DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG)irpSp->FileObject);

        //
        // Get the a referenced pointer to the node and make sure it is
        // not being closed.
        //

        if ((blockType = MupDecodeFileObject( irpSp->FileObject,
                                              &fsContext,
                                              &fsContext2 )) == BlockTypeUndefined) {

            DebugTrace(0, Dbg, "The file is closed\n", 0);

            FsRtlExitFileSystem();

            MupCompleteRequest( Irp, STATUS_INVALID_HANDLE );
            status = STATUS_INVALID_HANDLE;

            DebugTrace(-1, Dbg, "MupCleanup -> %08lx\n", status );
            MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, MupCleanup_Error_FileClosed, 
                                 LOGSTATUS(status)
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject)
                                 LOGPTR(MupDeviceObject));
            return status;
        }

        //
        // Decide how to handle this IRP.
        //

        switch ( blockType ) {


        case BlockTypeVcb:       // Cleanup MUP

            status = MupCleanupVcb( MupDeviceObject,
                                    Irp,
                                    (PVCB)fsContext
                                    );

            MupCompleteRequest( Irp, STATUS_SUCCESS );
            MupDereferenceVcb( (PVCB)fsContext );

            //
            // Cleanup the UNC Provider
            //

            if ( fsContext2 != NULL ) {
                MupCloseUncProvider((PUNC_PROVIDER)fsContext2 );
                MupDereferenceUncProvider( (PUNC_PROVIDER)fsContext2 );

                MupAcquireGlobalLock();
                MupProviderCount--;
                MupReleaseGlobalLock();
            }

            status = STATUS_SUCCESS;
            break;

        case BlockTypeFcb:

            if (((PFCB)fsContext)->BlockHeader.BlockState == BlockStateActive) {
	       MupCleanupFcb( MupDeviceObject,
                                       Irp,
                                       (PFCB)fsContext
                                       );
	       status = STATUS_SUCCESS;
	    }
	    else {
	      status = STATUS_INVALID_HANDLE;
              MUP_TRACE_HIGH(ERROR, MupCleanup_Error1, 
                             LOGSTATUS(status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject)
                             LOGPTR(MupDeviceObject));
	    }

            MupCompleteRequest( Irp, STATUS_SUCCESS );
            MupDereferenceFcb( (PFCB)fsContext );

            break;

    #ifdef MUPDBG
        default:

            //
            // This is not one of ours.
            //

            KeBugCheckEx( FILE_SYSTEM, 2, 0, 0, 0 );
            break;
    #endif

        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();

    }

    FsRtlExitFileSystem();

    MUP_TRACE_HIGH(TRACE_IRP, MupCleanup_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(Irp)
                   LOGPTR(FileObject)
                   LOGPTR(MupDeviceObject));
    DebugTrace(-1, Dbg, "MupCleanup -> %08lx\n", status);
    return status;
}



NTSTATUS
MupCleanupVcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb
    )

/*++

Routine Description:

    The routine cleans up a VCB.

Arguments:

    MupDeviceObject - A pointer the the MUP device object.

    Irp - Supplies the IRP associated with the cleanup.

    Vcb - Supplies the VCB for the MUP.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;

    MupDeviceObject;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCleanupVcb...\n", 0);

    //
    //  Now acquire exclusive access to the Vcb
    //

    ExAcquireResourceExclusiveLite( &MupVcbLock, TRUE );
    status = STATUS_SUCCESS;

    try {

        //
        // Ensure that this VCB is still active.
        //

        MupVerifyBlock( Vcb, BlockTypeVcb );

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        IoRemoveShareAccess( irpSp->FileObject,
                             &Vcb->ShareAccess );


    } finally {

        ExReleaseResourceLite( &MupVcbLock );
        DebugTrace(-1, Dbg, "MupCleanupVcb -> %08lx\n", status);
    }

    //
    //  And return to our caller
    //

    return status;
}


NTSTATUS
MupCleanupFcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    The routine cleans up a FCB.

Arguments:

    MupDeviceObject - A pointer the the MUP device object.

    Irp - Supplies the IRP associated with the cleanup.

    Vcb - Supplies the VCB for the MUP.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN holdingGlobalLock;
    PLIST_ENTRY listEntry, nextListEntry;
    PCCB ccb;

    MupDeviceObject;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCleanupVcb...\n", 0);

    //
    //  Now acquire exclusive access to the Vcb
    //

    MupAcquireGlobalLock();
    holdingGlobalLock = TRUE;
    status = STATUS_SUCCESS;

    try {

        //
        // Ensure that this FCB is still active.
        //

        MupVerifyBlock( Fcb, BlockTypeFcb );

        Fcb->BlockHeader.BlockState = BlockStateClosing;

        MupReleaseGlobalLock();
        holdingGlobalLock = FALSE;

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        // Loop through the list of CCBs, and release the open reference
        // to each one.  We must be careful because:
        //
        //   (1)  We cannot dereference the Ccb with the CcbListLock held.
        //   (2)  Dereferncing a Ccb may cause it to be removed from this
        //        list and freed.
        //

        ACQUIRE_LOCK( &MupCcbListLock );

        listEntry = Fcb->CcbList.Flink;

        while ( listEntry != &Fcb->CcbList ) {

            nextListEntry = listEntry->Flink;
            RELEASE_LOCK( &MupCcbListLock );

            ccb = CONTAINING_RECORD( listEntry, CCB, ListEntry );
            MupDereferenceCcb( ccb );

            ACQUIRE_LOCK( &MupCcbListLock );

            listEntry = nextListEntry;
        }

        RELEASE_LOCK( &MupCcbListLock );

    } finally {

        if ( holdingGlobalLock ) {
            MupReleaseGlobalLock();
        }

        DebugTrace(-1, Dbg, "MupCleanupFcb -> %08lx\n", status);
    }

    //
    //  And return to our caller
    //

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\block.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    block.c

Abstract:

    This module implements block management functions.

Author:

    Manny Weiser (mannyw)    12-29-91

Revision History:

--*/

#include "mup.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_BLOCK)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupAllocateMasterIoContext )
#pragma alloc_text( PAGE, MupAllocateMasterQueryContext )
#pragma alloc_text( PAGE, MupAllocatePrefixEntry )
#pragma alloc_text( PAGE, MupAllocateUncProvider )
#pragma alloc_text( PAGE, MupCalculateTimeout )
#pragma alloc_text( PAGE, MupCloseUncProvider )
#pragma alloc_text( PAGE, MupCreateCcb )
#pragma alloc_text( PAGE, MupCreateFcb )
#pragma alloc_text( PAGE, MupDereferenceVcb )
#pragma alloc_text( INIT, MupInitializeVcb )
#endif

VOID
MupInitializeVcb(
    IN PVCB Vcb
    )

/*++

Routine Description:

    The routine initializes the VCB for the MUP.

Arguments:

    VCB - A pointer to the MUP VCB.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupInitializeVcb\n", 0);

    RtlZeroMemory( Vcb, sizeof( VCB ) );

    Vcb->BlockHeader.BlockType = BlockTypeVcb;
    Vcb->BlockHeader.BlockState = BlockStateActive;
    Vcb->BlockHeader.ReferenceCount = 1;
    Vcb->BlockHeader.BlockSize = sizeof( VCB );

    DebugTrace(-1, Dbg, "MupInitializeVcb -> VOID\n", 0);
}

VOID
MupDereferenceVcb(
    PVCB Vcb
    )
{
    LONG result;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupDereferenceVcb\n", 0 );

    result = InterlockedDecrement(
                 &Vcb->BlockHeader.ReferenceCount
                 );

    DebugTrace( 0, Dbg, "ReferenceCount = %d\n", Vcb->BlockHeader.ReferenceCount );

    if ( result == 0 ) {

        KeBugCheckEx( FILE_SYSTEM, 3, 0, 0, 0 );
    }

    DebugTrace( -1, Dbg, "MupDereferenceVcb -> VOID\n", 0 );
}


PFCB
MupCreateFcb(
    VOID
    )

/*++

Routine Description:

    This routine allocates an FCB block

Arguments:

    None.

Return Value:

    A pointer to the allocated FCB.

--*/

{
    PFCB fcb;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupCreateFcb\n", 0 );

    //
    // Attempt to allocate memory.
    //

    fcb = ExAllocatePoolWithTag(
                PagedPool,
                sizeof(FCB),
                ' puM');

    if (fcb == NULL) {

        return NULL;

    }

    //
    // Initialize the UNC provider block header
    //

    fcb->BlockHeader.BlockType = BlockTypeFcb;
    fcb->BlockHeader.BlockState = BlockStateActive;
    fcb->BlockHeader.ReferenceCount = 1;
    fcb->BlockHeader.BlockSize = sizeof( FCB );

    InitializeListHead( &fcb->CcbList );

    DebugTrace( -1, Dbg, "MupCreateFcb -> 0x%8lx\n", fcb );
    return fcb;


}

VOID
MupDereferenceFcb(
    PFCB Fcb
    )
{
    LONG result;

    ASSERT( Fcb->BlockHeader.BlockType == BlockTypeFcb );

    DebugTrace( +1, Dbg, "MupDereferenceFcb\n", 0 );

    result = InterlockedDecrement(
                 &Fcb->BlockHeader.ReferenceCount
                 );

    DebugTrace( 0, Dbg, "ReferenceCount = %d\n", Fcb->BlockHeader.ReferenceCount);

    if ( result == 0 ) {

        ASSERT( IsListEmpty( &Fcb->CcbList ) );

        MupFreeFcb( Fcb );
    }

    DebugTrace( -1, Dbg, "MupDereferenceFcb -> VOID\n", 0 );

}

VOID
MupFreeFcb(
    PFCB Fcb
    )

/*++

Routine Description:

    This routine frees an FCB block

Arguments:

    A pointer to the FCB block to free.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeFcb\n", 0 );
    ASSERT( Fcb->BlockHeader.BlockType == BlockTypeFcb );

    ExFreePool( Fcb );

    DebugTrace( -1, Dbg, "MupFreeFcb -> VOID\n", 0 );
}


PCCB
MupCreateCcb(
    VOID
    )

/*++

Routine Description:

    This routine allocates an CCB block

Arguments:

    None.

Return Value:

    A pointer to the allocated CCB.

--*/

{
    PCCB ccb;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupCreateCcb\n", 0 );

    //
    // Attempt to allocate memory.
    //

    ccb = ExAllocatePoolWithTag(
                PagedPool,
                sizeof(CCB),
                ' puM');

    if (ccb == NULL) {

        return NULL;

    }

    //
    // Initialize the UNC provider block header
    //

    ccb->BlockHeader.BlockType = BlockTypeCcb;
    ccb->BlockHeader.BlockState = BlockStateActive;
    ccb->BlockHeader.ReferenceCount = 1;
    ccb->BlockHeader.BlockSize = sizeof( CCB );

    DebugTrace( -1, Dbg, "MupCreateCcb -> 0x%8lx\n", ccb );

    return ccb;
}

VOID
MupDereferenceCcb(
    PCCB Ccb
    )
{
    LONG result;

    DebugTrace( +1, Dbg, "MupDereferenceCcb\n", 0 );

    ASSERT( Ccb->BlockHeader.BlockType == BlockTypeCcb );

    result = InterlockedDecrement(
                 &Ccb->BlockHeader.ReferenceCount
                 );

    DebugTrace( 0, Dbg, "ReferenceCount = %d\n", Ccb->BlockHeader.ReferenceCount );

    if ( result == 0 ) {

        ACQUIRE_LOCK( &MupCcbListLock );
        RemoveEntryList( &Ccb->ListEntry );
        RELEASE_LOCK( &MupCcbListLock );

        //
        // Release our references then free the CCB.
        //

        ObDereferenceObject( Ccb->FileObject );

        MupDereferenceFcb( Ccb->Fcb );

        MupFreeCcb( Ccb );
    }

    DebugTrace( -1, Dbg, "MupDereferenceCcb -> VOID\n", 0 );
}

VOID
MupFreeCcb(
    PCCB Ccb
    )

/*++

Routine Description:

    This routine frees a CCB block

Arguments:

    A pointer to the CCB block to free.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeCcb\n", 0 );

    ASSERT( Ccb->BlockHeader.BlockType == BlockTypeCcb );

    ExFreePool( Ccb );

    DebugTrace( -1, Dbg, "MupFreeCcb -> VOID\n", 0 );
}


PUNC_PROVIDER
MupAllocateUncProvider(
    ULONG DataLength
    )

/*++

Routine Description:

    The routine allocates and initializes the VCB for the MUP.

Arguments:

    DataLength - The size (in bytes) of the UNC provider.

Return Value:

    None.

--*/

{
    PUNC_PROVIDER uncProvider;
    ULONG size;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupAllocateUncProvider\n", 0);

    size = DataLength + sizeof( UNC_PROVIDER );

    uncProvider = ExAllocatePoolWithTag(
                        PagedPool,
                        size,
                        ' puM');

    if (uncProvider != NULL) {

        //
        // Initialize the UNC provider block header
        //

        uncProvider->BlockHeader.BlockType = BlockTypeUncProvider;
        uncProvider->BlockHeader.BlockState = BlockStateActive;
        uncProvider->BlockHeader.ReferenceCount = 0;
        uncProvider->BlockHeader.BlockSize = size;

	// 
	// By default we will make the provider unregistered
	//

	uncProvider->Registered = FALSE;

    }

    DebugTrace(-1, Dbg, "MupAllocateUncProvider -> 0x%8lx\n", uncProvider);

    return uncProvider;
}


VOID
MupDereferenceUncProvider(
    PUNC_PROVIDER UncProvider
    )

/*++

Routine Description:

    The routine dereference a UNC provider block.

Arguments:

    UncProvider - A pointer to the UNC provider block.

Return Value:

    None.

--*/

{
    LONG result;

    DebugTrace(+1, Dbg, "MupDereferenceProvider\n", 0);

    ASSERT( UncProvider->BlockHeader.BlockType == BlockTypeUncProvider );

    result = InterlockedDecrement(
                 &UncProvider->BlockHeader.ReferenceCount
                 );

    DebugTrace(0, Dbg, "ReferenceCount = %d\n", UncProvider->BlockHeader.ReferenceCount);

    ASSERT( result >= 0 );

    //
    // Do not free this block, even if the result is zero.  This
    // saves us from having to reread information for this provider
    // from the registry when the provider re-registers.
    //

    DebugTrace(-1, Dbg, "MupDereferenceUncProvider -> VOID\n", 0);
}


VOID
MupCloseUncProvider(
    PUNC_PROVIDER UncProvider
    )

/*++

Routine Description:

    The routine closes a UNC provider block.

Arguments:

    UncProvider - A pointer to the UNC provider block.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupDereferenceProvider\n", 0);

    ASSERT( UncProvider->BlockHeader.BlockType == BlockTypeUncProvider );

    MupAcquireGlobalLock();

    if ( UncProvider->BlockHeader.BlockState == BlockStateActive ) {

        DebugTrace(0, Dbg, "Closing UNC provider %08lx\n", UncProvider );

        UncProvider->BlockHeader.BlockState = BlockStateClosing;

        //
        // Mark the provider as unregistered
        //

	UncProvider->Registered = FALSE;

        MupReleaseGlobalLock();

        //
        // Close our handle to the provider, and release our reference
        // to the file object.
        //

        if (UncProvider->FileObject != NULL) {
            ZwClose( UncProvider->Handle );
            ObDereferenceObject( UncProvider->FileObject );
        }

    } else {
        MupReleaseGlobalLock();
    }

    DebugTrace(-1, Dbg, "MupDereferenceUncProvider -> VOID\n", 0);

}


PKNOWN_PREFIX
MupAllocatePrefixEntry(
    ULONG DataLength
    )

/*++

Routine Description:

    The routine allocates known prefix block.

Arguments:

    DataLength - The size (in bytes) of the extra data to allocate in the
            buffer for the prefix buffer.

Return Value:

    A pointer to the newly allocated block or NULL if it could not be
    allocated.

--*/

{
    PKNOWN_PREFIX knownPrefix;
    ULONG size;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupAllocatePrefixEntry\n", 0);

    size = DataLength + sizeof( KNOWN_PREFIX );

    knownPrefix = ExAllocatePoolWithTag(
                        PagedPool,
                        size,
                        ' puM');

    if (knownPrefix == NULL) {

        return NULL;

    }

    RtlZeroMemory( knownPrefix, size );

    //
    // Initialize the UNC provider block header
    //

    knownPrefix->BlockHeader.BlockType = BlockTypeKnownPrefix;
    knownPrefix->BlockHeader.BlockState = BlockStateActive;
    knownPrefix->BlockHeader.ReferenceCount = 1;
    knownPrefix->BlockHeader.BlockSize = size;

    if ( DataLength > 0 ) {
        knownPrefix->Prefix.Buffer = (PWCH)(knownPrefix + 1);
        knownPrefix->Prefix.MaximumLength = (USHORT)DataLength;
    } else {
        //
        // It is up to the caller to really allocate the memory!
        //
        knownPrefix->PrefixStringAllocated = TRUE;
    }

    knownPrefix->Active = FALSE;

    MupCalculateTimeout( &knownPrefix->LastUsedTime );

    DebugTrace(-1, Dbg, "MupAllocatePrefixEntry -> 0x%8lx\n", knownPrefix);

    return knownPrefix;

}

VOID
MupDereferenceKnownPrefix(
    PKNOWN_PREFIX KnownPrefix
    )

/*++

Routine Description:

    The routine dereferences a Known prefix block.

    *** MupPrefixTableLock assumed held when this routine is called.
        Remains held on exit. ***

Arguments:

    KnownPrefix - A pointer to the Known prefix block.

Return Value:

    None.

--*/

{
    LONG result;

    DebugTrace(+1, Dbg, "MupDereferenceKnownPrefix\n", 0);

    ASSERT( KnownPrefix->BlockHeader.BlockType == BlockTypeKnownPrefix );

    result = InterlockedDecrement(
                 &KnownPrefix->BlockHeader.ReferenceCount
                 );

    DebugTrace(0, Dbg, "ReferenceCount = %d\n", KnownPrefix->BlockHeader.ReferenceCount);

    ASSERT( result >= 0 );

    if ( result == 0 ) {

        //
        // Remove the table entry
        //

        if ( KnownPrefix->InTable ) {
            RtlRemoveUnicodePrefix( &MupPrefixTable, &KnownPrefix->TableEntry );
            RemoveEntryList(&KnownPrefix->ListEntry);
        }

        //
        // Free the Prefix string.
        //

        if ( KnownPrefix->PrefixStringAllocated &&
            KnownPrefix->Prefix.Buffer != NULL ) {

            ExFreePool( KnownPrefix->Prefix.Buffer );
        }

        //
        // Dereference the associated UNC provider
        //

        if ( KnownPrefix->UncProvider != NULL ) {
            MupDereferenceUncProvider( KnownPrefix->UncProvider );
        }

        //
        // Time to free the block
        //

        MupFreeKnownPrefix( KnownPrefix );

    }

    DebugTrace( 0, Dbg, "MupDereferenceKnownPrefix -> VOID\n", 0 );
}

VOID
MupFreeKnownPrefix(
    PKNOWN_PREFIX KnownPrefix
    )

/*++

Routine Description:

    This routine frees a known prefix block

Arguments:

    A pointer to the known prefix block to free.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeKnownPrefix\n", 0 );

    ASSERT( KnownPrefix->BlockHeader.BlockType == BlockTypeKnownPrefix );

    ExFreePool( KnownPrefix );

    DebugTrace( -1, Dbg, "MupFreeKnownPrefix -> VOID\n", 0 );
}



PMASTER_FORWARDED_IO_CONTEXT
MupAllocateMasterIoContext(
    VOID
    )

/*++

Routine Description:

    This routine allocates a master fowarded io context block.

Arguments:

    None.

Return Value:

    A pointer to the master forwarded context block, or NULL if the
    allocation fails

--*/

{
    PMASTER_FORWARDED_IO_CONTEXT masterContext;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupAllocateMasterIoContext\n", 0 );

    masterContext = ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof( MASTER_FORWARDED_IO_CONTEXT ),
                        ' puM');

    if (masterContext != NULL) {

        //
        // Initialize the block header
        //

        masterContext->BlockHeader.BlockType = BlockTypeMasterIoContext;
        masterContext->BlockHeader.BlockState = BlockStateActive;
        masterContext->BlockHeader.ReferenceCount = 1;
        masterContext->BlockHeader.BlockSize = sizeof( MASTER_FORWARDED_IO_CONTEXT );

    }

    DebugTrace( -1, Dbg, "MupAllocateWorkContext -> 0x%8lx\n", masterContext );

    return masterContext;
}



NTSTATUS
MupDereferenceMasterIoContext(
    PMASTER_FORWARDED_IO_CONTEXT MasterContext,
    PNTSTATUS Status
    )

/*++

Routine Description:

    The routine dereferences a Master forwarded io context block.
    If the count reaches zero the original IRP is completed.

Arguments:

    A pointer to the a master forwarded io context block.

    Status for this mini context.

Return Value:

    NTSTATUS - OPTIONAL - The status of the original IRP.

--*/

{
    int result;
    PIRP originalIrp;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;

    DebugTrace(+1, Dbg, "MupDereferenceMasterIoContext\n", 0);
    DebugTrace( 0, Dbg, "MasterContext = 0x%08lx\n", MasterContext );


    ASSERT( MasterContext->BlockHeader.BlockType == BlockTypeMasterIoContext );

    //
    //  If any requests pass then set Irp status to success and leave
    //  it as success. If they all fail then use the last errorcode.
    //  To make this work we create the context with an error status.
    //

    if (Status != NULL) {

        //
        //  We can modify MasterContext because we have it referenced and
        //  we write 32 bits which is atomic.
        //

        if (NT_SUCCESS(*Status)) {

            MasterContext->SuccessStatus = STATUS_SUCCESS;

        } else {

            MasterContext->ErrorStatus = *Status;

        }

    }

    DebugTrace(0, Dbg, "ReferenceCount        = %d\n", MasterContext->BlockHeader.ReferenceCount);
    DebugTrace(0, Dbg, "MasterContext->Status = %8lx\n", MasterContext->ErrorStatus);


    result = InterlockedDecrement(
                 &MasterContext->BlockHeader.ReferenceCount
                 );

    ASSERT( result >= 0 );

    if ( result == 0 ) {

        //
        // Complete the original IRP
        //

        originalIrp = MasterContext->OriginalIrp;

        irpSp = IoGetCurrentIrpStackLocation( originalIrp );
        if ( irpSp->MajorFunction == IRP_MJ_WRITE ) {
            originalIrp->IoStatus.Information = irpSp->Parameters.Write.Length;
        } else {
            originalIrp->IoStatus.Information = 0;
        }

        //
        //  If any requests pass then set Irp status to success and return
        //  success. If they all fail then use the last errorcode.
        //

        if (NT_SUCCESS(MasterContext->SuccessStatus)) {

            status = STATUS_SUCCESS;

        } else {

            status = MasterContext->ErrorStatus;

        }

        DebugTrace(0, Dbg, "MupCompleteRequest = %8lx\n", status);
        MupCompleteRequest( originalIrp, status );

        //
        // Dereference the FCB
        //

        MupDereferenceFcb( MasterContext->Fcb );

        //
        // Free the Master context block
        //

        MupFreeMasterIoContext( MasterContext );

        // return status

    } else {

        status = STATUS_PENDING;

    }

    DebugTrace( 0, Dbg, "MupDereferenceMasterIoContext -> %X\n", status );

    return status;
}

VOID
MupFreeMasterIoContext(
    PMASTER_FORWARDED_IO_CONTEXT MasterContext
    )

/*++

Routine Description:

    This routine frees a master forwarded io context block.

Arguments:

    A pointer to the a master forwarded io context block.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeMasterIoContext\n", 0 );

    ASSERT( MasterContext->BlockHeader.BlockType == BlockTypeMasterIoContext );
    ExFreePool( MasterContext );

    DebugTrace( -1, Dbg, "MupFreeMasterIoContext -> VOID\n", 0 );
}




PMASTER_QUERY_PATH_CONTEXT
MupAllocateMasterQueryContext(
    VOID
    )

/*++

Routine Description:

    This routine allocates a master query path context block.

Arguments:

    None.

Return Value:

    A pointer to the master query path block.  If the allocation
    fails, NULL is returned.

--*/

{
    PMASTER_QUERY_PATH_CONTEXT masterContext;

    PAGED_CODE();
    DebugTrace( +1, Dbg, "MupAllocateMasterQueryContext\n", 0 );

    masterContext = ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof( MASTER_QUERY_PATH_CONTEXT ),
                        ' puM');

    if (masterContext == NULL) {

        return NULL;

    }


    //
    // Initialize the block header
    //

    masterContext->BlockHeader.BlockType = BlockTypeMasterQueryContext;
    masterContext->BlockHeader.BlockState = BlockStateActive;
    masterContext->BlockHeader.ReferenceCount = 1;
    masterContext->BlockHeader.BlockSize = sizeof( MASTER_QUERY_PATH_CONTEXT );
    InitializeListHead(&masterContext->MasterQueryList);
    InitializeListHead(&masterContext->QueryList);


    INITIALIZE_LOCK(
        &masterContext->Lock,
        QUERY_CONTEXT_LOCK_LEVEL,
        "Master query context lock"
        );

    DebugTrace( -1, Dbg, "MupAllocateMasterQueryContext -> 0x%8lx\n", masterContext );

    return masterContext;
}

NTSTATUS
MupDereferenceMasterQueryContext(
    PMASTER_QUERY_PATH_CONTEXT MasterContext
    )

/*++

Routine Description:

    The routine dereferences a Master query path context block.
    If the count reaches zero the original IRP is completed.

Arguments:

    A pointer to the a master query path context block.

Return Value:

    NTSTATUS - The final create IRP status.

--*/

{
    LONG result;
    NTSTATUS status;

    DebugTrace(+1, Dbg, "MupDereferenceMasterQueryContext\n", 0);
    DebugTrace( 0, Dbg, "MasterContext = 0x%08lx\n", MasterContext );

    ASSERT( MasterContext->BlockHeader.BlockType == BlockTypeMasterQueryContext );

    MupAcquireGlobalLock();

    result = --MasterContext->BlockHeader.ReferenceCount;
             
    MupReleaseGlobalLock();
    DebugTrace(0, Dbg, "ReferenceCount = %d\n", MasterContext->BlockHeader.ReferenceCount);

    ASSERT( result >= 0 );

    if ( result == 0 ) {

        BOOLEAN fActive;

        if (MasterContext->OriginalIrp == NULL) {

            DbgPrint("OriginalIrp == NULL, MasterContext=0x%x\n", MasterContext);
            KeBugCheck( FILE_SYSTEM );

        }

	// we are done with this master query so remove it from the global list
	MupAcquireGlobalLock();
	RemoveEntryList(&MasterContext->MasterQueryList);
	MupReleaseGlobalLock();


        ACQUIRE_LOCK( &MupPrefixTableLock );

        fActive = MasterContext->KnownPrefix->Active;

        MupDereferenceKnownPrefix( MasterContext->KnownPrefix );

        //
        // Reroute the request and complete the original IRP
        //

        if (( MasterContext->Provider != NULL) &&
	    ( MasterContext->ErrorStatus == STATUS_SUCCESS )) {

            //
            // Remove final ref if nothing ended up in the table
            //
            if (fActive == FALSE) {
                MupDereferenceKnownPrefix( MasterContext->KnownPrefix );
            }

            RELEASE_LOCK( &MupPrefixTableLock );

	    MUP_TRACE_NORM(TRACE_IRP, MupDereferenceMasterQueryContext_RerouteOpen,
			   LOGUSTR(MasterContext->Provider->DeviceName)
			   LOGUSTR(MasterContext->FileObject->FileName)
			   LOGPTR(MasterContext->OriginalIrp)
			   LOGPTR(MasterContext->FileObject));
            status = MupRerouteOpen(
                         MasterContext->FileObject,
                         MasterContext->Provider
                         );

        } else {

	    if (MasterContext->Provider != NULL) {
		MupDereferenceUncProvider(MasterContext->Provider);
	    }

            //
            // No provider claimed this open.  Dereference the known prefix
            // entry and fail the create request.
            //

            MupDereferenceKnownPrefix( MasterContext->KnownPrefix );
            RELEASE_LOCK( &MupPrefixTableLock );
            status = MasterContext->ErrorStatus;

        }

	MUP_TRACE_NORM(TRACE_IRP, MupDereferenceMasterQueryContext_CompleteRequest,
		       LOGPTR(MasterContext->OriginalIrp)
		       LOGSTATUS(status));
        FsRtlCompleteRequest( MasterContext->OriginalIrp, status );
        MasterContext->OriginalIrp = NULL;
        MupFreeMasterQueryContext( MasterContext );

    } else {

        status = STATUS_PENDING;

    }

    DebugTrace( 0, Dbg, "MupDereferenceMasterQueryContext -> 0x%08lx\n", status );

    return status;

}

VOID
MupFreeMasterQueryContext(
    PMASTER_QUERY_PATH_CONTEXT MasterContext
    )

/*++

Routine Description:

    This routine frees a master query path context block.

Arguments:

    A pointer to the a master query path context block.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "MupFreeMasterQueryPathContext\n", 0 );

    ASSERT( BlockType( MasterContext ) == BlockTypeMasterQueryContext );

    DELETE_LOCK( &MasterContext->Lock );
    ExFreePool( MasterContext );

    DebugTrace( -1, Dbg, "MupFreeMasterQueryPathContext -> VOID\n", 0 );
}

VOID
MupCalculateTimeout(
    PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine calculates the an absolute timeout time.  This value
    equals the current system time plus the MUP timeout time.

Arguments:

    A pointer to the time structure.

Return Value:

    None.

--*/

{
    LARGE_INTEGER now;

    PAGED_CODE();
    KeQuerySystemTime( &now );
    Time->QuadPart = now.QuadPart + MupKnownPrefixTimeout.QuadPart;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements the file create routine for the MUP.

Author:

    Manny Weiser (mannyw)    16-Dec-1991

Revision History:

--*/

#include "mup.h"
//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
// Local functions
//

NTSTATUS
CreateRedirectedFile(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PIO_SECURITY_CONTEXT Security
    );

NTSTATUS
QueryPathCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MupRerouteOpenToDfs (
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
BroadcastOpen (
    IN PIRP Irp
    );

IO_STATUS_BLOCK
OpenMupFileSystem (
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    );

NTSTATUS
IsThisASysVolPath(
    IN PUNICODE_STRING PathName,
    IN PUNICODE_STRING DCName);

NTSTATUS
MupDomainToDC(
    PUNICODE_STRING RootName,
    PUNICODE_STRING DCName);

BOOLEAN
MupFlushPrefixEntry (
   PUNICODE_STRING pathName
   );

VOID
MupInvalidatePrefixTable (
    VOID
    );

BOOLEAN
DfspIsSysVolShare(
    PUNICODE_STRING ShareName);



#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, BroadcastOpen )
#pragma alloc_text( PAGE, CreateRedirectedFile )
#pragma alloc_text( PAGE, MupCreate )
#pragma alloc_text( PAGE, MupRerouteOpenToDfs )
#pragma alloc_text( PAGE, OpenMupFileSystem )
#pragma alloc_text( PAGE, QueryPathCompletionRoutine )
#pragma alloc_text( PAGE, MupFlushPrefixEntry)
#pragma alloc_text( PAGE, MupInvalidatePrefixTable)
#pragma alloc_text( PAGE, IsThisASysVolPath)
#pragma alloc_text( PAGE, MupDomainToDC)
#ifdef TERMSRV
#pragma alloc_text( PAGE, TSGetRequestorSessionId )
#endif // TERMSRV
#endif

#ifdef TERMSRV

NTSTATUS
TSGetRequestorSessionId(
    IN PIRP pIrp,
    OUT PULONG pulSessionId
    )
/*++

Routine Description:

    This routine returns the session ID for user that is creating a file
    via the IRP_MJ_CREATE, IRP_MJ_CREATE_NAMED_PIPE or IRP_MJ_CREATE_MAILSLOT
    IRP requests.

Arguments:

    pIrp - pointer to the I/O Request Packet.

    pulSessionId - pointer to the session Id which is set upon successful
        return.

Return Value:

    STATUS_SUCCESS - if the session ID was available.
    STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    PFILE_OBJECT FileObject = pIrpSp->FileObject;
    PIO_SECURITY_CONTEXT pSecurityContext;
    PSECURITY_SUBJECT_CONTEXT pSecSubjectContext;
    UNICODE_STRING FileName = FileObject->FileName;

    switch (pIrpSp->MajorFunction) {
        case IRP_MJ_CREATE:
        case IRP_MJ_CREATE_NAMED_PIPE:
        case IRP_MJ_CREATE_MAILSLOT:
            pSecurityContext = pIrpSp->Parameters.Create.SecurityContext;
            break;

#if 0
        case IRP_MJ_CREATE_NAMED_PIPE:
            pSecurityContext = pIrpSp->Parameters.CreatePipe.SecurityContext;
            break;

        case IRP_MJ_CREATE_MAILSLOT:
            pSecurityContext = pIrpSp->Parameters.CreateMailslot.SecurityContext;
            break;
#endif // 0

        default:
            pSecurityContext = NULL;
            break;
    }

    if ( pSecurityContext == NULL ) {
        *pulSessionId = (ULONG) INVALID_SESSIONID;
        ntStatus = STATUS_UNSUCCESSFUL;
        MUP_TRACE_HIGH(ERROR, TSGetRequestorSessionId_Error1, 
                       LOGSTATUS(ntStatus)
                       LOGPTR(pIrp)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));

        goto Cleanup;
    }

    pSecSubjectContext = &pSecurityContext->AccessState->SubjectSecurityContext;

    ntStatus = SeQuerySessionIdToken(
                ((pSecSubjectContext->ClientToken != NULL) ?
                    pSecSubjectContext->ClientToken :
                    pSecSubjectContext->PrimaryToken ),
                pulSessionId);
Cleanup:

    if( !NT_SUCCESS( ntStatus ) ) {
        DebugTrace(0, Dbg,
            "TSGetRequestorSessionId returns error, 0x%lx\n",
            ntStatus);
    }
    else {
        DebugTrace(0, Dbg,
            "TSGetRequestorSessionId returns SessionID, %ld\n",
            *pulSessionId);
    }

    return(ntStatus);

}


#endif // TERMSRV


NTSTATUS
MupCreate (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the the Create IRP.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    NTSTATUS status;

    PIO_STACK_LOCATION irpSp;

    PFILE_OBJECT fileObject;
    PFILE_OBJECT relatedFileObject;
    STRING fileName;
    ACCESS_MASK desiredAccess;
    USHORT shareAccess;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    BOOLEAN caseInsensitive = TRUE; //**** Make all searches case insensitive
    PVCB vcb;


    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCreate\n", 0);

    //
    // Make local copies of our input parameters to make things easier.
    //

    irpSp             = IoGetCurrentIrpStackLocation( Irp );
    fileObject        = irpSp->FileObject;
    relatedFileObject = irpSp->FileObject->RelatedFileObject;
    fileName          = *((PSTRING)(&irpSp->FileObject->FileName));
    desiredAccess     = irpSp->Parameters.Create.SecurityContext->DesiredAccess;
    shareAccess       = irpSp->Parameters.Create.ShareAccess;
    vcb               = &MupDeviceObject->Vcb;

    DebugTrace( 0, Dbg, "Irp               = %08lx\n", (ULONG)Irp );
    DebugTrace( 0, Dbg, "FileObject        = %08lx\n", (ULONG)fileObject );
    DebugTrace( 0, Dbg, "FileName          = %Z\n",    (ULONG)&fileName );


    MUP_TRACE_HIGH(TRACE_IRP, MupCreate_Entry, 
                   LOGPTR(MupDeviceObject)
                   LOGPTR(fileObject)
                   LOGPTR(Irp)
                   LOGUSTR(fileName));

    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] MupCreate(%wZ)\n",
                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                &fileObject->FileName);
    }
#endif

    FsRtlEnterFileSystem();

    try {

        //
        // Check to see if this is an open that came in via a Dfs device
        // object.
        //

        if (MupEnableDfs) {
            if ((MupDeviceObject->DeviceObject.DeviceType == FILE_DEVICE_DFS) ||
                    (MupDeviceObject->DeviceObject.DeviceType ==
                        FILE_DEVICE_DFS_FILE_SYSTEM)) {

                status = DfsFsdCreate( (PDEVICE_OBJECT) MupDeviceObject, Irp );
                MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, MupCreate_Error_DfsFsdCreate, 
                                     LOGSTATUS(status)
                                     LOGPTR(fileObject)
                                     LOGPTR(Irp));
                try_return( NOTHING );
            }
        }

        //
        // Check if we are trying to open the mup file system
        //

        if ( fileName.Length == 0
                         &&
             ( relatedFileObject == NULL ||
               BlockType(relatedFileObject->FsContext) == BlockTypeVcb ) ) {

            DebugTrace(0, Dbg, "Open MUP file system\n", 0);

            Irp->IoStatus = OpenMupFileSystem( &MupDeviceObject->Vcb,
                                               fileObject,
                                               desiredAccess,
                                               shareAccess );

            status = Irp->IoStatus.Status;
            MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, MupCreate_Error_OpenMupFileSystem, 
                                 LOGSTATUS(status)
                                 LOGPTR(fileObject)
                                 LOGPTR(Irp));
            
            MupCompleteRequest( Irp, status );
            try_return( NOTHING );
        }

        //
        // This is a UNC file open.  Try to pass the request on.
        //

        status  = CreateRedirectedFile(
                      Irp,
                      fileObject,
                      irpSp->Parameters.Create.SecurityContext
                      );
        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, MupCreate_Error_CreateRedirectedFile, 
                             LOGSTATUS(status)
                             LOGPTR(fileObject)
                             LOGPTR(Irp));

    try_exit: NOTHING;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
	  // we need to complete the IRP.
	  // But first, get the error code.
	  status = GetExceptionCode();
	  MupCompleteRequest( Irp, status );
    }

    FsRtlExitFileSystem();

    MUP_TRACE_HIGH(TRACE_IRP, MupCreate_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(fileObject)
                   LOGPTR(Irp));
    DebugTrace(-1, Dbg, "MupCreate -> %08lx\n", status);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] MupCreate exit 0x%x\n",
            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
            status);
    }
#endif
    return status;
}



IO_STATUS_BLOCK
OpenMupFileSystem (
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    )

/*++

Routine Description:

    This routine attempts to open the VCB.

Arguments:

    Vcb - A pointer to the MUP volume control block.

    FileObject - A pointer to the IO system supplied file object for this
        Create IRP.

    DesiredAccess - The user specified desired access to the VCB.

    ShareAccess - The user specified share access to the VCB.

Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    IO_STATUS_BLOCK iosb;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupOpenMupFileSystem\n", 0 );
    MUP_TRACE_LOW(DEFAULT, OpenMupFileSystem_Entry, 
                   LOGPTR(Vcb)
                   LOGPTR(FileObject)
                   LOGULONG(DesiredAccess)
                   LOGXSHORT(ShareAccess));


    ExAcquireResourceExclusiveLite( &MupVcbLock, TRUE );

    try {

        //
        //  Set the new share access
        //

        if (!NT_SUCCESS(iosb.Status = IoCheckShareAccess( DesiredAccess,
                                                       ShareAccess,
                                                       FileObject,
                                                       &Vcb->ShareAccess,
                                                       TRUE ))) {

            DebugTrace(0, Dbg, "bad share access\n", 0);
            MUP_TRACE_ERROR_HIGH(iosb.Status, ALL_ERROR, OpenMupFileSystem_Error_IoCheckShareAccess,
                                 LOGSTATUS(iosb.Status)
                                 LOGPTR(FileObject));
            try_return( NOTHING );
        }

        //
        // Supply the file object with a referenced pointer to the VCB.
        //

        MupReferenceBlock( Vcb );
        MupSetFileObject( FileObject, Vcb, NULL );

        //
        // Set the return status.
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;

    try_exit: NOTHING;

    } finally {

        ExReleaseResourceLite( &MupVcbLock );

    }

    //
    // Return to the caller.
    //

    MUP_TRACE_LOW(DEFAULT, OpenMupFileSystem_Exit, 
                  LOGSTATUS(iosb.Status)
                  LOGPTR(FileObject));
    DebugTrace(-1, Dbg, "MupOpenMupFileSystem -> Iosb.Status = %08lx\n", iosb.Status);
    return iosb;
}

NTSTATUS
CreateRedirectedFile(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PIO_SECURITY_CONTEXT SecurityContext
    )
/*++

Routine Description:

    This routine attempts to reroute a file create request to a redirector.
    It attempts to find the correct redirector in 2 steps.

    (1)  The routine checks a list of known prefixes.  If the file object -
    file name prefix matches a known prefix, the request is forwarded to
    the redirector that "owns" the prefix.

    (2)  The routine queries each redirector in turn, until one claims
    ownership of the file.  The request is then rerouted to that redirector.

    If after these steps no owner is located, the MUP fails the request.

Arguments:

    Irp - A pointer to the create IRP.

    FileObject - A pointer to the IO system supplied file object for this
        create request.

    SecurityContext - A pointer to the IO security context for this request.

Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    NTSTATUS status = STATUS_BAD_NETWORK_PATH;

    PUNICODE_PREFIX_TABLE_ENTRY entry;
    PKNOWN_PREFIX knownPrefix = NULL;
    PLIST_ENTRY listEntry;
    PUNC_PROVIDER provider;
    PWCH buffer;
    LONG length;
    BOOLEAN ownLock;
    BOOLEAN providerReferenced = FALSE;
    BOOLEAN firstProvider = TRUE;

    PQUERY_PATH_REQUEST qpRequest;

    PMASTER_QUERY_PATH_CONTEXT masterContext = NULL;
    PQUERY_PATH_CONTEXT queryContext;

    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER now;
    UNICODE_STRING FileName = FileObject->FileName;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "CreateRedirectedFile\n", 0);
    MUP_TRACE_LOW(DEFAULT, CreateRedirectedFile_Entry,
		  LOGPTR(Irp)
		  LOGPTR(FileObject)
		  LOGUSTR(FileName));

// #ifdef TERMSRV
#if 0 // need to confirm with the citrix guys about this change.

    if( IsTerminalServer() ) {

        //
        // Translate the filename for terminal server based on the session ID.
        //
        // NOTE: This re-allocates FileObject->FileName as needed
        //

        TSTranslateClientName( Irp, FileObject );
    }

#endif // TERMSRV

    //
    // Handle empty filename
    //

    if (FileObject->FileName.Length == 0) {

        MupCompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST);
        status = STATUS_INVALID_DEVICE_REQUEST;
        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, CreateRedirectedFile_Error_EmptyFilename, 
                             LOGSTATUS(status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));
        DebugTrace(-1, Dbg, "CreateRedirectedFile exit 0x%x\n", status);
        return status;

    }

    //
    // Check to see if this file name begins with a known prefix.
    //

    ACQUIRE_LOCK( &MupPrefixTableLock );

    entry = RtlFindUnicodePrefix( &MupPrefixTable, &FileObject->FileName, TRUE );

    if ( entry != NULL ) {

        DebugTrace(0, Dbg, "Prefix %Z is known, rerouting...\n", (PSTRING)&FileObject->FileName);

        //
        // This is a known file, forward appropriately
        //

        knownPrefix = CONTAINING_RECORD( entry, KNOWN_PREFIX, TableEntry );

        KeQuerySystemTime( &now );

        if ( now.QuadPart < knownPrefix->LastUsedTime.QuadPart ) {

            //
            // The known prefix has not timed out yet, recalculate the
            // timeout time and reroute the open.
            //

            MupCalculateTimeout( &knownPrefix->LastUsedTime );
            status = MupRerouteOpen( FileObject, knownPrefix->UncProvider );
            RELEASE_LOCK( &MupPrefixTableLock );
            DebugTrace(-1, Dbg, "CreateRedirectedFile -> %8lx", status );
            MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, CreateRedirectedFile_Error_MupRerouteOpen,
                                 LOGSTATUS(status)
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject)
				 LOGUSTR(FileObject->FileName));

            if (status == STATUS_REPARSE)
                Irp->IoStatus.Information = IO_REPARSE;

            MupCompleteRequest( Irp, status );
            return status;

        } else {

            DebugTrace(0, Dbg, "Prefix %Z has timed out\n", (PSTRING)&FileObject->FileName);

            //
            // The known prefix has timed out, dereference it so that
            // it will get removed from the table.
            //
            if ( knownPrefix->InTable ) {
               MupRemoveKnownPrefixEntry( knownPrefix);
            }
            RELEASE_LOCK( &MupPrefixTableLock );
        }

    } else {

        RELEASE_LOCK( &MupPrefixTableLock );

    }

    //
    // Is this a client side mailslot file?  It is if the file name
    // is of the form \\server\mailslot\Anything, and this is a create
    // operation.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    buffer = (PWCH)FileObject->FileName.Buffer;
    length = FileObject->FileName.Length;

    if ( *buffer == L'\\' && irpSp->MajorFunction == IRP_MJ_CREATE ) {
        buffer++;
        while ( (length -= sizeof(WCHAR)) > 0 && *buffer++ != L'\\' )
           NOTHING;
        length -= sizeof(WCHAR);

        if (
            length >= (sizeof(L"MAILSLOT") - sizeof(WCHAR))
                &&
             _wcsnicmp(
                buffer,
                L"Mailslot",
                MIN(length/sizeof(WCHAR),(sizeof(L"MAILSLOT")-sizeof(WCHAR))/sizeof(WCHAR))) == 0
        ) {

            //
            // This is a mailslot file.  Forward the create IRP to all
            // redirectors that support broadcast.
            //

            DebugTrace(0, Dbg, "Prefix %Z is a mailslot\n", (ULONG)&FileObject->FileName);

            status = BroadcastOpen( Irp );
            if (status == STATUS_REPARSE)
                Irp->IoStatus.Information = IO_REPARSE;
            MUP_TRACE_LOW(DEFAULT, CreateRedirectedFile_Exit_Mailslot, 
                          LOGSTATUS(status)
                          LOGPTR(Irp)
                          LOGPTR(FileObject)
			  LOGUSTR(FileName));
            MupCompleteRequest( Irp, status );
            DebugTrace(-1, Dbg, "CreateRedirectedFile -> 0x%8lx\n", status );
            return status;

        }

    }

    //
    // Check to see if this is a Dfs name. If so, we'll handle it separately
    //

    if (MupEnableDfs &&
            (FileObject->FsContext2 != UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT))) {
        UNICODE_STRING pathName;
        UNICODE_STRING DCName;

        status = DfsFsctrlIsThisADfsPath( &FileObject->FileName, FALSE, &pathName );

        if (status == STATUS_SUCCESS) {

            DebugTrace(-1, Dbg, "Rerouting open of [%wZ] to Dfs\n", &FileObject->FileName);
            status = MupRerouteOpenToDfs(FileObject);
            if (status == STATUS_REPARSE)
                Irp->IoStatus.Information = IO_REPARSE;
            MupCompleteRequest( Irp, status );
            return( status );

        }

        //
        // If special table is not init'ed, and this is \<domainname>\<specialname>,
        // rewrite into \<dcname>\<specialname>
        //
        if (DfsData.Pkt.SpecialTable.SpecialEntryCount == 0) {
            DCName.Buffer = NULL;
            DCName.Length = DCName.MaximumLength = 0;
            status = IsThisASysVolPath(&FileObject->FileName, &DCName);
            if (status == STATUS_SUCCESS)
                MupDomainToDC(&FileObject->FileName, &DCName);
            if (DCName.Buffer != NULL)
                ExFreePool(DCName.Buffer);
        }
    }

    //
    // We don't know who owns this file, query the redirectors in sequence
    // until one works.
    //

    IoMarkIrpPending(Irp);

    //
    // Allocate the master context and knownprefix.  If either allocation fails, we'll
    // complete the irp with STATUS_INSUFFICIENT_RESOURCES
    //

    knownPrefix = MupAllocatePrefixEntry( 0 );

    if (knownPrefix == NULL) {
        MupCompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES);
        return STATUS_PENDING;

    }

    masterContext = MupAllocateMasterQueryContext();

    if (masterContext == NULL) {

        ExFreePool(knownPrefix);

        MupCompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES);
        return STATUS_PENDING;

    }

    try {

        masterContext->OriginalIrp = Irp;

        masterContext->FileObject = FileObject;
        masterContext->Provider = NULL;
        masterContext->KnownPrefix = knownPrefix;
        masterContext->ErrorStatus = STATUS_BAD_NETWORK_PATH;

        MupAcquireGlobalLock();
	// for debugging: insert the Master Context into the global list.
	InsertHeadList(&MupMasterQueryList, &masterContext->MasterQueryList);
        MupReferenceBlock( knownPrefix );
        MupReleaseGlobalLock();

        try {

            MupAcquireGlobalLock();
            ownLock = TRUE;

            listEntry = MupProviderList.Flink;
            while ( listEntry != &MupProviderList ) {

                provider = CONTAINING_RECORD(
                               listEntry,
                               UNC_PROVIDER,
                               ListEntry
                               );

                //
                // Reference the provider block so that it doesn't go away
                // while we are using it.
                //

                MupReferenceBlock( provider );
                providerReferenced = TRUE;

                MupReleaseGlobalLock();
                ownLock = FALSE;

		// only use this provider if it is registered
		if(provider->Registered) {

		    //
		    // Allocate buffers for the io request.
		    //

		    qpRequest = NULL;
		    queryContext = NULL;

		    qpRequest = ExAllocatePoolWithTag(
			PagedPool,
			sizeof( QUERY_PATH_REQUEST ) +
			FileObject->FileName.Length,
			' puM');

		    if (qpRequest == NULL) {
			ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
		    }

		    queryContext = ExAllocatePoolWithTag(
			PagedPool,
			sizeof( QUERY_PATH_CONTEXT ),
			' puM');

		    if (queryContext == NULL) {
			ExFreePool(qpRequest);
			ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
		    }

		    InitializeListHead(&queryContext->QueryList);
		    queryContext->MasterContext = masterContext;
		    queryContext->Buffer = qpRequest;

		    //
		    // Generate a query path request.
		    //

		    qpRequest->PathNameLength = FileObject->FileName.Length;
		    qpRequest->SecurityContext = SecurityContext;

		    RtlMoveMemory(
			qpRequest->FilePathName,
			FileObject->FileName.Buffer,
			FileObject->FileName.Length
			);

		    //
		    // Build the query path Io control IRP.
		    //

		    irp = MupBuildIoControlRequest(
			NULL,
			provider->FileObject,
			queryContext,
			IRP_MJ_DEVICE_CONTROL,
			IOCTL_REDIR_QUERY_PATH,
			qpRequest,
			sizeof( QUERY_PATH_REQUEST ) + FileObject->FileName.Length,
			qpRequest,
			sizeof( QUERY_PATH_RESPONSE ),
			QueryPathCompletionRoutine
			);

		    if ( irp == NULL ) {
			ExFreePool(qpRequest);
			ExFreePool(queryContext);
			ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
		    }

		    //
		    // Set the RequestorMode to KernelMode, since all the
		    // parameters to this Irp are in kernel space
		    //

		    irp->RequestorMode = KernelMode;

		    //
		    // Get a referenced pointer to the provider, the reference
		    // is release when the IO completes.
		    //

		    queryContext->Provider = provider;
		    queryContext->QueryIrp = irp;

		    MupAcquireGlobalLock();
		    MupReferenceBlock( provider );
		    MupReferenceBlock( masterContext );
		    MupReleaseGlobalLock();


		    // insert this query into the master context's list of queries (for debugging)
		    ACQUIRE_LOCK( &masterContext->Lock );
		    InsertHeadList(&masterContext->QueryList, &queryContext->QueryList);
		    RELEASE_LOCK( &masterContext->Lock );

		    //
		    // Submit the request.
		    //

  		    MUP_TRACE_HIGH(ALL_ERROR, CreateRedirectedFile_Before_IoCallDriver,
				   LOGPTR(masterContext->OriginalIrp)
				   LOGPTR(queryContext->QueryIrp)
				   LOGPTR(FileObject)
				   LOGUSTR(FileName)
				   LOGUSTR(provider->DeviceName));
		    status = IoCallDriver( provider->DeviceObject, irp );
		    MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, CreateRedirectedFile_Error_IoCallDriver,
					 LOGSTATUS(status)
					 LOGPTR(masterContext->OriginalIrp)
					 LOGPTR(FileObject)
					 LOGUSTR(provider->DeviceName));

		} // if registered

		//
		// Acquire the lock that protects the provider list, and get
		// a pointer to the next provider in the list.
		//
		    
		MupAcquireGlobalLock();
                ownLock = TRUE;
                listEntry = listEntry->Flink;

                MupDereferenceUncProvider( provider );
                providerReferenced = FALSE;

                //
                // If this is the first provider and it responded with SUCCESS, we can return early.
                // The list of providers is sorted in order of priority, so we know that this is
                // the highest prority provider and it can get to the destination.
                //

                if( firstProvider && (status == STATUS_SUCCESS) ) {
                    break;
                }

                firstProvider = FALSE;

            } // while

        } finally {

            //
            // Dereference the previous provider.
            //

            if ( providerReferenced ) {
                MupDereferenceUncProvider( provider );
            }

            if ( ownLock ) {
                MupReleaseGlobalLock();
            }
        }


    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        masterContext->ErrorStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(masterContext != NULL);

    //
    // Release our reference to the query context.
    //

    MupDereferenceMasterQueryContext( masterContext );

    status = STATUS_PENDING;

    MUP_TRACE_LOW(DEFAULT, CreateRedirectedFile_Exit, 
                  LOGSTATUS(status)
                  LOGPTR(Irp)
                  LOGPTR(FileObject));
    DebugTrace(-1, Dbg, "CreateRedirectedFile -> 0x%8lx\n", status );
    return status;
}

NTSTATUS
MupRerouteOpen (
    IN PFILE_OBJECT FileObject,
    IN PUNC_PROVIDER UncProvider
    )

/*++

Routine Description:

    This routine redirects an create IRP request to the specified redirector
    by changing the name of the file and returning STATUS_REPARSE to the
    IO system

Arguments:

    FileObject - The file object to open

    UncProvider - The UNC provider that will process the create IRP.

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    PCHAR buffer;
    ULONG deviceNameLength;
    ULONG nameLength;
    NTSTATUS status;
    UNICODE_STRING FileName = FileObject->FileName;
    //
    // Check that we won't create a name that is too long
    //

    nameLength = UncProvider->DeviceName.Length + FileObject->FileName.Length;

    if (nameLength > MAXUSHORT) {
        status = STATUS_NAME_TOO_LONG;
        MUP_TRACE_HIGH(ERROR, MupRerouteOpen_Error1, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));
        return STATUS_NAME_TOO_LONG;
    }

    //
    //  Allocate storage for the new file name.
    //

    buffer = ExAllocatePoolWithTag(
                 PagedPool,
                 UncProvider->DeviceName.Length + FileObject->FileName.Length,
                 ' puM');

    if ( buffer ==  NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        MUP_TRACE_HIGH(ERROR, MupRerouteOpen_Error2, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));
        return status;
    }

    //
    // Copy the device name to the string buffer.
    //

    RtlMoveMemory(
        buffer,
        UncProvider->DeviceName.Buffer,
        UncProvider->DeviceName.Length);

    deviceNameLength = UncProvider->DeviceName.Length;

    //
    // Append the file name
    //

    RtlMoveMemory(
        buffer + deviceNameLength,
        FileObject->FileName.Buffer,
        FileObject->FileName.Length);

    //
    // Free the old file name string buffer.
    //

    ExFreePool( FileObject->FileName.Buffer );

    FileObject->FileName.Buffer = (PWCHAR)buffer;
    FileObject->FileName.MaximumLength = FileObject->FileName.Length + (USHORT)deviceNameLength;
    FileObject->FileName.Length = FileObject->FileName.MaximumLength;

    //
    // Tell the file system to try again.
    //

    return STATUS_REPARSE;
}

NTSTATUS
MupRerouteOpenToDfs (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine redirects an create IRP request to the Dfs part of this
    driver by changing the name of the file and returning
    STATUS_REPARSE to the IO system

Arguments:

    FileObject - The file object to open

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    PCHAR buffer;
    ULONG deviceNameLength;
    ULONG nameLength;
    NTSTATUS status;
    UNICODE_STRING FileName = FileObject->FileName;

    PAGED_CODE();

    MUP_TRACE_NORM(TRACE_IRP, MupRerouteOpenToDfs_Entry,
		   LOGPTR(FileObject)
		   LOGUSTR(FileName));

#if DBG
    if (MupVerbose)
        DbgPrint("MupRerouteOpenToDfs(%wZ)\n", &FileObject->FileName);
#endif

    deviceNameLength = sizeof(DFS_DEVICE_ROOT) - sizeof(UNICODE_NULL);

    //
    // Check that we won't create a name that is too long
    //

    nameLength = deviceNameLength + FileObject->FileName.Length;

    if (nameLength > MAXUSHORT) {
        status = STATUS_NAME_TOO_LONG;
        MUP_TRACE_HIGH(ERROR, MupRerouteOpenToDfs_Error1, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));
#if DBG
        if (MupVerbose)
            DbgPrint("MupRerouteOpenToDfs exit STATUS_NAME_TOO_LONG\n");
#endif
        return STATUS_NAME_TOO_LONG;
    }

    //
    //  Allocate storage for the new file name.
    //

    buffer = ExAllocatePoolWithTag(
                 PagedPool,
                 sizeof(DFS_DEVICE_ROOT) + FileObject->FileName.Length,
                 ' puM');

    if ( buffer ==  NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        MUP_TRACE_HIGH(ERROR, MupRerouteOpenToDfs_Error2, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
		       LOGUSTR(FileName));
#if DBG
        if (MupVerbose)
            DbgPrint("MupRerouteOpenToDfs exit STATUS_INSUFFICIENT_RESOURCES\n");
#endif
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the device name to the string buffer.
    //

    RtlMoveMemory(
        buffer,
        DFS_DEVICE_ROOT,
        sizeof(DFS_DEVICE_ROOT));

    //
    // Append the file name
    //

    RtlMoveMemory(
        buffer + deviceNameLength,
        FileObject->FileName.Buffer,
        FileObject->FileName.Length);

    //
    // Free the old file name string buffer.
    //

    ExFreePool( FileObject->FileName.Buffer );

    FileObject->FileName.Buffer = (PWCHAR)buffer;
    FileObject->FileName.MaximumLength = FileObject->FileName.Length + (USHORT)deviceNameLength;
    FileObject->FileName.Length = FileObject->FileName.MaximumLength;

    //
    // Tell the file system to try again.
    //

#if DBG
    if (MupVerbose)
        DbgPrint("MupRerouteOpenToDfs exit STATUS_REPARSE ->[%wZ]\n", &FileObject->FileName);
#endif
    return STATUS_REPARSE;
}


NTSTATUS
BroadcastOpen (
    PIRP Irp
    )

/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    NTSTATUS status;
    PFCB fcb;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT fileObject;
    BOOLEAN requestForwarded;
    PLIST_ENTRY listEntry;
    PUNC_PROVIDER uncProvider, previousUncProvider = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    PCCB ccb;
    OBJECT_HANDLE_INFORMATION handleInformation;
    HANDLE handle;
    BOOLEAN lockHeld = FALSE;
    BOOLEAN providerReferenced = FALSE;
    ULONG Len;
    UNICODE_STRING FileName;

    NTSTATUS statusToReturn = STATUS_NO_SUCH_FILE;
    ULONG priorityOfStatus = 0xFFFFFFFF;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "BroadcastOpen\n", 0 );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    FileName = irpSp->FileObject->FileName;
    try {

        //
        // Create a FCB for this file.
        //

        fcb = MupCreateFcb( );

        if (fcb == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            MUP_TRACE_HIGH(ERROR, BroadcastOpen_Error1, 
                           LOGSTATUS(status)
                           LOGPTR(Irp)
                           LOGPTR(irpSp->FileObject)
			   LOGUSTR(FileName));
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        try {

            //
            // Set the file object back pointers and our pointer to the
            // server file object.
            //

            fileObject = irpSp->FileObject;

            MupAcquireGlobalLock();
            lockHeld = TRUE;

            MupSetFileObject( fileObject,
                              fcb,
                              NULL );

            fcb->FileObject = fileObject;

            //
            // Loop through the list of UNC providers and try to create the
            // file on all file systems that support broadcast.
            //

            requestForwarded = FALSE;

            listEntry = MupProviderList.Flink;

            while ( listEntry != &MupProviderList ) {

                uncProvider = CONTAINING_RECORD( listEntry, UNC_PROVIDER, ListEntry );

                //
                // Reference the provider so that it won't go away
                //

                MupReferenceBlock( uncProvider );
                providerReferenced = TRUE;

                MupReleaseGlobalLock();
                lockHeld = FALSE;

                Len = uncProvider->DeviceName.Length + fileObject->FileName.Length;

                if ( uncProvider->MailslotsSupported && Len <= MAXUSHORT) {

                    //
                    // Build the rerouted file name, consisting of the file
                    // named we received appended to the UNC provider device
                    // name.
                    //

                    UNICODE_STRING fileName;

                    fileName.MaximumLength = fileName.Length = (USHORT) Len;

                    fileName.Buffer =
                        ExAllocatePoolWithTag(
                            PagedPool,
                            fileName.MaximumLength,
                            ' puM');

                    if (fileName.Buffer == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        MUP_TRACE_HIGH(ERROR, BroadcastOpen_Error2, 
                                       LOGSTATUS(status)
                                       LOGPTR(Irp)
                                       LOGPTR(fileObject)
				       LOGUSTR(FileName));
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                    }

                    RtlMoveMemory(
                        fileName.Buffer,
                        uncProvider->DeviceName.Buffer,
                        uncProvider->DeviceName.Length
                        );

                    RtlMoveMemory(
                        (PCHAR)fileName.Buffer + uncProvider->DeviceName.Length,
                        fileObject->FileName.Buffer,
                        fileObject->FileName.Length
                        );


                    //
                    // Attempt to open the file.  Copy all of the information
                    // from the create IRP we received, masking off additional
                    // baggage that the IO system added along the way.
                    //

                    DebugTrace( 0, Dbg, "Attempt to open %Z\n", (ULONG)&fileName );

                    InitializeObjectAttributes(
                        &objectAttributes,
                        &fileName,
                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                        0,
                        NULL                   // !!! Security
                        );

                    status = IoCreateFile(
                              &handle,
                              irpSp->Parameters.Create.SecurityContext->DesiredAccess & 0x1FF,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,
                              irpSp->Parameters.Create.FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS,
                              irpSp->Parameters.Create.ShareAccess & FILE_SHARE_VALID_FLAGS,
                              FILE_OPEN,
                              irpSp->Parameters.Create.Options & FILE_VALID_SET_FLAGS,
                              NULL,               // Ea buffer
                              0,                  // Ea length
                              CreateFileTypeNone,
                              NULL,               // parameters
                              IO_NO_PARAMETER_CHECKING
                              );

                    MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, BroadcastOpen_Error_IoCreateFile,
                                         LOGSTATUS(status)
                                         LOGPTR(Irp)
                                         LOGPTR(fileObject)
					 LOGUSTR(FileName));
                    ExFreePool( fileName.Buffer );

                    if ( NT_SUCCESS( status ) ) {
                        status = ioStatusBlock.Status;
                   

			ccb = MupCreateCcb( );

			if (ccb == NULL) {

			    status = STATUS_INSUFFICIENT_RESOURCES;
			    MUP_TRACE_HIGH(ERROR, BroadcastOpen_Error3, 
					   LOGSTATUS(status)
					   LOGPTR(Irp)
					   LOGPTR(fileObject)
					   LOGUSTR(FileName));

			}
		    }

                    if ( NT_SUCCESS( status ) ) {

                        DebugTrace( 0, Dbg, "Open attempt succeeded\n", 0 );

                       //
                       // 426184, need to check return code for errors.
                       //
                        status = ObReferenceObjectByHandle(
                                     handle,
                                     0,
                                     NULL,
                                     KernelMode,
                                     (PVOID *)&ccb->FileObject,
                                     &handleInformation );
                        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, BroadcastOpen_Error_ObReferenceObjectByHandle,
                                             LOGSTATUS(status)
                                             LOGPTR(Irp)
                                             LOGPTR(fileObject)
					     LOGUSTR(FileName));

                        ZwClose( handle );
                    }

                    if ( NT_SUCCESS( status ) ) {
                        ccb->DeviceObject =
                            IoGetRelatedDeviceObject( ccb->FileObject );

                        ccb->Fcb = fcb;

                        MupAcquireGlobalLock();
                        lockHeld = TRUE;
                        MupReferenceBlock( fcb );
                        MupReleaseGlobalLock();
                        lockHeld = FALSE;

                        //
                        // At least one provider will accept this mailslot
                        // request.
                        //

                        requestForwarded = TRUE;

                        //
                        // Keep a list of CCBs.  Since we just created the FCB
                        // there is no need to use the lock to access the list.
                        //

                        InsertTailList( &fcb->CcbList, &ccb->ListEntry );

                    } else { // NT_SUCCESS( status ), IoCreateFile

                        DebugTrace( 0, Dbg, "Open attempt failed %8lx\n", status );

                        //
                        // Remember the status code if this is the highest
                        // priority provider so far.  This code is returned if
                        // all providers fail the Create operation.
                        //

                        if ( uncProvider->Priority <= priorityOfStatus ) {
                            priorityOfStatus = uncProvider->Priority;
                            statusToReturn = status;
                        }

                    }

                }  // uncProvider->MailslotsSupported

                MupAcquireGlobalLock();
                lockHeld = TRUE;

                listEntry = listEntry->Flink;

                //
                // It is now safe to dereference the previous provider.
                //

                MupDereferenceUncProvider( uncProvider );
                providerReferenced = FALSE;

            } // while

            MupReleaseGlobalLock();
            lockHeld = FALSE;

            //
            //  And set our return status
            //

            if ( requestForwarded ) {
                status = STATUS_SUCCESS;
            } else {
                status = statusToReturn;
            }

        } finally {

            DebugTrace(-1, Dbg, "BroadcastOpen -> %08lx\n", status);

            if ( providerReferenced ) {
                MupDereferenceUncProvider( uncProvider );
            }

            if ( lockHeld ) {
                MupReleaseGlobalLock();
            }

            //
            // Now if we ever terminate the preceding try-statement with
            // a status that is not successful and the FCB pointer
            // is non-null then we need to deallocate the structure.
            //

            if (!NT_SUCCESS( status ) && fcb != NULL) {
                MupFreeFcb( fcb );
            }

        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        NOTHING;

    }

    return status;
}


NTSTATUS
QueryPathCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine the querying a path.  Cleanup our
    IRP and complete the original IRP if necessary.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    NTSTATUS - If STATUS_MORE_PROCESSING_REQUIRED is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.

--*/

{
    PQUERY_PATH_RESPONSE qpResponse;
    PMASTER_QUERY_PATH_CONTEXT masterContext;
    PQUERY_PATH_CONTEXT queryPathContext;
    PCH buffer;
    PKNOWN_PREFIX knownPrefix;
    ULONG lengthAccepted;
    NTSTATUS status;

    DeviceObject;   // prevent compiler warnings

    queryPathContext = Context;
    masterContext = queryPathContext->MasterContext;

    qpResponse = queryPathContext->Buffer;
    lengthAccepted = qpResponse->LengthAccepted;

    status = Irp->IoStatus.Status;

    MUP_TRACE_NORM(TRACE_IRP, QueryPathCompletionRoutine_Enter,
		   LOGPTR(DeviceObject)
		   LOGPTR(Irp)
		   LOGUSTR(queryPathContext->Provider->DeviceName)
		   LOGPTR(masterContext->FileObject)
		   LOGUSTR(masterContext->FileObject->FileName)
		   LOGSTATUS(status)
		   );

    //
    // Acquire the lock to protect access to the master context Provider
    // field.
    //

    ACQUIRE_LOCK( &masterContext->Lock );

    // remove this query from the MasterQueryContext's list.
    RemoveEntryList(&queryPathContext->QueryList);


    if (NT_SUCCESS(status) && lengthAccepted != 0) {

        knownPrefix = masterContext->KnownPrefix;

        if ( masterContext->Provider != NULL ) {

            if ( queryPathContext->Provider->Priority < masterContext->Provider->Priority ) {

                //
                // A provider of higher priority (i.e. a lower priority code)
                // has claimed this prefix.  Release the previous provider's
                // claim.
                //

                ACQUIRE_LOCK( &MupPrefixTableLock );

                if ( knownPrefix->InTable ) {
		    RtlRemoveUnicodePrefix(&MupPrefixTable, &knownPrefix->TableEntry);
		    RemoveEntryList(&knownPrefix->ListEntry);
		    knownPrefix->InTable = FALSE;
                }

                RELEASE_LOCK( &MupPrefixTableLock );

		knownPrefix->Active = FALSE;


                //
                // If Dfs generated this query there will not have been anything
                // stored in the knowPrefix->Prefix, so we check if there is indeed
                // anything to free.
                //

                if (knownPrefix->Prefix.Length > 0 && knownPrefix->Prefix.Buffer != NULL) {
                    ExFreePool(knownPrefix->Prefix.Buffer);
                    knownPrefix->Prefix.Length = knownPrefix->Prefix.MaximumLength = 0;
                    knownPrefix->Prefix.Buffer = NULL;
		    knownPrefix->PrefixStringAllocated = FALSE;
                }
                if(knownPrefix->UncProvider) {
                    MupDereferenceUncProvider( knownPrefix->UncProvider );
		    knownPrefix->UncProvider = NULL;
                }

            } else {

                //
                // The current provider keeps ownership of the prefix.
                //

		MupDereferenceUncProvider( queryPathContext->Provider );
                goto not_this_one;
            }
        }

        //
        // This provider gets the prefix.
        //

        masterContext->Provider = queryPathContext->Provider;
	masterContext->ErrorStatus = status;
        //
        // We have found a match.  Attempt to remember it.
        //

        if (masterContext->FileObject->FsContext2 != UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT)) {

            buffer = ExAllocatePoolWithTag(
                        PagedPool,
                        lengthAccepted,
                        ' puM');

            if (buffer != NULL) {

                RtlMoveMemory(
                    buffer,
                    masterContext->FileObject->FileName.Buffer,
                    lengthAccepted
                    );

                //
                // Copy the reference provider pointer for the known prefix
                // block.
                //

                knownPrefix->UncProvider = masterContext->Provider;
                knownPrefix->Prefix.Buffer = (PWCH)buffer;
                knownPrefix->Prefix.Length = (USHORT)lengthAccepted;
                knownPrefix->Prefix.MaximumLength = (USHORT)lengthAccepted;
                knownPrefix->PrefixStringAllocated = TRUE;

                ACQUIRE_LOCK( &MupPrefixTableLock );

                if (RtlInsertUnicodePrefix(
                        &MupPrefixTable,
                        &knownPrefix->Prefix,
                        &knownPrefix->TableEntry) == TRUE) {

                    InsertTailList( &MupPrefixList, &knownPrefix->ListEntry);
                    knownPrefix->InTable = TRUE;
                    knownPrefix->Active = TRUE;

                } else {

                    knownPrefix->InTable = FALSE;

                }

                RELEASE_LOCK( &MupPrefixTableLock );

            } else {

                knownPrefix->InTable = FALSE;

            }

        }



    } else { 

	MupDereferenceUncProvider( queryPathContext->Provider );

	if (masterContext->Provider == NULL) {

	    //
	    // If our error status is more significant than the error status
	    //  stored in the masterContext, then put ours there
	    //

	    ULONG newError, oldError;

	    //
	    // MupOrderedErrorList is a list of error codes ordered from least
	    //  important to most important.  We're calling down to multiple
	    //  redirectors, but we can only return 1 error code on complete failure.
	    //
	    // To figure out which error to return, we look at the stored error and
	    //  the current error.  We return the error having the highest index in
	    //  the MupOrderedErrorList
	    //
	    if( NT_SUCCESS( masterContext->ErrorStatus ) ) {
		masterContext->ErrorStatus = status;
	    } else {
		for( oldError = 0; MupOrderedErrorList[ oldError ]; oldError++ )
		    if( masterContext->ErrorStatus == MupOrderedErrorList[ oldError ] )
			break;

		    for( newError = 0; newError < oldError; newError++ )
			if( status == MupOrderedErrorList[ newError ] )
			    break;

			if( newError >= oldError ) {
			    masterContext->ErrorStatus = status;
			}
	    }

	}
    }

not_this_one:


    //
    // Free our buffers
    //

    ExFreePool( qpResponse );
    ExFreePool( queryPathContext );
    IoFreeIrp( Irp );




    RELEASE_LOCK( &masterContext->Lock );
    MupDereferenceMasterQueryContext( masterContext );

    //
    // Return more processing required to the IO system so that it
    // doesn't attempt further processing on the IRP we just freed.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//+----------------------------------------------------------------------------
//
//  Function:   MupFlushPrefixEntry
//
//  Synopsis:   Given a pathname, checks if the mup has the prefix cached.
//              It removes the entry if it exists from the mup cache
//
//  Arguments:  [FileName] -- pathname which needs to be removed.
//
//  Returns:    TRUE if entry found in mup cache. False otherwise.
//
//-----------------------------------------------------------------------------



BOOLEAN
MupFlushPrefixEntry(
   PUNICODE_STRING pathName)
{
    PUNICODE_PREFIX_TABLE_ENTRY entry;
    PKNOWN_PREFIX knownPrefix;

    ACQUIRE_LOCK( &MupPrefixTableLock );

    entry = RtlFindUnicodePrefix( &MupPrefixTable, pathName, TRUE );

    if (entry != NULL) {
        knownPrefix = CONTAINING_RECORD( entry, KNOWN_PREFIX, TableEntry );
        if ( knownPrefix->InTable ) {
            MupRemoveKnownPrefixEntry( knownPrefix );
        }
    }
    RELEASE_LOCK( &MupPrefixTableLock );
    
    return (entry != NULL) ? TRUE : FALSE;
}



//+----------------------------------------------------------------------------
//
//  Function:   MupInvalidatePrefixTable
//
//  Synopsis:   Removes all the entries from the mup prefix table.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//-----------------------------------------------------------------------------


VOID
MupInvalidatePrefixTable(VOID)
{
    PLIST_ENTRY listEntry;
    PKNOWN_PREFIX knownPrefix;
    
    ACQUIRE_LOCK( &MupPrefixTableLock );

    listEntry = MupPrefixList.Flink;
    while ( listEntry != &MupPrefixList ) {
        knownPrefix = CONTAINING_RECORD( listEntry, KNOWN_PREFIX, ListEntry );
        listEntry = listEntry->Flink;
        if ( knownPrefix->InTable ) {
            MupRemoveKnownPrefixEntry( knownPrefix );
        }
    }

    RELEASE_LOCK( &MupPrefixTableLock );
}

VOID
MupRemoveKnownPrefixEntry(
       PKNOWN_PREFIX knownPrefix
)
{
    MUP_TRACE_LOW(KNOWN_PREFIX, MupRemoveKnownPrefixEntry,
                  LOGPTR(knownPrefix));

     RtlRemoveUnicodePrefix(&MupPrefixTable, &knownPrefix->TableEntry);
     RemoveEntryList(&knownPrefix->ListEntry);
     knownPrefix->InTable = FALSE;
     MupDereferenceKnownPrefix(knownPrefix);
}


NTSTATUS
IsThisASysVolPath(
    IN PUNICODE_STRING PathName,
    IN PUNICODE_STRING DCName)
{
/*++

Routine Description:

    Determines whether a given path is a domain-based path or not
    The general algorithm is:

      - Extract the first component of the path
      - See if it the domain name
      - If it is, and the 2nd component is SYSVOL or NETLOGON, return the DCName

Arguments

    PathName - Name of entire file
    DCName - If this is a domain-based path, this is the name of
                        a dc in the domain.

Returns value

    STATUS_SUCCESS -- PathName is a domain-based path
    STATUS_BAD_NETWORK_PATH -- PathName is not a domain-based path

--*/
    NTSTATUS status;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PUNICODE_STRING pName;
    UNICODE_STRING RootName;
    UNICODE_STRING ShareName;
    USHORT i;
    USHORT j;
    PDFS_PKT Pkt;
    BOOLEAN pktLocked;

    DfsDbgTrace(+1, Dbg, "IsThisASysVolPath: PathName %wZ \n", PathName);

    //
    // Only proceed if the first character is a backslash.
    //

    if (PathName->Buffer[0] != UNICODE_PATH_SEP) {
        DfsDbgTrace(-1, Dbg, "PathName does not begin with backslash\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    //
    // Find the first component in the name.
    //

    for (i = 1;
            i < PathName->Length/sizeof(WCHAR) &&
                PathName->Buffer[i] != UNICODE_PATH_SEP;
                    i++) {
        NOTHING;
    }

    if (PathName->Buffer[i] != UNICODE_PATH_SEP) {
        DfsDbgTrace(-1, Dbg, "Did not find second backslash\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    RootName.Length = (i-1) * sizeof(WCHAR);
    RootName.MaximumLength = RootName.Length;
    RootName.Buffer = &PathName->Buffer[1];

    if (RootName.Length == 0)
        return( STATUS_BAD_NETWORK_PATH );

    //
    // Figure out the share name
    //

    for (j = i+1;
            j < PathName->Length/sizeof(WCHAR) &&
                PathName->Buffer[j] != UNICODE_PATH_SEP;
                        j++) {
         NOTHING;
    }

    ShareName.Length = (j - i - 1) * sizeof(WCHAR);
    ShareName.MaximumLength = ShareName.Length;
    ShareName.Buffer = &PathName->Buffer[i+1];

    if (ShareName.Length == 0 || DfspIsSysVolShare(&ShareName) == FALSE)
        return( STATUS_BAD_NETWORK_PATH );

    Pkt = _GetPkt();
    PktAcquireShared(TRUE, &pktLocked);

    if (
        (Pkt->DomainNameFlat.Buffer != NULL
            &&
        Pkt->DomainNameDns.Buffer != NULL
            &&
        Pkt->DCName.Buffer != NULL)
            &&
        (RtlCompareUnicodeString(&RootName, &Pkt->DomainNameFlat, TRUE) == 0
            ||
        RtlCompareUnicodeString(&RootName, &Pkt->DomainNameDns, TRUE) == 0)
    ) {
        pName = &Pkt->DCName;
        DCName->Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            pName->MaximumLength,
                            ' puM');
        if (DCName->Buffer != NULL) {
            DCName->Length = pName->Length;
            DCName->MaximumLength = pName->MaximumLength;
            RtlCopyMemory(
                DCName->Buffer,
                pName->Buffer,
                pName->MaximumLength);
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        status = STATUS_BAD_NETWORK_PATH;
    }

    PktRelease();
    DfsDbgTrace(-1, Dbg, "IsThisASysVolPath: Exit -> %08lx\n", LongToPtr( status ) );
    return status;

}

NTSTATUS
MupDomainToDC(
    PUNICODE_STRING RootName,
    PUNICODE_STRING DCName)
{
/*++

Routine Description:

    This routine rewrites the file name of a domain-based path into a dc-based
    path.  Ex:  \domainfoo\sysvol -> \dc1\sysvol

Arguments:

    RootName - The RootName to rewrite

    DCName - The name of the DC to change the path to

Return Value:

    NTSTATUS - The status of the operation

--*/
    ULONG Size;
    PCHAR Buffer;
    PWCHAR pBuf;
    PWCHAR OrgBuffer;

    PAGED_CODE();

    DfsDbgTrace(+1, Dbg, "MupDomainToDC: RootName = %wZ\n", RootName);

    //
    // Only proceed if the first character is a backslash.
    //

    if (RootName->Buffer == NULL) {
        DfsDbgTrace(-1, Dbg, "RootName is NULL\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    if (RootName->Buffer[0] != UNICODE_PATH_SEP) {
        DfsDbgTrace(-1, Dbg, "RootName does not begin with backslash\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    OrgBuffer = RootName->Buffer;

    //
    // Skip over leading UNICODE_PATH_SEP
    //

    RootName->Length -= sizeof(WCHAR);
    RootName->MaximumLength -= sizeof(WCHAR);
    RootName->Buffer++;

    //
    // Motor along until end of string or a UNICODE_PATH_SEP
    //

    while (RootName->Length > 0 && RootName->Buffer[0] != UNICODE_PATH_SEP) {
        RootName->Length -= sizeof(WCHAR);
        RootName->MaximumLength -= sizeof(WCHAR);
        RootName->Buffer++;
    }

    if (RootName->Length == 0) {
        DfsDbgTrace(-1, Dbg, "Did not find second backslash\n", 0);
        return( STATUS_BAD_NETWORK_PATH );

    }
        
    //
    //  Allocate storage for the new file name.
    //

    Size = sizeof(WCHAR) +          // leading UNICODE_PATH_SEP
                DCName->Length +
                    RootName->Length;

    Buffer = ExAllocatePoolWithTag(
                 PagedPool,
                 Size,
                 ' puM');

    if ( Buffer ==  NULL)
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // Leading UNICODE_PATH_SEP's
    //

    pBuf = (WCHAR *)Buffer;
    *pBuf++ = UNICODE_PATH_SEP;

    //
    // Copy the DC name to the buffer
    //

    RtlMoveMemory(
        pBuf,
        DCName->Buffer,
        DCName->Length);

    pBuf += DCName->Length / sizeof(WCHAR);

    //
    // Append the trailing file name
    //

    RtlMoveMemory(
        pBuf,
        RootName->Buffer,
        RootName->Length);

    //
    // Free the old file name string buffer.
    //

    ExFreePool( OrgBuffer );

    RootName->Buffer = (PWCHAR)Buffer;
    RootName->Length = (USHORT) Size;
    RootName->MaximumLength = (USHORT) Size;

    DfsDbgTrace(+1, Dbg, "MupDomainToDC: Exit\n", 0);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements the file close routine for MUP.

Author:

    Manny Weiser (mannyw)    28-Dec-1991

Revision History:

--*/

#include "mup.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)


NTSTATUS
MupCloseVcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
MupCloseFcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupClose )
#pragma alloc_text( PAGE, MupCloseFcb )
#pragma alloc_text( PAGE, MupCloseVcb )
#endif

NTSTATUS
MupClose (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the close IRP.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the IRP.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID fsContext, fsContext2;
    PFILE_OBJECT FileObject;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupClose\n", 0);

    if (MupEnableDfs) {
        if ((MupDeviceObject->DeviceObject.DeviceType == FILE_DEVICE_DFS) ||
                (MupDeviceObject->DeviceObject.DeviceType ==
                       FILE_DEVICE_DFS_FILE_SYSTEM)) {
            status = DfsFsdClose((PDEVICE_OBJECT) MupDeviceObject, Irp);
            return( status );
	}
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  Get the current stack location
        //

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        FileObject = irpSp->FileObject;
        MUP_TRACE_HIGH(TRACE_IRP, MupClose_Entry,
                       LOGPTR(MupDeviceObject)
                       LOGPTR(Irp)
                       LOGPTR(FileObject));

        DebugTrace(+1, Dbg, "MupClose...\n", 0);
        DebugTrace( 0, Dbg, " Irp            = %08lx\n", (ULONG)Irp);

        //
        // Decode the file object to figure out who we are.
        //

        (PVOID)MupDecodeFileObject( irpSp->FileObject,
                                   &fsContext,
                                   &fsContext2 );

        if ( fsContext == NULL ) {

            DebugTrace(0, Dbg, "The file is disconnected\n", 0);

            MupCompleteRequest( Irp, STATUS_INVALID_HANDLE );
            status = STATUS_INVALID_HANDLE;
            MUP_TRACE_HIGH(ERROR, MupClose_Error1, 
                           LOGSTATUS(status)
                           LOGPTR(MupDeviceObject)
                           LOGPTR(FileObject)
                           LOGPTR(Irp));

            DebugTrace(-1, Dbg, "MupClose -> %08lx\n", status );
            FsRtlExitFileSystem();
            return status;
        }

        //
        // Ignore the return code from MupDecode.  Parse the fsContext
        // to decide how to process the close IRP.
        //

        switch ( BlockType( fsContext ) ) {

        case BlockTypeVcb:

            status = MupCloseVcb( MupDeviceObject,
                                  Irp,
                                  (PVCB)fsContext,
                                  irpSp->FileObject
                                  );

            //
            // Complete the close IRP.
            //

            MupCompleteRequest( Irp, STATUS_SUCCESS );
            break;


        case BlockTypeFcb:

            //
            // MupDecodeFileObject bumped the refcount on the fcb,
            // so we decrement that extra ref here.
            //

            MupDereferenceFcb((PFCB)fsContext);

            status = MupCloseFcb( MupDeviceObject,
                                  Irp,
                                  (PFCB)fsContext,
                                  irpSp->FileObject
                                  );

            //
            // Complete the close IRP.
            //

            MupCompleteRequest( Irp, STATUS_SUCCESS );
            break;

    #ifdef MUPDBG
        default:
            //
            // This is not one of ours.
            //
            KeBugCheckEx( FILE_SYSTEM, 1, 0, 0, 0 );
            break;
    #else
        default:
            //
            // Complete the IRP with an error
            //
            MupCompleteRequest(Irp,STATUS_INVALID_HANDLE);
            status = STATUS_INVALID_HANDLE;
            MUP_TRACE_HIGH(ERROR, MupClose_Error2, 
                           LOGSTATUS(status)
                           LOGPTR(MupDeviceObject)
                           LOGPTR(FileObject)
                           LOGPTR(Irp));

            break;
    #endif
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();

    }

    FsRtlExitFileSystem();


    MUP_TRACE_HIGH(TRACE_IRP, MupClose_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(MupDeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    DebugTrace(-1, Dbg, "MupClose -> %08lx\n", status);
    return status;
}


NTSTATUS
MupCloseVcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine closes the a file object that had opened the file system.

Arguments:

    MupDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the IRP associate with the close.

    Vcb - Supplies the VCB for the MUP.

    FileObject - Supplies the file object being closed.

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    Irp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCloseVcb, Vcb = %08lx\n", (ULONG)Vcb);


    //
    // Acquire exclusive access to the VCB.
    //

    MupAcquireGlobalLock();

    try {

        //
        // Clear the referenced pointer to the VCB in the file object
        // and derefence the VCB.
        //

        ASSERT ( FileObject->FsContext == Vcb );

        MupSetFileObject( FileObject, NULL, NULL );
        MupDereferenceVcb( Vcb );

    } finally {

        MupReleaseGlobalLock( );
        DebugTrace(-1, Dbg, "MupCloseVcb -> STATUS_SUCCESS\n", 0);

    }

    //
    // Return to the caller.
    //

    return STATUS_SUCCESS;
}


NTSTATUS
MupCloseFcb (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine closes the a file control block.

Arguments:

    MupDeviceObject - Supplies a pointer to our device object.

    Irp - Supplies the IRP associate with the close.

    Fcb - Supplies the FCB to close.

    FileObject - Supplies the file object being closed.

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    MupDeviceObject; Irp;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupCloseFcb, Fcb = %08lx\n", (ULONG)Fcb);

    //
    // Acquire exclusive access to the VCB.
    //

    MupAcquireGlobalLock();

    try {

        //
        // Clear the referenced pointer to the VCB in the file object
        // and derefence the VCB.
        //

        ASSERT ( FileObject->FsContext == Fcb );

        MupSetFileObject( FileObject, NULL, NULL );
        MupDereferenceFcb( Fcb );

    } finally {

        MupReleaseGlobalLock( );
        DebugTrace(-1, Dbg, "MupCloseFcb -> STATUS_SUCCESS\n", 0);

    }

    //
    // Return to the caller.
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\creds.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       creds.c
//
//  Contents:   Code to handle user-defined credentials
//
//  Classes:    None
//
//  Functions:  DfsCreateCredentials --
//              DfsFreeCredentials --
//              DfsInsertCredentials --
//              DfsDeleteCredentials --
//              DfsLookupCredentials --
//
//  History:    March 18, 1996          Milans Created
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"

#include <align.h>
#include <ntddnfs.h>

#include "dnr.h"
#include "rpselect.h"
#include "creds.h"

VOID
DfspFillEa(
    OUT PFILE_FULL_EA_INFORMATION EA,
    IN LPSTR EaName,
    IN PUNICODE_STRING EaValue);

NTSTATUS
DfspTreeConnectToService(
    IN PDFS_SERVICE Service,
    IN PDFS_CREDENTIALS Creds);

VOID
DfspDeleteAllAuthenticatedConnections(
    IN PDFS_CREDENTIALS Creds);

NTSTATUS
DfsCompleteDeleteTreeConnection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx);

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE,DfsCreateCredentials)
#pragma alloc_text(PAGE,DfsVerifyCredentials)
#pragma alloc_text(PAGE,DfspFillEa)
#pragma alloc_text(PAGE,DfsFreeCredentials)
#pragma alloc_text(PAGE,DfsInsertCredentials)
#pragma alloc_text(PAGE,DfsDeleteCredentials)
#pragma alloc_text(PAGE,DfsLookupCredentials)
#pragma alloc_text(PAGE,DfsLookupCredentialsByServerShare)
#pragma alloc_text(PAGE,DfspTreeConnectToService)
#pragma alloc_text(PAGE,DfspDeleteAllAuthenticatedConnections)
#pragma alloc_text(PAGE,DfsDeleteTreeConnection)

#endif // ALLOC_PRAGMA

//+----------------------------------------------------------------------------
//
//  Function:   DfsCreateCredentials
//
//  Synopsis:   Creates a DFS_CREDENTIALS structure from a
//              FILE_DFS_DEF_ROOT_CREDENTIALS structure.
//
//  Arguments:  [CredDef] -- The input PFILE_DFS_DEF_ROOT_CREDENTIALS.
//              [CredDefSize] -- Size in bytes of *CredDef.
//              [Creds] -- On successful return, contains a pointer to the
//                      allocated PDFS_CREDENTIALS structure.
//
//  Returns:    [STATUS_SUCCESS] -- Allocated credentials
//
//              [STATUS_INVALID_PARAMETER] -- CredDef didn't pass mustard.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate pool.
//
//-----------------------------------------------------------------------------

#define DEF_NAME_TO_UNICODE_STRING(srcLength, dest, srcBuf, destBuf)    \
    if ((srcLength)) {                                                  \
        (dest)->Length = (dest)->MaximumLength = srcLength;             \
        (dest)->Buffer = (destBuf);                                     \
        RtlMoveMemory((dest)->Buffer, (srcBuf), (dest)->Length);        \
        srcBuf += ((dest)->Length / sizeof(WCHAR));                     \
        destBuf += ((dest)->Length / sizeof(WCHAR));                    \
    }

#ifdef TERMSRV

NTSTATUS
DfsCreateCredentials(
    IN PFILE_DFS_DEF_ROOT_CREDENTIALS CredDef,
    IN ULONG CredDefSize,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_CREDENTIALS *Creds
    )

#else // TERMSRV

NTSTATUS
DfsCreateCredentials(
    IN PFILE_DFS_DEF_ROOT_CREDENTIALS CredDef,
    IN ULONG CredDefSize,
    IN PLUID LogonID,
    OUT PDFS_CREDENTIALS *Creds)

#endif // TERMSRV
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG totalSize;
    PDFS_CREDENTIALS creds;
    PWCHAR nameSrc, nameBuf;
    PFILE_FULL_EA_INFORMATION ea;
    ULONG eaLength;

    totalSize = CredDef->DomainNameLen +
                    CredDef->UserNameLen +
                        CredDef->PasswordLen +
                            CredDef->ServerNameLen +
                                CredDef->ShareNameLen;

    //
    // Validate the CredDef buffer
    //

    if ((totalSize + sizeof(FILE_DFS_DEF_ROOT_CREDENTIALS) - sizeof(WCHAR)) >
            CredDefSize)
        status = STATUS_INVALID_PARAMETER;
    else if (CredDef->ServerNameLen == 0)
        status = STATUS_INVALID_PARAMETER;
    else if (CredDef->ShareNameLen == 0)
        status = STATUS_INVALID_PARAMETER;

    //
    // Allocate the new DFS_CREDENTIALS structure
    //

    if (NT_SUCCESS(status)) {

        //
        // Add in the size of the DFS_CREDENTIALS_STRUCTURE itself.
        //

        totalSize += sizeof(DFS_CREDENTIALS);

        //
        // Add in the size of the EA_BUFFER that we will create. The
        // eaLength has room for 4 FILE_FULL_EA_INFORMATION structures,
        // the names and values of the four EAs we will use, and, since each
        // EA structure has to be long-word aligned, 4 ULONGs.
        //

        eaLength = 4 * sizeof(FILE_FULL_EA_INFORMATION) +
                        sizeof(EA_NAME_DOMAIN) +
                            sizeof(EA_NAME_USERNAME) +
                                sizeof(EA_NAME_PASSWORD) +
                                    sizeof(EA_NAME_CSCAGENT) +
                                        CredDef->DomainNameLen +
                                            CredDef->UserNameLen +
                                                CredDef->PasswordLen +
                                                    4 * sizeof(ULONG);

        if (CredDef->Flags & DFS_USE_NULL_PASSWORD) {
            eaLength += sizeof(UNICODE_NULL);
            totalSize += sizeof(UNICODE_NULL);
        }

        //
        // The buffers for DomainName, UserName etc. will start right after
        // the EaBuffer of DFS_CREDENTIALS. So, EaLength has to be WCHAR
        // aligned.
        //

        eaLength = ROUND_UP_COUNT(eaLength, ALIGN_WCHAR);

        //
        // Now, allocate the pool
        //

        creds = (PDFS_CREDENTIALS) ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        totalSize + eaLength,
                                        ' puM');

        if (creds == NULL)
            status = STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Fill up the DFS_CREDENTIALS structure.
    //

    if (NT_SUCCESS(status)) {

        nameSrc = CredDef->Buffer;

        nameBuf =
            (PWCHAR) ((PUCHAR) creds + sizeof(DFS_CREDENTIALS) + eaLength);

        RtlZeroMemory( creds, sizeof(DFS_CREDENTIALS) );

        DEF_NAME_TO_UNICODE_STRING(
            CredDef->DomainNameLen,
            &creds->DomainName,
            nameSrc,
            nameBuf);

        DEF_NAME_TO_UNICODE_STRING(
            CredDef->UserNameLen,
            &creds->UserName,
            nameSrc,
            nameBuf);

        if (CredDef->Flags & DFS_USE_NULL_PASSWORD) {

            LPWSTR nullPassword = L"";

            DEF_NAME_TO_UNICODE_STRING(
                sizeof(UNICODE_NULL),
                &creds->Password,
                nullPassword,
                nameBuf);

        } else {

            DEF_NAME_TO_UNICODE_STRING(
                CredDef->PasswordLen,
                &creds->Password,
                nameSrc,
                nameBuf);

        }

        DEF_NAME_TO_UNICODE_STRING(
            CredDef->ServerNameLen,
            &creds->ServerName,
            nameSrc,
            nameBuf);

        DEF_NAME_TO_UNICODE_STRING(
            CredDef->ShareNameLen,
            &creds->ShareName,
            nameSrc,
            nameBuf);

        creds->RefCount = 0;

        creds->NetUseCount = 0;

        eaLength = 0;

        ea = (PFILE_FULL_EA_INFORMATION) &creds->EaBuffer[0];

        if (creds->DomainName.Length != 0) {

            DfspFillEa(ea, EA_NAME_DOMAIN, &creds->DomainName);

            eaLength += ea->NextEntryOffset;

        }

        if (creds->UserName.Length != 0) {

            ea = (PFILE_FULL_EA_INFORMATION)
                    ((PUCHAR) ea + ea->NextEntryOffset);

            DfspFillEa(ea, EA_NAME_USERNAME, &creds->UserName);

            eaLength += ea->NextEntryOffset;

        }

        if (CredDef->Flags & DFS_USE_NULL_PASSWORD) {

            UNICODE_STRING nullPassword;

            RtlInitUnicodeString(&nullPassword, L"");

            ea = (PFILE_FULL_EA_INFORMATION)
                    ((PUCHAR) ea + ea->NextEntryOffset);

            DfspFillEa(ea, EA_NAME_PASSWORD, &nullPassword);

            eaLength += ea->NextEntryOffset;

        } else if (creds->Password.Length != 0) {

            ea = (PFILE_FULL_EA_INFORMATION)
                    ((PUCHAR) ea + ea->NextEntryOffset);

            DfspFillEa(ea, EA_NAME_PASSWORD, &creds->Password);

            eaLength += ea->NextEntryOffset;

        }

        if (CredDef->CSCAgentCreate == TRUE) {

            UNICODE_STRING EmptyUniString;

            RtlInitUnicodeString(&EmptyUniString, NULL);

            ea = (PFILE_FULL_EA_INFORMATION)
                    ((PUCHAR) ea + ea->NextEntryOffset);

            DfspFillEa(ea, EA_NAME_CSCAGENT, &EmptyUniString);

            eaLength += ea->NextEntryOffset;

        }

        ea->NextEntryOffset = 0;

        creds->EaLength = eaLength;

#ifdef TERMSRV
        creds->SessionID = SessionID;
#endif // TERMSRV

	RtlCopyLuid(&creds->LogonID, LogonID);

        *Creds = creds;

    }

    //
    // Done...
    // 

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspFillEa
//
//  Synopsis:   Helper routine to fill up an EA Buffer
//
//  Arguments:  [EA] -- Pointer to FILE_FULL_EA_INFORMATION to fill
//
//              [EaName] -- Name of Ea
//
//              [EaValue] -- Value (UNICODE_STRING) of Ea
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
DfspFillEa(
    OUT PFILE_FULL_EA_INFORMATION EA,
    IN LPSTR EaName,
    IN PUNICODE_STRING EaValue)
{
    ULONG nameLen;

    nameLen = strlen(EaName) + sizeof(CHAR);

    EA->Flags = 0;

    EA->EaNameLength =
        (UCHAR) ROUND_UP_COUNT(nameLen, ALIGN_WCHAR) - sizeof(CHAR);

    EA->EaValueLength = EaValue->Length;

    //
    // Set the last character of EaName to 0 - the IO subsystem checks for
    // this
    //

    EA->EaName[ EA->EaNameLength ] = 0;

    RtlMoveMemory(&EA->EaName[0], EaName, nameLen);

    if (EaValue->Length > 0) {

        RtlMoveMemory(
            &EA->EaName[ EA->EaNameLength + 1 ],
            EaValue->Buffer,
            EA->EaValueLength);

    }

    EA->NextEntryOffset = ROUND_UP_COUNT(
			    FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                EA->EaNameLength +
                                EA->EaValueLength,
                            ALIGN_DWORD);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFreeCredentials
//
//  Synopsis:   Frees up the resources used by the DFS_CREDENTIALS structure.
//              Dual of DfsCreateCredentials
//
//  Arguments:  [Creds] -- The credentials structure to free
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsFreeCredentials(
    PDFS_CREDENTIALS Creds)
{
    ExFreePool( Creds );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsInsertCredentials
//
//  Synopsis:   Inserts a new user credential into DfsData.Credentials queue.
//              Note that if this routine finds an existing credential
//              record, it will free up the passed in one, bump up the ref
//              count on the existing one, return a pointer to the
//              existing one, and return STATUS_OBJECT_NAME_COLLISION.
//
//  Arguments:  [Creds] -- Pointer to DFS_CREDENTIALS structure to insert.
//              [ForDevicelessConnection] -- If TRUE, the creds are being
//                      inserted because the caller wants to create a
//                      deviceless connection.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully inserted structure
//
//              [STATUS_NETWORK_CREDENTIAL_CONFLICT] -- There is already
//                      another set of credentials for the given server\share.
//
//              [STATUS_OBJECT_NAME_COLLISION] -- There is already another
//                      net use to the same server\share with the same
//                      credentials.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsInsertCredentials(
    IN OUT PDFS_CREDENTIALS *Creds,
    IN BOOLEAN ForDevicelessConnection)
{

    NTSTATUS status = STATUS_SUCCESS;
    PDFS_CREDENTIALS creds, existingCreds;

    creds = *Creds;

    ASSERT(creds->ServerName.Length != 0);
    ASSERT(creds->ShareName.Length != 0);

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

#ifdef TERMSRV

    existingCreds =
        DfsLookupCredentialsByServerShare(
            &creds->ServerName,
            &creds->ShareName,
            creds->SessionID,
            &creds->LogonID );

#else // TERMSRV

    existingCreds = DfsLookupCredentialsByServerShare(
                        &creds->ServerName,
                        &creds->ShareName,
                        &creds->LogonID );

#endif // TERMSRV

    if (existingCreds != NULL) {
        
        if (
            (creds->DomainName.Length > 0 && !RtlEqualUnicodeString(
                                                    &existingCreds->DomainName,
                                                    &creds->DomainName,
                                                    TRUE))
                    ||
            (creds->UserName.Length > 0 && !RtlEqualUnicodeString(
                                                    &existingCreds->UserName,
                                                    &creds->UserName,
                                                    TRUE))
                    ||
	    //
	    // For compatibility reasons, check for password inconsistency ONLY
	    // if we have a previously setup credentials and the previous 
	    // credentials had explicit password and the current request
	    // has explicitly specified password.
	    // rdr2\rdbss\rxconnct.c also has a similar check for the rdr.
	    //

            (existingCreds->Password.Length > 0 && creds->Password.Length > 0 && !RtlEqualUnicodeString(
                                                    &existingCreds->Password,
                                                    &creds->Password,
                                                    TRUE))
        ) {

            status = STATUS_NETWORK_CREDENTIAL_CONFLICT;

        } else {
	    //
	    // Do this for both deviceless and has device cases.
	    // With deep net uses of deviceless, multiple DevlessRoots
	    // may point to the same credentials.
	    //
	    existingCreds->NetUseCount++;
	    existingCreds->RefCount++;

            DfsFreeCredentials( *Creds );

            *Creds = existingCreds;

            status = STATUS_OBJECT_NAME_COLLISION;
        }

    } else {

        ASSERT(creds->RefCount == 0);

        ASSERT(creds->NetUseCount == 0);

        creds->RefCount = 1;

        creds->NetUseCount = 1;

        InsertTailList( &DfsData.Credentials, &creds->Link );

        status = STATUS_SUCCESS;

    }

    if (status != STATUS_NETWORK_CREDENTIAL_CONFLICT) {

        if (ForDevicelessConnection)
            (*Creds)->Flags |= CRED_IS_DEVICELESS;
        else
            (*Creds)->Flags |= CRED_HAS_DEVICE;

    }

    ExReleaseResourceLite( &DfsData.Resource );

    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteCredentials
//
//  Synopsis:   Deletes a user credential record. This is the dual of
//              DfsInsertCredentials, NOT DfsCreateCredentials.
//
//  Arguments:  [Creds] -- Pointer to DFS_CREDENTIALS record to delete.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsDeleteCredentials(
    IN PDFS_CREDENTIALS Creds)
{
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    Creds->NetUseCount--;

    Creds->RefCount--;

    if (Creds->NetUseCount == 0) {

        DfspDeleteAllAuthenticatedConnections( Creds );

        RemoveEntryList( &Creds->Link );

        InsertTailList( &DfsData.DeletedCredentials, &Creds->Link );

    }

    ExReleaseResourceLite( &DfsData.Resource );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsLookupCredentials
//
//  Synopsis:   Looks up a credential, if any, associated with a file name.
//
//  Arguments:  [FileName] -- Name of file. Assumed to have atleast a
//                      \server\share part.
//
//  Returns:    Pointer to DFS_CREDENTIALS to use, NULL if not found.
//
//-----------------------------------------------------------------------------


#ifdef TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentials(
    IN PUNICODE_STRING FileName,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentials(
    IN PUNICODE_STRING FileName,
    IN PLUID LogonID
    )

#endif // TERMSRV
{
    UNICODE_STRING server, share;
    USHORT i;

    //
    // FileName has to be atleast \a\b
    //

    if (FileName->Length < 4 * sizeof(WCHAR))
        return( NULL );

    if (FileName->Buffer[0] != UNICODE_PATH_SEP)
        return( NULL );

    server.Buffer = &FileName->Buffer[1];

    for (i = 1, server.Length = 0;
            i < FileName->Length/sizeof(WCHAR) &&
                FileName->Buffer[i] != UNICODE_PATH_SEP;
                    i++, server.Length += sizeof(WCHAR)) {
         NOTHING;
    }

    server.MaximumLength = server.Length;

    i++;                                         // Go past the backslash

    share.Buffer = &FileName->Buffer[i];

    for (share.Length = 0;
            i < FileName->Length/sizeof(WCHAR) &&
                    FileName->Buffer[i] != UNICODE_PATH_SEP;
                        i++, share.Length += sizeof(WCHAR)) {
          NOTHING;
    }

    share.MaximumLength = share.Length;

    if ((server.Length == 0) || (share.Length == 0))
        return( NULL );


#ifdef TERMSRV

    return DfsLookupCredentialsByServerShare( &server, &share, SessionID, LogonID );

#else // TERMSRV

    return DfsLookupCredentialsByServerShare( &server, &share, LogonID );

#endif // TERMSRV

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsLookupCredentialsByServerShare
//
//  Synopsis:   Searches DfsData.Credentials for credentials given a server
//              and share name.
//
//  Arguments:  [ServerName] -- Name of server to match.
//              [ShareName] -- Name of share to match.
//
//  Returns:    Pointer to DFS_CREDENTIALS, NULL if not found.
//
//-----------------------------------------------------------------------------

#ifdef TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentialsByServerShare(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentialsByServerShare(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PLUID LogonID
    )

#endif // TERMSRV
{
    PLIST_ENTRY link;
    PDFS_CREDENTIALS matchedCreds = NULL;

    for (link = DfsData.Credentials.Flink;
            link != &DfsData.Credentials && matchedCreds == NULL;
                link = link->Flink) {

         PDFS_CREDENTIALS creds;

         creds = CONTAINING_RECORD(link, DFS_CREDENTIALS, Link);

         if (RtlEqualUnicodeString(ServerName, &creds->ServerName, TRUE) &&
                RtlEqualUnicodeString(ShareName, &creds->ShareName, TRUE)) {
#ifdef TERMSRV

             if( (creds->SessionID == SessionID) &&
	                RtlEqualLuid(&creds->LogonID, LogonID) ) {
                matchedCreds = creds;
             }

#else // TERMSRV
             if( RtlEqualLuid(&creds->LogonID, LogonID) ) {
	     
	         matchedCreds = creds;
             }

#endif // TERMSRV
         }


    }

    return( matchedCreds );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsVerifyCredentials
//
//  Synopsis:   Returns the result of trying to connect to a Dfs share using
//              the supplied credentials
//
//  Arguments:  [Prefix] -- The Dfs Prefix to connect to.
//              [Creds] -- The DFS_CREDENTIALS record to use for connecting.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully connected.
//
//              [STATUS_BAD_NETWORK_PATH] -- Unable to find Prefix
//                      in Pkt or a server for prefix could not be found.
//
//              NT Status of Tree Connect attempt
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsVerifyCredentials(
    IN PUNICODE_STRING Prefix,
    IN PDFS_CREDENTIALS Creds)
{
    NTSTATUS status;
    UNICODE_STRING remPath, shareName;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    PDFS_SERVICE service;
    ULONG i, USN;
    BOOLEAN pktLocked, fRetry;
    UNICODE_STRING UsePrefix;

    DfsGetServerShare( &UsePrefix,
                       Prefix );

    pkt = _GetPkt();


    //
    // We acquire Pkt exclusive because we might tear down the IPC$ connection
    // to a server while trying to establish a connection with supplied
    // credentials.
    //

    PktAcquireExclusive( TRUE, &pktLocked );

    do {

        fRetry = FALSE;

        pktEntry = PktLookupEntryByPrefix( pkt, &UsePrefix, &remPath );


        if (pktEntry != NULL) {

            InterlockedIncrement(&pktEntry->UseCount);

            USN = pktEntry->USN;

            status = STATUS_BAD_NETWORK_PATH;

            for (i = 0; i < pktEntry->Info.ServiceCount; i++) {

                service = &pktEntry->Info.ServiceList[i];

                status = DfspTreeConnectToService(service, Creds);

                //
                // If tree connect succeeded, we are done.
                //

                if (NT_SUCCESS(status))
                    break;

                //
                // If tree connect failed with an "interesting error" like
                // STATUS_ACCESS_DENIED, we are done.
                //

                if (!ReplIsRecoverableError(status))
                    break;

                //
                // Tree connect failed because of an error like host not
                // reachable. In that case, we want to go on to the next
                // server in the list. But before we do that, we have to see
                // if the pkt changed on us while we were off doing the tree
                // connect.
                //

                if (USN != pktEntry->USN) {

                    fRetry = TRUE;

                    break;

                }

            }

            InterlockedDecrement(&pktEntry->UseCount);

        } else {

            status = STATUS_BAD_NETWORK_PATH;

        }

    } while ( fRetry );

    PktRelease();

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspTreeConnectToService
//
//  Synopsis:   Helper routine to tree connect to a DFS_SERVICE with supplied
//              credentials.
//
//  Arguments:  [Service] -- The service to connect to
//              [Creds] -- The credentials to use to tree connect
//
//  Returns:    NT Status of tree connect
//
//  Notes:      This routine assumes that the Pkt has been acquired before
//              being called. This routine will release and reacquire the Pkt
//              so the caller should be prepared for the event that the Pkt
//              has changed after a call to this routine.
//
//-----------------------------------------------------------------------------


NTSTATUS
DfspTreeConnectToService(
    IN PDFS_SERVICE Service,
    IN PDFS_CREDENTIALS Creds)
{
    NTSTATUS status;
    UNICODE_STRING shareName;
    HANDLE treeHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN pktLocked;
    USHORT i, k;

    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );

    //
    // Compute the share name...
    //

    if (Service->pProvider != NULL &&
            Service->pProvider->DeviceName.Buffer != NULL &&
                Service->pProvider->DeviceName.Length > 0) {

        //
        // We have a provider already - use it
        //

        shareName.MaximumLength =
            Service->pProvider->DeviceName.Length +
                Service->Address.Length;

    } else {

        //
        // We don't have a provider yet - give it to the mup to find one
        //

        shareName.MaximumLength =
            sizeof(DD_NFS_DEVICE_NAME_U) +
                Service->Address.Length;

    }

    shareName.Buffer = ExAllocatePoolWithTag(PagedPool, shareName.MaximumLength, ' puM');

    if (shareName.Buffer != NULL) {

        //
        // If we have a cached connection to the IPC$ share of this server,
        // close it or it might conflict with the credentials supplied here.
        //

        if (Service->ConnFile != NULL) {

            ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

            if (Service->ConnFile != NULL)
                DfsCloseConnection(Service);

            ExReleaseResourceLite(&DfsData.Resource);

        }

        //
        // Now, build the share name to tree connect to.
        //

        shareName.Length = 0;

        if (Service->pProvider != NULL &&
                Service->pProvider->DeviceName.Buffer != NULL &&
                    Service->pProvider->DeviceName.Length > 0) {

            //
            // We have a provider already - use it
            //
 
            RtlAppendUnicodeToString(
                &shareName,
                Service->pProvider->DeviceName.Buffer);

        } else {

            //
            // We don't have a provider yet - give it to the mup to find one
            //

            RtlAppendUnicodeToString(
            &shareName,
            DD_NFS_DEVICE_NAME_U);

        }
 
        RtlAppendUnicodeStringToString(&shareName, &Service->Address);

        //
        // One can only do tree connects to server\share. So, in case
        // pService->Address refers to something deeper than the share,
        // make sure we setup a tree-conn only to server\share. Note that
        // by now, shareName is of the form
        // \Device\LanmanRedirector\server\share<\path>. So, count up to
        // 4 slashes and terminate the share name there.
        //

        for (i = 0, k = 0;
                i < shareName.Length/sizeof(WCHAR) && k < 5;
                    i++) {

            if (shareName.Buffer[i] == UNICODE_PATH_SEP)
                k++;
        }

        shareName.Length = i * sizeof(WCHAR);
        if (k == 5)
            shareName.Length -= sizeof(WCHAR);

        InitializeObjectAttributes(
            &objectAttributes,
            &shareName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        //
        // Release the Pkt before going over the net...
        //

        PktRelease();

        status = ZwCreateFile(
                    &treeHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ |
                        FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                    (PVOID) Creds->EaBuffer,
                    Creds->EaLength);

        if (NT_SUCCESS(status)) {

            PFILE_OBJECT fileObject;

            //
            // 426184, need to check return code for errors.
            //
            status = ObReferenceObjectByHandle(
                          treeHandle,
                          0,
                          NULL,
                          KernelMode,
                          &fileObject,
                          NULL);

            ZwClose( treeHandle );

            if (NT_SUCCESS(status)) {
                DfsDeleteTreeConnection( fileObject, USE_FORCE );
            }
	}


        ExFreePool( shareName.Buffer );

        PktAcquireShared( TRUE, &pktLocked );

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspDeleteAllAuthenticatedConnections
//
//  Synopsis:   Deletes all authenticated connections made using a particular
//              set of credentials that we might have cached. Useful to
//              implement net use /d
//
//  Arguments:  [Creds] -- The Credentials to match against authenticated
//                      connection
//
//  Returns:    Nothing
//
//  Notes:      Pkt and DfsData must have been acquired before calling!
//
//-----------------------------------------------------------------------------

VOID
DfspDeleteAllAuthenticatedConnections(
    IN PDFS_CREDENTIALS Creds)
{
    PDFS_PKT_ENTRY pktEntry;
    ULONG i;
    PDFS_MACHINE_ENTRY machine;

    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() ||
                PKT_LOCKED_FOR_EXCLUSIVE_ACCESS() );

    ASSERT( ExIsResourceAcquiredExclusiveLite( &DfsData.Resource ) );

    for (pktEntry = PktFirstEntry(&DfsData.Pkt);
            pktEntry != NULL;
                pktEntry = PktNextEntry(&DfsData.Pkt, pktEntry)) {

        for (i = 0; i < pktEntry->Info.ServiceCount; i++) {

            //
            // Tear down connection to IPC$ if we have one...
            //

            if (pktEntry->Info.ServiceList[i].ConnFile != NULL)
                DfsCloseConnection( &pktEntry->Info.ServiceList[i] );


            machine = pktEntry->Info.ServiceList[i].pMachEntry;

            if (machine->Credentials == Creds) {

                DfsDeleteTreeConnection(machine->AuthConn, USE_LOTS_OF_FORCE);

                machine->AuthConn = NULL;

                machine->Credentials->RefCount--;

                machine->Credentials = NULL;

            }

        }

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteTreeConnection, public
//
//  Synopsis:   Tears down tree connections given the file object representing
//              the tree connection.
//
//  Arguments:  [TreeConnFileObj] -- The tree connection to tear down.
//              [ForceFilesClosed] -- If TRUE, the tree connection will be
//                      torn down even if files are open on the server
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsDeleteTreeConnection(
    IN PFILE_OBJECT TreeConnFileObj,
    IN ULONG  Level)
{
    PIRP irp;
    KEVENT event;
    static LMR_REQUEST_PACKET req;

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    req.Version = REQUEST_PACKET_VERSION;

    req.Level = Level;

    irp = DnrBuildFsControlRequest(
                TreeConnFileObj,
                &event,
                FSCTL_LMR_DELETE_CONNECTION,
                &req,
                sizeof(req),
                NULL,
                0,
                DfsCompleteDeleteTreeConnection);

    if (irp != NULL) {

        IoCallDriver(
            IoGetRelatedDeviceObject( TreeConnFileObj ),
            irp);

        KeWaitForSingleObject(
            &event,
            UserRequest,
            KernelMode,
            FALSE,           // Alertable
            NULL);           // Timeout

        IoFreeIrp( irp );

        ObDereferenceObject(TreeConnFileObj);

    }

}

NTSTATUS
DfsCompleteDeleteTreeConnection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx)
{

    KeSetEvent( (PKEVENT) Ctx, EVENT_INCREMENT, FALSE );

    return( STATUS_MORE_PROCESSING_REQUIRED );
}



VOID
DfsGetServerShare(
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc)
{
    ULONG i;

    *pDest = *pSrc;


    for (i = 0; ((i < pDest->Length/sizeof(WCHAR)) && (pDest->Buffer[i] == UNICODE_PATH_SEP)); i++)
    {
        NOTHING;
    }
    for (; ((i < pDest->Length/sizeof(WCHAR)) && (pDest->Buffer[i] != UNICODE_PATH_SEP)); i++)
    {
        NOTHING;
    }
    for (i = i + 1; ((i < pDest->Length/sizeof(WCHAR)) && (pDest->Buffer[i] != UNICODE_PATH_SEP)); i++)
    {
        NOTHING;
    }

    if (i <= pDest->Length/sizeof(WCHAR))
    {
        pDest->Length = (USHORT)i * sizeof(WCHAR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\creds.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       creds.h
//
//  Contents:   Code to handle user-defined credentials
//
//  Classes:    None
//
//  Functions:  DfsCreateCredentials --
//              DfsInsertCredentials --
//              DfsDeleteCredentials --
//              DfsLookupCredentials --
//              DfsFreeCredentials --
//
//  History:    March 18, 1996          Milans Created
//
//-----------------------------------------------------------------------------

#ifndef _DFS_CREDENTIALS_
#define _DFS_CREDENTIALS_


#ifdef TERMSRV

NTSTATUS
DfsCreateCredentials(
    IN PFILE_DFS_DEF_ROOT_CREDENTIALS CredDef,
    IN ULONG CredDefSize,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_CREDENTIALS *Creds
    );

#else // TERMSRV

NTSTATUS
DfsCreateCredentials(
    IN PFILE_DFS_DEF_ROOT_CREDENTIALS CredDef,
    IN ULONG CredDefSize,
    IN PLUID LogonID,
    OUT PDFS_CREDENTIALS *Creds);

#endif // TERMSRV

VOID
DfsFreeCredentials(
    PDFS_CREDENTIALS Creds);

NTSTATUS
DfsInsertCredentials(
    IN OUT PDFS_CREDENTIALS *Creds,
    IN BOOLEAN ForDevicelessConnection);

VOID
DfsDeleteCredentials(
    IN PDFS_CREDENTIALS Creds);


#ifdef TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentials(
    IN PUNICODE_STRING FileName,
    IN ULONG SessionID,
    IN PLUID LogonID		   
    );

PDFS_CREDENTIALS
DfsLookupCredentialsByServerShare(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN ULONG SessionID,
    IN PLUID LogonID
    );

#else // TERMSRV

PDFS_CREDENTIALS
DfsLookupCredentials(
    IN PUNICODE_STRING FileName);

PDFS_CREDENTIALS
DfsLookupCredentialsByServerShare(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PLUID LogonID
    );

#endif // TERMSRV

NTSTATUS
DfsVerifyCredentials(
    IN PUNICODE_STRING Prefix,
    IN PDFS_CREDENTIALS Creds);

VOID
DfsDeleteTreeConnection(
    IN PFILE_OBJECT TreeConnFileObj,
    IN ULONG  Level);


PDFS_CREDENTIALS
DfsCaptureCredentials(
    IN PIRP Irp,
    IN PUNICODE_STRING FileName);


VOID
DfsGetServerShare(
    PUNICODE_STRING pDest,
    PUNICODE_STRING pSrc);

#endif // _DFS_CREDENTIALS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\debug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements the debugging function for the MUP.

Author:

    Manny Weiser (mannyw)    27-Dec-1991

Revision History:

--*/

#include "mup.h"
#include "stdio.h"


#ifdef MUPDBG
#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, _DebugTrace )
#endif

VOID
_DebugTrace(
    LONG Indent,
    ULONG Level,
    PSZ X,
    ULONG Y
    )

/*++

Routine Description:

    This routine display debugging information.

Arguments:

    Level - The debug level required to display this message.  If
        level is 0 the message is displayed regardless of the setting
        or the debug level

    Indent - Incremement or the current debug message indent

    X - 1st print parameter

    Y - 2nd print parameter

Return Value:

    None.

--*/

{
    LONG i;
    char printMask[100];

    PAGED_CODE();
    if ((Level == 0) || (MupDebugTraceLevel & Level)) {

        if (Indent < 0) {
            MupDebugTraceIndent += Indent;
        }

        if (MupDebugTraceIndent < 0) {
            MupDebugTraceIndent = 0;
        }

        sprintf( printMask, "%%08lx:%%.*s%s", X );

        i = (LONG)PsGetCurrentThread();
        DbgPrint( printMask, i, MupDebugTraceIndent, "", Y );
        if (Indent > 0) {
            MupDebugTraceIndent += Indent;
        }
    }
}
#endif // MUPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\debug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module defines debug functions and manifests.

Author:

    Manny Weiser (mannyw)    20-Dec-1991

Revision History:

--*/

#ifndef _MUPDEBUG_
#define _MUPDEBUG_

//
// MUP debug level
//

#ifdef MUPDBG

#define DEBUG_TRACE_FILOBSUP                0x00000001
#define DEBUG_TRACE_CREATE                  0x00000002
#define DEBUG_TRACE_FSCONTROL               0x00000004
#define DEBUG_TRACE_REFCOUNT                0x00000008
#define DEBUG_TRACE_CLOSE                   0x00000010
#define DEBUG_TRACE_CLEANUP                 0x00000020
#define DEBUG_TRACE_FORWARD                 0x00000040
#define DEBUG_TRACE_BLOCK                   0x00000080

extern LONG MsDebugTraceLevel;
extern LONG MsDebugTraceIndent;

VOID
_DebugTrace(
    LONG Indent,
    ULONG Level,
    PSZ X,
    ULONG Y
    );

#define DebugDump(STR,LEVEL,PTR) {                          \
    ULONG _i;                                               \
    VOID MupDump();                                         \
    if (((LEVEL) == 0) || (MupDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                   \
        DbgPrint("%08lx:",_i);                              \
        DbgPrint(STR);                                      \
        if (PTR != NULL) {MupDump(PTR);}                    \
        DbgBreakPoint();                                    \
    }                                                       \
}

#define DebugTrace(i,l,x,y)              _DebugTrace(i,l,x,(ULONG)y)

//
//  The following routine and macro is used to catch exceptions in
//  try except statements.  It allows us to catch the exception before
//  executing the exception handler.  The exception catcher procedure is
//  declared in msdata.c
//

LONG MupExceptionCatcher (IN PSZ String);

#define Exception(STR)                   (MupExceptionCatcher(STR))

#else  // MUPDBG

#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#define Exception(STR)                   (EXCEPTION_EXECUTE_HANDLER)

#define DebugTrace(I,L,X,Y)              {NOTHING;}

#endif // MUPDBG

#endif // _MUPDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfserr.h ===
//-------------------------------------------------------------------------
//
// File:        dfserr.h
//
// Contents:    This file has all the DFS driver error codes defined.
//              This includes only NTSTATUS codes returned from the
//              DFS driver.  For user-level HRESULTs, see oleerror.mc.
//
// History:     04-Feb-93       SudK    Created.
//              23 Sep 93       Alanw   Cleaned up, changed naming
//                                      convention to be DFS_STATUS_xxx
//
//  NOTES:      These error codes probably need to be differentiated from
//              the generic mappings used. Keep in mind for next generation DFS
//
//-------------------------------------------------------------------------

#ifndef _DFSERR_H_
#define _DFSERR_H_

//
//  The following are errror status codes which can be returned by the
//  DFS driver.
//

#define DFS_STATUS_NOSUCH_LOCAL_VOLUME          STATUS_OBJECT_NAME_NOT_FOUND
#define DFS_STATUS_BAD_EXIT_POINT               STATUS_OBJECT_NAME_INVALID
#define DFS_STATUS_STORAGEID_ALREADY_INUSE      STATUS_OBJECT_NAME_COLLISION
#define DFS_STATUS_BAD_STORAGEID                STATUS_OBJECT_PATH_INVALID

//
//  Defines for PKT specific errors
//

#define DFS_STATUS_ENTRY_EXISTS             STATUS_OBJECT_NAME_COLLISION
#define DFS_STATUS_NO_SUCH_ENTRY            STATUS_OBJECT_NAME_NOT_FOUND
#define DFS_STATUS_NO_DOMAIN_SERVICE        STATUS_CANT_ACCESS_DOMAIN_INFO
#define DFS_STATUS_LOCAL_ENTRY              STATUS_CANNOT_DELETE
#define DFS_STATUS_INCONSISTENT             STATUS_INTERNAL_DB_CORRUPTION
#define DFS_STATUS_RESYNC_INFO              STATUS_MEDIA_CHECK

#endif  // _DFSERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsdata.c ===
//+----------------------------------------------------------------------------
//
//  File:       dfsdata.c
//
//  Contents:
//      This module declares the global data used by the Dfs file system.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"

//
//  The debug trace level
//

#define Dbg             (DEBUG_TRACE_CATCH_EXCEPTIONS)


//  DfsBugCheck
//  DfsExceptionFilter
//  DfsProcessException

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsBugCheck )
#pragma alloc_text ( PAGE, DfsExceptionFilter )
#pragma alloc_text ( PAGE, DfsProcessException )

//
//  The following rountine cannot be paged because it raises the IRQL to
//  complete IRPs.
//
//
//  DfsCompleteRequest_Real
//

#endif // ALLOC_PRAGMA

//
//  The global FSD data record
//

DFS_DATA DfsData;

//
// The global event logging level
//

ULONG DfsEventLog = 0;

//
// The global Dfs debug level
//

ULONG MupVerbose = 0;


DFS_TIMER_CONTEXT       DfsTimerContext;

//
//  Some often used strings
//

WCHAR   LogicalRootDevPath[ MAX_LOGICAL_ROOT_LEN ] = { DD_DFS_DEVICE_DIRECTORY };

#if DBG

//+---------------------------------------------------------------------------
// Function:    DfsDebugTracePrint, public
//
// Synopsis:    Produce a DFS debug trace printout
//
// Arguments:   [x] -- DbgPrint format string
//              [y] -- optional argument to DbgPrint
//
// Returns:     None
//
//----------------------------------------------------------------------------

LONG DfsDebugTraceLevel = 0x00000001;
LONG DfsDebugTraceIndent = 0;

VOID
DfsDebugTracePrint(PCHAR x, PVOID y)
{
        int i;

        DbgPrint("%p:",PsGetCurrentThread());
        if (DfsDebugTraceIndent < 0)
            DfsDebugTraceIndent = 0;
        for (i = 0; i+5 < DfsDebugTraceIndent; i += 5) {
            DbgPrint("      ");
        }
        for ( ; i < DfsDebugTraceIndent; i += 1) {
            DbgPrint(" ");
        }
        DbgPrint(x,y);
}

#endif // DBG



//+---------------------------------------------------------------------------
// Function:    DfsBugCheck, public
//
// Synopsis:    Call KeBugCheck with DFS' constant
//
// Arguments:   [pszmsg]  -- message            (DBG=1 only)
//              [pszfile] -- filename           (DBG=1 only)
//              [line]    -- line number        (DBG=1 only)
//
// Returns:     None
//
//----------------------------------------------------------------------------

#if DBG
VOID DfsBugCheck(CHAR *pszmsg, CHAR *pszfile, ULONG line)
{
    PVOID CallersAddress, CallersCaller;

    RtlGetCallersAddress(&CallersAddress, &CallersCaller);

    DbgPrint("\nDFS: BugCheck in %s, line %u (%s)\n", pszfile, line, pszmsg);
    KeBugCheckEx(DFS_FILE_SYSTEM, (ULONG_PTR)CallersAddress, (ULONG_PTR)pszmsg,
                                  (ULONG_PTR)pszfile, line);
}
#else   // DBG
VOID DfsBugCheck(VOID)
{
    PVOID CallersAddress, CallersCaller;

    RtlGetCallersAddress(&CallersAddress, &CallersCaller);
    KeBugCheckEx(DFS_FILE_SYSTEM, (ULONG_PTR)CallersAddress, (ULONG_PTR)CallersCaller,
                                0, 0);
}
#endif  // DBG

//+----------------------------------------------------------------------------
//
//  Function:   FillDebugException
//
//  Synopsis:   Captures the exception record into variables that we can
//              look at.
//
//  Arguments:  [pep] -- Pointer to exception record.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define CEXCEPTION_STACK        8

PEXCEPTION_RECORD   DfsExceptionRecord;
PCONTEXT            DfsExceptionContext;
ULONG               DfsExceptionStack[CEXCEPTION_STACK];

VOID
FillDebugException(
    PEXCEPTION_POINTERS pep)
{
    if(pep != NULL) {

        DfsExceptionRecord = pep->ExceptionRecord;

        DfsExceptionContext = pep->ContextRecord;

    }

}


//+-------------------------------------------------------------------
//
//  Function:   DfsExceptionFilter
//
//  Synopsis:   Decide if we should or should not handle an exception status
//              that is being raised.  Insert the status into the IrpContext
//              and either indicate that we should handle the exception or
//              BugCheck the system.
//
//  Arguments:  [IrpContext] -- IRP context for the request being processed.
//              [ExceptionCode] -- Supplies the exception code to being checked.
//
//  Returns:    ULONG - returns EXCEPTION_EXECUTE_HANDLER or BugChecks
//
//--------------------------------------------------------------------

LONG
DfsExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN NTSTATUS ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionPointers OPTIONAL
) {
    DfsDbgTrace(
        0, DEBUG_TRACE_UNWIND, "DfsExceptionFilter %lx\n", ULongToPtr(ExceptionCode) );

    FillDebugException( ExceptionPointers );

    ASSERT(ExceptionCode != STATUS_ACCESS_VIOLATION);

    ASSERTMSG(
        "DfsExceptionFilter entered\n",
        !(DfsDebugTraceLevel & DEBUG_TRACE_UNWIND));

    //
    //  If there is not an irp context, we must have had insufficient resources.
    //

    if (!ARGUMENT_PRESENT( IrpContext )) {

        ASSERT( ExceptionCode == STATUS_INSUFFICIENT_RESOURCES );
        return EXCEPTION_EXECUTE_HANDLER;
    }

    IrpContext->Flags |= IRP_CONTEXT_FLAG_WAIT;

    if (IrpContext->ExceptionStatus == 0) {

        if (FsRtlIsNtstatusExpected( ExceptionCode )) {
            IrpContext->ExceptionStatus = ExceptionCode;

        } else {
            BugCheck( "DfsExceptionFilter: Unexpected exception" );

        }
    } else {

        //
        //  We raised this code explicitly ourselves, so it had better be
        //  expected.
        //

        ASSERT( FsRtlIsNtstatusExpected( ExceptionCode ) );
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

//+-------------------------------------------------------------------
//
//  Function:   DfsProcessException, public
//
//  Synopsis:   This routine processes an exception.  It either completes
//              the request with the saved exception status or it sends
//              the request off to the Fsp.
//
//  Arguments:  [Irp] -- Supplies the IRP being processed
//              [ExceptionCode] -- normalized exception status being handled
//
//  Returns:    NTSTATUS - Returns the results of either posting the Irp or the
//              saved completion status.
//
//--------------------------------------------------------------------

NTSTATUS
DfsProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )
{
    NTSTATUS Status;

    DfsDbgTrace(0, Dbg, "DfsProcessException\n", 0);

    //
    //  If there is not an irp context, we must have had insufficient resources.
    //

    if (!ARGUMENT_PRESENT( IrpContext )) {

        ASSERT( ExceptionCode == STATUS_INSUFFICIENT_RESOURCES );

        DfsCompleteRequest( IrpContext, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Check if the status is verify required and if so then we
    //  either send the request off to the fsp or we complete
    //  the request with verify required.
    //

    if (ExceptionCode == STATUS_CANT_WAIT) {

        Status = DfsFsdPostRequest( IrpContext, Irp );

    } else {

        //
        //  We got an error, so zero out the information field before
        //  completing the request if this was an input operation.
        //  Otherwise IopCompleteRequest will try to copy to the user's buffer.
        //

        if ((Irp->Flags & IRP_INPUT_OPERATION) != 0) {

            Irp->IoStatus.Information = 0;
        }

        Status = IrpContext->ExceptionStatus;

        DfsCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCompleteRequest, public
//
//  Synopsis:   This routine completes a Irp
//
//  Arguments:  [IrpContext] - context record to be freed
//              [Irp] - Supplies the Irp being processed
//              [Status] - Supplies the status to complete the Irp with
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID
DfsCompleteRequest_Real (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
) {
    KIRQL PreviousIrql;

    //
    //  If we have an Irp then complete the irp.
    //

    if (Irp != NULL) {

        Irp->IoStatus.Status = Status;
        // KeRaiseIrql( DISPATCH_LEVEL, &PreviousIrql );
        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
        // KeLowerIrql( PreviousIrql );
    }

    //
    //  Delete the Irp context.
    //

    if (IrpContext != NULL) {

        DfsDeleteIrpContext( IrpContext );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfscreat.c ===
//+----------------------------------------------------------------------------
//
//  File:       create.c
//
//  Contents:
//
//      This module implements the File Create routine for Dfs called by the
//      dispatch driver.  Unlike traditional disk-based FSDs, there is only
//      one entry point, DfsFsdCreate.  The request is assumed to be
//      synchronous (whether the user thread requests it or not).
//      Of course, since we will typically be calling out to some other
//      FSD, that FSD may post the request and return to us with a
//      STATUS_PENDING.
//
//  Functions:  DfsFsdCreate - FSD entry point for NtCreateFile/NtOpenFile
//              DfsCommonCreate, local
//              DfsPassThroughRelativeOpen, local
//              DfsCompleteRelativeOpen, local
//              DfsPostProcessRelativeOpen, local
//              DfsRestartRelativeOpen, local
//              DfsComposeFullName, local
//              DfsAreFilesOnSameLocalVolume, local
//
//  History:    27 Jan 1992     AlanW   Created.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "dnr.h"
#include "fcbsup.h"
#include "mupwml.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonCreate (
    OPTIONAL IN PIRP_CONTEXT IrpContext,
    PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

IO_STATUS_BLOCK
DfsOpenDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateOptions);

NTSTATUS
DfsPassThroughRelativeOpen(
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB ParentFcb);

NTSTATUS
DfsCompleteRelativeOpen(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context);

NTSTATUS
DfsPostProcessRelativeOpen(
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB ParentFcb);

VOID
DfsRestartRelativeOpen(
    IN PIRP_CONTEXT IrpContext);

NTSTATUS
DfsComposeFullName(
    IN PUNICODE_STRING ParentName,
    IN PUNICODE_STRING RelativeName,
    OUT PUNICODE_STRING FullName);

NTSTATUS
DfsAreFilesOnSameLocalVolume(
    IN PUNICODE_STRING ParentName,
    IN PUNICODE_STRING FileName);


#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFsdCreate )
#pragma alloc_text( PAGE, DfsCommonCreate )
#pragma alloc_text( PAGE, DfsOpenDevice )
#pragma alloc_text( PAGE, DfsPassThroughRelativeOpen )
#pragma alloc_text( PAGE, DfsPostProcessRelativeOpen )
#pragma alloc_text( PAGE, DfsRestartRelativeOpen )
#pragma alloc_text( PAGE, DfsComposeFullName )
#pragma alloc_text( PAGE, DfsAreFilesOnSameLocalVolume )

//
// The following are not pageable since they can be called at DPC level
//
// DfsCompleteRelativeOpen
//

#endif // ALLOC_PRAGMA



//+-------------------------------------------------------------------
//
//  Function:   DfsFsdCreate, public
//
//  Synopsis:   This routine implements the FSD part of the NtCreateFile
//              and NtOpenFile API calls.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where
//                      the file/directory exists that we are trying
//                      to open/create exists
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The Fsd status for the Irp
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PDFS_FCB pFcb = NULL;

    DfsDbgTrace(+1, Dbg, "DfsFsdCreate: Entered\n", 0);

    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdCreate_Entry, 
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGUSTR(FileObject->FileName)
                   LOGPTR(Irp));

    ASSERT(IoIsOperationSynchronous(Irp) == TRUE);

    //
    //  Call the common create routine, with block allowed if the operation
    //  is synchronous.
    //

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonCreate( IrpContext, DeviceObject, Irp );

    } except( DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );

    }

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdCreate: Exit -> %08lx\n", ULongToPtr(Status) );
    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdCreate_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    return Status;
}


//+-------------------------------------------------------------------
//  Function:   DfsCommonCreate, private
//
//  Synopsis:   This is the common routine for creating/opening a file
//              called by both the FSD and FSP threads.
//
//  Arguments:  [DeviceObject] - The device object associated with
//                      the request.
//              [Irp] -- Supplies the Irp to process
//
//  Returns:    NTSTATUS - the return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsCommonCreate (
    OPTIONAL IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    IO_STATUS_BLOCK Iosb;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDFS_VCB Vcb = NULL;
    PDFS_FCB Fcb = NULL;

    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFILE_OBJECT RelatedFileObject;
    UNICODE_STRING FileName;
    ACCESS_MASK DesiredAccess;
    ULONG CreateOptions;
    USHORT ShareAccess;
    NTSTATUS Status;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    DfsDbgTrace(+1, Dbg, "DfsCommonCreate\n", 0 );
    DfsDbgTrace( 0, Dbg, "Irp                   = %08lx\n", Irp );
    DfsDbgTrace( 0, Dbg, "->Flags               = %08lx\n", ULongToPtr(Irp->Flags) );
    DfsDbgTrace( 0, Dbg, "->FileObject          = %08lx\n", FileObject );
    DfsDbgTrace( 0, Dbg, "  ->RelatedFileObject = %08lx\n", FileObject->RelatedFileObject );
    DfsDbgTrace( 0, Dbg, "  ->FileName          = %wZ\n",    &FileObject->FileName );
    DfsDbgTrace( 0, Dbg, "->DesiredAccess       = %08lx\n", ULongToPtr(IrpSp->Parameters.Create.SecurityContext->DesiredAccess) );
    DfsDbgTrace( 0, Dbg, "->CreateOptions       = %08lx\n", ULongToPtr(IrpSp->Parameters.Create.Options) );
    DfsDbgTrace( 0, Dbg, "->FileAttributes      = %04x\n",  IrpSp->Parameters.Create.FileAttributes );
    DfsDbgTrace( 0, Dbg, "->ShareAccess         = %04x\n",  IrpSp->Parameters.Create.ShareAccess );
    DfsDbgTrace( 0, Dbg, "->EaLength            = %08lx\n", ULongToPtr(IrpSp->Parameters.Create.EaLength) );


    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] DfsCommonCreate(%wZ)\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        &FileObject->FileName);
    }
#endif

    //
    //  Reference our input parameters to make things easier
    //

    RelatedFileObject = IrpSp->FileObject->RelatedFileObject;
    FileName          = *((PUNICODE_STRING) &IrpSp->FileObject->FileName);
    DesiredAccess     = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    CreateOptions     = IrpSp->Parameters.Create.Options;
    ShareAccess       = IrpSp->Parameters.Create.ShareAccess;

    Iosb.Status = STATUS_SUCCESS;

    //
    //  Short circuit known invalid opens.
    //

    if ((IrpSp->Flags & SL_OPEN_PAGING_FILE) != 0) {

        DfsDbgTrace(0, Dbg,
            "DfsCommonCreate: Paging file not allowed on Dfs\n", 0);

        Iosb.Status = STATUS_INVALID_PARAMETER;

        MUP_TRACE_HIGH(ERROR, DfsCommonCreate_Error_PagingFileNotAllowed,
                       LOGSTATUS(Iosb.Status)
                       LOGPTR(DeviceObject)
                       LOGPTR(FileObject)
                       LOGPTR(Irp));

        DfsCompleteRequest( IrpContext, Irp, Iosb.Status );

        DfsDbgTrace(-1, Dbg, "DfsCommonCreate: Exit -> %08lx\n", ULongToPtr(Iosb.Status));

        return Iosb.Status;

    }

    //
    //  There are several cases we need to handle here.
    //
    //  1. FileName is 0 length
    //
    //     If the filename length is 0, then someone really wants to open the
    //     device object itself.
    //
    //  2. This is a Relative open and the parent is on the same volume,
    //     either local or remote.
    //
    //     We pass through the relative open to the driver that opened the
    //     parent.
    //
    //  3. This is a relative open and the parent is on a different volume.
    //
    //     Form the full name of the file by concatenating the parent's
    //     name with the relative file name. Stick this name in the FileObject
    //     and do DNR on the full name.
    //
    //  4. This is a relative open and the parent is a device object (ie,
    //     the parent was opened via case 1)
    //
    //     Assume the parent name is \, so concatenate \ with the relative
    //     file name. Stick this name in the FileObject and do DNR on the
    //     the full name.
    //
    //  5. This is an absolute open, (or a case 3/4 converted to an absolute
    //     open), and the SL_OPEN_TARGET_DIRECTORY bis *is* set.
    //
    //     a. If the file's immediate parent directory is on the same local
    //        volume as the file, then do a regular DNR, and let the
    //        underlying FS handle the SL_OPEN_TARGET_DIRECTORY.
    //
    //     b. If the file's immediate parent directory is on a local volume
    //        and the file is not on the same local volume, then immediately
    //        return STATUS_NOT_SAME_DEVICE.
    //
    //     c. If the file's immediate parent directory is on a remote volume,
    //        then do a full DNR. This will pass through the
    //        SL_OPEN_TARGET_DIRECTORY to the remote Dfs driver, which will
    //        handle it as case 5a. or 5b.
    //
    //  6. This is an absolute open, (or a case 3/4 converted to an absolute
    //     open), and the SL_OPEN_TARGET_DIRECTORY bit is *not* set.
    //
    //     Do a DNR on the FileObject's name.
    //

    try {

        //
        //  Check to see if we are opening a device object.  If so, and the
        //  file is being opened on the File system device object, it will
        //  only permit FsCtl and Close operations to be performed.
        //

        if (
            (FileName.Length == 0 && RelatedFileObject == NULL)
                ||
            (DeviceObject != NULL &&
             DeviceObject->DeviceType != FILE_DEVICE_DFS &&
             RelatedFileObject == NULL)
            ) {

            //
            // This is case 1.
            //
            // In this case there had better be a DeviceObject
            //

            ASSERT(ARGUMENT_PRESENT(DeviceObject));

            DfsDbgTrace(0, Dbg,
                "DfsCommonCreate: Opening the device, DevObj = %08lx\n",
                DeviceObject);

            Iosb = DfsOpenDevice( IrpContext,
                                  FileObject,
                                  DeviceObject,
                                  DesiredAccess,
                                  ShareAccess,
                                  CreateOptions);

            Irp->IoStatus.Information = Iosb.Information;

            DfsCompleteRequest( IrpContext, Irp, Iosb.Status );

            try_return( Iosb.Status );

        }

        if (DeviceObject != NULL && DeviceObject->DeviceType == FILE_DEVICE_DFS) {
            Vcb = &(((PLOGICAL_ROOT_DEVICE_OBJECT)DeviceObject)->Vcb);
        }

        //
        //  If there is a related file object, then this is a relative open.
        //

        if (RelatedFileObject != NULL) {

            //
            // This is case 2, 3, or 4.
            //

            PDFS_VCB TempVcb;
            TYPE_OF_OPEN OpenType;
            UNICODE_STRING NewFileName;

            OpenType = DfsDecodeFileObject( RelatedFileObject,
                                            &TempVcb,
                                            &Fcb);

            if (OpenType == RedirectedFileOpen) {

                DfsDbgTrace(0, Dbg, "Relative file open: DFS_FCB = %08x\n", Fcb);
                DfsDbgTrace(0, Dbg, "  Directory: %wZ\n", &Fcb->FullFileName);
                DfsDbgTrace(0, Dbg, "  Relative file:  %wZ\n", &FileName);

                //
                // This is case 2.
                //

                DfsDbgTrace(0, Dbg,
                    "Trying pass through of relative open\n", 0);

                Iosb.Status = DfsPassThroughRelativeOpen(
                                    Irp,
                                    IrpContext,
                                    Fcb
                                    );

                try_return( Iosb.Status );


            } else if (OpenType == LogicalRootDeviceOpen) {

                //
                // This is case 4.
                //
                // If the open is relative to a logical root open, then we
                // are forced to convert it to an absolute open, since there
                // is no underlying FS backing up the logical root to pass
                // the relative open to first.
                //

                DfsDbgTrace( 0, Dbg, "DfsCommonCreate: Open relative to Logical Root\n", 0);

                ASSERT (TempVcb == Vcb);

                NewFileName.MaximumLength = sizeof (WCHAR) +
                                                FileName.Length;

                NewFileName.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                NewFileName.MaximumLength,
                                                ' puM');

                if (NewFileName.Buffer == NULL) {

                    Iosb.Status = STATUS_INSUFFICIENT_RESOURCES;

                    DfsCompleteRequest( IrpContext, Irp, Iosb.Status );

                    try_return( Iosb.Status );

                }

                NewFileName.Buffer[0] = L'\\';

                NewFileName.Length = sizeof (WCHAR);

            } else {

                Iosb.Status = STATUS_INVALID_HANDLE;

                DfsCompleteRequest( IrpContext, Irp, Iosb.Status );

                DfsDbgTrace(0, Dbg, "DfsCommonCreate: Invalid related file object\n", 0);

                try_return( Iosb.Status );

            }

            (void) DnrConcatenateFilePath (
                        &NewFileName,
                        FileName.Buffer,
                        FileName.Length);

            if (IrpSp->FileObject->FileName.Buffer)
                ExFreePool( IrpSp->FileObject->FileName.Buffer );

            FileName = IrpSp->FileObject->FileName = NewFileName;

        }

        ASSERT(FileName.Length != 0);

        //
        // This is case 5b, 5c, or 6 - Do a full DNR.
        //

        if (Vcb == NULL) {

            DfsDbgTrace(0, Dbg, "DfsCommonCreate: Null Vcb!\n", 0);

            Iosb.Status = STATUS_INVALID_PARAMETER;
            MUP_TRACE_HIGH(ERROR, DfsCommonCreate_Error_NullVcb,
                           LOGSTATUS(Iosb.Status)
                           LOGPTR(DeviceObject)
                           LOGPTR(FileObject)
                           LOGPTR(Irp));
            DfsCompleteRequest(IrpContext, Irp, Iosb.Status);

            try_return(Iosb.Status);

        }

        Iosb.Status = DnrStartNameResolution(IrpContext, Irp, Vcb);

    try_exit: NOTHING;
    } finally {

        DfsDbgTrace(-1, Dbg, "DfsCommonCreate: Exit  ->  %08lx\n", ULongToPtr(Iosb.Status));
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("[%d] DfsCommonCreate exit 0x%x\n",
                            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                            Iosb.Status);
        }
#endif
    }

    return Iosb.Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsOpenDevice, local
//
//  Synopsis:   This routine opens the specified device for direct
//              access.
//
//  Arguments:  [FileObject] - Supplies the File object
//              [DeviceObject] - Supplies the object denoting the device
//                      being opened
//              [DesiredAccess] - Supplies the desired access of the caller
//              [ShareAccess] - Supplies the share access of the caller
//              [CreateOptions] - Supplies the create options for
//                      this operation
//
//  Returns:    [IO_STATUS_BLOCK] - Returns the completion status for
//                      the operation
//
//--------------------------------------------------------------------

IO_STATUS_BLOCK
DfsOpenDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateOptions
) {
    IO_STATUS_BLOCK Iosb;
    PDFS_VCB Vcb = NULL;

    //
    //  The following variables are for abnormal termination
    //
    BOOLEAN UnwindShareAccess = FALSE;
    BOOLEAN UnwindVolumeLock = FALSE;

    DfsDbgTrace( +1, Dbg, "DfsOpenDevice: Entered\n", 0 );

    try {

        //
        //  Check to see which type of device is being opened.
        //  We don't permit all open modes on the file system
        //  device object.
        //

        if (DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM ) {
            ULONG CreateDisposition = (CreateOptions >> 24) & 0x000000ff;

            //
            //  Check for proper desired access and rights
            //
            if (CreateDisposition != FILE_OPEN
                && CreateDisposition != FILE_OPEN_IF ) {

                Iosb.Status = STATUS_ACCESS_DENIED;
                MUP_TRACE_HIGH(ERROR, DfsOpenDevice_Error_BadDisposition,
                               LOGSTATUS(Iosb.Status)
                               LOGPTR(DeviceObject)
                               LOGPTR(FileObject));
                try_return( Iosb );
            }

            //
            //  Check if we were to open a directory
            //

            if (CreateOptions & FILE_DIRECTORY_FILE) {
                DfsDbgTrace(0, Dbg, "DfsOpenDevice: Cannot open device as a directory\n", 0);

                Iosb.Status = STATUS_NOT_A_DIRECTORY;
                MUP_TRACE_HIGH(ERROR, DfsOpenDevice_Error_CannotOpenAsDirectory,
                               LOGSTATUS(Iosb.Status)
                               LOGPTR(DeviceObject)
                               LOGPTR(FileObject));
                try_return( Iosb );
            }


            DfsSetFileObject( FileObject,
                             FilesystemDeviceOpen,
                             DeviceObject
                             );

            Iosb.Status = STATUS_SUCCESS;
            Iosb.Information = FILE_OPENED;
            try_return( Iosb );
        }

        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);
        Vcb = & (((PLOGICAL_ROOT_DEVICE_OBJECT)DeviceObject)->Vcb);


        //
        //  If the user does not want to share anything then we will try and
        //  take out a lock on the volume.  We check if the volume is already
        //  in use, and if it is then we deny the open
        //

        if ((ShareAccess & (
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)) == 0 ) {

            if (Vcb->OpenFileCount != 0) {

                ExReleaseResourceLite( &DfsData.Resource );
                Iosb.Status = STATUS_ACCESS_DENIED;
                MUP_TRACE_HIGH(ERROR, DfsOpenDevice_Error_FileInUse,
                               LOGSTATUS(Iosb.Status)
                               LOGPTR(DeviceObject)
                               LOGPTR(FileObject));

                try_return( Iosb );
            }

            //
            //  Lock the volume
            //

            Vcb->VcbState |= VCB_STATE_FLAG_LOCKED;
            Vcb->FileObjectWithVcbLocked = FileObject;
            UnwindVolumeLock = TRUE;
        }

        //
        //  If the volume is already opened by someone then we need to check
        //  the share access
        //

        if (Vcb->DirectAccessOpenCount > 0) {

            if ( !NT_SUCCESS( Iosb.Status
                                = IoCheckShareAccess( DesiredAccess,
                                                      ShareAccess,
                                                      FileObject,
                                                      &Vcb->ShareAccess,
                                                      TRUE ))) {
                ExReleaseResourceLite( &DfsData.Resource );

                MUP_TRACE_ERROR_HIGH(Iosb.Status, ALL_ERROR, DfsOpenDevice_Error_IoCheckShareAccess,
                                     LOGSTATUS(Iosb.Status)
                                     LOGPTR(DeviceObject)
                                     LOGPTR(FileObject));

                try_return( Iosb );
            }

        } else {

            IoSetShareAccess( DesiredAccess,
                              ShareAccess,
                              FileObject,
                              &Vcb->ShareAccess );
        }

        UnwindShareAccess = TRUE;


        //
        // Bug: 425017. Update the counters with lock held to avoid race between multiple processors.
        //


        InterlockedIncrement(&Vcb->DirectAccessOpenCount);
        InterlockedIncrement(&Vcb->OpenFileCount);

        ExReleaseResourceLite( &DfsData.Resource );
        //
        //  Setup the context pointers, and update
        //  our reference counts
        //

        DfsSetFileObject( FileObject,
                          LogicalRootDeviceOpen,
                          Vcb
                         );


        //
        //  And set our status to success
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination() && (Vcb != NULL)) {

            if (UnwindShareAccess) {
                IoRemoveShareAccess( FileObject, &Vcb->ShareAccess );
            }

            if (UnwindVolumeLock) {
                Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED;
                Vcb->FileObjectWithVcbLocked = NULL;
            }

        }

        DfsDbgTrace(-1, Dbg, "DfsOpenDevice: Exit -> Iosb.Status = %08lx\n", ULongToPtr(Iosb.Status));
    }

    return Iosb;
}


//+----------------------------------------------------------------------------
//
//  Function:  DfsPassThroughRelativeOpen
//
//  Synopsis:  Passes through a relative open call to the device handling
//             the parent. This is required for structured storages on OFS
//             to work, for replication's Do-not-cross-JP sematics to work,
//             and as an optimization.
//
//  Arguments: [Irp] -- The open Irp, which we will pass through.
//             [IrpContext] -- Associated with the above Irp.
//             [ParentFcb] -- Fcb of related file object.
//
//  Returns:   Status returned by the underlying FS, or by DNR if
//             the underlying FS complained about STATUS_DFS_EXIT_PATH_FOUND.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPassThroughRelativeOpen(
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB ParentFcb)
{

    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp, NextIrpSp;
    PFILE_OBJECT FileObject;
    PDFS_FCB NewFcb;
    UNICODE_STRING NewFileName;

    DfsDbgTrace(+1, Dbg, "DfsPassThroughRelativeOpen: Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // Prepare to pass the request to the device handling the parent open.
    //

    //
    // First, we preallocate an DFS_FCB, assuming that the relative open will
    // succeed. We need to do this at this point in time because the
    // FileObject->FileName is still intact; after we pass through, the
    // underlying can do as it wishes with the FileName field, and we will
    // be unable to construct the full file name for the DFS_FCB.
    //

    Status = DfsComposeFullName(
                &ParentFcb->FullFileName,
                &IrpSp->FileObject->FileName,
                &NewFileName);

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(-1, Dbg, "DfsPassThroughRelativeOpen: Unable to create full Name %08lx\n",
                                        ULongToPtr(Status) );
        DfsCompleteRequest( IrpContext, Irp, Status );
        return( Status );
    }


    NewFcb = DfsCreateFcb( NULL, ParentFcb->Vcb, &NewFileName );

    if (NewFcb == NULL) {

        if (NewFileName.Buffer != NULL)
            ExFreePool(NewFileName.Buffer);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DfsDbgTrace(-1, Dbg, "DfsPassThroughRelativeOpen: Exited %08lx\n", ULongToPtr(Status));

        DfsCompleteRequest( IrpContext, Irp, Status );
        return( Status );

    }

    // Changes for 426540. Do all the right logic for CSC. 
    // since DFS does not "failover" for relative names, allow CSC to go
    // offline if necessary to serve the name. This does mean that the DFS
    // namespace will be served by the CSC even when one of the DFS alternates
    // exists.

    NewFcb->DfsNameContext.Flags = DFS_FLAG_LAST_ALTERNATE;

    if (NewFcb->Vcb != NULL) {
        if (NewFcb->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) {
            NewFcb->DfsNameContext.NameContextType = DFS_CSCAGENT_NAME_CONTEXT;
         }
         else {
            NewFcb->DfsNameContext.NameContextType = DFS_USER_NAME_CONTEXT;
         }
    }

    NewFcb->TargetDevice = ParentFcb->TargetDevice;
    NewFcb->ProviderId = ParentFcb->ProviderId;
    NewFcb->DfsMachineEntry = ParentFcb->DfsMachineEntry;
    NewFcb->FileObject = IrpSp->FileObject;

    DfsSetFileObject(IrpSp->FileObject,
		     RedirectedFileOpen,
		     NewFcb
		     );

    IrpSp->FileObject->FsContext = &(NewFcb->DfsNameContext);
    if (ParentFcb->ProviderId == PROV_ID_DFS_RDR) {
        IrpSp->FileObject->FsContext2 = UIntToPtr(DFS_OPEN_CONTEXT);
    }

    if (NewFileName.Buffer != NULL)
        ExFreePool( NewFileName.Buffer );

    //
    // Next, setup the IRP stack location
    //

    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    (*NextIrpSp) = (*IrpSp);

    //
    // Put the parent DFS_FCB pointer in the IrpContext.
    //

    IrpContext->Context = (PVOID) NewFcb;

    IoSetCompletionRoutine(
        Irp,
        DfsCompleteRelativeOpen,
        IrpContext,
        TRUE,
        TRUE,
        TRUE);

    Status = IoCallDriver( ParentFcb->TargetDevice, Irp );
    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsPassThroughRelativeOpen_Error_IoCallDriver,
                         LOGSTATUS(Status)
                         LOGPTR(FileObject)
                         LOGPTR(Irp));

    DfsDbgTrace(0, Dbg, "IoCallDriver returned %08lx\n", ULongToPtr(Status));

    if (Status != STATUS_PENDING) {

        Status =  DfsPostProcessRelativeOpen(
                        Irp,
                        IrpContext,
                        NewFcb);

    }

    DfsDbgTrace(-1, Dbg, "DfsPassThroughRelativeOpen: Exited %08lx\n", ULongToPtr(Status));

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  Function:  DfsCompleteRelativeOpen
//
//  Synopsis:  Completion routine for DfsPassThroughRelativeOpen. It is
//             interesting only in case where STATUS_PENDING was originally
//             returned from IoCallDriver. If so, then this routine simply
//             queues DfsRestartRelativeOpen to a work queue. Note that it
//             must queue an item at this stage instead of doing the work
//             itself because this routine is executed at DPC level.
//
//  Arguments: [pDevice] -- Our device object.
//             [Irp] -- The Irp being completed.
//             [IrpContext] -- Context associated with Irp.
//
//  Returns:    STATUS_MORE_PROCESSING_REQUIRED. Either the posted routine
//              or DfsPassThroughRelativeOpen must complete the IRP for real.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsCompleteRelativeOpen(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext)
{

    DfsDbgTrace( +1, Dbg, "DfsCompleteRelativeOpen: Entered\n", 0);

    //
    // We are only interested in the case when the pass through of relative
    // opens returned STATUS_PENDING. In that case, the original thread has
    // popped all the way back to the caller of NtCreateFile, and we need
    // to finish the open in an asynchronous manner.
    //

    if (Irp->PendingReturned) {

        DfsDbgTrace(0, Dbg, "Pending returned : Queuing DfsRestartRelativeOpen\n", 0);

        //
        // We need to call IpMarkIrpPending so the IoSubsystem will realize
        // that our FSD routine returned STATUS_PENDING. We can't call this
        // from the FSD routine itself because the FSD routine doesn't have
        // access to the stack location when the underlying guy returns
        // STATUS_PENDING
        //

        IoMarkIrpPending( Irp );

        ExInitializeWorkItem( &(IrpContext->WorkQueueItem),
                              DfsRestartRelativeOpen,
                              (PVOID) IrpContext );

        ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    }

    //
    // We MUST return STATUS_MORE_PROCESSING_REQUIRED to halt the completion
    // of the Irp. Either DfsRestartRelativeOpen that we queued above or
    // DfsPassThroughRelativeOpen will complete the IRP after it is done.
    //

    DfsDbgTrace(-1, Dbg, "DfsCompleteRelativeOpen: Exited\n", 0);

    return( STATUS_MORE_PROCESSING_REQUIRED );

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsPostProcessRelativeOpen
//
//  Synopsis:  Continues a relative open after it has already been passed
//             to the device of the parent. One of three things could have
//             happened -
//
//              a) The device of the parent successfully handled the open.
//                 We create an fcb and return.
//              b) The device of the parent could not do the open for some
//                 reason other than STATUS_DFS_EXIT_PATH_FOUND. We return
//                 the error to the caller.
//              c) The device of the parent returned STATUS_DFS_EXIT_PATH
//                 found. In that case, we convert the relative open to an
//                 absolute open and do a full Dnr.
//
//  Arguments:  [Irp] -- Pointer to Irp
//              [IrpContext] -- Pointer to IrpContext associated with Irp
//              [Fcb] -- Preallocated Fcb of this file.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPostProcessRelativeOpen(
    IN PIRP Irp,
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB Fcb)
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    UNICODE_STRING NewFileName;
    BOOLEAN fCompleteRequest = TRUE;

    DfsDbgTrace(+1, Dbg, "DfsPostProcessRelativeOpen: Entered\n", 0);

    ASSERT( ARGUMENT_PRESENT( Irp ) );
    ASSERT( ARGUMENT_PRESENT( IrpContext ) );
    ASSERT( ARGUMENT_PRESENT( Fcb ) );

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    ASSERT( Fcb->Vcb != NULL );
    ASSERT( NodeType(Fcb->Vcb) == DSFS_NTC_VCB );


    Status = Irp->IoStatus.Status;

    if (Status == STATUS_SUCCESS) {

        //
        // Just set the DFS_FCB for the FileObject.
        //

        DfsDbgTrace( 0, Dbg, "Relative Open pass through succeeded\n", 0 );

        DfsDbgTrace(0, Dbg, "Fcb = %08lx\n", Fcb);

        InterlockedIncrement(&Fcb->DfsMachineEntry->UseCount);

        //
        // Now that a File Open has succeeded, we need to bump up OpenCnt
        // on the DFS_VCB.
        //

        InterlockedIncrement(&Fcb->Vcb->OpenFileCount);

    } else if ( Status == STATUS_DFS_EXIT_PATH_FOUND ||
                    Status == STATUS_PATH_NOT_COVERED ) {

        PDFS_VCB Vcb;

        //
        // Exit path was found. We'll have to convert this relative open to
        // an absolute open, and do a normal dnr on it.
        //

        DfsDbgTrace(0, Dbg, "Exit point found! Trying absolute open\n", 0);

        Vcb = Fcb->Vcb;

        NewFileName.Buffer = ExAllocatePoolWithTag(
                                NonPagedPool,
                                Fcb->FullFileName.MaximumLength,
                                ' puM');

        if (NewFileName.Buffer != NULL) {

            NewFileName.Length = Fcb->FullFileName.Length;
            NewFileName.MaximumLength = Fcb->FullFileName.MaximumLength;

            RtlMoveMemory(
                (PVOID) NewFileName.Buffer,
                (PVOID) Fcb->FullFileName.Buffer,
                Fcb->FullFileName.Length );

	    DfsDetachFcb( FileObject, Fcb );

            DfsDeleteFcb( IrpContext, Fcb );

            if (FileObject->FileName.Buffer) {

                ExFreePool( FileObject->FileName.Buffer );

            }

            FileObject->FileName = NewFileName;

            // OFS apparently sets the FileObject->Vpb even though it failed
            //         the open. Reset it to NULL.
            //

            if (FileObject->Vpb != NULL) {
                FileObject->Vpb = NULL;
            }

            DfsDbgTrace(0, Dbg, "Absolute path == %wZ\n", &NewFileName);

            fCompleteRequest = FALSE;

            ASSERT( Vcb != NULL );

            Status = DnrStartNameResolution( IrpContext, Irp, Vcb );

        } else {

	    DfsDetachFcb( FileObject, Fcb );

            DfsDeleteFcb( IrpContext, Fcb );

            Status = STATUS_INSUFFICIENT_RESOURCES;

            DfsDbgTrace(0, Dbg, "Unable to allocate full name!\n", 0);

        }

    } else {

        DfsDetachFcb( FileObject, Fcb );
        DfsDeleteFcb( IrpContext, Fcb );

    }

    if (fCompleteRequest) {

        DfsCompleteRequest( IrpContext, Irp, Status );

    }

    DfsDbgTrace(-1, Dbg, "DfsPostProcessRelativeOpen: Exited %08lx\n", ULongToPtr(Status));

    return(Status);

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsRestartRelativeOpen
//
//  Synopsis:  This function is intended to be queued to complete processing
//             of a relative open IRP that was passed through and originally
//             came back with STATUS_PENDING.
//
//  Arguments: [IrpContext]
//
//  Returns:   Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsRestartRelativeOpen(
    IN PIRP_CONTEXT IrpContext)
{
    NTSTATUS Status;

    DfsDbgTrace(+1, Dbg, "DfsRestartRelativeOpen: Entered IrpContext == %08lx\n", IrpContext);

    Status = DfsPostProcessRelativeOpen(
                IrpContext->OriginatingIrp,
                IrpContext,
                (PDFS_FCB) IrpContext->Context);

    DfsDbgTrace(-1, Dbg, "DfsRestartRelativeOpen: Exited\n", 0);

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsComposeFullName
//
//  Synopsis:  Given a fully qualified name and a relative name, this
//             function allocates room for the concatenation of the two, and
//             fills up the buffer with the concatenated name.
//
//  Arguments: [ParentName] -- Pointer to fully qualified parent name.
//             [RelativeName] -- Pointer to name relative to parent.
//             [FullName] -- Pointer to UNICODE_STRING structure that will
//                           get filled up with the full name.
//
//  Returns:   STATUS_INSUFFICIENT_RESOURCES if memory allocation fails.
//             STAUS_SUCCESS otherwise.
//
//  Notes:     This routine uses an appropriate allocator so that the
//             returned FullName can be put into a FILE_OBJECT.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsComposeFullName(
    IN PUNICODE_STRING ParentName,
    IN PUNICODE_STRING RelativeName,
    OUT PUNICODE_STRING FullName)
{
    ULONG nameLen;
    NTSTATUS status;

    nameLen = ParentName->Length +
                    sizeof (WCHAR) +           // For backslash
                    RelativeName->Length;

    if (nameLen > MAXUSHORT) {
        status = STATUS_NAME_TOO_LONG;
        MUP_TRACE_HIGH(ERROR, DfsComposeFullName_Error1,
                       LOGUSTR(*ParentName)
                       LOGSTATUS(status));
        return status;
    }

    FullName->Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        nameLen,
                                        ' puM');

    if (FullName->Buffer == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    FullName->Length = ParentName->Length;
    FullName->MaximumLength = (USHORT)nameLen;
    RtlMoveMemory (FullName->Buffer, ParentName->Buffer, ParentName->Length);

    if (RelativeName->Length > 0) {
        (void) DnrConcatenateFilePath(
                        FullName,
                        RelativeName->Buffer,
                        RelativeName->Length);
    }

    return( STATUS_SUCCESS );
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsAreFilesOnSameLocalVolume
//
//  Synopsis:   Given a file name and a name relative to it, this routine
//              will determine if both files live on the same local volume.
//
//  Arguments:  [ParentName] -- The name of the parent file.
//              [FileName] -- Name relative to parent of the other file.
//
//  Returns:    [STATUS_SUCCESS] -- The two files should indeed be on the
//                      same local volume.
//
//              [STATUS_NOT_SAME_DEVICE] -- The two files are not on the
//                      same local volume.
//
//              [STATUS_OBJECT_TYPE_MISMATCH] -- ustrParentName is not on
//                      a local volume.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsAreFilesOnSameLocalVolume(
    IN PUNICODE_STRING ParentName,
    IN PUNICODE_STRING FileName)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntryParent;
    PDFS_PKT_ENTRY pktEntryFile;
    UNICODE_STRING remPath;
    BOOLEAN pktLocked;

    DfsDbgTrace(+1, Dbg, "DfsAreFilesOnSameLocalVolume entered\n", 0);

    DfsDbgTrace(0, Dbg, "Parent = [%wZ]\n", ParentName);
    DfsDbgTrace(0, Dbg, "File = [%wZ]\n", FileName);

    pkt = _GetPkt();

    PktAcquireShared( TRUE, &pktLocked );

    //
    // First, see if the parent is on a local volume at all.
    //

    pktEntryParent = PktLookupEntryByPrefix( pkt, ParentName, &remPath );

    DfsDbgTrace(0, Dbg, "Parent Entry @%08lx\n", pktEntryParent);

    if (pktEntryParent == NULL ||
            !(pktEntryParent->Type & PKT_ENTRY_TYPE_LOCAL)) {

        status = STATUS_OBJECT_TYPE_MISMATCH;

    }

    if (NT_SUCCESS(status)) {

        USHORT parentLen;

        //
        // Parent is local, verify that the relative file does not cross a
        // junction point. We'll iterate through the list of exit points on
        // the parent's local volume pkt entry, comparing the remaing path
        // of the exit point with the FileName argument
        //

        ASSERT(pktEntryParent != NULL);

        parentLen = pktEntryParent->Id.Prefix.Length +
                        sizeof(UNICODE_PATH_SEP);

        for (pktEntryFile = PktEntryFirstSubordinate(pktEntryParent);
                pktEntryFile != NULL && NT_SUCCESS(status);
                    pktEntryFile = PktEntryNextSubordinate(
                        pktEntryParent, pktEntryFile)) {

            remPath = pktEntryFile->Id.Prefix;
            remPath.Length -= parentLen;
            remPath.Buffer += (parentLen/sizeof(WCHAR));

            if (DfsRtlPrefixPath( &remPath, FileName, FALSE)) {

                DfsDbgTrace(0, Dbg,
                    "Found entry %08lx for File\n", pktEntryFile);

                //
                // FileName is on another volume.
                //

                status = STATUS_NOT_SAME_DEVICE;

            }

        }

    }

    PktRelease();

    DfsDbgTrace(-1, Dbg, "DfsAreFilesOnSameLocalVolume exit %08lx\n", ULongToPtr(status));

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsclose.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       CLOSE.C
//
//  Contents:   This module implements the File Close and Cleanup routines for
//              Dsfs called by the dispatch driver.
//
//  Functions:  DfsFsdClose - FSD entry point for Close IRP
//              DfsFsdCleanup - FSD entry point for Cleanup IRP
//              DfsFspClose - FSP entry point for Close IRP
//              DfsCommonClose - Common close IRP handler
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "fcbsup.h"
#include "mupwml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsCloseWorkInSystemContext (
    PDFS_FCB pDfsFcb );

VOID
DfsClosePostSystemWork(
    PDFS_FCB pDfsFcb );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsdClose )
#pragma alloc_text( PAGE, DfsFsdCleanup )
#pragma alloc_text( PAGE, DfsFspClose )
#pragma alloc_text( PAGE, DfsCommonClose )
#endif // ALLOC_PRAGMA

//+-------------------------------------------------------------------
//
//  Function:   DfsFsdClose, public
//
//  Synopsis:   This routine implements the FSD part of closing down the
//              last reference to a file object.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the
//                                file being closed exists
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The FSD status for the IRP
//
//  Notes:      Even when the close is through the attached device
//              object, we need to check if the file is one of ours,
//              since files opened via the logical root device
//              object get switched over to the attached device for
//              local volumes.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext;

    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdClose_Entry, 
                   LOGPTR(DeviceObject)
                   LOGPTR(Irp)
                   LOGPTR(FileObject));

    DfsDbgTrace(+1, Dbg, "DfsFsdClose:  Entered\n", 0);
    ASSERT(IoIsOperationSynchronous(Irp) == TRUE);

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {
        if (DfsLookupFcb(IrpSp->FileObject) == NULL) {
            Status = DfsVolumePassThrough(DeviceObject, Irp);
            DfsDbgTrace(-1, Dbg, "DfsFsdClose:  Exit -> %08lx\n", ULongToPtr(Status) );
            return Status;
        }
    }

    //
    //  Call the common close routine, with blocking allowed if synchronous
    //
    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonClose( IrpContext, Irp );


    } except(DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdClose:  Exit -> %08lx\n", ULongToPtr(Status));

    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdClose_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(DeviceObject)
                   LOGPTR(Irp)
                   LOGPTR(FileObject)); 
    return Status;
}




//+-------------------------------------------------------------------
//
//  Function:   DfsFsdCleanup, public
//
//  Synopsis:   This routine implements the FSD part of closing down the
//              last user handle to a file object.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the
//                                file being closed exists
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The FSD status for the IRP
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    DfsDbgTrace(+1, Dbg, "DfsFsdCleanup:  Entered\n", 0);
    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdCleanup_Entry,
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));

    ASSERT(IoIsOperationSynchronous(Irp) == TRUE);

    //
    // Now, pass through to the device that opened the file for us if the
    // file was a redirected open of some kind.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS) {
        TypeOfOpen = DfsDecodeFileObject( FileObject, &Vcb, &Fcb);
        if (TypeOfOpen == RedirectedFileOpen) {
            Status = DfsVolumePassThrough(DeviceObject, Irp);
            DfsDbgTrace(-1, Dbg, "DfsFsdCleanup: RedirectedOpen.Exit -> %08lx\n", ULongToPtr(Status) );
            return Status;
        }
    }

    //
    //  TypeOfOpen != RedirectedFileOpen. We do nothing special for cleanup;
    //  everything is done in the close routine.
    //

    FsRtlEnterFileSystem();

    Status = STATUS_SUCCESS;

    DfsCompleteRequest( NULL, Irp, Status );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdCleanup:  Exit -> %08lx\n", ULongToPtr(Status));

    MUP_TRACE_HIGH(TRACE_IRP, DfsFsdCleanup_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    return Status;

}



//+-------------------------------------------------------------------
//
//  Function:   DfsFspClose, public
//
//  Synopsis:   This routine implements the FSP part of closing down the
//              last reference to a file object.
//
//  Arguments:  [IrpContext] -- Supplies the IRP context for the request
//                              being processed.
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    PDEVICE_OBJECT - Returns the volume device object
//                      of the volume just processed by this operation.
//                      This value is used by the Fsp dispatcher to examine
//                      the device object's overflow queue
//
//--------------------------------------------------------------------


VOID
DfsFspClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    DfsDbgTrace(+1, Dbg, "DfsFspClose:  Entered\n", 0);

    //
    //  Call the common close routine.
    //

    (VOID)DfsCommonClose( IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspClose:  Exit -> VOID\n", 0);
}




//+-------------------------------------------------------------------
//
//  Function:   DfsCommonClose, local
//
//  Synopsis:   This is the common routine for closing a file/directory
//              called by both the fsd and fsp threads.
//
//              Close is invoked whenever the last reference to a file
//              object is deleted.  Cleanup is invoked when the last handle
//              to a file object is closed, and is called before close.
//
//              The function of close is to completely tear down and
//              remove the DFS_FCB structures associated with the
//              file object.
//
//  Arguments:  [Irp] -- Supplies the Irp to process
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    BOOLEAN DontComplete = FALSE;
    BOOLEAN pktLocked;

    DfsDbgTrace(+1, Dbg, "DfsCommonClose: Entered\n", 0);

    DfsDbgTrace( 0, Dbg, "Irp          = %08lx\n", Irp);
    DfsDbgTrace( 0, Dbg, "->FileObject = %08lx\n", FileObject);


    //
    //  This action is a noop for unopened file objects.  Nothing needs
    //  to be done for FS device opens, either.
    //

    TypeOfOpen = DfsDecodeFileObject( FileObject, &Vcb, &Fcb);
    if (TypeOfOpen == UnopenedFileObject ||
        TypeOfOpen == FilesystemDeviceOpen ) {

        DfsDbgTrace(-1, Dbg, "DfsCommonClose:  Filesystem file object\n", 0);
        DfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    try {

        //
        //  Case on the type of open that we are trying to close.
        //

        switch (TypeOfOpen) {

        case LogicalRootDeviceOpen:

            DfsDbgTrace(0, Dbg, "DfsCommonClose: Close LogicalRootDevice\n", 0);

            InterlockedDecrement(&Vcb->DirectAccessOpenCount);
            InterlockedDecrement(&Vcb->OpenFileCount);

            if (Vcb->VcbState & VCB_STATE_FLAG_LOCKED) {
                ASSERT (Vcb->FileObjectWithVcbLocked == FileObject);
                Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED;
                Vcb->FileObjectWithVcbLocked = NULL;
            }

            try_return( Status = STATUS_SUCCESS );

        case RedirectedFileOpen:

            DfsDbgTrace(0, Dbg, "DfsCommonClose:  File -> %wZ\n", &Fcb->FullFileName);

            //
            //  Decrement the OpenFileCount for the Vcb through which this
            //  file was opened.
            //

            InterlockedDecrement(&Vcb->OpenFileCount);


            //
            //  Close the redirected file by simply passing through
            //  to the redirected device.  We detach the DFS_FCB from the
            //  file object before the close so it cannot be looked
            //  up in some other thread.
            //

            DfsDetachFcb( FileObject, Fcb);
            Status = DfsFilePassThrough(Fcb, Irp);

            DontComplete = TRUE;

            //
            // Post to system work here, to avoid deadlocks with RDR.
            // workaround for bug 20642.
            //
            DfsClosePostSystemWork( Fcb );

            break;

        default:
            BugCheck("Dfs close, unexpected open type");
        }

    try_exit: NOTHING;

    } finally {

        //
        //  If this is a normal termination, then complete the request.
        //  Even if we're not to complete the IRP, we still need to
        //  delete the IRP_CONTEXT.
        //

        if (!AbnormalTermination()) {
            if (DontComplete) {
                DfsCompleteRequest( IrpContext, NULL, 0 );
            } else {
                DfsCompleteRequest( IrpContext, Irp, Status );
            }
        }

        DfsDbgTrace(-1, Dbg, "DfsCommonClose:  Exit -> %08lx\n", ULongToPtr(Status));
    }
    return Status;
}


VOID
DfsClosePostSystemWork(
    PDFS_FCB pDfsFcb )
{
    ExInitializeWorkItem( &pDfsFcb->WorkQueueItem,
                          DfsCloseWorkInSystemContext,
                          pDfsFcb );

    ExQueueWorkItem( &pDfsFcb->WorkQueueItem, CriticalWorkQueue );

    return;
}

//
//work around for bug 20642.
//
VOID
DfsCloseWorkInSystemContext (
    PDFS_FCB pDfsFcb )
{

    BOOLEAN pktLocked;
    //
    //  Decrement the RefCount on the DFS_MACHINE_ENTRY through which
    //  this file was opened
    //

    PktAcquireExclusive( TRUE, &pktLocked );

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    DfsDecrementMachEntryCount(pDfsFcb->DfsMachineEntry, TRUE);

    ExReleaseResourceLite( &DfsData.Resource );

    PktRelease();


    DfsDeleteFcb( NULL, pDfsFcb );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsgluon.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       DfsGluon.h
//
//  Contents:   Declarations for dfs use of gluons
//
//  Classes:
//
//  Functions:
//
//  History:    March 24, 1994		Milans Created
//
//-----------------------------------------------------------------------------


#ifndef _DFS_GLUON_
#define _DFS_GLUON_

#include <gluon.h>

//
// Marshalling info for TAddress
//

extern MARSHAL_INFO MiTAddress;

#define INIT_TADDRESS_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_TAddress[] = {			\
    	_MCode_conformant(TA_ADDRESS, Address, AddressLength),		\
    	_MCode_ush(TA_ADDRESS, AddressLength),				\
	_MCode_ush(TA_ADDRESS, AddressType),				\
	_MCode_cauch(TA_ADDRESS, Address, AddressLength) 		\
    };									\
    MARSHAL_INFO MiTAddress = _mkMarshalInfo(TA_ADDRESS, _MCode_TAddress);

//
// Marshalling info for DS_TRANSPORT
//

extern MARSHAL_INFO MiDSTransport;

#define INIT_DS_TRANSPORT_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSTransport[] = {			\
        _MCode_conformant(DS_TRANSPORT, taddr.Address, taddr.AddressLength), \
    	_MCode_ush(DS_TRANSPORT, usFileProtocol),			\
	_MCode_ush(DS_TRANSPORT, iPrincipal),				\
	_MCode_ush(DS_TRANSPORT, grfModifiers),				\
	_MCode_struct(DS_TRANSPORT, taddr, &MiTAddress)		\
    };									\
    MARSHAL_INFO MiDSTransport = _mkMarshalInfo(DS_TRANSPORT, _MCode_DSTransport);


//
// The following is needed to define an array of pointers to DS_TRANSPORT
//

typedef struct _DS_TRANSPORT_P {
    PDS_TRANSPORT pDSTransport;
} DS_TRANSPORT_P;

#define INIT_DS_TRANSPORT_P_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSTransportP[] = {			\
    	_MCode_pstruct(DS_TRANSPORT_P, pDSTransport, &MiDSTransport)	\
    };									\
    MARSHAL_INFO MiDSTransportP = _mkMarshalInfo(DS_TRANSPORT_P, _MCode_DSTransportP);

extern MARSHAL_INFO MiDSTransportP;

//
// Marshalling info for DS_MACHINE
//

extern MARSHAL_INFO MiDSMachine;

#define INIT_DS_MACHINE_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_DSMachine[] = {			\
        _MCode_conformant(DS_MACHINE, rpTrans, cTransports),		\
    	_MCode_guid(DS_MACHINE, guidSite),				\
	_MCode_guid(DS_MACHINE, guidMachine),				\
	_MCode_ul(DS_MACHINE, grfFlags),				\
	_MCode_pwstr(DS_MACHINE, pwszShareName),			\
	_MCode_ul(DS_MACHINE, cPrincipals),				\
	_MCode_pcapwstr(DS_MACHINE, prgpwszPrincipals, cPrincipals),	\
	_MCode_ul(DS_MACHINE, cTransports),				\
	_MCode_castruct(DS_MACHINE, rpTrans, cTransports, &MiDSTransportP) \
    };									\
    MARSHAL_INFO MiDSMachine = _mkMarshalInfo(DS_MACHINE, _MCode_DSMachine);

//
// The following is needed to define an array of pointers to DS_MACHINE
//

typedef struct _DS_MACHINE_P {
    PDS_MACHINE pDSMachine;
} DS_MACHINE_P;

#define INIT_DS_MACHINE_P_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSMachineP[] = {			\
    	_MCode_pstruct(DS_MACHINE_P, pDSMachine, &MiDSMachine)		\
    };									\
    MARSHAL_INFO MiDSMachineP = _mkMarshalInfo(DS_MACHINE_P, _MCode_DSMachineP);

extern MARSHAL_INFO MiDSMachineP;

#endif // _DFS_GLUON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsdata.h ===
//+----------------------------------------------------------------------------
//
//  File:       dfsdata.h
//
//  Contents:   This module declares the global data used by the
//              Dfs file system.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created.
//
//-----------------------------------------------------------------------------

#ifndef _DFSDATA_
#define _DFSDATA_

//
//  The global Dfs FSD data record. All Dfs allocated data structures are
//  anchored off of DfsData.
//

extern DFS_DATA DfsData;

//
//  The global timer context record, used by the timer thread and work items
//  queued by the timer thread.
//

extern DFS_TIMER_CONTEXT DfsTimerContext;

//
//  The maximum length of a logical root device name: length
//  of the device name prefix, plus size of a path separator
//  plus the maximum logical root name length.
//

#define MAX_LOGICAL_ROOT_LEN    (sizeof(DD_DFS_DEVICE_DIRECTORY) +          \
                                    sizeof (UNICODE_PATH_SEP) +             \
                                    MAX_LOGICAL_ROOT_NAME * sizeof (WCHAR))

extern WCHAR LogicalRootDevPath[];

extern ULONG DfsEventLog;
extern ULONG MupVerbose;

//
//  The global Dsfs debug level variable.
//

#if DBG

extern LONG DfsDebugTraceLevel;
extern LONG DfsDebugTraceIndent;

#define DEBUG_TRACE_ERROR               (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS         (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS    (0x00000004)
#define DEBUG_TRACE_UNWIND              (0x00000008)
#define DEBUG_TRACE_REGISTRY            (0x00000010)
#define DEBUG_TRACE_CLOSE               (0x00000020)
#define DEBUG_TRACE_CREATE              (0x00000040)
#define DEBUG_TRACE_INIT                (0x00000080)
#define DEBUG_TRACE_INSTRUM             (0x00000100)
#define DEBUG_TRACE_FILEINFO            (0x00000200)
#define DEBUG_TRACE_FSCTRL              (0x00000400)
#define DEBUG_TRACE_RTL                 (0x00000800)
#define DEBUG_TRACE_READ                (0x00001000)
#define DEBUG_TRACE_VOLINFO             (0x00002000)
#define DEBUG_TRACE_WRITE               (0x00004000)
#define DEBUG_TRACE_DEVCTRL             (0x00008000)
#define DEBUG_TRACE_PKT                 (0x00010000)
#define DEBUG_TRACE_DOTDFS              (0x00020000)
#define DEBUG_TRACE_LOCALVOL            (0x00040000)
#define DEBUG_TRACE_DNR                 (0x00080000)
#define DEBUG_TRACE_ATTACH              (0x00100000)
#define DEBUG_TRACE_FASTIO              (0x00200000)
#define DEBUG_TRACE_DIRSUP              (0x00400000)
#define DEBUG_TRACE_FILOBSUP            (0x00800000)
#define DEBUG_TRACE_EVENTLOG            (0x01000000)
#define DEBUG_TRACE_LOGROOT             (0x02000000)
#define DEBUG_TRACE_CACHESUP            (0x04000000)
#define DEBUG_TRACE_PREFXSUP            (0x08000000)
#define DEBUG_TRACE_DEVIOSUP            (0x10000000)
#define DEBUG_TRACE_STRUCSUP            (0x20000000)
#define DEBUG_TRACE_FSP_DISPATCHER      (0x40000000)
#define DEBUG_TRACE_FSP_DUMP            (0x80000000)

//+---------------------------------------------------------------------------
// Macro:       DfsDbgTrace, public
//
// Synopsis:    Conditionally print a debug trace message
//
// Arguments:   [Indent] -- Indent to appluy: +1, 0 or -1
//              [Level] -- debug trace level
//              [Msg] -- Message to be printed, can include one prinf-style
//                      format effector.
//              [Y] -- Value to be printed
//
// Returns:     None
//
//----------------------------------------------------------------------------

VOID DfsDebugTracePrint(PCHAR x, PVOID y);

#define DfsDbgTrace(INDENT,LEVEL,X,Y) {                      \
    if (((LEVEL) == 0) || (DfsDebugTraceLevel & (LEVEL))) { \
        if ((INDENT) < 0) {                                 \
            DfsDebugTraceIndent += (INDENT);                \
        }                                                   \
        DfsDebugTracePrint(X, (PVOID)Y);                    \
        if ((INDENT) > 0) {                                 \
            DfsDebugTraceIndent += (INDENT);                \
        }                                                   \
    }                                                       \
}

#define DebugUnwind(X) {                                        \
    if (AbnormalTermination()) {                                \
        DfsDbgTrace(0, DEBUG_TRACE_UNWIND, #X ", Abnormal termination.\n", 0); \
    }                                                           \
}

#else

#define DfsDbgTrace(INDENT,LEVEL,X,Y)     {NOTHING;}

#define DebugUnwind(X)                   {NOTHING;}

#endif // DBG


//+---------------------------------------------------------------------------
// Macro:       BugCheck, public
//
// Synopsis:    Call DfsBugCheck with invoker's file and line numbers
//
// Arguments:   [Msg] -- Optional Message to be printed for debug
//                      builds
//
// Returns:     None
//
//----------------------------------------------------------------------------

#if DBG

VOID DfsBugCheck(CHAR *pszmsg, CHAR *pszfile, ULONG line);

#define BugCheck(sz)    DfsBugCheck(sz, __FILE__, __LINE__)

#else

VOID DfsBugCheck(VOID);

#define BugCheck(sz)    DfsBugCheck()

#endif

#endif // _DFSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsrtl.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   DfsRtl.h
//
//  Contents:
//
//  Functions:
//
//  History:     27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#ifndef _DFSRTL_
#define _DFSRTL_

#include <stddef.h>

BOOLEAN
DfsRtlPrefixPath (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Test,
    IN BOOLEAN IgnoreCase
);

#endif // _DFSRTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsfilob.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       FILOBSUP.C
//
//  Contents:   This module implements the Dfs File object support routines.
//
//  Functions:  DfsSetFileObject - associate internal data structs to file obj
//              DfsDecodeFileObject - get internal structures from file obj
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//              02 Mar 1993     AlanW   Added association of DFS_FCBs with
//                                      file objects (without actually
//                                      modifying fscontext fields).
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "fcbsup.h"

//
//  The debug trace level
//

#define Dbg                             (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsSetFileObject )
#pragma alloc_text ( PAGE, DfsDecodeFileObject )
#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsSetFileObject, public
//
//  Synopsis:   This routine sets the file system pointers within the
//              file object
//
//  Arguments:  [FileObject] -- the file object being modified.
//              [TypeOfOpen] -- Supplies the type of open denoted by
//                      the file object.  This is only used by this
//                      procedure for sanity checking.
//              [VcbOrFcb] -- Supplies a pointer to either a DFS_VCB or DFS_FCB.
//
//  Returns:    None.
//
//--------------------------------------------------------------------


VOID
DfsSetFileObject (
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PVOID VcbOrFcb
) {
    DfsDbgTrace(+1, Dbg, "DfsSetFileObject, FileObject = %08lx\n", FileObject);

    ASSERT( TypeOfOpen == RedirectedFileOpen
            && NodeType( VcbOrFcb ) == DSFS_NTC_FCB
            && ((PDFS_FCB) VcbOrFcb)->FileObject == FileObject

                ||

            (TypeOfOpen == UserVolumeOpen
             || TypeOfOpen == LogicalRootDeviceOpen)
            && NodeType( VcbOrFcb ) == DSFS_NTC_VCB

                ||

            TypeOfOpen == FilesystemDeviceOpen
            && NodeType( VcbOrFcb ) == IO_TYPE_DEVICE

                ||

            TypeOfOpen == UnopenedFileObject );



    //
    //  Now set the fscontext fields of the file object
    //

    if ( ARGUMENT_PRESENT( FileObject )) {
        ASSERT( DfsLookupFcb(FileObject) == NULL );

        if (TypeOfOpen == RedirectedFileOpen) {
            DfsAttachFcb(FileObject, (PDFS_FCB) VcbOrFcb);
        } else {
            FileObject->FsContext  = VcbOrFcb;
            FileObject->FsContext2 = NULL;
        }
    }

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsSetFileObject -> VOID\n", 0);
    return;
}




//+-------------------------------------------------------------------
//
//  Function:   DfsDecodeFileObject, public
//
//  Synopsis:   This procedure takes a pointer to a file object, that
//              has already been opened by the Dsfs file system and
//              figures out what really is opened.
//
//  Arguments:  [FileObject] -- Supplies the file object pointer being
//                      interrogated
//              [ppVcb] -- Receives a pointer to the Vcb for the file object.
//              [ppFcb] -- Receives a pointer to the Fcb for the
//                      file object, if one exists.
//
//  Returns:    [TYPE_OF_OPEN] - returns the type of file denoted by the
//                      input file object.
//
//              FilesystemDeviceOpen -
//
//              LogicalRootDeviceOpen -
//
//              RedirectedFileOpen - The FO represents a user's opened file or
//                      directory which must be passed through to some other
//                      FSD.  Fcb, Vcb are set.  Fcb points to an Fcb.
//
//--------------------------------------------------------------------

TYPE_OF_OPEN
DfsDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PDFS_VCB *ppVcb,
    OUT PDFS_FCB *ppFcb
) {
    TYPE_OF_OPEN TypeOfOpen;
    PVOID FsContext = FileObject->FsContext;
    PDFS_FCB pFcb;

    DfsDbgTrace(+1, Dbg, "DfsDecodeFileObject, FileObject = %08lx\n",
                                FileObject);

    //
    //  Zero out the out pointer parameters.
    //

    *ppFcb = NULL;
    *ppVcb = NULL;

    //
    //  Attempt to look up the associated DFS_FCB in the lookaside table.
    //  If it's there, the open type must be RedirectedFileOpen.
    //

    pFcb = DfsLookupFcb(FileObject);
    if (pFcb != NULL) {
        *ppFcb = pFcb;
        *ppVcb = pFcb->Vcb;

        ASSERT(pFcb->TargetDevice != NULL);
        TypeOfOpen = RedirectedFileOpen;

        DfsDbgTrace(0, Dbg, "DfsDecodeFileObject, Fcb = %08x\n", pFcb);
        DfsDbgTrace(-1, Dbg, "DfsDecodeFileObject -> %x\n", TypeOfOpen);
        return TypeOfOpen;
    }

    //
    //  Special case the situation where FsContext is null
    //

    if ( FsContext == NULL ) {

        TypeOfOpen = UnopenedFileObject;

    } else {

        //
        //  Now we can case on the node type code of the fscontext pointer
        //  and set the appropriate out pointers
        //

        switch ( NodeType( FsContext )) {

        case IO_TYPE_DEVICE:

            TypeOfOpen = FilesystemDeviceOpen;
            break;

        case DSFS_NTC_VCB:
            *ppVcb = (PDFS_VCB) FsContext;

            TypeOfOpen = LogicalRootDeviceOpen;
            break;

        default:
            TypeOfOpen = UnknownOpen;
        }
    }

    //
    //  and return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsDecodeFileObject -> %x\n", TypeOfOpen);

    return TypeOfOpen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsstr.h ===
//+--------------------------------------------------------------------------
// Module Name: Dfsstr.h
//
// Copyright 1985-96, Microsoft Corporation
//
// Contents:    This module is a common place for all strings in DFS.
//
//---------------------------------------------------------------------------

#ifndef _DFSSTRING_H_
#define _DFSSTRING_H_

//
// Display names for use by Dfs related code
//

#define DFS_COMPONENT_NAME      L"Distributed File System"
#define DFS_PROVIDER_NAME       DFS_COMPONENT_NAME

//
// Commonly used strings and characters
//

#define UNICODE_PATH_SEP_STR    L"\\"
#define UNICODE_PATH_SEP        L'\\'
#define UNICODE_DRIVE_SEP_STR   L":"
#define UNICODE_DRIVE_SEP       L':'


//
// Registry key and value names for storing Dfs volume information
//

#define VOLUMES_DIR             L"Software\\Microsoft\\Dfs\\volumes\\"
#define DOMAIN_ROOT_VOL         L"domainroot"
#define ROOT_SHARE_VALUE_NAME   L"RootShare"
#define CHANGE_LOG_DIR          L"Software\\Microsoft\\Dfs\\ChangeLog\\"
#define CHANGE_ID_VALUE_NAME    L"ChangeId"
#define MAX_CHANGES_VALUE_NAME  L"MaxChanges"
#define NUM_CHANGES_VALUE_NAME  L"NumberOfChanges"
#define CHANGES_KEY_NAME        L"Changes"

//
// The share to connect with to get a referral
//

#define ROOT_SHARE_NAME         L"\\IPC$"
#define ROOT_SHARE_NAME_NOBS    L"IPC$"

//
// Names of driver created objects
//

#define DFS_DEVICE_DIR          L"\\Device\\WinDfs"
#define ORG_NAME                L"Root"
#define DFS_DEVICE_ROOT         L"\\Device\\WinDfs\\Root"
#define DFS_DEVICE_ORG          DFS_DEVICE_ROOT

//
// The share name used to identify UNC access to a Dfs name
//

#define DFS_SHARENAME           L"\\DFS"
#define DFS_SHARENAME_NOBS      L"DFS"

//
// Registry key and value names for storing local volume information
//

#define REG_KEY_LOCAL_VOLUMES   L"SYSTEM\\CurrentControlSet\\Services\\DFS\\LocalVolumes"
#define REG_VALUE_ENTRY_PATH    L"EntryPath"
#define REG_VALUE_ENTRY_TYPE    L"EntryType"
#define REG_VALUE_STORAGE_ID    L"StorageId"

//
// Registry key and value name for retrieving list of trusted domain names
//

#define REG_KEY_TRUSTED_DOMAINS  L"SYSTEM\\CurrentControlSet\\Services\\NetLogon\\Parameters"
#define REG_VALUE_TRUSTED_DOMAINS L"TrustedDomainList"

//
// The following two are related and must be kept in sync. One is the name
// of the named pipe as used by user-level processes. The second names the
// same pipe for kernel-mode code.
//

#define DFS_MESSAGE_PIPE        L"\\\\.\\pipe\\DfsMessage"
#define DFS_KERNEL_MESSAGE_PIPE L"\\Device\\NamedPipe\\DfsMessage"

#endif //_DFSSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsinit.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsinit.c
//
//  Contents:   This module implements the DRIVER_INITIALIZATION routine
//      for the Dfs file system driver.
//
//  Functions:  DfsDriverEntry - Main entry point for driver initialization
//              DfsIoTimerRoutine - Main entry point for scavenger thread
//              DfsDeleteDevices - Routine to scavenge deleted net uses
//
//-----------------------------------------------------------------------------

#include "align.h"

#include "dfsprocs.h"
#include "fastio.h"
#include "fcbsup.h"

//
// The following are includes for init modules, which will get discarded when
// the driver has finished loading.
//

#include "provider.h"

//
//  The debug trace level
//

#define Dbg              (DEBUG_TRACE_INIT)


VOID
MupGetDebugFlags(VOID);

VOID
DfsGetEventLogValue(VOID);

VOID
DfsIoTimerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID    Context
    );

VOID
DfsDeleteDevices(
    PDFS_TIMER_CONTEXT DfsTimerContext);

NTSTATUS
DfsShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOL
DfsCheckLUIDDeviceMapsEnabled(
    VOID
    );

//
// Globals
//
HANDLE DfsDirHandle = NULL;
BOOL DfsLUIDDeviceMapsEnabled = FALSE;

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DfsDriverEntry)
#pragma alloc_text(PAGE, DfsDeleteDevices)
#pragma alloc_text(PAGE, DfsUnload)
#pragma alloc_text(PAGE, DfsShutdown)

//
// The following routine should not be pageable, because it gets called by
// the NT timer routine frequently. We don't want to thrash.
//
// DfsIoTimerRoutine
//


#endif // ALLOC_PRAGMA

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (        \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )



//+-------------------------------------------------------------------
//
//  Function:   DfsDriverEntry, main entry point
//
//  Synopsis:   This is the initialization routine for the Dfs file system
//      device driver.  This routine creates the device object for
//      the FileSystem device and performs all other driver
//      initialization.
//
//  Arguments:  [DriverObject] -- Pointer to driver object created by the
//                      system.
//              [RegistryPath] -- Path to section in registry describing
//                      this driver's configuration.
//
//  Returns:    [NTSTATUS] - The function value is the final status from
//                      the initialization operation.
//
//--------------------------------------------------------------------

NTSTATUS
DfsDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
) {
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT DeviceObject;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PWSTR p;
    int i;
    IO_STATUS_BLOCK iosb;
    LUID LogonID = SYSTEM_LUID;

#if DBG
    //
    // If debug, get debug flags
    //
    MupGetDebugFlags();

#endif

    //
    // Get the event logging level
    //
    DfsGetEventLogValue();

    //
    // See if someone else has already created a File System Device object
    // with the name we intend to use. If so, we bail.
    //

    RtlInitUnicodeString( &UnicodeString, DFS_DRIVER_NAME );

    //
    // Create the filesystem device object.
    //

    Status = IoCreateDevice( DriverObject,
             0,
             &UnicodeString,
             FILE_DEVICE_DFS_FILE_SYSTEM,
             FILE_REMOTE_DEVICE | FILE_DEVICE_SECURE_OPEN,
             FALSE,
             &DeviceObject );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    //
    // Create a permanent object directory in which the logical root
    // device objects will reside.  Make the directory temporary, so
    // we can just close the handle to make it go away.
    //

    UnicodeString.Buffer = p = LogicalRootDevPath;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = MAX_LOGICAL_ROOT_LEN;
    while (*p++ != UNICODE_NULL)
        UnicodeString.Length += sizeof (WCHAR);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        0,
        NULL,
        NULL );

    Status = ZwCreateDirectoryObject(
                &DfsDirHandle,
                DIRECTORY_ALL_ACCESS,
                &ObjectAttributes);

    if ( !NT_SUCCESS( Status ) ) {
        IoDeleteDevice (DeviceObject);
        return Status;
    }

    p[-1] = UNICODE_PATH_SEP;
    UnicodeString.Length += sizeof (WCHAR);

    //
    // Initialize the driver object with this driver's entry points.
    // Most are simply passed through to some other device driver.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = DfsVolumePassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]      = (PDRIVER_DISPATCH)DfsFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]       = (PDRIVER_DISPATCH)DfsFsdClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]     = (PDRIVER_DISPATCH)DfsFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = (PDRIVER_DISPATCH)DfsFsdQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = (PDRIVER_DISPATCH)DfsFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = (PDRIVER_DISPATCH)DfsFsdFileSystemControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION]= (PDRIVER_DISPATCH)DfsFsdQueryVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_VOLUME_INFORMATION]= (PDRIVER_DISPATCH)DfsFsdSetVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = DfsShutdown;

    DriverObject->FastIoDispatch = &FastIoDispatch;

    Status = FsRtlRegisterFileSystemFilterCallbacks( DriverObject, &FsFilterCallbacks );

    if (!NT_SUCCESS( Status )) {

        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        goto ErrorOut;
    }

    //
    //  Initialize the global data structures
    //


    RtlZeroMemory(&DfsData, sizeof (DFS_DATA));

    DfsData.NodeTypeCode = DSFS_NTC_DATA_HEADER;
    DfsData.NodeByteSize = sizeof( DFS_DATA );

    InitializeListHead( &DfsData.VcbQueue );
    InitializeListHead( &DfsData.DeletedVcbQueue );

    // Initialize the devless root queue: this holds all the device less
    // net uses.
    InitializeListHead( &DfsData.DrtQueue );

    InitializeListHead( &DfsData.Credentials );
    InitializeListHead( &DfsData.DeletedCredentials );

    InitializeListHead( &DfsData.OfflineRoots );

    DfsData.DriverObject = DriverObject;
    DfsData.FileSysDeviceObject = DeviceObject;

    DfsData.LogRootDevName = UnicodeString;

    ExInitializeResourceLite( &DfsData.Resource );
    KeInitializeEvent( &DfsData.PktWritePending, NotificationEvent, TRUE );
    KeInitializeSemaphore( &DfsData.PktReferralRequests, 1, 1 );

    DfsData.MachineState = DFS_CLIENT;

    //
    //  Allocate Provider structures.
    //

    DfsData.pProvider = ExAllocatePoolWithTag(
                           PagedPool,
                           sizeof ( PROVIDER_DEF ) * MAX_PROVIDERS,
                           ' puM');

    if (DfsData.pProvider == NULL) {
        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorOut;
    }

    for (i = 0; i < MAX_PROVIDERS; i++) {
        DfsData.pProvider[i].NodeTypeCode = DSFS_NTC_PROVIDER;
        DfsData.pProvider[i].NodeByteSize = sizeof ( PROVIDER_DEF );
    }

    DfsData.cProvider = 0;
    DfsData.maxProvider = MAX_PROVIDERS;


    //
    //  Initialize the system wide PKT
    //

    PktInitialize(&DfsData.Pkt);

    {
       ULONG SystemSizeMultiplier;

       switch (MmQuerySystemSize()) {
       default:
       case MmSmallSystem:
           SystemSizeMultiplier = 4;
           break;
       case MmMediumSystem:
           SystemSizeMultiplier = 8;
           break;

       case MmLargeSystem:
           SystemSizeMultiplier = 16;
           break;
       }

       //
       //  Allocate the DFS_FCB hash table structure.  The number of 
       // hash buckets will depend upon the memory size of the system.
       //

       Status = DfsInitFcbs(SystemSizeMultiplier * 2);
       if (!NT_SUCCESS (Status)) {
           PktUninitialize(&DfsData.Pkt);
           ExFreePool (DfsData.pProvider);
           ZwClose (DfsDirHandle);
           IoDeleteDevice (DeviceObject);
           goto ErrorOut;
       }

       //
       // Create a lookaside for the IRP contexts
       //

       ExInitializeNPagedLookasideList (&DfsData.IrpContextLookaside,
                                        NULL,
                                        NULL,
                                        0,
                                        sizeof(IRP_CONTEXT),
                                        'IpuM',
                                        10 // unused
                                       );

    }

    //
    //  Set up global pointer to the system process.
    //

    DfsData.OurProcess = PsGetCurrentProcess();

    //
    // Set up the global pointers for the EA buffers to be used to differentiate
    // CSC agent opens from non CSC agent opens. This is a read only buffer used
    // to distinguish the CSC agent requests
    //
    //

    {
        UCHAR EaNameCSCAgentSize = (UCHAR) (ROUND_UP_COUNT(
                                            strlen(EA_NAME_CSCAGENT) + sizeof(CHAR),
                                            ALIGN_DWORD
                                            ) - sizeof(CHAR));

        DfsData.CSCEaBufferLength = ROUND_UP_COUNT(
                                         FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                         EaNameCSCAgentSize + sizeof(CHAR),
                                         ALIGN_DWORD
                                     );

        DfsData.CSCEaBuffer = ExAllocatePoolWithTag(
                                  PagedPool,
                                  DfsData.CSCEaBufferLength,
                                  ' puM');

        if (DfsData.CSCEaBuffer != NULL) {

            // clear the buffer, otherwise so we don't get any spurious 
            // failure due to IO manager checks
            memset(DfsData.CSCEaBuffer, 0, DfsData.CSCEaBufferLength);

            RtlCopyMemory(
                (LPSTR)DfsData.CSCEaBuffer->EaName,
                EA_NAME_CSCAGENT,
                EaNameCSCAgentSize);

            DfsData.CSCEaBuffer->EaNameLength = EaNameCSCAgentSize;

            DfsData.CSCEaBuffer->EaValueLength = 0;

            DfsData.CSCEaBuffer->NextEntryOffset = 0;
        } else {
            ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
            DfsUninitFcbs ();
            PktUninitialize(&DfsData.Pkt);
            ExFreePool (DfsData.pProvider);
            ZwClose (DfsDirHandle);
            IoDeleteDevice (DeviceObject);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DfsDbgTrace(-1, DEBUG_TRACE_ERROR, "Failed to allocate CSC ea buffer %08lx\n", ULongToPtr(Status) );
            return Status;
        }
    }

    //
    //  Register the file system with the I/O system. We don't need to invert this as its never registered.
    //

    IoRegisterFileSystem( DeviceObject );

    Status = IoRegisterShutdownNotification (DeviceObject); // This is automaticaly removed when IoDeleteDevice is called
    if (!NT_SUCCESS (Status)) {
        ExFreePool (DfsData.CSCEaBuffer);
        ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
        DfsUninitFcbs ();
        PktUninitialize(&DfsData.Pkt);
        ExFreePool (DfsData.pProvider);
        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        return Status;
    }
    //
    //  Initialize the provider definitions from the registry.
    //

    if (!NT_SUCCESS( ProviderInit() )) {

        DfsDbgTrace(0,DEBUG_TRACE_ERROR,
               "Could not initialize some or all providers!\n", 0);

    }

    //
    // Check if LUID device maps are enabled
    //
    DfsLUIDDeviceMapsEnabled = DfsCheckLUIDDeviceMapsEnabled();
    
    //
    // Initialize the logical roots device objects. These are what form the
    // link between the outside world and the Dfs driver.
    //

#ifdef TERMSRV
    Status = DfsInitializeLogicalRoot( DD_DFS_DEVICE_NAME, NULL, NULL, 0, INVALID_SESSIONID, &LogonID);
#else // TERMSRV
    Status = DfsInitializeLogicalRoot( DD_DFS_DEVICE_NAME, NULL, NULL, 0, &LogonID);
#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(-1, DEBUG_TRACE_ERROR, "Failed creation of root logical root %08lx\n", ULongToPtr(Status) );

        ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
        DfsUninitFcbs ();
        PktUninitialize(&DfsData.Pkt);
        ExFreePool (DfsData.pProvider);
        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        return(Status);
    }

    //
    // Let us start off the Timer Routine.
    //

    RtlZeroMemory(&DfsTimerContext, sizeof(DFS_TIMER_CONTEXT));
    DfsTimerContext.InUse = FALSE;
    DfsTimerContext.TickCount = 0;
    
    //
    // 375929, io initialize timer, check return status.
    //
    Status =  IoInitializeTimer( DeviceObject,
                                 DfsIoTimerRoutine, 
                                 &DfsTimerContext );
    if (Status != STATUS_SUCCESS) {
#ifdef TERMSRV
        DfsDeleteLogicalRoot (DD_DFS_DEVICE_NAME, FALSE, INVALID_SESSIONID, &LogonID);
#else
        DfsDeleteLogicalRoot (DD_DFS_DEVICE_NAME, FALSE, &LogonID);
#endif
        ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
        DfsUninitFcbs ();
        PktUninitialize(&DfsData.Pkt);
        ExFreePool (DfsData.pProvider);
        ZwClose (DfsDirHandle);
        IoDeleteDevice (DeviceObject);
        goto ErrorOut;
    }
    DfsDbgTrace(0, Dbg, "Initialized the Timer routine\n", 0);

    //
    //  Let us start the timer now.
    //

    IoStartTimer(DeviceObject);

    DfsDbgTrace(-1, Dbg, "DfsDriverEntry exit STATUS_SUCCESS\n", 0);

    return STATUS_SUCCESS;

ErrorOut:

     DfsDbgTrace(-1, DEBUG_TRACE_ERROR, "DfsDriverEntry exit  %08lx\n", ULongToPtr(Status) );

     return Status;

}


NTSTATUS
DfsShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    //
    // Unregister the file system object so we can unload
    //
    IoUnregisterFileSystem (DeviceObject);

    DfsCompleteRequest( NULL, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsUnload
//
//  Synopsis:   Routine called at unload time to free resources
//
//  Arguments:  [DriverObject] -- Driver object of MUP
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID
DfsUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    LUID LogonID = SYSTEM_LUID;

    IoStopTimer(DfsData.FileSysDeviceObject);
#ifdef TERMSRV
    DfsDeleteLogicalRoot (DD_DFS_DEVICE_NAME, FALSE, INVALID_SESSIONID, &LogonID);
#else
    DfsDeleteLogicalRoot (DD_DFS_DEVICE_NAME, FALSE, &LogonID);
#endif
    ExFreePool (DfsData.CSCEaBuffer);
    ExDeleteNPagedLookasideList (&DfsData.IrpContextLookaside);
    DfsUninitFcbs ();
    PktUninitialize(&DfsData.Pkt);
    ExFreePool (DfsData.pProvider);
    ExDeleteResourceLite( &DfsData.Resource );
    ZwClose (DfsDirHandle);
    IoDeleteDevice (DfsData.FileSysDeviceObject);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteDevices
//
//  Synopsis:   Routine to scavenge deleted devices (net uses).
//
//  Arguments:  [pDfsTimerContext] -- Timer Context
//
//  Returns:    Nothing - this routine is meant to be queued to a worker
//              thread.
//
//-----------------------------------------------------------------------------

VOID
DfsDeleteDevices(
    PDFS_TIMER_CONTEXT DfsTimerContext)
{
    PLIST_ENTRY plink;
    PDFS_VCB Vcb;
    PLOGICAL_ROOT_DEVICE_OBJECT DeletedObject;

    if (DfsData.DeletedVcbQueue.Flink != &DfsData.DeletedVcbQueue) {

        DfsDbgTrace(0, Dbg, "Examining Deleted Vcbs...\n", 0);

        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

        for (plink = DfsData.DeletedVcbQueue.Flink;
                plink != &DfsData.DeletedVcbQueue;
                    NOTHING) {

             Vcb = CONTAINING_RECORD(
                        plink,
                        DFS_VCB,
                        VcbLinks);

             plink = plink->Flink;

             DeletedObject = CONTAINING_RECORD(
                                Vcb,
                                LOGICAL_ROOT_DEVICE_OBJECT,
                                Vcb);

             if (Vcb->OpenFileCount == 0 &&
                    Vcb->DirectAccessOpenCount == 0 &&
                        DeletedObject->DeviceObject.ReferenceCount == 0) {

                 DfsDbgTrace(0, Dbg, "Deleting Vcb@%08lx\n", Vcb);

                 if (Vcb->LogRootPrefix.Buffer != NULL)
                     ExFreePool(Vcb->LogRootPrefix.Buffer);

                 if (Vcb->LogicalRoot.Buffer != NULL)
                     ExFreePool(Vcb->LogicalRoot.Buffer);

                 RemoveEntryList(&Vcb->VcbLinks);

                 ObDereferenceObject((PVOID) DeletedObject);

                 IoDeleteDevice( &DeletedObject->DeviceObject );

             } else {

                 DfsDbgTrace(0, Dbg, "Not deleting Vcb@%08lx\n", Vcb);

                 DfsDbgTrace(0, Dbg,
                    "OpenFileCount = %d\n", ULongToPtr(Vcb->OpenFileCount) );

                 DfsDbgTrace(0, Dbg,
                    "DirectAccessOpens = %d\n", ULongToPtr(Vcb->DirectAccessOpenCount) );

                 DfsDbgTrace(0, Dbg,
                    "DeviceObject Reference count = %d\n",
                    ULongToPtr(DeletedObject->DeviceObject.ReferenceCount) );

             }

        }

        ExReleaseResourceLite(&DfsData.Resource);

    }

    DfsTimerContext->InUse = FALSE;

}

//+-------------------------------------------------------------------------
//
// Function:    DfsIoTimerRoutine
//
// Synopsis:    This function gets called by IO Subsystem once every second.
//      This can be used for various purposes in the driver.  For now,
//      it periodically posts a request to a system thread to age Pkt
//      Entries.
//
// Arguments:   [Context] -- This is the context information.  It is actually
//              a pointer to a DFS_TIMER_CONTEXT.
//      [DeviceObject] -- Pointer to the Device object for DFS. We dont
//              really use this here.
//
// Returns: Nothing
//
// Notes:   The Context which we get here is assumed to have all the
//      required fields setup properly.
//
// History: 04/24/93    SudK    Created.
//
//--------------------------------------------------------------------------
VOID
DfsIoTimerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID    Context
)
{
    PDFS_TIMER_CONTEXT  pDfsTimerContext = (PDFS_TIMER_CONTEXT) Context;

    DfsDbgTrace(+1, Dbg, "DfsIoTimerRoutine: Entered\n", 0);

    //
    // If the DfsTimerContext is in USE then we just return blindly. Due to
    // this action we might actually lose some ticks. But then we really are
    // not very particular about this and hence dont care.
    //

    if (pDfsTimerContext->InUse == TRUE)    {

        DfsDbgTrace(-1, Dbg, "DfsIoTimerRoutine: TimerContext in use\n", 0);

        return;

    }

    //
    // First let us increment the count in the DFS_TIMER_CONTEXT. If it has
    // reached a bound value then we have to go ahead and schedule the
    // necessary work items.
    //

    pDfsTimerContext->TickCount++;

    if (pDfsTimerContext->TickCount == DFS_MAX_TICKS)   {

        DfsDbgTrace(0, Dbg, "Queuing Pkt Entry Scavenger\n", 0);

        pDfsTimerContext->InUse = TRUE;

        ExInitializeWorkItem(
            &pDfsTimerContext->WorkQueueItem,
            DfsAgePktEntries,
            pDfsTimerContext);

        ExQueueWorkItem( &pDfsTimerContext->WorkQueueItem, DelayedWorkQueue);

    } else if (DfsData.DeletedVcbQueue.Flink != &DfsData.DeletedVcbQueue) {

        DfsDbgTrace(0, Dbg, "Queueing Deleted Vcb Scavenger\n", 0);

        pDfsTimerContext->InUse = TRUE;

        ExInitializeWorkItem(
            &pDfsTimerContext->DeleteQueueItem,
            DfsDeleteDevices,
            pDfsTimerContext);

        ExQueueWorkItem(&pDfsTimerContext->DeleteQueueItem, DelayedWorkQueue);

    }

    DfsDbgTrace(-1, Dbg, "DfsIoTimerRoutine: Exiting\n", 0);

}

//+-------------------------------------------------------------------------
//
// Function:    DfsCheckLUIDDeviceMapsEnabled
//
// Synopsis:    This function calls ZwQueryInformationProcess to determine if
//    LUID device maps are enabled/disabled
//
// Arguments:   NONE
//
// Returns:
//          TRUE - LUID device maps are enabled
//
//          FALSE - LUID device maps are disabled
//
//--------------------------------------------------------------------------
BOOL
DfsCheckLUIDDeviceMapsEnabled(
    VOID
    )
{
    NTSTATUS  Status;
    ULONG     LUIDDeviceMapsEnabled;
    BOOL      Result;

    Status = ZwQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(
            -1,
            DEBUG_TRACE_ERROR,
            "DfsCheckLUIDDeviceMapsEnabled to failed to check if LUID device maps enabled, status = %08lx\n",
            ULongToPtr(Status));
        Result = FALSE;
    }
    else {
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsrtl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsrtl.c
//
//  Contents:
//
//  Functions:  DfsRtlPrefixPath - Is one path a prefix of another?
//
//  History:    27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include "dfsprocs.h"
#include "dfsrtl.h"

#define Dbg              (DEBUG_TRACE_RTL)

#endif

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsRtlPrefixPath )

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsRtlPrefixPath, local
//
//  Synopsis:   This routine will return TRUE if the first string argument
//              is a path name prefix of the second string argument.
//
//  Arguments:  [Prefix] -- Pointer to target device object for
//                      the request.
//              [Test] -- Pointer to I/O request packet
//              [IgnoreCase] -- TRUE if the comparison should be done
//                      case-insignificant.
//
//  Returns:    BOOLEAN - TRUE if Prefix is a prefix of Test and the
//                      comparison ends at a path separator character.
//
//--------------------------------------------------------------------


BOOLEAN
DfsRtlPrefixPath (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Test,
    IN BOOLEAN IgnoreCase
) {
    int cchPrefix;

    if (Prefix->Length > Test->Length) {

        return FALSE;

    }

    cchPrefix = Prefix->Length / sizeof (WCHAR);

    if (Prefix->Length < Test->Length &&
            Test->Buffer[cchPrefix] != L'\\') {

        return FALSE;

    }

    return( RtlPrefixUnicodeString( Prefix, Test, IgnoreCase ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsmrshl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       dfsmrshl.c
//
//  Contents:   Routines to handle marshalling of data structures. This file
//              has been specifically created so that user level code can
//              avail of the marshalling code simply by including this file.
//
//  Classes:
//
//  Functions:
//
//  History:    March 29, 1994          Milans created from PeterCo's routines
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include "dfsprocs.h"
#include "dfsmrshl.h"
#include "dfsrtl.h"

#define Dbg              (DEBUG_TRACE_RTL)

#else // !KERNEL_MODE

#include "dfsmrshl.h"

#ifndef ExRaiseStatus
#define ExRaiseStatus(x)        RtlRaiseStatus(x)
#endif // ExRaiseStatus

#ifndef try_return
#define try_return(s)           {s; goto try_exit;}
#endif // try_return

#ifndef DfsDbgTrace
#define DfsDbgTrace(i,l,f,s)
#endif // DfsDbgTrace

#endif // KERNEL_MODE



NTSTATUS
DfsRtlGetpwString(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    OUT    PWSTR                *ppwszString
);

NTSTATUS
DfsRtlPutpwString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PWSTR       *ppwszString
);

NTSTATUS
DfsRtlGetString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
);

NTSTATUS
DfsRtlPutString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
);

NTSTATUS
DfsRtlGetArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray);

NTSTATUS
DfsRtlPutArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsRtlGetpwString )
#pragma alloc_text( PAGE, DfsRtlPutpwString )
#pragma alloc_text( PAGE, DfsRtlGetString )
#pragma alloc_text( PAGE, DfsRtlPutString )
#pragma alloc_text( PAGE, DfsRtlGetArrayUchar )
#pragma alloc_text( PAGE, DfsRtlPutArrayUchar )
#pragma alloc_text( PAGE, DfsRtlGet )
#pragma alloc_text( PAGE, DfsRtlPut )
#pragma alloc_text( PAGE, DfsRtlSize )
#pragma alloc_text( PAGE, DfsRtlUnwindGet )

#endif //ALLOC_PRAGMA

#define UNREFERENCED_LABEL(label)\
    if(0) goto label;

//
// Defines and functions for unmarshalling base types.
// Regarding the BYTE macros below we dont care whether we are on
// LITTLE ENDIAN or BIG ENDIAN. It just does not matter.
//

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)


#define DfsRtlGetUchar(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 1 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (UCHAR)((MarshalBuffer)->Current[0]     ),          \
        (MarshalBuffer)->Current += 1,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUchar(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 1 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current += 1,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + 2 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (USHORT)((MarshalBuffer)->Current[0]     ) |        \
                            ((MarshalBuffer)->Current[1] << 8),         \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + 2 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
   