unger = (IU32)((FPHOST *)&(memPtr->fpvalue))->hiword.mant_hi;
	munger <<= 11;
	munger |= 0x80000000;
	((FP80 *)&(FPTemp.fpvalue))->mant_hi = munger | (((FPHOST *)&(memPtr->fpvalue))->mant_lo >> 21);
	((FP80 *)&(FPTemp.fpvalue))->mant_lo = ((((FPHOST *)&(memPtr->fpvalue))->mant_lo) << 11);
}


LOCAL VOID WriteInfinityToIntel IFN2(VOID *, memPtr, IU16, neg_val)
{
	if (FPtype == M32R) {
		if (neg_val == 0) {
			*(IU32 *)memPtr = 0x7f800000;
		} else {
			*(IU32 *)memPtr = 0xff800000;
		}
	} else {
		if (FPtype == M80R) {
			if (neg_val == 0) {
				*((IU8 *)memPtr + 0) = 0x7f;
			} else {
				*((IU8 *)memPtr + 0) = 0xff;
			}
			*((IU8 *)memPtr + 1) = 0xff;
			*((IU8 *)memPtr + 2) = 0x80;
			*((IU8 *)memPtr + 3) = 0;
			*((IU8 *)memPtr + 4) = 0;
			*((IU8 *)memPtr + 5) = 0;
			*((IU8 *)memPtr + 6) = 0;
			*((IU8 *)memPtr + 7) = 0;
			*((IU8 *)memPtr + 8) = 0;
			*((IU8 *)memPtr + 9) = 0;
		} else {
			if (neg_val == 0) {
				*((IU8 *)memPtr + 0) = 0x7f;
			} else {
				*((IU8 *)memPtr + 0) = 0xff;
			}
			*((IU8 *)memPtr + 1) = 0xf0;
			*((IU8 *)memPtr + 2) = 0;
			*((IU8 *)memPtr + 3) = 0;
			*((IU8 *)memPtr + 4) = 0;
			*((IU8 *)memPtr + 5) = 0;
			*((IU8 *)memPtr + 6) = 0;
			*((IU8 *)memPtr + 7) = 0;
		}
	}
}


LOCAL VOID PopStack IFN0()
{
	/* Mark current TOS as free */
	TOSPtr->tagvalue = TAG_EMPTY_MASK;
	TOSPtr = StackEntryByIndex(1);
	DoAPop = FALSE;
}


LOCAL VOID CPY64BIT8BIT IFN2(FPU_I64 *, as64, IU8 *, as8)
{
	*as8 = (as64->low_word & 0xff);
}


LOCAL VOID WriteIntegerIndefinite IFN1(VOID *, memPtr)
{
	switch (FPtype) {
		case M16I	: *((IU32 *)memPtr) = 0x8000;
			  	  break;
		case M32I 	: *((IU32 *)memPtr) = 0x80000000;
			  	  break;
		case M64I	: *((IU8 *)memPtr + 0) = 0x80;
				  *((IU8 *)memPtr + 1) = 0;
				  *((IU8 *)memPtr + 2) = 0;
				  *((IU8 *)memPtr + 3) = 0;
				  *((IU8 *)memPtr + 4) = 0;
				  *((IU8 *)memPtr + 5) = 0;
				  *((IU8 *)memPtr + 6) = 0;
				  *((IU8 *)memPtr + 7) = 0;
				  break;
	}
}


/*(
Name		: SignalStackOverflow
Function		: To set the required bits in the status word following
			  a stack overflow exception, and to issue the required
			  response.
)*/


LOCAL VOID SignalStackOverflow IFN1(FPSTACKENTRY *, StackPtr)
{
	NpxStatus |= (SW_IE_MASK | SW_SF_MASK);
	FlagC1(1);
	if ((NpxControl & CW_IM_MASK) == 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
		DoAPop=FALSE;	/* Just in case it was set */
	} else {
		WriteIndefinite(StackPtr);
	}
}


LOCAL VOID Set64Bit IFN2(FPU_I64 *, as64, IU8, small_val)
{
	as64->high_word = 0;
	as64->low_word = small_val;
}


LOCAL VOID Sub64Bit8Bit IFN2(FPU_I64 *, as64, IU8, small_val)
{
	CVTI64FPH(as64);
	FPRes -= (FPH)small_val;
	CVTFPHI64(as64, &FPRes);
}


LOCAL VOID SignalBCDIndefinite IFN1(IU8 *, memPtr)
{
	*((IU8 *)memPtr + 0) = 0xff;
	*((IU8 *)memPtr + 1) = 0xff;
	*((IU8 *)memPtr + 2) = 0xc0;
	*((IU8 *)memPtr + 3) = 0;
	*((IU8 *)memPtr + 4) = 0;
	*((IU8 *)memPtr + 5) = 0;
	*((IU8 *)memPtr + 6) = 0;
	*((IU8 *)memPtr + 7) = 0;
	*((IU8 *)memPtr + 8) = 0;
	*((IU8 *)memPtr + 9) = 0;
}

/* Called from cpu_init and cpu_reset */

GLOBAL VOID InitNpx IFN1(IBOOL, disabled)
{
	IU16 i;
	IU8 *bottom_ptr;
	IU16 stackPtr = 0;
	SAVED IBOOL first = TRUE;

	/* Set up a couple of control type things */
	NpxException = FALSE;
	NPX_ADDRESS_SIZE_32 = FALSE;
	NPX_PROT_MODE = FALSE;

	if (first)
	{
		/* Get the required memory */
#ifndef SFELLOW
		check_malloc(FPUStackBase, 8, FPSTACKENTRY);
#else
		FPUStackBase = (FPSTACKENTRY *)SFMalloc(8*sizeof(FPSTACKENTRY), FALSE);
#endif	/* SFELLOW */
		first = FALSE;
	}

	for (i=0; i<8; i++) {
		(FPUStackBase+i)->tagvalue = TAG_EMPTY_MASK;
	}
	TOSPtr = FPUStackBase;
	DoAPop = FALSE;

	i=0;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = npx_pi_by_two;
	FpatanTable[i++] = npx_pi_by_two;
	FpatanTable[i++] = npx_zero;
	FpatanTable[i++] = npx_pi;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = npx_minus_pi_by_two;
	FpatanTable[i++] = npx_minus_pi_by_two;
	FpatanTable[i++] = npx_minus_zero;
	FpatanTable[i++] = npx_minus_pi;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = npx_zero;
	FpatanTable[i++] = npx_pi;
	FpatanTable[i++] = npx_zero;
	FpatanTable[i++] = npx_pi;
	FpatanTable[i++] = npx_zero;
	FpatanTable[i++] = npx_pi;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = npx_minus_zero;
	FpatanTable[i++] = npx_minus_pi;
	FpatanTable[i++] = npx_minus_zero;
	FpatanTable[i++] = npx_minus_pi;
	FpatanTable[i++] = npx_minus_zero;
	FpatanTable[i++] = npx_minus_pi;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = npx_pi_by_two;
	FpatanTable[i++] = npx_pi_by_two;
	FpatanTable[i++] = npx_pi_by_two;
	FpatanTable[i++] = npx_pi_by_two;
	FpatanTable[i++] = npx_pi_by_four;
	FpatanTable[i++] = npx_three_pi_by_four;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = npx_minus_pi_by_two;
	FpatanTable[i++] = npx_minus_pi_by_two;
	FpatanTable[i++] = npx_minus_pi_by_two;
	FpatanTable[i++] = npx_minus_pi_by_two;
	FpatanTable[i++] = npx_minus_pi_by_four;
	FpatanTable[i++] = npx_minus_three_pi_by_four;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i++] = NULL;
	FpatanTable[i] = NULL;

	/* Finally, the rest of the FINIT functionality */

	NpxDisabled = disabled;	/* If disabled via the UIF we must ignore FSTSW/FSTCW */

	NpxControl = 0x037f;
	npxRounding = ROUND_NEAREST;
	NpxStatus = 0;
	NpxLastSel=0;
	NpxLastOff=0;
	NpxFEA=0;
	NpxFDS=0;
	NpxFIP=0;
	NpxFOP=0;
	NpxFCS=0;

}


/*(
Name		: LoadValue
Function	: Load up the value for any flavour of operand.
		  This is ALWAYS inlined.
)*/


LOCAL VOID LoadValue IFN2(VOID *, SrcOp, IU16 *, IndexVal)
{
	if (FPtype == FPSTACK) {
		*IndexVal = *(IU16 *)SrcOp;
	} else {
		switch (FPtype) {
			case M16I:	Loadi16ToFP(&FPTemp, SrcOp);
					break;
			case M32I:	Loadi32ToFP(&FPTemp, SrcOp);
					break;
			case M64I:	Loadi64ToFP(&FPTemp, SrcOp);
					break;
			case M32R:	Loadr32ToFP(&FPTemp, SrcOp, FALSE);
					break;
			case M64R:	Loadr64ToFP(&FPTemp, SrcOp, FALSE);
					break;
			case M80R:	Loadr80ToFP(&FPTemp, SrcOp);
					break;
		}
		*IndexVal = FPTEMP_INDEX;
	}
}


/*(
Name		: Loadi16ToFP
Function	: Load a 16-bit value from intel memory and convert it
		  to FPH
)*/

LOCAL VOID Loadi16ToFP IFN2(FPSTACKENTRY *, FPPtr, VOID *, memPtr)
{
	IS16 asint;

	asint = (IS16)*((IU32 *)memPtr);	/* High byte */
	if (asint == 0) {
		/* Fast pass through */
		FPPtr->tagvalue = TAG_ZERO_MASK;
	} else {
		FPPtr->fpvalue = (FPH)asint;
		if (asint < 0) {
			FPPtr->tagvalue = TAG_NEGATIVE_MASK;
		} else {
			FPPtr->tagvalue = 0;
		}
	}
}



/*(
Name		: Loadi32ToFP
Function	: Load a 32-bit value from intel memory and convert it
		  to FPH
)*/


LOCAL VOID Loadi32ToFP IFN2(FPSTACKENTRY *, FPPtr, VOID *, memPtr)
{
	IS32 asint;

	asint = *((IS32 *)memPtr);
	if (asint == 0) {
		/* Fast pass through */
		FPPtr->tagvalue = TAG_ZERO_MASK;
	} else {
		FPPtr->fpvalue = (FPH)asint;
		if (asint < 0) {
			FPPtr->tagvalue = TAG_NEGATIVE_MASK;
		} else {
			FPPtr->tagvalue = 0;
		}
	}
}



/*(
Name		: Loadi64ToFP
Function	: Load a 64-bit value from intel memory and convert it
		  to FPH
)*/


LOCAL VOID Loadi64ToFP IFN2(FPSTACKENTRY *, FPPtr, VOID *, memPtr)
{
	IS32 asint_hi;
	IU32 asint_lo;

	asint_hi = *((IS8 *)memPtr + 0);
	asint_hi <<= 8;
	asint_hi += *((IU8 *)memPtr + 1);
	asint_hi <<= 8;
	asint_hi += *((IU8 *)memPtr + 2);
	asint_hi <<= 8;
	asint_hi += *((IU8 *)memPtr + 3);

	asint_lo = *((IU8 *)memPtr + 4);
	asint_lo <<= 8;
	asint_lo += *((IU8 *)memPtr + 5);
	asint_lo <<= 8;
	asint_lo += *((IU8 *)memPtr + 6);
	asint_lo <<= 8;
	asint_lo += *((IU8 *)memPtr + 7);

	if ((asint_hi | asint_lo) == 0) {
		/* Fast pass through */
		FPPtr->tagvalue = TAG_ZERO_MASK;
	} else {
		FPPtr->fpvalue = (FPH)asint_hi*4294967296.0 + (FPH)asint_lo;
		if (asint_hi < 0) {
			FPPtr->tagvalue = TAG_NEGATIVE_MASK;
		} else {
			FPPtr->tagvalue = 0;
		}
	}
}



/*(
Name		: Loadr32ToFP
Function	: Load a 32-bit real value from intel memory and convert
		  it to FPH
)*/


LOCAL VOID Loadr32ToFP IFN3(FPSTACKENTRY *, FPPtr, VOID *, memPtr, BOOL, setTOS)
{
	IU16 localtag;
	IS32 mantissa;

	/* Note that this, being a 32-bit quantity, is loaded with correct
	host endianness */
	if (((FP32 *)memPtr)->sign == 1) {
		localtag = TAG_NEGATIVE_MASK;
	} else {
		 localtag = 0;
	}
	/* Now check the exponent... */
	if (((FP32 *)memPtr)->exp == 0) {
		/* It's either zero or denormal */
		mantissa = ((FP32 *)memPtr)->mant;
		if (mantissa == 0x0)  {
			/* It's zero */
			 localtag |= TAG_ZERO_MASK;
		} else {
			/* It's a denormal */
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				if (setTOS)
					TOSPtr = FPPtr;
				DoNpxException();
				return;
			} else {
				FPPtr->fpvalue = (FPH)(*(float *)memPtr);
			}
		}
	} else {
		if (((FP32 *)memPtr)->exp == 255) {
			/* It's either infinity or a NaN */
			mantissa = ((FP32 *)memPtr)->mant;
			if (mantissa == 0x0)  {
				/* It's infinity */
				localtag |= TAG_INFINITY_MASK;
			} else {
				localtag |= TAG_NAN_MASK;
				/* Is it quiet or signalling? */
				if ((mantissa & 0x400000) == 0) {
					/* It's a signalling NaN */
					NpxStatus |= SW_IE_MASK;
					if ((NpxControl & CW_IM_MASK) == 0) {
						NpxStatus |= SW_ES_MASK;
						DoNpxException();
						return;
					}
				}
				/* Must load up the mantissa of the NaN */
				((IU32 *)FPPtr)[NPX_HIGH_32_BITS] = ((mantissa << 8) | 0x80000000);
				((IU32 *)FPPtr)[NPX_LOW_32_BITS] = 0;
				if ((mantissa & 0x400000) == 0) {
					if (setTOS)
						((IS32 *)FPPtr)[NPX_HIGH_32_BITS] |= 0x40000000;
					else
						localtag |= TAG_SNAN_MASK;
				}
			}
		} else {
			/* It's a boring ordinary number */
			FPPtr->fpvalue = (FPH)(*(float *)memPtr);
		}
	}
	FPPtr->tagvalue = localtag;
}


/*(
Name		: Loadr64ToFP
Function	: Load a 64-bit real value from intel memory and convert
		  it to FPH
)*/

LOCAL VOID Loadr64ToFP IFN3(FPSTACKENTRY *, FPPtr, VOID *, memPtr, BOOL, setTOS)
{
	IU16 localtag;
	IS32 mantissa_lo;
	IS32 mantissa_hi;

	CopyR64(FPUpload, memPtr);
	if (((FP64 *)&(FPUpload->fpvalue))->hiword.sign != 0) {
		localtag = TAG_NEGATIVE_MASK;
	} else {
		 localtag = 0;
	}
	/* Now check the exponent... */
	if (((FP64 *)&(FPUpload->fpvalue))->hiword.exp == 0) {
		/* It's either zero or denormal */
		mantissa_lo = ((FP64 *)&(FPUpload->fpvalue))->mant_lo;
		mantissa_hi = ((FP64 *)&(FPUpload->fpvalue))->hiword.mant_hi;
		if ((mantissa_lo | mantissa_hi) == 0) {
			/* It's zero */
			 localtag |= TAG_ZERO_MASK;
		} else {
			/* It's a denormal */
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				if (setTOS)
					TOSPtr = FPPtr;
				DoNpxException();
			} else {
				FPPtr->fpvalue = (FPH)(*(DOUBLE *)&(FPUpload->fpvalue));
				/* Really need a sort of host denormal detection */
				/* localtag |= TAG_DENORMAL_MASK; */
			}
		}
	} else {
		if (((FP64 *)&(FPUpload->fpvalue))->hiword.exp == 2047) {
			/* It's either infinity or a NaN */
			mantissa_lo = ((FP64 *)&(FPUpload->fpvalue))->mant_lo;
			mantissa_hi = ((FP64 *)&(FPUpload->fpvalue))->hiword.mant_hi;
			if ((mantissa_lo | mantissa_hi) == 0) {
				/* It's infinity */
				localtag |= TAG_INFINITY_MASK;
			} else {
				localtag |= TAG_NAN_MASK;
				/* Is it quiet or signalling? */
				if ((mantissa_hi & 0x80000) == 0) {
					/* It's a signalling NaN */
					NpxStatus |= SW_IE_MASK;
					if ((NpxControl & CW_IM_MASK) == 0) {
						NpxStatus |= SW_ES_MASK;
						DoNpxException();
						return;
					}
				}
				/* Must load up the mantissa of the NaN */
				((IS32 *)FPPtr)[NPX_HIGH_32_BITS] = ((mantissa_hi << 11) | 0x80000000);
				((IS32 *)FPPtr)[NPX_HIGH_32_BITS] |= ((IU32)mantissa_lo >> 21);
				((IS32 *)FPPtr)[NPX_LOW_32_BITS] = (mantissa_lo << 11);
				if ((mantissa_hi & 0x80000) == 0) {
					if (setTOS)
						((IS32 *)FPPtr)[NPX_HIGH_32_BITS] |= 0x40000000;
					else
						localtag |= TAG_SNAN_MASK;
				}
			}
		} else {
			/* It's a boring ordinary number */
			 FPPtr->fpvalue = (FPH)(*(DOUBLE *)FPUpload);
		}
	}
	FPPtr->tagvalue = localtag;
}


/*(
Name		: LoadrTByteToFP
Function	: Load a 80-bit real value from intel memory and convert
		  it to FPH
)*/


/*
 * The R80 representation is { IU64 mant; IU16 signexp }
 * in order to be compatible with the Acpu representation of things.
 */
LOCAL VOID LoadTByteToFP IFN2(FPSTACKENTRY *, FPPtr, VOID *, memPtr)
{
	*((IU8 *)FPPtr + HOST_R80_BYTE_0) = *((IU8 *)memPtr + 0);
	*((IU8 *)FPPtr + HOST_R80_BYTE_1) = *((IU8 *)memPtr + 1);
	*((IU8 *)FPPtr + HOST_R80_BYTE_2) = *((IU8 *)memPtr + 2);
	*((IU8 *)FPPtr + HOST_R80_BYTE_3) = *((IU8 *)memPtr + 3);
	*((IU8 *)FPPtr + HOST_R80_BYTE_4) = *((IU8 *)memPtr + 4);
	*((IU8 *)FPPtr + HOST_R80_BYTE_5) = *((IU8 *)memPtr + 5);
	*((IU8 *)FPPtr + HOST_R80_BYTE_6) = *((IU8 *)memPtr + 6);
	*((IU8 *)FPPtr + HOST_R80_BYTE_7) = *((IU8 *)memPtr + 7);
	*((IU8 *)FPPtr + HOST_R80_BYTE_8) = *((IU8 *)memPtr + 8);
	*((IU8 *)FPPtr + HOST_R80_BYTE_9) = *((IU8 *)memPtr + 9);
}


/*(
Name		: Loadr80ToFP
Function	: Load a 80-bit real value from intel memory
)*/


LOCAL VOID Loadr80ToFP IFN2(FPSTACKENTRY *, FPPtr, VOID *, memPtr)
{
	LoadTByteToFP(FPPtr, memPtr);
	FPPtr->tagvalue = TAG_R80_MASK;
}


LOCAL VOID ConvertR80 IFN1(FPSTACKENTRY *, memPtr)
{
IU32 mantissa_hi;
IU32 mantissa_lo;
IU16 exp_value;

	CopyR80(FPUpload, (VOID *)&(memPtr->fpvalue));
	if (((FP80 *)&(FPUpload->fpvalue))->sign_exp.sign != 0) {
		memPtr->tagvalue = TAG_NEGATIVE_MASK;
	} else {
		memPtr->tagvalue = 0;
	}
	exp_value = ((FP80 *)&(FPUpload->fpvalue))->sign_exp.exp;
	mantissa_hi = ((FP80 *)&(FPUpload->fpvalue))->mant_hi;
	mantissa_lo = ((FP80 *)&(FPUpload->fpvalue))->mant_lo;
	/* Now check the exponent... */
	if ((exp_value >= (16383-HOST_BIAS)) && (exp_value <= (16383+HOST_BIAS))) {
		/* It's a boring ordinary number */
		/* But let's check that it isn't an unnormal */
		if ((mantissa_hi & 0x80000000) == 0) {
			memPtr->tagvalue |= TAG_UNSUPPORTED_MASK;
		} else {
			CVTR80FPH(memPtr, FPUpload);
		}
		return;
	}
	if (exp_value == 0) {
		/* It's either zero or denormal */
		/* It's only meaningful to check for a denorm if HOST_BIAS
		   is equal to or greater than 16383. Otherwise we can do
		   nothing except set the thing to zero.
		*/
#if (HOST_BIAS >= 16383)
		if ((mantissa_hi | mantissa_lo) == 0)  {
			/* It's zero */
			 memPtr->tagvalue |= TAG_ZERO_MASK;
		} else {
			/* It's a denormal */
			/* First, check it isn't a pseudodenorm */
			if ((mantissa_hi & 0x80000000) != 0) {
				memPtr->tagvalue |= TAG_UNSUPPORTED_MASK;
			} else {
				memPtr->tagvalue |= TAG_DENORMAL_MASK;
				CVTR80FPH(memPtr, FPUpload);
			}
		}
#else
		/* It's zero either way */
		if ((mantissa_hi | mantissa_lo) != 0)  {
			/* It's a denormal */
			 memPtr->tagvalue |= TAG_DENORMAL_MASK;
		}
		memPtr->tagvalue |= TAG_ZERO_MASK;
#endif
	} else {
		if ((mantissa_hi & 0x80000000) == 0) {
			memPtr->tagvalue |= TAG_UNSUPPORTED_MASK;
		} else {
			if (exp_value == 32767) {
				/* It's either infinity or a NaN */
				if ((mantissa_hi == 0x80000000) && mantissa_lo == 0)  {
					/* It's infinity */
					memPtr->tagvalue |= TAG_INFINITY_MASK;
				} else {
					memPtr->tagvalue |= TAG_NAN_MASK;
					/* Is it quiet or signalling? */
					if ((mantissa_hi & 0x40000000) == 0) {
						/* It's a signalling NaN */
						memPtr->tagvalue |= TAG_SNAN_MASK;
					}
					/* Must load up the mantissa of the NaN */
					((IU32 *)memPtr)[NPX_HIGH_32_BITS] = mantissa_hi;
					((IU32 *)memPtr)[NPX_LOW_32_BITS]  = mantissa_lo;
				}
			} else {
				if (exp_value > 16384) {
					/* Default to infinity */
					memPtr->tagvalue |= TAG_INFINITY_MASK;
				} else {
					/* Default to zero */
					memPtr->tagvalue |= TAG_ZERO_MASK;
				}
			}
		}
	}
}



/*(
Name		: PostCheckOUP
Function	: This generator is associated with the result of an
		  instruction emulation whose result, an FPH, is to
		  be written out to the stack. We check for O, U anf
		  P exceptions here, but we make no attempt to write out
		  the result. This is because the writing of the result
		  is independent of these exceptions, since for results
		  being written to the stack, delivery of the result
		  cannot be prevented even where these exceptions are
		  unmasked.
)*/


LOCAL VOID PostCheckOUP IFN0()
{
	if (HostGetOverflowException() != 0) {
		NpxStatus |= SW_OE_MASK;	/* Set the overflow bit */
		/* For the masked overflow case, the result delivered by */
		/* the host will be correct, provided it is IEEE compliant. */
		if ((NpxControl & CW_OM_MASK) == 0) {
			AdjustOverflowResponse();
			NpxStatus |= SW_ES_MASK;
			NpxException = TRUE;
		}
	} else {
		/* Overflow and underflow being mutually exclusive... */
		if (HostGetUnderflowException() != 0) {
			NpxStatus |= SW_UE_MASK;
			if ((NpxControl & CW_UM_MASK) == 0) {
				AdjustUnderflowResponse();
				NpxStatus |= SW_ES_MASK;
				NpxException = TRUE;
			}
		}
	}
	if (HostGetPrecisionException() != 0) {
		SetPrecisionBit();
		if ((NpxControl & CW_PM_MASK) == 0) {
			NpxStatus |= SW_ES_MASK;
			NpxException = TRUE;
		}
	}
}



/*(
Name		: CalcTagword
Function	: To calculate the tagword associated with a value
		  and write out the result where appropriate.
)*/


LOCAL VOID CalcTagword IFN1(FPSTACKENTRY *, FPPtr)
{
	IU16 tagword;

	FPPtr->fpvalue = FPRes;
	if (((FPHOST *)&(FPPtr->fpvalue))->hiword.sign == 1) {
		tagword = TAG_NEGATIVE_MASK;
	} else {
		tagword = 0;
	}
	if (((FPHOST *)&(FPPtr->fpvalue))->hiword.exp == 0) {
		/* It's either a zero or a denorm */
		if (FPPtr->fpvalue == 0.0) {
			/* It's a zero */
			tagword |= TAG_ZERO_MASK;
#if (HOST_BIAS >= 16383)
		} else {
			/* It's a denorm */
			tagword |= TAG_DENORMAL_MASK;
#endif
		}
	} else {
		if (((FPHOST *)&(FPPtr->fpvalue))->hiword.exp == HOST_MAX_EXP) {
			/* It MUST be infinity as we can't generate NaNs */
			tagword |= TAG_INFINITY_MASK;
		}
	}
	FPPtr->tagvalue = tagword;
	if (NpxException) {
		DoNpxException();
	}
}



/*(
Name		: SignalStackUnderflow
Function	: To set the required bits in the status word following
		  a stack underflow exception, and to issue the required
		  response.
)*/

LOCAL VOID SignalStackUnderflow IFN1(FPSTACKENTRY *, StackPtr)
{
	NpxStatus |= (SW_IE_MASK | SW_SF_MASK);
	FlagC1(0);
	if ((NpxControl & CW_IM_MASK) == 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
		DoAPop=FALSE;	/* Just in case it was set */
	} else {
		WriteIndefinite(StackPtr);
	}
}


/*(
Name		: SignalSNaN
Function	: To set the required bits in the status word following
		  detection of a signalling NaN.
)*/


LOCAL VOID SignalSNaN IFN1(FPSTACKENTRY *, StackPtr)
{
	NpxStatus |= SW_IE_MASK;
	NpxStatus &= ~SW_SF_MASK;
	if ((NpxControl & CW_IM_MASK) == 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
		DoAPop=FALSE;
	}
}


/*(
Name		: SignalInvalid
Function	: To set the required bits in the status word following
		  any standard "invalid" exception
)*/


LOCAL VOID SignalIndefinite IFN1(FPSTACKENTRY *, StackPtr)
{
	NpxStatus |= SW_IE_MASK;
	NpxStatus &= ~SW_SF_MASK;
	if ((NpxControl & CW_IM_MASK) == 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
		DoAPop=FALSE;
	} else {
		WriteIndefinite(StackPtr);
	}
}



LOCAL VOID SignalInvalid IFN0()
{
	NpxStatus |= SW_IE_MASK;
	NpxStatus &= ~SW_SF_MASK;
	if ((NpxControl & CW_IM_MASK) == 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
		DoAPop=FALSE;
	}
}



/*(
Name		: WriteIndefinite
Function	: Write the value "indefinite" into the location
)*/

LOCAL VOID WriteIndefinite IFN1(FPSTACKENTRY *, StackPtr)
{
	StackPtr->tagvalue = (TAG_NEGATIVE_MASK | TAG_NAN_MASK);
	(((IU32 *)StackPtr)[NPX_HIGH_32_BITS]) = 0xc0000000;
	(((IU32 *)StackPtr)[NPX_LOW_32_BITS]) = 0;
}



/* This generator should always be inlined. */


LOCAL VOID Test2NaN IFN3(IU16, destIndex, FPSTACKENTRY *, src1_addr, FPSTACKENTRY *, src2_addr)
{
	/* Are they both NaNs? */
	if ((tag_xor & TAG_NAN_MASK) == 0) {
		/* Yes, they are.  */
		WriteBiggestNaN(destIndex, src1_addr, src2_addr);
	} else {
		/* No, only one NaN.  */
		if ((src1_addr->tagvalue & TAG_NAN_MASK) != 0) {
			/* It was src1. */
			src2_addr = StackEntryByIndex(destIndex);
			CopyFP(src2_addr, src1_addr);
			if ((src2_addr->tagvalue & TAG_SNAN_MASK) != 0) {
				src2_addr->tagvalue ^= TAG_SNAN_MASK;
				SignalInvalid();
				(((IU32 *)src2_addr)[NPX_HIGH_32_BITS]) |= 0x40000000;
			}
		} else {
			/* It was src2. */
			src1_addr = StackEntryByIndex(destIndex);
			CopyFP(src1_addr, src2_addr);
			if ((src1_addr->tagvalue & TAG_SNAN_MASK) != 0) {
				src1_addr->tagvalue ^= TAG_SNAN_MASK;
				SignalInvalid();
				(((IU32 *)src1_addr)[NPX_HIGH_32_BITS]) |= 0x40000000;
			}
		}
	}
}



/*
Name		: F2XM1
Function	: Compute 2**x - 1
Operation	: ST <- (2**ST - 1)
Flags		: C1 set as per table 15-1
Exceptions	: P, U, D, I, IS
Valid range	: -1 < ST < +1
Notes		: If ST is outside the required range, the result is
		  undefined.
)*/


GLOBAL VOID F2XM1 IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	TestUneval(TOSPtr);
	/* Check if a real value... */
	if ((TOSPtr->tagvalue & ~TAG_NEGATIVE_MASK) == 0) {
		HostClearExceptions();
		/* We can just write the value straight out */
		FPRes = pow(2.0, TOSPtr->fpvalue) - 1.0;
		PostCheckOUP();
		/* This could return anything really.... */
		CalcTagword(TOSPtr);
		return;
	} else {
		/* Some funny bit was set. Check for the possibilities */
		/* We begin with the most obvious cases... */
		/* Response to zero is to return zero with same sign */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0) {
			return;	/* The required result! */
		}
		/* We do denorm checking and bit setting ourselves because this  */
		/* reduces the overhead if the thing is masked. */
		if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			} else {
				HostClearExceptions();
				FPRes = pow(2.0, TOSPtr->fpvalue) - 1.0;
				PostCheckOUP();
				/* Could return a denorm, zero, real, infinity... */
				CalcTagword(TOSPtr);
			}
			return;
		}
		/* If -infinity, return -1. If +infinity, return that */
		/* Sensible enough really, I suppose */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
				memset((char*)TOSPtr,0,sizeof(FPSTACKENTRY));
				TOSPtr->fpvalue = -1.0;
				TOSPtr->tagvalue = TAG_NEGATIVE_MASK;
			}
			return;
		}
		if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			SignalStackUnderflow(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_SNAN_MASK) != 0) {
			MakeNaNQuiet(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_UNSUPPORTED_MASK) != 0) {
			SignalIndefinite(TOSPtr);
			return;
		}
	}
}

/*(
Name		: FABS
Function	: Make the value absolute
Operation	: sign bit of ST <- 0
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined
Exceptions	: IS
Valid range	: Any
Notes		: Note that only the IS exception can be flagged. All
		  other error conditions are ignored, even a signalling
		  NaN! We ALWAYS attempt to make the value positive.
)*/


GLOBAL VOID FABS IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) == 0) {
		/* Now clear the negative bit. */
		if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			TOSPtr->tagvalue ^= TAG_NEGATIVE_MASK;
			/* If the value is real or denormal, we'll want to change the MSB */
			if ((TOSPtr->tagvalue & ~TAG_DENORMAL_MASK) == 0) {
				((FPHOST *)&(TOSPtr->fpvalue))->hiword.sign = 0;
			}
		}
	} else {
		SignalStackUnderflow(TOSPtr);
	}
}

/*(
Name		: FADD
Function	: Add two numbers together
Operation	: Dest <- Src1 + Src2
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined
Exceptions	: IS
Valid range	: Any
Notes		: Note the dependence on the rounding mode when
		  calculating the sign of zero for situations
		  where two zeroes of different sign are input.
)*/


GLOBAL VOID FADD IFN3(IU16, destIndex, IU16, src1Index, VOID *, src2)
{
	IU16 src2Index;

	LoadValue(src2, &src2Index);
	if (POPST) {
		DoAPop=TRUE;
	}
	GenericAdd(destIndex, src1Index, src2Index);
	if (POPST) {
		if (DoAPop) {
			PopStack();
		}
	}
}



/*(
Name		: GenericAdd
Function	: To return dest <- src1+src2
)*/


LOCAL VOID GenericAdd IFN3(IU16, destIndex, IU16, src1Index, IU16, src2Index)
{
	FPSTACKENTRY *src1_addr;
	FPSTACKENTRY *src2_addr;

	src1_addr = StackEntryByIndex(src1Index);
	src2_addr = StackEntryByIndex(src2Index);

	/* Clear C1 */
	FlagC1(0);
	/* If the only tagword bits set are negative or denormal then just proceed */
	TestUneval(src1_addr);
	TestUneval(src2_addr);
	tag_or = (src1_addr->tagvalue | src2_addr->tagvalue);
	if ((tag_or & ~TAG_NEGATIVE_MASK) == 0) {
		HostClearExceptions();
		FPRes = src1_addr->fpvalue + src2_addr->fpvalue;
		/* Reuse one of the above to calculate the destination */
		src1_addr = StackEntryByIndex(destIndex);
		PostCheckOUP();
		/* Could return virtually anything */
		CalcTagword(src1_addr);
	} else {
		/* Some funny bit was set. Check for the possibilities */
		/* The odds on an 'empty', 'unsupported' or 'nan' must be low... */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0) {
			if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
				src1_addr = StackEntryByIndex(destIndex);
				SignalIndefinite(src1_addr);
			} else {
				if ((tag_or & TAG_EMPTY_MASK) != 0) {
					src1_addr = StackEntryByIndex(destIndex);
					SignalStackUnderflow(src1_addr);
				} else {
					/* It must be a NaN type thing. */
					/* Calculate the xor of the tagwords. */
					tag_xor = (src1_addr->tagvalue ^ src2_addr->tagvalue);
					Test2NaN(destIndex, src1_addr, src2_addr);
				}
			}
			return;
		}
		/* Check for the denorm case...I think the odds on it are low, however */
		if ((tag_or & TAG_DENORMAL_MASK) != 0)  {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				DoAPop=FALSE;
				return;
			} else {
				/* First, make sure that we don't have any zeros or */
				/* infinities lurking around... */
				if ((tag_or & ~(TAG_DENORMAL_MASK | TAG_NEGATIVE_MASK)) == 0) {
					HostClearExceptions();
					FPRes = src1_addr->fpvalue + src2_addr->fpvalue;
					/* Reuse one of the above to calculate the destination */
					src1_addr = StackEntryByIndex(destIndex);
					PostCheckOUP();
					/* Could return anything */
					CalcTagword(src1_addr);
					return;
				}
				/* If there were zeros or infinities then we go on to the  */
				/* appropriate code */
			}
		}
		tag_xor = (src1_addr->tagvalue ^ src2_addr->tagvalue);
		/* Check for the case of zero... This is very likely */
		if ((tag_or & TAG_ZERO_MASK) != 0)  {
			if ((tag_xor & TAG_ZERO_MASK) != 0) {
				/* Only one zero. */
				if ((src1_addr->tagvalue & TAG_ZERO_MASK) != 0) {
					src1_addr = StackEntryByIndex(destIndex);
					CopyFP(src1_addr, src2_addr);
				} else {
					src2_addr = StackEntryByIndex(destIndex);
					CopyFP(src2_addr, src1_addr);
				}
			} else {
				/* Both are zeros. Do they have the same sign? */
				src1_addr = StackEntryByIndex(destIndex);
				if ((tag_xor & TAG_NEGATIVE_MASK) != 0) {
					/* No, they don't */
					if (npxRounding == ROUND_NEG_INFINITY) {
						src1_addr->tagvalue = (TAG_ZERO_MASK | TAG_NEGATIVE_MASK);
					} else {
						src1_addr->tagvalue = TAG_ZERO_MASK;
					}
				}
			}
			return;
		}
		/* The only funny bit left is infinity */
		if ((tag_xor & TAG_INFINITY_MASK) == 0) {
			/* They are both infinity. */
			/* If they are the same sign, copy either */
			src1_addr = StackEntryByIndex(destIndex);
			if ((tag_xor & TAG_NEGATIVE_MASK) == 0) {
				src1_addr->tagvalue = tag_or;
			} else {
				/* If opposite signed, raise Invalid */
				SignalIndefinite(src1_addr);
			}
		} else {
			/* Only one is infinity. That is the result. */
			if ((src1_addr->tagvalue & TAG_INFINITY_MASK) != 0) {
				src2_addr = StackEntryByIndex(destIndex);
				src2_addr->tagvalue = src1_addr->tagvalue;
			} else {
				src1_addr = StackEntryByIndex(destIndex);
				src1_addr->tagvalue = src2_addr->tagvalue;
			}
		}
	}
}



/* AddBCDByte(). This generator should be inlined.
 This generator add in a BCD byte to a grand total.
*/

LOCAL VOID AddBCDByte IFN2(FPU_I64 *, total, IU8, byte_val)
{
	Add64Bit8Bit(total, byte_val);
	if (byte_val >= 0x10)  { /* Odds ought to be 16 to 1 on. */
		/* We've added in 16 times the high BCD digit, */
		/* so we need to subtract off 6 times that amount. */
		byte_val &= 0xf0;	/* Isolate the high digit */
		byte_val >>= 2;	/* This is now four times the high digit */
		Sub64Bit8Bit(total, byte_val);
		byte_val >>= 1;	/* This is twice the high digit */
		Sub64Bit8Bit(total, byte_val);
	}
}



/* FBLD: Load BCD value from intel memory.
 The alorithm used here is identical to that in the generic NPX.
 We take each BCD digit and multiply it up by an appropriate amount
 (1, 10, 100, 1000 etc) in order to create two nine digit 32-bit binary
 values. We then convert the word with the high digits (d17-d9) into
 floating point format and multiply by the representation of the value
 for 10**9. This is then stored away (in FPTEMP) and the word with the
 low digits (d8-d0) is converted to floating point format and added to
 the value in FPTEMP. This is then the final binary representation of
 the original BCD value that can be stored at TOS. */

/*(
Name		: FBLD
Function		: Load the BCD value in intel memory onto TOS
Operation		: ST <- Convert to FPH(memPtr);
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined
Exceptions	: IS
Valid range	: -999999999999999999 to 999999999999999999
)*/


GLOBAL VOID FBLD IFN1(IU8 *, memPtr)
{

	/* Clear C1 */
	FlagC1(0);
	/* All we shall do is load it up without consideration */
	TOSPtr = StackEntryByIndex(7);
	if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) == 0) {  /* Highly unlikely, see notes. */
		SignalStackOverflow(TOSPtr);
	} else {
		/* We just copy the bytes directly */
		LoadTByteToFP(TOSPtr, memPtr);
		TOSPtr->tagvalue = TAG_BCD_MASK;
	}
}


LOCAL VOID ConvertBCD IFN1(FPSTACKENTRY *, bcdPtr)
{
	IU8 *memPtr = (IU8 *)&(bcdPtr->fpvalue);
	FPU_I64 total;

	Set64Bit(&total, 0);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_1]);	/* Get d17d16 */
	Mul64Bit8Bit(&total, 100);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_2]);
	Mul64Bit8Bit(&total, 100);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_3]);
	Mul64Bit8Bit(&total, 100);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_4]);
	Mul64Bit8Bit(&total, 100);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_5]);
	Mul64Bit8Bit(&total, 100);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_6]);
	Mul64Bit8Bit(&total, 100);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_7]);
	Mul64Bit8Bit(&total, 100);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_8]);
	Mul64Bit8Bit(&total, 100);
	AddBCDByte(&total, memPtr[HOST_R80_BYTE_9]);
	CVTI64FPH(&total);
	if ((*(memPtr + 0) & 0x80) != 0) {
		FPRes = -FPRes;		/* Make it negative! */
	}
	CalcTagword(bcdPtr);	/* Silly...it can only be negative */
						/* or zero. */
}


/* FBSTP: Store binary coded decimal and pop.
This uses much the same algorithm as before, but reversed. You begin
by checking that the value at TOS is real, then compare it against the
maximum possible value (having first forced the sign bit to be zero).
If it's OK, then turn it into a 64 bit integer and perform the
required repeated subtractions to calculate each of the BCD digits. */


GLOBAL VOID FBSTP IFN1(IU8 *, memPtr)
{
	FPH local_fp;
	IS8 nibble_num;
	IU8 byte_val;
	FPU_I64 as64bit;

	/* Clear C1 */
	FlagC1(0);
	if ((TOSPtr->tagvalue & UNEVALMASK) != 0) {
		switch (TOSPtr->tagvalue & UNEVALMASK) {
			case TAG_BCD_MASK:	/* We just copy the bytes directly */
						WriteFP80ToIntel(memPtr, TOSPtr);
						PopStack();
						return;
						break;
			case TAG_R80_MASK:	ConvertR80(TOSPtr);
						break;
		}
	}
	if ((TOSPtr->tagvalue & ~(TAG_DENORMAL_MASK | TAG_NEGATIVE_MASK)) == 0) {
		/* We're OK. Let's do some checking... */
		if (fabs(TOSPtr->fpvalue) >= MaxBCDValue) {
			/* It's all gone horribly wrong */
			SignalInvalid();
			SignalBCDIndefinite((IU8 *)memPtr);
			PopStack();
			return;
		}
		/* The value is OK. Do the conversion. */
		local_fp = npx_rint(TOSPtr->fpvalue);
		((FPHOST *)&local_fp)->hiword.sign = 0;	/* Force it to be positive */
		CVTFPHI64(&as64bit, &local_fp);
		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[0])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[0]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[0])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[0]);
		}
		*(memPtr + 1) = byte_val;

		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[1])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[1]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[1])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[1]);
		}
		*(memPtr + 2) = byte_val;

		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[2])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[2]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[2])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[2]);
		}
		*(memPtr + 3) = byte_val;

		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[3])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[3]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[3])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[3]);
		}
		*(memPtr + 4) = byte_val;

		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[4])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[4]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[4])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[4]);
		}
		*(memPtr + 5) = byte_val;

		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[5])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[5]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[5])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[5]);
		}
		*(memPtr + 6) = byte_val;

		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[6])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[6]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[6])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[6]);
		}
		*(memPtr + 7) = byte_val;

		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[7])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[7]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[7])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[7]);
		}
		*(memPtr + 8) = byte_val;

		byte_val = 0;
		while (Cmp64BitGTE(&as64bit, &BCDHighNibble[8])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDHighNibble[8]);
		}
		byte_val <<= 4;
		while (Cmp64BitGTE(&as64bit, &BCDLowNibble[8])) {
			byte_val += 1;
			Sub64Bit64Bit(&as64bit, &BCDLowNibble[8]);
		}
		*(memPtr + 9) = byte_val;

		if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			*(memPtr + 0) = 0x80;
			((FPHOST *)&local_fp)->hiword.sign = 1;
		} else {
			*(memPtr + 0) = 0;
		}
		/* Can't prevent delivery of result with unmasked precision
		exception... */
		if (local_fp != TOSPtr->fpvalue) {
			SetPrecisionBit();
			if ((NpxControl & CW_PM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				PopStack();
				DoNpxException();
				return;
			}
		}
	} else {
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) == 0) {
			/* Anything else: Infinity, NaN or whatever... */
			SignalInvalid();
			SignalBCDIndefinite((IU8 *)memPtr);
			PopStack();
			return;
		}
		*(memPtr + 3) = (IU8)0;
		*(memPtr + 4) = (IU8)0;
		*(memPtr + 5) = (IU8)0;
		*(memPtr + 6) = (IU8)0;
		*(memPtr + 7) = (IU8)0;
		*(memPtr + 8) = (IU8)0;
		*(memPtr + 9) = (IU8)0;
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) == 0) {	/* Again, to check what top bytes should be. */
			*(memPtr + 0) = (IU8)0xff;	/* Not the zero case...It must be indefinite */
			*(memPtr + 1) = (IU8)0xff;
			*(memPtr + 2) = (IU8)0xc0;
		} else {
			*(memPtr + 1) = (IU8)0;
			*(memPtr + 2) = (IU8)0;
			if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
				*(memPtr + 0) = 0x80;
			} else {
				*(memPtr + 0) = 0;
			}
		}
	}
	PopStack();
}



/*(
Name		: FCHS
Function	: Change the sign of the value at TOS
Operation	: ST <- Change sign (ST)
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined
Exceptions	: IS
Valid range	: Any
)*/


GLOBAL VOID FCHS IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
		SignalStackUnderflow(TOSPtr);
		return;
	}
	/* That is the only exception condition possible. FCHS always */
	/* succeeds! What a strange instruction! */
	TOSPtr->tagvalue ^= TAG_NEGATIVE_MASK; /* Twiddle the tagword bit */
	/* We only twiddle the sign bit in numbers that are really */
	/* being represented. */
	if ((TOSPtr->tagvalue & ~(TAG_DENORMAL_MASK | TAG_NEGATIVE_MASK)) == 0) {
		((FPHOST *)&(TOSPtr->fpvalue))->hiword.sign ^= 1;
	}
}



/*(
Name		: FCLEX
Function	: Clear the exception flags, exception status flag
		  and busy flag in the FPU status word.
Operation	: SW[0..7]<-0; SW[15]<-0
Flags		: C0, C1, C2 and C3 undefined
Exceptions	: None
Valid range	: Any
)*/


GLOBAL VOID FCLEX IFN0()
{
	NpxStatus &= FCLEX_MASK;
}


/* Comparision opcodes: The following opcodes are all taken care of
in this routine: FCOM m32r, FCOM m64r, FCOM ST(i), FCOM, FCOMP m32real,
FCOMP m64real, FCOMP ST(i), FCOMP, FCOMPP, FICOM m16i, FICOM m32i,
FICOMP m16i, FICOMP m32i.
The method is simple: In every case, one of the two operands for which
comparison is to occur is ST. The second operand is either one of the
four memory operand types specified, or another stack element, ST(i).
There are, in addition, two possible control variables - POPST and
DOUBLEPOP, which set appropriate values in global variables.
*/


GLOBAL VOID FCOM IFN1(VOID *, src2)
{
	IU16 src2Index;

	LoadValue(src2, &src2Index);
	if (POPST || DOUBLEPOP) {
		DoAPop=TRUE;
	}
	GenericCompare(src2Index);
	if (POPST || DOUBLEPOP) {
		if (DoAPop) {
			PopStack();
			if (DOUBLEPOP) {
				PopStack();
			}
		}
	}
}



LOCAL VOID GenericCompare IFN1(IU16, src2Index)
{
	FPSTACKENTRY *src2_addr;

	src2_addr = StackEntryByIndex(src2Index);

	/* Clear C1 */
	FlagC1(0);
	TestUneval(TOSPtr);
	TestUneval(src2_addr);
	tag_or = (TOSPtr->tagvalue | src2_addr->tagvalue);
	/* If the only tagword bit set is negative then just proceed */
	if ((tag_or & ~TAG_NEGATIVE_MASK) == 0)  {
		NpxStatus &= C3C2C0MASK;	/* Clear those bits */
		if (TOSPtr->fpvalue > src2_addr->fpvalue) {
			NpxStatus |= INTEL_COMP_GT;
		} else {
			if (TOSPtr->fpvalue < src2_addr->fpvalue) {
				NpxStatus |= INTEL_COMP_LT;
			} else {
				NpxStatus |= INTEL_COMP_EQ;
			}
		}
	} else {
		/* Everything was not sweetness and light...  */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0) {
			if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
				SignalIndefinite(TOSPtr);
			} else {
				if ((tag_or & TAG_EMPTY_MASK) != 0) {
					SignalStackUnderflow(TOSPtr);
				} else {
					/* It must be a NaN. Just set the "not comparable" result */
					if (UNORDERED) {
						if ((tag_or & TAG_SNAN_MASK) != 0) {
							SignalIndefinite(TOSPtr);
						}
					} else {
						SignalIndefinite(TOSPtr);
					}
				}
			}
			NpxStatus &= C3C2C0MASK;
			NpxStatus |= INTEL_COMP_NC;
			return;
		}
		if ((tag_or & TAG_DENORMAL_MASK) != 0)  {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				return;
			} else {
				/* We can do it now, providing we've got no zeros or infinities */
				if ((tag_or & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0) {
					NpxStatus &= C3C2C0MASK;      /* Clear those bits */
					if (TOSPtr->fpvalue > src2_addr->fpvalue) {
						NpxStatus |= INTEL_COMP_GT;
					} else {
						if (TOSPtr->fpvalue < src2_addr->fpvalue) {
							NpxStatus |= INTEL_COMP_LT;
						} else {
							NpxStatus |= INTEL_COMP_EQ;
						}
					}
					return;
				}
			}
		}
		/* We can calculate the result immediately based on any combination */
		/* of zero, infinity and negative bits. These are the only bits left. */
		/* We will calculate the result using a little table */
		/* First, get the index: */
		tag_or = (TOSPtr->tagvalue & 0x7);
		tag_or <<= 3;
		tag_or |= (src2_addr->tagvalue & 0x7);
		/* This table looks as shown below: */
		/*        TOSPtr            Other Value       Result */
		/*  INF   ZERO   NEG     INF   ZERO    NEG        */
		/*   0      0     0       0      1      0     COMP_GT */
		/*   0      0     0       0      1      1     COMP_GT */
		/*   0      0     0       1      0      0     COMP_LT */
		/*   0      0     0       1      0      1     COMP_GT */
		/*   0      1     0       0      0      0     COMP_LT */
		/*   0      1     0       0      0      1     COMP_GT */
		/*   0      1     0       0      1      0     COMP_EQ */
		/*   0      1     0       0      1      1     COMP_EQ */
		/*   0      1     0       1      0      0     COMP_LT */
		/*   0      1     0       1      0      1     COMP_GT */
		/*   0      1     1       0      0      0     COMP_LT */
		/*   0      1     1       0      0      1     COMP_GT */
		/*   0      1     1       0      1      0     COMP_EQ */
		/*   0      1     1       0      1      1     COMP_EQ */
		/*   0      1     1       1      0      0     COMP_LT */
		/*   0      1     1       1      0      1     COMP_GT */
		/*   1      0     0       0      0      0     COMP_GT */
		/*   1      0     0       0      0      1     COMP_GT */
		/*   1      0     0       0      1      0     COMP_GT */
		/*   1      0     0       0      1      1     COMP_GT */
		/*   1      0     0       1      0      0     COMP_EQ */
		/*   1      0     0       1      0      1     COMP_GT */
		/*   1      0     1       0      0      0     COMP_LT */
		/*   1      0     1       0      0      1     COMP_LT */
		/*   1      0     1       0      1      0     COMP_LT */
		/*   1      0     1       0      1      1     COMP_LT */
		/*   1      0     1       1      0      0     COMP_LT */
		/*   1      0     1       1      0      1     COMP_EQ */
		/*  */
		/* All other values are not possible. */
		NpxStatus &= C3C2C0MASK;
		NpxStatus |= CompZeroTable[tag_or];
		return;
	}
}


/*(
Name		: FCOS
Function	: Calculate the cosine of ST
Operation	: ST <- COSINE(ST)
Flags		: C1, C2 as per table 15-2. C0 and C3 undefined.
Exceptions	: P. U, D, I, IS
Valid range	: |ST| < 2**63.
)*/

GLOBAL VOID FCOS IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	/* Clear C2 */
	FlagC2(0);
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & ~TAG_NEGATIVE_MASK) == 0)  {
		HostClearExceptions();
		/* We can just write the value straight out */
		FPRes = cos(TOSPtr->fpvalue);
		PostCheckOUP();
		/* The return value must be in the range -1 to +1. */
		CalcTagword(TOSPtr);
		return;
	} else {
		/* Lets do the most probable cases first... */
		/* Response to either zero is to return +1 */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0)  {
			memset((char*)TOSPtr,0,sizeof(FPSTACKENTRY));
			TOSPtr->fpvalue = 1.0;
			TOSPtr->tagvalue = 0;
			return;
		}
		/* Lets check for a denormal */
		if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			} else {
				HostClearExceptions();
				FPRes = cos(TOSPtr->fpvalue);
				PostCheckOUP();
				/* The return value must be in the range -1 to +1 */
				CalcTagword(TOSPtr);
			}
			return;
		}
		/* Or it could possibly be infinity... */
		/* For this, the C2 bit is set and the result remains */
		/* unchanged. */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			FlagC2(1);
			return;
		}
		/* It was one of the really wacky bits... */
		if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			SignalStackUnderflow(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_SNAN_MASK) != 0) {
			MakeNaNQuiet(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_UNSUPPORTED_MASK) != 0) {
			SignalIndefinite(TOSPtr);
			return;
		}
	}
}



/*(
Name		: FDECSTP
Function	: Subtract one from the TOS
Operation	: if (ST != 0) { ST <- ST-1 else { ST <- 7 }
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined.
Exceptions	: None
Valid range	: N/A
)*/


GLOBAL VOID FDECSTP IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	TOSPtr = StackEntryByIndex(7);
}



/*(
Name		: FDIV
Function	: Divide the two numbers
Operation	: Dest <- Src1 / Src2 or Dest <- Src2 / Src1
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined
Exceptions	: P, U, O, Z, D, I, IS
Valid range	: Any
Notes		: The REVERSE control variable determines which of the
		  two forms of the operation is used. Popping after a
		  successful execution is controlled by POPST.
)*/


GLOBAL VOID FDIV IFN3(IU16, destIndex, IU16, src1Index, VOID *, src2)
{
	IU16 src2Index;

	LoadValue(src2, &src2Index);
	if (POPST) {
		DoAPop=TRUE;
	}
	GenericDivide(destIndex, REVERSE?src2Index:src1Index, REVERSE?src1Index:src2Index);
	if (POPST) {
		if (DoAPop) {
			PopStack();
		}
	}
}


/*(
Name		: GenericDivide
Function	: To return dest <- src1/src2
)*/


LOCAL VOID GenericDivide IFN3(IU16, destIndex, IU16, src1Index, IU16, src2Index)
{
	FPSTACKENTRY *src1_addr;
	FPSTACKENTRY *src2_addr;

	src1_addr = StackEntryByIndex(src1Index);
	src2_addr = StackEntryByIndex(src2Index);

	/* Clear C1 */
	FlagC1(0);
	TestUneval(src1_addr);
	TestUneval(src2_addr);
	tag_or = (src1_addr->tagvalue | src2_addr->tagvalue);
	/* If the only tagword bit set is negative then just proceed */
	if ((tag_or & (~TAG_NEGATIVE_MASK)) == 0)  {
		HostClearExceptions();
		FPRes = src1_addr->fpvalue/src2_addr->fpvalue;
		/* Reuse one of the above to calculate the destination */
		src1_addr = StackEntryByIndex(destIndex);
		PostCheckOUP();
		/* Value could be anything */
		CalcTagword(src1_addr);
	} else {
		/* Some funny bit was set. Check for the possibilities */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0)  {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				src1_addr = StackEntryByIndex(destIndex);
				SignalStackUnderflow(src1_addr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					src1_addr = StackEntryByIndex(destIndex);
					SignalIndefinite(src1_addr);
				} else {
					/* Well, I suppose it has to be the NaN case... */
					/* Calculate the xor of the tagwords */
					tag_xor = (src1_addr->tagvalue ^ src2_addr->tagvalue);
					Test2NaN(destIndex, src1_addr, src2_addr);
				}
			}
			return;
		}
		if ((tag_or & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				DoAPop = FALSE;
				return;
			} else {
				if ((tag_or & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0) {
					/* OK to proceed */
					HostClearExceptions();
					FPRes = src1_addr->fpvalue/src2_addr->fpvalue;
					/* Reuse one of the above to calculate the destination */
					src1_addr = StackEntryByIndex(destIndex);
					PostCheckOUP();
					/* Value could be anything */
					CalcTagword(src1_addr);
					return;
				}
			}
		}
		tag_xor = (src1_addr->tagvalue ^ src2_addr->tagvalue);
		/* Check for infinity as it has higher precendence than zero. */
		if ((tag_or & TAG_INFINITY_MASK) != 0) {
			if ((tag_xor & TAG_INFINITY_MASK) == 0) {
				/* They are both infinity. This is invalid. */
				src1_addr = StackEntryByIndex(destIndex);
				SignalIndefinite(src1_addr);
			} else {
				/* Only one is infinity. If src1 in infinity, then so */
				/* is the result (even if src2 is zero). */
				src2_addr = StackEntryByIndex(destIndex);
				if ((src1_addr->tagvalue & TAG_INFINITY_MASK) != 0) {
					tag_or = TAG_INFINITY_MASK;
				} else {
					tag_or = TAG_ZERO_MASK;
				}
				tag_or |= (tag_xor & TAG_NEGATIVE_MASK);
				src2_addr->tagvalue = tag_or;
			}
			return;
		}
		/* The only funny bit left is zero */
		if ((tag_xor & TAG_ZERO_MASK) != 0) {
			/* Only one zero. */
			if ((src1_addr->tagvalue & TAG_ZERO_MASK) == 0) {
				/* Src2 is zero. Raise divide by zero */
				NpxStatus |= SW_ZE_MASK;
				if ((NpxControl & CW_ZM_MASK) == 0) {
					NpxStatus |= SW_ES_MASK;
					DoNpxException();
					DoAPop=FALSE;
					return;
				} else {
				/* Unmasked. Infinity with xor of signs. */
					tag_or = TAG_INFINITY_MASK;
				}
			} else {
				/* Src1 is zero. The result is zero with */
				/* the xor of the sign bits. */
				tag_or = TAG_ZERO_MASK;
			}
			src1_addr = StackEntryByIndex(destIndex);
			tag_or |= (tag_xor & TAG_NEGATIVE_MASK);
			src1_addr->tagvalue = tag_or;
		} else {
			/* Both are zeros. This is an invalid operation */
			src1_addr = StackEntryByIndex(destIndex);
			SignalIndefinite(src1_addr);
		}
	}
}


/*
Name		: FFREE
Function	: Set the 'empty' tagword bit in the destination
Operation	: Tag(dest) <- 'empty'
Flags		: All undefined
Exceptions	: None
Valid range	: Any
Notes		:
*/


GLOBAL VOID FFREE IFN1(IU16, destIndex)
{
	FPSTACKENTRY *dest_addr;

	dest_addr = StackEntryByIndex(destIndex);
	dest_addr->tagvalue = TAG_EMPTY_MASK;
	if (POPST) {
		PopStack();
	}
}


/*
Name		: FILD
Function	: Push the memory integer onto the stack
Operation	: Decrement TOS; ST(0) <- SRC.
Flags		: C1 as per table 15-1. Others undefined.
Exceptions	: IS
Valid range	: Any
Notes		: FLD Instruction only: source operand is denormal.
		  Masked response: No special action, load as usual.
		  fld gives an Invalid exception if the stack is full. Unmasked
		  Invalid exceptions leave the stack unchanged. Neither the MIPS
		  nor the 68k code notice stack full, so it is probably safe to
		  assume that it rarely happens, and optimise for the case where
		  there is no exception.
		  fld does not generate an Invalid exception if the ST is a NaN.
		  When loading a Short real or Long real NaN, fld extends the
		  significand by adding zeros at the least significant end.
		  Load operations raise denormal as an "after" exception: the
		  register stack is already updated when the exception is raised
		  fld produces a denormal result only when loading from memory:
		  using fld to transfer a denormal value between registers has
		  no effect.
*/


GLOBAL VOID FLD IFN1(VOID *, memPtr)
{
	FPSTACKENTRY *src_addr;
	IU16 IndexVal;

	/* Clear C1 */
	FlagC1(0);
	src_addr = StackEntryByIndex(7);
	if ((src_addr->tagvalue & TAG_EMPTY_MASK) == 0) {  /* Highly unlikely, see notes. */
		NpxStatus |= (SW_IE_MASK | SW_SF_MASK);
		FlagC1(1);
		if ((NpxControl & CW_IM_MASK) == 0) {
			NpxStatus |= SW_ES_MASK;
			DoNpxException();
		} else {
			TOSPtr = src_addr;
			WriteIndefinite(TOSPtr);
		}
	} else {
		if (FPtype == FPSTACK) {
			IndexVal = *(IU16 *)memPtr;
			src_addr = StackEntryByIndex(IndexVal);
			TOSPtr = StackEntryByIndex(7);
			CopyFP(TOSPtr, src_addr);
		} else {
			switch (FPtype) {
				case M16I	: TOSPtr = src_addr;
						  Loadi16ToFP(TOSPtr, memPtr);
						  break;
				case M32I	: TOSPtr = src_addr;
						  Loadi32ToFP(TOSPtr, memPtr);
					          break;
				case M64I	: TOSPtr = src_addr;
						  Loadi64ToFP(TOSPtr, memPtr);
						  break;
				case M32R	: Loadr32ToFP(src_addr, memPtr, TRUE);
						  TOSPtr = src_addr;
						  break;
				case M64R	: Loadr64ToFP(src_addr, memPtr, TRUE);
						  TOSPtr = src_addr;
						  break;
				case M80R	: TOSPtr = src_addr;
						  Loadr80ToFP(TOSPtr, memPtr);
						  break;
			}
		}
	}
}



/*(
Name		: FINCSTP
Function	: Add one to the TOS
Operation	: if (ST != 7) { ST <- ST+1 else { ST <- 0 ENDif
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined.
Exceptions	: None
Valid range	: N/A
)*/


GLOBAL VOID FINCSTP IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	TOSPtr = StackEntryByIndex(1);
}



/*(
Name		: FINIT
Function	: Initialise the floating point unit
Operation	: CW<-037F; SW<-0; TW<-FFFFH; FEA<-0; FDS<-0;
		  FIP<-0; FOP<-0; FCS<-0;
Flags		: All reset
Exceptions	: None
Valid range	: N/A
)*/


GLOBAL VOID FINIT IFN0()
{
	IU8 counter;

	NpxControl = 0x037f;
	npxRounding = ROUND_NEAREST;
	NpxStatus = 0;
	NpxLastSel=0;
	NpxLastOff=0;
	NpxFEA=0;
	NpxFDS=0;
	NpxFIP=0;
	NpxFOP=0;
	NpxFCS=0;
	TOSPtr = FPUStackBase;
	counter=0;
	while (counter++ < 8) {
		TOSPtr->tagvalue = TAG_EMPTY_MASK;
		TOSPtr++;
	}
	TOSPtr = FPUStackBase;
}



/*(
Name		: FIST(P)
Function	: Store integer from top of stack to memory
Operation	: [mem] <- (I)ST
Flags		: C1 as per table 15-1. All other underfined.
Exceptions	: P, I, IS
Valid range	: N/A
Notes		: FIST (integer store) rounds the content of the stack top to an
		  integer according to the RC field of the control word and transfers
		  the result to the destination. The destination may define a word or
		  short integer variable. Negative zero is stored in the same encoding
		  as positive zero: 0000..00.
		  Where the source register is empty, a NaN, denormal, unsupported,
		  infinity, or exceeds the representable range of destination, the
		  Masked Response: Store integer indefinite.
*/


GLOBAL VOID FIST IFN1(VOID *, memPtr)
{
	IS16 exp_value;
	IS32 res_out;

	/* Clear C1 */
	FlagC1(0);
	if (POPST) {
		DoAPop = TRUE;
	}
	/* If anything other than the negative bit is set then we should deal  */
	/* with it here... */
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & (~TAG_NEGATIVE_MASK)) != 0) { /* Must be unlikely */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0)  {  /* But this is the most likely of them */
			switch (FPtype) {
				case M16I	:
				case M32I	: *((IS32 *)memPtr) = 0;
					          break;
				case M64I	: *((IU8 *)memPtr + 0) = 0;
						  *((IU8 *)memPtr + 1) = 0;
						  *((IU8 *)memPtr + 2) = 0;
						  *((IU8 *)memPtr + 3) = 0;
						  *((IU8 *)memPtr + 4) = 0;
						  *((IU8 *)memPtr + 5) = 0;
						  *((IU8 *)memPtr + 6) = 0;
						  *((IU8 *)memPtr + 7) = 0;
						  break;
			}
		} else {
			NpxStatus |= SW_IE_MASK;
			if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
				NpxStatus |= SW_SF_MASK;
			}
			FlagC1(0);
			if ((NpxControl & CW_IM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				if (POPST) {
					DoAPop=FALSE;	/* Unset it - we won't be popping. */
				}
			} else {
				WriteIntegerIndefinite(memPtr);
			}
		}
	} else {
		HostClearExceptions();
		exp_value = 0;
		/* The result of conversion is written out  */
		/* to FPTemp? */
		switch (FPtype) {
			case M16I	: *(IS16 *)&FPTemp = (IS16)npx_rint(TOSPtr->fpvalue);
					  /* Check for overflow */
					  if ((FPH)(*(IS16 *)&FPTemp) != npx_rint(TOSPtr->fpvalue)) {
						exp_value = 1;	/* flag exception */
					  }
					  break;
			case M32I	: *(IS32 *)&FPTemp = (IS32)npx_rint(TOSPtr->fpvalue);
					  /* Check for overflow */
					  if ((FPH)(*(IS32 *)&FPTemp) != npx_rint(TOSPtr->fpvalue)) {
						exp_value = 1;	/* flag exception */
					  }
				          break;
			case M64I	: CVTFPHI64((FPU_I64 *)&FPTemp, &(TOSPtr->fpvalue)); /* Must be writing the result to FPTemp as well... */
					  CVTI64FPH((FPU_I64 *)&FPTemp);	/* Result in FPRes */
					  /* Check for overflow */
					  if (FPRes != npx_rint(TOSPtr->fpvalue)) {
						exp_value = 1;	/* flag exception */
					  }
					  break;
		}
		if (exp_value == 1) {
			NpxStatus |= SW_IE_MASK;	/* Set the invalid bit */
			/* For the masked overflow case, the result delivered by */
			/* the host will be correct, provided it is IEEE compliant. */
			if ((NpxControl & CW_IM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				DoAPop = FALSE;
			} else {
				WriteIntegerIndefinite(memPtr);
			}
		}
		if (exp_value == 0) {
			switch (FPtype) {
				case M16I	: res_out = *(IS16 *)&FPTemp;
						  *((IU32 *)memPtr) = (IU32)res_out;
						  break;
				case M32I	: res_out = *(IS32 *)&FPTemp;
						  *((IS32 *)memPtr) = (IS32)res_out;
					          break;
				case M64I	: res_out = ((FPU_I64 *)&FPTemp)->high_word;
						  *((IU8 *)memPtr + 3) = res_out & 0xff;
						  res_out >>= 8;
						  *((IU8 *)memPtr + 2) = res_out & 0xff;
						  res_out >>= 8;
						  *((IU8 *)memPtr + 1) = res_out & 0xff;
						  res_out >>= 8;
						  *((IU8 *)memPtr + 0) = res_out & 0xff;
						  res_out = ((FPU_I64 *)&FPTemp)->low_word;
						  *((IU8 *)memPtr + 7) = res_out & 0xff;
						  res_out >>= 8;
						  *((IU8 *)memPtr + 6) = res_out & 0xff;
						  res_out >>= 8;
						  *((IU8 *)memPtr + 5) = res_out & 0xff;
						  res_out >>= 8;
						  *((IU8 *)memPtr + 4) = res_out & 0xff;
						  break;
			}
			/* Check for precision  */
			if (TOSPtr->fpvalue != npx_rint(TOSPtr->fpvalue)) {
				SetPrecisionBit();
				if ((NpxControl & CW_PM_MASK) == 0) {
					NpxStatus |= SW_ES_MASK;
					if (POPST) {
						if (DoAPop) {
							PopStack();
						}
					}
					DoNpxException();
					return;
				}
			}
		}
	}
	if (POPST) {
		if (DoAPop) {
			PopStack();
		}
	}
}



/*(
Name		: FLDconstant
Function	: Load constant value to TOS
Operation	: Push ST: ST(0) <- constant
Flags		: C1 as per table 15-1. All other underfined.
Exceptions	: IS
Valid range	: N/A
*/


GLOBAL VOID FLDCONST IFN1(IU8, const_index)
{

	/* Clear C1 */
	FlagC1(0);
	TOSPtr = StackEntryByIndex(7);
	if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) == 0) {
		SignalStackOverflow(TOSPtr);
	} else {
		memset((char*)TOSPtr,0,sizeof(FPSTACKENTRY));
		TOSPtr->fpvalue =  ConstTable[const_index].fpvalue;
		TOSPtr->tagvalue = ConstTable[const_index].tagvalue;
	}
}



/*(
Name		: FLDCW
Function	: Replace the current value of the FPU control word with
		  the value in the specified memory location.
Operation	: CW <- SRC.
Flags		: All undefined.
Exceptions	: None - but unmasking previously masked exceptions will
		  cause the unmasked exception to be triggered if the
		  matching bit is set in the status word.
Valid range	: N/A
*/


GLOBAL VOID FLDCW IFN1(VOID *, memPtr)
{
	IU32 result;
/*
This function has to modify things. The control word contains the
following information:
Precision control - not implemented.
Rounding control - implemented.
Exception masks - implemented.
Thus when we read in a value for the control word, we have to update
the host's rounding mode and also the exception masks.
*/
	/* First, set the rounding mode */
	result = *(IU32 *)memPtr;
	NpxControl = (IU16)result;
	npxRounding = (NpxControl & 0xc00);
	switch (npxRounding) {
		case ROUND_NEAREST 	: HostSetRoundToNearest();
				   	  break;
		case ROUND_NEG_INFINITY	: HostSetRoundDown();
					  break;
		case ROUND_POS_INFINITY	: HostSetRoundUp();
					  break;
		case ROUND_ZERO		: HostSetRoundToZero();
					  break;
	}
	/* Now adjust the exceptions. If an exception is unmasked, then the */
	/* bit value in NpxControl in '0'. If the exception has been  */
	/* triggered then the corresponding bit in NpxStatus is '1'.Thus, */
	/* the expression ~NpxControl(5..0) | NpxStatus(5..0) will be  */
	/* non-zero when we have unmasked exceptions that were previously */
	/* masked. */
	if (((~(NpxControl & 0x3f)) & (NpxStatus & 0x3f)) != 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
	}
}

GLOBAL VOID FLDCW16 IFN1(VOID *, memPtr)
{
/*
This function has to modify things. The control word contains the
following information:
Precision control - not implemented.
Rounding control - implemented.
Exception masks - implemented.
Thus when we read in a value for the control word, we have to update
the host's rounding mode and also the exception masks.
*/
	/* First, set the rounding mode */
	NpxControl = *(IU16 *)memPtr;
	npxRounding = (NpxControl & 0xc00);
	switch (npxRounding) {
		case ROUND_NEAREST 	: HostSetRoundToNearest();
				   	  break;
		case ROUND_NEG_INFINITY	: HostSetRoundDown();
					  break;
		case ROUND_POS_INFINITY	: HostSetRoundUp();
					  break;
		case ROUND_ZERO		: HostSetRoundToZero();
					  break;
	}
	/* Now adjust the exceptions. If an exception is unmasked, then the */
	/* bit value in NpxControl in '0'. If the exception has been  */
	/* triggered then the corresponding bit in NpxStatus is '1'.Thus, */
	/* the expression ~NpxControl(5..0) | NpxStatus(5..0) will be  */
	/* non-zero when we have unmasked exceptions that were previously */
	/* masked. */
	if (((~(NpxControl & 0x3f)) & (NpxStatus & 0x3f)) != 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
	}
}

/*(
Name		: FLDENV
Function	: Reload the FPU state from memory.
Operation	: FPU state <- SRC
Flags		: As loaded.
Exceptions	: None - but unmasking previously masked exceptions will
		  cause the unmasked exception to be triggered if the
		  matching bit is set in the status word.
Valid range	: N/A
*/


GLOBAL VOID FLDENV IFN1(VOID *, memPtr)
{
	/* First. load the control, status, tagword regs. etc. */
	OpFpuRestoreFpuState(memPtr, 0);
	/* Finally, check to see if any previously unmasked exceptions  */
	/* are now needed to go off. Do this by anding the "triggered" bits in */
	/* NpxStatus with the one's complement of the "masked" bits in NpxControl. */
	if (((NpxStatus & 0x3f) & (~(NpxControl & 0x3f))) != 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
	}
}

/* This generator is used to write out the 14/28 bytes stored by FSTENV,
and FSAVE. */


LOCAL VOID OpFpuStoreFpuState IFN2(VOID *, memPtr, IU32, fsave_offset)
{
	IU32 result;

	/* how the copy takes place depends on the addressing mode */
	/* NPX_ADDRESS_SIZE_32 and NPX_PROT_MODE settings */
	/*************************************************************** */
	/* Need to do similar thing to strings to check that space  */
	/* is available and that there is not paging fault!!!! */
	/*************************************************************** */
	/* The operation should store the control word, tag word */
	/* and status word, so these need to be calculated. It also */
	/* stores the last instruction and data pointers and the opcode */
	/* (if in real mode) */
	/* The offsets from memPtr look strange. Remember that we are going to*/
	/* write this data using the "write bytes" function. This assumes that*/
	/* the data is stored bigendian and writes it out back to front for */
	/* the little-endian intel, as it were. Are you with me? */
	/* fsave offset is required since if we are asked to do an "fsave" */
	/* (as opposed to an fstenv), then the "string" that we are going to */
	/* write will be even bigger, and this stuff must be at the top end */
	/* of it. Horrible but logical */
	if (NPX_PROT_MODE) {
		if (NPX_ADDRESS_SIZE_32) {
			WriteI32ToIntel(((IU8 *)memPtr+24+fsave_offset), (IU32)NpxControl);
			GetIntelStatusWord();
			WriteI32ToIntel(((IU8 *)memPtr+20+fsave_offset), (IU32)NpxStatus);
			GetIntelTagword(&result);
			WriteI32ToIntel(((IU8 *)memPtr+16+fsave_offset), (IU32)result);
			WriteI32ToIntel(((IU8 *)memPtr+12+fsave_offset), (IU32)NpxFIP);
			WriteI32ToIntel(((IU8 *)memPtr+8+fsave_offset), (IU32)NpxFCS);
			WriteI32ToIntel(((IU8 *)memPtr+4+fsave_offset), (IU32)NpxFEA);
			WriteI32ToIntel(((IU8 *)memPtr+0+fsave_offset), (IU32)NpxFDS);
		} else {
			WriteI16ToIntel(((IU8 *)memPtr+12+fsave_offset), (IU16)NpxControl);
			GetIntelStatusWord();
			WriteI16ToIntel(((IU8 *)memPtr+10+fsave_offset), (IU16)NpxStatus);
			GetIntelTagword(&result);
			WriteI16ToIntel(((IU8 *)memPtr+8+fsave_offset), (IU16)result);
			WriteI16ToIntel(((IU8 *)memPtr+6+fsave_offset), (IU16)NpxFIP);
			WriteI16ToIntel(((IU8 *)memPtr+4+fsave_offset), (IU16)NpxFCS);
			WriteI16ToIntel(((IU8 *)memPtr+2+fsave_offset), (IU16)NpxFEA);
			WriteI16ToIntel(((IU8 *)memPtr+0+fsave_offset), (IU16)NpxFDS);
		}
	} else {
		if (NPX_ADDRESS_SIZE_32) {
			WriteI32ToIntel(((IU8 *)memPtr+24+fsave_offset), (IU32)NpxControl);
			GetIntelStatusWord();
			WriteI32ToIntel(((IU8 *)memPtr+20+fsave_offset), (IU32)NpxStatus);
			GetIntelTagword(&result);
			WriteI32ToIntel(((IU8 *)memPtr+16+fsave_offset), (IU32)result);
			WriteI32ToIntel(((IU8 *)memPtr+12+fsave_offset), (IU32)((NpxFIP+(NpxFCS<<4)) & 0xffff));
			WriteI32ToIntel(((IU8 *)memPtr+8+fsave_offset), (IU32)((((NpxFIP+(NpxFCS<<4)) & 0xffff0000) >> 4) | ((IU32)(NpxFOP & 0x7ff))));
			WriteI32ToIntel(((IU8 *)memPtr+4+fsave_offset), (IU32)((NpxFEA+(NpxFDS<<4)) & 0xffff));
			WriteI32ToIntel(((IU8 *)memPtr+0+fsave_offset), (IU32)(((NpxFEA+(NpxFDS<<4)) & 0xffff0000) >> 4));
		} else {
			WriteI16ToIntel(((IU8 *)memPtr+12+fsave_offset), (IU16)NpxControl);
			GetIntelStatusWord();
			WriteI16ToIntel(((IU8 *)memPtr+10+fsave_offset), (IU16)NpxStatus);
			GetIntelTagword(&result);
			WriteI16ToIntel(((IU8 *)memPtr+8+fsave_offset), (IU16)result);
			WriteI16ToIntel(((IU8 *)memPtr+6+fsave_offset), (IU16)((NpxFIP+(NpxFCS<<4)) & 0xffff));
			WriteI16ToIntel(((IU8 *)memPtr+4+fsave_offset), (IU16)((((NpxFIP+(NpxFCS<<4)) & 0xffff0000) >> 4) | ((IU16)(NpxFOP & 0x7ff))));
			WriteI16ToIntel(((IU8 *)memPtr+2+fsave_offset), (IU16)(((NpxFDS<<4)+NpxFEA) & 0xffff));
			WriteI16ToIntel(((IU8 *)memPtr+0+fsave_offset), (IU16)(((NpxFEA+(NpxFDS<<4)) & 0xffff0000) >> 4));
		}
	}
}

/* This generator is called by FLDENV and FRSTOR, to load up the 14/28
byte block. */


LOCAL VOID OpFpuRestoreFpuState IFN2(VOID *, memPtr, IU32, frstor_offset)
{
	IU32 result;

	/* how the copy takes place depends on the addressing mode */
	/* NPX_ADDRESS_SIZE_32 and NPX_PROT_MODE settings */
	/*************************************************************** */
	/* Need to do similar thing to strings to check that space */
	/* is available and that there is not paging fault!!!! */
	/************************************************************** */
	/* The operation should restore the control word, tag word */
	/* and status word, so these need to be translated. It also */
	/* restores the last instruction and data pointers and the opcode */
	/* (if in real mode) */


	/* get the rest of the data, instruction and data pointers */
	if ( NPX_PROT_MODE ) {
		if (NPX_ADDRESS_SIZE_32) {
			ReadI32FromIntel(&result, ((IU8 *)memPtr+24+frstor_offset));
			FLDCW((VOID *)&result);
			ReadI32FromIntel(&result, ((IU8 *)memPtr+20+frstor_offset));
			SetIntelStatusWord(result);
			ReadI32FromIntel(&result, ((IU8 *)memPtr+16+frstor_offset));
			SetIntelTagword(result);
			ReadI32FromIntel(&NpxFIP, ((IU8 *)memPtr+12+frstor_offset));
			ReadI32FromIntel(&NpxFCS, ((IU8 *)memPtr+8+frstor_offset));
			ReadI32FromIntel(&NpxFEA, ((IU8 *)memPtr+4+frstor_offset));
			ReadI32FromIntel(&NpxFDS, ((IU8 *)memPtr+0+frstor_offset));
		} else {
			ReadI16FromIntel(&result, ((IU8 *)memPtr+12+frstor_offset));
			/* Note this is a 32-bit result ! */
			FLDCW((VOID *)&result);
			ReadI16FromIntel(&result, ((IU8 *)memPtr+10+frstor_offset));
			SetIntelStatusWord(result);
			ReadI16FromIntel(&result, ((IU8 *)memPtr+8+frstor_offset));
			SetIntelTagword(result);
			ReadI16FromIntel(&NpxFIP, ((IU8 *)memPtr+6+frstor_offset));
			ReadI16FromIntel(&NpxFCS, ((IU8 *)memPtr+4+frstor_offset));
			ReadI16FromIntel(&NpxFEA, ((IU8 *)memPtr+2+frstor_offset));
			ReadI16FromIntel(&NpxFDS, ((IU8 *)memPtr+0+frstor_offset));
		}
	} else {
		if (NPX_ADDRESS_SIZE_32) {
			ReadI32FromIntel(&result, ((IU8 *)memPtr+24+frstor_offset));
			FLDCW((VOID *)&result);
			ReadI32FromIntel(&result, ((IU8 *)memPtr+20+frstor_offset));
			SetIntelStatusWord(result);
			ReadI32FromIntel(&result, ((IU8 *)memPtr+16+frstor_offset));
			SetIntelTagword(result);
			ReadI32FromIntel(&NpxFIP, ((IU8 *)memPtr+12+frstor_offset));
			NpxFIP &= 0xffff;
			ReadI32FromIntel(&result, ((IU8 *)memPtr+8+frstor_offset));
			NpxFIP |= ((result & 0x0ffff000) << 4);
			ReadI32FromIntel(&NpxFOP, ((IU8 *)memPtr+8+frstor_offset));
			NpxFOP &= 0x7ff;
			ReadI32FromIntel(&NpxFEA, ((IU8 *)memPtr+4+frstor_offset));
			NpxFEA &= 0xffff;
			ReadI32FromIntel(&result, ((IU8 *)memPtr+0+frstor_offset));
			NpxFEA |= ((result & 0x0ffff000) << 4);
		} else {
			ReadI16FromIntel(&result, ((IU8 *)memPtr+12+frstor_offset));
			FLDCW((VOID *)&result);
			ReadI16FromIntel(&result, ((IU8 *)memPtr+10+frstor_offset));
			SetIntelStatusWord(result);
			ReadI16FromIntel(&result, ((IU8 *)memPtr+8+frstor_offset));
			SetIntelTagword(result);
			ReadI16FromIntel(&NpxFIP, ((IU8 *)memPtr+6+frstor_offset));
			ReadI16FromIntel(&result, ((IU8 *)memPtr+4+frstor_offset));
			NpxFIP |= ((result & 0xf000) << 4);
			ReadI16FromIntel(&NpxFOP, ((IU8 *)memPtr+4+frstor_offset));
			NpxFOP &= 0x7ff;
			ReadI16FromIntel(&NpxFEA, ((IU8 *)memPtr+2+frstor_offset));
			ReadI16FromIntel(&result, ((IU8 *)memPtr+0+frstor_offset));
			NpxFEA |= (IU32)((result & 0xf000) << 4);
		}
	}
}



/*(
Name		: FMUL
Function	: Multiply two numbers together
Operation	: Dest <- Src1 * Src2
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined
Exceptions	: P, U, O, D, I, IS
Valid range	: Any
Notes		:
)*/


GLOBAL VOID FMUL IFN3(IU16, destIndex, IU16, src1Index, VOID *, src2)
{
	IU16 src2Index;

	LoadValue(src2, &src2Index);
	if (POPST) {
		DoAPop=TRUE;
	}
	GenericMultiply(destIndex, src1Index, src2Index);
	if (POPST) {
		if (DoAPop) {
			PopStack();
		}
	}
}



LOCAL VOID GenericMultiply IFN3(IU16, destIndex, IU16, src1Index, IU16, src2Index)
{
	FPSTACKENTRY *src1_addr;
	FPSTACKENTRY *src2_addr;

	src1_addr = StackEntryByIndex(src1Index);
	src2_addr = StackEntryByIndex(src2Index);

	/* Clear C1 */
	FlagC1(0);
	TestUneval(src1_addr);
	TestUneval(src2_addr);
	tag_or = (src1_addr->tagvalue | src2_addr->tagvalue);
	/* If the only tagword bits set are negative or denormal then just proceed */
	if ((tag_or & ~TAG_NEGATIVE_MASK) == 0)  {
		HostClearExceptions();
		FPRes = src1_addr->fpvalue * src2_addr->fpvalue;
		/* Reuse one of the above to calculate the destination */
		src1_addr = StackEntryByIndex(destIndex);
		PostCheckOUP();
		/* Value could be anything */
		CalcTagword(src1_addr);
	} else {
		/* Some funny bit was set. Check for the possibilities */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0) {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				src1_addr = StackEntryByIndex(destIndex);
				SignalStackUnderflow(src1_addr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					src1_addr = StackEntryByIndex(destIndex);
					SignalIndefinite(src1_addr);
				} else {
					/* It must be NaN */
					tag_xor = (src1_addr->tagvalue ^ src2_addr->tagvalue);
					Test2NaN(destIndex, src1_addr, src2_addr);
				}
			}
			return;
		}
		/* Check for the denorm case... */
		if ((tag_or & TAG_DENORMAL_MASK) != 0)  {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				DoAPop=FALSE;	/* Just in case */
				return;
			} else {
				/* Proceed if we've no zeroes or infinities. */
				if ((tag_or & ~(TAG_DENORMAL_MASK | TAG_NEGATIVE_MASK)) == 0) {
					HostClearExceptions();
					FPRes = src1_addr->fpvalue * src2_addr->fpvalue;
					/* Reuse one of the above to calculate the destination */
					src1_addr = StackEntryByIndex(destIndex);
					PostCheckOUP();
					/* Value could be anything */
					CalcTagword(src1_addr);
					return;
				}
			}
		}
		tag_xor = (src1_addr->tagvalue ^ src2_addr->tagvalue);
		/* For zero or infinity operands we will have the result  */
		src2_addr = StackEntryByIndex(destIndex);
		if ((tag_or & TAG_ZERO_MASK) != 0) {
			/* Multiplying zero by infinity yields zero with the xor of the signs */
			if ((tag_or & TAG_INFINITY_MASK) != 0) {
				SignalIndefinite(src2_addr);
			} else {
				/* Zero by anything else is zero with sign equal */
				/* to the xor of the signs of the two sources. */
				src2_addr->tagvalue = (TAG_ZERO_MASK | (tag_xor & TAG_NEGATIVE_MASK));
			}
			return;
		}
		/* The only funny bit left is infinity. The result is going */
		/* to be infinity with sign equal to the xor of the signs of */
		/* the sources. */
		src2_addr->tagvalue = TAG_INFINITY_MASK | (tag_xor & TAG_NEGATIVE_MASK);
	}
}



/* The FNOP operation doesn't do anything, it just does the normal
checks for exceptions. */


GLOBAL VOID FNOP IFN0()
{
}


/* FPATAN: This generator returns the value ARCTAN(ST(1)/ST) to ST(1)
then pops the stack. Its response to zeros and infinities is rather
unusual...
+-0 / +X = 0 with sign of original zero
+-0 / -X = pi with sign of original zero
+-X /+-0 = pi/2 with sign of original X
+-0 / +0 = 0 with sign of original zero
+-0 / -0 = pi with sign of original zero
+inf / +-0 = +pi/2
-inf / +-0 = -pi/2
+-0 / +inf = 0 with sign of original zero
+-0 / -inf = pi with sign of original zero
+-inf / +-X = pi/2 with sign of original infinity
+-Y / +inf = 0 with sign of original Y
+-Y / -inf = pi with sign of original Y
+-inf / +inf = pi/4 with sign of original inf
+-inf / -inf = 3*pi/4 with sign of original inf
Otherwise, we just take the two operands from the stack and call the
appropriate EDL to do the instruction.
The use of an invalid operand with masked exception set causes
the pop to go off, cruds up the contents of the stack and doesn't set
the invalid exception, although if the invalid is infinity or NaN,
overflow and precision exceptions are also generated, while if it is
a denorm, underflow and precision exceptions are generated.
With unmasked exceptions, exactly the same chain of events occurs.
UNDER ALL CIRCUMSTANCES, THE STACK GETS POPPED.
*/


GLOBAL VOID FPATAN IFN0()
{
	FPSTACKENTRY *st1_addr;

	st1_addr = StackEntryByIndex(1);
	/* Clear C1 */
	FlagC1(0);
	/* If only the negative bit is set, just proceed.... */
	TestUneval(TOSPtr);
	TestUneval(st1_addr);
	tag_or = (TOSPtr->tagvalue | st1_addr->tagvalue);
	if ((tag_or & ~TAG_NEGATIVE_MASK) == 0)  {
		HostClearExceptions();
		FPRes = atan2(st1_addr->fpvalue, TOSPtr->fpvalue);
		PostCheckOUP();
		/* The retrun value has to be in the range -pi to +pi */
		CalcTagword(st1_addr);
	} else {
		/* Some funny bit set.... */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0) {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				SignalStackUnderflow(st1_addr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					SignalIndefinite(st1_addr);
				} else {
					/* It must be a NaN. */
					tag_xor = (TOSPtr->tagvalue ^ st1_addr->tagvalue);
					Test2NaN(0, TOSPtr, st1_addr);
				}
			}
			PopStack();
			return;
		}
		if ((tag_or & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				PopStack();
				return;
			} else {
				/* Proceed if we've no zeroes or infinities. */
				if ((tag_or & ~(TAG_DENORMAL_MASK | TAG_NEGATIVE_MASK)) == 0) {
					HostClearExceptions();
					FPRes = atan2(st1_addr->fpvalue, TOSPtr->fpvalue);
					PostCheckOUP();
					/* The return value is -pi to +pi */
					CalcTagword(st1_addr);
					PopStack();
					return;
				}
			}
		}
		/* It must have been a zero or an infinity. As can be seen */
		/* from the table above, there is a complicated interaction */
		/* between the result for each type and its option. */
		/* Let's simplify it by use of a little table. */
		/*       ST               ST(1)            Result */
		/*   Z    I    S     Z    I      S     */
		/*   0    0    0     0    1      0         pi/2 */
		/*   0    0    0     0    1      1         -pi/2 */
		/*   0    0    0     1    0      0         +0 */
		/*   0    0    0     1    0      1         -0 */
		/*   0    1    0     0    1      0         pi/4 */
		/*   0    1    0     0    1      1         3*pi/4 */
		/*   0    1    0     1    0      0         pi/2 */
		/*   0    1    0     1    0      1         pi/2 */
		/*   0    1    1     0    1      0         -pi/4 */
		/*   0    1    1     0    1      1         -3*pi/4 */
		/*   0    1    1     1    0      0         -pi/2 */
		/*   0    1    1     1    0      1         -pi/2 */
		/*   1    0    0     0    1      0         +0 */
		/*   1    0    0     0    1      1         pi */
		/*   1    0    0     1    0      0         +0 */
		/*   1    0    0     1    0      1         pi */
		/*   1    0    1     0    1      0         -0 */
		/*   1    0    1     0    1      1         -pi */
		/*   1    0    1     1    0      0         -0 */
		/*   1    0    1     1    0      1         -pi */
		/* */
		/* All other combinations are invalid, as they would involve */
		/* a tagword having both infinity and zero bits set. */
		tag_xor = (st1_addr->tagvalue & 7);
		tag_xor <<= 3;
		tag_xor |= (TOSPtr->tagvalue & 7);
		CopyFP(st1_addr, FpatanTable[tag_xor]);
	}
	/* No matter what has happened... We ALWAYS pop on FPATAN!!! */
	PopStack();
}



/* FPREM: This is the same function as implemented on the 80287. It is
NOT the same as the IEEE required REM function, this is now supplied as
FPREM1. FPREM predates the final draft of IEEE 754 and is maintained for
the purpose of backward compatibility.
*/


GLOBAL VOID FPREM IFN0()
{
	IS16 exp_diff;
	IU8 little_rem;
	FPU_I64 remainder;
	FPH fprem_val;
	FPSTACKENTRY *st1_addr;

	st1_addr = StackEntryByIndex(1);
	TestUneval(TOSPtr);
	TestUneval(st1_addr);
	tag_or = (TOSPtr->tagvalue | st1_addr->tagvalue);
	/* First, check if the values are real. If so, we can proceed. */
	if ((tag_or & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0)  {
		/* First, check for the denormal possibility... */
		if ((tag_or & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				return;
			}
		}
		/* Make both values positive */
		((FPHOST *)&(TOSPtr->fpvalue))->hiword.sign = 0;
		((FPHOST *)&(st1_addr->fpvalue))->hiword.sign = 0;

		/* Find the difference in exponents... */
		exp_diff = ((FPHOST *)&(TOSPtr->fpvalue))->hiword.exp - ((FPHOST *)&(st1_addr->fpvalue))->hiword.exp;
		/* If it's more than 63, we can't do it at once... */
		if (exp_diff >= 64) {
			((FPHOST *) &fprem_val) -> hiword.sign = 0;
			((FPHOST *) &fprem_val) -> hiword.mant_hi = 0;
			((FPHOST *) &fprem_val) -> mant_lo = 0;
			((FPHOST *) &fprem_val) -> hiword.exp = (exp_diff - 50) + HOST_BIAS;
			FlagC2(1);	/* This will be incomplete reduction */
		} else {
			FlagC2(0); /* This will be complete reduction */
		}
		HostClearExceptions();
        	tag_xor = (NpxControl & 0xc00);
		NpxControl &= 0xf3ff;
		NpxControl |= ROUND_ZERO;
		HostSetRoundToZero();
		/* Unfortunately, because the function isn't the strict */
		/* IEEE compliant style, if we use an IEEE compliant FREM */
		/* operation, as like as not we'd get the wrong answer. So */
		/* we perform the operation by doing the steps given in the */
		/* page in the instruction set. */
		FPRes = TOSPtr->fpvalue / st1_addr->fpvalue;
		if ((NpxStatus & 0x0400) != 0) {	/* The incomplete reduction case */
			FPRes = FPRes / fprem_val;
		}
		FPRes = npx_rint(FPRes);
		/* Calculate the remainder */
		if ((NpxStatus & 0x0400) == 0)  {
			CVTFPHI64(&remainder, &FPRes);
			CPY64BIT8BIT(&remainder, &little_rem);
		}
        	switch (tag_xor) {
                	case ROUND_NEAREST      : HostSetRoundToNearest();
                                       		  break;
                	case ROUND_NEG_INFINITY : HostSetRoundDown();
                                       		  break;
                	case ROUND_POS_INFINITY : HostSetRoundUp();
                                       		  break;
                	case ROUND_ZERO         : HostSetRoundToZero();
                                       		  break;
        	}
		NpxControl &= 0xf3ff;
		NpxControl |= tag_xor;
		FPRes *= st1_addr->fpvalue;
		if ((NpxStatus & 0x0400) != 0) {	/* The incomplete reduction case */
			FPRes *= fprem_val;
			FPRes = TOSPtr->fpvalue - FPRes;
		} else {		/* Complete reduction */
			FPRes = TOSPtr->fpvalue - FPRes;
			FlagC0((little_rem&4)?1:0);
			FlagC3((little_rem&2)?1:0);
			FlagC1((little_rem&1));
		}
		/* Check for an underflow response */
		if (HostGetUnderflowException() != 0) {
			NpxStatus |= SW_UE_MASK;
			if ((NpxControl & CW_UM_MASK) == 0) {
				AdjustUnderflowResponse();
				NpxStatus |= SW_ES_MASK;
				NpxException = TRUE;
			}
		}
		/* But the remainder must have the sign of the original ST! */
		if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			((FPHOST *)&(FPRes))->hiword.sign = 1;
		} else {
			((FPHOST *)&(FPRes))->hiword.sign = 0;
		}
		/* And restore st1 sign bit if required */
		if ((st1_addr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			((FPHOST *)&(st1_addr->fpvalue))->hiword.sign = 1;
		}
		CalcTagword(TOSPtr);
	} else {
		/* We had a funny thing */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0) {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				SignalStackUnderflow(TOSPtr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					SignalIndefinite(TOSPtr);
				} else {
					/* It must be a NaN. */
					tag_xor = (TOSPtr->tagvalue ^ st1_addr->tagvalue);
					Test2NaN(0, TOSPtr, st1_addr);
				}
			}
			return;
		}
		/* The logical way to arrange zeroes and infinities is zero first. */
		if ((tag_or & TAG_ZERO_MASK) != 0)  {
			/* A zero in ST(1) is ALWAYS invalid... */
			if ((st1_addr->tagvalue & TAG_ZERO_MASK) != 0) {
				SignalIndefinite(TOSPtr);
			}
			/* The zero must be in ST, the result is what is there... */
			FlagC0(0);
			FlagC1(0);
			FlagC2(0);
			FlagC3(0);
			return;
		}
		/* OK, it HAS to be infinity */
		/* An infinity at ST is ALWAYS invalid... */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			SignalIndefinite(TOSPtr);
		}
		/* An infinity at ST(1) leaves ST untouched */
		FlagC0(0);
		FlagC1(0);
		FlagC2(0);
		FlagC3(0);
	}
}




/* FPREM1: This is the IEEE required REM function, this is now supplied as
FPREM1. FPREM predates the final draft of IEEE 754 and is maintained for
the purpose of backward compatibility.
*/


GLOBAL VOID FPREM1 IFN0()
{
	IS16 exp_diff;
	IU8 little_rem;
	FPU_I64 remainder;
	FPH fprem_val;
	FPSTACKENTRY *st1_addr;

	st1_addr = StackEntryByIndex(1);
	TestUneval(TOSPtr);
	TestUneval(st1_addr);
	tag_or = (TOSPtr->tagvalue | st1_addr->tagvalue);
	/* First, check if the values are real. If so, we can proceed. */
	if ((tag_or & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0)  {
		/* First, check for the denormal possibility... */
		if ((tag_or & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				return;
			}
		}
		/* Make both values positive */
		((FPHOST *)&(TOSPtr->fpvalue))->hiword.sign = 0;
		((FPHOST *)&(st1_addr->fpvalue))->hiword.sign = 0;

		/* Find the difference in exponents... */
		exp_diff = ((FPHOST *)&(TOSPtr->fpvalue))->hiword.exp - ((FPHOST *)&(st1_addr->fpvalue))->hiword.exp;
		/* If it's more than 63, we can't do it at once... */
		if (exp_diff >= 64) {
			((FPHOST *) &fprem_val) -> hiword.sign = 0;
			((FPHOST *) &fprem_val) -> hiword.mant_hi = 0;
			((FPHOST *) &fprem_val) -> mant_lo = 0;
			((FPHOST *) &fprem_val) -> hiword.exp = (exp_diff - 50) + HOST_BIAS;
			FlagC2(1);	/* This will be incomplete reduction */
		} else {
			FlagC2(0); /* This will be complete reduction */
		}
		HostClearExceptions();
		/* Note that this is the only difference between FPREM and
		   FPREM1. For the incomplete reduction case we use "round
		   to nearest" rather than "round to zero".
		*/
        	tag_xor = (NpxControl & 0xc00);
		NpxControl &= 0xf3ff;
		if ((NpxStatus & 0x0400) == 0)  {
			HostSetRoundToZero();
			NpxControl |= ROUND_ZERO;
		} else {
			HostSetRoundToNearest();
			NpxControl |= ROUND_NEAREST;
		}
		FPRes = TOSPtr->fpvalue / st1_addr->fpvalue;
		if ((NpxStatus & 0x0400) != 0) {	/* The incomplete reduction case */
			FPRes = FPRes / fprem_val;
		}
		FPRes = npx_rint(FPRes);
		/* Calculate the remainder */
		if ((NpxStatus & 0x0400) == 0)  {
			CVTFPHI64(&remainder, &FPRes);
			CPY64BIT8BIT(&remainder, &little_rem);
		}
        	switch (tag_xor) {
                	case ROUND_NEAREST      : HostSetRoundToNearest();
                                       		  break;
                	case ROUND_NEG_INFINITY : HostSetRoundDown();
                                       		  break;
                	case ROUND_POS_INFINITY : HostSetRoundUp();
                                       		  break;
                	case ROUND_ZERO         : HostSetRoundToZero();
                                       		  break;
        	}
		NpxControl &= 0xf3ff;
		NpxControl |= tag_xor;
		FPRes = st1_addr->fpvalue * FPRes;
		if ((NpxStatus & 0x0400) != 0) {	/* The incomplete reduction case */
			FPRes = FPRes * fprem_val;
			FPRes = TOSPtr->fpvalue - FPRes;
		} else {		/* Complete reduction */
			FPRes = TOSPtr->fpvalue - FPRes;
			FlagC0((little_rem&4)?1:0);
			FlagC3((little_rem&2)?1:0);
			FlagC1(little_rem&1);
		}
		/* Check for an underflow response */
		if (HostGetUnderflowException() != 0) {
			NpxStatus |= SW_UE_MASK;
			if ((NpxControl & CW_UM_MASK) == 0) {
				AdjustUnderflowResponse();
				NpxStatus |= SW_ES_MASK;
				NpxException = TRUE;
			}
		}
		/* But the remainder must have the sign of the original ST! */
		if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			((FPHOST *)&(FPRes))->hiword.sign = 1;
		} else {
			((FPHOST *)&(FPRes))->hiword.sign = 0;
		}
		/* And restore st1 sign bit if required */
		if ((st1_addr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			((FPHOST *)&(st1_addr->fpvalue))->hiword.sign = 1;
		}
		CalcTagword(TOSPtr);
	} else {
		/* We had a funny thing */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0) {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				SignalStackUnderflow(TOSPtr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					SignalIndefinite(TOSPtr);
				} else {
					/* It must be a NaN. */
					tag_xor = (TOSPtr->tagvalue ^ st1_addr->tagvalue);
					Test2NaN(0, TOSPtr, st1_addr);
				}
			}
			return;
		}
		/* The logical way to arrange zeroes and infinities is zero first. */
		if ((tag_or & TAG_ZERO_MASK) != 0)  {
			/* A zero in ST(1) is ALWAYS invalid... */
			if ((st1_addr->tagvalue & TAG_ZERO_MASK) != 0) {
				SignalIndefinite(TOSPtr);
			}
			/* The zero must be in ST, the result is what is there... */
			FlagC0(0);
			FlagC1(0);
			FlagC2(0);
			FlagC3(0);
			return;
		}
		/* OK, it HAS to be infinity */
		/* An infinity at ST is ALWAYS invalid... */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			SignalIndefinite(TOSPtr);
		}
		/* An infinity at ST(1) leaves ST untouched */
		FlagC0(0);
		FlagC1(0);
		FlagC2(0);
		FlagC3(0);
	}
}



/*(
 * Name		: FPTAN
 * Operation	: Compute the value of TAN(ST)
 * Flags 	: C1 as per table 15-1, others undefined.
 * Exceptions	: P, U, D, I, IS
 * Valid range	: |ST| < 2**63
 * Notes	: This function has been substantially overhauled
		  since the 80287. It now has a much wider range
		  (it previously had to be 0<ST<(PI/4). In addition,
		  the return value is now really the tan of ST, with
		  a 1 pushed above it on the stack to maintain
		  compatibility with the 8087/80287. Previously the
		  result was a ratio of two values, neither of which
		  could be guaranteed.
)*/


GLOBAL VOID FPTAN IFN0()
{
	FPSTACKENTRY *st1_addr;

	/* Clear C1 */
	FlagC1(0);
	/* Set C2 to zero */
	FlagC2(0);
	st1_addr = StackEntryByIndex(7);
	/* Make sure that the stack element is free */
	if ((st1_addr->tagvalue & TAG_EMPTY_MASK) == 0) {
		WriteIndefinite(TOSPtr);
		TOSPtr = st1_addr;
		SignalStackOverflow(TOSPtr);
		return;
	}
	TestUneval(TOSPtr);
	/* Check if a real value...We won't bother with limit checking */
	if ((TOSPtr->tagvalue & ~TAG_NEGATIVE_MASK) == 0)  {
		HostClearExceptions();
		/* We can just write the value straight out */
		FPRes = tan(TOSPtr->fpvalue);
		PostCheckOUP();
		/* The return value could be absolutely anything */
		CalcTagword(TOSPtr);
		TOSPtr = st1_addr;
		CopyFP(TOSPtr, npx_one);
	} else {
		/* Some funny bit was set. Check for the possibilities */
		/* We begin with the most obvious cases... */
		/* Response to zero is to return zero with same sign */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0)  {
			TOSPtr = st1_addr;
			CopyFP(TOSPtr, npx_one);
			return;	/* The required result! */
		}
		/* We do denorm checking and bit setting ourselves because this  */
		/* reduces the overhead if the thing is masked. */
		if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			} else {
				HostClearExceptions();
				FPRes = tan(TOSPtr->fpvalue);
				PostCheckOUP();
				/* The return value could be anything */
				CalcTagword(TOSPtr);
				TOSPtr = st1_addr;
				CopyFP(TOSPtr, npx_one);
			}
			return;
		}
		/* If the value is outside the acceptable range (including */
		/* infinity) then we set the C2 flag and leave everything */
		/* unchanged. */
		/* Sensible enough really, I suppose */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			FlagC2(1);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			SignalStackUnderflow(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_SNAN_MASK) != 0) {
			MakeNaNQuiet(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_UNSUPPORTED_MASK) != 0) {
			SignalIndefinite(TOSPtr);
			return;
		}
	}
}



/*(
 * Name		: FRNDINT
 * Operation	: ST <- rounded ST
 * Flags 	: C1 as per table 15-1, others undefined.
 * Exceptions	: P, U, D, I, IS
 * Valid range	: All
 * Notes	: On the 80287, a precision exception would be
		  raised if the operand wasn't an integer.
		  I begin by ASSUMING that on the 486 the response
		  is IEEE compliant so no OUP exceptions.
)*/


GLOBAL VOID FRNDINT IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & ~TAG_NEGATIVE_MASK) == 0)  {
		HostClearExceptions();
		/* We can just write the value straight out */
		FPRes = npx_rint(TOSPtr->fpvalue);
		if (FPRes != TOSPtr->fpvalue) {
			SetPrecisionBit();
			/* If the rounding mode is "round to nearest" and we've
			rounded up then we'll set C1 */
			if (npxRounding == ROUND_NEAREST) {
				if (TOSPtr->fpvalue < FPRes) {
					FlagC1(1);
				}
			}
			if ((NpxControl & CW_PM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				return;
			}
		}
		/* It was a real before, it still must be one now. It could */
		/* be zero possibly. */
		CalcTagword(TOSPtr);
	} else {
		/* Lets do the most probable cases first... */
		/* If it's a zero or infinity, we do nothing. */
		if ((TOSPtr->tagvalue & (TAG_ZERO_MASK | TAG_INFINITY_MASK)) == 0) {
			/* Lets check for a denormal */
			if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
				SetPrecisionBit();
				NpxStatus |= SW_DE_MASK;
				if ((NpxControl & CW_DM_MASK) == 0) {
					NpxStatus |= SW_ES_MASK;
					DoNpxException();
				} else {
					/* The result of rounding a denorm is dependent on */
					/* its sign and the prevailing rounding mode */
					switch (npxRounding) {
						case ROUND_ZERO	:
						case ROUND_NEAREST 	:
							TOSPtr->tagvalue &= TAG_NEGATIVE_MASK;
							TOSPtr->tagvalue |= TAG_ZERO_MASK;

				   	  	break;
						case ROUND_NEG_INFINITY	:
							if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
								memset((char*)TOSPtr,0,sizeof(FPSTACKENTRY));
								TOSPtr->fpvalue = -1.0;
								TOSPtr->tagvalue = TAG_NEGATIVE_MASK;
							} else {
								TOSPtr->tagvalue &= TAG_NEGATIVE_MASK;
								TOSPtr->tagvalue |= TAG_ZERO_MASK;
							}
					  	break;
						case ROUND_POS_INFINITY	:
							if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) == 0) {
								memset((char*)TOSPtr,0,sizeof(FPSTACKENTRY));
								TOSPtr->fpvalue = 1.0;
								TOSPtr->tagvalue = 0;
							} else {
								TOSPtr->tagvalue &= TAG_NEGATIVE_MASK;
								TOSPtr->tagvalue |= TAG_ZERO_MASK;
							}
					  	break;
					}
				}
				return;
			}
			/* It was one of the really wacky bits... */
			if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
				SignalStackUnderflow(TOSPtr);
				return;
			}
			if ((TOSPtr->tagvalue & TAG_SNAN_MASK) != 0) {
				MakeNaNQuiet(TOSPtr);
				return;
			}
			if ((TOSPtr->tagvalue & TAG_UNSUPPORTED_MASK) != 0) {
				SignalIndefinite(TOSPtr);
				return;
			}
		}
	}
}




/*(
Name		: FSTCW
Function	: Write the FPU control word to memory
Operation	: DEST <- Cw
Flags		: All undefined.
Exceptions	: None - but unmasking previously masked exceptions will
		  cause the unmasked exception to be triggered if the
		  matching bit is set in the status word.
Valid range	: N/A
*/


GLOBAL VOID FSTCW IFN1(VOID *, memPtr)
{
	if (NpxDisabled)
	{
		/* UIF has told us to pretend we do not have an NPX */
		*(IU32 *)memPtr = (IU16)0xFFFF;
	}
	else
	{
		*(IU32 *)memPtr = (IU16)NpxControl;
	}
}



/*(
Name		: FRSTOR
Function	: Reload the FPU state from memory.
Operation	: FPU state <- SRC
Flags		: As loaded.
Exceptions	: None - but unmasking previously masked exceptions will
		  cause the unmasked exception to be triggered if the
		  matching bit is set in the status word.
Valid range	: N/A
*/


GLOBAL VOID FRSTOR IFN1(VOID *, memPtr)
{
	IU8 *FPPtr;
	IU32 i;
	/* First. load the control, status, tagword regs. etc. */
	OpFpuRestoreFpuState(memPtr, 80);
	FPPtr = (IU8 *)((IU8 *)memPtr+70);
	FPtype = M80R;
	for ( i=8; i--; )
	{
		if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) == 0) {
			/* We have to do a bit of fiddling to make FLD happy */
			TOSPtr->tagvalue = TAG_EMPTY_MASK;
			TOSPtr = StackEntryByIndex(1);
			FLD(FPPtr);
		}
		TOSPtr = StackEntryByIndex(1);
		FPPtr -= 10;
	}
	/* Finally, check to see if any previously unmasked exceptions  */
	/* are now needed to go off. Do this by anding the "triggered" bits in */
	/* NpxStatus with the one's complement of the "masked" bits in NpxControl. */
	if (((NpxStatus & 0x3f) & (~(NpxControl & 0x3f))) != 0) {
		NpxStatus |= SW_ES_MASK;
		DoNpxException();
	}
}



/*(
Name		: FSAVE
Function	: Write the FPU state to memory.
Operation	: DEST <- FPU STATE
Flags		: All cleared.
Exceptions	: None.
Valid range	: N/A
*/

GLOBAL VOID FSAVE IFN1(VOID *, memPtr)
{
	IU8 *FPPtr;
	IU32 i;

	OpFpuStoreFpuState(memPtr, 80);
	FPPtr = (IU8 *)((IU8 *)memPtr+70);
	/* Now store out the eight values... */
	FPtype = M80R;
	FST(FPPtr);
	for ( i=7; i--; )
	{
		FPPtr -= 10;	/* Go back to the next entry */
		TOSPtr = StackEntryByIndex(1);
		FST(FPPtr);
	}
	/* Finally, reset the FPU... */
	FINIT();
}



/*(
Name		: FSCALE
Function	: Scale up ST by a factor involving ST(1)
Operation	: ST <- ST * 2**ST(1)
Flags		: C1 as per table 15-1. Others undefined.
Exceptions	: P, U, O, D, I, IS
Valid range	: Any
)*/


GLOBAL VOID FSCALE IFN0()
{
	FPSTACKENTRY *st1_addr;

	st1_addr = StackEntryByIndex(1);
	/* Clear C1 */
	FlagC1(0);
	TestUneval(TOSPtr);
	TestUneval(st1_addr);
	tag_or = (TOSPtr->tagvalue | st1_addr->tagvalue);
	/* First, check if the values are real. If so, we can proceed. */
	if ((tag_or & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0)  {
		/* First, check for the denormal case. */
		if ((tag_or & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				return;
			}
		}
		/* OK. ST(1) has to be rounded to an integer. */
		/* We want a 'chop' function */
		if (st1_addr->fpvalue > 0.0) {
			FPRes = floor(st1_addr->fpvalue);
		} else {
			FPRes = ceil(st1_addr->fpvalue);
		}
		HostClearExceptions();
		FPRes = pow(2.0, FPRes);
		FPRes = TOSPtr->fpvalue * FPRes;
		PostCheckOUP();
		/* Return value could be anything */
		CalcTagword(TOSPtr);
	} else {
		/* A funny thing happened on the way to the answer */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0) {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				SignalStackUnderflow(TOSPtr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					SignalIndefinite(TOSPtr);
				} else {
					/* It must be a NaN. */
					tag_xor = (TOSPtr->tagvalue ^ st1_addr->tagvalue);
					Test2NaN(0, TOSPtr, st1_addr);
				}
			}
			return;
		}
		/* The rules for scaling combinations of zeroes, reals and infinities, both */
		/* positive and negative, are so complex that I don't intend to do lots of */
		/* logic to figure them out. Basically, there are six options: */
		/* 1. Leave the TOS alone */
		/* 2. +Infinity */
		/* 3. +0 */
		/* 4. -Infinity */
		/* 5. -0 */
		/* 6. Raise Invalid operation exception */
		/* */
		/*      TOS        ST(1)       RESULT */
		/*   I   S   Z   I   S   Z */
		/*   0   0   0   0   0   1     1 */
		/*   0   0   0   0   1   1     1 */
		/*   0   0   0   1   0   0     2 */
		/*   0   0   0   1   1   0     3 */
		/*   0   0   1   0   0   0     1 */
		/*   0   0   1   0   0   1     1 */
		/*   0   0   1   0   1   0     1 */
		/*   0   0   1   0   1   1     1 */
		/*   0   0   1   1   0   0     6 */
		/*   0   0   1   1   1   0     1 */
		/*   0   1   0   0   0   1     1 */
		/*   0   1   0   0   1   1     1 */
		/*   0   1   0   1   0   0     4 */
		/*   0   1   0   1   1   0     5 */
		/*   0   1   1   0   0   0     1 */
		/*   0   1   1   0   0   1     1 */
		/*   0   1   1   0   1   0     1 */
		/*   0   1   1   0   1   1     1 */
		/*   0   1   1   1   0   0     6 */
		/*   0   1   1   1   1   0     1 */
		/*   1   0   0   0   0   0     1 */
		/*   1   0   0   0   0   1     1 */
		/*   1   0   0   0   1   0     1 */
		/*   1   0   0   0   1   1     1 */
		/*   1   0   0   1   0   0     6 */
		/*   1   1   0   0   0   0     1 */
		/*   1   1   0   0   0   1     1 */
		/*   1   1   0   0   1   0     1 */
		/*   1   1   0   0   1   1     1 */
		/*   1   1   0   1   0   0     1 */
		/*   1   1   0   1   1   0     6 */
		/* */
		/* All other combinations are impossible. This can be done as a look up */
		/* table with an enumerated type. */
		tag_or = (TOSPtr->tagvalue & 7);
		tag_or <<= 3;
		tag_or |= (st1_addr->tagvalue & 7);
		tag_or = FscaleTable[tag_or];
		if ((tag_or & TAG_FSCALE_MASK) != 0) {
			if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
				SignalIndefinite(TOSPtr);
			}
		} else {
			TOSPtr->tagvalue = tag_or;
		}
	}
}



/*(
Name		: FSIN
Function	: Calculate the sine of ST
Operation	: ST <- SINE(ST)
Flags		: C1, C2 as per table 15-2. C0 and C3 undefined.
Exceptions	: P. U, D, I, IS
Valid range	: |ST| < 2**63.
)*/


GLOBAL VOID FSIN IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	/* Clear C2 */
	FlagC2(0);
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & ~TAG_NEGATIVE_MASK) == 0)  {
		HostClearExceptions();
		/* We can just write the value straight out */
		FPRes = sin(TOSPtr->fpvalue);
		PostCheckOUP();
		/* Return value must be in the range -1 to +1 */
		CalcTagword(TOSPtr);
	} else {
		/* Lets do the most probable cases first... */
		/* A zero returns exactly the same thing */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0)  {
			return;
		}
		/* Lets check for a denormal */
		if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			} else {
				HostClearExceptions();
				FPRes = sin(TOSPtr->fpvalue);
				PostCheckOUP();
				/* Return value must be in the range -1 to +1 */
				CalcTagword(TOSPtr);
			}
			return;
		}
		/* Or it could possibly be infinity... */
		/* For this, the C2 bit is set and the result remains */
		/* unchanged. */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			FlagC2(1);
			return;
		}
		/* It was one of the really wacky bits... */
		if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			SignalStackUnderflow(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_SNAN_MASK) != 0) {
			MakeNaNQuiet(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_UNSUPPORTED_MASK) != 0) {
			SignalIndefinite(TOSPtr);
			return;
		}
	}
}



/*(
Name		: FSINCOS
Function	: Calculate the sine and cosine of ST
Operation	: TEMP <-COSINE(ST); ST <- SINE(ST); PUSH; ST <- TEMP
Flags		: C1, C2 as per table 15-2. C0 and C3 undefined.
Exceptions	: P. U, D, I, IS
Valid range	: |ST| < 2**63.
)*/


GLOBAL VOID FSINCOS IFN0()
{
	FPSTACKENTRY *st1_addr;

	/* Clear C1 */
	FlagC1(0);
	/* Clear C2 */
	FlagC2(0);
	st1_addr = StackEntryByIndex(7);
	/* First, check that this one is empty. */
	if ((st1_addr->tagvalue & TAG_EMPTY_MASK) == 0) {
		WriteIndefinite(TOSPtr);
		TOSPtr = st1_addr;
		SignalStackOverflow(TOSPtr);
		return;
	}
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & ~TAG_NEGATIVE_MASK) == 0)  {
		HostClearExceptions();
		/* We can just write the value straight out */
		FPRes = cos(TOSPtr->fpvalue);
		/* The range for a cosine is -1 through to +1. */
		CalcTagword(st1_addr);
		/* I can write out the SINE myself, since as we are */
		/* writing to the stack, even an unmasked U or P */
		/* cannot stop delivery of the result. */
		/* The range for a sine is -1 through to +1. */
		FPRes = sin(TOSPtr->fpvalue);
		CalcTagword(TOSPtr);
		TOSPtr = st1_addr;
		PostCheckOUP();
		return;
	} else {
		/* Lets do the most probable cases first... */
		/* A zero returns exactly the same thing */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0)  {
			/* The sine of zero is zero so just push the stack */
			TOSPtr = st1_addr;
			/* Now write out plus one */
			CopyFP(TOSPtr, npx_one);
			return;
		}
		/* Lets check for a denormal */
		if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			} else {
				HostClearExceptions();
				/* We can just write the value straight out */
				FPRes = cos(TOSPtr->fpvalue);
				/* The range for a cos is -1 through to +1 */
				CalcTagword(st1_addr);
				/* I can write out the SINE myself, since as we are */
				/* writing to the stack, even an unmasked U or P */
				/* cannot stop delivery of the result. */
				/* The range for a sine is -1 through to +1 */
				FPRes = sin(TOSPtr->fpvalue);
				CalcTagword(TOSPtr);
				TOSPtr = st1_addr;
				PostCheckOUP();
			}
			return;
		}
		/* Or it could possibly be infinity... */
		/* For this, the C2 bit is set and the result remains */
		/* unchanged. */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			FlagC2(1);
			return;
		}
		/* It was one of the really wacky bits... */
		if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			SignalStackUnderflow(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_SNAN_MASK) != 0) {
			MakeNaNQuiet(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_UNSUPPORTED_MASK) != 0) {
			SignalIndefinite(TOSPtr);
			return;
		}
	}
}



/*(
Name		: FSQRT
Function	: Calculate the square root of ST
Operation	: ST <- SQRT(ST)
Flags		: C1 as per table 15-1. Others undefined.
Exceptions	: P. D, I, IS
Valid range	: ST >= -0.0
)*/


GLOBAL VOID FSQRT IFN0()
{

	/* Clear C1 */
	FlagC1(0);
	TestUneval(TOSPtr);
	if (TOSPtr->tagvalue == 0)  {
		HostClearExceptions();
		/* We can just write the value straight out */
		FPRes = sqrt(TOSPtr->fpvalue);
		PostCheckOUP();
		TOSPtr->fpvalue = FPRes;
		/* The tagword can't have changed! */
		return;
	} else {
		/* Lets do the most probable cases first... */
		/* A zero returns exactly the same thing */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0)  {
			return;
		}
		if ((TOSPtr->tagvalue & TAG_NAN_MASK) != 0) {
			if ((TOSPtr->tagvalue & TAG_SNAN_MASK) != 0) {
				MakeNaNQuiet(TOSPtr);
			}
			return;
		}
		/* Having taken care of that case, lets check for negative... */
		if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			SignalIndefinite(TOSPtr);
			return;
		}
		/* Lets check for a denormal */
		if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			} else {
				HostClearExceptions();
				FPRes = sqrt(TOSPtr->fpvalue);
				PostCheckOUP();
				/* It might not be a denorm anymore */
				CalcTagword(TOSPtr);
			}
			return;
		}
		/* Or it could possibly be infinity...This just returns. */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			return;
		}
		/* It was one of the really wacky bits... */
		if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			SignalStackUnderflow(TOSPtr);
			return;
		}
		if ((TOSPtr->tagvalue & TAG_UNSUPPORTED_MASK) != 0) {
			SignalIndefinite(TOSPtr);
			return;
		}
	}
}


/* CheckOUPForIntel: This is a special version of the PostCheckOUP
routine that is designed for use in situations where the result
is to be written to intel memory space. It just looks at the
excpetions bits and sets the appropriate bits, it doesn't write
the value back or anything like that. */


LOCAL VOID CheckOUPForIntel IFN0()
{
	tag_or=0;	/* Prime tag_or */
	if (HostGetOverflowException() != 0) {
		NpxStatus |= SW_OE_MASK;	/* Set the overflow bit */
		/* For the masked overflow case, the result delivered by */
		/* the host will be correct, provided it is IEEE compliant. */
		if ((NpxControl & CW_OM_MASK) == 0) {
			NpxStatus |= SW_ES_MASK;
			NpxException = TRUE;
			tag_or = 1;
		}
	} else {
		/* Overflow and underflow being mutually exclusive... */
		if (HostGetUnderflowException() != 0) {
			NpxStatus |= SW_UE_MASK;
			if ((NpxControl & CW_UM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				NpxException = TRUE;
				tag_or=1;
			}
		}
	}
	if (HostGetPrecisionException() != 0) {
		SetPrecisionBit();
		if ((NpxControl & CW_PM_MASK) == 0) {
			NpxStatus |= SW_ES_MASK;
			NpxException = TRUE;
			/* An unmasked precision exception cannot prevent
			delivery of the result */
		}
	}
	/* Only call for overflow or underflow */
	if (NpxException && (tag_or == 1)) {
		NpxException = FALSE;
		DoNpxException();
	}
}



/*(
Name		: FST{P}
Function	: Copy ST to the specified location
Operation	: DEST <- ST(0); if FSTP { pop ST FI;
Flags		: C1 as per table 15-1. Others undefined.
Exceptions	: For stack or extended-real, IS.
		  For single or double-real P. U, O, D, I, IS
Valid range	: N/A
)*/


GLOBAL VOID FST IFN1(VOID *, memPtr)
{
	/* Clear C1 */
	FlagC1(0);
	if (POPST) {
		DoAPop=TRUE;
	}
	if ((TOSPtr->tagvalue & UNEVALMASK) != 0) {
		if ((TOSPtr->tagvalue & TAG_BCD_MASK) != 0) {
			ConvertBCD(TOSPtr);
		} else {
			/* Doesn't apply for FPStack or M80R types */
			if ((FPtype == M32R) || (FPtype == M64R))  {
				ConvertR80(TOSPtr);
			}
		}
	}
	if (   ((TOSPtr->tagvalue & TAG_R80_MASK) != 0)
	    || ((TOSPtr->tagvalue & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0)
	    || (FPtype == FPSTACK)) {
		if (FPtype == FPSTACK) {
			/* check for empty here */
			if (TOSPtr->tagvalue & TAG_EMPTY_MASK) {
				NpxStatus |= SW_IE_MASK|SW_SF_MASK;
				if ((NpxControl & CW_IM_MASK) == 0) {
					NpxStatus |= SW_ES_MASK;
					DoNpxException();
					return;
				}
				WriteIndefinite(StackEntryByIndex(*(IU16 *)memPtr));
			} else
				/* The invalid operation doesn't apply to non-empty */
				/* stack locations. We carry on regardless. */
				CopyFP(StackEntryByIndex(*(IU16 *)memPtr), TOSPtr);
		} else {
			if (FPtype == M80R) {
				if ((TOSPtr->tagvalue & TAG_R80_MASK) == 0) {
					CVTFPHR80(TOSPtr);
					WriteFP80ToIntel(memPtr, &FPTemp);
				} else {
					WriteFP80ToIntel(memPtr, TOSPtr);
				}
			} else {
				/* First, check for the denormal case... */
				if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
					NpxStatus |= SW_DE_MASK;
					if ((NpxControl & CW_DM_MASK) == 0) {
						NpxStatus |= SW_ES_MASK;
						DoNpxException();
						return;
					}
				}
				HostClearExceptions();
				/* The result of the conversion should be written to FPTemp. */
				if (FPtype == M32R) {
					*(float *)&(FPTemp.fpvalue) = (float)TOSPtr->fpvalue;
					/* Our host MUST have double precision, so we will have to */
					/* test for problems caused by the conversion... */
					CheckOUPForIntel();
					if (tag_or == 0)  {
						WriteFP32ToIntel(memPtr, &FPTemp);
					}
				}
				if (FPtype == M64R) {
					*(DOUBLE *)&(FPTemp.fpvalue) = (DOUBLE)TOSPtr->fpvalue;
					/* If we are dealing with a 64-bit host, then the J-code for */
					/* the above is nothing at all, and we don't need to do any */
					/* testing, but if the host precision is, say 80-bit, then */
					/* we do! Note that this doesn't use the @if format in order */
					/* to avoid generating different J-code for different hosts... */
					CheckOUPForIntel();
					if (tag_or == 0)  {
						WriteFP64ToIntel(memPtr, &FPTemp);
					}
				}
			}
		}
	} else {
		/* Test for funny values */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0) {
			/* In this case, we'll allow the casting to be done for us! */
			WriteZeroToIntel(memPtr, TOSPtr->tagvalue & TAG_NEGATIVE_MASK);
		} else if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			if ((FPtype == M32R) || (FPtype == M64R))  {
				NpxStatus |= SW_OE_MASK;
				if ((NpxControl & CW_OM_MASK) == 0) {
					NpxStatus |= SW_ES_MASK;
					DoNpxException();
					return;
				}
			}
			WriteInfinityToIntel(memPtr, TOSPtr->tagvalue & TAG_NEGATIVE_MASK);
		} else if ((TOSPtr->tagvalue & TAG_NAN_MASK) != 0) {
			if ((TOSPtr->tagvalue & TAG_SNAN_MASK) != 0) {
				/* Signal invalid for sNaN */
				if (((FPtype == M32R) || (FPtype == M64R)))  {
					NpxStatus |= SW_IE_MASK;
					if ((NpxControl & CW_IM_MASK) == 0) {
						NpxStatus |= SW_ES_MASK;
						DoNpxException();
						return;
					}
				}
			}
			WriteNaNToIntel(memPtr, TOSPtr);
		} else if ( (TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0 ) {
			NpxStatus |= (SW_IE_MASK | SW_SF_MASK);
			FlagC1(0);
			if ((NpxControl & CW_IM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				return;
			}
			WriteIndefiniteToIntel(memPtr);
		} else { /* Must be unsupported. */
			if (FPtype == M80R) {
				/* unsupported: Write back the unresolved string */
				if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
					((FP80 *)&(TOSPtr->fpvalue))->sign_exp.sign = 1;
				} else {
					((FP80 *)&(TOSPtr->fpvalue))->sign_exp.sign = 0;
				}
				WriteFP80ToIntel(memPtr, TOSPtr);
			} else {
				NpxStatus |= SW_IE_MASK;
				if ((NpxControl & CW_IM_MASK) == 0) {
					NpxStatus |= SW_ES_MASK;
					DoNpxException();
					return;
				}
				WriteIndefiniteToIntel(memPtr);
			}
		}
	}
	if (POPST) {
		if (DoAPop == TRUE) {
			PopStack();
		}
	}
	/* Check for the case of an unmasked precision exception */
	if (NpxException) {
		NpxException = FALSE;
		DoNpxException();
	}
}



/*(
Name		: FSTENV
Function	: Store the FPU environment
Operation	: DEST <- FPU environment
Flags		: All undefined.
Exceptions	: None
Valid range	: N/A
*/


GLOBAL VOID FSTENV IFN1(VOID *, memPtr)
{
	/* First. load the control, status, tagword regs. etc. */
	OpFpuStoreFpuState(memPtr,0);
	/* Then set all the exceptions to be masked */
	NpxControl |= 0x0000003f;
}


/*(
Name		: FSTSW
Function	: Write the FPU status word to memory
Operation	: DEST <- SW
Flags		: All undefined.
Exceptions	: None
Valid range	: N/A
*/


GLOBAL VOID FSTSW IFN2(VOID *, memPtr, BOOL, toAX)
{
	GetIntelStatusWord();

	if (NpxDisabled)
	{
		/* UIF has told us to pretend we do not have an NPX */

		if (toAX) {
			*(IU16 *)memPtr = 0xFFFF;
		} else {
			/* Write it out host format */

			*(IU16 *)memPtr = (IU16)NpxStatus;
		}
	} else {
		if (toAX) {
			*(IU16 *)memPtr = (IU16)NpxStatus;
		} else {
			*(IU32 *)memPtr = (IU32)NpxStatus;
		}
	}
}

/*(
Name		: FSUB
Function	: Subtract one number from the other
Operation	: Dest <- Src1 - Src2 or Dest <- Src2 - Src1
Flags		: C1 as per table 15-1. C0, C2 and C3 undefined
Exceptions	: P, U, O, D, I, IS
Valid range	: Any
Notes		: The REVERSE control variable determines which of the
		  two forms of the operation is used. Popping after a
		  successful execution is controlled by POPST.
)*/


GLOBAL VOID FSUB IFN3(IU16, destIndex, IU16, src1Index, VOID *, src2)
{
	IU16 src2Index;

	LoadValue(src2, &src2Index);
	if (POPST) {
		DoAPop=TRUE;
	}
	GenericSubtract(destIndex, REVERSE?src2Index:src1Index, REVERSE?src1Index:src2Index);
	if (POPST) {
		if (DoAPop) {
			PopStack();
		}
	}
}


/*(
Name		: GenericSubtract
Function	: To return dest <- src1-src2
)*/


LOCAL VOID GenericSubtract IFN3(IU16, destIndex, IU16, src1Index, IU16, src2Index)
{
	FPSTACKENTRY *src1_addr;
	FPSTACKENTRY *src2_addr;

	src1_addr = StackEntryByIndex(src1Index);
	src2_addr = StackEntryByIndex(src2Index);

	/* Clear C1 */
	FlagC1(0);
	TestUneval(src1_addr);
	TestUneval(src2_addr);
	tag_or = (src1_addr->tagvalue | src2_addr->tagvalue);
	/* If the only tagword bit set is negative then just proceed */
	if ((tag_or & ~TAG_NEGATIVE_MASK) == 0)  {
		HostClearExceptions();
		FPRes=src1_addr->fpvalue - src2_addr->fpvalue;
		/* Reuse one of the above to calculate the destination */
		src1_addr = StackEntryByIndex(destIndex);
		PostCheckOUP();
		/* Could be anything */
		CalcTagword(src1_addr);
	} else {
		/* Some funny bit was set. Check for the possibilities */
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0)  {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				src1_addr = StackEntryByIndex(destIndex);
				SignalStackUnderflow(src1_addr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					src1_addr = StackEntryByIndex(destIndex);
					SignalIndefinite(src1_addr);
				} else {
					/* Well, I suppose it has to be the NaN case... */
					/* Calculate the xor of the tagwords */
					tag_xor = (src1_addr->tagvalue ^ src2_addr->tagvalue);
					Test2NaN(destIndex, src1_addr, src2_addr);
				}
			}
			return;
		}
		if ((tag_or & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				DoAPop = FALSE;
				return;
			} else {
				if ((tag_or & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0) {
					/* OK to proceed */
					HostClearExceptions();
					FPRes=src1_addr->fpvalue - src2_addr->fpvalue;
					/* Reuse one of the above to calculate the destination */
					src1_addr = StackEntryByIndex(destIndex);
					PostCheckOUP();
					/* Could be anything */
					CalcTagword(src1_addr);
					return;
				}
			}
		}
		tag_xor = (src1_addr->tagvalue ^ src2_addr->tagvalue);
		/* Check for infinity as it has higher precendence than zero. */
		if ((tag_or & TAG_INFINITY_MASK) != 0) {
			if ((tag_xor & TAG_INFINITY_MASK) == 0) {
				/* Have they the same sign? */
				if ((tag_xor & TAG_NEGATIVE_MASK) == 0) {
					/* They are both the same sign infinity. This is invalid. */
					src1_addr = StackEntryByIndex(destIndex);
					SignalIndefinite(src1_addr);
				} else {
					/* If of different sign then src1 is the answer */
					src2_addr = StackEntryByIndex(destIndex);
					src2_addr->tagvalue = src1_addr->tagvalue;
				}
			} else {
				/* Only one is infinity. If src1 in infinity, then the result */
				/* is the same. If src2 is infinity, then the result is an */
				/* infinity of opposite sign. */
				tag_or = src2_addr->tagvalue;
				src2_addr = StackEntryByIndex(destIndex);
				if ((src1_addr->tagvalue & TAG_INFINITY_MASK) != 0) {
					src2_addr->tagvalue = src1_addr->tagvalue;
				} else {
					src2_addr->tagvalue = tag_or ^ TAG_NEGATIVE_MASK;
				}
			}
			return;
		}
		/* Check for the case of zero... This is very likely */
		if ((tag_or & TAG_ZERO_MASK) != 0)  {
			if ((tag_xor & TAG_ZERO_MASK) != 0) {
				/* Only one zero. */
				if ((src1_addr->tagvalue & TAG_ZERO_MASK) != 0) {
					/* If src1 is zero, -src2 is result */
					src1_addr = StackEntryByIndex(destIndex);
					CopyFP(src1_addr, src2_addr);
					src1_addr->tagvalue ^= TAG_NEGATIVE_MASK;
					((FPHOST *)&(src1_addr->fpvalue))->hiword.sign ^= 1;
				} else {
					/* If src2 is zero, src1 is result. */
					src2_addr = StackEntryByIndex(destIndex);
					CopyFP(src2_addr, src1_addr);
				}
			} else {
				/* Both are zeros. Do they have the same sign? */
				src2_addr = StackEntryByIndex(destIndex);
				if ((tag_xor & TAG_NEGATIVE_MASK) != 0) {
					/* No, they don't - the result is src1 */
					src2_addr->tagvalue = src1_addr->tagvalue;
				} else {
					/* Yes, they do... */
					if (npxRounding == ROUND_NEG_INFINITY) {
						src2_addr->tagvalue = (TAG_ZERO_MASK | TAG_NEGATIVE_MASK);
					} else {
						src2_addr->tagvalue = TAG_ZERO_MASK;
					}
				}
			}
			return;
		}
	}
}



/*(
Name		: FTST
Function	: Compare ST against 0.0
Operation	: Set C023 on result of comparison
Flags		: C1 as per table 15-1. C0, C2 and C3 as result of comparison.
Exceptions	: D, I, IS
Valid range	: Any
)*/


GLOBAL VOID FTST IFN0()
{
	/* Clear C1 */
	FlagC1(0);
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & ~((TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK) | TAG_INFINITY_MASK)) == 0)  {
		/* First, check for the denormal case... */
		if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				return;
			}
		}
		FlagC2(0);
		FlagC3(0);
		if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			/* ST is less than zero */
			FlagC0(1);
		} else {
			/* ST is greater than zero */
			FlagC0(0);
		}
	} else {
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0) {
			FlagC0(0);
			FlagC2(0);
			FlagC3(1);
		} else {
			/* For anything else the result is "unordered" */
			FlagC0(1);
			FlagC2(1);
			FlagC3(1);
			NpxStatus |= SW_IE_MASK;
			if ((NpxControl & CW_IM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			}
		}
	}
}


/*(
Name		: FXAM
Function	: Report on the type of object in ST
Operation	: Set C0123 on result of comparison
Flags		: C0, C1, C2 and C3 as required.
Exceptions	: None
Valid range	: Any
)*/


GLOBAL VOID FXAM IFN0()
{
	TestUneval(TOSPtr);
	tag_or = TOSPtr->tagvalue;
	if ((tag_or & TAG_NEGATIVE_MASK) == 0) {
		FlagC1(0);
	} else {
		FlagC1(1);
		tag_or &= ~TAG_NEGATIVE_MASK;
	}
	tag_or &= ~TAG_SNAN_MASK;
	/* This gets rid of all the confusing bits... */
	/* There is now only one bit set or none at all... */
	if (tag_or == 0) {
		FlagC0(0);
		FlagC2(1);
		FlagC3(0);
		return;
	}
	if ((tag_or & TAG_ZERO_MASK) != 0) {
		FlagC0(0);
		FlagC2(0);
		FlagC3(1);
		return;
	}
	if ((tag_or & TAG_INFINITY_MASK) != 0) {
		FlagC0(1);
		FlagC2(1);
		FlagC3(0);
		return;
	}
	if ((tag_or & TAG_DENORMAL_MASK) != 0) {
		FlagC0(0);
		FlagC2(1);
		FlagC3(1);
		return;
	}
	if ((tag_or & TAG_NAN_MASK) != 0) {
		FlagC0(1);
		FlagC2(0);
		FlagC3(0);
		return;
	}
	if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
		FlagC0(0);
		FlagC2(0);
		FlagC3(0);
		return;
	}
	/* MUST be empty */
	FlagC0(1);
	FlagC2(0);
	FlagC3(1);
}


/*(
Name		: FXCH
Function	: Swap the contents of two stack registers.
Operation	: TEMP <- ST; ST <- DEST; DEST <- TEMP
Flags		: C1 as per table 15-1. Others undefined
Exceptions	: IS
Valid range	: Any
Notes		: If either of the registers is tagged empty then it is
		  loaded with indefinite and the exchange performed.
)*/


GLOBAL VOID FXCH IFN1(IU16, destIndex)
{
	FPSTACKENTRY *dest_addr;

	dest_addr = StackEntryByIndex(destIndex);
	/* Clear C1 */
	FlagC1(0);
	tag_or = (TOSPtr->tagvalue | dest_addr->tagvalue);
	if ((tag_or & TAG_EMPTY_MASK) != 0) {
		NpxStatus |= SW_IE_MASK;
		if ((NpxControl & CW_IM_MASK) == 0) {
			NpxStatus |= SW_ES_MASK;
			DoNpxException();
			return;
		}
		if ((TOSPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			WriteIndefinite(TOSPtr);
		}
		if ((dest_addr->tagvalue & TAG_EMPTY_MASK) != 0) {
			WriteIndefinite(dest_addr);
		}
	}
	CopyFP(&FPTemp, TOSPtr);
	CopyFP(TOSPtr, dest_addr);
	CopyFP(dest_addr, &FPTemp);
}



/*(
Name		: FXTRACT
Function	: Split the value in ST into its exponent and significand
Operation	: TEMP<-sig(ST); ST<-exp(ST); Dec ST; ST<-TEMP
Flags		: C1 as per table 15-1. Others undefined
Exceptions	: Z, D, I, IS
Valid range	: Any
Notes		: If the original operand is zero, result is ST(1) is -infinity
		  and ST is the original zero. The zero divide exception is also
		  raised. If the original operand is infinity, ST(1) is +infinity
		  and ST is the original infinity. If ST(7) is not empty, the
		  invalid operation exception is raised.
)*/


GLOBAL VOID FXTRACT IFN1(IU16, destIndex)
{
	FPSTACKENTRY *dest_addr;
	IS16 exp_val;

	dest_addr = StackEntryByIndex(7);
	/* Clear C1 */
	FlagC1(0);
	if ((dest_addr->tagvalue & TAG_EMPTY_MASK) == 0) {
		NpxStatus |= SW_IE_MASK;
		NpxStatus &= ~SW_SF_MASK;
		if ((NpxControl & CW_IM_MASK) == 0) {
			NpxStatus |= SW_ES_MASK;
			DoNpxException();
		} else {
			WriteIndefinite(TOSPtr);
			TOSPtr=dest_addr;
			WriteIndefinite(TOSPtr);
		}
		return;
	}
	TestUneval(TOSPtr);
	if ((TOSPtr->tagvalue & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0)  {
		if ((TOSPtr->tagvalue & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				return;
			}
			/* It won't be a denormal after we've finished */
			TOSPtr->tagvalue ^= TAG_DENORMAL_MASK;
		}
		/* It is entirely valid */
		exp_val = ((FPHOST *)&(TOSPtr->fpvalue))->hiword.exp-HOST_BIAS;
		((FPHOST *)&(TOSPtr->fpvalue))->hiword.exp=HOST_BIAS;
		TOSPtr->tagvalue &= TAG_NEGATIVE_MASK;
		CopyFP(dest_addr, TOSPtr);
		FPRes = (FPH)exp_val;
		/* This MUST be a real number, it could be negative. */
		CalcTagword(TOSPtr);
		TOSPtr = dest_addr;
	} else {
		/* Check if it was a zero */
		if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0)  {
			dest_addr->tagvalue = TOSPtr->tagvalue;
			TOSPtr->tagvalue = (TAG_INFINITY_MASK | TAG_NEGATIVE_MASK);
			TOSPtr = dest_addr;
			NpxStatus |= SW_ZE_MASK;
			if ((NpxControl & CW_ZM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			}
			return;
		}
		/* Check if it was an infinity */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			dest_addr->tagvalue = TOSPtr->tagvalue;
			TOSPtr->tagvalue = TAG_INFINITY_MASK;
			TOSPtr = dest_addr;
			return;
		}
		/* There was something funny...Was it empty or unsupported? */
		if ((TOSPtr->tagvalue & (TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK)) != 0) {
			NpxStatus |= SW_IE_MASK;
			NpxStatus &= ~SW_SF_MASK;
			if ((NpxControl & CW_IM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
			} else {
				WriteIndefinite(TOSPtr);
				TOSPtr=dest_addr;
				WriteIndefinite(TOSPtr);
			}
			return;
		}
		CopyFP(dest_addr, TOSPtr);
		TOSPtr = dest_addr;
	}
}



/*(
FYL2X (Y log base 2 of X) calculates the function Z=Y*LOG2(X). X is
taken from ST(0) and Y is taken from ST(1). The operands must be in
the range 0 < X < +inf and -inf < Y < +inf. The instruction pops the
)*/


GLOBAL VOID FYL2X IFN0()
{
	FPSTACKENTRY *st1_addr;

	/* Clear C1 */
	FlagC1(0);
	st1_addr = StackEntryByIndex(1);
	TestUneval(TOSPtr);
	TestUneval(st1_addr);
	tag_or = (TOSPtr->tagvalue | st1_addr->tagvalue);
	/* First, check if the values are real. If so, we can proceed. */
	if ((tag_or & ~(TAG_DENORMAL_MASK | TAG_NEGATIVE_MASK)) == 0)  {
		/* Check for the denorm case... */
		if ((tag_or & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				/* We ALWAYS pop!!! */
				TOSPtr->tagvalue = TAG_EMPTY_MASK;
				TOSPtr = st1_addr;
				return;
			}
		}
		/* Check for the case of a negative in ST */
		if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			SignalIndefinite(st1_addr);
			TOSPtr->tagvalue = TAG_EMPTY_MASK;
			TOSPtr = st1_addr;
			return;
		}

		/* OK, we can do the operation ... */

		FPRes = st1_addr->fpvalue * host_log2(TOSPtr->fpvalue);

		PostCheckOUP();
		/* Tgis is just a multiplication, result could be anything */
		CalcTagword(st1_addr);
	} else {
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0)  {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				SignalStackUnderflow(st1_addr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					SignalIndefinite(st1_addr);
				} else {
					/* Well, I suppose it has to be the NaN case... */
					/* Calculate the xor of the tagwords */
					tag_xor = (TOSPtr->tagvalue ^ st1_addr->tagvalue);
					Test2NaN(1, TOSPtr, st1_addr);
				}
			}
			TOSPtr->tagvalue = TAG_EMPTY_MASK;
			TOSPtr = st1_addr;
			return;
		}
		/* The only possibilities left are infinity and zero..  */
		/* Let's begin with the zeroes case.. */
		if ((tag_or & TAG_ZERO_MASK) != 0) {
			if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0) {
				/* ST is zero. Can have two possibilities */
				/* if ST(1) is zero, raise invalid */
				/* Otherwise raise divide by zero */
				if ((st1_addr->tagvalue & TAG_ZERO_MASK) != 0) {
					SignalIndefinite(st1_addr);
				} else {
					if ((st1_addr->tagvalue & TAG_INFINITY_MASK) == 0) {
						/* Calculate the xor of the tagwords */
						tag_xor = (TOSPtr->tagvalue ^ st1_addr->tagvalue);
						SignalDivideByZero(st1_addr);
					} else {
						st1_addr->tagvalue ^= TAG_NEGATIVE_MASK;
					}
				}
			} else {
				/* ST(1) must be zero */
				/* We already know that TOSPtr isn't zero. */
				/* There are three possibilities again. */
				/* If TOSPtr is infinity, raise invalid exception. */
				/* If TOSPtr < 1.0 then the result is zero with the  */
				/* complement of the sign of ST(1) */
				/* If TOSPtr >= 1.0 then the result is ST(1) */
				if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
					SignalIndefinite(st1_addr);
				} else {
					if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
						SignalIndefinite(st1_addr);
					} else {
						if (TOSPtr->fpvalue < 1.0) {
							st1_addr->tagvalue ^= TAG_NEGATIVE_MASK;
						}
					}
				}
			}
			TOSPtr->tagvalue = TAG_EMPTY_MASK;
			TOSPtr = st1_addr;
			return;
		}
		/* The only thing left is infinity... */
		/* If ST is infinity then there are two possibilities... */
		/* If it is +infinity the result is infinity with sign of ST(1) */
		/* If it is -infinity the result is an invalid operation */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) == 0) {
				st1_addr->tagvalue &= TAG_NEGATIVE_MASK;
				st1_addr->tagvalue |= TAG_INFINITY_MASK;
			} else {
				SignalIndefinite(st1_addr);
			}
		} else {
			/* ST(1) MUST be infinity (and ST is real). */
			/* There are three possibilities: */
			/* If ST is exactly 1.0 then raise Invalid */
			/* If ST is less than 1.0 then the result is the */
			/* infinity with the complement of its sign. */
			/* If ST is greater than 1.0 the result is the infinity. */
			if (TOSPtr->fpvalue == 1.0) {
				SignalIndefinite(st1_addr);
			} else {
				if (TOSPtr->fpvalue < 1.0) {
					if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
						 SignalIndefinite(st1_addr);
					} else {
						st1_addr->tagvalue ^= TAG_NEGATIVE_MASK;
					}
				}
			}
		}
	}
	TOSPtr->tagvalue = TAG_EMPTY_MASK;
	TOSPtr = st1_addr;
}



/*(
FYL2XP1 (Y log base 2 of (X+1)) calculates the function Z=Y*LOG2(X+1). X is
taken from ST(0) and Y is taken from ST(1). The operands must be in
the range 0 < X < +inf and -inf < Y < +inf. The instruction pops the
TOS value. This is better than FYL2X when X is very small, since more significant
digits can be retained for 1+X than can be for X alone.
)*/


GLOBAL VOID FYL2XP1 IFN0()
{
	FPSTACKENTRY *st1_addr;

	/* Clear C1 */
	FlagC1(0);
	st1_addr = StackEntryByIndex(1);
	TestUneval(TOSPtr);
	TestUneval(st1_addr);
	tag_or = (TOSPtr->tagvalue | st1_addr->tagvalue);
	/* First, check if the values are real. If so, we can proceed. */
	if ((tag_or & ~(TAG_DENORMAL_MASK | TAG_NEGATIVE_MASK)) == 0)  {
		/* Check for the denorm case... */
		if ((tag_or & TAG_DENORMAL_MASK) != 0) {
			NpxStatus |= SW_DE_MASK;
			if ((NpxControl & CW_DM_MASK) == 0) {
				NpxStatus |= SW_ES_MASK;
				DoNpxException();
				/* We ALWAYS pop!!! */
				TOSPtr->tagvalue = TAG_EMPTY_MASK;
				TOSPtr = st1_addr;
				return;
			}
		}
		/* Check for the case of a value less than -1 */
		if (TOSPtr->fpvalue <= -1.0) {
			SignalIndefinite(st1_addr);
			TOSPtr->tagvalue = TAG_EMPTY_MASK;
			TOSPtr = st1_addr;
			return;
		}

		/* OK, we can do the operation ...  */

		FPRes = st1_addr->fpvalue * host_log1p(TOSPtr->fpvalue);

		PostCheckOUP();
		/* This is just a numtiplication - result could be anything */
		CalcTagword(st1_addr);
	} else {
		if ((tag_or & ((TAG_EMPTY_MASK | TAG_UNSUPPORTED_MASK) | TAG_NAN_MASK)) != 0)  {
			if ((tag_or & TAG_EMPTY_MASK) != 0) {
				SignalStackUnderflow(st1_addr);
			} else {
				if ((tag_or & TAG_UNSUPPORTED_MASK) != 0) {
					SignalIndefinite(st1_addr);
				} else {
					/* Well, I suppose it has to be the NaN case... */
					/* Calculate the xor of the tagwords */
					tag_xor = (TOSPtr->tagvalue ^ st1_addr->tagvalue);
					Test2NaN(1, TOSPtr, st1_addr);
				}
			}
			TOSPtr->tagvalue = TAG_EMPTY_MASK;
			TOSPtr = st1_addr;
			return;
		}
		/* The only possibilities left are infinity and zero..  */
		/* Let's begin with the zeroes case.. */
		if ((tag_or & TAG_ZERO_MASK) != 0) {
			if ((TOSPtr->tagvalue & TAG_ZERO_MASK) != 0) {
				/* ST is zero. Can have two possibilities */
				/* if ST(1) is positive, result is ST */
				/* if ST(1) is negative, result is -ST */
				if ((st1_addr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
					st1_addr->tagvalue = (TAG_ZERO_MASK | (TOSPtr->tagvalue & TAG_NEGATIVE_MASK));
				} else {
					st1_addr->tagvalue = (TAG_ZERO_MASK | (TOSPtr->tagvalue ^ TAG_NEGATIVE_MASK));
				}
			} else {
				/* ST(1) must be zero */
				/* We already know that TOSPtr isn't zero. */
				/* There are three possibilities again. */
				/* If TOSPtr is infinity, raise invalid exception. */
				/* If TOSPtr < 0 then the result is zero with the  */
				/* complement of the sign of ST(1) */
				/* If TOSPtr >= 0 then the result is ST(1) */
				if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
					SignalIndefinite(st1_addr);
				} else {
					if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
						st1_addr->tagvalue ^= TAG_NEGATIVE_MASK;
					}
				}
			}
			TOSPtr->tagvalue = TAG_EMPTY_MASK;
			TOSPtr = st1_addr;
			return;
		}
		/* The only thing left is infinity... */
		/* If ST is infinity then there are two possibilities... */
		/* If it is +infinity the result is infinity with sign of ST(1) */
		/* If it is -infinity the result is an invalid operation */
		if ((TOSPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
			if ((TOSPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
				st1_addr->tagvalue &= TAG_NEGATIVE_MASK;
				st1_addr->tagvalue |= TAG_INFINITY_MASK;
			} else {
				SignalIndefinite(st1_addr);
			}
		} else {
			/* ST(1) MUST be infinity (and ST is non-zero). */
			/* There are three possibilities: */
			/* If ST is exactly 1.0 then raise Invalid */
			/* If ST is less than 0.0 then the result is the */
			/* infinity with the complement of its sign. */
			/* If ST is greater than 0.0 the result is the infinity. */
			if (TOSPtr->fpvalue ==  1.0) {
				SignalIndefinite(st1_addr);
			} else {
				if (TOSPtr->fpvalue < 0.0) {
					st1_addr->tagvalue ^= TAG_NEGATIVE_MASK;
				}
			}
		}
	}
	TOSPtr->tagvalue = TAG_EMPTY_MASK;
	TOSPtr = st1_addr;
}

/* These functions are provided in order to facilitate pigging */

#ifndef PIG
/* copied here from FmNpx.c */

GLOBAL	void NpxStackRegAsString IFN3(FPSTACKENTRY *, fpStPtr, char *, buf, IU32, prec)
{
	/* The overwhelmingly most likely option is empty. */
	if ((fpStPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
		strcpy(buf, "empty");
		return;
	}
	if ((fpStPtr->tagvalue & ~(TAG_NEGATIVE_MASK | TAG_DENORMAL_MASK)) == 0) {
		sprintf(buf, "%.*g", prec, fpStPtr->fpvalue);
		return;
	}
	/* OK, one of the funny bits was set. But which? */
	if ((fpStPtr->tagvalue & TAG_ZERO_MASK) != 0) {
		if ((fpStPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			strcpy(buf, "-0");
		} else {
			strcpy(buf, "0");
		}
		return;
	}
	if ((fpStPtr->tagvalue & UNEVALMASK) != 0) {
		sprintf(buf, "%04x %08x%08x",
			((FP80*)fpStPtr)->sign_exp,
			((FP80*)fpStPtr)->mant_hi,
			((FP80*)fpStPtr)->mant_lo);
		strcat(buf, " uneval");
		return;
	}
	if ((fpStPtr->tagvalue & TAG_INFINITY_MASK) != 0) {
		if ((fpStPtr->tagvalue & TAG_NEGATIVE_MASK) != 0) {
			strcpy(buf, "minus infinity");
		} else {
			strcpy(buf, "infinity");
		}
		return;
	}
	if ((fpStPtr->tagvalue & (TAG_NAN_MASK|TAG_SNAN_MASK)) != 0) {
		if (    ((FP80*)fpStPtr)->mant_lo == 0
		     && ((FP80*)fpStPtr)->mant_hi == 0xC0000000
		     && *(IU16*)&((FP80*)fpStPtr)->sign_exp == 0xFFFF )
			strcpy(buf, "indefinite");
		else
			sprintf(buf, "%08x%08x %s %sNan",
				((FP80*)fpStPtr)->mant_hi,
				((FP80*)fpStPtr)->mant_lo,
				 (fpStPtr->tagvalue & TAG_NEGATIVE_MASK) ? "negative" : "",
				 (fpStPtr->tagvalue & TAG_SNAN_MASK) ? "S" : "");
		return;
	}
	/* It MUST be unsupported */
	sprintf(buf, "%04 %08x%08x unsupported",
		((FP80*)fpStPtr)->sign_exp,
		((FP80*)fpStPtr)->mant_hi,
		((FP80*)fpStPtr)->mant_lo);
	return;
}

/* this one is only ever used in trace.c and only if pure CCPU */
GLOBAL char * getNpxStackReg IFN2(IU32, reg_num, char *, buffer)
{
	reg_num += TOSPtr - FPUStackBase;
	NpxStackRegAsString (&FPUStackBase[reg_num&7], buffer, 12);
	return buffer;
}
#endif	/* !PIG */

GLOBAL IU32 getNpxControlReg IFN0()
{
	return(NpxControl);
}

GLOBAL VOID setNpxControlReg IFN1(IU32, newControl)
{
	NpxControl = newControl;
	npxRounding = (NpxControl & 0xc00);
	switch (npxRounding) {
		case ROUND_NEAREST 	: HostSetRoundToNearest();
				   	  break;
		case ROUND_NEG_INFINITY	: HostSetRoundDown();
					  break;
		case ROUND_POS_INFINITY	: HostSetRoundUp();
					  break;
		case ROUND_ZERO		: HostSetRoundToZero();
					  break;
	}
}

GLOBAL IU32 getNpxStatusReg IFN0()
{
	GetIntelStatusWord();
	return(NpxStatus);
}

GLOBAL VOID setNpxStatusReg IFN1( IU32, newStatus)
{
	TOSPtr = FPUStackBase + ((newStatus >> 11) & 7);
	NpxStatus = newStatus;
}

GLOBAL IU32 getNpxTagwordReg IFN0()
{
	IU32 result;
	FPSTACKENTRY *tagPtr = &FPUStackBase[7];
	IU8 counter = 0;

	result = 0;
	while (counter++ < 8) {
		result <<= 2;
		if ((tagPtr->tagvalue & TAG_EMPTY_MASK) != 0) {
			result |= 3;
		} else {
			if ((tagPtr->tagvalue & TAG_ZERO_MASK) != 0) {
				result |= 1;
			} else {
				if ((tagPtr->tagvalue & ~TAG_NEGATIVE_MASK) != 0) {
					result |= 2;
				}
			}
		}
		tagPtr--;
	}
	return(result);
}

GLOBAL VOID setNpxTagwordReg IFN1(IU32, newTag)
{
	/* Don't do it!! */
	/* SetIntelTagword(newTag); */
}

GLOBAL void getNpxStackRegs IFN1(FPSTACKENTRY *, dumpPtr)
{
	memcpy((char *)dumpPtr, (char *)FPUStackBase, 8 * sizeof(FPSTACKENTRY));
}

GLOBAL void setNpxStackRegs IFN1(FPSTACKENTRY *, loadPtr)
{
	memcpy((char *)FPUStackBase, (char *)loadPtr, 8 * sizeof(FPSTACKENTRY));
}


/* And finally some stubs */
GLOBAL void initialise_npx IFN0()
{
}

GLOBAL void npx_reset IFN0()
{
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\idiv.h ===
/* 
   idiv.h

   Define all IDIV CPU functions.
 */

/*
   static char SccsID[]="@(#)idiv.h	1.4 02/09/94";
 */

IMPORT VOID IDIV8
       
IPT1(
	IU32, op2

   );

IMPORT VOID IDIV16
       
IPT1(
	IU32, op2

   );

IMPORT VOID IDIV32
       
IPT1(
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\imul.c ===
/*[

imul.c

LOCAL CHAR SccsID[]="@(#)imul.c	1.8 11/09/94";

IMUL CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <imul.h>
#include <c_mul64.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Signed multiply.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
IMUL8
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst(low half)/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   IU32 result;

   /* Sign extend operands to 32-bits (ie Host Size) */
   if ( *pop1 & BIT7_MASK )
      *pop1 |= ~BYTE_MASK;
   if ( op2 & BIT7_MASK )
      op2 |= ~BYTE_MASK;

   result = *pop1 * op2;	/* Do operation */
   SET_AH(result >> 8 & BYTE_MASK);	/* Store top half of result */

   				/* Set CF/OF. */
   if ( (result & 0xff80) == 0 || (result & 0xff80) == 0xff80 )
      {
      SET_CF(0); SET_OF(0);
      }
   else
      {
      SET_CF(1); SET_OF(1);
      }

#ifdef SET_UNDEFINED_MUL_FLAG
   /* Do NOT Set all undefined flag.
    * Microsoft VGA Mouse relies on preserved flags
    */
#endif
   *pop1 = result;	/* Return low half of result */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Signed multiply.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
IMUL16
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst(low half)/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   IU32 result;

   /* Sign extend operands to 32-bits (ie Host Size) */
   if ( *pop1 & BIT15_MASK )
      *pop1 |= ~WORD_MASK;
   if ( op2 & BIT15_MASK )
      op2 |= ~WORD_MASK;

   result = *pop1 * op2;		/* Do operation */
   SET_DX(result >> 16 & WORD_MASK);	/* Store top half of result */

   					/* Set CF/OF. */
   if ( (result & 0xffff8000) == 0 || (result & 0xffff8000) == 0xffff8000 )
      {
      SET_CF(0); SET_OF(0);
      }
   else
      {
      SET_CF(1); SET_OF(1);
      }

#ifdef SET_UNDEFINED_MUL_FLAG
   /* Do NOT Set all undefined flag.
    * Microsoft VGA Mouse relies on preserved flags
    */
#endif
   *pop1 = result;	/* Return low half of result */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Signed multiply, 16bit = 16bit x 16bit.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
IMUL16T
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2,	/* lsrc operand */
	IU32, op3	/* rsrc operand */
    )


   {
   IU32 result;

   /* Sign extend operands to 32-bits (ie Host Size) */
   if ( op2 & BIT15_MASK )
      op2 |= ~WORD_MASK;
   if ( op3 & BIT15_MASK )
      op3 |= ~WORD_MASK;

   result = op2 * op3;		/* Do operation */

   				/* Set CF/OF. */
   if ( (result & 0xffff8000) == 0 || (result & 0xffff8000) == 0xffff8000 )
      {
      SET_CF(0); SET_OF(0);
      }
   else
      {
      SET_CF(1); SET_OF(1);
      }

#ifdef SET_UNDEFINED_MUL_FLAG
   /* Do NOT Set all undefined flag.
    * Microsoft VGA Mouse relies on preserved flags
    */
#endif
   *pop1 = result;	/* Return low half of result */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Signed multiply.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
IMUL32
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst(low half)/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   IS32 result;
   IS32 top;
   IBOOL is_signed = FALSE;

   mul64(&top, &result, (IS32)*pop1, (IS32)op2);   /* Do operation */
   SET_EDX(top);			/* Store top half of result */

   if ( result & BIT31_MASK )
      is_signed = TRUE;

   				/* Set CF/OF. */
   if ( top == 0 && !is_signed || top == 0xffffffff && is_signed )
      {
      SET_CF(0); SET_OF(0);
      }
   else
      {
      SET_CF(1); SET_OF(1);
      }

#ifdef SET_UNDEFINED_MUL_FLAG
   /* Do NOT Set all undefined flag.
    * Microsoft VGA Mouse relies on preserved flags
    */
#endif
   *pop1 = result;	/* Return low half of result */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Signed multiply, 32bit = 32bit x 32bit.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
IMUL32T
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2,	/* lsrc operand */
	IU32, op3	/* rsrc operand */
    )


   {
   IS32 result;
   IS32 top;
   IBOOL is_signed = FALSE;

   mul64(&top, &result, (IS32)op2, (IS32)op3);	/* Do operation */

   if ( result & BIT31_MASK )
      is_signed = TRUE;

   					/* Set CF/OF. */
   if ( top == 0 && !is_signed || top == 0xffffffff && is_signed )
      {
      SET_CF(0); SET_OF(0);
      }
   else
      {
      SET_CF(1); SET_OF(1);
      }

#ifdef SET_UNDEFINED_MUL_FLAG
   /* Do NOT Set all undefined flag.
    * Microsoft VGA Mouse relies on preserved flags
    */
#endif

   *pop1 = result;	/* Return low half of result */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\fpu_c.h ===
#ifndef _Fpu_c_h
#define _Fpu_c_h
#define HOST_BIAS (1023)
#define MIN_EXP (-1023)
#define MAX_EXP (1024)
#define STACKENTRYSIZE (16)
#define STACKSIZE (128)
#define STACKWRAP (-129)
#define TAG_NEGATIVE_BIT (0)
#define TAG_ZERO_BIT (1)
#define TAG_INFINITY_BIT (2)
#define TAG_DENORMAL_BIT (3)
#define TAG_NAN_BIT (4)
#define TAG_SNAN_BIT (5)
#define TAG_UNSUPPORTED_BIT (6)
#define TAG_EMPTY_BIT (7)
#define TAG_FSCALE_BIT (8)
#define TAG_BCD_BIT (9)
#define TAG_R80_BIT (10)
#define TAG_UNEVAL_BIT_E (9)
#define TAG_UNEVAL_BIT_S (10)
#define TAG_REAL_POSITIVE_MASK (0)
#define TAG_NEGATIVE_MASK (1)
#define TAG_ZERO_MASK (2)
#define TAG_INFINITY_MASK (4)
#define TAG_DENORMAL_MASK (8)
#define TAG_NAN_MASK (16)
#define TAG_SNAN_MASK (32)
#define TAG_UNSUPPORTED_MASK (64)
#define TAG_EMPTY_MASK (128)
#define TAG_FSCALE_MASK (256)
#define TAG_BCD_MASK (512)
#define TAG_R80_MASK (1024)
#define TAG_UNEVAL_MASK (1536)
#define ST_IE_BIT (0)
#define ST_DE_BIT (1)
#define ST_ZE_BIT (2)
#define ST_OE_BIT (3)
#define ST_UE_BIT (4)
#define ST_PE_BIT (5)
#define ST_SF_BIT (6)
#define ST_ES_BIT (7)
#define ST_IE_MASK (1)
#define ST_DE_MASK (2)
#define ST_ZE_MASK (4)
#define ST_OE_MASK (8)
#define ST_UE_MASK (16)
#define ST_PE_MASK (32)
#define ST_SF_MASK (64)
#define ST_ES_MASK (128)
#define ST_C0_BIT (8)
#define ST_C1_BIT (9)
#define ST_C2_BIT (10)
#define ST_C3_BIT (14)
#define ST_C0_MASK (65279)
#define ST_C1_MASK (65023)
#define ST_C2_MASK (64511)
#define ST_C3_MASK (49151)
#define ST_B_BIT (15)
#define ST_ST_BIT_S (13)
#define ST_ST_BIT_E (11)
#define ST_B_MASK (61439)
#define ST_ST_MASK (51199)
#define TW_TAG_0_S (1)
#define TW_TAG_0_E (0)
#define TW_TAG_LENGTH (2)
#define TW_TAG_0_MASK (3)
#define TW_TAG_VALID (0)
#define TW_TAG_ZERO (1)
#define TW_TAG_INVALID (2)
#define TW_TAG_EMPTY (3)
#define CW_IM_BIT (0)
#define CW_DM_BIT (1)
#define CW_ZM_BIT (2)
#define CW_OM_BIT (3)
#define CW_UM_BIT (4)
#define CW_PM_BIT (5)
#define CW_PC_BIT_E (8)
#define CW_PC_BIT_S (9)
#define CW_RC_BIT_E (10)
#define CW_RC_BIT_S (11)
#define CW_IC_BIT (12)
#define CW_IM_MASK (1)
#define CW_DM_MASK (2)
#define CW_ZM_MASK (4)
#define CW_OM_MASK (8)
#define CW_UM_MASK (16)
#define CW_PM_MASK (32)
#define CW_PC_MASK (768)
#define CW_RC_MASK (3072)
#define CW_IC_MASK (4096)
#define ROUND_NEAREST (0)
#define ROUND_NEG_INFINITY (1)
#define ROUND_POS_INFINITY (2)
#define ROUND_TO_ZERO (3)
#define INTEL_I16_SIGN_BIT (15)
#define INTEL_I16_SIGN_MASK (32768)
#define INTEL_I32_SIGN_BIT (31)
#define INTEL_I32_SIGN_MASK (-2147483648)
#define INTEL_I64_SIGN_BIT (31)
#define INTEL_BCD_SIGN_BIT (15)
#define INTEL_SR_SIGN_BIT (31)
#define INTEL_SR_SIGN_MASK (-2147483648)
#define INTEL_SR_EXP_S (30)
#define INTEL_SR_EXP_E (23)
#define INTEL_SR_EXP_MASK (2139095040)
#define INTEL_SR_EXP_MAX (255)
#define INTEL_SR_MANT_S (22)
#define INTEL_SR_MANT_E (0)
#define INTEL_SR_MANT_MASK (8388607)
#define INTEL_LR_SIGN_BIT (31)
#define INTEL_LR_SIGN_MASK (-2147483648)
#define INTEL_LR_EXP_S (30)
#define INTEL_LR_EXP_E (20)
#define INTEL_LR_EXP_MASK (2146435072)
#define INTEL_LR_EXP_MAX (2047)
#define INTEL_LR_MANT_S (19)
#define INTEL_LR_MANT_E (0)
#define INTEL_LR_MANT_MASK (1048575)
#define INTEL_TR_SIGN_BIT (15)
#define INTEL_TR_SIGN_MASK (32768)
#define INTEL_TR_EXP_S (14)
#define INTEL_TR_EXP_E (0)
#define INTEL_TR_EXP_MASK (32767)
#define INTEL_COMP_NC (17664)
#define INTEL_COMP_GT (0)
#define INTEL_COMP_LT_BIT (8)
#define INTEL_COMP_EQ_BIT (14)
#define INTEL_COMP_LT (256)
#define INTEL_COMP_EQ (16384)
#define FPTEMP_INDEX (8)
#define C3C2C0MASK (47359)
#define FCLEX_MASK (32512)
#define COMP_LT (0)
#define COMP_GT (1)
#define COMP_EQ (2)
#define FPBASE_OFFSET (8)
#define CONST_ONE_OFFSET (0)
#define CONST_LOG2_10_OFFSET (1)
#define CONST_LOG2_E_OFFSET (2)
#define CONST_PI_OFFSET (3)
#define CONST_LOG10_2_OFFSET (4)
#define CONST_LOGE_2_OFFSET (5)
#define CONST_ZERO_OFFSET (6)
#define CONST_TWO_OFFSET (7)
#define CONST_MINUS_ONE_OFFSET (8)
struct FPSTACKENTRY
{
	double fpvalue;
	IUH padding;
	IUH tagvalue;
};
struct FP_I64
{
	IU32 word1;
	IU32 word2;
};
struct FP_R64
{
	IU32 word1;
	IU32 word2;
};
struct FP_R80
{
	struct FP_I64 mantissa;
	IU16 exponent;
};
#endif /* ! _Fpu_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\in.h ===
/* 
   in.h

   Define all IN CPU functions.
 */

/*
   static char SccsID[]="@(#)in.h	1.4 02/09/94";
 */

IMPORT VOID IN8
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID IN16
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID IN32
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\imul.h ===
/* 
   imul.h

   Define all IMUL CPU functions.
 */

/*
   static char SccsID[]="@(#)imul.h	1.4 02/09/94";
 */

IMPORT VOID IMUL8
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID IMUL16
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID IMUL16T
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IU32, op3

   );

IMPORT VOID IMUL32
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID IMUL32T
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IU32, op3

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\into.h ===
/* 
   into.h

   Define INTO CPU functions.
 */

/*
   static char SccsID[]="@(#)into.h	1.5 09/01/94";
 */

IMPORT VOID INTO IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\intx.c ===
/*[

intx.c

LOCAL CHAR SccsID[]="@(#)intx.c	1.5 02/09/94";

INT andISM323 CPU Functions.
----------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>

#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <intx.h>
#include <c_intr.h>

/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*ISM32n orISM323.                                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
INTx
                 
IFN1(
	IU32, op1
    )


   {
#ifdef NTVDM
   extern BOOL host_swint_hook IPT1(IS32, int_no);

   if(GET_PE() && host_swint_hook((IS32) op1))
	  return; /* Interrupt processed by user defined handler */
#endif

   EXT = INTERNAL;
   do_intrupt((IU16)op1, TRUE, FALSE, (IU16)0);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\inc.c ===
/*[

inc.c

LOCAL CHAR SccsID[]="@(#)inc.c	1.5 02/09/94";

INC CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <inc.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'inc'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
INC
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 msb;
   IU32 op1_msb;
   IU32 res_msb;

   msb = SZ2MSB(op_sz);

   result = *pop1 + 1 & SZ2MASK(op_sz);		/* Do operation */
   op1_msb = (*pop1  & msb) != 0;	/* Isolate all msb's */
   res_msb = (result & msb) != 0;
					/* Determine flags */
   SET_OF(!op1_msb & res_msb);		/* OF = !op1 & res */
					/* CF left unchanged */
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */
   SET_AF(((*pop1 ^ result) & BIT4_MASK) != 0);	/* AF = Bit 4 carry */
   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\inc.h ===
/* 
   inc.h

   Define all INC CPU functions.
 */

/*
   static char SccsID[]="@(#)inc.h	1.4 02/09/94";
 */

IMPORT VOID INC
           
IPT2(
	IU32 *, pop1,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\in.c ===
/*[

in.c

LOCAL CHAR SccsID[]="@(#)in.c	1.8 09/27/94";

IN CPU Functions.
-----------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <in.h>
#include <ios.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


/*
 * Need to call the IO functions directly from the base arrays (just like
 * the assembler CPU does), rather than calling inb etc., as the latter
 * could cause a virtualisation that would end-up back here.
 */

GLOBAL VOID
IN8
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2	/* src(port nr.) operand */
    )


   {
#ifndef PIG
   IU8 temp;

   (*Ios_inb_function[Ios_in_adapter_table[(IO_ADDR)op2 & (PC_IO_MEM_SIZE-1)]])
			((IO_ADDR)op2, &temp);
   *pop1 = temp;
#endif /* !PIG */
   }

GLOBAL VOID
IN16
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2	/* src(port nr.) operand */
    )


   {
#ifndef PIG
   IU16 temp;

   (*Ios_inw_function[Ios_in_adapter_table[(IO_ADDR)op2 & (PC_IO_MEM_SIZE-1)]])
			((IO_ADDR)op2, &temp);
   *pop1 = temp;
#endif /* !PIG */
   }

GLOBAL VOID
IN32 IFN2(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2	/* src(port nr.) operand */
    )
{
#ifndef PIG
	IU32 temp;

#ifdef SFELLOW
	(*Ios_ind_function[Ios_in_adapter_table[(IO_ADDR)op2 & 
		(PC_IO_MEM_SIZE-1)]])
			((IO_ADDR)op2, &temp);
	*pop1 = temp;
#else
	IN16(&temp, op2);
	*pop1 = temp;
	IN16(&temp, op2 + 2);
	*pop1 += temp << 16;
#endif
#endif /* !PIG */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\into.c ===
/*[

into.c

LOCAL CHAR SccsID[]="@(#)into.c	1.5 02/09/94";

INTO CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <into.h>
#include <c_intr.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Interrupt on Overflow                                              */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
INTO()
   {

  if ( GET_OF() )
      {
#ifdef NTVDM
      extern BOOL host_swint_hook IPT1(IS32, int_no);

      if(GET_PE() && host_swint_hook((IS32) 4))
	  return; /* Interrupt processed by user defined handler */
#endif

      EXT = INTERNAL;
      do_intrupt((IU16)4, TRUE, FALSE, (IU16)0);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\intx.h ===
/* 
   intx.h

   DefineISM32andISM323 (ie INTx) CPU functions.
 */

/*
   static char SccsID[]="@(#)intx.h	1.4 02/09/94";
 */

IMPORT VOID INTx
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\invd.c ===
/*[

invd.c

LOCAL CHAR SccsID[]="@(#)invd.c	1.5 02/09/94";

INVD CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <invd.h>

/*
   =====================================================================
   EXECUTION STARTS HERE.
   =====================================================================
 */


#ifdef SPC486

VOID
INVD()
   {
   /*
      If cache is implemented - then make call to flush cache.
      flush_cache();
    */
   }

#endif /* SPC486 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\invd.h ===
/* 
   invd.h

   Define INVD CPU functions.
 */

/*
   static char SccsID[]="@(#)invd.h	1.5 09/01/94";
 */

IMPORT VOID INVD IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\invlpg.c ===
/*[

invlpg.c

LOCAL CHAR SccsID[]="@(#)invlpg.c	1.5 02/09/94";

INVLPG CPU Functions.
---------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <invlpg.h>
#include <c_tlb.h>

/*
   =====================================================================
   EXECUTION STARTS HERE.
   =====================================================================
 */


#ifdef SPC486

GLOBAL VOID
INVLPG
       	          
IFN1(
	IU32, op1	/* src operand */
    )


   {
   invalidate_tlb_entry((IU32) op1);
   }

#endif /* SPC486 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\invlpg.h ===
/* 
   invlpg.h

   Define INVLPG CPU functions.
 */

/*
   static char SccsID[]="@(#)invlpg.h	1.4 02/09/94";
 */

IMPORT VOID INVLPG
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\iret.h ===
/* 
   iret.h

   Define IRET CPU functions.
 */

/*
   static char SccsID[]="@(#)iret.h	1.5 09/01/94";
 */

IMPORT VOID IRET IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\iret.c ===
/*[

iret.c

LOCAL CHAR SccsID[]="@(#)iret.c	1.13 1/19/95";

IRET CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include CpuH
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <iret.h>
#include <c_xfer.h>
#include <c_tsksw.h>
#include <c_page.h>
#include <fault.h>



/*
   =====================================================================
   INTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*--------------------------------------------------------------------*/
/* Intelligent support for writing (E)FLAGS.                          */
/*--------------------------------------------------------------------*/
LOCAL VOID
set_current_FLAGS
                 
IFN1(
	IU32, flags
    )


   {
   if ( GET_OPERAND_SIZE() == USE16 )
      setFLAGS(flags);
   else   /* USE32 */
      c_setEFLAGS(flags);
   }


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
IRET()
   {
   IU16  new_cs;	/* The return destination */
   IU32 new_ip;

   IU32 new_flags;	/* The new flags */

   IU16  back_link;		/* Task Return variables */
   IU32 tss_descr_addr;

   ISM32 dest_type;	/* category for destination */
   ISM32 privilege;	/* return privilege level */

   IU32 cs_descr_addr;	/* code segment descriptor address */
   CPU_DESCR cs_entry;	/* code segment descriptor entry */

   IU16  new_ss;	/* The new stack */
   IU32 new_sp;

   IU16 new_data_selector;	/* ES,DS,FS,GS selector */

   IU32 ss_descr_addr;	/* stack segment descriptor address */
   CPU_DESCR ss_entry;	/* stack segment descriptor entry */

   if ( GET_PE() == 0 || GET_VM() == 1 )
      {
      /* Real Mode or V86 Mode */

      /* must have (E)IP:CS:(E)FLAGS on stack */
      validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_3);

      /* retrieve return destination and flags from stack */
      new_ip =    tpop(STACK_ITEM_1, NULL_BYTE_OFFSET);
      new_cs =    tpop(STACK_ITEM_2, NULL_BYTE_OFFSET);
      new_flags = tpop(STACK_ITEM_3, NULL_BYTE_OFFSET);

#ifdef	TAKE_REAL_MODE_LIMIT_FAULT

      /* do ip limit check */
      if ( new_ip > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_IRET_RM_CS_LIMIT);

#else	/* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */

      /* ALL SYSTEMS GO */

      load_CS_cache(new_cs, (IU32)0, (CPU_DESCR *)0);
      SET_EIP(new_ip);

      change_SP((IS32)NR_ITEMS_3);

      set_current_FLAGS(new_flags);

      return;
      }
   
   /* PROTECTED MODE */

   /* look for nested return, ie return to another task */
   if ( GET_NT() == 1 )
      {
      /* NESTED RETURN - get old TSS */
      back_link = spr_read_word(GET_TR_BASE());
      (VOID)validate_TSS(back_link, &tss_descr_addr, TRUE);
      switch_tasks(RETURNING, NOT_NESTING, back_link, tss_descr_addr,
		   GET_EIP());

      /* limit check new IP (now in new task) */
      if ( GET_EIP() > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_IRET_PM_TASK_CS_LIMIT);

      return;
      }
   
   /* SAME TASK RETURN */

   /* must have (E)IP:CS:(E)FLAGS on stack */
   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_3);

   /* retrieve return destination from stack */
   new_ip = tpop(STACK_ITEM_1, NULL_BYTE_OFFSET);
   new_cs = tpop(STACK_ITEM_2, NULL_BYTE_OFFSET);
   new_flags = tpop(STACK_ITEM_3, NULL_BYTE_OFFSET);

   if ( GET_CPL() != 0 )
      new_flags = new_flags & ~BIT17_MASK;   /* Clear new VM */

   if ( new_flags & BIT17_MASK )   /* VM bit set? */
      {
      /*
	 Return to V86 Mode. Stack holds:-

	 ===========
	 |   EIP   |
	 |    | CS |
	 | EFLAGS  |
	 |   ESP   |
	 |    | SS |
	 |    | ES |
	 |    | DS |
	 |    | FS |
	 |    | GS |
	 ===========
       */

      validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_9);

      /* Check Instruction Pointer valid. */
      if ( new_ip > (IU32)0xffff )
	 GP((IU16)0, FAULT_IRET_VM_CS_LIMIT);

      /* ALL SYSTEMS GO */
      c_setEFLAGS(new_flags);	/* ensure VM set before segment loads */

      SET_CPL(3);		/* V86 privilege level */
      load_CS_cache(new_cs, (IU32)0, (CPU_DESCR *)0);
      SET_CS_LIMIT(0xffff);

      SET_EIP(new_ip);

      /* Retrieve new stack ESP:SS */
      new_sp = tpop(STACK_ITEM_4, NULL_BYTE_OFFSET);
      new_ss = tpop(STACK_ITEM_5, NULL_BYTE_OFFSET);

      /* Retrieve and set up new data selectors */
      new_data_selector = tpop(STACK_ITEM_6, NULL_BYTE_OFFSET);
      load_data_seg(ES_REG, new_data_selector);

      new_data_selector = tpop(STACK_ITEM_7, NULL_BYTE_OFFSET);
      load_data_seg(DS_REG, new_data_selector);

      new_data_selector = tpop(STACK_ITEM_8, NULL_BYTE_OFFSET);
      load_data_seg(FS_REG, new_data_selector);

      new_data_selector = tpop(STACK_ITEM_9, NULL_BYTE_OFFSET);
      load_data_seg(GS_REG, new_data_selector);

      /* Set up new stack */
      load_stack_seg(new_ss);
      set_current_SP(new_sp);

      /* Set up pseudo descriptors */
      load_pseudo_descr(SS_REG);
      load_pseudo_descr(DS_REG);
      load_pseudo_descr(ES_REG);
      load_pseudo_descr(FS_REG);
      load_pseudo_descr(GS_REG);

      return;
      }

   /* decode action and further check stack */
   privilege = GET_SELECTOR_RPL(new_cs);
   if ( privilege < GET_CPL() )
      {
      GP(new_cs, FAULT_IRET_CS_ACCESS_1);   /* you can't get to higher privilege */
      }
   else if ( privilege == GET_CPL() )
      {
      dest_type = SAME_LEVEL;
      }
   else
      {
      /* going to lower privilege */
      /* must have (E)IP:CS, (E)FLAGS, (E)SP:SS on stack */
      validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_5);
      dest_type = LOWER_PRIVILEGE;
      }

   if ( selector_outside_GDT_LDT(new_cs, &cs_descr_addr) )
      GP(new_cs, FAULT_IRET_SELECTOR);

   /* check type, access and presence of return addr */

   /* load descriptor */
   read_descriptor_linear(cs_descr_addr, &cs_entry);

   /* must be a code segment */
   switch ( descriptor_super_type(cs_entry.AR) )
      {
   case CONFORM_NOREAD_CODE:
   case CONFORM_READABLE_CODE:
      /* access check requires DPL <= return RPL */
      /* note that this even true when changing to outer rings - despite
         what it says in the 80286 & i486 PRMs - this has been verified on
         a real 80386 & i486 - Wayne 18th May 1994                         */
      if ( GET_AR_DPL(cs_entry.AR) > privilege )
	 GP(new_cs, FAULT_IRET_ACCESS_2);
      break;
   
   case NONCONFORM_NOREAD_CODE:
   case NONCONFORM_READABLE_CODE:
      /* access check requires DPL == return RPL */
      if ( GET_AR_DPL(cs_entry.AR) != privilege )
	 GP(new_cs, FAULT_IRET_ACCESS_3);
      break;
   
   default:
      GP(new_cs, FAULT_IRET_BAD_SEG_TYPE);
      }

   if ( GET_AR_P(cs_entry.AR) == NOT_PRESENT )
      NP(new_cs, FAULT_IRET_NP_CS);

   /* action the target */
   switch ( dest_type )
      {
   case SAME_LEVEL:
      /* do ip limit checking */
      if ( new_ip > cs_entry.limit )
	 GP((IU16)0, FAULT_IRET_PM_CS_LIMIT_1);

      /* ALL SYSTEMS GO */

      load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
      SET_EIP(new_ip);

      change_SP((IS32)NR_ITEMS_3);

      set_current_FLAGS(new_flags);
      break;

   case LOWER_PRIVILEGE:
      /* check new stack */
      new_ss = tpop(STACK_ITEM_5, NULL_BYTE_OFFSET);
      check_SS(new_ss, privilege, &ss_descr_addr, &ss_entry);
      
      /* do ip limit checking */
      if ( new_ip > cs_entry.limit )
	 GP((IU16)0, FAULT_IRET_PM_CS_LIMIT_2);

      /* ALL SYSTEMS GO */

      load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
      SET_EIP(new_ip);

      set_current_FLAGS(new_flags);

      new_sp = tpop(STACK_ITEM_4, NULL_BYTE_OFFSET);
      load_SS_cache(new_ss, ss_descr_addr, &ss_entry);
      if ( GET_OPERAND_SIZE() == USE16 )
	 SET_SP (new_sp);
      else
	 SET_ESP (new_sp);

      SET_CPL(privilege);

      /* finally re-validate DS and ES segments */
      load_data_seg_new_privilege(DS_REG);
      load_data_seg_new_privilege(ES_REG);
      load_data_seg_new_privilege(FS_REG);
      load_data_seg_new_privilege(GS_REG);
      break;
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\jmp.h ===
/* 
   jmp.h

   Define all JMP CPU functions.
 */

/*
   static char SccsID[]="@(#)jmp.h	1.4 02/09/94";
 */

IMPORT VOID JMPF
       
IPT1(
	IU32, op1[2]

   );

IMPORT VOID JMPN
       
IPT1(
	IU32, offset

   );

IMPORT VOID JMPR
       
IPT1(
	IU32, rel_offset

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\jcxz.c ===
/*[

jcxz.c

LOCAL CHAR SccsID[]="@(#)jcxz.c	1.5 02/09/94";

JCXZ CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <jcxz.h>
#include <c_xfer.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
JCXZ
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_CX() == 0 )
      update_relative_ip(rel_offset);
   }

GLOBAL VOID
JECXZ
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_ECX() == 0 )
      update_relative_ip(rel_offset);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\jmp.c ===
/*[

jmp.c

LOCAL CHAR SccsID[]="@(#)jmp.c	1.10 01/19/95";

JMP CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <jmp.h>
#include <c_xfer.h>
#include <c_tsksw.h>
#include <fault.h>

#define TAKE_PROT_MODE_LIMIT_FAULT


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Process far jmps.                                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JMPF
#ifdef ANSI
   (
   IU32 op1[2]       /* offset:segment pointer */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   IU16  new_cs;	/* The destination */
   IU32 new_ip;

   IU32 descr_addr;	/* cs descriptor address and entry */
   CPU_DESCR entry;

   ISM32 dest_type;	/* category for destination */
   IU8 count;	/* dummy for call gate count */

   new_cs = op1[1];
   new_ip = op1[0];

   if ( GET_PE() == 0 || GET_VM() == 1 )
      {
      /* Real Mode or V86 Mode */

#ifdef	TAKE_REAL_MODE_LIMIT_FAULT

      /*
	 Although the 386 book says a 16-bit operand should be AND'ed
	 with 0x0000ffff, a 16-bit operand is never fetched with the
	 top bits dirty anyway, so we don't AND here.
       */
      if ( new_ip > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_JMPF_RM_CS_LIMIT);

#else	/* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */

      load_CS_cache(new_cs, (IU32)0, (CPU_DESCR *)0);
      SET_EIP(new_ip);
      }
   else
      {
      /* Protected Mode */

      /* decode and check final destination */
      validate_far_dest(&new_cs, &new_ip, &descr_addr, &count,
			&dest_type, JMP_ID);

      /* action possible types of target */
      switch ( dest_type )
	 {
      case NEW_TASK:
	 switch_tasks(NOT_RETURNING, NOT_NESTING, new_cs, descr_addr, GET_EIP());

	 /* limit check new IP (now in new task) */
	 if ( GET_EIP() > GET_CS_LIMIT() )
	    GP((IU16)0, FAULT_JMPF_TASK_CS_LIMIT);

	 break;

      case SAME_LEVEL:
	 read_descriptor_linear(descr_addr, &entry);

	 /* do limit checking */
	 if ( new_ip > entry.limit )
	    GP((IU16)0, FAULT_JMPF_PM_CS_LIMIT);

	 /* stamp new selector with CPL */
	 SET_SELECTOR_RPL(new_cs, GET_CPL());
	 load_CS_cache(new_cs, descr_addr, &entry);
	 SET_EIP(new_ip);
	 break;
	 }
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* jump near indirect                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JMPN
                 
IFN1(
	IU32, offset
    )


   {
   /*
      Although the 386 book says a 16-bit operand should be AND'ed
      with 0x0000ffff, a 16-bit operand is never fetched with the
      top bits dirty anyway, so we don't AND here.
    */

   /* do ip limit check */
#ifdef	TAKE_REAL_MODE_LIMIT_FAULT

   if ( offset > GET_CS_LIMIT() )
      GP((IU16)0, FAULT_JMPN_RM_CS_LIMIT);

#else /* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#ifdef TAKE_PROT_MODE_LIMIT_FAULT

   if ( GET_PE() == 1 && GET_VM() == 0 )
      {
      if ( offset > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_JMPN_PM_CS_LIMIT);
      }

#endif /* TAKE_PROT_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Protected Mode limit failues
       * for the instructions with relative offsets, Jxx, LOOPxx, JCXZ,
       * JMP rel and CALL rel, or instructions with near offsets,
       * JMP near and CALL near.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */

   SET_EIP(offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* jump near relative                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JMPR
                 
IFN1(
	IU32, rel_offset
    )


   {
   update_relative_ip(rel_offset);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\jcxz.h ===
/* 
   jcxz.h

   Define all JCXZ CPU functions.
 */

/*
   static char SccsID[]="@(#)jcxz.h	1.4 02/09/94";
 */

IMPORT VOID JCXZ
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JECXZ
       
IPT1(
	IU32, rel_offset

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\jxx.h ===
/* 
   jxx.h

   Define all Jxx CPU functions.
 */

/*
   static char SccsID[]="@(#)jxx.h	1.4 02/09/94";
 */

IMPORT VOID JB
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JBE
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JL
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JLE
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JNB
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JNBE
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JNL
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JNLE
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JNO
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JNP
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JNS
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JNZ
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JO
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JP
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JS
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID JZ
       
IPT1(
	IU32, rel_offset

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lahf.c ===
/*[

lahf.c

LOCAL CHAR SccsID[]="@(#)lahf.c	1.5 02/09/94";

LAHF CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <lahf.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
LAHF()
   {
   IU32 temp;

   /*            7   6   5   4   3   2   1   0  */
   /* set AH = <SF><ZF>< 0><AF>< 0><PF>< 1><CF> */

   temp = GET_SF() << 7 | GET_ZF() << 6 | GET_AF() << 4 | GET_PF() << 2 |
	  GET_CF() | 0x2;
   SET_AH(temp);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\jxx.c ===
/*[

jxx.c

LOCAL CHAR SccsID[]="@(#)jxx.c	1.5 02/09/94";

Jxx CPU Functions (Conditional Jumps).
--------------------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <jxx.h>
#include <c_xfer.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Below (CF=1)                                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JB
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_CF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Below or Equal (CF=1 || ZF=1)                              */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JBE
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_CF() || GET_ZF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Less (SF != OF)                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JL
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_SF() != GET_OF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Less or Equal (ZF=1 || (SF != OF))                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JLE
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_SF() != GET_OF() || GET_ZF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Not Below (CF=0)                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JNB
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( !GET_CF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Not Below or Equal (CF=0 && ZF=0)                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JNBE
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( !GET_CF() && !GET_ZF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Not Less (SF==OF)                                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JNL
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_SF() == GET_OF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Not Less or Equal (ZF=0 && (SF==OF))                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JNLE
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_SF() == GET_OF() && !GET_ZF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Not Overflow (OF=0)                                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JNO
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( !GET_OF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Not Parity (PF=0)                                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JNP
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( !GET_PF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Not Sign (SF=0)                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JNS
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( !GET_SF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Not Zero (ZF=0)                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JNZ
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( !GET_ZF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Overflow (OF=1)                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JO
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_OF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Parity (PF=1)                                              */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JP
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_PF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Sign (SF=1)                                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JS
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_SF() )
      update_relative_ip(rel_offset);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Jump if Zero (ZF=1)                                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
JZ
                 
IFN1(
	IU32, rel_offset
    )


   {
   if ( GET_ZF() )
      update_relative_ip(rel_offset);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lahf.h ===
/* 
   lahf.h

   Define all LAHF CPU functions.
 */

/*
   static char SccsID[]="@(#)lahf.h	1.5 09/01/94";
 */

IMPORT VOID LAHF IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lar.h ===
/* 
   lar.h

   Define all LAR CPU functions.
 */

/*
   static char SccsID[]="@(#)lar.h	1.4 02/09/94";
 */

IMPORT VOID LAR
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lea.c ===
/*[

lea.c

LOCAL CHAR SccsID[]="@(#)lea.c	1.5 02/09/94";

LEA CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <lea.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
LEA
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2	/* src(address) operand */
    )


   {
   *pop1 = op2;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lar.c ===
/*[

lar.c

LOCAL CHAR SccsID[]="@(#)lar.c	1.5 02/09/94";

LAR CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <lar.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
LAR
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2	/* src operand */
    )


   {
   BOOL loadable = FALSE;
   IU32 descr_addr;
   CPU_DESCR entry;

   if ( !selector_outside_GDT_LDT((IU16)op2, &descr_addr) )
      {
      /* read descriptor from memory */
      read_descriptor_linear(descr_addr, &entry);

      switch ( descriptor_super_type(entry.AR) )
	 {
      case INVALID:
	 break;   /* never loaded */

      case CONFORM_NOREAD_CODE:
      case CONFORM_READABLE_CODE:
	 loadable = TRUE;   /* always loadable */
	 break;
      
      case INTERRUPT_GATE:
      case TRAP_GATE:
      case XTND_AVAILABLE_TSS:
      case XTND_BUSY_TSS:
      case XTND_CALL_GATE:
      case XTND_INTERRUPT_GATE:
      case XTND_TRAP_GATE:
      case AVAILABLE_TSS:
      case LDT_SEGMENT:
      case BUSY_TSS:
      case CALL_GATE:
      case TASK_GATE:
      case EXPANDUP_READONLY_DATA:
      case EXPANDUP_WRITEABLE_DATA:
      case EXPANDDOWN_READONLY_DATA:
      case EXPANDDOWN_WRITEABLE_DATA:
      case NONCONFORM_NOREAD_CODE:
      case NONCONFORM_READABLE_CODE:
	 /* access depends on privilege, it is required that
	       DPL >= CPL and DPL >= RPL */
	 if ( GET_AR_DPL(entry.AR) >= GET_CPL() &&
	      GET_AR_DPL(entry.AR) >= GET_SELECTOR_RPL(op2) )
	    loadable = TRUE;
	 break;
	 }
      }

   if ( loadable )
      {
      /* Give em the access rights, in a suitable format */
      *pop1 = (IU32)entry.AR << 8;
      SET_ZF(1);
      }
   else
      {
      SET_ZF(0);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lea.h ===
/* 
   lea.h

   Define all LEA CPU functions.
 */

/*
   static char SccsID[]="@(#)lea.h	1.4 02/09/94";
 */

IMPORT VOID LEA
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\leave.h ===
/* 
   leave.h

   Define all LEAVE CPU functions.
 */

/*
   static char SccsID[]="@(#)leave.h	1.5 09/01/94";
 */

IMPORT VOID LEAVE16 IPT0();

IMPORT VOID LEAVE32 IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\leave.c ===
/*[

leave.c

LOCAL CHAR SccsID[]="@(#)leave.c	1.5 02/09/94";

LEAVE CPU functions.
--------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <leave.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
LEAVE16()
   {
   IU32 new_bp;

   /* check operand exists */
   validate_stack_exists(USE_BP, (ISM32)NR_ITEMS_1);

   /* all ok - we can safely update the stack pointer */
   set_current_SP(GET_EBP());

   /* and update frame pointer */
   new_bp = spop();
   SET_BP(new_bp);
   }

GLOBAL VOID
LEAVE32()
   {
   IU32 new_bp;

   /* check operand exists */
   validate_stack_exists(USE_BP, (ISM32)NR_ITEMS_1);

   /* all ok - we can safely update the stack pointer */
   set_current_SP(GET_EBP());

   /* and update frame pointer */
   new_bp = spop();
   SET_EBP(new_bp);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lgdt.h ===
/* 
   lgdt.h

   Define all LGDT CPU functions.
 */

/*
   static char SccsID[]="@(#)lgdt.h	1.4 02/09/94";
 */

IMPORT VOID LGDT16
       
IPT1(
	IU32, op1[2]

   );

IMPORT VOID LGDT32
       
IPT1(
	IU32, op1[2]

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lidt.h ===
/* 
   lidt.h

   Define all LIDT CPU functions.
 */

/*
   static char SccsID[]="@(#)lidt.h	1.4 02/09/94";
 */

IMPORT VOID LIDT16
       
IPT1(
	IU32, op1[2]

   );

IMPORT VOID LIDT32
       
IPT1(
	IU32, op1[2]

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lgdt.c ===
/*[

lgdt.c

LOCAL CHAR SccsID[]="@(#)lgdt.c	1.5 02/09/94";

LGDT CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <lgdt.h>

/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
LGDT16
#ifdef ANSI
   (
   IU32 op1[2]	/* src(limit:base pair) operand */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   SET_STAR_LIMIT(GDT_REG, op1[0]);
   SET_STAR_BASE(GDT_REG, op1[1] & 0xffffff);   /* store 24-bit base */
#ifdef DOUBLE_CPU
   double_switch_to(SOFT_CPU);
#endif
   }

GLOBAL VOID
LGDT32
#ifdef ANSI
   (
   IU32 op1[2]	/* src(limit:base pair) operand */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   SET_STAR_LIMIT(GDT_REG, op1[0]);
   SET_STAR_BASE(GDT_REG, op1[1]);
#ifdef DOUBLE_CPU
   double_switch_to(SOFT_CPU);
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lldt.h ===
/* 
   lldt.h

   Define all LLDT CPU functions.
 */

/*
   static char SccsID[]="@(#)lldt.h	1.4 02/09/94";
 */

IMPORT VOID LLDT
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lidt.c ===
/*[

lidt.c

LOCAL CHAR SccsID[]="@(#)lidt.c	1.5 02/09/94";

LIDT CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <lidt.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
LIDT16
#ifdef ANSI
   (
   IU32 op1[2]	/* src(limit:base pair) operand */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   SET_STAR_LIMIT(IDT_REG, op1[0]);
   SET_STAR_BASE(IDT_REG, op1[1] & 0xffffff);   /* store 24-bit base */
   }

GLOBAL VOID
LIDT32
#ifdef ANSI
   (
   IU32 op1[2]	/* src(limit:base pair) operand */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   SET_STAR_LIMIT(IDT_REG, op1[0]);
   SET_STAR_BASE(IDT_REG, op1[1]);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lldt.c ===
/*[

lldt.c

LOCAL CHAR SccsID[]="@(#)lldt.c	1.8 01/19/95";

LLDT CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <lldt.h>
#include <fault.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
LLDT
                 
IFN1(
	IU32, op1
    )


   {
   IU16  selector;
   IU32 descr_addr;
   CPU_DESCR entry;

   if ( selector_is_null(selector = op1) )
      {
#ifndef DONT_CLEAR_LDTR_ON_INVALID
      SET_LDT_SELECTOR(selector);
#else
      SET_LDT_SELECTOR(0);   /* just invalidate LDT */
#endif /* DONT_CLEAR_LDTR_ON_INVALID */
#ifndef DONT_CLEAR_LDT_BL_ON_INVALID
      /* Make the C-CPU behave like the assembler CPU with respect
       * to LDT base and limit when the selector is set to NULL 
       * - there is no way for an Intel app to determine the values
       * of the LDT base&limit so this will not affect the emulation
       */
      SET_LDT_BASE(0);
      SET_LDT_LIMIT(0);
#endif /* DONT_CLEAR_LDT_BL_ON_INVALID */
      }
   else
      {
      /* must be in GDT */
      if ( selector_outside_GDT(selector, &descr_addr) )
	 GP(selector, FAULT_LLDT_SELECTOR);

      read_descriptor_linear(descr_addr, &entry);

      if ( descriptor_super_type(entry.AR) != LDT_SEGMENT )
	 GP(selector, FAULT_LLDT_NOT_LDT);
      
      /* must be present */
      if ( GET_AR_P(entry.AR) == NOT_PRESENT )
	 NP(selector, FAULT_LLDT_NP);

      /* all OK - load up register */

      SET_LDT_SELECTOR(selector);
      SET_LDT_BASE(entry.base);
      SET_LDT_LIMIT(entry.limit);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lmsw.c ===
/*[

lmsw.c

LOCAL CHAR SccsID[]="@(#)lmsw.c	1.5 02/09/94";

LMSW CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <lmsw.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
LMSW
       	          
IFN1(
	IU32, op1	/* src operand */
    )


   {
   IU32 temp;
   IU32 no_clear = 0xfffffff1;  /* can't clear top 28-bits or PE */
   IU32 no_set   = 0xfffffff0;  /* can't set top 28-bits */

   /* kill off bits which can not be set */
   op1 = op1 & ~no_set;

   /* retain bits which can not be cleared */
   temp = GET_CR(CR_STAT) & no_clear;

   /* thus update only the bits allowed */
   SET_CR(CR_STAT, temp | op1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lmsw.h ===
/* 
   lmsw.h

   Define all LMSW CPU functions.
 */

/*
   static char SccsID[]="@(#)lmsw.h	1.4 02/09/94";
 */

IMPORT VOID LMSW
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\localfm.c ===
#include <insignia.h>
#include <host_def.h>
#include <host_inc.h>
#include CpuH

IHP Gdp;
struct CpuVector Cpu;
struct SasVector Sas;
struct VideoVector Video;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\loopxx.c ===
/*[

loopxx.c

LOCAL CHAR SccsID[]="@(#)loopxx.c	1.5 02/09/94";

LOOPxx CPU Functions.
---------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <loopxx.h>
#include <c_xfer.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
LOOP16
                 
IFN1(
	IU32, rel_offset
    )


   {
   SET_CX(GET_CX() - 1);
   if ( GET_CX() != 0 )
      update_relative_ip(rel_offset);
   }

GLOBAL VOID
LOOP32
                 
IFN1(
	IU32, rel_offset
    )


   {
   SET_ECX(GET_ECX() - 1);
   if ( GET_ECX() != 0 )
      update_relative_ip(rel_offset);
   }

GLOBAL VOID
LOOPE16
                 
IFN1(
	IU32, rel_offset
    )


   {
   SET_CX(GET_CX() - 1);
   if ( GET_CX() != 0 && GET_ZF() )
      update_relative_ip(rel_offset);
   }

GLOBAL VOID
LOOPE32
                 
IFN1(
	IU32, rel_offset
    )


   {
   SET_ECX(GET_ECX() - 1);
   if ( GET_ECX() != 0 && GET_ZF() )
      update_relative_ip(rel_offset);
   }

GLOBAL VOID
LOOPNE16
                 
IFN1(
	IU32, rel_offset
    )


   {
   SET_CX(GET_CX() - 1);
   if ( GET_CX() != 0 && !GET_ZF() )
      update_relative_ip(rel_offset);
   }

GLOBAL VOID
LOOPNE32
                 
IFN1(
	IU32, rel_offset
    )


   {
   SET_ECX(GET_ECX() - 1);
   if ( GET_ECX() != 0 && !GET_ZF() )
      update_relative_ip(rel_offset);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\loopxx.h ===
/* 
   loopxx.h

   Define all LOOPxx CPU functions.
 */

/*
   static char SccsID[]="@(#)loopxx.h	1.4 02/09/94";
 */

IMPORT VOID LOOP16
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID LOOP32
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID LOOPE16
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID LOOPE32
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID LOOPNE16
       
IPT1(
	IU32, rel_offset

   );

IMPORT VOID LOOPNE32
       
IPT1(
	IU32, rel_offset

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lsl.c ===
/*[

lsl.c

LOCAL CHAR SccsID[]="@(#)lsl.c	1.5 02/09/94";

LSL CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <lsl.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
LSL
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2	/* src operand */
    )


   {
   BOOL loadable = FALSE;
   IU32 descr_addr;
   CPU_DESCR entry;

   if ( !selector_outside_GDT_LDT((IU16)op2, &descr_addr) )
      {
      /* read descriptor from memory */
      read_descriptor_linear(descr_addr, &entry);

      switch ( descriptor_super_type(entry.AR) )
	 {
      case INVALID:
      case CALL_GATE:
      case TASK_GATE:
      case INTERRUPT_GATE:
      case TRAP_GATE:
      case XTND_CALL_GATE:
      case XTND_INTERRUPT_GATE:
      case XTND_TRAP_GATE:
	 break;   /* never loaded - don't have a limit */

      case CONFORM_NOREAD_CODE:
      case CONFORM_READABLE_CODE:
	 loadable = TRUE;   /* always loadable */
	 break;
      
      case AVAILABLE_TSS:
      case LDT_SEGMENT:
      case BUSY_TSS:
      case XTND_AVAILABLE_TSS:
      case XTND_BUSY_TSS:
      case EXPANDUP_READONLY_DATA:
      case EXPANDUP_WRITEABLE_DATA:
      case EXPANDDOWN_READONLY_DATA:
      case EXPANDDOWN_WRITEABLE_DATA:
      case NONCONFORM_NOREAD_CODE:
      case NONCONFORM_READABLE_CODE:
	 /* access depends on privilege, it is required that
	       DPL >= CPL and DPL >= RPL */
	 if ( GET_AR_DPL(entry.AR) >= GET_CPL() &&
	      GET_AR_DPL(entry.AR) >= GET_SELECTOR_RPL(op2) )
	    loadable = TRUE;
	 break;
	 }
      }

   if ( loadable )
      {
      /* Give em the limit */
      *pop1 = entry.limit;
      SET_ZF(1);
      }
   else
      {
      SET_ZF(0);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lsl.h ===
/* 
   lsl.h

   Define all LSL CPU functions.
 */

/*
   static char SccsID[]="@(#)lsl.h	1.4 02/09/94";
 */

IMPORT VOID LSL
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lxs.h ===
/* 
   lxs.h

   Define LDS and LES (ie LxS) CPU functions.
 */

/*
   static char SccsID[]="@(#)lxs.h	1.4 02/09/94";
 */

IMPORT VOID LDS
           
IPT2(
	IU32 *, pop1,
	IU32, op2[2]

   );

IMPORT VOID LES
           
IPT2(
	IU32 *, pop1,
	IU32, op2[2]

   );

IMPORT VOID LFS
           
IPT2(
	IU32 *, pop1,
	IU32, op2[2]

   );

IMPORT VOID LGS
           
IPT2(
	IU32 *, pop1,
	IU32, op2[2]

   );

IMPORT VOID LSS
           
IPT2(
	IU32 *, pop1,
	IU32, op2[2]

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ltr.h ===
/* 
   ltr.h

   Define all LTR CPU functions.
 */

/*
   static char SccsID[]="@(#)ltr.h	1.4 02/09/94";
 */

IMPORT VOID LTR
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ltr.c ===
/*[

ltr.c

LOCAL CHAR SccsID[]="@(#)ltr.c	1.5 02/09/94";

LTR CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <ltr.h>
#include <c_page.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
LTR
       	          
IFN1(
	IU32, op1	/* alleged TSS selector */
    )


   {
   IU16 selector;
   IU32 descr_addr;
   CPU_DESCR entry;
   ISM32 super;

   /* Validate and Read decrciptor info. */
   selector = op1;
   super = validate_TSS(selector, &descr_addr, FALSE);
   read_descriptor_linear(descr_addr, &entry);

   /* mark in memory descriptor as busy */
   entry.AR |= BIT1_MASK;
   spr_write_byte(descr_addr+5, (IU8)entry.AR);

   /* finally load components of task register */
   SET_TR_SELECTOR(selector);
   SET_TR_BASE(entry.base);
   SET_TR_LIMIT(entry.limit);

   /* store busy form of TSS */
   super |= BIT1_MASK;
   SET_TR_AR_SUPER(super);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\lxs.c ===
/*[

lxs.c

LOCAL CHAR SccsID[]="@(#)lxs.c	1.5 02/09/94";

LDS, LES, LGS, LGS and LSS (ie LxS) CPU Functions.
--------------------------------------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <lxs.h>
#include <mov.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load Full Pointer to DS segment register:general register pair.    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
LDS
#ifdef ANSI
   (
   IU32 *pop1,	/* Pntr to dst(offset) operand */
   IU32 op2[2]	/* src(offset:selector pair) operand */
   )
#else
   (pop1, op2)
   IU32 *pop1;
   IU32 op2[2];
#endif
   {
   /* load segment selector first */
   MOV_SR((IU32)DS_REG, op2[1]);

   /* then (if it works) load offset */
   *pop1 = op2[0];
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load Full Pointer to ES segment register:general register pair.    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
LES
#ifdef ANSI
   (
   IU32 *pop1,	/* Pntr to dst(offset) operand */
   IU32 op2[2]	/* src(offset:selector pair) operand */
   )
#else
   (pop1, op2)
   IU32 *pop1;
   IU32 op2[2];
#endif
   {
   /* load segment selector first */
   MOV_SR((IU32)ES_REG, op2[1]);

   /* then (if it works) load offset */
   *pop1 = op2[0];
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load Full Pointer to FS segment register:general register pair.    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
LFS
#ifdef ANSI
   (
   IU32 *pop1,	/* Pntr to dst(offset) operand */
   IU32 op2[2]	/* src(offset:selector pair) operand */
   )
#else
   (pop1, op2)
   IU32 *pop1;
   IU32 op2[2];
#endif
   {
   /* load segment selector first */
   MOV_SR((IU32)FS_REG, op2[1]);

   /* then (if it works) load offset */
   *pop1 = op2[0];
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load Full Pointer to GS segment register:general register pair.    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
LGS
#ifdef ANSI
   (
   IU32 *pop1,	/* Pntr to dst(offset) operand */
   IU32 op2[2]	/* src(offset:selector pair) operand */
   )
#else
   (pop1, op2)
   IU32 *pop1;
   IU32 op2[2];
#endif
   {
   /* load segment selector first */
   MOV_SR((IU32)GS_REG, op2[1]);

   /* then (if it works) load offset */
   *pop1 = op2[0];
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Load Full Pointer to SS segment register:general register pair.    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
LSS
#ifdef ANSI
   (
   IU32 *pop1,	/* Pntr to dst(offset) operand */
   IU32 op2[2]	/* src(offset:selector pair) operand */
   )
#else
   (pop1, op2)
   IU32 *pop1;
   IU32 op2[2];
#endif
   {
   /* load segment selector first */
   MOV_SR((IU32)SS_REG, op2[1]);

   /* then (if it works) load offset */
   *pop1 = op2[0];
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\mov.h ===
/* 
   mov.h

   Define all MOV CPU functions.
 */

/*
   static char SccsID[]="@(#)mov.h	1.4 02/09/94";
 */

IMPORT VOID MOV
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID MOV_SR	/* to Segment Register */
           
IPT2(
	IU32, op1,
	IU32, op2

   );

IMPORT VOID MOV_CR	/* to Control Register */
           
IPT2(
	IU32, op1,
	IU32, op2

   );

IMPORT VOID MOV_DR	/* to Debug Register */
           
IPT2(
	IU32, op1,
	IU32, op2

   );

IMPORT VOID MOV_TR	/* to Test Register */
           
IPT2(
	IU32, op1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\movsx.c ===
/*[

movsx.c

LOCAL CHAR SccsID[]="@(#)movsx.c	1.5 02/09/94";

MOVSX CPU Functions.
--------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <movsx.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'movsx'.                               */
/* NB. This function sign extends to 32-bits.                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MOVSX
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8 or 16-bit (original rsrc operand size) */
    )


   {
   if ( SZ2MSB(op_sz) & op2 )   /* sign bit set? */
      {
      /* or in sign extension */
      op2 = op2 | ~SZ2MASK(op_sz);
      }
   *pop1 = op2;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\movsx.h ===
/* 
   movsx.h

   MOVSX CPU functions.
 */

/*
   static char SccsID[]="@(#)movsx.h	1.4 02/09/94";
 */

IMPORT VOID MOVSX
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\mul.c ===
/*[

mul.c

LOCAL CHAR SccsID[]="@(#)mul.c	1.8 11/09/94";

MUL CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <mul.h>
#include <c_mul64.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Unsigned multiply.                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MUL8
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst(low half)/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   IU32 result;
   IU32 top;

   result = *pop1 * op2;	/* Do operation */
   top = result >> 8 & 0xff;	/* get top 8 bits of result */
   SET_AH(top);		/* Store top half of result */

   if ( top )		/* Set CF/OF */
      {
      SET_CF(1); SET_OF(1);
      }
   else
      {
      SET_CF(0); SET_OF(0);
      }

#ifdef SET_UNDEFINED_MUL_FLAG
   /* Do NOT Set all undefined flag.
    * Microsoft VGA Mouse relies on preserved flags in IMUL
    */
#endif

   *pop1 = result;	/* Return low half of result */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Unsigned multiply.                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MUL16
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst(low half)/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   IU32 result;
   IU32 top;

   result = *pop1 * op2;	/* Do operation */
   top = result >> 16 & WORD_MASK;	/* get top 16 bits of result */
   SET_DX(top);		/* Store top half of result */

   if ( top )		/* Set CF/OF */
      {
      SET_CF(1); SET_OF(1);
      }
   else
      {
      SET_CF(0); SET_OF(0);
      }

#ifdef SET_UNDEFINED_MUL_FLAG
   /* Do NOT Set all undefined flag.
    * Microsoft VGA Mouse relies on preserved flags in IMUL
    */
#endif

   *pop1 = result;	/* Return low half of result */
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Unsigned multiply.                                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MUL32
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst(low half)/lsrc operand */
	IU32, op2	/* rsrc operand */
    )


   {
   IU32 result;
   IU32 top;

   mulu64(&top, &result, *pop1, op2);	/* Do operation */
   SET_EDX(top);		/* Store top half of result */

   if ( top )		/* Set CF/OF */
      {
      SET_CF(1); SET_OF(1);
      }
   else
      {
      SET_CF(0); SET_OF(0);
      }

#ifdef SET_UNDEFINED_MUL_FLAG
   /* Do NOT Set all undefined flag.
    * Microsoft VGA Mouse relies on preserved flags in IMUL
    */
#endif

   *pop1 = result;	/* Return low half of result */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\mov.c ===
/*[

mov.c

LOCAL CHAR SccsID[]="@(#)mov.c	1.12 02/13/95";

MOV CPU Functions.
------------------

]*/


#include <stdio.h>

#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <mov.h>
#include <c_tlb.h>
#include <c_debug.h>
#include <fault.h>
#include  <config.h>	/* For C_SWITCHNPX */


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'lods'.                                */
/* Generic - one size fits all 'mov'.                                 */
/* Generic - one size fits all 'movzx'.                               */
/* Generic - one size fits all 'movs'.                                */
/* Generic - one size fits all 'stos'.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MOV
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst operand */
	IU32, op2	/* src operand */
    )


   {
   *pop1 = op2;
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* 'mov' to segment register.                                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MOV_SR
       	    	               
IFN2(
	IU32, op1,	/* index to segment register */
	IU32, op2	/* src operand */
    )


   {
   switch ( op1 )
      {
   case DS_REG:
   case ES_REG:
   case FS_REG:
   case GS_REG:
      load_data_seg((ISM32)op1, (IU16)op2);
      break;

   case SS_REG:
      load_stack_seg((IU16)op2);
      break;

   default:
      break;
      }
   }


#ifdef SPC486
#define CR0_VALID_BITS 0xe005003f
#define CR3_VALID_BITS 0xfffff018
#else
#define CR0_VALID_BITS 0x8000001f
#define CR3_VALID_BITS 0xfffff000
#endif /* SPC486 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* 'mov' to control register.                                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MOV_CR
       	    	               
IFN2(
	IU32, op1,	/* index to control register */
	IU32, op2	/* src operand */
    )


   {
   IU32 keep_et;

   /*
      Maintain all Reserved bits as 0.
    */
   switch ( op1 )
      {
   case CR_STAT:   /* system control flags */
      /* If trying to set PG=1 and PE=0, then fault. */
      if ( (op2 & BIT31_MASK) && !(op2 & BIT0_MASK) )
	 GP((IU16)0, FAULT_MOV_CR_PAGE_IN_RM);

      /* Note ET bit is set at RESET time and remains unchanged */
      keep_et = GET_ET();
      SET_CR(CR_STAT, op2 & CR0_VALID_BITS);
      SET_ET(keep_et);
      break;

   case 1:   /* reserved */
      break;

   case CR_PFLA:   /* page fault linear address */
      SET_CR(CR_PFLA, op2);
      break;

   case CR_PDBR:   /* page directory base register (PDBR) */
      SET_CR(CR_PDBR, (op2 & CR3_VALID_BITS));
      flush_tlb();
      break;

   default:
      break;
      }
   }

#define DR7_VALID_BITS 0xffff03ff
#define DR6_VALID_BITS 0x0000e00f

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* 'mov' to debug register.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MOV_DR
       	    	               
IFN2(
	IU32, op1,	/* index to debug register, (0 - 7) */
	IU32, op2	/* src operand */
    )


   {
   switch ( op1 )
      {
   case 0:   /* Breakpoint Linear Address */
   case 1:
   case 2:
   case 3:
      SET_DR(op1, op2);
      setup_breakpoints();
      break;

   case 4:   /* Reserved */
   case 5:
      break;

   case 6:   /* Debug Status Register */
      SET_DR(DR_DSR, (op2 & DR6_VALID_BITS));
      break;

   case 7:   /* Debug Control Register */
      SET_DR(DR_DCR, (op2 & DR7_VALID_BITS));
      setup_breakpoints();
      break;

   default:
      break;
      }
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* 'mov' to test register.                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
MOV_TR
       	    	               
IFN2(
	IU32, op1,	/* index to test register */
	IU32, op2	/* src operand */
    )


   {
   switch ( op1 )
      {
   case 0:   /* Reserved */
   case 1:
   case 2:
      break;

   case TR_CDR:   /* Cache test Data Register */
      printf("Write to Cache Test Data Register.\n");
      break;

   case TR_CSR:   /* Cache test Status Register */
      printf("Write to Cache Test Status Register.\n");
      break;

   case TR_CCR:   /* Cache test Control Register */
      printf("Write to Cache Test Control Register.\n");
      break;

   case TR_TCR:   /* Test Command Register */
      SET_TR(TR_TCR, op2);
      test_tlb();
      break;

   case TR_TDR:   /* Test Data Register */
      SET_TR(TR_TDR, op2);
      break;

   default:
      break;
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\mul.h ===
/* 
   mul.h

   Define all MUL CPU functions.
 */

/*
   static char SccsID[]="@(#)mul.h	1.4 02/09/94";
 */

IMPORT VOID MUL8
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID MUL16
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );

IMPORT VOID MUL32
           
IPT2(
	IU32 *, pop1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\neg.h ===
/* 
   neg.h

   Define all NEG CPU functions.
 */

/*
   static char SccsID[]="@(#)neg.h	1.4 02/09/94";
 */

IMPORT VOID NEG
           
IPT2(
	IU32 *, pop1,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\neg.c ===
/*[

neg.c

LOCAL CHAR SccsID[]="@(#)neg.c	1.5 02/09/94";

NEG CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <neg.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'neg'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
NEG
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 msb;
   IU32 op1_msb;
   IU32 res_msb;

   msb = SZ2MSB(op_sz);

   result = -(*pop1) & SZ2MASK(op_sz);		/* Do operation */
   op1_msb = (*pop1  & msb) != 0;	/* Isolate all msb's */
   res_msb = (result & msb) != 0;
					/* Determine flags */
   SET_OF(op1_msb & res_msb);		/* OF = op1 & res */
   SET_CF(op1_msb | res_msb);		/* CF = op1 | res */
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */
   SET_AF(((*pop1 ^ result) & BIT4_MASK) != 0);	/* AF = Bit 4 carry */
   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\nop.h ===
/* 
   nop.h

   Define all NOP CPU functions.
 */

/*
   static char SccsID[]="@(#)nop.h	1.5 09/01/94";
 */

IMPORT VOID NOP IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\nop.c ===
/*[

nop.c

LOCAL CHAR SccsID[]="@(#)nop.c	1.5 02/09/94";

NOP CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <nop.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
NOP()
   {
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\newnpx.h ===
/*
 * SccsID = @(#)newnpx.h	1.4 10/06/94
 */

/* Function prototypes - everything returns void */
IMPORT VOID F2XM1(); 
IMPORT VOID FABS(); 
IMPORT VOID FADD(); 
IMPORT VOID FBLD(); 
IMPORT VOID FBSTP(); 
IMPORT VOID FCHS(); 
IMPORT VOID FCLEX(); 
IMPORT VOID FCOM(); 
IMPORT VOID FCOS(); 
IMPORT VOID FDECSTP(); 
IMPORT VOID FDIV();
IMPORT VOID FFREE();
IMPORT VOID FILD();
IMPORT VOID FLD();
IMPORT VOID FINCSTP();
IMPORT VOID FINIT();
IMPORT VOID FIST();
IMPORT VOID FLDCONST();
IMPORT VOID FLDCW();
IMPORT VOID FMUL();
IMPORT VOID FNOP();
IMPORT VOID FPATAN();
IMPORT VOID FPREM();
IMPORT VOID FPREM1();
IMPORT VOID FPTAN();
IMPORT VOID FRNDINT();
IMPORT VOID FSTCW();
IMPORT VOID FRSTOR();
IMPORT VOID FSAVE();
IMPORT VOID FSCALE();
IMPORT VOID FSIN();
IMPORT VOID FSINCOS();
IMPORT VOID FSQRT();
IMPORT VOID FST();
IMPORT VOID FSTENV();
IMPORT VOID FSTSW();
IMPORT VOID FSTCW();
IMPORT VOID FSUB();
IMPORT VOID FTST();
IMPORT VOID FXAM();
IMPORT VOID FXCH();
IMPORT VOID FXTRACT();
IMPORT VOID FYL2X();
IMPORT VOID FYL2XP1();

#define SAVE_PTRS()	\
	if (!NPX_PROT_MODE) {	\
		NpxFOP = NpxInstr;	\
	}				\
	NpxFCS = GET_CS_SELECTOR();	\
	NpxFIP = GET_EIP();

#define SAVE_DPTRS()	\
	NpxFEA = m_off[0];	\
	NpxFDS = GET_SR_SELECTOR(m_seg[0])

typedef enum 
{
FPSTACK,
M16I,
M32I,
M64I,
M32R,
M64R,
M80R
} NPXOPTYPE;

IMPORT IU8 FPtype;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\not.h ===
/* 
   not.h

   Define all NOT CPU functions.
 */

/*
   static char SccsID[]="@(#)not.h	1.4 02/09/94";
 */

IMPORT VOID NOT
       
IPT1(
	IU32 *, pop1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\not.c ===
/*[

not.c

LOCAL CHAR SccsID[]="@(#)not.c	1.5 02/09/94";

NOT CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <not.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'not'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
NOT
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst/src operand */
    )


   {
   *pop1 = ~*pop1;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\or.h ===
/* 
   or.h

   Define all OR CPU functions.
 */

/*
   static char SccsID[]="@(#)or.h	1.4 02/09/94";
 */

IMPORT VOID OR
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ntstubs.c ===
#include "insignia.h"
#include "host_def.h"
#include "evidgen.h"

#include "cpu4.h"

#ifndef PIG

extern struct VideoVector C_Video;

IHP Gdp;
struct CpuVector Cpu;
//struct SasVector Sas;
struct VideoVector Video;

a3_cpu_interrupt (int errupt, IU16 numint)
{
    switch(errupt)
    {
    case 1:    /* 3.0 cpu_timer_tick */
        c_cpu_interrupt(CPU_TIMER_TICK, numint);
        break;
    case 3: /* 3.0 cpu_hw_int */
        c_cpu_interrupt(CPU_HW_INT, numint);
        break;
    default: 
        printf("a3_cpu_interrupt - unhandled int %d\n", errupt);
    }
    
}
GLOBAL IBOOL AlreadyInYoda=FALSE;

void Cpu_define_outb (IU16 id, void (*func)() )
{
    UNUSED(id);
    UNUSED(func);
}

void CpuInitializeProfile()
{
}

void CpuAnalyzeProfile()
{
}

void CpuStartProfile()
{
}

IU32 a3_cpu_calc_q_ev_inst_for_time (IU32 val)
{
    return(c_cpu_calc_q_ev_inst_for_time (val));
}

void a3_cpu_init()
{
    c_cpu_init();
}

void a3_cpu_q_ev_set_count (IU32 val)
{
    c_cpu_q_ev_set_count (val);
}

IU32 a3_cpu_q_ev_get_count ()
{
    return(c_cpu_q_ev_get_count ());
}

void a3_cpu_clear_hw_int ()
{
}

void a3_cpu_terminate ()
{
    c_cpu_terminate();
}

void _asm_simulate()
{
    c_cpu_simulate();
}

#if 0
void cpu_simulate()
{
    c_cpu_simulate();
}
#endif

void copyROM()
{
}

void initialise_npx()
{
}

void npx_reset()
{
}

IHPE Cpu_outb_function;
IHPE GDP;

void _Call_C_2(IHPE a, IHPE b)
{
    UNUSED(a);
    UNUSED(b);
}

void D2DmpBinaryImage (LONG base) { UNUSED(base); }
void D2ForceTraceInit() { }
LONG D2LowerThreshold,  D2UpperThreshold;
void IH_dump_frag_hist(ULONG n) { UNUSED(n); }
void Mgr_yoda() { }
char *NPXDebugBase = "NPXDebugBase";
char *NPXDebugPtr = "NPXDebugPtr";
ULONG *NPXFreq = (ULONG *)0;
ULONG get_287_control_word() { return(0L); }
double get_287_reg_as_double(int n) { return((double)n); }
int get_287_sp() { return(0); }
ULONG get_287_status_word() { return(0L); }
word get_287_tag_word() { return(0); }


#include "sas.h"

#undef sas_connect_memory
void sas_connect_memory IFN3(PHY_ADDR, low, PHY_ADDR, high, SAS_MEM_TYPE, type)
{
    c_sas_connect_memory(low, high, type);
}
#undef sas_disable_20_bit_wrapping
void sas_disable_20_bit_wrapping IFN0() { c_sas_disable_20_bit_wrapping(); }
#undef sas_enable_20_bit_wrapping
void sas_enable_20_bit_wrapping IFN0() { c_sas_enable_20_bit_wrapping(); }
#undef sas_dw_at
IU32 sas_dw_at IFN1(LIN_ADDR, addr) { return(c_sas_dw_at(addr)); }
#undef sas_fills
void sas_fills IFN3(LIN_ADDR, dest, IU8 , val, LIN_ADDR, len) { c_sas_fills(dest, val, len); }
#undef sas_fillsw
void sas_fillsw IFN3(LIN_ADDR, dest, IU16 , val, LIN_ADDR, len) { c_sas_fillsw(dest, val, len); }
#undef sas_hw_at
IU8 sas_hw_at IFN1(LIN_ADDR, addr) { return(c_sas_hw_at(addr)); }
#undef sas_hw_at_no_check
IU8 sas_hw_at_no_check IFN1(LIN_ADDR, addr) { return(c_sas_hw_at(addr)); }
#undef sas_load
void sas_load IFN2(sys_addr, addr, half_word *, val)
{
    *val = c_sas_hw_at(addr);
}
#undef sas_loadw
void sas_loadw IFN2(sys_addr, addr, word *, val)
{
    *val = c_sas_w_at(addr);
}
#undef sas_loads
void sas_loads IFN3(LIN_ADDR, src, IU8 *, dest, LIN_ADDR, len)
{
    c_sas_loads(src, dest, len);
}
#undef sas_memory_size
PHY_ADDR sas_memory_size IFN0() { return(c_sas_memory_size()); }
#undef sas_memory_type
SAS_MEM_TYPE sas_memory_type IFN1(PHY_ADDR, addr) { return(c_sas_memory_type(addr)); }
#undef sas_move_bytes_forward
void sas_move_bytes_forward IFN3(sys_addr, src, sys_addr, dest, sys_addr, len)
{
    c_sas_move_bytes_forward(src, dest, len);
}
#undef sas_move_words_forward
void sas_move_words_forward IFN3(sys_addr, src, sys_addr, dest, sys_addr, len)
{
    c_sas_move_words_forward(src, dest, len);
}
#undef sas_overwrite_memory
void sas_overwrite_memory IFN2(PHY_ADDR, addr, PHY_ADDR, len)
{
    c_sas_overwrite_memory(addr, len);
}
#undef sas_scratch_address
IU8 *sas_scratch_address IFN1(sys_addr, length) { return(c_sas_scratch_address(length)); }
#undef sas_store
void sas_store IFN2(LIN_ADDR, addr, IU8, val) { c_sas_store(addr, val); }
#undef sas_store_no_check
void sas_store_no_check IFN2(LIN_ADDR, addr, IU8, val) { c_sas_store(addr, val); }
#undef sas_storedw
void sas_storedw IFN2(LIN_ADDR, addr, IU32, val) { c_sas_storedw(addr, val); }
#undef sas_storew
void sas_storew IFN2(LIN_ADDR, addr, IU16, val) { c_sas_storew(addr, val); }
#undef sas_storew_no_check
void sas_storew_no_check IFN2(LIN_ADDR, addr, IU16, val) { c_sas_storew(addr, val); }
#undef sas_stores
void sas_stores IFN3(LIN_ADDR, dest, IU8 *, src, LIN_ADDR, len)
{
    c_sas_stores(dest, src, len);
}
#undef sas_w_at
IU16 sas_w_at IFN1(LIN_ADDR, addr) { return(c_sas_w_at(addr)); }
#undef sas_w_at_no_check
IU16 sas_w_at_no_check IFN1(LIN_ADDR, addr) { return(c_sas_w_at(addr)); }
#undef sas_transbuf_address
IU8 *sas_transbuf_address IFN2(LIN_ADDR, dest_intel_addr, PHY_ADDR, len)
{
    return(c_sas_transbuf_address(dest_intel_addr, len));
}
#undef sas_twenty_bit_wrapping_enabled
IBOOL sas_twenty_bit_wrapping_enabled() { return(c_sas_twenty_bit_wrapping_enabled()); }
#undef sas_loads_to_transbuf
void sas_loads_to_transbuf(IU32 src, IU8 * dest, IU32 len)
{
    sas_loads(src, dest, len);
}

#undef sas_stores_from_transbuf
void sas_stores_from_transbuf(IU32 dest, IU8 * src, IU32 len)
{
    sas_stores(dest, src, len);
}

/*************************************************************************
*************************************************************************/

#endif /* !PIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\out.c ===
/*[

out.c

LOCAL CHAR SccsID[]="@(#)out.c	1.8 09/27/94";

OUT CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <out.h>
#include <ios.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */

/*
 * Need to call the IO functions directly from the base arrays (just like
 * the assembler CPU does), rather than calling outb etc., as the latter
 * could cause a virtualisation that would end-up back here.
 */

GLOBAL VOID
OUT8
       	    	               
IFN2(
	IU32, op1,	/* src1(port nr.) operand */
	IU32, op2	/* src2(data) operand */
    )


   {
#ifndef PIG
	(*Ios_outb_function[Ios_out_adapter_table[op1 & 
			(PC_IO_MEM_SIZE-1)]])
				(op1, op2);
#endif /* !PIG */
   }

GLOBAL VOID
OUT16
       	    	               
IFN2(
	IU32, op1,	/* src1(port nr.) operand */
	IU32, op2	/* src2(data) operand */
    )


   {
#ifndef PIG
	(*Ios_outw_function[Ios_out_adapter_table[op1 & 
			(PC_IO_MEM_SIZE-1)]])
				(op1, op2);
#endif /* !PIG */
   }

GLOBAL VOID
OUT32 IFN2(
	IU32, op1,	/* src1(port nr.) operand */
	IU32, op2	/* src2(data) operand */
    )
{
#ifndef PIG
#ifdef SFELLOW
	(*Ios_outd_function[Ios_out_adapter_table[op1 & 
			(PC_IO_MEM_SIZE-1)]])
				(op1, op2);
#else
	OUT16(op1, op2 & 0xffff);
	OUT16(op1 + 2, op2 >> 16);
#endif
#endif /* !PIG */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ntthread.c ===
#include <windows.h>
#include "insignia.h"
#include "host_def.h"

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

#define BADID   ((DWORD)-1)

#define MAXDEPTH    20

typedef struct {
    IS32 level;
    jmp_buf sims[MAXDEPTH];
    jmp_buf excepts[MAXDEPTH];
} ThreadSimBuf, *ThreadSimBufPtr;
    
typedef struct tids {
    DWORD tid;
    struct tids *next;
} TidList, *TidListPtr;

#define TIDNULL ((TidListPtr)0)

TidListPtr tidlist = TIDNULL;

void ccpu386InitThreadStuff();
void ccpu386foundnewthread();
void ccpu386newthread();
void ccpu386exitthread();
jmp_buf *ccpu386SimulatePtr();
void ccpu386Unsimulate();
jmp_buf *ccpu386ThrdExptnPtr();
void ccpu386GotoThrdExptnPt();

DWORD ccpuSimId = BADID;
IBOOL potentialNewThread = FALSE;

void ccpu386InitThreadStuff()
{
    static TidList lhead;

    ccpuSimId = TlsAlloc();

    if (ccpuSimId == BADID)
        fprintf(stderr, "ccpu386InitThreadStuff: TlsAlloc() failed\n");

    lhead.tid = GetCurrentThreadId();
    lhead.next = TIDNULL;
    tidlist = &lhead;

    ccpu386foundnewthread();     /* for main thread */

}

// what we'd really like to do at create thread time if we could be called
// in the correct context.
void ccpu386foundnewthread()
{
    ThreadSimBufPtr simstack;
    TidListPtr tp;

    if (ccpuSimId == BADID)
    {
        fprintf(stderr, "ccpu386foundnewthread id:%#x called with Bad Id\n", GetCurrentThreadId());
        return;
    }
    // get buffer for this thread to do sim/unsim on.
    simstack = (ThreadSimBufPtr)malloc(sizeof(ThreadSimBuf));

    if (simstack == (ThreadSimBufPtr)0)
    {
        fprintf(stderr, "ccpu386foundnewthread id:%#x cant malloc %d bytes. Err:%#x\n", GetCurrentThreadId(), sizeof(ThreadSimBuf), GetLastError());
        return;
    }
    simstack->level = 0;
    if (!TlsSetValue(ccpuSimId, simstack))
    {
        fprintf(stderr, "ccpu386foundnewthread id:%#x simid %#x TlsSetValue failed (err:%#x)\n", GetCurrentThreadId(), ccpuSimId, GetLastError());
        return;
    }
}

/* just set bool to be checked in simulate which will be in new thread context*/
void ccpu386newthread()
{
    potentialNewThread = TRUE;
}

void ccpu386exitthread()
{
    ThreadSimBufPtr simstack;
    TidListPtr tp, prev;

    if (ccpuSimId == BADID)
    {
        fprintf(stderr, "ccpu386exitthread id:%#x called with Bad Id\n", GetCurrentThreadId());
        return;
    }
    simstack = (ThreadSimBufPtr)TlsGetValue(ccpuSimId);
    if (simstack == (ThreadSimBufPtr)0)
    {
        fprintf(stderr, "ccpu386exitthread tid:%#x simid %#x TlsGetValue failed (err:%#x)\n", GetCurrentThreadId(), ccpuSimId, GetLastError());
        return;
    }
    free(simstack);     //lose host sim memory for this thread 

    prev = tidlist;
    tp = tidlist->next;  // assume wont lose main thread

    // remove tid from list of known threads
    while(tp != TIDNULL)
    {
        if (tp->tid == GetCurrentThreadId())
        {
            prev->next = tp->next;  /* take current node out of chain */
            free(tp);
            break;
        }
        prev = tp;
        tp = tp->next;
    }
}

jmp_buf *ccpu386SimulatePtr()
{
    ThreadSimBufPtr simstack;
    TidListPtr tp, prev;

    if (ccpuSimId == BADID)
    {
        fprintf(stderr, "ccpu386SimulatePtr id:%#x called with Bad Id\n", GetCurrentThreadId());
        return ((jmp_buf *)0);
    }

    // Check for 'first call in new thread context' case where we need to set
    // up new thread data space.
    if (potentialNewThread)
    {
        prev = tp = tidlist;
        while(tp != TIDNULL)        // look for tid in current list
        {
            if (tp->tid == GetCurrentThreadId())
                break;
            prev = tp;
            tp = tp->next;
        }
        if (tp == TIDNULL)      // must be new thread!
        {
            potentialNewThread = FALSE;     // remove search criteria

            tp = (TidListPtr)malloc(sizeof(TidList));   // make new node
            if (tp == TIDNULL)
            {
                fprintf(stderr, "ccpuSimulatePtr: can't malloc space for new thread data\n");
                return((jmp_buf *)0);
            }
            // connect & initialise node
            prev->next = tp;
            tp->tid = GetCurrentThreadId();
            tp->next = TIDNULL;
            //get tls data
            ccpu386foundnewthread();
        }
    }

    simstack = (ThreadSimBufPtr)TlsGetValue(ccpuSimId);
    if (simstack == (ThreadSimBufPtr)0)
    {
        fprintf(stderr, "ccpu386SimulatePtr tid:%#x simid %#x TlsGetValue failed (err:%#x)\n", GetCurrentThreadId(), ccpuSimId, GetLastError());
        return ((jmp_buf *)0);
    }
    
    if (simstack->level >= MAXDEPTH)
    {
        fprintf(stderr, "Stack overflow in ccpu386SimulatePtr()!\n");
        return((jmp_buf *)0);
    }

      /* return pointer to current context and invoke a new CPU level */
      /* can't setjmp here & return otherwise stack unwinds & context lost */

    return(&simstack->sims[simstack->level++]);
}

void ccpu386Unsimulate()
{
    ThreadSimBufPtr simstack;
    extern ISM32 in_C;

    if (ccpuSimId == BADID)
    {
        fprintf(stderr, "ccpu386Unsimulate id:%#x called with Bad Id\n", GetCurrentThreadId());
        return ;
    }
    simstack = (ThreadSimBufPtr)TlsGetValue(ccpuSimId);
    if (simstack == (ThreadSimBufPtr)0)
    {
        fprintf(stderr, "ccpu386Unsimulate tid:%#x simid %#x TlsGetValue failed (err:%#x)\n", GetCurrentThreadId(), ccpuSimId, GetLastError());
        return ;
    }
    
    if (simstack->level == 0)
    {
        fprintf(stderr, "host_unsimulate() - already at base of stack!\n");
    }

    /* Return to previous context */
    in_C = 1;
    simstack->level --;
    longjmp(simstack->sims[simstack->level], 1);
}

   /* somewhere for exceptions to return to */
jmp_buf *ccpu386ThrdExptnPtr()
{
    ThreadSimBufPtr simstack;

    if (ccpuSimId == BADID)
    {
        fprintf(stderr, "ccpu386ThrdExptnPtr id:%#x called with Bad Id\n", GetCurrentThreadId());
        return ;
    }
    simstack = (ThreadSimBufPtr)TlsGetValue(ccpuSimId);
    if (simstack == (ThreadSimBufPtr)0)
    {
        fprintf(stderr, "ccpu386ThrdExptnPtr id:%#x TlsGetValue failed (err:%#x)\n", GetCurrentThreadId(), GetLastError());
        return ;
    }
    
    return(&simstack->excepts[simstack->level - 1]);
}

/* take exception */
void ccpu386GotoThrdExptnPt()
{
    ThreadSimBufPtr simstack;

    if (ccpuSimId == BADID)
    {
        fprintf(stderr, "ccpu386GotoThrdExptnPtr id:%#x called with Bad Id\n", GetCurrentThreadId());
        return;
    }
    simstack = (ThreadSimBufPtr)TlsGetValue(ccpuSimId);
    if (simstack == (ThreadSimBufPtr)0)
    {
        fprintf(stderr, "ccpu386GotoThrdExptnPtr id:%#x TlsGetValue failed (err:%#x)\n", GetCurrentThreadId(), GetLastError());
        return ;
    }
    
    longjmp(simstack->excepts[simstack->level - 1], 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ntthread.h ===
extern void ccpu386InitThreadStuff();
extern void ccpu386foundnewthread();
extern void ccpu386newthread();
extern void ccpu386exitthread();
extern jmp_buf *ccpu386SimulatePtr();
extern void ccpu386Unsimulate();
extern jmp_buf *ccpu386ThrdExptnPtr();
extern void ccpu386GotoThrdExptnPt();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\pigger_c.h ===
#ifndef _Pigger_c_h
#define _Pigger_c_h
#define Pig (1)
#endif /* ! _Pigger_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\out.h ===
/* 
   out.h

   Define all OUT CPU functions.
 */

/*
   static char SccsID[]="@(#)out.h	1.4 02/09/94";
 */

IMPORT VOID OUT8
           
IPT2(
	IU32, op1,
	IU32, op2

   );

IMPORT VOID OUT16
           
IPT2(
	IU32, op1,
	IU32, op2

   );

IMPORT VOID OUT32
           
IPT2(
	IU32, op1,
	IU32, op2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\or.c ===
/*[

or.c

LOCAL CHAR SccsID[]="@(#)or.c	1.5 02/09/94";

OR CPU functions.
-----------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <or.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'or'.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
OR
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;

   result = *pop1 | op2;		/* Do operation */
   SET_CF(0);				/* Determine flags */
   SET_OF(0);
   SET_AF(0);
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & SZ2MSB(op_sz)) != 0);	/* SF = MSB */
   *pop1 = result;		/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\popf.c ===
/*[

popf.c

LOCAL CHAR SccsID[]="@(#)popf.c	1.6 02/05/95";

POPF CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include CpuH
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <popf.h>
#include <debug.h>
#include <config.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
POPF()
   {
   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_1);
   setFLAGS(spop());
   }

GLOBAL VOID
POPFD()
   {
   IU32 keep_vm;
   IU32 keep_rf;
   IU32 val;

   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_1);

   /* NB. POPFD does not change the VM or RF flags. */
   keep_vm = GET_VM();
   keep_rf = GET_RF();
   val = spop();
   if (val & (7 << 19))
   {
	   char buf[64];
	   sprintf(buf, "POPFD attempt to pop %08x", val);
	   note_486_instruction(buf);
   }
   c_setEFLAGS(val);
   SET_VM(keep_vm);
   SET_RF(keep_rf);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\push.h ===
/* 
   push.h

   Define all PUSH CPU functions.
 */

/*
   static char SccsID[]="@(#)push.h	1.5 07/05/94";
 */

IMPORT VOID PUSH
       
IPT1(
	IU32, op1

   );

IMPORT VOID PUSH_SR
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\popa.c ===
/*[

popa.c

LOCAL CHAR SccsID[]="@(#)popa.c	1.5 02/09/94";

POPA CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <popa.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
POPA()
   {
   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_8);
   SET_DI(spop());
   SET_SI(spop());
   SET_BP(spop());
   (VOID) spop();   /* throwaway SP */
   SET_BX(spop());
   SET_DX(spop());
   SET_CX(spop());
   SET_AX(spop());
   }

GLOBAL VOID
POPAD()
   {
   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_8);
   SET_EDI(spop());
   SET_ESI(spop());
   SET_EBP(spop());
   (VOID) spop();   /* throwaway ESP */
   SET_EBX(spop());
   SET_EDX(spop());
   SET_ECX(spop());
   SET_EAX(spop());
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\pop.c ===
/*[

pop.c

LOCAL CHAR SccsID[]="@(#)pop.c	1.5 02/09/94";

POP CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <pop.h>
#include <mov.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'pop'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
POP
                 
IFN1(
	IU32 *, pop1
    )


   {
   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_1);
   *pop1 = spop();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* 'pop' to segment register.                                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
POP_SR
       	          
IFN1(
	IU32, op1	/* index to segment register */
    )


   {
   IU32 op2;   /* data from stack */

   /* get implicit operand without changing (E)SP */
   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_1);
   op2 = tpop(STACK_ITEM_1, NULL_BYTE_OFFSET);

   /* only use bottom 16-bits */
   op2 &= WORD_MASK;

   /* do the move */
   MOV_SR(op1, op2);

   /* if it works update (E)SP */
   change_SP((IS32)NR_ITEMS_1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\pop.h ===
/* 
   pop.h

   Define all POP CPU functions.
 */

/*
   static char SccsID[]="@(#)pop.h	1.4 02/09/94";
 */

IMPORT VOID POP
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID POP_SR 	/* to Segment Register */
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\popa.h ===
/* 
   popa.h

   Define all POPA CPU functions.
 */

/*
   static char SccsID[]="@(#)popa.h	1.5 09/01/94";
 */

IMPORT VOID POPA IPT0();

IMPORT VOID POPAD IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\popf.h ===
/* 
   popf.h

   Define all POPF CPU functions.
 */

/*
   static char SccsID[]="@(#)popf.h	1.5 09/01/94";
 */

IMPORT VOID POPF IPT0();

IMPORT VOID POPFD IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\push.c ===
/*[

push.c

LOCAL CHAR SccsID[]="@(#)push.c	1.6 07/05/94";

PUSH CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <push.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'push'.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
PUSH
                 
IFN1(
	IU32, op1
    )


   {
   validate_stack_space(USE_SP, (ISM32)NR_ITEMS_1);
   spush(op1);
   }


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* 'push' segment register (always write 16 bits, in a 16/32 bit hole)*/
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
PUSH_SR
       	          
IFN1(
	IU32, op1
    )


   {
   validate_stack_space(USE_SP, (ISM32)NR_ITEMS_1);
   spush16(op1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\pusha.h ===
/* 
   pusha.h

   Define all PUSHA CPU functions.
 */

/*
   static char SccsID[]="@(#)pusha.h	1.5 09/01/94";
 */

IMPORT VOID PUSHA IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\pusha.c ===
/*[

pusha.c

LOCAL CHAR SccsID[]="@(#)pusha.c	1.5 02/09/94";

PUSHA CPU Functions.
--------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <pusha.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
PUSHA()
   {
   IU32 temp;

   /* verify stack is writable */
   validate_stack_space(USE_SP, (ISM32)NR_ITEMS_8);
   
   /* all ok, shunt data onto stack */
   temp = GET_ESP();
   spush((IU32)GET_EAX());
   spush((IU32)GET_ECX());
   spush((IU32)GET_EDX());
   spush((IU32)GET_EBX());
   spush(temp);
   spush((IU32)GET_EBP());
   spush((IU32)GET_ESI());
   spush((IU32)GET_EDI());
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\pushf.c ===
/*[

pushf.c

LOCAL CHAR SccsID[]="@(#)pushf.c	1.6 01/17/95";

PUSHF CPU Functions.
--------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <pushf.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
PUSHF()
   {
   IU32 flags;

   /* verify stack is writable */
   validate_stack_space(USE_SP, (ISM32)NR_ITEMS_1);
   
   /* all ok, shunt data onto stack */
   flags = c_getEFLAGS();

   /* VM and RF are cleared in pushed image. */
   flags = flags & ~BIT17_MASK;   /* Clear VM */
   flags = flags & ~BIT16_MASK;   /* Clear RF */

   spush(flags);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\pushf.h ===
/* 
   pushf.h

   Define all PUSHF CPU functions.
 */

/*
   static char SccsID[]="@(#)pushf.h	1.5 09/01/94";
 */

IMPORT VOID PUSHF IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\rcr.c ===
/*[

rcr.c

LOCAL CHAR SccsID[]="@(#)rcr.c	1.5 02/09/94";

RCR CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <rcr.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'rcr'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
RCR
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IU32, op2,	/* rotation count operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 temp_cf;
   IU32 result;
   IU32 feedback;	/* Bit posn to feed carry back to */
   ISM32 i;
   ISM32 new_of;

   /* only use lower five bits of count */
   if ( (op2 &= 0x1f) == 0 )
      return;

   /*
	    =================     ====
	 -> | | | | | | | | | --> |CF| ---
	 |  =================     ====   |
	 ---------------------------------
    */
   feedback = SZ2MSB(op_sz);
   for ( result = *pop1, i = 0; i < op2; i++ )
      {
      temp_cf = GET_CF();
      SET_CF((result & BIT0_MASK) != 0);		/* CF <= Bit 0 */
      result >>= 1;
      if ( temp_cf )
	 result |= feedback;
      }
   
   /* OF = MSB of result ^ (MSB-1) of result */
   new_of = ((result ^ result << 1) & feedback) != 0;

   if ( op2 == 1 )
      {
      SET_OF(new_of);
      }
   else
      {
      do_multiple_shiftrot_of(new_of);
      }

   *pop1 = result;	/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\rcl.h ===
/* 
   rcl.h

   Define all RCL CPU functions.
 */

/*
   static char SccsID[]="@(#)rcl.h	1.4 02/09/94";
 */

IMPORT VOID RCL
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\rcl.c ===
/*[

rcl.c

LOCAL CHAR SccsID[]="@(#)rcl.c	1.5 02/09/94";

RCL CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <rcl.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'rcl'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
RCL
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IU32, op2,	/* rotation count operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 feedback;	/* Bit posn to feed into carry */
   ISM32 i;
   ISM32 new_of;

   /* only use lower five bits of count */
   if ( (op2 &= 0x1f) == 0 )
      return;

   /*
	    ====     =================
	 -- |CF| <-- | | | | | | | | | <--
	 |  ====     =================   |
	 ---------------------------------
    */
   feedback = SZ2MSB(op_sz);
   for ( result = *pop1, i = 0; i < op2; i++ )
      {
      if ( result & feedback )
	 {
	 result = result << 1 | GET_CF();
	 SET_CF(1);
	 }
      else
	 {
	 result = result << 1 | GET_CF();
	 SET_CF(0);
	 }
      }
   
   /* OF = CF ^ MSB of result */
   new_of = GET_CF() ^ (result & feedback) != 0;

   if ( op2 == 1 )
      {
      SET_OF(new_of);
      }
   else
      {
      do_multiple_shiftrot_of(new_of);
      }

   *pop1 = result;	/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ret.h ===
/* 
   ret.h

   Define all RET CPU functions.
 */

/*
   static char SccsID[]="@(#)ret.h	1.4 02/09/94";
 */

IMPORT VOID RETF
       
IPT1(
	IU32, op1

   );

IMPORT VOID RETN
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ret.c ===
/*[

ret.c

LOCAL CHAR SccsID[]="@(#)ret.c	1.9 02/27/95";

RET CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include <c_reg.h>
#include <ret.h>
#include <c_xfer.h>
#include <fault.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Process far RET.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
RETF
       	          
IFN1(
	IU32, op1	/* Number of bytes to pop from stack.
		   NB OS2 Rel 2 implies (contrary to Intel doc.) that
		   imm16(op1) is always a byte quantity! */
    )


   {
   IU16  new_cs;	/* The return destination */
   IU32 new_ip;

   IU32 cs_descr_addr;	/* code segment descriptor address */
   CPU_DESCR cs_entry;	/* code segment descriptor entry */

   ISM32 dest_type;	/* category for destination */
   ISM32 privilege;	/* return privilege level */

   IU16  new_ss;	/* The new stack */
   IU32 new_sp;

   IU32 ss_descr_addr;	/* stack segment descriptor address */
   CPU_DESCR ss_entry;	/* stack segment descriptor entry */

   IS32 stk_inc;	/* Stack increment for basic instruction */
   ISM32  stk_item;	/* Number of items of immediate data */

   /* must have CS:(E)IP on the stack */
   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_2);

   /* retrieve return destination from stack */
   new_ip = tpop(STACK_ITEM_1, NULL_BYTE_OFFSET);
   new_cs = tpop(STACK_ITEM_2, NULL_BYTE_OFFSET);

   /* force immediate offset to be an item count */
   if ( GET_OPERAND_SIZE() == USE16 )
      stk_item = op1 / 2;
   else /* USE32 */
      stk_item = op1 / 4;

   if ( GET_PE() == 0 || GET_VM() == 1 )
      {
      /* Real Mode or V86 Mode */

#ifdef	TAKE_REAL_MODE_LIMIT_FAULT

      /* do ip limit check */
      if ( new_ip > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_RETF_RM_CS_LIMIT);

#else	/* TAKE_REAL_MODE_LIMIT_FAULT */

      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

#endif	/* TAKE_REAL_MODE_LIMIT_FAULT */

      /* all systems go */
      load_CS_cache(new_cs, (IU32)0, (CPU_DESCR *)0);
      SET_EIP(new_ip);

      stk_inc = NR_ITEMS_2;   /* allow for CS:(E)IP */
      }
   else
      {
      /* Protected Mode */

      /* decode final action and complete stack check */
      privilege = GET_SELECTOR_RPL(new_cs);
      if ( privilege < GET_CPL() )
	 {
	 GP(new_cs, FAULT_RETF_PM_ACCESS); /* you can't get to higher privilege */
	 }
      else if ( privilege == GET_CPL() )
	 {
	 dest_type = SAME_LEVEL;
	 }
      else
	 {
	 /* going to lower privilege */
	 /* must have CS:(E)IP, immed bytes, SS:(E)SP on stack */
	 validate_stack_exists(USE_SP, (ISM32)(NR_ITEMS_4 + stk_item));
	 dest_type = LOWER_PRIVILEGE;
	 }

      if ( selector_outside_GDT_LDT(new_cs, &cs_descr_addr) )
	 GP(new_cs,  FAULT_RETF_SELECTOR);

      /* check type, access and presence of return addr */

      /* load descriptor */
      read_descriptor_linear(cs_descr_addr, &cs_entry);

      /* must be a code segment */
      switch ( descriptor_super_type(cs_entry.AR) )
	 {
      case CONFORM_NOREAD_CODE:
      case CONFORM_READABLE_CODE:
	 /* access check requires DPL <= return RPL */
	 if ( GET_AR_DPL(cs_entry.AR) > privilege )
	    GP(new_cs, FAULT_RETF_ACCESS_1);
	 break;
      
      case NONCONFORM_NOREAD_CODE:
      case NONCONFORM_READABLE_CODE:
	 /* access check requires DPL == return RPL */
	 if ( GET_AR_DPL(cs_entry.AR) != privilege )
	    GP(new_cs, FAULT_RETF_ACCESS_2);
	 break;
      
      default:
	 GP(new_cs,  FAULT_RETF_BAD_SEG_TYPE);
	 }
      
      if ( GET_AR_P(cs_entry.AR) == NOT_PRESENT )
	 NP(new_cs, FAULT_RETF_CS_NOTPRESENT);

      /* action the target */
      switch ( dest_type )
	 {
      case SAME_LEVEL:
	 /* do ip  limit checking */
	 if ( new_ip > cs_entry.limit )
	    GP((IU16)0, FAULT_RETF_PM_CS_LIMIT_1);

	 /* ALL SYSTEMS GO */

	 load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
	 SET_EIP(new_ip);
	 stk_inc = NR_ITEMS_2;   /* allow for CS:(E)IP */
	 break;
      
      case LOWER_PRIVILEGE:
	 /*
	    
		      ==========
	    SS:SP  -> | old IP |
		      | old CS |
		      | parm 1 |
		      |  ...   |
		      | parm n |
		      | old SP |
		      | old SS |
		      ==========
	  */

	 /* check new stack */
	 new_ss = tpop(STACK_ITEM_4, (ISM32)op1);
	 check_SS(new_ss, privilege, &ss_descr_addr, &ss_entry);
	 
	 /* do ip limit checking */
	 if ( new_ip > cs_entry.limit )
	    GP((IU16)0, FAULT_RETF_PM_CS_LIMIT_2);

	 /* ALL SYSTEMS GO */

	 SET_CPL(privilege);

	 load_CS_cache(new_cs, cs_descr_addr, &cs_entry);
	 SET_EIP(new_ip);

	 new_sp = tpop(STACK_ITEM_3, (ISM32)op1);
	 load_SS_cache(new_ss, ss_descr_addr, &ss_entry);
	 if ( GET_OPERAND_SIZE() == USE16 )
	    SET_SP(new_sp);
	 else
	    SET_ESP(new_sp);
	 stk_inc = 0;

	 /* finally re-validate DS and ES segments */
	 load_data_seg_new_privilege(DS_REG);
	 load_data_seg_new_privilege(ES_REG);
	 load_data_seg_new_privilege(FS_REG);
	 load_data_seg_new_privilege(GS_REG);
	 break;
	 }
      }

   /* finally increment stack pointer */
   change_SP(stk_inc);
   byte_change_SP((IS32)op1);
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* near return                                                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
RETN
                 
IFN1(
	IU32, op1
    )


   {
   IU32 new_ip;

   /* must have ip on stack */
   validate_stack_exists(USE_SP, (ISM32)NR_ITEMS_1);

   new_ip = tpop(STACK_ITEM_1, NULL_BYTE_OFFSET);   /* get ip */

   /* do ip limit check */
#ifndef	TAKE_REAL_MODE_LIMIT_FAULT
      /* The Soft486 EDL CPU does not take Real Mode limit failures.
       * Since the Ccpu486 is used as a "reference" cpu we wish it
       * to behave a C version of the EDL Cpu rather than as a C
       * version of a i486.
       */

   if ( GET_PE() == 1 && GET_VM() == 0 )
#endif	/* nTAKE_REAL_MODE_LIMIT_FAULT */
      {
      if ( new_ip > GET_CS_LIMIT() )
	 GP((IU16)0, FAULT_RETN_CS_LIMIT);
      }

   /* all systems go */
   SET_EIP(new_ip);
   change_SP((IS32)NR_ITEMS_1);

   if ( op1 )
      {
      byte_change_SP((IS32)op1);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\rcr.h ===
/* 
   rcr.h

   Define all RCR CPU functions.
 */

/*
   static char SccsID[]="@(#)rcr.h	1.4 02/09/94";
 */

IMPORT VOID RCR
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\rol.c ===
/*[

rol.c

LOCAL CHAR SccsID[]="@(#)rol.c	1.5 02/09/94";

ROL CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <rol.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'rol'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
ROL
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IU32, op2,	/* rotation count operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 feedback;	/* Bit posn to feed into Bit 0 */
   ISM32 i;
   ISM32 new_of;

   /* only use lower five bits of count */
   if ( (op2 &= 0x1f) == 0 )
      return;

   /*
	    ====        =================
	    |CF| <-- -- | | | | | | | | | <--
	    ====     |  =================   |
	             ------------------------
    */
   feedback = SZ2MSB(op_sz);
   for ( result = *pop1, i = 0; i < op2; i++ )
      {
      if ( result & feedback )
	 {
	 result = result << 1 | 1;
	 SET_CF(1);
	 }
      else
	 {
	 result <<= 1;
	 SET_CF(0);
	 }
      }
   
   /* OF = CF ^ MSB of result */
   new_of = GET_CF() ^ (result & feedback) != 0;

   if ( op2 == 1 )
      {
      SET_OF(new_of);
      }
   else
      {
      do_multiple_shiftrot_of(new_of);
      }

   *pop1 = result;	/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\rol.h ===
/* 
   rol.h

   Define all ROL CPU functions.
 */

/*
   static char SccsID[]="@(#)rol.h	1.4 02/09/94";
 */

IMPORT VOID ROL
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ror.c ===
/*[

ror.c

LOCAL CHAR SccsID[]="@(#)ror.c	1.5 02/09/94";

ROR CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <ror.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'ror'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
ROR
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IU32, op2,	/* rotation count operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 feedback;		/* Bit posn to feed Bit 0 back to */
   ISM32 i;
   ISM32 new_of;

   /* only use lower five bits of count */
   if ( (op2 &= 0x1f) == 0 )
      return;

   /*
	    =================         ====
	 -> | | | | | | | | | --- --> |CF|
	 |  =================   |     ====
	 ------------------------
    */
   feedback = SZ2MSB(op_sz);
   for ( result = *pop1, i = 0; i < op2; i++ )
      {
      if ( result & BIT0_MASK )
	 {
	 result = result >> 1 | feedback;
	 SET_CF(1);
	 }
      else
	 {
	 result >>= 1;
	 SET_CF(0);
	 }
      }
   
   /* OF = MSB of result ^ (MSB-1) of result */
   new_of = ((result ^ result << 1) & feedback) != 0;

   if ( op2 == 1 )
      {
      SET_OF(new_of);
      }
   else
      {
      do_multiple_shiftrot_of(new_of);
      }

   *pop1 = result;	/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\ror.h ===
/* 
   ror.h

   Define all ROR CPU functions.
 */

/*
   static char SccsID[]="@(#)ror.h	1.4 02/09/94";
 */

IMPORT VOID ROR
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\rsrvd.c ===
/*[

rsrvd.c

LOCAL CHAR SccsID[]="@(#)rsrvd.c	1.5 02/09/94";

Reserved CPU Functions.
-----------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <rsrvd.h>

/*
   =====================================================================
   EXECUTION STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Reserved opcode.                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
VOID
RSRVD()
   {
   /*
      Reserved operation - nothing to do.
      In particular reserved opcodes do not cause Int6 exceptions.
      0f 07, 0f 10, 0f 11, 0f 12, 0f 13 are known to be reserved.
    */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sahf.h ===
/* 
   sahf.h

   Define all SAHF CPU functions.
 */

/*
   static char SccsID[]="@(#)sahf.h	1.5 09/01/94";
 */

IMPORT VOID SAHF IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sar.h ===
/* 
   sar.h

   Define all SAR CPU functions.
 */

/*
   static char SccsID[]="@(#)sar.h	1.4 02/09/94";
 */

IMPORT VOID SAR
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\rsrvd.h ===
/* 
   rsrvd.h

   Define Reserved CPU functions.
 */

/*
   static char SccsID[]="@(#)rsrvd.h	1.5 09/01/94";
 */

IMPORT VOID RSRVD IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sascdef.c ===
/*[
 * Generated File: sasCdef.c
 *
]*/

#include	"insignia.h"
#include	"host_inc.h"
#include	"host_def.h"
#include	"Fpu_c.h"
#include	"PigReg_c.h"
#include	"Univer_c.h"
#define	CPU_PRIVATE
#include	"cpu4.h"
#include	"gdpvar.h"
#include	"sas.h"
#include	"evidgen.h"

#include	<stdio.h>
GLOBAL void SasAccessProblem IFN0()
{
	fprintf(stderr, "Sas used at illegal time\n");
}

extern TYPE_sas_memory_size c_sas_memory_size;
extern TYPE_sas_connect_memory c_sas_connect_memory;
extern TYPE_sas_enable_20_bit_wrapping c_sas_enable_20_bit_wrapping;
extern TYPE_sas_disable_20_bit_wrapping c_sas_disable_20_bit_wrapping;
extern TYPE_sas_twenty_bit_wrapping_enabled c_sas_twenty_bit_wrapping_enabled;
extern TYPE_sas_memory_type c_sas_memory_type;
extern TYPE_sas_hw_at c_sas_hw_at;
extern TYPE_sas_w_at c_sas_w_at;
extern TYPE_sas_dw_at c_sas_dw_at;
extern TYPE_sas_hw_at_no_check c_sas_hw_at;
extern TYPE_sas_w_at_no_check c_sas_w_at;
extern TYPE_sas_dw_at_no_check c_sas_dw_at;
extern TYPE_sas_store c_sas_store;
extern TYPE_sas_storew c_sas_storew;
extern TYPE_sas_storedw c_sas_storedw;
extern TYPE_sas_store_no_check c_sas_store;
extern TYPE_sas_storew_no_check c_sas_storew;
extern TYPE_sas_storedw_no_check c_sas_storedw;
extern TYPE_sas_loads c_sas_loads;
extern TYPE_sas_stores c_sas_stores;
extern TYPE_sas_loads_no_check c_sas_loads_no_check;
extern TYPE_sas_stores_no_check c_sas_stores_no_check;
extern TYPE_sas_move_bytes_forward c_sas_move_bytes_forward;
extern TYPE_sas_move_words_forward c_sas_move_words_forward;
extern TYPE_sas_move_doubles_forward c_sas_move_doubles_forward;
extern TYPE_sas_move_bytes_backward c_sas_move_bytes_backward;
extern TYPE_sas_move_words_backward c_sas_move_words_backward;
extern TYPE_sas_move_doubles_backward c_sas_move_doubles_backward;
extern TYPE_sas_fills c_sas_fills;
extern TYPE_sas_fillsw c_sas_fillsw;
extern TYPE_sas_fillsdw c_sas_fillsdw;
extern TYPE_sas_scratch_address c_sas_scratch_address;
extern TYPE_sas_transbuf_address c_sas_transbuf_address;
extern TYPE_sas_loads_to_transbuf c_sas_loads;
extern TYPE_sas_stores_from_transbuf c_sas_stores;
extern TYPE_sas_PR8 phy_r8;
extern TYPE_sas_PR16 phy_r16;
extern TYPE_sas_PR32 phy_r32;
extern TYPE_sas_PW8 phy_w8;
extern TYPE_sas_PW16 phy_w16;
extern TYPE_sas_PW32 phy_w32;
extern TYPE_sas_PW8_no_check phy_w8_no_check;
extern TYPE_sas_PW16_no_check phy_w16_no_check;
extern TYPE_sas_PW32_no_check phy_w32_no_check;
extern TYPE_getPtrToPhysAddrByte c_GetPhyAdd;
extern TYPE_get_byte_addr c_get_byte_addr;
extern TYPE_getPtrToLinAddrByte c_GetLinAdd;
extern TYPE_sas_init_pm_selectors c_SasRegisterVirtualSelectors;
extern TYPE_sas_PWS c_sas_PWS;
extern TYPE_sas_PWS_no_check c_sas_PWS_no_check;
extern TYPE_sas_PRS c_sas_PRS;
extern TYPE_sas_PRS_no_check c_sas_PRS_no_check;
extern TYPE_sas_PigCmpPage c_sas_PigCmpPage;
extern TYPE_sas_touch c_sas_touch;
extern TYPE_IOVirtualised c_IOVirtualised;
extern TYPE_VirtualiseInstruction c_VirtualiseInstruction;


struct SasVector cSasPtrs = {
	c_sas_memory_size,
	c_sas_connect_memory,
	c_sas_enable_20_bit_wrapping,
	c_sas_disable_20_bit_wrapping,
	c_sas_twenty_bit_wrapping_enabled,
	c_sas_memory_type,
	c_sas_hw_at,
	c_sas_w_at,
	c_sas_dw_at,
	c_sas_hw_at,
	c_sas_w_at,
	c_sas_dw_at,
	c_sas_store,
	c_sas_storew,
	c_sas_storedw,
	c_sas_store,
	c_sas_storew,
	c_sas_storedw,
	c_sas_loads,
	c_sas_stores,
	c_sas_loads_no_check,
	c_sas_stores_no_check,
	c_sas_move_bytes_forward,
	c_sas_move_words_forward,
	c_sas_move_doubles_forward,
	c_sas_move_bytes_backward,
	c_sas_move_words_backward,
	c_sas_move_doubles_backward,
	c_sas_fills,
	c_sas_fillsw,
	c_sas_fillsdw,
	c_sas_scratch_address,
	c_sas_transbuf_address,
	c_sas_loads,
	c_sas_stores,
	phy_r8,
	phy_r16,
	phy_r32,
	phy_w8,
	phy_w16,
	phy_w32,
	phy_w8_no_check,
	phy_w16_no_check,
	phy_w32_no_check,
	c_GetPhyAdd,
	c_get_byte_addr,
	c_GetLinAdd,
	c_SasRegisterVirtualSelectors,
	(void (*)()) 0,
	c_sas_PWS,
	c_sas_PWS_no_check,
	c_sas_PRS,
	c_sas_PRS_no_check,
	c_sas_PigCmpPage,
	c_sas_touch,
	c_IOVirtualised,
	c_VirtualiseInstruction
};

/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sahf.c ===
/*[

sahf.c

LOCAL CHAR SccsID[]="@(#)sahf.c	1.5 02/09/94";

SAHF CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <sahf.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
SAHF()
   {
   IU32 temp;

   /*        7   6   5   4   3   2   1   0  */
   /* AH = <SF><ZF><xx><AF><xx><PF><xx><CF> */

   temp = GET_AH();
   SET_SF((temp & BIT7_MASK) != 0);
   SET_ZF((temp & BIT6_MASK) != 0);
   SET_AF((temp & BIT4_MASK) != 0);
   SET_PF((temp & BIT2_MASK) != 0);
   SET_CF((temp & BIT0_MASK) != 0);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sbb.c ===
/*[

sbb.c

LOCAL CHAR SccsID[]="@(#)sbb.c	1.5 02/09/94";

SBB CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <sbb.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'sbb'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SBB
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 carry;
   IU32 msb;
   IU32 op1_msb;
   IU32 op2_msb;
   IU32 res_msb;

   msb = SZ2MSB(op_sz);
   					/* Do operation */
   result = *pop1 - op2 - GET_CF() & SZ2MASK(op_sz);
   op1_msb = (*pop1  & msb) != 0;	/* Isolate all msb's */
   op2_msb = (op2    & msb) != 0;
   res_msb = (result & msb) != 0;
   carry = *pop1 ^ op2 ^ result;	/* Isolate carries */
					/* Determine flags */
   /*
      OF = (op1 == !op2) & (op1 ^ res)
      ie if operand signs differ and res sign different to original
      destination set OF.
    */
   SET_OF((op1_msb != op2_msb) & (op1_msb ^ res_msb));
   /*
      Formally:-     CF = !op1 & op2 | res & !op1 | res & op2
      Equivalently:- CF = OF ^ op1 ^ op2 ^ res
    */
   SET_CF(((carry & msb) != 0) ^ GET_OF());
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */
   SET_AF((carry & BIT4_MASK) != 0);	/* AF = Bit 4 carry */
   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sar.c ===
/*[

sar.c

LOCAL CHAR SccsID[]="@(#)sar.c	1.5 02/09/94";

SAR CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <sar.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'sar'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SAR
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IU32, op2,	/* shift count operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 prelim;
   IU32 result;
   IU32 feedback;
   ISM32 i;

   /* only use lower five bits of count */
   if ( (op2 &= 0x1f) == 0 )
      return;

   /*
	     =================     ====
	 --> | | | | | | | | | --> |CF|
	 |   =================     ====
	 ---- |
    */
   prelim = *pop1;			/* Initialise */
   feedback = prelim & SZ2MSB(op_sz);	/* Determine MSB */
   for ( i = 0; i < (op2 - 1); i++ )	/* Do all but last shift */
      {
      prelim = prelim >> 1 | feedback;
      }
   SET_CF((prelim & BIT0_MASK) != 0);	/* CF = Bit 0 */
   result = prelim >> 1 | feedback;	/* Do final shift */
   SET_OF(0);
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF(feedback != 0);		/* SF = MSB */

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_AF(UNDEFINED_FLAG);
#endif

   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sbb.h ===
/* 
   sbb.h

   Define all SBB CPU functions.
 */

/*
   static char SccsID[]="@(#)sbb.h	1.4 02/09/94";
 */

IMPORT VOID SBB
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\setxx.c ===
/*[

setxx.c

LOCAL CHAR SccsID[]="@(#)setxx.c	1.5 02/09/94";

SETxx CPU functions (Byte Set on Condition).
--------------------------------------------

All these functions return 1 if the condition is true, else 0.

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <setxx.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Below (CF=1)                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETB
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_CF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Below or Equal (CF=1 || ZF=1)                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETBE
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_CF() || GET_ZF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Less (SF != OF)                                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETL
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_SF() != GET_OF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Less or Equal (ZF=1 || (SF != OF))                     */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETLE
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_SF() != GET_OF() || GET_ZF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Not Below (CF=0)                                       */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETNB
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = !GET_CF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Not Below or Equal (CF=0 && ZF=0)                      */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETNBE
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = !GET_CF() && !GET_ZF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Not Less (SF==OF)                                      */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETNL
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_SF() == GET_OF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Not Less or Equal (ZF=0 && (SF==OF))                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETNLE
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_SF() == GET_OF() && !GET_ZF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Not Overflow (OF=0)                                    */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETNO
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = !GET_OF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Not Parity (PF=0)                                      */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETNP
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = !GET_PF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Not Sign (SF=0)                                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETNS
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = !GET_SF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Not Zero (ZF=0)                                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETNZ
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = !GET_ZF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Overflow (OF=1)                                        */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETO
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_OF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Parity (PF=1)                                          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETP
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_PF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Sign (SF=1)                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETS
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_SF();
   }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Set Byte if Zero (ZF=1)                                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SETZ
       	          
IFN1(
	IU32 *, pop1	/* pntr to dst operand */
    )


   {
   *pop1 = GET_ZF();
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\setxx.h ===
/* 
   setxx.h

   SETxx CPU functions.
 */

/*
   static char SccsID[]="@(#)setxx.h	1.4 02/09/94";
 */

IMPORT VOID SETB
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETBE
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETL
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETLE
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETNB
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETNBE
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETNL
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETNLE
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETNO
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETNP
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETNS
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETNZ
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETO
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETP
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETS
       
IPT1(
	IU32 *, pop1

   );

IMPORT VOID SETZ
       
IPT1(
	IU32 *, pop1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\shl.h ===
/* 
   shl.h

   Define all SHL CPU functions.
 */

/*
   static char SccsID[]="@(#)shl.h	1.4 02/09/94";
 */

IMPORT VOID SHL
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\shl.c ===
/*[

shl.c

LOCAL CHAR SccsID[]="@(#)shl.c	1.5 02/09/94";

SHL CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <shl.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'shl'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SHL
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IU32, op2,	/* shift count operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 msb;
   ISM32 new_of;

   /* only use lower five bits of count */
   if ( (op2 &= 0x1f) == 0 )
      return;

   msb = SZ2MSB(op_sz);

   /*
	 ====     =================
	 |CF| <-- | | | | | | | | | <-- 0
	 ====     =================
    */
   result = *pop1 << op2 - 1;		/* Do all but last shift */
   SET_CF((result & msb) != 0);		/* CF = MSB */
   result = result << 1 & SZ2MASK(op_sz);	/* Do final shift */
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */

   /* OF = CF ^ SF(MSB) */
   new_of = GET_CF() ^ GET_SF();
   
   if ( op2 == 1 )
      {
      SET_OF(new_of);
      }
   else
      {
      do_multiple_shiftrot_of(new_of);
      }

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_AF(UNDEFINED_FLAG);
#endif

   *pop1 = result;	/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\shld.h ===
/* 
   shld.h

   SHLD CPU functions.
 */

/*
   static char SccsID[]="@(#)shld.h	1.4 02/09/94";
 */

IMPORT VOID SHLD
                   
IPT4(
	IU32 *, pop1,
	IU32, op2,
	IU32, op3,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sgdt.h ===
/* 
   sgdt.h

   Define all SGDT CPU functions.
 */

/*
   static char SccsID[]="@(#)sgdt.h	1.4 02/09/94";
 */

IMPORT VOID SGDT16
       
IPT1(
	IU32, op1[2]

   );

IMPORT VOID SGDT32
       
IPT1(
	IU32, op1[2]

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sgdt.c ===
/*[

sgdt.c

LOCAL CHAR SccsID[]="@(#)sgdt.c	1.5 02/09/94";

SGDT CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <sgdt.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
SGDT16
#ifdef ANSI
   (
   IU32 op1[2]	/* dst (limit:base pair) operand */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   /*
      NB. The Intel manual says the top 8-bits will be stored as zero's,
      I think they mean this only if it was loaded with a 24-bit (286
      like) value. Otherwise it just stores what was loaded.
      It might be that it always stores 'FF' like 286, this needs
      checking.
    */
	op1[0] = GET_STAR_LIMIT(GDT_REG);
	op1[1] = GET_STAR_BASE(GDT_REG);
   }

GLOBAL VOID
SGDT32
#ifdef ANSI
   (
   IU32 op1[2]	/* dst (limit:base pair) operand */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   op1[0] = GET_STAR_LIMIT(GDT_REG);
   op1[1] = GET_STAR_BASE(GDT_REG);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\shld.c ===
/*[

shld.c

LOCAL CHAR SccsID[]="@(#)shld.c	1.6 09/02/94";

SHLD CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <shld.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'shld'.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SHLD
       	    	    	    	                         
IFN4(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IU32, op3,	/* shift count operand */
	IUM8, op_sz	/* 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 msb;
   ISM32 new_of;

   /* only use lower five bits of count, ie modulo 32 */
   if ( (op3 &= 0x1f) == 0 )
      return;

   /*
      NB. Intel doc. says that if op3 >= op_sz then the operation
      is undefined. In practice if op_sz is 32 then as op3 is taken
      modulo 32 it can never be in the undefined range and if op_sz
      is 16 the filler bits from op2 are 'recycled' for counts of 16
      and above.
    */

   /*
	 ====     =================     =================
	 |CF| <-- | | | |op1| | | | <-- | | | |op2| | | |
	 ====     =================     =================
    */

   if ( op_sz == 16 )
      {
      op2 = op2 << 16 | op2;	/* Double up filler bits */
      }

   /* Do all but last shift */
   op3 = op3 - 1;	/* op3 now in range 0 - 30 */
   if ( op3 != 0 )
      {
      result = *pop1 << op3 | op2 >> 32-op3;
      op2 = op2 << op3;
      }
   else
      {
      result = *pop1;
      }

   /* Last shift will put MSB into carry */
   msb = SZ2MSB(op_sz);
   SET_CF((result & msb) != 0);

   /* Now do final shift */
   result = result << 1 | op2 >> 31;
   result = result & SZ2MASK(op_sz);

   SET_PF(pf_table[result & 0xff]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);

   /* OF set if sign changes */
   new_of = GET_CF() ^ GET_SF();
   
   if ( op3 == 0 )   /* NB Count has been decremented! */
      {
      SET_OF(new_of);
      }
   else
      {
#ifdef SET_UNDEFINED_SHxD_FLAG
      /* Set OF to changed  SF(original) and SF(result) */
      new_of = ((result ^ *pop1) & SZ2MSB(op_sz)) != 0;
      SET_OF(new_of);
#else /* SET_UNDEFINED_SHxD_FLAG */
      do_multiple_shiftrot_of(new_of);
#endif /* SET_UNDEFINED_SHxD_FLAG */
      }

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_AF(UNDEFINED_FLAG);
#endif

   *pop1 = result;	/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\shr.c ===
/*[

shr.c

LOCAL CHAR SccsID[]="@(#)shr.c	1.5 02/09/94";

SHR CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <shr.h>

/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'shr'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SHR
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/src operand */
	IU32, op2,	/* shift count operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 prelim;
   IU32 result;
   ISM32 new_of;

   /* only use lower five bits of count */
   if ( (op2 &= 0x1f) == 0 )
      return;

   /*
	       =================     ====
	 0 --> | | | | | | | | | --> |CF|
	       =================     ====
    */
   prelim = *pop1 >> op2 - 1;		/* Do all but last shift */
   SET_CF((prelim & BIT0_MASK) != 0);	/* CF = Bit 0 */

   /* OF = MSB of operand */
   new_of = (prelim & SZ2MSB(op_sz)) != 0;

   result = prelim >> 1;		/* Do final shift */
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF(0);

   if ( op2 == 1 )
      {
      SET_OF(new_of);
      }
   else
      {
      do_multiple_shiftrot_of(new_of);
      }

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_AF(UNDEFINED_FLAG);
#endif

   *pop1 = result;		/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\shr.h ===
/* 
   shr.h

   Define all SHR CPU functions.
 */

/*
   static char SccsID[]="@(#)shr.h	1.4 02/09/94";
 */

IMPORT VOID SHR
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\shrd.h ===
/* 
   shrd.h

   SHRD CPU functions.
 */

/*
   static char SccsID[]="@(#)shrd.h	1.4 02/09/94";
 */

IMPORT VOID SHRD
                   
IPT4(
	IU32 *, pop1,
	IU32, op2,
	IU32, op3,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\shrd.c ===
/*[

shrd.c

LOCAL CHAR SccsID[]="@(#)shrd.c	1.6 09/02/94";

SHRD CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <shrd.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'shrd'.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SHRD
       	    	    	    	                         
IFN4(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IU32, op3,	/* shift count operand */
	IUM8, op_sz	/* 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 msb;
   ISM32 new_of;

   /* only use lower five bits of count */
   if ( (op3 &= 0x1f) == 0 )
      return;

   /*
      NB. Intel doc. says that if op3 >= op_sz then the operation
      is undefined. In practice if op_sz is 32 then as op3 is taken
      modulo 32 it can never be in the undefined range and if op_sz
      is 16 the filler bits from op2 are 'recycled' for counts of 16
      and above.
    */

   /*
	 =================     =================     ====
	 | | | |op2| | | | --> | | | |op1| | | | --> |CF|
	 =================     =================     ====
    */

   if ( op_sz == 16 )
      {
      *pop1 = op2 << 16 | *pop1;	/* Double up filler bits */
      }

   /* Do all but last shift */
   op3 = op3 - 1;	/* op3 now in range 0 - 30 */
   if ( op3 != 0 )
      {
      result = *pop1 >> op3 | op2 << 32-op3;
      op2 = op2 >> op3;
      }
   else
      {
      result = *pop1;
      }

   SET_CF((result & BIT0_MASK) != 0);	/* last shift puts LSB in CF */

   /* save msb */
   msb = SZ2MSB(op_sz);
   msb = (result & msb) != 0;

   /* Now do final shift */
   result = result >> 1 | op2 << 31;
   result = result & SZ2MASK(op_sz);

   SET_PF(pf_table[result & 0xff]);
   SET_ZF(result == 0);
   SET_SF((result & SZ2MSB(op_sz)) != 0);

   /* set OF if sign changes */
   new_of = msb ^ GET_SF();
   
   if ( op3 == 0 )   /* NB Count has been decremented! */
      {
      SET_OF(new_of);
      }
   else
      {
#ifdef SET_UNDEFINED_SHxD_FLAG
      /* Set OF to changed  SF(original) and SF(result) */
      new_of = ((result ^ *pop1) & SZ2MSB(op_sz)) != 0;
      SET_OF(new_of);
#else /* SET_UNDEFINED_SHxD_FLAG */
      do_multiple_shiftrot_of(new_of);
#endif /* SET_UNDEFINED_SHxD_FLAG */
      }

   /* Set undefined flag(s) */
#ifdef SET_UNDEFINED_FLAG
   SET_AF(UNDEFINED_FLAG);
#endif

   *pop1 = result;	/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sidt.h ===
/* 
   sidt.h

   Define all SIDT CPU functions.
 */

/*
   static char SccsID[]="@(#)sidt.h	1.4 02/09/94";
 */

IMPORT VOID SIDT16
       
IPT1(
	IU32, op1[2]

   );

IMPORT VOID SIDT32
       
IPT1(
	IU32, op1[2]

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sldt.c ===
/*[

sldt.c

LOCAL CHAR SccsID[]="@(#)sldt.c	1.5 02/09/94";

SLDT CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <sldt.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
SLDT
                 
IFN1(
	IU32 *, pop1
    )


   {
   *pop1 = GET_LDT_SELECTOR();
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sldt.h ===
/* 
   sldt.h

   Define all SLDT CPU functions.
 */

/*
   static char SccsID[]="@(#)sldt.h	1.4 02/09/94";
 */

IMPORT VOID SLDT
       
IPT1(
	IU32 *, pop1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\smsw.h ===
/* 
   smsw.h

   Define all SMSW CPU functions.
 */

/*
   static char SccsID[]="@(#)smsw.h	1.4 02/09/94";
 */

IMPORT VOID SMSW
       
IPT1(
	IU32 *, pop1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\smsw.c ===
/*[

smsw.c

LOCAL CHAR SccsID[]="@(#)smsw.c	1.5 02/09/94";

SMSW CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <smsw.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */

GLOBAL VOID
SMSW
                 
IFN1(
	IU32 *, pop1
    )

   {
	*pop1 = GET_MSW();
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sidt.c ===
/*[

sidt.c

LOCAL CHAR SccsID[]="@(#)sidt.c	1.5 02/09/94";

SIDT CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <sidt.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
SIDT16
#ifdef ANSI
   (
   IU32 op1[2]	/* dst (limit:base pair) operand */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   /*
      NB. The Intel manual says the top 8-bits will be stored as zero's,
      I think they mean this only if it was loaded with a 24-bit (286
      like) value. Otherwise it just stores what was loaded.
      It might be that it always stores 'FF' like 286, this needs
      checking.
    */

	op1[0] = GET_STAR_LIMIT(IDT_REG);
	op1[1] = GET_STAR_BASE(IDT_REG);
   }

GLOBAL VOID
SIDT32
#ifdef ANSI
   (
   IU32 op1[2]	/* dst (limit:base pair) operand */
   )
#else
   (op1)
   IU32 op1[2];
#endif
   {
   op1[0] = GET_STAR_LIMIT(IDT_REG);
   op1[1] = GET_STAR_BASE(IDT_REG);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\stc.c ===
/*[

stc.c

LOCAL CHAR SccsID[]="@(#)stc.c	1.5 02/09/94";

STC CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <stc.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
STC()
   {
   SET_CF(1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\stc.h ===
/* 
   stc.h

   Define all STC CPU functions.
 */

/*
   static char SccsID[]="@(#)stc.h	1.5 09/01/94";
 */

IMPORT VOID STC IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\std.c ===
/*[

std.c

LOCAL CHAR SccsID[]="@(#)std.c	1.5 02/09/94";

STD CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <std.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
STD()
   {
   SET_DF(1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\std.h ===
/* 
   std.h

   Define all STD CPU functions.
 */

/*
   static char SccsID[]="@(#)std.h	1.5 09/01/94";
 */

IMPORT VOID STD IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\str.c ===
/*[

str.c

LOCAL CHAR SccsID[]="@(#)str.c	1.5 02/09/94";

STR CPU Functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <str.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
STR
                 
IFN1(
	IU32 *, pop1
    )


   {
   *pop1 = GET_TR_SELECTOR();
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\str.h ===
/* 
   str.h

   Define all STR CPU functions.
 */

/*
   static char SccsID[]="@(#)str.h	1.4 02/09/94";
 */

IMPORT VOID STR
       
IPT1(
	IU32 *, pop1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sti.c ===
/*[

sti.c

LOCAL CHAR SccsID[]="@(#)sti.c	1.5 02/09/94";

STI CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <sti.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
STI()
   {
   SET_IF(1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\stubs.c ===
#include "insignia.h"
#include "host_def.h"

/*	@(#)stubs.c	1.1 06/26/94

	Stubs file for Prod Ccpu (Ccpu too hard to deyodarise)
*/

void	check_I	IFN0()
{
}

void	check_D	IFN0()
{
}

void	force_yoda()
{
}

IBOOL	do_condition_checks = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sti.h ===
/* 
   sti.h

   Define all STI CPU functions.
 */

/*
   static char SccsID[]="@(#)sti.h	1.5 09/01/94";
 */

IMPORT VOID STI IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sub.h ===
/* 
   sub.h

   Define all SUB CPU functions.
 */

/*
   static char SccsID[]="@(#)sub.h	1.4 02/09/94";
 */

IMPORT VOID SUB
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\sub.c ===
/*[

sub.c

LOCAL CHAR SccsID[]="@(#)sub.c	1.5 02/09/94";

SUB CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <sub.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'sub'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
SUB
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;
   IU32 carry;
   IU32 msb;
   IU32 op1_msb;
   IU32 op2_msb;
   IU32 res_msb;

   msb = SZ2MSB(op_sz);

   result = *pop1 - op2 & SZ2MASK(op_sz);	/* Do operation */
   op1_msb = (*pop1  & msb) != 0;	/* Isolate all msb's */
   op2_msb = (op2    & msb) != 0;
   res_msb = (result & msb) != 0;
   carry = *pop1 ^ op2 ^ result;	/* Isolate carries */
					/* Determine flags */
   /*
      OF = (op1 == !op2) & (op1 ^ res)
      ie if operand signs differ and res sign different to original
      destination set OF.
    */
   SET_OF((op1_msb != op2_msb) & (op1_msb ^ res_msb));
   /*
      Formally:-     CF = !op1 & op2 | res & !op1 | res & op2
      Equivalently:- CF = OF ^ op1 ^ op2 ^ res
    */
   SET_CF(((carry & msb) != 0) ^ GET_OF());
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & msb) != 0);		/* SF = MSB */
   SET_AF((carry & BIT4_MASK) != 0);	/* AF = Bit 4 carry */
   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\test.c ===
/*[

test.c

LOCAL CHAR SccsID[]="@(#)test.c	1.5 02/09/94";

TEST CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <test.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'test'.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
TEST
       	    	    	                    
IFN3(
	IU32, op1,	/* lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;

   result = op1 & op2;			/* Do operation */
   SET_CF(0);				/* Determine flags */
   SET_OF(0);
   SET_AF(0);
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & SZ2MSB(op_sz)) != 0);	/* SF = MSB */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\univer_c.h ===
#ifndef _Univer_c_h
#define _Univer_c_h
#define ImpossibleConstraint (-1)
#endif /* ! _Univer_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\test.h ===
/* 
   test.h

   Define all Arithmetic/Logical CPU functions.
 */

/*
   static char SccsID[]="@(#)test.h	1.4 02/09/94";
 */

IMPORT VOID TEST
               
IPT3(
	IU32, op1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\verr.c ===
/*[

verr.c

LOCAL CHAR SccsID[]="@(#)verr.c	1.5 02/09/94";

VERR CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <verr.h>
#include <c_page.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
VERR
       	          
IFN1(
	IU32, op1	/* src(selector) operand */
    )


   {
   BOOL readable = FALSE;
   IU32 descr;
   IU8 AR;

   if ( !selector_outside_GDT_LDT((IU16)op1, &descr) )
      {
      /* get access rights */
      AR = spr_read_byte(descr+5);

      /* Handle each type of descriptor */
      switch ( descriptor_super_type((IU16)AR) )
	 {
      case INVALID:
      case AVAILABLE_TSS:
      case LDT_SEGMENT:
      case BUSY_TSS:
      case CALL_GATE:
      case TASK_GATE:
      case INTERRUPT_GATE:
      case TRAP_GATE:
      case XTND_AVAILABLE_TSS:
      case XTND_BUSY_TSS:
      case XTND_CALL_GATE:
      case XTND_INTERRUPT_GATE:
      case XTND_TRAP_GATE:
      case CONFORM_NOREAD_CODE:
      case NONCONFORM_NOREAD_CODE:
	 break;   /* never readable */
      
      case CONFORM_READABLE_CODE:
	 readable = TRUE;   /* always readable */
	 break;
      
      case EXPANDUP_READONLY_DATA:
      case EXPANDUP_WRITEABLE_DATA:
      case EXPANDDOWN_READONLY_DATA:
      case EXPANDDOWN_WRITEABLE_DATA:
      case NONCONFORM_READABLE_CODE:
	 /* access depends on privilege, it is required that
	    DPL >= CPL and DPL >= RPL */
	 if ( GET_AR_DPL(AR) >= GET_CPL() &&
	      GET_AR_DPL(AR) >= GET_SELECTOR_RPL(op1) )
	    readable = TRUE;
	 break;
	 }
      }

   if ( readable )
      {
      SET_ZF(1);
      }
   else
      {
      SET_ZF(0);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\verw.c ===
/*[

verw.c

LOCAL CHAR SccsID[]="@(#)verw.c	1.5 02/09/94";

VERW CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <verw.h>
#include <c_page.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
VERW
       	          
IFN1(
	IU32, op1	/* src(selector) operand */
    )


   {
   BOOL writeable = FALSE;
   IU32 descr;
   IU8 AR;

   if ( !selector_outside_GDT_LDT((IU16)op1, &descr) )
      {
      /* get access rights */
      AR = spr_read_byte(descr+5);

      switch ( descriptor_super_type((IU16)AR) )
	 {
      case INVALID:
      case AVAILABLE_TSS:
      case LDT_SEGMENT:
      case BUSY_TSS:
      case CALL_GATE:
      case TASK_GATE:
      case INTERRUPT_GATE:
      case TRAP_GATE:
      case XTND_AVAILABLE_TSS:
      case XTND_BUSY_TSS:
      case XTND_CALL_GATE:
      case XTND_INTERRUPT_GATE:
      case XTND_TRAP_GATE:
      case CONFORM_NOREAD_CODE:
      case CONFORM_READABLE_CODE:
      case NONCONFORM_NOREAD_CODE:
      case NONCONFORM_READABLE_CODE:
      case EXPANDUP_READONLY_DATA:
      case EXPANDDOWN_READONLY_DATA:
	 break;   /* never writeable */

      case EXPANDUP_WRITEABLE_DATA:
      case EXPANDDOWN_WRITEABLE_DATA:
	 /* access depends on privilege, it is required that
	       DPL >= CPL and DPL >= RPL */
	 if ( GET_AR_DPL(AR) >= GET_CPL() &&
	      GET_AR_DPL(AR) >= GET_SELECTOR_RPL(op1) )
	    writeable = TRUE;
	 break;
	 }
      }

   if ( writeable )
      {
      SET_ZF(1);
      }
   else
      {
      SET_ZF(0);
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\verr.h ===
/* 
   verr.h

   Define all VERR CPU functions.
 */

/*
   static char SccsID[]="@(#)verr.h	1.4 02/09/94";
 */

IMPORT VOID VERR
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\verw.h ===
/* 
   verw.h

   Define all VERW CPU functions.
 */

/*
   static char SccsID[]="@(#)verw.h	1.4 02/09/94";
 */

IMPORT VOID VERW
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\wait.c ===
/*[

wait.c

LOCAL CHAR SccsID[]="@(#)wait.c	1.5 02/09/94";

WAIT CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <wait.h>


/*
   =====================================================================
   EXTERNAL ROUTINES STARTS HERE.
   =====================================================================
 */


GLOBAL VOID
WAIT()
   {
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\wait.h ===
/* 
   wait.h

   Define all WAIT CPU functions.
 */

/*
   static char SccsID[]="@(#)wait.h	1.5 09/01/94";
 */

IMPORT VOID WAIT IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\wbinvd.c ===
/*[

wbinvd.c

LOCAL CHAR SccsID[]="@(#)wbinvd.c	1.5 02/09/94";

WBINVD CPU Functions.
---------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <wbinvd.h>

/*
   =====================================================================
   EXECUTION STARTS HERE.
   =====================================================================
 */


#ifdef SPC486

VOID
WBINVD()
   {
   /*
      If cache is implemented - then make call to flush cache.
      flush_cache();
    */
   }

#endif /* SPC486 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\vglob.c ===
/*[
*************************************************************************

	Name:		Vglob.c
	Author:		Simon Frost
	Created:	October 1994
	Derived from:	Vglob.edl
	Sccs ID:	@(#)Vglob.c	1.1 10/24/94
	Purpose:	EXTERNAL interface to VGLOB record.
			Rewritten in C to save overhead of EDL/C context change
			for one memory read/write.

	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.

*************************************************************************
]*/

#include "insignia.h"
#include "host_def.h"
#include "Evid_c.h"
#include "gdpvar.h"

/*
 * Note: no interfaces produced for the following 3.0 VGlob entries as
 * unused in Evid.
 *      copy_func_pbp	( now video_base_lin_addr )
 *      route_reg1
 *      route_reg2
 */

/* {get,set}Videolatches still in EvPtrs.edl as required for pigging */

GLOBAL void
setVideorplane IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.VGA_rplane = value;
}
GLOBAL IU8 *
getVideorplane IFN0()
{
	return(GLOBAL_VGAGlobals.VGA_rplane);
}

GLOBAL void
setVideowplane IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.VGA_wplane = value;
}
GLOBAL IU8 *
getVideowplane IFN0()
{
	return(GLOBAL_VGAGlobals.VGA_wplane);
}

GLOBAL void
setVideoscratch IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.scratch = value;
}
GLOBAL IU8 *
getVideoscratch IFN0()
{
	return(GLOBAL_VGAGlobals.scratch);
}

GLOBAL void
setVideosr_masked_val IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.sr_masked_val = value;
}
GLOBAL IU32
getVideosr_masked_val IFN0()
{
	return(GLOBAL_VGAGlobals.sr_masked_val);
}

GLOBAL void
setVideosr_nmask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.sr_nmask = value;
}

GLOBAL IU32
getVideosr_nmask IFN0()
{
	return(GLOBAL_VGAGlobals.sr_nmask);
}

GLOBAL void
setVideodata_and_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.data_and_mask = value;
}

GLOBAL IU32
getVideodata_and_mask IFN0()
{
	return(GLOBAL_VGAGlobals.data_and_mask);
}

GLOBAL void
setVideodata_xor_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.data_xor_mask = value;
}
GLOBAL IU32
getVideodata_xor_mask IFN0()
{
	return(GLOBAL_VGAGlobals.data_xor_mask);
}

GLOBAL void
setVideolatch_xor_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.latch_xor_mask = value;
}
GLOBAL IU32
getVideolatch_xor_mask IFN0()
{
	return(GLOBAL_VGAGlobals.latch_xor_mask);
}

GLOBAL void
setVideobit_prot_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.bit_prot_mask = value;
}
GLOBAL IU32
getVideobit_prot_mask IFN0()
{
	return(GLOBAL_VGAGlobals.bit_prot_mask);
}

GLOBAL void
setVideoplane_enable IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.plane_enable = value;
}
GLOBAL IU32
getVideoplane_enable IFN0()
{
	return(GLOBAL_VGAGlobals.plane_enable);
}

GLOBAL void
setVideoplane_enable_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.plane_enable_mask = value;
}
GLOBAL IU32
getVideoplane_enable_mask IFN0()
{
	return(GLOBAL_VGAGlobals.plane_enable_mask);
}

GLOBAL void
setVideosr_lookup IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.sr_lookup = value;
}
GLOBAL IUH *
getVideosr_lookup IFN0()
{
	return(GLOBAL_VGAGlobals.sr_lookup);
}

GLOBAL void
setVideofwd_str_read_addr IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.fwd_str_read_addr = value;
}
GLOBAL IUH *
getVideofwd_str_read_addr IFN0()
{
	return(GLOBAL_VGAGlobals.fwd_str_read_addr);
}

GLOBAL void
setVideobwd_str_read_addr IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.bwd_str_read_addr = value;
}
GLOBAL IUH *
getVideobwd_str_read_addr IFN0()
{
	return(GLOBAL_VGAGlobals.bwd_str_read_addr);
}

GLOBAL void
setVideodirty_total IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.dirty_total = value;
}
GLOBAL IU32
getVideodirty_total IFN0()
{
	return(GLOBAL_VGAGlobals.dirty_total);
}

GLOBAL void
setVideodirty_low IFN1(IS32, value)
{
	GLOBAL_VGAGlobals.dirty_low = value;
}
GLOBAL IS32
getVideodirty_low IFN0()
{
	return(GLOBAL_VGAGlobals.dirty_low);
}

GLOBAL void
setVideodirty_high IFN1(IS32, value)
{
	GLOBAL_VGAGlobals.dirty_high = value;
}
GLOBAL IS32
getVideodirty_high IFN0()
{
	return(GLOBAL_VGAGlobals.dirty_high);
}

GLOBAL void
setVideovideo_copy IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.video_copy = value;
}
GLOBAL IU8 *
getVideovideo_copy IFN0()
{
	return(GLOBAL_VGAGlobals.video_copy);
}

GLOBAL void
setVideomark_byte IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.mark_byte = value;
}
GLOBAL IUH *
getVideomark_byte IFN0()
{
	return(GLOBAL_VGAGlobals.mark_byte);
}

GLOBAL void
setVideomark_word IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.mark_word = value;
}
GLOBAL IUH *
getVideomark_word IFN0()
{
	return(GLOBAL_VGAGlobals.mark_word);
}

GLOBAL void
setVideomark_string IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.mark_string = value;
}
GLOBAL IUH *
getVideomark_string IFN0()
{
	return(GLOBAL_VGAGlobals.mark_string);
}

GLOBAL void
setVideoread_shift_count IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.read_shift_count = value;
}
GLOBAL IU32
getVideoread_shift_count IFN0()
{
	return(GLOBAL_VGAGlobals.read_shift_count);
}

GLOBAL void
setVideoread_mapped_plane IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.read_mapped_plane = value;
}
GLOBAL IU32
getVideoread_mapped_plane IFN0()
{
	return(GLOBAL_VGAGlobals.read_mapped_plane);
}

GLOBAL void
setVideocolour_comp IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.colour_comp = value;
}
GLOBAL IU32
getVideocolour_comp IFN0()
{
	return(GLOBAL_VGAGlobals.colour_comp);
}

GLOBAL void
setVideodont_care IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.dont_care = value;
}
GLOBAL IU32
getVideodont_care IFN0()
{
	return(GLOBAL_VGAGlobals.dont_care);
}

GLOBAL void
setVideov7_bank_vid_copy_off IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.v7_bank_vid_copy_off = value;
}
GLOBAL IU32
getVideov7_bank_vid_copy_off IFN0()
{
	return(GLOBAL_VGAGlobals.v7_bank_vid_copy_off);
}

GLOBAL void
setVideoscreen_ptr IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.screen_ptr = value;
}
GLOBAL IU8 *
getVideoscreen_ptr IFN0()
{
	return(GLOBAL_VGAGlobals.screen_ptr);
}

GLOBAL void
setVideorotate IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.rotate = value;
}
GLOBAL IU32
getVideorotate IFN0()
{
	return(GLOBAL_VGAGlobals.rotate);
}

GLOBAL void
setVideocalc_data_xor IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.calc_data_xor = value;
}
GLOBAL IU32
getVideocalc_data_xor IFN0()
{
	return(GLOBAL_VGAGlobals.calc_data_xor);
}

GLOBAL void
setVideocalc_latch_xor IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.calc_latch_xor = value;
}
GLOBAL IU32
getVideocalc_latch_xor IFN0()
{
	return(GLOBAL_VGAGlobals.calc_latch_xor);
}

GLOBAL void
setVideoread_byte_addr IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.read_byte_addr = value;
}
GLOBAL IUH *
getVideoread_byte_addr IFN0()
{
	return(GLOBAL_VGAGlobals.read_byte_addr);
}

GLOBAL void
setVideov7_fg_latches IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.v7_fg_latches = value;
}
GLOBAL IU32
getVideov7_fg_latches IFN0()
{
	return(GLOBAL_VGAGlobals.v7_fg_latches);
}

GLOBAL void
setVideoGC_regs IFN1(IUH **, value)
{
	GLOBAL_VGAGlobals.GCRegs = value;
}
GLOBAL IUH **
getVideoGC_regs IFN0()
{
	return(GLOBAL_VGAGlobals.GCRegs);
}

GLOBAL void
setVideolast_GC_index IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.lastGCindex = value;
}
GLOBAL IU8
getVideolast_GC_index IFN0()
{
	return(GLOBAL_VGAGlobals.lastGCindex);
}

GLOBAL void
setVideodither IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.dither = value;
}
GLOBAL IU8
getVideodither IFN0()
{
	return(GLOBAL_VGAGlobals.dither);
}

GLOBAL void
setVideowrmode IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.wrmode = value;
}
GLOBAL IU8
getVideowrmode IFN0()
{
	return(GLOBAL_VGAGlobals.wrmode);
}

GLOBAL void
setVideochain IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.chain = value;
}
GLOBAL IU8
getVideochain IFN0()
{
	return(GLOBAL_VGAGlobals.chain);
}

GLOBAL void
setVideowrstate IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.wrstate = value;
}
GLOBAL IU8
getVideowrstate IFN0()
{
	return(GLOBAL_VGAGlobals.wrstate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\wbinvd.h ===
/* 
   wbinvd.h

   Define WBINVD CPU functions.
 */

/*
   static char SccsID[]="@(#)wbinvd.h	1.5 09/01/94";
 */

IMPORT VOID WBINVD IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\xadd.c ===
/*[

xadd.c

LOCAL CHAR SccsID[]="@(#)xadd.c	1.5 02/09/94";

XADD CPU functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <xadd.h>
#include <add.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


#ifdef SPC486

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'xadd'.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
XADD
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32 *, pop2,	/* pntr to dst/rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 temp;

   temp = *pop1;
   ADD(pop1, *pop2, op_sz);
   *pop2 = temp;
   }

#endif /* SPC486 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\xchg.c ===
/*[

xchg.c

LOCAL CHAR SccsID[]="@(#)xchg.c	1.5 02/09/94";

XCHG CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <xchg.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'xchg'.                                */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
XCHG
       	    	               
IFN2(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32 *, pop2	/* pntr to dst/rsrc operand */
    )


   {
   IU32 temp;

   temp = *pop1;
   *pop1 = *pop2;
   *pop2 = temp;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\xadd.h ===
/* 
   xadd.h

   XADD CPU functions.
 */

/*
   static char SccsID[]="@(#)xadd.h	1.4 02/09/94";
 */

IMPORT VOID XADD
               
IPT3(
	IU32 *, pop1,
	IU32 *, pop2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\xchg.h ===
/* 
   xchg.h

   Define all XCHG CPU functions.
 */

/*
   static char SccsID[]="@(#)xchg.h	1.4 02/09/94";
 */

IMPORT VOID XCHG
           
IPT2(
	IU32 *, pop1,
	IU32 *, pop2

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\xlat.h ===
/* 
   xlat.h

   Define all XLAT CPU functions.
 */

/*
   static char SccsID[]="@(#)xlat.h	1.4 02/09/94";
 */

IMPORT VOID XLAT
       
IPT1(
	IU32, op1

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\xlat.c ===
/*[

xlat.c

LOCAL CHAR SccsID[]="@(#)xlat.c	1.5 02/09/94";

XLAT CPU Functions.
-------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <xlat.h>


/*
   =====================================================================
   EXTERNAL ROUTINES START HERE
   =====================================================================
 */


GLOBAL VOID
XLAT
       	          
IFN1(
	IU32, op1	/* src operand */
    )


   {
   SET_AL(op1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\xor.c ===
/*[

xor.c

LOCAL CHAR SccsID[]="@(#)xor.c	1.5 02/09/94";

XOR CPU functions.
------------------

]*/


#include <insignia.h>

#include <host_def.h>
#include <xt.h>
#include <c_main.h>
#include <c_addr.h>
#include <c_bsic.h>
#include <c_prot.h>
#include <c_seg.h>
#include <c_stack.h>
#include <c_xcptn.h>
#include	<c_reg.h>
#include <xor.h>


/*
   =====================================================================
   EXTERNAL FUNCTIONS START HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Generic - one size fits all 'xor'.                                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL VOID
XOR
       	    	    	                    
IFN3(
	IU32 *, pop1,	/* pntr to dst/lsrc operand */
	IU32, op2,	/* rsrc operand */
	IUM8, op_sz	/* 8, 16 or 32-bit */
    )


   {
   IU32 result;

   result = *pop1 ^ op2;		/* Do operation */
   SET_CF(0);				/* Determine flags */
   SET_OF(0);
   SET_AF(0);
   SET_PF(pf_table[result & BYTE_MASK]);
   SET_ZF(result == 0);
   SET_SF((result & SZ2MSB(op_sz)) != 0);	/* SF = MSB */
   *pop1 = result;			/* Return answer */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\xor.h ===
/* 
   xor.h

   Define all XOR CPU functions.
 */

/*
   static char SccsID[]="@(#)xor.h	1.4 02/09/94";
 */

IMPORT VOID XOR
               
IPT3(
	IU32 *, pop1,
	IU32, op2,
	IUM8, op_sz

   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\zfrsrvd.h ===
/* 
   zfrsrvd.h

   Define Reserved Floating Point CPU functions.
 */

/*
   static char SccsID[]="@(#)zfrsrvd.h	1.4 02/09/94";
 */

IMPORT VOID ZFRSRVD
      
IPT1(
	IU32, npxopcode
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\ccpu386\zfrsrvd.c ===
/*[

zfrsrvd.c

LOCAL CHAR SccsID[]="@(#)zfrsrvd.c	1.23 03/28/95";

Reserved Floating Point CPU Functions.
--------------------------------------

]*/
#include <insignia.h>
#include <host_def.h>
#include <cfpu_def.h>
#include <newnpx.h>
#include <debug.h>
#include <xt.h>         /* DESCR and effective_addr support */
#include <sas.h>        /* need memory(M)     */
#define HOOKED_IRETS
#include <ica.h>	/* need NPX interrupt line */
#include <ccpusas4.h>   /* the cpu internal sas bits */
#include <c_main.h>     /* C CPU definitions-interfaces */
#include <c_page.h>     /* Paging Interface */
#include <c_mem.h>      /* CPU - Memory Interface */
#include <c_oprnd.h>
#include <c_reg.h>
#include <c_xcptn.h>	/* Definition of Int16() */
#include <fault.h>
#ifdef SFELLOW
#include <CpuInt_c.h>
#endif	/* SFELLOW */

typedef union
{
IU32 sng;           /* Single Part Operand */
IU32 mlt[2];        /* Multiple (two) Part Operand */
IU8 npxbuff[108];   /* Make it the maximum required size */
} OPERAND;

IMPORT IU8 *Start_of_M_area;
IMPORT PHY_ADDR  Length_of_M_area;
IMPORT ISM32 in_C;
IMPORT IU8 *CCPU_M;
IMPORT IU32 Sas_wrap_mask;
IMPORT IU32 event_counter;
IMPORT IU8 *p;                        /* Pntr. to Intel Opcode Stream. */
IMPORT IU8 *p_start;          /* Pntr. to Start of Intel Opcode Stream. */
IMPORT IU8 opcode;            /* Last Opcode Byte Read. */
IMPORT IU8 modRM;                     /* The modRM byte. */
IMPORT OPERAND ops[3];          /* Inst. Operands. */
IMPORT IU32 save_id[3];                /* Saved state for Inst. Operands. */
IMPORT IU32 m_off[3];          /* Memory Operand offset. */
IMPORT IU32 m_pa[3];
IMPORT IU32 m_la[3];
IMPORT ISM32   m_seg[3];          /* Memory Operand segment reg. index. */
IMPORT BOOL m_isreg[3];                /* Memory Operand Register(true)/
                           Memory(false) indicator */
IMPORT IU8 segment_override;  /* Segment Prefix for current inst. */
IMPORT IU8 repeat;            /* Repeat Prefix for current inst. */
IMPORT IU32 rep_count;         /* Repeat Count for string insts. */
IMPORT IUM32 old_TF;   /* used by POPF and IRET to save Trap Flag */
IMPORT IU32 immed;                     /* For immediate generation. */

IMPORT BOOL POPST;
IMPORT BOOL DOUBLEPOP;
IMPORT BOOL REVERSE;
IMPORT BOOL UNORDERED;
IMPORT BOOL NPX_PROT_MODE;
IMPORT BOOL NPX_ADDRESS_SIZE_32;
IMPORT BOOL NpxException;
IMPORT IU32 NpxLastSel;
IMPORT IU32 NpxLastOff;
IMPORT IU32 NpxFEA;
IMPORT IU32 NpxFDS;
IMPORT IU32 NpxFIP;
IMPORT IU32 NpxFOP;
IMPORT IU32 NpxFCS;
IU16 Ax_regptr;
IMPORT SEGMENT_REGISTER CCPU_SR[6];
IMPORT IU16 *CCPU_WR[8];
IMPORT IU32 CCPU_IP;

LOCAL BOOL DoNpxPrologue IPT0();

LOCAL IU32 NpxInstr;

LOCAL VOID npx_fabs() {
	SAVE_PTRS();
	FABS();
}

LOCAL VOID npx_fadd_f0_f0() {
/* fadd	st,st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f0_f1() {
/* fadd	st,st(1) 	*/
	IU16 src2_index = 1;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f0_f2() {
/* fadd	st,st(2) 	*/
	IU16 src2_index = 2;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f0_f3() {
/* fadd	st,st(3) 	*/
	IU16 src2_index = 3;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f0_f4() {
/* fadd	st,st(4) 	*/
	IU16 src2_index = 4;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f0_f5() {
/* fadd	st,st(5) 	*/
	IU16 src2_index = 5;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f0_f6() {
/* fadd	st,st(6) 	*/
	IU16 src2_index = 6;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f0_f7() {
/* fadd	st,st(7) 	*/
	IU16 src2_index = 7;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f1_f0() {
/* fadd	st(1),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(1, 1, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f2_f0() {
/* fadd	st(2),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(2, 2, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f3_f0() {
/* fadd	st(3),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(3, 3, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f4_f0() {
/* fadd	st(4),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(4, 4, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f5_f0() {
/* fadd	st(5),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(5, 5, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f6_f0() {
/* fadd	st(6),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(6, 6, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_f7_f0() {
/* fadd	st(7),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FADD(7, 7, (VOID *)&src2_index);
}

LOCAL VOID npx_fadd_short() {
/* fadd	DWORD PTR  	*/

	FPtype = M32R;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FADD(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fadd_long() {
/* fadd	QWORD PTR  	*/

	FPtype = M64R;
	D_E08(0, RO0, PG_R);
	F_E08(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FADD(0, 0, &ops[0].npxbuff[0]);
}

LOCAL VOID npx_faddp_f0() {
/* faddp	st(0),st 	*/

	POPST = TRUE;
	npx_fadd_f0_f0();
	POPST = FALSE;
}

LOCAL VOID npx_faddp_f1() {
/* faddp	st(1),st 	*/

	POPST = TRUE;
	npx_fadd_f1_f0();
	POPST = FALSE;
}

LOCAL VOID npx_faddp_f2() {
/* faddp	st(2),st 	*/

	POPST = TRUE;
	npx_fadd_f2_f0();
	POPST = FALSE;
}

LOCAL VOID npx_faddp_f3() {
/* faddp	st(3),st 	*/

	POPST = TRUE;
	npx_fadd_f3_f0();
	POPST = FALSE;
}

LOCAL VOID npx_faddp_f4() {
/* faddp	st(4),st 	*/

	POPST = TRUE;
	npx_fadd_f4_f0();
	POPST = FALSE;
}

LOCAL VOID npx_faddp_f5() {
/* faddp	st(5),st 	*/

	POPST = TRUE;
	npx_fadd_f5_f0();
	POPST = FALSE;
}

LOCAL VOID npx_faddp_f6() {
/* faddp	st(6),st 	*/

	POPST = TRUE;
	npx_fadd_f6_f0();
	POPST = FALSE;
}

LOCAL VOID npx_faddp_f7() {
/* faddp	st(7),st 	*/

	POPST = TRUE;
	npx_fadd_f7_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fbld() {
/* fbld	TBYTE PTR  	*/

	D_E0a(0, RO0, PG_R);
	F_E0a(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FBLD(&ops[0].npxbuff[0]);
}

LOCAL VOID npx_fbstp() {
/* fbstp	TBYTE PTR  	*/

	D_E0a(0, WO0, PG_W);
	SAVE_PTRS();
	SAVE_DPTRS();
	FBSTP(&ops[0].npxbuff[0]);
	P_E0a(0);
}

LOCAL VOID npx_fchs() {
/* fchs		*/

	SAVE_PTRS();
	FCHS();
}

LOCAL VOID npx_fclex() {
/* fclex		*/

	FCLEX();
}

LOCAL VOID npx_fcom_f0() {
/* fcom	st(0) 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FCOM((VOID *)&src2_index);
}

LOCAL VOID npx_fcom_f1() {
/* fcom	st(1) 	*/
	IU16 src2_index = 1;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FCOM((VOID *)&src2_index);
}

LOCAL VOID npx_fcom_f2() {
/* fcom	st(2) 	*/
	IU16 src2_index = 2;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FCOM((VOID *)&src2_index);
}

LOCAL VOID npx_fcom_f3() {
/* fcom	st(3) 	*/
	IU16 src2_index = 3;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FCOM((VOID *)&src2_index);
}

LOCAL VOID npx_fcom_f4() {
/* fcom	st(4) 	*/
	IU16 src2_index = 4;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FCOM((VOID *)&src2_index);
}

LOCAL VOID npx_fcom_f5() {
/* fcom	st(5) 	*/
	IU16 src2_index = 5;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FCOM((VOID *)&src2_index);
}

LOCAL VOID npx_fcom_f6() {
/* fcom	st(6) 	*/
	IU16 src2_index = 6;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FCOM((VOID *)&src2_index);
}

LOCAL VOID npx_fcom_f7() {
/* fcom	st(7) 	*/
	IU16 src2_index = 7;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FCOM((VOID *)&src2_index);
}

LOCAL VOID npx_fcom_short() {
/* fcom	DWORD PTR  	*/

	FPtype = M32R;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FCOM(&ops[0].sng);
}

LOCAL VOID npx_fcom_long() {
/* fcom	QWORD PTR  	*/

	FPtype = M64R;
	D_E08(0, RO0, PG_R);
	F_E08(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FCOM(&ops[0].npxbuff[0]);
}

LOCAL VOID npx_fcomp_f0() {
/* fcomp	st(0) 	*/

	POPST = TRUE;
	npx_fcom_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_f1() {
/* fcomp	st(1) 	*/

	POPST = TRUE;
	npx_fcom_f1();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_f2() {
/* fcomp	st(2) 	*/

	POPST = TRUE;
	npx_fcom_f2();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_f3() {
/* fcomp	st(3) 	*/

	POPST = TRUE;
	npx_fcom_f3();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_f4() {
/* fcomp	st(4) 	*/

	POPST = TRUE;
	npx_fcom_f4();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_f5() {
/* fcomp	st(5) 	*/

	POPST = TRUE;
	npx_fcom_f5();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_f6() {
/* fcomp	st(6) 	*/

	POPST = TRUE;
	npx_fcom_f6();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_f7() {
/* fcomp	st(7) 	*/

	POPST = TRUE;
	npx_fcom_f7();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_short() {
/* fcomp	DWORD PTR  	*/

	POPST = TRUE;
	npx_fcom_short();
	POPST = FALSE;
}

LOCAL VOID npx_fcomp_long() {
/* fcomp	QWORD PTR  	*/

	POPST = TRUE;
	npx_fcom_long();
	POPST = FALSE;
}

LOCAL VOID npx_fcompp() {
/* fcompp		*/

	DOUBLEPOP = TRUE;
	npx_fcom_f1();
	DOUBLEPOP = FALSE;
}

LOCAL VOID npx_fcos() {
/* fcos 		*/

	SAVE_PTRS();
	FCOS();
}

LOCAL VOID npx_fdecstp() {
/* fdecstp		*/

	FDECSTP();
}

LOCAL VOID npx_fdiv_f0_f0() {
/* fdiv	st,st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f0_f1() {
/* fdiv	st,st(1) 	*/
	IU16 src2_index = 1;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f0_f2() {
/* fdiv	st,st(2) 	*/
	IU16 src2_index = 2;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f0_f3() {
/* fdiv	st,st(3) 	*/
	IU16 src2_index = 3;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f0_f4() {
/* fdiv	st,st(4) 	*/
	IU16 src2_index = 4;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f0_f5() {
/* fdiv	st,st(5) 	*/
	IU16 src2_index = 5;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f0_f6() {
/* fdiv	st,st(6) 	*/
	IU16 src2_index = 6;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f0_f7() {
/* fdiv	st,st(7) 	*/
	IU16 src2_index = 7;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(0, 0, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f1_f0() {
/* fdiv	st(1),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(1, 1, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f2_f0() {
/* fdiv	st(2),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(2, 2, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f3_f0() {
/* fdiv	st(3),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(3, 3, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f4_f0() {
/* fdiv	st(4),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(4, 4, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f5_f0() {
/* fdiv	st(5),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(5, 5, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f6_f0() {
/* fdiv	st(6),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(6, 6, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_f7_f0() {
/* fdiv	st(7),st 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FDIV(7, 7, (VOID *)&src2_index);
}

LOCAL VOID npx_fdiv_short() {
/* fdiv	DWORD PTR  	*/

	FPtype = M32R;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FDIV(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fdiv_long() {
/* fdiv	QWORD PTR  	*/

	FPtype = M64R;
	D_E08(0, RO0, PG_R);
	F_E08(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FDIV(0, 0, &ops[0].npxbuff[0]);
}

LOCAL VOID npx_fdivp_f0() {
/* fdivp	st(0),st 	*/

	POPST = TRUE;
	npx_fdiv_f0_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fdivp_f1() {
/* fdivp	st(1),st 	*/

	POPST = TRUE;
	npx_fdiv_f1_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fdivp_f2() {
/* fdivp	st(2),st 	*/

	POPST = TRUE;
	npx_fdiv_f2_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fdivp_f3() {
/* fdivp	st(3),st 	*/

	POPST = TRUE;
	npx_fdiv_f3_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fdivp_f4() {
/* fdivp	st(4),st 	*/

	POPST = TRUE;
	npx_fdiv_f4_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fdivp_f5() {
/* fdivp	st(5),st 	*/

	POPST = TRUE;
	npx_fdiv_f5_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fdivp_f6() {
/* fdivp	st(6),st 	*/

	POPST = TRUE;
	npx_fdiv_f6_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fdivp_f7() {
/* fdivp	st(7),st 	*/

	POPST = TRUE;
	npx_fdiv_f7_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fdivr_f0_f0() {
/* fdivr	st,st 	*/

	REVERSE = TRUE;
	npx_fdiv_f0_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f0_f1() {
/* fdivr	st,st(1) 	*/

	REVERSE = TRUE;
	npx_fdiv_f0_f1();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f0_f2() {
/* fdivr	st,st(2) 	*/

	REVERSE = TRUE;
	npx_fdiv_f0_f2();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f0_f3() {
/* fdivr	st,st(3) 	*/

	REVERSE = TRUE;
	npx_fdiv_f0_f3();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f0_f4() {
/* fdivr	st,st(4) 	*/

	REVERSE = TRUE;
	npx_fdiv_f0_f4();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f0_f5() {
/* fdivr	st,st(5) 	*/

	REVERSE = TRUE;
	npx_fdiv_f0_f5();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f0_f6() {
/* fdivr	st,st(6) 	*/

	REVERSE = TRUE;
	npx_fdiv_f0_f6();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f0_f7() {
/* fdivr	st,st(7) 	*/

	REVERSE = TRUE;
	npx_fdiv_f0_f7();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f1_f0() {
/* fdivr	st(1),st 	*/

	REVERSE = TRUE;
	npx_fdiv_f1_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f2_f0() {
/* fdivr	st(2),st 	*/

	REVERSE = TRUE;
	npx_fdiv_f2_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f3_f0() {
/* fdivr	st(3),st 	*/

	REVERSE = TRUE;
	npx_fdiv_f3_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f4_f0() {
/* fdivr	st(4),st 	*/

	REVERSE = TRUE;
	npx_fdiv_f4_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f5_f0() {
/* fdivr	st(5),st 	*/

	REVERSE = TRUE;
	npx_fdiv_f5_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f6_f0() {
/* fdivr	st(6),st 	*/

	REVERSE = TRUE;
	npx_fdiv_f6_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_f7_f0() {
/* fdivr	st(7),st 	*/

	REVERSE = TRUE;
	npx_fdiv_f7_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_short() {
/* fdivr	DWORD PTR  	*/

	REVERSE = TRUE;
	npx_fdiv_short();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivr_long() {
/* fdivr	QWORD PTR  	*/

	REVERSE = TRUE;
	npx_fdiv_long();
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivrp_f0() {
/* fdivrp	st(0),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fdiv_f0_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivrp_f1() {
/* fdivrp	st(1),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fdiv_f1_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivrp_f2() {
/* fdivrp	st(2),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fdiv_f2_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivrp_f3() {
/* fdivrp	st(3),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fdiv_f3_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivrp_f4() {
/* fdivrp	st(4),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fdiv_f4_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivrp_f5() {
/* fdivrp	st(5),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fdiv_f5_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivrp_f6() {
/* fdivrp	st(6),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fdiv_f6_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fdivrp_f7() {
/* fdivrp	st(7),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fdiv_f7_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_ffree_f0() {
/* ffree	st(0) 	*/

	SAVE_PTRS();
	FFREE(0);
}

LOCAL VOID npx_ffree_f1() {
/* ffree	st(1) 	*/

	SAVE_PTRS();
	FFREE(1);
}

LOCAL VOID npx_ffree_f2() {
/* ffree	st(2) 	*/

	SAVE_PTRS();
	FFREE(2);
}

LOCAL VOID npx_ffree_f3() {
/* ffree	st(3) 	*/

	SAVE_PTRS();
	FFREE(3);
}

LOCAL VOID npx_ffree_f4() {
/* ffree	st(4) 	*/

	SAVE_PTRS();
	FFREE(4);
}

LOCAL VOID npx_ffree_f5() {
/* ffree	st(5) 	*/

	SAVE_PTRS();
	FFREE(5);
}

LOCAL VOID npx_ffree_f6() {
/* ffree	st(6) 	*/

	SAVE_PTRS();
	FFREE(6);
}

LOCAL VOID npx_ffree_f7() {
/* ffree	st(7) 	*/

	SAVE_PTRS();
	FFREE(7);
}

LOCAL VOID npx_ffreep_f0() {
/* ffreep	st(0) 	*/

	POPST=TRUE;
	npx_ffree_f0();
	POPST=FALSE;
}

LOCAL VOID npx_ffreep_f1() {
/* ffreep	st(1) 	*/

	POPST=TRUE;
	npx_ffree_f1();
	POPST=FALSE;
}

LOCAL VOID npx_ffreep_f2() {
/* ffreep	st(2) 	*/

	POPST=TRUE;
	npx_ffree_f2();
	POPST=FALSE;
}

LOCAL VOID npx_ffreep_f3() {
/* ffreep	st(3) 	*/

	POPST=TRUE;
	npx_ffree_f3();
	POPST=FALSE;
}

LOCAL VOID npx_ffreep_f4() {
/* ffreep	st(4) 	*/

	POPST=TRUE;
	npx_ffree_f4();
	POPST=FALSE;
}

LOCAL VOID npx_ffreep_f5() {
/* ffreep	st(5) 	*/

	POPST=TRUE;
	npx_ffree_f5();
	POPST=FALSE;
}

LOCAL VOID npx_ffreep_f6() {
/* ffreep	st(6) 	*/

	POPST=TRUE;
	npx_ffree_f6();
	POPST=FALSE;
}

LOCAL VOID npx_ffreep_f7() {
/* ffreep	st(7) 	*/

	POPST=TRUE;
	npx_ffree_f7();
	POPST=FALSE;
}

LOCAL VOID npx_fiadd_word() {
/* fiadd	WORD PTR  	*/

	FPtype = M16I;
	D_Ew(0, RO0, PG_R);
	F_Ew(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FADD(0, 0, &ops[0].sng);
}


LOCAL VOID npx_fiadd_short() {
/* fiadd	DWORD PTR  	*/

	FPtype = M32I;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FADD(0, 0, &ops[0].sng);
}

LOCAL VOID npx_ficom_word() {
/* ficom	WORD PTR  	*/

	FPtype = M16I;
	D_Ew(0, RO0, PG_R);
	F_Ew(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FCOM(&ops[0].sng);
}

LOCAL VOID npx_ficom_short() {
/* ficom	DWORD PTR  	*/

	FPtype = M32I;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FCOM(&ops[0].sng);
}

LOCAL VOID npx_ficomp_word() {
/* ficomp	WORD PTR  	*/

	POPST = TRUE;
	npx_ficom_word();
	POPST = FALSE;
}

LOCAL VOID npx_ficomp_short() {
/* ficomp	DWORD PTR  	*/

	POPST = TRUE;
	npx_ficom_short();
	POPST = FALSE;
}

LOCAL VOID npx_fidiv_word() {
/* fidiv	WORD PTR  	*/

	FPtype = M16I;
	D_Ew(0, RO0, PG_R);
	F_Ew(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FDIV(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fidiv_short() {
/* fidiv	DWORD PTR  	*/

	FPtype = M32I;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FDIV(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fidivr_word() {
/* fidivr	WORD PTR  	*/

	REVERSE=TRUE;
	npx_fidiv_word();
	REVERSE = FALSE;
}

LOCAL VOID npx_fidivr_short() {
/* fidivr	DWORD PTR  	*/

	REVERSE=TRUE;
	npx_fidiv_short();
	REVERSE = FALSE;
}

LOCAL VOID npx_fild_word() {
/* fild	WORD PTR  	*/

	FPtype = M16I;
	D_Ew(0, RO0, PG_R);
	F_Ew(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FLD(&ops[0].sng);
}

LOCAL VOID npx_fild_short() {
/* fild	DWORD PTR  	*/

	FPtype = M32I;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FLD(&ops[0].sng);
}

LOCAL VOID npx_fild_long() {
/* fild	QWORD PTR  	*/

	FPtype = M64I;
	D_E08(0, RO0, PG_R);
	F_E08(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FLD(&ops[0].npxbuff[0]);
}

LOCAL VOID npx_fimul_word() {
/* fimul	WORD PTR  	*/

	FPtype = M16I;
	D_Ew(0, RO0, PG_R);
	F_Ew(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FMUL(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fimul_short() {
/* fimul	DWORD PTR  	*/

	FPtype = M32I;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FMUL(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fincstp() {
/* fincstp		*/

	FINCSTP();
}

LOCAL VOID npx_finit() {
/* finit		*/

	FINIT();
}

LOCAL VOID npx_fist_word() {
/* fist	WORD PTR  	*/

	FPtype = M16I;
	D_Ew(0, WO0, PG_W);
	SAVE_PTRS();
	SAVE_DPTRS();
	FIST(&ops[0].sng);
	P_Ew(0);
}

LOCAL VOID npx_fist_short() {
/* fist	DWORD PTR  	*/

	FPtype = M32I;
	D_Ed(0, WO0, PG_W);
	SAVE_PTRS();
	SAVE_DPTRS();
	FIST(&ops[0].sng);
	P_Ed(0);
}

LOCAL VOID npx_fistp_word() {
/* fistp	WORD PTR  	*/

	POPST = TRUE;
	npx_fist_word();
	POPST = FALSE;
}

LOCAL VOID npx_fistp_short() {
/* fistp	DWORD PTR  	*/

	POPST = TRUE;
	npx_fist_short();
	POPST = FALSE;
}

LOCAL VOID npx_fistp_long() {
/* fistp	QWORD PTR  	*/

	FPtype = M64I;
	POPST = TRUE;
	D_E08(0, WO0, PG_W);
	SAVE_PTRS();
	SAVE_DPTRS();
	FIST(&ops[0].npxbuff[0]);
	P_E08(0);
	POPST = FALSE;
}

LOCAL VOID npx_fisub_word() {
/* fisub	WORD PTR  	*/

	FPtype = M16I;
	D_Ew(0, RO0, PG_R);
	F_Ew(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FSUB(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fisub_short() {
/* fisub	DWORD PTR  	*/

	FPtype = M32I;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FSUB(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fisubr_word() {
/* fisubr	WORD PTR  	*/

	REVERSE = TRUE;
	npx_fisub_word();
	REVERSE = FALSE;
}

LOCAL VOID npx_fisubr_short() {
/* fisubr	DWORD PTR  	*/

	REVERSE = TRUE;
	npx_fisub_short();
	REVERSE = FALSE;
}

LOCAL VOID npx_fld_f0() {
/* fld	st(0) 	*/
	IU16 stackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FLD((VOID *)&stackPtr);
}

LOCAL VOID npx_fld_f1() {
/* fld	st(1) 	*/
	IU16 stackPtr = 1;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FLD((VOID *)&stackPtr);
}

LOCAL VOID npx_fld_f2() {
/* fld	st(2) 	*/
	IU16 stackPtr = 2;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FLD((VOID *)&stackPtr);
}

LOCAL VOID npx_fld_f3() {
/* fld	st(3) 	*/
	IU16 stackPtr = 3;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FLD((VOID *)&stackPtr);
}

LOCAL VOID npx_fld_f4() {
/* fld	st(4) 	*/
	IU16 stackPtr = 4;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FLD((VOID *)&stackPtr);
}

LOCAL VOID npx_fld_f5() {
/* fld	st(5) 	*/
	IU16 stackPtr = 5;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FLD((VOID *)&stackPtr);
}

LOCAL VOID npx_fld_f6() {
/* fld	st(6) 	*/
	IU16 stackPtr = 6;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FLD((VOID *)&stackPtr);
}

LOCAL VOID npx_fld_f7() {
/* fld	st(7) 	*/
	IU16 stackPtr = 7;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FLD((VOID *)&stackPtr);
}

LOCAL VOID npx_fld_short() {
/* fld	DWORD PTR  	*/

	FPtype=M32R;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FLD(&ops[0].sng);
}

LOCAL VOID npx_fld_long() {
/* fld	QWORD PTR  	*/

	FPtype=M64R;
	D_E08(0, RO0, PG_R);
	F_E08(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FLD(&ops[0].npxbuff[0]);
}

LOCAL VOID npx_fld_temp() {
/* fld	TBYTE PTR  	*/

	FPtype=M80R;
	D_E0a(0, RO0, PG_R);
	F_E0a(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FLD(&ops[0].npxbuff[0]);
}

LOCAL VOID npx_fldcw() {
/* fldcw	 	*/

	D_Ew(0, RO0, PG_R);
	F_Ew(0);
	FLDCW(&ops[0].sng);
}

LOCAL VOID npx_fldenv() {
/* fldenv	 	*/

	NPX_ADDRESS_SIZE_32 = (GET_OPERAND_SIZE()==USE16)?FALSE:TRUE;
	NPX_PROT_MODE = ( GET_PE() && (GET_VM() == 0) );
	D_E0e(0, RO0, PG_R);
	F_E0e(0);
	FLDENV(&ops[0].npxbuff[0]);
}

LOCAL VOID npx_fldlg2() {
/* fldlg2		*/

	SAVE_PTRS();
	FLDCONST(4);
}

LOCAL VOID npx_fldln2() {
/* fldln2		*/

	SAVE_PTRS();
	FLDCONST(5);
}

LOCAL VOID npx_fldl2e() {
/* fldl2e		*/

	SAVE_PTRS();
	FLDCONST(2);
}

LOCAL VOID npx_fldl2t() {
/* fldl2t		*/

	SAVE_PTRS();
	FLDCONST(1);
}

LOCAL VOID npx_fldpi() {
/* fldpi		*/

	SAVE_PTRS();
	FLDCONST(3);
}

LOCAL VOID npx_fldz() {
/* fldz		*/

	SAVE_PTRS();
	FLDCONST(6);
}

LOCAL VOID npx_fld1() {
/* fld1		*/

	SAVE_PTRS();
	FLDCONST(0);
}

LOCAL VOID npx_fmul_f0_f0() {
/* fmul	st,st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f0_f1() {
/* fmul	st,st(1) 	*/
	IU16 StackPtr = 1;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f0_f2() {
/* fmul	st,st(2) 	*/
	IU16 StackPtr = 2;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f0_f3() {
/* fmul	st,st(3) 	*/
	IU16 StackPtr = 3;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f0_f4() {
/* fmul	st,st(4) 	*/
	IU16 StackPtr = 4;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f0_f5() {
/* fmul	st,st(5) 	*/
	IU16 StackPtr = 5;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f0_f6() {
/* fmul	st,st(6) 	*/
	IU16 StackPtr = 6;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f0_f7() {
/* fmul	st,st(7) 	*/
	IU16 StackPtr = 7;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f1_f0() {
/* fmul	st(1),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(1, 1, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f2_f0() {
/* fmul	st(2),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(2, 2, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f3_f0() {
/* fmul	st(3),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(3, 3, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f4_f0() {
/* fmul	st(4),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(4, 4, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f5_f0() {
/* fmul	st(5),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(5, 5, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f6_f0() {
/* fmul	st(6),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(6, 6, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_f7_f0() {
/* fmul	st(7),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FMUL(7, 7, (VOID *)&StackPtr);
}

LOCAL VOID npx_fmul_short() {
/* fmul	DWORD PTR  	*/

	FPtype = M32R;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FMUL(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fmul_long() {
/* fmul	QWORD PTR  	*/

	FPtype = M64R;
	D_E08(0, RO0, PG_R);
	F_E08(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FMUL(0, 0, &ops[0].npxbuff[0]);
}

LOCAL VOID npx_fmulp_f0() {
/* fmulp	st(0),st 	*/

	POPST = TRUE;
	npx_fmul_f0_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fmulp_f1() {
/* fmulp	st(1),st 	*/

	POPST = TRUE;
	npx_fmul_f1_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fmulp_f2() {
/* fmulp	st(2),st 	*/

	POPST = TRUE;
	npx_fmul_f2_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fmulp_f3() {
/* fmulp	st(3),st 	*/

	POPST = TRUE;
	npx_fmul_f3_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fmulp_f4() {
/* fmulp	st(4),st 	*/

	POPST = TRUE;
	npx_fmul_f4_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fmulp_f5() {
/* fmulp	st(5),st 	*/

	POPST = TRUE;
	npx_fmul_f5_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fmulp_f6() {
/* fmulp	st(6),st 	*/

	POPST = TRUE;
	npx_fmul_f6_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fmulp_f7() {
/* fmulp	st(7),st 	*/

	POPST = TRUE;
	npx_fmul_f7_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fnop() {
/* fnop		*/

	SAVE_PTRS();
	FNOP();
}

LOCAL VOID npx_fpatan() {
/* fpatan		*/

	SAVE_PTRS();
	FPATAN();
}

LOCAL VOID npx_fprem() {
/* fprem		*/

	SAVE_PTRS();
	FPREM();
}

LOCAL VOID npx_fprem1() {
/* fprem		*/

	SAVE_PTRS();
	FPREM1();
}

LOCAL VOID npx_fptan() {
/* fptan		*/

	SAVE_PTRS();
	FPTAN();
}

LOCAL VOID npx_frndint() {
/* frndint		*/

	SAVE_PTRS();
	FRNDINT();
}

LOCAL VOID npx_fscale() {
/* fscale		*/

	SAVE_PTRS();
	FSCALE();
}

LOCAL VOID npx_fsin() {
/* fsin			*/

	SAVE_PTRS();
	FSIN();
}

LOCAL VOID npx_fsincos() {
/* fsincos		*/

	SAVE_PTRS();
	FSINCOS();
}

LOCAL VOID npx_fsqrt() {
/* fsqrt		*/

	SAVE_PTRS();
	FSQRT();
}

LOCAL VOID npx_frstor() {
/* frstor	 	*/

	NPX_ADDRESS_SIZE_32 = (GET_OPERAND_SIZE()==USE16)?FALSE:TRUE;
	NPX_PROT_MODE = ( GET_PE() && (GET_VM() == 0) );
	D_E5e(0, RO0, PG_R);
	F_E5e(0);
	FRSTOR(&ops[0].npxbuff[0]);
}

LOCAL VOID npx_fsave() {
/* fsave	 	*/

	NPX_ADDRESS_SIZE_32 = (GET_OPERAND_SIZE()==USE16)?FALSE:TRUE;
	NPX_PROT_MODE = ( GET_PE() && (GET_VM() == 0) );
	D_E5e(0, WO0, PG_W);
	FSAVE(&ops[0].npxbuff[0]);
	P_E5e(0);
}

LOCAL VOID npx_fst_f0() {
/* fst	st(0) 	*/
	IU16 StackPtr=0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FST((VOID *)&StackPtr);
}

LOCAL VOID npx_fst_f1() {
/* fst	st(1) 	*/
	IU16 StackPtr=1;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FST((VOID *)&StackPtr);
}

LOCAL VOID npx_fst_f2() {
/* fst	st(2) 	*/
	IU16 StackPtr=2;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FST((VOID *)&StackPtr);
}

LOCAL VOID npx_fst_f3() {
/* fst	st(3) 	*/
	IU16 StackPtr=3;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FST((VOID *)&StackPtr);
}

LOCAL VOID npx_fst_f4() {
/* fst	st(4) 	*/
	IU16 StackPtr=4;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FST((VOID *)&StackPtr);
}

LOCAL VOID npx_fst_f5() {
/* fst	st(5) 	*/
	IU16 StackPtr=5;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FST((VOID *)&StackPtr);
}

LOCAL VOID npx_fst_f6() {
/* fst	st(6) 	*/
	IU16 StackPtr=6;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FST((VOID *)&StackPtr);
}

LOCAL VOID npx_fst_f7() {
/* fst	st(7) 	*/
	IU16 StackPtr=7;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FST((VOID *)&StackPtr);
}

LOCAL VOID npx_fst_short() {
/* fst	DWORD PTR  	*/

	FPtype = M32R;
	D_Ed(0, WO0, PG_W);
	SAVE_PTRS();
	SAVE_DPTRS();
	FST(&ops[0].sng);
	P_Ed(0);
}

LOCAL VOID npx_fst_long() {
/* fst	QWORD PTR  	*/

	FPtype = M64R;
	D_E08(0, WO0, PG_W);
	SAVE_PTRS();
	SAVE_DPTRS();
	FST(&ops[0].npxbuff[0]);
	P_E08(0);
}

LOCAL VOID npx_fstcw() {
/* fstcw	 	*/

	D_Ew(0, WO0, PG_W);
	FSTCW(&ops[0].sng);
	P_Ew(0);
}

LOCAL VOID npx_fstenv() {
/* fstenv	 	*/

	NPX_ADDRESS_SIZE_32 = (GET_OPERAND_SIZE()==USE16)?FALSE:TRUE;
	NPX_PROT_MODE = ( GET_PE() && (GET_VM() == 0) );
	D_E0e(0, WO0, PG_W);
	FSTENV(&ops[0].npxbuff[0]);
	P_E0e(0);
}

LOCAL VOID npx_fstp_f0() {
/* fstp	st(0) 	*/

	POPST = TRUE;
	npx_fst_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_f1() {
/* fstp	st(1) 	*/

	POPST = TRUE;
	npx_fst_f1();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_f2() {
/* fstp	st(2) 	*/

	POPST = TRUE;
	npx_fst_f2();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_f3() {
/* fstp	st(3) 	*/

	POPST = TRUE;
	npx_fst_f3();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_f4() {
/* fstp	st(4) 	*/

	POPST = TRUE;
	npx_fst_f4();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_f5() {
/* fstp	st(5) 	*/

	POPST = TRUE;
	npx_fst_f5();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_f6() {
/* fstp	st(6) 	*/

	POPST = TRUE;
	npx_fst_f6();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_f7() {
/* fstp	st(7) 	*/

	POPST = TRUE;
	npx_fst_f7();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_short() {
/* fstp	DWORD PTR  	*/

	POPST = TRUE;
	npx_fst_short();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_long() {
/* fstp	QWORD PTR  	*/

	POPST = TRUE;
	npx_fst_long();
	POPST = FALSE;
}

LOCAL VOID npx_fstp_temp() {
/* fstp	TBYTE PTR  	*/

	POPST = TRUE;
	FPtype = M80R;
	D_E0a(0, WO0, PG_W);
	SAVE_PTRS();
	SAVE_DPTRS();
	FST(&ops[0].npxbuff[0]);
	P_E0a(0);
	POPST = FALSE;
}

LOCAL VOID npx_fstsw() {
/* fstsw 	*/

	D_Ew(0, WO0, PG_W);
	FSTSW(&ops[0].sng, FALSE);
	P_Ew(0);
}

LOCAL VOID npx_fstswax() {
/* fstswax		*/

	FSTSW((VOID *)&Ax_regptr, TRUE);
	SET_AX(Ax_regptr);
}

LOCAL VOID npx_fsub_f0_f0() {
/* fsub	st,st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f0_f1() {
/* fsub	st,st(1) 	*/
	IU16 StackPtr = 1;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f0_f2() {
/* fsub	st,st(2) 	*/
	IU16 StackPtr = 2;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f0_f3() {
/* fsub	st,st(3) 	*/
	IU16 StackPtr = 3;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f0_f4() {
/* fsub	st,st(4) 	*/
	IU16 StackPtr = 4;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f0_f5() {
/* fsub	st,st(5) 	*/
	IU16 StackPtr = 5;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f0_f6() {
/* fsub	st,st(6) 	*/
	IU16 StackPtr = 6;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f0_f7() {
/* fsub	st,st(7) 	*/
	IU16 StackPtr = 7;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(0, 0, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f1_f0() {
/* fsub	st(1),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(1, 1, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f2_f0() {
/* fsub	st(2),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(2, 2, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f3_f0() {
/* fsub	st(3),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(3, 3, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f4_f0() {
/* fsub	st(4),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(4, 4, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f5_f0() {
/* fsub	st(5),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(5, 5, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f6_f0() {
/* fsub	st(6),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(6, 6, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_f7_f0() {
/* fsub	st(7),st 	*/
	IU16 StackPtr = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	FSUB(7, 7, (VOID *)&StackPtr);
}

LOCAL VOID npx_fsub_short() {
/* fsub	DWORD PTR  	*/

	FPtype = M32R;
	D_Ed(0, RO0, PG_R);
	F_Ed(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FSUB(0, 0, &ops[0].sng);
}

LOCAL VOID npx_fsub_long() {
/* fsub	QWORD PTR  	*/

	FPtype = M64R;
	D_E08(0, RO0, PG_R);
	F_E08(0);
	SAVE_PTRS();
	SAVE_DPTRS();
	FSUB(0, 0, &ops[0].npxbuff[0]);
}

LOCAL VOID npx_fsubp_f0() {
/* fsubp	st(0),st 	*/

	POPST = TRUE;
	npx_fsub_f0_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fsubp_f1() {
/* fsubp	st(1),st 	*/

	POPST = TRUE;
	npx_fsub_f1_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fsubp_f2() {
/* fsubp	st(2),st 	*/

	POPST = TRUE;
	npx_fsub_f2_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fsubp_f3() {
/* fsubp	st(3),st 	*/

	POPST = TRUE;
	npx_fsub_f3_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fsubp_f4() {
/* fsubp	st(4),st 	*/

	POPST = TRUE;
	npx_fsub_f4_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fsubp_f5() {
/* fsubp	st(5),st 	*/

	POPST = TRUE;
	npx_fsub_f5_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fsubp_f6() {
/* fsubp	st(6),st 	*/

	POPST = TRUE;
	npx_fsub_f6_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fsubp_f7() {
/* fsubp	st(7),st 	*/

	POPST = TRUE;
	npx_fsub_f7_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fsubr_f0_f0() {
/* fsubr	st,st 	*/

	REVERSE = TRUE;
	npx_fsub_f0_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f0_f1() {
/* fsubr	st,st(1) 	*/

	REVERSE = TRUE;
	npx_fsub_f0_f1();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f0_f2() {
/* fsubr	st,st(2) 	*/

	REVERSE = TRUE;
	npx_fsub_f0_f2();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f0_f3() {
/* fsubr	st,st(3) 	*/

	REVERSE = TRUE;
	npx_fsub_f0_f3();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f0_f4() {
/* fsubr	st,st(4) 	*/

	REVERSE = TRUE;
	npx_fsub_f0_f4();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f0_f5() {
/* fsubr	st,st(5) 	*/

	REVERSE = TRUE;
	npx_fsub_f0_f5();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f0_f6() {
/* fsubr	st,st(6) 	*/

	REVERSE = TRUE;
	npx_fsub_f0_f6();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f0_f7() {
/* fsubr	st,st(7) 	*/

	REVERSE = TRUE;
	npx_fsub_f0_f7();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f1_f0() {
/* fsubr	st(1),st 	*/

	REVERSE = TRUE;
	npx_fsub_f1_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f2_f0() {
/* fsubr	st(2),st 	*/

	REVERSE = TRUE;
	npx_fsub_f2_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f3_f0() {
/* fsubr	st(3),st 	*/

	REVERSE = TRUE;
	npx_fsub_f3_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f4_f0() {
/* fsubr	st(4),st 	*/

	REVERSE = TRUE;
	npx_fsub_f4_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f5_f0() {
/* fsubr	st(5),st 	*/

	REVERSE = TRUE;
	npx_fsub_f5_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f6_f0() {
/* fsubr	st(6),st 	*/

	REVERSE = TRUE;
	npx_fsub_f6_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_f7_f0() {
/* fsubr	st(7),st 	*/

	REVERSE = TRUE;
	npx_fsub_f7_f0();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_short() {
/* fsubr	DWORD PTR  	*/

	REVERSE = TRUE;
	npx_fsub_short();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubr_long() {
/* fsubr	QWORD PTR  	*/

	REVERSE = TRUE;
	npx_fsub_long();
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubrp_f0() {
/* fsubrp	st(0),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fsub_f0_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubrp_f1() {
/* fsubrp	st(1),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fsub_f1_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubrp_f2() {
/* fsubrp	st(2),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fsub_f2_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubrp_f3() {
/* fsubrp	st(3),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fsub_f3_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubrp_f4() {
/* fsubrp	st(4),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fsub_f4_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubrp_f5() {
/* fsubrp	st(5),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fsub_f5_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubrp_f6() {
/* fsubrp	st(6),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fsub_f6_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_fsubrp_f7() {
/* fsubrp	st(7),st 	*/

	REVERSE = TRUE;
	POPST = TRUE;
	npx_fsub_f7_f0();
	POPST = FALSE;
	REVERSE = FALSE;
}

LOCAL VOID npx_ftst() {
/* ftst		*/

	SAVE_PTRS();
	FTST();
}

LOCAL VOID npx_fucom_f0() {
/* fucom	st(0) 	*/
	IU16 src2_index = 0;

	SAVE_PTRS();
	FPtype = FPSTACK;
	UNORDERED = TRUE;
	FCOM((VOID *)&src2_index);
	UNORDERED = FALSE;
}

LOCAL VOID npx_fucom_f1() {
/* fucom	st(1) 	*/
	IU16 src2_index = 1;

	SAVE_PTRS();
	FPtype = FPSTACK;
	UNORDERED = TRUE;
	FCOM((VOID *)&src2_index);
	UNORDERED = FALSE;
}

LOCAL VOID npx_fucom_f2() {
/* fucom	st(2) 	*/
	IU16 src2_index = 2;

	SAVE_PTRS();
	FPtype = FPSTACK;
	UNORDERED = TRUE;
	FCOM((VOID *)&src2_index);
	UNORDERED = FALSE;
}

LOCAL VOID npx_fucom_f3() {
/* fucom	st(3) 	*/
	IU16 src2_index = 3;

	SAVE_PTRS();
	FPtype = FPSTACK;
	UNORDERED = TRUE;
	FCOM((VOID *)&src2_index);
	UNORDERED = FALSE;
}

LOCAL VOID npx_fucom_f4() {
/* fucom	st(4) 	*/
	IU16 src2_index = 4;

	SAVE_PTRS();
	FPtype = FPSTACK;
	UNORDERED = TRUE;
	FCOM((VOID *)&src2_index);
	UNORDERED = FALSE;
}

LOCAL VOID npx_fucom_f5() {
/* fucom	st(5) 	*/
	IU16 src2_index = 5;

	SAVE_PTRS();
	FPtype = FPSTACK;
	UNORDERED = TRUE;
	FCOM((VOID *)&src2_index);
	UNORDERED = FALSE;
}

LOCAL VOID npx_fucom_f6() {
/* fucom	st(6) 	*/
	IU16 src2_index = 6;

	SAVE_PTRS();
	FPtype = FPSTACK;
	UNORDERED = TRUE;
	FCOM((VOID *)&src2_index);
	UNORDERED = FALSE;
}

LOCAL VOID npx_fucom_f7() {
/* fucom	st(7) 	*/
	IU16 src2_index = 7;

	SAVE_PTRS();
	FPtype = FPSTACK;
	UNORDERED = TRUE;
	FCOM((VOID *)&src2_index);
	UNORDERED = FALSE;
}

LOCAL VOID npx_fucomp_f0() {
/* fucomp	st(0) 	*/

	POPST = TRUE;
	npx_fucom_f0();
	POPST = FALSE;
}

LOCAL VOID npx_fucomp_f1() {
/* fucomp	st(1) 	*/

	POPST = TRUE;
	npx_fucom_f1();
	POPST = FALSE;
}

LOCAL VOID npx_fucomp_f2() {
/* fucomp	st(2) 	*/

	POPST = TRUE;
	npx_fucom_f2();
	POPST = FALSE;
}

LOCAL VOID npx_fucomp_f3() {
/* fucomp	st(3) 	*/

	POPST = TRUE;
	npx_fucom_f3();
	POPST = FALSE;
}

LOCAL VOID npx_fucomp_f4() {
/* fucomp	st(4) 	*/

	POPST = TRUE;
	npx_fucom_f4();
	POPST = FALSE;
}

LOCAL VOID npx_fucomp_f5() {
/* fucomp	st(5) 	*/

	POPST = TRUE;
	npx_fucom_f5();
	POPST = FALSE;
}

LOCAL VOID npx_fucomp_f6() {
/* fucomp	st(6) 	*/

	POPST = TRUE;
	npx_fucom_f6();
	POPST = FALSE;
}

LOCAL VOID npx_fucomp_f7() {
/* fucomp	st(7) 	*/

	POPST = TRUE;
	npx_fucom_f7();
	POPST = FALSE;
}

LOCAL VOID npx_fucompp() {
/* fucompp		*/

	DOUBLEPOP = TRUE;
	npx_fucom_f1();
	DOUBLEPOP = FALSE;
}

LOCAL VOID npx_fxam() {
/* fxam		*/

	SAVE_PTRS();
	FXAM();
}

LOCAL VOID npx_fxch_f0() {
/* fxch	st(0) 	*/

	SAVE_PTRS();
	FXCH(0);
}

LOCAL VOID npx_fxch_f1() {
/* fxch	st(1) 	*/

	SAVE_PTRS();
	FXCH(1);
}

LOCAL VOID npx_fxch_f2() {
/* fxch	st(2) 	*/

	SAVE_PTRS();
	FXCH(2);
}

LOCAL VOID npx_fxch_f3() {
/* fxch	st(3) 	*/

	SAVE_PTRS();
	FXCH(3);
}

LOCAL VOID npx_fxch_f4() {
/* fxch	st(4) 	*/

	SAVE_PTRS();
	FXCH(4);
}

LOCAL VOID npx_fxch_f5() {
/* fxch	st(5) 	*/

	SAVE_PTRS();
	FXCH(5);
}

LOCAL VOID npx_fxch_f6() {
/* fxch	st(6) 	*/

	SAVE_PTRS();
	FXCH(6);
}

LOCAL VOID npx_fxch_f7() {
/* fxch	st(7) 	*/

	SAVE_PTRS();
	FXCH(7);
}

LOCAL VOID npx_fxtract() {
/* fxtract		*/

	SAVE_PTRS();
	FXTRACT();
}

LOCAL VOID npx_fyl2x() {
/* fyl2x		*/

	SAVE_PTRS();
	FYL2X();
}

LOCAL VOID npx_fyl2xp1() {
/* fyl2xp1		*/

	SAVE_PTRS();
	FYL2XP1();
}

LOCAL VOID npx_f2xm1() {
/* f2xm1		*/

	SAVE_PTRS();
	F2XM1();
}

LOCAL VOID npx_funimp() {
	Int6();
}


LOCAL VOID (*inst_table[])() = {
npx_fadd_short,		/* d8 00 */
npx_fadd_short,		/* d8 01 */
npx_fadd_short,		/* d8 02 */
npx_fadd_short,		/* d8 03 */
npx_fadd_short,		/* d8 04 */
npx_fadd_short,		/* d8 05 */
npx_fadd_short,		/* d8 06 */
npx_fadd_short,		/* d8 07 */
npx_fmul_short,		/* d8 08 */
npx_fmul_short,		/* d8 09 */
npx_fmul_short,		/* d8 0a */
npx_fmul_short,		/* d8 0b */
npx_fmul_short,		/* d8 0c */
npx_fmul_short,		/* d8 0d */
npx_fmul_short,		/* d8 0e */
npx_fmul_short,		/* d8 0f */
npx_fcom_short,		/* d8 10 */
npx_fcom_short,		/* d8 11 */
npx_fcom_short,		/* d8 12 */
npx_fcom_short,		/* d8 13 */
npx_fcom_short,		/* d8 14 */
npx_fcom_short,		/* d8 15 */
npx_fcom_short,		/* d8 16 */
npx_fcom_short,		/* d8 17 */
npx_fcomp_short,	/* d8 18 */
npx_fcomp_short,	/* d8 19 */
npx_fcomp_short,	/* d8 1a */
npx_fcomp_short,	/* d8 1b */
npx_fcomp_short,	/* d8 1c */
npx_fcomp_short,	/* d8 1d */
npx_fcomp_short,	/* d8 1e */
npx_fcomp_short,	/* d8 1f */
npx_fsub_short,		/* d8 20 */
npx_fsub_short,		/* d8 21 */
npx_fsub_short,		/* d8 22 */
npx_fsub_short,		/* d8 23 */
npx_fsub_short,		/* d8 24 */
npx_fsub_short,		/* d8 25 */
npx_fsub_short,		/* d8 26 */
npx_fsub_short,		/* d8 27 */
npx_fsubr_short,	/* d8 28 */
npx_fsubr_short,	/* d8 29 */
npx_fsubr_short,	/* d8 2a */
npx_fsubr_short,	/* d8 2b */
npx_fsubr_short,	/* d8 2c */
npx_fsubr_short,	/* d8 2d */
npx_fsubr_short,	/* d8 2e */
npx_fsubr_short,	/* d8 2f */
npx_fdiv_short,		/* d8 30 */
npx_fdiv_short,		/* d8 31 */
npx_fdiv_short,		/* d8 32 */
npx_fdiv_short,		/* d8 33 */
npx_fdiv_short,		/* d8 34 */
npx_fdiv_short,		/* d8 35 */
npx_fdiv_short,		/* d8 36 */
npx_fdiv_short,		/* d8 37 */
npx_fdivr_short,	/* d8 38 */
npx_fdivr_short,	/* d8 39 */
npx_fdivr_short,	/* d8 3a */
npx_fdivr_short,	/* d8 3b */
npx_fdivr_short,	/* d8 3c */
npx_fdivr_short,	/* d8 3d */
npx_fdivr_short,	/* d8 3e */
npx_fdivr_short,	/* d8 3f */
npx_fadd_short,		/* d8 40 */
npx_fadd_short,		/* d8 41 */
npx_fadd_short,		/* d8 42 */
npx_fadd_short,		/* d8 43 */
npx_fadd_short,		/* d8 44 */
npx_fadd_short,		/* d8 45 */
npx_fadd_short,		/* d8 46 */
npx_fadd_short,		/* d8 47 */
npx_fmul_short,		/* d8 48 */
npx_fmul_short,		/* d8 49 */
npx_fmul_short,		/* d8 4a */
npx_fmul_short,		/* d8 4b */
npx_fmul_short,		/* d8 4c */
npx_fmul_short,		/* d8 4d */
npx_fmul_short,		/* d8 4e */
npx_fmul_short,		/* d8 4f */
npx_fcom_short,		/* d8 50 */
npx_fcom_short,		/* d8 51 */
npx_fcom_short,		/* d8 52 */
npx_fcom_short,		/* d8 53 */
npx_fcom_short,		/* d8 54 */
npx_fcom_short,		/* d8 55 */
npx_fcom_short,		/* d8 56 */
npx_fcom_short,		/* d8 57 */
npx_fcomp_short,	/* d8 58 */
npx_fcomp_short,	/* d8 59 */
npx_fcomp_short,	/* d8 5a */
npx_fcomp_short,	/* d8 5b */
npx_fcomp_short,	/* d8 5c */
npx_fcomp_short,	/* d8 5d */
npx_fcomp_short,	/* d8 5e */
npx_fcomp_short,	/* d8 5f */
npx_fsub_short,		/* d8 60 */
npx_fsub_short,		/* d8 61 */
npx_fsub_short,		/* d8 62 */
npx_fsub_short,		/* d8 63 */
npx_fsub_short,		/* d8 64 */
npx_fsub_short,		/* d8 65 */
npx_fsub_short,		/* d8 66 */
npx_fsub_short,		/* d8 67 */
npx_fsubr_short,	/* d8 68 */
npx_fsubr_short,	/* d8 69 */
npx_fsubr_short,	/* d8 6a */
npx_fsubr_short,	/* d8 6b */
npx_fsubr_short,	/* d8 6c */
npx_fsubr_short,	/* d8 6d */
npx_fsubr_short,	/* d8 6e */
npx_fsubr_short,	/* d8 6f */
npx_fdiv_short,		/* d8 70 */
npx_fdiv_short,		/* d8 71 */
npx_fdiv_short,		/* d8 72 */
npx_fdiv_short,		/* d8 73 */
npx_fdiv_short,		/* d8 74 */
npx_fdiv_short,		/* d8 75 */
npx_fdiv_short,		/* d8 76 */
npx_fdiv_short,		/* d8 77 */
npx_fdivr_short,	/* d8 78 */
npx_fdivr_short,	/* d8 79 */
npx_fdivr_short,	/* d8 7a */
npx_fdivr_short,	/* d8 7b */
npx_fdivr_short,	/* d8 7c */
npx_fdivr_short,	/* d8 7d */
npx_fdivr_short,	/* d8 7e */
npx_fdivr_short,	/* d8 7f */
npx_fadd_short,		/* d8 80 */
npx_fadd_short,		/* d8 81 */
npx_fadd_short,		/* d8 82 */
npx_fadd_short,		/* d8 83 */
npx_fadd_short,		/* d8 84 */
npx_fadd_short,		/* d8 85 */
npx_fadd_short,		/* d8 86 */
npx_fadd_short,		/* d8 87 */
npx_fmul_short,		/* d8 88 */
npx_fmul_short,		/* d8 89 */
npx_fmul_short,		/* d8 8a */
npx_fmul_short,		/* d8 8b */
npx_fmul_short,		/* d8 8c */
npx_fmul_short,		/* d8 8d */
npx_fmul_short,		/* d8 8e */
npx_fmul_short,		/* d8 8f */
npx_fcom_short,		/* d8 90 */
npx_fcom_short,		/* d8 91 */
npx_fcom_short,		/* d8 92 */
npx_fcom_short,		/* d8 93 */
npx_fcom_short,		/* d8 94 */
npx_fcom_short,		/* d8 95 */
npx_fcom_short,		/* d8 96 */
npx_fcom_short,		/* d8 97 */
npx_fcomp_short,	/* d8 98 */
npx_fcomp_short,	/* d8 99 */
npx_fcomp_short,	/* d8 9a */
npx_fcomp_short,	/* d8 9b */
npx_fcomp_short,	/* d8 9c */
npx_fcomp_short,	/* d8 9d */
npx_fcomp_short,	/* d8 9e */
npx_fcomp_short,	/* d8 9f */
npx_fsub_short,		/* d8 a0 */
npx_fsub_short,		/* d8 a1 */
npx_fsub_short,		/* d8 a2 */
npx_fsub_short,		/* d8 a3 */
npx_fsub_short,		/* d8 a4 */
npx_fsub_short,		/* d8 a5 */
npx_fsub_short,		/* d8 a6 */
npx_fsub_short,		/* d8 a7 */
npx_fsubr_short,	/* d8 a8 */
npx_fsubr_short,	/* d8 a9 */
npx_fsubr_short,	/* d8 aa */
npx_fsubr_short,	/* d8 ab */
npx_fsubr_short,	/* d8 ac */
npx_fsubr_short,	/* d8 ad */
npx_fsubr_short,	/* d8 ae */
npx_fsubr_short,	/* d8 af */
npx_fdiv_short,		/* d8 b0 */
npx_fdiv_short,		/* d8 b1 */
npx_fdiv_short,		/* d8 b2 */
npx_fdiv_short,		/* d8 b3 */
npx_fdiv_short,		/* d8 b4 */
npx_fdiv_short,		/* d8 b5 */
npx_fdiv_short,		/* d8 b6 */
npx_fdiv_short,		/* d8 b7 */
npx_fdivr_short,	/* d8 b8 */
npx_fdivr_short,	/* d8 b9 */
npx_fdivr_short,	/* d8 ba */
npx_fdivr_short,	/* d8 bb */
npx_fdivr_short,	/* d8 bc */
npx_fdivr_short,	/* d8 bd */
npx_fdivr_short,	/* d8 be */
npx_fdivr_short,	/* d8 bf */
npx_fadd_f0_f0,		/* d8 c0 */
npx_fadd_f0_f1,
npx_fadd_f0_f2,
npx_fadd_f0_f3,
npx_fadd_f0_f4,
npx_fadd_f0_f5,
npx_fadd_f0_f6,
npx_fadd_f0_f7,
npx_fmul_f0_f0,		/* d8 c7 */
npx_fmul_f0_f1,
npx_fmul_f0_f2,
npx_fmul_f0_f3,
npx_fmul_f0_f4,
npx_fmul_f0_f5,
npx_fmul_f0_f6,
npx_fmul_f0_f7,
npx_fcom_f0,		/* d8 d0 */
npx_fcom_f1,	
npx_fcom_f2,	
npx_fcom_f3,	
npx_fcom_f4,	
npx_fcom_f5,	
npx_fcom_f6,	
npx_fcom_f7,	
npx_fcomp_f0,	
npx_fcomp_f1,	
npx_fcomp_f2,	
npx_fcomp_f3,	
npx_fcomp_f4,	
npx_fcomp_f5,	
npx_fcomp_f6,	
npx_fcomp_f7,	
npx_fsub_f0_f0,		/* d8 e0 */
npx_fsub_f0_f1,
npx_fsub_f0_f2,
npx_fsub_f0_f3,
npx_fsub_f0_f4,
npx_fsub_f0_f5,
npx_fsub_f0_f6,
npx_fsub_f0_f7,
npx_fsubr_f0_f0,
npx_fsubr_f0_f1,
npx_fsubr_f0_f2,
npx_fsubr_f0_f3,
npx_fsubr_f0_f4,
npx_fsubr_f0_f5,
npx_fsubr_f0_f6,
npx_fsubr_f0_f7,
npx_fdiv_f0_f0,		/* d8 f0 */
npx_fdiv_f0_f1,
npx_fdiv_f0_f2,
npx_fdiv_f0_f3,
npx_fdiv_f0_f4,
npx_fdiv_f0_f5,
npx_fdiv_f0_f6,
npx_fdiv_f0_f7,
npx_fdivr_f0_f0,
npx_fdivr_f0_f1,
npx_fdivr_f0_f2,
npx_fdivr_f0_f3,
npx_fdivr_f0_f4,
npx_fdivr_f0_f5,
npx_fdivr_f0_f6,
npx_fdivr_f0_f7,
npx_fld_short,		/* d9 00 */
npx_fld_short,		/* d9 01 */
npx_fld_short,		/* d9 02 */
npx_fld_short,		/* d9 03 */
npx_fld_short,		/* d9 04 */
npx_fld_short,		/* d9 05 */
npx_fld_short,		/* d9 06 */
npx_fld_short,		/* d9 07 */
npx_funimp,		/* d9 08 */
npx_funimp,		/* d9 09 */
npx_funimp,		/* d9 0a */
npx_funimp,		/* d9 0b */
npx_funimp,		/* d9 0c */
npx_funimp,		/* d9 0d */
npx_funimp,		/* d9 0e */
npx_funimp,		/* d9 0f */
npx_fst_short,		/* d9 10 */
npx_fst_short,		/* d9 11 */
npx_fst_short,		/* d9 12 */
npx_fst_short,		/* d9 13 */
npx_fst_short,		/* d9 14 */
npx_fst_short,		/* d9 15 */
npx_fst_short,		/* d9 16 */
npx_fst_short,		/* d9 17 */
npx_fstp_short,		/* d9 18 */
npx_fstp_short,		/* d9 19 */
npx_fstp_short,		/* d9 1a */
npx_fstp_short,		/* d9 1b */
npx_fstp_short,		/* d9 1c */
npx_fstp_short,		/* d9 1d */
npx_fstp_short,		/* d9 1e */
npx_fstp_short,		/* d9 1f */
npx_fldenv,		/* d9 20 */
npx_fldenv,		/* d9 21 */
npx_fldenv,		/* d9 22 */
npx_fldenv,		/* d9 23 */
npx_fldenv,		/* d9 24 */
npx_fldenv,		/* d9 25 */
npx_fldenv,		/* d9 26 */
npx_fldenv,		/* d9 27 */
npx_fldcw,		/* d9 28 */
npx_fldcw,		/* d9 29 */
npx_fldcw,		/* d9 2a */
npx_fldcw,		/* d9 2b */
npx_fldcw,		/* d9 2c */
npx_fldcw,		/* d9 2d */
npx_fldcw,		/* d9 2e */
npx_fldcw,		/* d9 2f */
npx_fstenv,		/* d9 30 */
npx_fstenv,		/* d9 31 */
npx_fstenv,		/* d9 32 */
npx_fstenv,		/* d9 33 */
npx_fstenv,		/* d9 34 */
npx_fstenv,		/* d9 35 */
npx_fstenv,		/* d9 36 */
npx_fstenv,		/* d9 37 */
npx_fstcw,		/* d9 38 */
npx_fstcw,		/* d9 39 */
npx_fstcw,		/* d9 3a */
npx_fstcw,		/* d9 3b */
npx_fstcw,		/* d9 3c */
npx_fstcw,		/* d9 3d */
npx_fstcw,		/* d9 3e */
npx_fstcw,		/* d9 3f */
npx_fld_short,		/* d9 40 */
npx_fld_short,		/* d9 41 */
npx_fld_short,		/* d9 42 */
npx_fld_short,		/* d9 43 */
npx_fld_short,		/* d9 44 */
npx_fld_short,		/* d9 45 */
npx_fld_short,		/* d9 46 */
npx_fld_short,		/* d9 47 */
npx_funimp,		/* d9 48 */
npx_funimp,		/* d9 49 */
npx_funimp,		/* d9 4a */
npx_funimp,		/* d9 4b */
npx_funimp,		/* d9 4c */
npx_funimp,		/* d9 4d */
npx_funimp,		/* d9 4e */
npx_funimp,		/* d9 4f */
npx_fst_short,		/* d9 50 */
npx_fst_short,		/* d9 51 */
npx_fst_short,		/* d9 52 */
npx_fst_short,		/* d9 53 */
npx_fst_short,		/* d9 54 */
npx_fst_short,		/* d9 55 */
npx_fst_short,		/* d9 56 */
npx_fst_short,		/* d9 57 */
npx_fstp_short,		/* d9 58 */
npx_fstp_short,		/* d9 59 */
npx_fstp_short,		/* d9 5a */
npx_fstp_short,		/* d9 5b */
npx_fstp_short,		/* d9 5c */
npx_fstp_short,		/* d9 5d */
npx_fstp_short,		/* d9 5e */
npx_fstp_short,		/* d9 5f */
npx_fldenv,		/* d9 60 */
npx_fldenv,		/* d9 61 */
npx_fldenv,		/* d9 62 */
npx_fldenv,		/* d9 63 */
npx_fldenv,		/* d9 64 */
npx_fldenv,		/* d9 65 */
npx_fldenv,		/* d9 66 */
npx_fldenv,		/* d9 67 */
npx_fldcw,		/* d9 68 */
npx_fldcw,		/* d9 69 */
npx_fldcw,		/* d9 6a */
npx_fldcw,		/* d9 6b */
npx_fldcw,		/* d9 6c */
npx_fldcw,		/* d9 6d */
npx_fldcw,		/* d9 6e */
npx_fldcw,		/* d9 6f */
npx_fstenv,		/* d9 70 */
npx_fstenv,		/* d9 71 */
npx_fstenv,		/* d9 72 */
npx_fstenv,		/* d9 73 */
npx_fstenv,		/* d9 74 */
npx_fstenv,		/* d9 75 */
npx_fstenv,		/* d9 76 */
npx_fstenv,		/* d9 77 */
npx_fstcw,		/* d9 78 */
npx_fstcw,		/* d9 79 */
npx_fstcw,		/* d9 7a */
npx_fstcw,		/* d9 7b */
npx_fstcw,		/* d9 7c */
npx_fstcw,		/* d9 7d */
npx_fstcw,		/* d9 7e */
npx_fstcw,		/* d9 7f */
npx_fld_short,		/* d9 80 */
npx_fld_short,		/* d9 81 */
npx_fld_short,		/* d9 82 */
npx_fld_short,		/* d9 83 */
npx_fld_short,		/* d9 84 */
npx_fld_short,		/* d9 85 */
npx_fld_short,		/* d9 86 */
npx_fld_short,		/* d9 87 */
npx_funimp,		/* d9 88 */
npx_funimp,		/* d9 89 */
npx_funimp,		/* d9 8a */
npx_funimp,		/* d9 8b */
npx_funimp,		/* d9 8c */
npx_funimp,		/* d9 8d */
npx_funimp,		/* d9 8e */
npx_funimp,		/* d9 8f */
npx_fst_short,		/* d9 90 */
npx_fst_short,		/* d9 91 */
npx_fst_short,		/* d9 92 */
npx_fst_short,		/* d9 93 */
npx_fst_short,		/* d9 94 */
npx_fst_short,		/* d9 95 */
npx_fst_short,		/* d9 96 */
npx_fst_short,		/* d9 97 */
npx_fstp_short,		/* d9 98 */
npx_fstp_short,		/* d9 99 */
npx_fstp_short,		/* d9 9a */
npx_fstp_short,		/* d9 9b */
npx_fstp_short,		/* d9 9c */
npx_fstp_short,		/* d9 9d */
npx_fstp_short,		/* d9 9e */
npx_fstp_short,		/* d9 9f */
npx_fldenv,		/* d9 a0 */
npx_fldenv,		/* d9 a1 */
npx_fldenv,		/* d9 a2 */
npx_fldenv,		/* d9 a3 */
npx_fldenv,		/* d9 a4 */
npx_fldenv,		/* d9 a5 */
npx_fldenv,		/* d9 a6 */
npx_fldenv,		/* d9 a7 */
npx_fldcw,		/* d9 a8 */
npx_fldcw,		/* d9 a9 */
npx_fldcw,		/* d9 aa */
npx_fldcw,		/* d9 ab */
npx_fldcw,		/* d9 ac */
npx_fldcw,		/* d9 ad */
npx_fldcw,		/* d9 ae */
npx_fldcw,		/* d9 af */
npx_fstenv,		/* d9 b0 */
npx_fstenv,		/* d9 b1 */
npx_fstenv,		/* d9 b2 */
npx_fstenv,		/* d9 b3 */
npx_fstenv,		/* d9 b4 */
npx_fstenv,		/* d9 b5 */
npx_fstenv,		/* d9 b6 */
npx_fstenv,		/* d9 b7 */
npx_fstcw,		/* d9 b8 */
npx_fstcw,		/* d9 b9 */
npx_fstcw,		/* d9 ba */
npx_fstcw,		/* d9 bb */
npx_fstcw,		/* d9 bc */
npx_fstcw,		/* d9 bd */
npx_fstcw,		/* d9 be */
npx_fstcw,		/* d9 bf */
npx_fld_f0,		/* d9 c0 */
npx_fld_f1,	
npx_fld_f2,	
npx_fld_f3,	
npx_fld_f4,	
npx_fld_f5,	
npx_fld_f6,	
npx_fld_f7,
npx_fxch_f0,
npx_fxch_f1,
npx_fxch_f2,
npx_fxch_f3,
npx_fxch_f4,
npx_fxch_f5,
npx_fxch_f6,
npx_fxch_f7,
npx_fnop,		/* d9 d0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_fstp_f0,
npx_fstp_f1,
npx_fstp_f2,
npx_fstp_f3,
npx_fstp_f4,
npx_fstp_f5,
npx_fstp_f6,
npx_fstp_f7,
npx_fchs,		/* d9 e0 */
npx_fabs,		/* d9 e1 */
npx_funimp,
npx_funimp,
npx_ftst,		/* d9 e4 */
npx_fxam,		/* d9 e5 */
npx_funimp,
npx_funimp,
npx_fld1,		/* d9 e8 */
npx_fldl2t,		/* d9 e9 */
npx_fldl2e,		/* d9 ea */
npx_fldpi,		/* d9 eb */
npx_fldlg2,		/* d9 ec */
npx_fldln2,		/* d9 ed */
npx_fldz,		/* d9 ee */
npx_funimp,
npx_f2xm1,		/* d9 f0 */
npx_fyl2x,		/* d9 f1 */
npx_fptan,		/* d9 f2 */
npx_fpatan,		/* d9 f3 */
npx_fxtract,		/* d9 f4 */
npx_fprem1,		/* d9 f5 */
npx_fdecstp,		/* d9 f6 */
npx_fincstp,		/* d9 f7 */
npx_fprem,		/* d9 f8 */
npx_fyl2xp1,		/* d9 f9 */
npx_fsqrt,		/* d9 fa */
npx_fsincos,		/* d9 fb */
npx_frndint,		/* d9 fc */
npx_fscale,		/* d9 fd */
npx_fsin,		/* d9 fe */
npx_fcos,		/* d9 ff */
npx_fiadd_short,	/* da 00 */
npx_fiadd_short,	/* da 01 */
npx_fiadd_short,	/* da 02 */
npx_fiadd_short,	/* da 03 */
npx_fiadd_short,	/* da 04 */
npx_fiadd_short,	/* da 05 */
npx_fiadd_short,	/* da 06 */
npx_fiadd_short,	/* da 07 */
npx_fimul_short,	/* da 08 */
npx_fimul_short,	/* da 09 */
npx_fimul_short,	/* da 0a */
npx_fimul_short,	/* da 0b */
npx_fimul_short,	/* da 0c */
npx_fimul_short,	/* da 0d */
npx_fimul_short,	/* da 0e */
npx_fimul_short,	/* da 0f */
npx_ficom_short,	/* da 10 */
npx_ficom_short,	/* da 11 */
npx_ficom_short,	/* da 12 */
npx_ficom_short,	/* da 13 */
npx_ficom_short,	/* da 14 */
npx_ficom_short,	/* da 15 */
npx_ficom_short,	/* da 16 */
npx_ficom_short,	/* da 17 */
npx_ficomp_short,	/* da 18 */
npx_ficomp_short,	/* da 19 */
npx_ficomp_short,	/* da 1a */
npx_ficomp_short,	/* da 1b */
npx_ficomp_short,	/* da 1c */
npx_ficomp_short,	/* da 1d */
npx_ficomp_short,	/* da 1e */
npx_ficomp_short,	/* da 1f */
npx_fisub_short,	/* da 20 */
npx_fisub_short,	/* da 21 */
npx_fisub_short,	/* da 22 */
npx_fisub_short,	/* da 23 */
npx_fisub_short,	/* da 24 */
npx_fisub_short,	/* da 25 */
npx_fisub_short,	/* da 26 */
npx_fisub_short,	/* da 27 */
npx_fisubr_short,	/* da 28 */
npx_fisubr_short,	/* da 29 */
npx_fisubr_short,	/* da 2a */
npx_fisubr_short,	/* da 2b */
npx_fisubr_short,	/* da 2c */
npx_fisubr_short,	/* da 2d */
npx_fisubr_short,	/* da 2e */
npx_fisubr_short,	/* da 2f */
npx_fidiv_short,	/* da 30 */
npx_fidiv_short,	/* da 31 */
npx_fidiv_short,	/* da 32 */
npx_fidiv_short,	/* da 33 */
npx_fidiv_short,	/* da 34 */
npx_fidiv_short,	/* da 35 */
npx_fidiv_short,	/* da 36 */
npx_fidiv_short,	/* da 37 */
npx_fidivr_short,	/* da 38 */
npx_fidivr_short,	/* da 39 */
npx_fidivr_short,	/* da 3a */
npx_fidivr_short,	/* da 3b */
npx_fidivr_short,	/* da 3c */
npx_fidivr_short,	/* da 3d */
npx_fidivr_short,	/* da 3e */
npx_fidivr_short,	/* da 3f */
npx_fiadd_short,	/* da 40 */
npx_fiadd_short,	/* da 41 */
npx_fiadd_short,	/* da 42 */
npx_fiadd_short,	/* da 43 */
npx_fiadd_short,	/* da 44 */
npx_fiadd_short,	/* da 45 */
npx_fiadd_short,	/* da 46 */
npx_fiadd_short,	/* da 47 */
npx_fimul_short,	/* da 48 */
npx_fimul_short,	/* da 49 */
npx_fimul_short,	/* da 4a */
npx_fimul_short,	/* da 4b */
npx_fimul_short,	/* da 4c */
npx_fimul_short,	/* da 4d */
npx_fimul_short,	/* da 4e */
npx_fimul_short,	/* da 4f */
npx_ficom_short,	/* da 50 */
npx_ficom_short,	/* da 51 */
npx_ficom_short,	/* da 52 */
npx_ficom_short,	/* da 53 */
npx_ficom_short,	/* da 54 */
npx_ficom_short,	/* da 55 */
npx_ficom_short,	/* da 56 */
npx_ficom_short,	/* da 57 */
npx_ficomp_short,	/* da 58 */
npx_ficomp_short,	/* da 59 */
npx_ficomp_short,	/* da 5a */
npx_ficomp_short,	/* da 5b */
npx_ficomp_short,	/* da 5c */
npx_ficomp_short,	/* da 5d */
npx_ficomp_short,	/* da 5e */
npx_ficomp_short,	/* da 5f */
npx_fisub_short,	/* da 60 */
npx_fisub_short,	/* da 61 */
npx_fisub_short,	/* da 62 */
npx_fisub_short,	/* da 63 */
npx_fisub_short,	/* da 64 */
npx_fisub_short,	/* da 65 */
npx_fisub_short,	/* da 66 */
npx_fisub_short,	/* da 67 */
npx_fisubr_short,	/* da 68 */
npx_fisubr_short,	/* da 69 */
npx_fisubr_short,	/* da 6a */
npx_fisubr_short,	/* da 6b */
npx_fisubr_short,	/* da 6c */
npx_fisubr_short,	/* da 6d */
npx_fisubr_short,	/* da 6e */
npx_fisubr_short,	/* da 6f */
npx_fidiv_short,	/* da 70 */
npx_fidiv_short,	/* da 71 */
npx_fidiv_short,	/* da 72 */
npx_fidiv_short,	/* da 73 */
npx_fidiv_short,	/* da 74 */
npx_fidiv_short,	/* da 75 */
npx_fidiv_short,	/* da 76 */
npx_fidiv_short,	/* da 77 */
npx_fidivr_short,	/* da 78 */
npx_fidivr_short,	/* da 79 */
npx_fidivr_short,	/* da 7a */
npx_fidivr_short,	/* da 7b */
npx_fidivr_short,	/* da 7c */
npx_fidivr_short,	/* da 7d */
npx_fidivr_short,	/* da 7e */
npx_fidivr_short,	/* da 7f */
npx_fiadd_short,	/* da 80 */
npx_fiadd_short,	/* da 81 */
npx_fiadd_short,	/* da 82 */
npx_fiadd_short,	/* da 83 */
npx_fiadd_short,	/* da 84 */
npx_fiadd_short,	/* da 85 */
npx_fiadd_short,	/* da 86 */
npx_fiadd_short,	/* da 87 */
npx_fimul_short,	/* da 88 */
npx_fimul_short,	/* da 89 */
npx_fimul_short,	/* da 8a */
npx_fimul_short,	/* da 8b */
npx_fimul_short,	/* da 8c */
npx_fimul_short,	/* da 8d */
npx_fimul_short,	/* da 8e */
npx_fimul_short,	/* da 8f */
npx_ficom_short,	/* da 90 */
npx_ficom_short,	/* da 91 */
npx_ficom_short,	/* da 92 */
npx_ficom_short,	/* da 93 */
npx_ficom_short,	/* da 94 */
npx_ficom_short,	/* da 95 */
npx_ficom_short,	/* da 96 */
npx_ficom_short,	/* da 97 */
npx_ficomp_short,	/* da 98 */
npx_ficomp_short,	/* da 99 */
npx_ficomp_short,	/* da 9a */
npx_ficomp_short,	/* da 9b */
npx_ficomp_short,	/* da 9c */
npx_ficomp_short,	/* da 9d */
npx_ficomp_short,	/* da 9e */
npx_ficomp_short,	/* da 9f */
npx_fisub_short,	/* da a0 */
npx_fisub_short,	/* da a1 */
npx_fisub_short,	/* da a2 */
npx_fisub_short,	/* da a3 */
npx_fisub_short,	/* da a4 */
npx_fisub_short,	/* da a5 */
npx_fisub_short,	/* da a6 */
npx_fisub_short,	/* da a7 */
npx_fisubr_short,	/* da a8 */
npx_fisubr_short,	/* da a9 */
npx_fisubr_short,	/* da aa */
npx_fisubr_short,	/* da ab */
npx_fisubr_short,	/* da ac */
npx_fisubr_short,	/* da ad */
npx_fisubr_short,	/* da ae */
npx_fisubr_short,	/* da af */
npx_fidiv_short,	/* da b0 */
npx_fidiv_short,	/* da b1 */
npx_fidiv_short,	/* da b2 */
npx_fidiv_short,	/* da b3 */
npx_fidiv_short,	/* da b4 */
npx_fidiv_short,	/* da b5 */
npx_fidiv_short,	/* da b6 */
npx_fidiv_short,	/* da b7 */
npx_fidivr_short,	/* da b8 */
npx_fidivr_short,	/* da b9 */
npx_fidivr_short,	/* da ba */
npx_fidivr_short,	/* da bb */
npx_fidivr_short,	/* da bc */
npx_fidivr_short,	/* da bd */
npx_fidivr_short,	/* da be */
npx_fidivr_short,	/* da bf */
npx_funimp,		/* da c0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,	
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,		/* da d0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,	
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,		/* da e0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_fucompp,		/* da e9 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,		/* da f0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,	
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_fild_short,		/* db 00 */
npx_fild_short,		/* db 01 */
npx_fild_short,		/* db 02 */
npx_fild_short,		/* db 03 */
npx_fild_short,		/* db 04 */
npx_fild_short,		/* db 05 */
npx_fild_short,		/* db 06 */
npx_fild_short,		/* db 07 */
npx_funimp,		/* db 08 */
npx_funimp,		/* db 09 */
npx_funimp,		/* db 0a */
npx_funimp,		/* db 0b */
npx_funimp,		/* db 0c */
npx_funimp,		/* db 0d */
npx_funimp,		/* db 0e */
npx_funimp,		/* db 0f */
npx_fist_short,		/* db 10 */
npx_fist_short,		/* db 11 */
npx_fist_short,		/* db 12 */
npx_fist_short,		/* db 13 */
npx_fist_short,		/* db 14 */
npx_fist_short,		/* db 15 */
npx_fist_short,		/* db 16 */
npx_fist_short,		/* db 17 */
npx_fistp_short,	/* db 18 */
npx_fistp_short,	/* db 19 */
npx_fistp_short,	/* db 1a */
npx_fistp_short,	/* db 1b */
npx_fistp_short,	/* db 1c */
npx_fistp_short,	/* db 1d */
npx_fistp_short,	/* db 1e */
npx_fistp_short,	/* db 1f */
npx_funimp,		/* db 20 */
npx_funimp,		/* db 21 */
npx_funimp,		/* db 22 */
npx_funimp,		/* db 23 */
npx_funimp,		/* db 24 */
npx_funimp,		/* db 25 */
npx_funimp,		/* db 26 */
npx_funimp,		/* db 27 */
npx_fld_temp,		/* db 28 */
npx_fld_temp,		/* db 29 */
npx_fld_temp,		/* db 2a */
npx_fld_temp,		/* db 2b */
npx_fld_temp,		/* db 2c */
npx_fld_temp,		/* db 2d */
npx_fld_temp,		/* db 2e */
npx_fld_temp,		/* db 2f */
npx_funimp,		/* db 30 */
npx_funimp,		/* db 31 */
npx_funimp,		/* db 32 */
npx_funimp,		/* db 33 */
npx_funimp,		/* db 34 */
npx_funimp,		/* db 35 */
npx_funimp,		/* db 36 */
npx_funimp,		/* db 37 */
npx_fstp_temp,		/* db 38 */
npx_fstp_temp,		/* db 39 */
npx_fstp_temp,		/* db 3a */
npx_fstp_temp,		/* db 3b */
npx_fstp_temp,		/* db 3c */
npx_fstp_temp,		/* db 3d */
npx_fstp_temp,		/* db 3e */
npx_fstp_temp,		/* db 3f */
npx_fild_short,		/* db 40 */
npx_fild_short,		/* db 41 */
npx_fild_short,		/* db 42 */
npx_fild_short,		/* db 43 */
npx_fild_short,		/* db 44 */
npx_fild_short,		/* db 45 */
npx_fild_short,		/* db 46 */
npx_fild_short,		/* db 47 */
npx_funimp,		/* db 48 */
npx_funimp,		/* db 49 */
npx_funimp,		/* db 4a */
npx_funimp,		/* db 4b */
npx_funimp,		/* db 4c */
npx_funimp,		/* db 4d */
npx_funimp,		/* db 4e */
npx_funimp,		/* db 4f */
npx_fist_short,		/* db 50 */
npx_fist_short,		/* db 51 */
npx_fist_short,		/* db 52 */
npx_fist_short,		/* db 53 */
npx_fist_short,		/* db 54 */
npx_fist_short,		/* db 55 */
npx_fist_short,		/* db 56 */
npx_fist_short,		/* db 57 */
npx_fistp_short,	/* db 58 */
npx_fistp_short,	/* db 59 */
npx_fistp_short,	/* db 5a */
npx_fistp_short,	/* db 5b */
npx_fistp_short,	/* db 5c */
npx_fistp_short,	/* db 5d */
npx_fistp_short,	/* db 5e */
npx_fistp_short,	/* db 5f */
npx_funimp,		/* db 60 */
npx_funimp,		/* db 61 */
npx_funimp,		/* db 62 */
npx_funimp,		/* db 63 */
npx_funimp,		/* db 64 */
npx_funimp,		/* db 65 */
npx_funimp,		/* db 66 */
npx_funimp,		/* db 67 */
npx_fld_temp,		/* db 68 */
npx_fld_temp,		/* db 69 */
npx_fld_temp,		/* db 6a */
npx_fld_temp,		/* db 6b */
npx_fld_temp,		/* db 6c */
npx_fld_temp,		/* db 6d */
npx_fld_temp,		/* db 6e */
npx_fld_temp,		/* db 6f */
npx_funimp,		/* db 70 */
npx_funimp,		/* db 71 */
npx_funimp,		/* db 72 */
npx_funimp,		/* db 73 */
npx_funimp,		/* db 74 */
npx_funimp,		/* db 75 */
npx_funimp,		/* db 76 */
npx_funimp,		/* db 77 */
npx_fstp_temp,		/* db 78 */
npx_fstp_temp,		/* db 79 */
npx_fstp_temp,		/* db 7a */
npx_fstp_temp,		/* db 7b */
npx_fstp_temp,		/* db 7c */
npx_fstp_temp,		/* db 7d */
npx_fstp_temp,		/* db 7e */
npx_fstp_temp,		/* db 7f */
npx_fild_short,		/* db 80 */
npx_fild_short,		/* db 81 */
npx_fild_short,		/* db 82 */
npx_fild_short,		/* db 83 */
npx_fild_short,		/* db 84 */
npx_fild_short,		/* db 85 */
npx_fild_short,		/* db 86 */
npx_fild_short,		/* db 87 */
npx_funimp,		/* db 88 */
npx_funimp,		/* db 89 */
npx_funimp,		/* db 8a */
npx_funimp,		/* db 8b */
npx_funimp,		/* db 8c */
npx_funimp,		/* db 8d */
npx_funimp,		/* db 8e */
npx_funimp,		/* db 8f */
npx_fist_short,		/* db 90 */
npx_fist_short,		/* db 91 */
npx_fist_short,		/* db 92 */
npx_fist_short,		/* db 93 */
npx_fist_short,		/* db 94 */
npx_fist_short,		/* db 95 */
npx_fist_short,		/* db 96 */
npx_fist_short,		/* db 97 */
npx_fistp_short,	/* db 98 */
npx_fistp_short,	/* db 99 */
npx_fistp_short,	/* db 9a */
npx_fistp_short,	/* db 9b */
npx_fistp_short,	/* db 9c */
npx_fistp_short,	/* db 9d */
npx_fistp_short,	/* db 9e */
npx_fistp_short,	/* db 9f */
npx_funimp,		/* db a0 */
npx_funimp,		/* db a1 */
npx_funimp,		/* db a2 */
npx_funimp,		/* db a3 */
npx_funimp,		/* db a4 */
npx_funimp,		/* db a5 */
npx_funimp,		/* db a6 */
npx_funimp,		/* db a7 */
npx_fld_temp,		/* db a8 */
npx_fld_temp,		/* db a9 */
npx_fld_temp,		/* db aa */
npx_fld_temp,		/* db ab */
npx_fld_temp,		/* db ac */
npx_fld_temp,		/* db ad */
npx_fld_temp,		/* db ae */
npx_fld_temp,		/* db af */
npx_funimp,		/* db b0 */
npx_funimp,		/* db b1 */
npx_funimp,		/* db b2 */
npx_funimp,		/* db b3 */
npx_funimp,		/* db b4 */
npx_funimp,		/* db b5 */
npx_funimp,		/* db b6 */
npx_funimp,		/* db b7 */
npx_fstp_temp,		/* db b8 */
npx_fstp_temp,		/* db b9 */
npx_fstp_temp,		/* db ba */
npx_fstp_temp,		/* db bb */
npx_fstp_temp,		/* db bc */
npx_fstp_temp,		/* db bd */
npx_fstp_temp,		/* db be */
npx_fstp_temp,		/* db bf */
npx_funimp,		/* db c0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,		/* db d0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_fnop,		/* db e0 */
npx_fnop,
npx_fclex,		/* db e2 */
npx_finit,		/* db e3 */
npx_fnop,		/* db e4 - used to be fsetpm */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,		/* db f0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_fadd_long,		/* dc 00 */
npx_fadd_long,		/* dc 01 */
npx_fadd_long,		/* dc 02 */
npx_fadd_long,		/* dc 03 */
npx_fadd_long,		/* dc 04 */
npx_fadd_long,		/* dc 05 */
npx_fadd_long,		/* dc 06 */
npx_fadd_long,		/* dc 07 */
npx_fmul_long,		/* dc 08 */
npx_fmul_long,		/* dc 09 */
npx_fmul_long,		/* dc 0a */
npx_fmul_long,		/* dc 0b */
npx_fmul_long,		/* dc 0c */
npx_fmul_long,		/* dc 0d */
npx_fmul_long,		/* dc 0e */
npx_fmul_long,		/* dc 0f */
npx_fcom_long,		/* dc 10 */
npx_fcom_long,		/* dc 11 */
npx_fcom_long,		/* dc 12 */
npx_fcom_long,		/* dc 13 */
npx_fcom_long,		/* dc 14 */
npx_fcom_long,		/* dc 15 */
npx_fcom_long,		/* dc 16 */
npx_fcom_long,		/* dc 17 */
npx_fcomp_long,		/* dc 18 */
npx_fcomp_long,		/* dc 19 */
npx_fcomp_long,		/* dc 1a */
npx_fcomp_long,		/* dc 1b */
npx_fcomp_long,		/* dc 1c */
npx_fcomp_long,		/* dc 1d */
npx_fcomp_long,		/* dc 1e */
npx_fcomp_long,		/* dc 1f */
npx_fsub_long,		/* dc 20 */
npx_fsub_long,		/* dc 21 */
npx_fsub_long,		/* dc 22 */
npx_fsub_long,		/* dc 23 */
npx_fsub_long,		/* dc 24 */
npx_fsub_long,		/* dc 25 */
npx_fsub_long,		/* dc 26 */
npx_fsub_long,		/* dc 27 */
npx_fsubr_long,		/* dc 28 */
npx_fsubr_long,		/* dc 29 */
npx_fsubr_long,		/* dc 2a */
npx_fsubr_long,		/* dc 2b */
npx_fsubr_long,		/* dc 2c */
npx_fsubr_long,		/* dc 2d */
npx_fsubr_long,		/* dc 2e */
npx_fsubr_long,		/* dc 2f */
npx_fdiv_long,		/* dc 30 */
npx_fdiv_long,		/* dc 31 */
npx_fdiv_long,		/* dc 32 */
npx_fdiv_long,		/* dc 33 */
npx_fdiv_long,		/* dc 34 */
npx_fdiv_long,		/* dc 35 */
npx_fdiv_long,		/* dc 36 */
npx_fdiv_long,		/* dc 37 */
npx_fdivr_long,		/* dc 38 */
npx_fdivr_long,		/* dc 39 */
npx_fdivr_long,		/* dc 3a */
npx_fdivr_long,		/* dc 3b */
npx_fdivr_long,		/* dc 3c */
npx_fdivr_long,		/* dc 3d */
npx_fdivr_long,		/* dc 3e */
npx_fdivr_long,		/* dc 3f */
npx_fadd_long,		/* dc 40 */
npx_fadd_long,		/* dc 41 */
npx_fadd_long,		/* dc 42 */
npx_fadd_long,		/* dc 43 */
npx_fadd_long,		/* dc 44 */
npx_fadd_long,		/* dc 45 */
npx_fadd_long,		/* dc 46 */
npx_fadd_long,		/* dc 47 */
npx_fmul_long,		/* dc 48 */
npx_fmul_long,		/* dc 49 */
npx_fmul_long,		/* dc 4a */
npx_fmul_long,		/* dc 4b */
npx_fmul_long,		/* dc 4c */
npx_fmul_long,		/* dc 4d */
npx_fmul_long,		/* dc 4e */
npx_fmul_long,		/* dc 4f */
npx_fcom_long,		/* dc 50 */
npx_fcom_long,		/* dc 51 */
npx_fcom_long,		/* dc 52 */
npx_fcom_long,		/* dc 53 */
npx_fcom_long,		/* dc 54 */
npx_fcom_long,		/* dc 55 */
npx_fcom_long,		/* dc 56 */
npx_fcom_long,		/* dc 57 */
npx_fcomp_long,		/* dc 58 */
npx_fcomp_long,		/* dc 59 */
npx_fcomp_long,		/* dc 5a */
npx_fcomp_long,		/* dc 5b */
npx_fcomp_long,		/* dc 5c */
npx_fcomp_long,		/* dc 5d */
npx_fcomp_long,		/* dc 5e */
npx_fcomp_long,		/* dc 5f */
npx_fsub_long,		/* dc 60 */
npx_fsub_long,		/* dc 61 */
npx_fsub_long,		/* dc 62 */
npx_fsub_long,		/* dc 63 */
npx_fsub_long,		/* dc 64 */
npx_fsub_long,		/* dc 65 */
npx_fsub_long,		/* dc 66 */
npx_fsub_long,		/* dc 67 */
npx_fsubr_long,		/* dc 68 */
npx_fsubr_long,		/* dc 69 */
npx_fsubr_long,		/* dc 6a */
npx_fsubr_long,		/* dc 6b */
npx_fsubr_long,		/* dc 6c */
npx_fsubr_long,		/* dc 6d */
npx_fsubr_long,		/* dc 6e */
npx_fsubr_long,		/* dc 6f */
npx_fdiv_long,		/* dc 70 */
npx_fdiv_long,		/* dc 71 */
npx_fdiv_long,		/* dc 72 */
npx_fdiv_long,		/* dc 73 */
npx_fdiv_long,		/* dc 74 */
npx_fdiv_long,		/* dc 75 */
npx_fdiv_long,		/* dc 76 */
npx_fdiv_long,		/* dc 77 */
npx_fdivr_long,		/* dc 78 */
npx_fdivr_long,		/* dc 79 */
npx_fdivr_long,		/* dc 7a */
npx_fdivr_long,		/* dc 7b */
npx_fdivr_long,		/* dc 7c */
npx_fdivr_long,		/* dc 7d */
npx_fdivr_long,		/* dc 7e */
npx_fdivr_long,		/* dc 7f */
npx_fadd_long,		/* dc 80 */
npx_fadd_long,		/* dc 81 */
npx_fadd_long,		/* dc 82 */
npx_fadd_long,		/* dc 83 */
npx_fadd_long,		/* dc 84 */
npx_fadd_long,		/* dc 85 */
npx_fadd_long,		/* dc 86 */
npx_fadd_long,		/* dc 87 */
npx_fmul_long,		/* dc 88 */
npx_fmul_long,		/* dc 89 */
npx_fmul_long,		/* dc 8a */
npx_fmul_long,		/* dc 8b */
npx_fmul_long,		/* dc 8c */
npx_fmul_long,		/* dc 8d */
npx_fmul_long,		/* dc 8e */
npx_fmul_long,		/* dc 8f */
npx_fcom_long,		/* dc 90 */
npx_fcom_long,		/* dc 91 */
npx_fcom_long,		/* dc 92 */
npx_fcom_long,		/* dc 93 */
npx_fcom_long,		/* dc 94 */
npx_fcom_long,		/* dc 95 */
npx_fcom_long,		/* dc 96 */
npx_fcom_long,		/* dc 97 */
npx_fcomp_long,		/* dc 98 */
npx_fcomp_long,		/* dc 99 */
npx_fcomp_long,		/* dc 9a */
npx_fcomp_long,		/* dc 9b */
npx_fcomp_long,		/* dc 9c */
npx_fcomp_long,		/* dc 9d */
npx_fcomp_long,		/* dc 9e */
npx_fcomp_long,		/* dc 9f */
npx_fsub_long,		/* dc a0 */
npx_fsub_long,		/* dc a1 */
npx_fsub_long,		/* dc a2 */
npx_fsub_long,		/* dc a3 */
npx_fsub_long,		/* dc a4 */
npx_fsub_long,		/* dc a5 */
npx_fsub_long,		/* dc a6 */
npx_fsub_long,		/* dc a7 */
npx_fsubr_long,		/* dc a8 */
npx_fsubr_long,		/* dc a9 */
npx_fsubr_long,		/* dc aa */
npx_fsubr_long,		/* dc ab */
npx_fsubr_long,		/* dc ac */
npx_fsubr_long,		/* dc ad */
npx_fsubr_long,		/* dc ae */
npx_fsubr_long,		/* dc af */
npx_fdiv_long,		/* dc b0 */
npx_fdiv_long,		/* dc b1 */
npx_fdiv_long,		/* dc b2 */
npx_fdiv_long,		/* dc b3 */
npx_fdiv_long,		/* dc b4 */
npx_fdiv_long,		/* dc b5 */
npx_fdiv_long,		/* dc b6 */
npx_fdiv_long,		/* dc b7 */
npx_fdivr_long,		/* dc b8 */
npx_fdivr_long,		/* dc b9 */
npx_fdivr_long,		/* dc 3a */
npx_fdivr_long,		/* dc bb */
npx_fdivr_long,		/* dc bc */
npx_fdivr_long,		/* dc bd */
npx_fdivr_long,		/* dc be */
npx_fdivr_long,		/* dc bf */
npx_fadd_f0_f0,		/* dc c0 */
npx_fadd_f1_f0,
npx_fadd_f2_f0,
npx_fadd_f3_f0,
npx_fadd_f4_f0,
npx_fadd_f5_f0,
npx_fadd_f6_f0,
npx_fadd_f7_f0,
npx_fmul_f0_f0,		/* dc c8 */
npx_fmul_f1_f0,
npx_fmul_f2_f0,
npx_fmul_f3_f0,
npx_fmul_f4_f0,
npx_fmul_f5_f0,
npx_fmul_f6_f0,
npx_fmul_f7_f0,
npx_fcom_f0,		/* dc d0 */
npx_fcom_f1,
npx_fcom_f2,
npx_fcom_f3,
npx_fcom_f4,
npx_fcom_f5,
npx_fcom_f6,
npx_fcom_f7,
npx_fcomp_f0,
npx_fcomp_f1,
npx_fcomp_f2,
npx_fcomp_f3,
npx_fcomp_f4,
npx_fcomp_f5,
npx_fcomp_f6,
npx_fcomp_f7,
npx_fsubr_f0_f0,	/* dc e0 */
npx_fsubr_f1_f0,
npx_fsubr_f2_f0,
npx_fsubr_f3_f0,
npx_fsubr_f4_f0,
npx_fsubr_f5_f0,
npx_fsubr_f6_f0,
npx_fsubr_f7_f0,
npx_fsub_f0_f0,		/* dc e8 */
npx_fsub_f1_f0,
npx_fsub_f2_f0,
npx_fsub_f3_f0,
npx_fsub_f4_f0,
npx_fsub_f5_f0,
npx_fsub_f6_f0,
npx_fsub_f7_f0,
npx_fdivr_f0_f0,	/* dc f0 */
npx_fdivr_f1_f0,
npx_fdivr_f2_f0,
npx_fdivr_f3_f0,
npx_fdivr_f4_f0,
npx_fdivr_f5_f0,
npx_fdivr_f6_f0,
npx_fdivr_f7_f0,
npx_fdiv_f0_f0,		/* dc f8 */
npx_fdiv_f1_f0,
npx_fdiv_f2_f0,
npx_fdiv_f3_f0,
npx_fdiv_f4_f0,
npx_fdiv_f5_f0,
npx_fdiv_f6_f0,
npx_fdiv_f7_f0,
npx_fld_long,		/* dd 00 */
npx_fld_long,		/* dd 01 */
npx_fld_long,		/* dd 02 */
npx_fld_long,		/* dd 03 */
npx_fld_long,		/* dd 04 */
npx_fld_long,		/* dd 05 */
npx_fld_long,		/* dd 06 */
npx_fld_long,		/* dd 07 */
npx_funimp,		/* dd 08 */
npx_funimp,		/* dd 09 */
npx_funimp,		/* dd 0a */
npx_funimp,		/* dd 0b */
npx_funimp,		/* dd 0c */
npx_funimp,		/* dd 0d */
npx_funimp,		/* dd 0e */
npx_funimp,		/* dd 0f */
npx_fst_long,		/* dd 10 */
npx_fst_long,		/* dd 11 */
npx_fst_long,		/* dd 12 */
npx_fst_long,		/* dd 13 */
npx_fst_long,		/* dd 14 */
npx_fst_long,		/* dd 15 */
npx_fst_long,		/* dd 16 */
npx_fst_long,		/* dd 17 */
npx_fstp_long,		/* dd 18 */
npx_fstp_long,		/* dd 19 */
npx_fstp_long,		/* dd 1a */
npx_fstp_long,		/* dd 1b */
npx_fstp_long,		/* dd 1c */
npx_fstp_long,		/* dd 1d */
npx_fstp_long,		/* dd 1e */
npx_fstp_long,		/* dd 1f */
npx_frstor,		/* dd 20 */
npx_frstor,		/* dd 21 */
npx_frstor,		/* dd 22 */
npx_frstor,		/* dd 23 */
npx_frstor,		/* dd 24 */
npx_frstor,		/* dd 25 */
npx_frstor,		/* dd 26 */
npx_frstor,		/* dd 27 */
npx_funimp,		/* dd 28 */
npx_funimp,		/* dd 29 */
npx_funimp,		/* dd 2a */
npx_funimp,		/* dd 2b */
npx_funimp,		/* dd 2c */
npx_funimp,		/* dd 2d */
npx_funimp,		/* dd 2e */
npx_funimp,		/* dd 2f */
npx_fsave,		/* dd 30 */
npx_fsave,		/* dd 31 */
npx_fsave,		/* dd 32 */
npx_fsave,		/* dd 33 */
npx_fsave,		/* dd 34 */
npx_fsave,		/* dd 35 */
npx_fsave,		/* dd 36 */
npx_fsave,		/* dd 37 */
npx_fstsw,		/* dd 38 */
npx_fstsw,		/* dd 39 */
npx_fstsw,		/* dd 3a */
npx_fstsw,		/* dd 3b */
npx_fstsw,		/* dd 3c */
npx_fstsw,		/* dd 3d */
npx_fstsw,		/* dd 3e */
npx_fstsw,		/* dd 3f */
npx_fld_long,		/* dd 40 */
npx_fld_long,		/* dd 41 */
npx_fld_long,		/* dd 42 */
npx_fld_long,		/* dd 43 */
npx_fld_long,		/* dd 44 */
npx_fld_long,		/* dd 45 */
npx_fld_long,		/* dd 46 */
npx_fld_long,		/* dd 47 */
npx_funimp,		/* dd 48 */
npx_funimp,		/* dd 49 */
npx_funimp,		/* dd 4a */
npx_funimp,		/* dd 4b */
npx_funimp,		/* dd 4c */
npx_funimp,		/* dd 4d */
npx_funimp,		/* dd 4e */
npx_funimp,		/* dd 4f */
npx_fst_long,		/* dd 50 */
npx_fst_long,		/* dd 51 */
npx_fst_long,		/* dd 52 */
npx_fst_long,		/* dd 53 */
npx_fst_long,		/* dd 54 */
npx_fst_long,		/* dd 55 */
npx_fst_long,		/* dd 56 */
npx_fst_long,		/* dd 57 */
npx_fstp_long,		/* dd 58 */
npx_fstp_long,		/* dd 59 */
npx_fstp_long,		/* dd 5a */
npx_fstp_long,		/* dd 5b */
npx_fstp_long,		/* dd 5c */
npx_fstp_long,		/* dd 5d */
npx_fstp_long,		/* dd 5e */
npx_fstp_long,		/* dd 5f */
npx_frstor,		/* dd 60 */
npx_frstor,		/* dd 61 */
npx_frstor,		/* dd 62 */
npx_frstor,		/* dd 63 */
npx_frstor,		/* dd 64 */
npx_frstor,		/* dd 65 */
npx_frstor,		/* dd 66 */
npx_frstor,		/* dd 67 */
npx_funimp,		/* dd 68 */
npx_funimp,		/* dd 69 */
npx_funimp,		/* dd 6a */
npx_funimp,		/* dd 6b */
npx_funimp,		/* dd 6c */
npx_funimp,		/* dd 6d */
npx_funimp,		/* dd 6e */
npx_funimp,		/* dd 6f */
npx_fsave,		/* dd 70 */
npx_fsave,		/* dd 71 */
npx_fsave,		/* dd 72 */
npx_fsave,		/* dd 73 */
npx_fsave,		/* dd 74 */
npx_fsave,		/* dd 75 */
npx_fsave,		/* dd 76 */
npx_fsave,		/* dd 77 */
npx_fstsw,		/* dd 78 */
npx_fstsw,		/* dd 79 */
npx_fstsw,		/* dd 7a */
npx_fstsw,		/* dd 7b */
npx_fstsw,		/* dd 7c */
npx_fstsw,		/* dd 7d */
npx_fstsw,		/* dd 7e */
npx_fstsw,		/* dd 7f */
npx_fld_long,		/* dd 80 */
npx_fld_long,		/* dd 81 */
npx_fld_long,		/* dd 82 */
npx_fld_long,		/* dd 83 */
npx_fld_long,		/* dd 84 */
npx_fld_long,		/* dd 85 */
npx_fld_long,		/* dd 86 */
npx_fld_long,		/* dd 87 */
npx_funimp,		/* dd 88 */
npx_funimp,		/* dd 89 */
npx_funimp,		/* dd 8a */
npx_funimp,		/* dd 8b */
npx_funimp,		/* dd 8c */
npx_funimp,		/* dd 8d */
npx_funimp,		/* dd 8e */
npx_funimp,		/* dd 8f */
npx_fst_long,		/* dd 90 */
npx_fst_long,		/* dd 91 */
npx_fst_long,		/* dd 92 */
npx_fst_long,		/* dd 93 */
npx_fst_long,		/* dd 94 */
npx_fst_long,		/* dd 95 */
npx_fst_long,		/* dd 96 */
npx_fst_long,		/* dd 97 */
npx_fstp_long,		/* dd 98 */
npx_fstp_long,		/* dd 99 */
npx_fstp_long,		/* dd 9a */
npx_fstp_long,		/* dd 9b */
npx_fstp_long,		/* dd 9c */
npx_fstp_long,		/* dd 9d */
npx_fstp_long,		/* dd 9e */
npx_fstp_long,		/* dd 9f */
npx_frstor,		/* dd a0 */
npx_frstor,		/* dd a1 */
npx_frstor,		/* dd a2 */
npx_frstor,		/* dd a3 */
npx_frstor,		/* dd a4 */
npx_frstor,		/* dd a5 */
npx_frstor,		/* dd a6 */
npx_frstor,		/* dd a7 */
npx_funimp,		/* dd a8 */
npx_funimp,		/* dd a9 */
npx_funimp,		/* dd aa */
npx_funimp,		/* dd ab */
npx_funimp,		/* dd ac */
npx_funimp,		/* dd ad */
npx_funimp,		/* dd ae */
npx_funimp,		/* dd af */
npx_fsave,		/* dd b0 */
npx_fsave,		/* dd b1 */
npx_fsave,		/* dd b2 */
npx_fsave,		/* dd b3 */
npx_fsave,		/* dd b4 */
npx_fsave,		/* dd b5 */
npx_fsave,		/* dd b6 */
npx_fsave,		/* dd b7 */
npx_fstsw,		/* dd b8 */
npx_fstsw,		/* dd b9 */
npx_fstsw,		/* dd ba */
npx_fstsw,		/* dd bb */
npx_fstsw,		/* dd bc */
npx_fstsw,		/* dd bd */
npx_fstsw,		/* dd be */
npx_fstsw,		/* dd bf */
npx_ffree_f0,		/* dd c0 */
npx_ffree_f1,
npx_ffree_f2,
npx_ffree_f3,
npx_ffree_f4,
npx_ffree_f5,
npx_ffree_f6,
npx_ffree_f7,
npx_fxch_f0,		/* dd c8 */
npx_fxch_f1,
npx_fxch_f2,
npx_fxch_f3,
npx_fxch_f4,
npx_fxch_f5,
npx_fxch_f6,
npx_fxch_f7,
npx_fst_f0,		/* dd d0 */
npx_fst_f1,
npx_fst_f2,
npx_fst_f3,
npx_fst_f4,
npx_fst_f5,
npx_fst_f6,
npx_fst_f7,
npx_fstp_f0,		/* dd d8 */
npx_fstp_f1,
npx_fstp_f2,
npx_fstp_f3,
npx_fstp_f4,
npx_fstp_f5,
npx_fstp_f6,
npx_fstp_f7,
npx_fucom_f0,		/* dd e0 */
npx_fucom_f1,
npx_fucom_f2,
npx_fucom_f3,
npx_fucom_f4,
npx_fucom_f5,
npx_fucom_f6,
npx_fucom_f7,
npx_fucomp_f0,		/* dd e8 */
npx_fucomp_f1,
npx_fucomp_f2,
npx_fucomp_f3,
npx_fucomp_f4,
npx_fucomp_f5,
npx_fucomp_f6,
npx_fucomp_f7,
npx_funimp,		/* dd f0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_fiadd_word,		/* de 00 */
npx_fiadd_word,		/* de 01 */
npx_fiadd_word,		/* de 02 */
npx_fiadd_word,		/* de 03 */
npx_fiadd_word,		/* de 04 */
npx_fiadd_word,		/* de 05 */
npx_fiadd_word,		/* de 06 */
npx_fiadd_word,		/* de 07 */
npx_fimul_word,		/* de 08 */
npx_fimul_word,		/* de 09 */
npx_fimul_word,		/* de 0a */
npx_fimul_word,		/* de 0b */
npx_fimul_word,		/* de 0c */
npx_fimul_word,		/* de 0d */
npx_fimul_word,		/* de 0e */
npx_fimul_word,		/* de 0f */
npx_ficom_word,		/* de 10 */
npx_ficom_word,		/* de 11 */
npx_ficom_word,		/* de 12 */
npx_ficom_word,		/* de 13 */
npx_ficom_word,		/* de 14 */
npx_ficom_word,		/* de 15 */
npx_ficom_word,		/* de 16 */
npx_ficom_word,		/* de 17 */
npx_ficomp_word,	/* de 18 */
npx_ficomp_word,	/* de 19 */
npx_ficomp_word,	/* de 1a */
npx_ficomp_word,	/* de 1b */
npx_ficomp_word,	/* de 1c */
npx_ficomp_word,	/* de 1d */
npx_ficomp_word,	/* de 1e */
npx_ficomp_word,	/* de 1f */
npx_fisub_word,		/* de 20 */
npx_fisub_word,		/* de 21 */
npx_fisub_word,		/* de 22 */
npx_fisub_word,		/* de 23 */
npx_fisub_word,		/* de 24 */
npx_fisub_word,		/* de 25 */
npx_fisub_word,		/* de 26 */
npx_fisub_word,		/* de 27 */
npx_fisubr_word,	/* de 28 */
npx_fisubr_word,	/* de 29 */
npx_fisubr_word,	/* de 2a */
npx_fisubr_word,	/* de 2b */
npx_fisubr_word,	/* de 2c */
npx_fisubr_word,	/* de 2d */
npx_fisubr_word,	/* de 2e */
npx_fisubr_word,	/* de 2f */
npx_fidiv_word,		/* de 30 */
npx_fidiv_word,		/* de 31 */
npx_fidiv_word,		/* de 32 */
npx_fidiv_word,		/* de 33 */
npx_fidiv_word,		/* de 34 */
npx_fidiv_word,		/* de 35 */
npx_fidiv_word,		/* de 36 */
npx_fidiv_word,		/* de 37 */
npx_fidivr_word,	/* de 38 */
npx_fidivr_word,	/* de 39 */
npx_fidivr_word,	/* de 3a */
npx_fidivr_word,	/* de 3b */
npx_fidivr_word,	/* de 3c */
npx_fidivr_word,	/* de 3d */
npx_fidivr_word,	/* de 3e */
npx_fidivr_word,	/* de 3f */
npx_fiadd_word,		/* de 40 */
npx_fiadd_word,		/* de 41 */
npx_fiadd_word,		/* de 42 */
npx_fiadd_word,		/* de 43 */
npx_fiadd_word,		/* de 44 */
npx_fiadd_word,		/* de 45 */
npx_fiadd_word,		/* de 46 */
npx_fiadd_word,		/* de 47 */
npx_fimul_word,		/* de 48 */
npx_fimul_word,		/* de 49 */
npx_fimul_word,		/* de 4a */
npx_fimul_word,		/* de 4b */
npx_fimul_word,		/* de 4c */
npx_fimul_word,		/* de 4d */
npx_fimul_word,		/* de 4e */
npx_fimul_word,		/* de 4f */
npx_ficom_word,		/* de 50 */
npx_ficom_word,		/* de 51 */
npx_ficom_word,		/* de 52 */
npx_ficom_word,		/* de 53 */
npx_ficom_word,		/* de 54 */
npx_ficom_word,		/* de 55 */
npx_ficom_word,		/* de 56 */
npx_ficom_word,		/* de 57 */
npx_ficomp_word,	/* de 58 */
npx_ficomp_word,	/* de 59 */
npx_ficomp_word,	/* de 5a */
npx_ficomp_word,	/* de 5b */
npx_ficomp_word,	/* de 5c */
npx_ficomp_word,	/* de 5d */
npx_ficomp_word,	/* de 5e */
npx_ficomp_word,	/* de 5f */
npx_fisub_word,		/* de 60 */
npx_fisub_word,		/* de 61 */
npx_fisub_word,		/* de 62 */
npx_fisub_word,		/* de 63 */
npx_fisub_word,		/* de 64 */
npx_fisub_word,		/* de 65 */
npx_fisub_word,		/* de 66 */
npx_fisub_word,		/* de 67 */
npx_fisubr_word,	/* de 68 */
npx_fisubr_word,	/* de 69 */
npx_fisubr_word,	/* de 6a */
npx_fisubr_word,	/* de 6b */
npx_fisubr_word,	/* de 6c */
npx_fisubr_word,	/* de 6d */
npx_fisubr_word,	/* de 6e */
npx_fisubr_word,	/* de 6f */
npx_fidiv_word,		/* de 70 */
npx_fidiv_word,		/* de 71 */
npx_fidiv_word,		/* de 72 */
npx_fidiv_word,		/* de 73 */
npx_fidiv_word,		/* de 74 */
npx_fidiv_word,		/* de 75 */
npx_fidiv_word,		/* de 76 */
npx_fidiv_word,		/* de 77 */
npx_fidivr_word,	/* de 78 */
npx_fidivr_word,	/* de 79 */
npx_fidivr_word,	/* de 7a */
npx_fidivr_word,	/* de 7b */
npx_fidivr_word,	/* de 7c */
npx_fidivr_word,	/* de 7d */
npx_fidivr_word,	/* de 7e */
npx_fidivr_word,	/* de 7f */
npx_fiadd_word,		/* de 80 */
npx_fiadd_word,		/* de 81 */
npx_fiadd_word,		/* de 82 */
npx_fiadd_word,		/* de 83 */
npx_fiadd_word,		/* de 84 */
npx_fiadd_word,		/* de 85 */
npx_fiadd_word,		/* de 86 */
npx_fiadd_word,		/* de 87 */
npx_fimul_word,		/* de 88 */
npx_fimul_word,		/* de 89 */
npx_fimul_word,		/* de 8a */
npx_fimul_word,		/* de 8b */
npx_fimul_word,		/* de 8c */
npx_fimul_word,		/* de 8d */
npx_fimul_word,		/* de 8e */
npx_fimul_word,		/* de 8f */
npx_ficom_word,		/* de 90 */
npx_ficom_word,		/* de 91 */
npx_ficom_word,		/* de 92 */
npx_ficom_word,		/* de 93 */
npx_ficom_word,		/* de 94 */
npx_ficom_word,		/* de 95 */
npx_ficom_word,		/* de 96 */
npx_ficom_word,		/* de 97 */
npx_ficomp_word,	/* de 98 */
npx_ficomp_word,	/* de 99 */
npx_ficomp_word,	/* de 9a */
npx_ficomp_word,	/* de 9b */
npx_ficomp_word,	/* de 9c */
npx_ficomp_word,	/* de 9d */
npx_ficomp_word,	/* de 9e */
npx_ficomp_word,	/* de 9f */
npx_fisub_word,		/* de a0 */
npx_fisub_word,		/* de a1 */
npx_fisub_word,		/* de a2 */
npx_fisub_word,		/* de a3 */
npx_fisub_word,		/* de a4 */
npx_fisub_word,		/* de a5 */
npx_fisub_word,		/* de a6 */
npx_fisub_word,		/* de a7 */
npx_fisubr_word,	/* de a8 */
npx_fisubr_word,	/* de a9 */
npx_fisubr_word,	/* de aa */
npx_fisubr_word,	/* de ab */
npx_fisubr_word,	/* de ac */
npx_fisubr_word,	/* de ad */
npx_fisubr_word,	/* de ae */
npx_fisubr_word,	/* de af */
npx_fidiv_word,		/* de b0 */
npx_fidiv_word,		/* de b1 */
npx_fidiv_word,		/* de b2 */
npx_fidiv_word,		/* de b3 */
npx_fidiv_word,		/* de b4 */
npx_fidiv_word,		/* de b5 */
npx_fidiv_word,		/* de b6 */
npx_fidiv_word,		/* de b7 */
npx_fidivr_word,	/* de b8 */
npx_fidivr_word,	/* de b9 */
npx_fidivr_word,	/* de ba */
npx_fidivr_word,	/* de bb */
npx_fidivr_word,	/* de bc */
npx_fidivr_word,	/* de bd */
npx_fidivr_word,	/* de be */
npx_fidivr_word,	/* de bf */
npx_faddp_f0,		/* de c0 */
npx_faddp_f1,
npx_faddp_f2,
npx_faddp_f3,
npx_faddp_f4,
npx_faddp_f5,
npx_faddp_f6,
npx_faddp_f7,
npx_fmulp_f0,		/* de c8 */
npx_fmulp_f1,
npx_fmulp_f2,
npx_fmulp_f3,
npx_fmulp_f4,
npx_fmulp_f5,
npx_fmulp_f6,
npx_fmulp_f7,
npx_fcomp_f0,		/* de d0 */
npx_fcomp_f1,
npx_fcomp_f2,
npx_fcomp_f3,
npx_fcomp_f4,
npx_fcomp_f5,
npx_fcomp_f6,
npx_fcomp_f7,
npx_funimp,
npx_fcompp,		/* de d9 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_fsubrp_f0,		/* de e0 */
npx_fsubrp_f1,
npx_fsubrp_f2,
npx_fsubrp_f3,
npx_fsubrp_f4,
npx_fsubrp_f5,
npx_fsubrp_f6,
npx_fsubrp_f7,
npx_fsubp_f0,		/* de e8 */
npx_fsubp_f1,
npx_fsubp_f2,
npx_fsubp_f3,
npx_fsubp_f4,
npx_fsubp_f5,
npx_fsubp_f6,
npx_fsubp_f7,
npx_fdivrp_f0,		/* de f0 */
npx_fdivrp_f1,
npx_fdivrp_f2,
npx_fdivrp_f3,
npx_fdivrp_f4,
npx_fdivrp_f5,
npx_fdivrp_f6,
npx_fdivrp_f7,
npx_fdivp_f0,		/* de f8 */
npx_fdivp_f1,
npx_fdivp_f2,
npx_fdivp_f3,
npx_fdivp_f4,
npx_fdivp_f5,
npx_fdivp_f6,
npx_fdivp_f7,
npx_fild_word,		/* df 00 */
npx_fild_word,		/* df 01 */
npx_fild_word,		/* df 02 */
npx_fild_word,		/* df 03 */
npx_fild_word,		/* df 04 */
npx_fild_word,		/* df 05 */
npx_fild_word,		/* df 06 */
npx_fild_word,		/* df 07 */
npx_funimp,		/* df 08 */
npx_funimp,		/* df 09 */
npx_funimp,		/* df 0a */
npx_funimp,		/* df 0b */
npx_funimp,		/* df 0c */
npx_funimp,		/* df 0d */
npx_funimp,		/* df 0e */
npx_funimp,		/* df 0f */
npx_fist_word,		/* df 10 */
npx_fist_word,		/* df 11 */
npx_fist_word,		/* df 12 */
npx_fist_word,		/* df 13 */
npx_fist_word,		/* df 14 */
npx_fist_word,		/* df 15 */
npx_fist_word,		/* df 16 */
npx_fist_word,		/* df 17 */
npx_fistp_word,		/* df 18 */
npx_fistp_word,		/* df 19 */
npx_fistp_word,		/* df 1a */
npx_fistp_word,		/* df 1b */
npx_fistp_word,		/* df 1c */
npx_fistp_word,		/* df 1d */
npx_fistp_word,		/* df 1e */
npx_fistp_word,		/* df 1f */
npx_fbld,		/* df 20 */
npx_fbld,		/* df 21 */
npx_fbld,		/* df 22 */
npx_fbld,		/* df 23 */
npx_fbld,		/* df 24 */
npx_fbld,		/* df 25 */
npx_fbld,		/* df 26 */
npx_fbld,		/* df 27 */
npx_fild_long,		/* df 28 */
npx_fild_long,		/* df 29 */
npx_fild_long,		/* df 2a */
npx_fild_long,		/* df 2b */
npx_fild_long,		/* df 2c */
npx_fild_long,		/* df 2d */
npx_fild_long,		/* df 2e */
npx_fild_long,		/* df 2f */
npx_fbstp,		/* df 30 */
npx_fbstp,		/* df 31 */
npx_fbstp,		/* df 32 */
npx_fbstp,		/* df 33 */
npx_fbstp,		/* df 34 */
npx_fbstp,		/* df 35 */
npx_fbstp,		/* df 36 */
npx_fbstp,		/* df 37 */
npx_fistp_long,		/* df 38 */
npx_fistp_long,		/* df 39 */
npx_fistp_long,		/* df 3a */
npx_fistp_long,		/* df 3b */
npx_fistp_long,		/* df 3c */
npx_fistp_long,		/* df 3d */
npx_fistp_long,		/* df 3e */
npx_fistp_long,		/* df 3f */
npx_fild_word,		/* df 40 */
npx_fild_word,		/* df 41 */
npx_fild_word,		/* df 42 */
npx_fild_word,		/* df 43 */
npx_fild_word,		/* df 44 */
npx_fild_word,		/* df 45 */
npx_fild_word,		/* df 46 */
npx_fild_word,		/* df 47 */
npx_funimp,		/* df 48 */
npx_funimp,		/* df 49 */
npx_funimp,		/* df 4a */
npx_funimp,		/* df 4b */
npx_funimp,		/* df 4c */
npx_funimp,		/* df 4d */
npx_funimp,		/* df 4e */
npx_funimp,		/* df 4f */
npx_fist_word,		/* df 50 */
npx_fist_word,		/* df 51 */
npx_fist_word,		/* df 52 */
npx_fist_word,		/* df 53 */
npx_fist_word,		/* df 54 */
npx_fist_word,		/* df 55 */
npx_fist_word,		/* df 56 */
npx_fist_word,		/* df 57 */
npx_fistp_word,		/* df 58 */
npx_fistp_word,		/* df 59 */
npx_fistp_word,		/* df 5a */
npx_fistp_word,		/* df 5b */
npx_fistp_word,		/* df 5c */
npx_fistp_word,		/* df 5d */
npx_fistp_word,		/* df 5e */
npx_fistp_word,		/* df 5f */
npx_fbld,		/* df 60 */
npx_fbld,		/* df 61 */
npx_fbld,		/* df 62 */
npx_fbld,		/* df 63 */
npx_fbld,		/* df 64 */
npx_fbld,		/* df 65 */
npx_fbld,		/* df 66 */
npx_fbld,		/* df 67 */
npx_fild_long,		/* df 68 */
npx_fild_long,		/* df 69 */
npx_fild_long,		/* df 6a */
npx_fild_long,		/* df 6b */
npx_fild_long,		/* df 6c */
npx_fild_long,		/* df 6d */
npx_fild_long,		/* df 6e */
npx_fild_long,		/* df 6f */
npx_fbstp,		/* df 70 */
npx_fbstp,		/* df 71 */
npx_fbstp,		/* df 72 */
npx_fbstp,		/* df 73 */
npx_fbstp,		/* df 34 */
npx_fbstp,		/* df 75 */
npx_fbstp,		/* df 76 */
npx_fbstp,		/* df 77 */
npx_fistp_long,		/* df 78 */
npx_fistp_long,		/* df 79 */
npx_fistp_long,		/* df 7a */
npx_fistp_long,		/* df 7b */
npx_fistp_long,		/* df 7c */
npx_fistp_long,		/* df 7d */
npx_fistp_long,		/* df 7e */
npx_fistp_long,		/* df 7f */
npx_fild_word,		/* df 80 */
npx_fild_word,		/* df 81 */
npx_fild_word,		/* df 82 */
npx_fild_word,		/* df 83 */
npx_fild_word,		/* df 84 */
npx_fild_word,		/* df 85 */
npx_fild_word,		/* df 86 */
npx_fild_word,		/* df 87 */
npx_funimp,		/* df 88 */
npx_funimp,		/* df 89 */
npx_funimp,		/* df 8a */
npx_funimp,		/* df 8b */
npx_funimp,		/* df 8c */
npx_funimp,		/* df 8d */
npx_funimp,		/* df 8e */
npx_funimp,		/* df 8f */
npx_fist_word,		/* df 90 */
npx_fist_word,		/* df 91 */
npx_fist_word,		/* df 92 */
npx_fist_word,		/* df 93 */
npx_fist_word,		/* df 94 */
npx_fist_word,		/* df 95 */
npx_fist_word,		/* df 96 */
npx_fist_word,		/* df 97 */
npx_fistp_word,		/* df 98 */
npx_fistp_word,		/* df 99 */
npx_fistp_word,		/* df 9a */
npx_fistp_word,		/* df 9b */
npx_fistp_word,		/* df 9c */
npx_fistp_word,		/* df 9d */
npx_fistp_word,		/* df 9e */
npx_fistp_word,		/* df 9f */
npx_fbld,		/* df a0 */
npx_fbld,		/* df a1 */
npx_fbld,		/* df a2 */
npx_fbld,		/* df a3 */
npx_fbld,		/* df a4 */
npx_fbld,		/* df a5 */
npx_fbld,		/* df a6 */
npx_fbld,		/* df a7 */
npx_fild_long,		/* df a8 */
npx_fild_long,		/* df a9 */
npx_fild_long,		/* df aa */
npx_fild_long,		/* df ab */
npx_fild_long,		/* df ac */
npx_fild_long,		/* df ad */
npx_fild_long,		/* df ae */
npx_fild_long,		/* df af */
npx_fbstp,		/* df b0 */
npx_fbstp,		/* df b1 */
npx_fbstp,		/* df b2 */
npx_fbstp,		/* df b3 */
npx_fbstp,		/* df b4 */
npx_fbstp,		/* df b5 */
npx_fbstp,		/* df b6 */
npx_fbstp,		/* df b7 */
npx_fistp_long,		/* df b8 */
npx_fistp_long,		/* df b9 */
npx_fistp_long,		/* df ba */
npx_fistp_long,		/* df bb */
npx_fistp_long,		/* df bc */
npx_fistp_long,		/* df bd */
npx_fistp_long,		/* df be */
npx_fistp_long,		/* df bf */
npx_ffreep_f0,		/* df c0 */
npx_ffreep_f1,
npx_ffreep_f2,
npx_ffreep_f3,
npx_ffreep_f4,
npx_ffreep_f5,
npx_ffreep_f6,
npx_ffreep_f7,
npx_fxch_f0,		/* df c8 */
npx_fxch_f1,
npx_fxch_f2,
npx_fxch_f3,
npx_fxch_f4,
npx_fxch_f5,
npx_fxch_f6,
npx_fxch_f7,
npx_fstp_f0,		/* df d0 */
npx_fstp_f1,
npx_fstp_f2,
npx_fstp_f3,
npx_fstp_f4,
npx_fstp_f5,
npx_fstp_f6,
npx_fstp_f7,
npx_fstp_f0,		/* df d8 */
npx_fstp_f1,
npx_fstp_f2,
npx_fstp_f3,
npx_fstp_f4,
npx_fstp_f5,
npx_fstp_f6,
npx_fstp_f7,
npx_fstswax,		/* df e0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,		/* df f0 */
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp,
npx_funimp
};

VOID ZFRSRVD(npx_instr)
IU32 npx_instr;
{
	if (!NPX_PROT_MODE) {
		NpxInstr = npx_instr;
	}
	if (DoNpxPrologue())
		(*inst_table[npx_instr])();
}

LOCAL BOOL DoNpxPrologue() {
	if (GET_EM() || GET_TS()) {
		INTx(0x7);
		return(FALSE);
	} else {
		return(TRUE);
	}
}

GLOBAL IBOOL NpxIntrNeeded = FALSE;
LOCAL IU32 NpxExceptionEIP = 0;

VOID DoNpxException() {

	NpxException = FALSE;
	NpxExceptionEIP = NpxFIP;
	NpxIntrNeeded = TRUE;	/* interrupt delayed until next NPX inst */
}

/* called on NPX instr that follows faulting instr */
void TakeNpxExceptionInt()
{
	IU32 hook_address;	
	IU16 cpu_hw_interrupt_number;

	NpxIntrNeeded = FALSE;
	NpxFIP = NpxExceptionEIP;

#ifdef	SPC486
	if (GET_NE() == 0)
	{
#ifndef SFELLOW
		ica_hw_interrupt (ICA_SLAVE, CPU_AT_NPX_INT, 1);
#else	/* SFELLOW */
		c_cpu_interrupt(CPU_NPX_INT, 0);
#endif	/* SFELLOW */
	}
	else
	{
		Int16();
	}
#else	/* SPC486 */
	ica_hw_interrupt (ICA_SLAVE, CPU_AT_NPX_INT, 1);
#endif	/* SPC486 */

#ifndef SFELLOW
	/* and immediately dispatch to interrupt */
	if (GET_IF())
	{
		cpu_hw_interrupt_number = ica_intack(&hook_address);
		EXT = EXTERNAL;
		do_intrupt(cpu_hw_interrupt_number, FALSE, FALSE, (IU16)0);
		CCPU_save_EIP = GET_EIP();   /* to reflect IP change */
	}
#endif	/*SFELLOW*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\comms\prt_scrn.c ===
/*
 * @(#)prt_screen.c	1.8 06/28/95
 *
 * This file has been deleted, its functionality has been replaced by
 * a pure Intel   implementation in bios4.rom
 */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\comms\com.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 3.0
 *
 * Title	: com.c
 *
 * Description	: Asynchronous Adaptor I/O functions.
 *
 * Notes	: Refer to the PC-XT Tech Ref Manual Section 1-185
 *		  For a detailed description of the Asynchronous Adaptor Card.
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)com.c	1.45 04/26/94 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_COMMS.seg"
#endif

/*
 *    O/S include files.
 */
#include <stdio.h>
#include <ctype.h>
#if defined(NTVDM) && defined(MONITOR)
#include <malloc.h>
#endif
#include TypesH
#include StringH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "ios.h"
#include "rs232.h"
#include "trace.h"
#include "error.h"
#include "config.h"
#include "host_com.h"
#include "ica.h"
#include "debug.h"
#include "timer.h"
#include "quick_ev.h"
#include "idetect.h"
#include "ckmalloc.h"
#ifdef GISP_CPU
#include "hg_cpu.h"	/* GISP CPU interface */
#endif /* GISP_CPU */

#ifndef NEC_98
LOCAL UTINY selectBits[4] = { 0x1f, 0x3f, 0x7f, 0xff } ;
#endif // NEC_98

#if defined(NEC_98)
// PC-9861K IR  Read Signal IR State
#define CH2_INT(IR) (IR == 3 ? 0 : IR == 5 ? 1 : IR == 6 ? 2 : 3)
#define CH3_INT(IR) (IR == 3 ? 0 : IR == 10 ? 1 : IR == 12 ? 2 : 3)
#endif

/*
 * =====================================================================
 * The rs232 adaptor state
 * =====================================================================
 */

/*
 * batch_size, current_count
 *	The IRET_HOOKS parameters batch_size and curr_count are used to prevent
 *	the number of interrupts that are emulated in one batch getting too
 *	large. When we reach the batch size we'll unhook the interrupt, and
 *	wait a while.
 * batch_running, qev_running
 *	These variables are used to prevent multiple quick events or batches
 *	running at once on a single adapter.
 */
#if defined(NEC_98)
static struct ADAPTER_STATE
{
        BUFFER_REG      tx_buffer;
        BUFFER_REG      rx_buffer;
        DIVISOR_LATCH   divisor_latch;
        COMMAND8251     command_write_reg;
        MODE8251        mode_set_reg;
        MASK8251        int_mask_reg;
        STATUS8251      read_status_reg;
        SIGNAL8251      read_signal_reg;
        TIMER_MODE      timer_mode_set_reg;

        int break_state;        /* either OFF or ON */
        int dtr_state;          /* either OFF or ON */
        int rts_state;          /* either OFF or ON */

        int RXR_enable_state;   /* either OFF or ON */
        int TXR_enable_state;   /* either OFF or ON */

        int mode_set_state;     /* either OFF or ON */
            // ON = next command port access is mode set. OFF = command write.
        int timer_mode_state;   /* either OFF or ON */
            // Timer conunter latch mode ON = MSB read. OFF = LSB read.
        int timer_LSB_set_state;/* either OFF or ON */
            // Timer conunter LSB set ON = LSB set. OFF = no.
        int timer_MSB_set_state;/* either OFF or ON */
            // Timer conunter MSB set ON = MSB set. OFF = no.

        int rx_ready_interrupt_state;
        int tx_ready_interrupt_state;
        int tx_empty_interrupt_state;

        int hw_interrupt_priority;
        int com_baud_ind;
        int had_first_read;
} adapter_state[3];
#else // NEC_98

static struct ADAPTER_STATE
{
	BUFFER_REG tx_buffer;
	BUFFER_REG rx_buffer;
	DIVISOR_LATCH divisor_latch;
	INT_ENABLE_REG int_enable_reg;
	INT_ID_REG int_id_reg;
	LINE_CONTROL_REG line_control_reg;
	MODEM_CONTROL_REG modem_control_reg;
	LINE_STATUS_REG line_status_reg;
	MODEM_STATUS_REG modem_status_reg;
#if defined(NTVDM) && defined(FIFO_ON)
    FIFO_CONTROL_REG  fifo_control_reg;
    FIFORXDATA  rx_fifo[FIFO_BUFFER_SIZE];
    half_word   rx_fifo_write_counter;
    half_word   rx_fifo_read_counter;
    half_word   fifo_trigger_counter;
    int fifo_timeout_interrupt_state;
#endif
	half_word scratch;      /* scratch register */

	int break_state;        /* either OFF or ON */
	int loopback_state;     /* either OFF or ON */
	int dtr_state;          /* either OFF or ON */
	int rts_state;          /* either OFF or ON */
	int out1_state;         /* either OFF or ON */
	int out2_state;         /* either OFF or ON */

	int receiver_line_status_interrupt_state;
	int data_available_interrupt_state;
	int tx_holding_register_empty_interrupt_state;
	int modem_status_interrupt_state;
	int hw_interrupt_priority;
	int com_baud_ind;
	int had_first_read;
#ifdef IRET_HOOKS
	IUM32 batch_size;
	IUM32 current_count;
	IBOOL batch_running;
	IBOOL qev_running;
#endif /* IRET_HOOKS */
#ifdef NTVDM
    MODEM_STATUS_REG last_modem_status_value;
    int modem_status_changed;
#endif
} adapter_state[NUM_SERIAL_PORTS];


#ifdef NTVDM
#define MODEM_STATE_CHANGE()	asp->modem_status_changed = TRUE;
#else
#define MODEM_STATE_CHANGE()
#endif
#endif // NEC_98


#ifdef IRET_HOOKS
/*
 * Also have an overall quick events running flag that is set, if either
 * adapter has an event running.
 */

IBOOL qev_running = FALSE;
#endif /* IRET_HOOKS */

/*
 * For synchronisation of adapter input.
 * Note this code is essential for the VMS equivalent of the async
 * event manager.  Removing it causes characters to be lost on reception.
 */
static int com_critical[NUM_SERIAL_PORTS];
#define is_com_critical(adapter)	(com_critical[adapter] != 0)
#define com_critical_start(adapter)	(++com_critical[adapter])
#define com_critical_end(adapter)	(--com_critical[adapter])
#define com_critical_reset(adapter)	(com_critical[adapter] = 0)


/*
 * Used to determine whether a flush input is needed for a LCR change
 */
#ifndef NEC_98
static LINE_CONTROL_REG LCRFlushMask;
#endif // NEC_98

/*
 *	Please note that the following arrays have been made global in order
 *	that they can be accessed from some SUN_VA code. Please do not make
 *	them static.
 */

#if defined(NTVDM) && defined(FIFO_ON)
static half_word    level_to_counter[4] = { 1, 4, 8, 14};
#endif

/*
 * The delay needed in microseconds between receiving 2 characters
 * note this time is about 10% less than the time for actual reception.
 *
 * These delays have been heavily fudged and are now based on the idea that
 * most of the comms interrupt handlers can handle 9600 baud.  So as a
 * result the delays between 2 characters are now always set for 9600 baud.
 * Also note the delays of the faster baud rates have been decreased to
 * 1/2 of original delays, again this is to try to empty the host buffers
 * quickly enough to avoid buffer overflows.
 * NB these figures are heuristic.
 *
 * Finally it may be possible that the transmit delays will have to
 * be similarly fudged.
 */
unsigned long RX_delay[] =
{
	34, /* 115200 baud */
	67, /* 57600 baud */
	103, /* 38400 baud */
	900, /* 19200 baud */
	900, /* 9600 baud */
	900, /* 7200 baud */
	900, /* 4800 baud */
	900, /* 3600 baud */
	900, /* 2400 baud */
	900, /* 2000 baud */
	900, /* 1800 baud */
	900, /* 1200 baud */
	900, /* 600 baud */
	900, /* 300 baud */
	900, /* 150 baud */
	900, /* 134 baud */
	900, /* 110 baud */
	900, /* 75 baud */
	900  /* 50 baud */
};

/*
 * the delay needed in microseconds between transmitting 2 characters
 * note this time is about 10% more than the time for actual transmission.
 */
unsigned long TX_delay[] =
{
	83, /* 115200 baud */
	165, /* 57600 baud */
	253, /* 38400 baud */
	495, /* 19200 baud */
	1100, /* 9600 baud */
	1375, /* 7200 baud */
	2063, /* 4800 baud */
	2750, /* 3600 baud */
	4125, /* 2400 baud */
	5042, /* 2000 baud */
	5500, /* 1800 baud */
	8250, /* 1200 baud */
	16500, /* 600 baud */
	33000, /* 300 baud */
	66000, /* 150 baud */
	73920, /* 134 baud */
	89980, /* 110 baud */
	132000, /* 75 baud */
	198000  /* 50 baud */
};

#ifndef PROD
FILE     *com_trace_fd = NULL;
int       com_dbg_pollcount = 0;
#endif /* !PROD */
/*
 * =====================================================================
 * Other variables
 * =====================================================================
 */

#if !defined(PROD) || defined(SHORT_TRACE)
static char buf[80];    /* Buffer for diagnostic prints */
#endif /* !PROD || SHORT_TRACE */

#ifdef PS_FLUSHING
LOCAL IBOOL psFlushEnabled[NUM_SERIAL_PORTS];	/* TRUE if PostScript flushing
						is enabled */
#endif	/* PS_FLUSHING */

/* Control TX pacing */
IBOOL tx_pacing_enabled = FALSE;

/*
 * =====================================================================
 * Static forward declarations
 * =====================================================================
 */
#if defined(NEC_98)
static void raise_rxr_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void raise_txr_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void raise_txe_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void raise_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void clear_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void com_flush_input IPT1(int, adapter);
static void com_send_not_finished IPT1(int, adapter);
static void do_wait_on_send IPT1(long, adapter);
void   com_inb IPT2(io_addr, port, half_word *, value);
void   com_outb IPT2(io_addr, port, half_word, value);
void   com_recv_char IPT1(int, adapter);
GLOBAL void recv_char IPT1(long, adapter);
void   com_modem_change IPT1(int, adapter);
static void modem_change IPT1(int, adapter);
static void set_recv_char_status IPT1(struct ADAPTER_STATE *, asp);
static void set_xmit_char_status IPT1(struct ADAPTER_STATE *, asp);
static void set_break IPT1(int, adapter);
void SetRSBaud( word BaudRate );
static void set_baud_rate IPT1(int, adapter);
static void set_mask_8251 IPT2(int, adapter, int, value);
//static void read_mask_8251 IPT2(int, adapter, int, value);
static void read_signal_8251 IPT1(int, adapter);
static void set_mode_8251 IPT2(int, adapter, int, value);
static void set_dtr IPT1(int, adapter);
static void set_rts IPT1(int, adapter);
static void super_trace IPT1(char *, string);
void   com1_flush_printer IPT0();
void   com2_flush_printer IPT0();
static void com_reset IPT1(int, adapter);
GLOBAL VOID com_init IPT1(int, adapter);
void   com_post IPT1(int, adapter);
void   com_close IPT1(int, adapter);
//int    Bus_Clock = 0;             // ADD 93.9.14
#else  // NEC_98
static void raise_rls_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void raise_rda_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void raise_ms_interrupt IPT1(struct ADAPTER_STATE *,asp);
static void raise_thre_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void generate_iir IPT1(struct ADAPTER_STATE *, asp);
static void raise_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void clear_interrupt IPT1(struct ADAPTER_STATE *, asp);
static void com_flush_input IPT1(int, adapter);
static void com_send_not_finished IPT1(int, adapter);
#ifndef NTVDM
static void do_wait_on_send IPT1(long, adapter);
#endif
void   com_inb IPT2(io_addr, port, half_word *, value);
void   com_outb IPT2(io_addr, port, half_word, value);
void   com_recv_char IPT1(int, adapter);
GLOBAL void recv_char IPT1(long, adapter);
void   com_modem_change IPT1(int, adapter);
static void modem_change IPT1(int, adapter);
static void set_recv_char_status IPT1(struct ADAPTER_STATE *, asp);
static void set_xmit_char_status IPT1(struct ADAPTER_STATE *, asp);
static void set_break IPT1(int, adapter);
static void set_baud_rate IPT1(int, adapter);
static void set_line_control IPT2(int, adapter, int, value);
static void set_dtr IPT1(int, adapter);
static void set_rts IPT1(int, adapter);
static void set_out1 IPT1(int, adapter);
static void set_out2 IPT1(int, adapter);
static void set_loopback IPT1(int, adapter);
static void super_trace IPT1(char *, string);
void   com1_flush_printer IPT0();
void   com2_flush_printer IPT0();
static void com_reset IPT1(int, adapter);
GLOBAL VOID com_init IPT1(int, adapter);
void   com_post IPT1(int, adapter);
void   com_close IPT1(int, adapter);
LOCAL void next_batch IPT1(long, l_adapter);
#ifdef NTVDM
static void lsr_change(struct ADAPTER_STATE *asp, unsigned int error);
#ifdef FIFO_ON
static void recv_char_from_fifo(struct ADAPTER_STATE *asp);
#endif
#endif
#endif // NEC_98

/*
 * =====================================================================
 * Subsidiary functions - for interrupt emulation
 * =====================================================================
 */

#if defined(NEC_98)
static void raise_txr_interrupt IFN1(struct ADAPTER_STATE *, asp)
{

//      PRINTDBGNEC98( NEC98DBG_int_trace,
//                    ("COMMS : raise_txr_interrupt : INT MASK = %x \n",asp->int_mask_reg.all) );
        /*
         * Check if txr interrupt is enabled
         */
        if ( asp->int_mask_reg.bits.TXR_enable == 0 )
                return;

        /*
        * Raise interrupt
         */
        raise_interrupt(asp);
        asp->tx_ready_interrupt_state = ON;

}

static void raise_txe_interrupt IFN1(struct ADAPTER_STATE *, asp)
{

//      PRINTDBGNEC98( NEC98DBG_int_trace,
//                    ("COMMS : raise_txe_interrupt : INT MASK = %x \n",asp->int_mask_reg.all) );
        /*
         * Check if txe interrupt is enabled
         */
        if ( asp->int_mask_reg.bits.TXE_enable == 0 )
                return;

        /*
     * Raise interrupt
       */
        raise_interrupt(asp);
        asp->tx_empty_interrupt_state = ON;

}

static void raise_rxr_interrupt IFN1(struct ADAPTER_STATE *, asp)
{

//      PRINTDBGNEC98( NEC98DBG_int_trace,
//                    ("COMMS : raise_rxr_interrupt : INT MASK = %x \n",asp->int_mask_reg.all) );
        /*
         * Check if data available interrupt is enabled
         */
        if ( asp->int_mask_reg.bits.RXR_enable == 0 )
                return;

        /*
         * Raise interrupt
         */
        raise_interrupt(asp);
        asp->rx_ready_interrupt_state = ON;
}
#else // NEC_98

static void raise_rls_interrupt IFN1(struct ADAPTER_STATE *, asp)
{
	/*
	 * Follow somewhat dubious advice on Page 1-188 of XT Tech Ref
	 * regarding the adapter card sending interrupts to the system.
	 * Apparently confirmed by the logic diagram.
	 */
	if ( asp->modem_control_reg.bits.OUT2 == 0 )
		return;
	
	/*
	 * Check if receiver line status interrupt is enabled
	 */
	if ( asp->int_enable_reg.bits.rx_line == 0 )
		return;
	
	/*
	 * Raise interrupt
	 */
	raise_interrupt(asp);
	asp->receiver_line_status_interrupt_state = ON;
}

static void raise_rda_interrupt IFN1(struct ADAPTER_STATE *, asp)
{
	if (( asp->modem_control_reg.bits.OUT2 == 0 ) &&
		( asp->loopback_state == OFF ))
		return;
	
	/*
	 * Check if data available interrupt is enabled
	 */
	if ( asp->int_enable_reg.bits.data_available == 0 )
		return;
	
	/*
	 * Raise interrupt
	 */
	raise_interrupt(asp);
	asp->data_available_interrupt_state = ON;
}

static void raise_ms_interrupt IFN1(struct ADAPTER_STATE *, asp)
{
	if ( asp->modem_control_reg.bits.OUT2 == 0 )
		return;
	
	/*
	 * Check if modem status interrupt is enabled
	 */
	if ( asp->int_enable_reg.bits.modem_status == 0 )
		return;
	
	/*
	 * Raise interrupt
	 */
	raise_interrupt(asp);
	asp->modem_status_interrupt_state = ON;
}

static void raise_thre_interrupt IFN1(struct ADAPTER_STATE *, asp)
{
	if ( asp->modem_control_reg.bits.OUT2 == 0 )
		return;
	
	/*
	 * Check if tx holding register empty interrupt is enabled
	 */
	if ( asp->int_enable_reg.bits.tx_holding == 0 )
		return;
	
	/*
	 * Raise interrupt
	 */
	raise_interrupt(asp);
	asp->tx_holding_register_empty_interrupt_state = ON;
}

static void generate_iir IFN1(struct ADAPTER_STATE *, asp)
{
	/*
	 * Set up interrupt identification register with highest priority
	 * pending interrupt.
	 */
	
	if ( asp->receiver_line_status_interrupt_state == ON )
	{
		asp->int_id_reg.bits.interrupt_ID = RLS_INT;
		asp->int_id_reg.bits.no_int_pending = 0;
	}
	else if ( asp->data_available_interrupt_state == ON )
	{
		asp->int_id_reg.bits.interrupt_ID = RDA_INT;
		asp->int_id_reg.bits.no_int_pending = 0;
	}
#if defined(NTVDM) && defined(FIFO_ON)
    else if (asp->fifo_timeout_interrupt_state == ON)
    {
        asp->int_id_reg.bits.interrupt_ID = FIFO_INT;
        asp->int_id_reg.bits.no_int_pending = 0;
    }
#endif
	else if ( asp->tx_holding_register_empty_interrupt_state == ON )
	{
		asp->int_id_reg.bits.interrupt_ID = THRE_INT;
		asp->int_id_reg.bits.no_int_pending = 0;
	}
	else if ( asp->modem_status_interrupt_state == ON )
	{
		asp->int_id_reg.bits.interrupt_ID = MS_INT;
		asp->int_id_reg.bits.no_int_pending = 0;
	}
	else
	{
		/* clear interrupt */
		asp->int_id_reg.bits.no_int_pending = 1;
		asp->int_id_reg.bits.interrupt_ID = 0;
	}
}
#endif // NEC_98

#if defined(NEC_98)
static void raise_interrupt IFN1(struct ADAPTER_STATE *, asp)
{
        /*
         * Make sure that some thing else has not raised an interrupt
         * already.
         */
        if ( ( asp->rx_ready_interrupt_state == OFF )
        &&   ( asp->tx_ready_interrupt_state == OFF )
        &&   ( asp->tx_empty_interrupt_state == OFF ) )
        {
//          PRINTDBGNEC98( NEC98DBG_int_trace,
//                        ("COMMS : raise_interrupt IRQ = %d \n", asp->hw_interrupt_priority) );
//                ica_hw_interrupt(0, asp->hw_interrupt_priority, 1);
                ica_hw_interrupt((asp->hw_interrupt_priority < 8 ? 0 : 1), (asp->hw_interrupt_priority & 7), 1);
        }
}

static void clear_interrupt IFN1(struct ADAPTER_STATE *, asp)
{
        /*
         * Make sure that some thing else has not raised an interrupt
         * already.  If so then we cant drop the line.
         */
        if ( ( asp->rx_ready_interrupt_state == OFF )
        &&   ( asp->tx_ready_interrupt_state == OFF )
        &&   ( asp->tx_empty_interrupt_state == OFF ))
        {
//          PRINTDBGNEC98( NEC98DBG_int_trace,
//                        ("COMMS : clear_interrupt IRQ = %d \n",asp->hw_interrupt_priority));
//                ica_clear_int(0, asp->hw_interrupt_priority);
                ica_clear_int((asp->hw_interrupt_priority < 8 ? 0 : 1), (asp->hw_interrupt_priority & 7));
        }
}
#else // NEC_98
static void raise_interrupt IFN1(struct ADAPTER_STATE *, asp)
{
	/*
	 * Make sure that some thing else has not raised an interrupt
	 * already.
	 */
	if ( ( asp->receiver_line_status_interrupt_state      == OFF )
	&&   ( asp->data_available_interrupt_state            == OFF )
	&&   ( asp->tx_holding_register_empty_interrupt_state == OFF )
	&&   ( asp->modem_status_interrupt_state              == OFF )
#if defined(NTVDM) && defined(FIFO_ON)
    &&   (asp->fifo_timeout_interrupt_state               == OFF )
#endif
       )
	{
#ifndef DELAYED_INTS
		ica_hw_interrupt(0, asp->hw_interrupt_priority, 1);
#else
		ica_hw_interrupt_delay(0, asp->hw_interrupt_priority, 1,
			HOST_COM_INT_DELAY);
#endif
	}
}

static void clear_interrupt IFN1(struct ADAPTER_STATE *, asp)
{
	/*
	 * Make sure that some thing else has not raised an interrupt
	 * already.  If so then we cant drop the line.
	 */
	if ( ( asp->receiver_line_status_interrupt_state      == OFF )
	&&   ( asp->data_available_interrupt_state            == OFF )
	&&   ( asp->tx_holding_register_empty_interrupt_state == OFF )
	&&   ( asp->modem_status_interrupt_state              == OFF )
#if defined(NTVDM) && defined(FIFO_ON)
    &&   ( asp->fifo_timeout_interrupt_state              == OFF )
#endif
       )
	{
		ica_clear_int(0, asp->hw_interrupt_priority);
	}
}
#endif // NEC_98

#if defined(NTVDM) && defined(FIFO_ON)

static void raise_fifo_timeout_interrupt(struct ADAPTER_STATE *asp)
{
    if (( asp->modem_control_reg.bits.OUT2 == 0 ) &&
        ( asp->loopback_state == OFF ))
        return;

    /*
     * Check if data available interrupt is enabled
     */
    if ( asp->int_enable_reg.bits.data_available == 0 )
        return;

    /*
     * Raise interrupt
     */
    raise_interrupt(asp);
    asp->fifo_timeout_interrupt_state = ON;
}
#endif



/*
 * =====================================================================
 * The Adaptor functions
 * =====================================================================
 */

static void com_flush_input IFN1(int, adapter)
{
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	int finished, error_mask;
	long input_ready = 0;

	sure_note_trace1(RS232_VERBOSE, "flushing the input for COM%c",
		adapter+'1');
	finished=FALSE;
	while(!finished)
	{
		host_com_ioctl(adapter, HOST_COM_INPUT_READY,
			(long)&input_ready);
		if (input_ready)
		{
			host_com_read(adapter, (UTINY *)&asp->rx_buffer,
				&error_mask);
		}
		else
		{
			finished=TRUE;
		}
	}
	set_xmit_char_status(asp);
}

#if defined(NEC_98)
static void com_send_not_finished(int adapter)
{
        struct ADAPTER_STATE *asp = &adapter_state[adapter];

        asp->read_status_reg.bits.tx_ready=0;
        asp->read_status_reg.bits.tx_empty=0;
}
#else // NEC_98
static void com_send_not_finished IFN1(int, adapter)
{
	struct ADAPTER_STATE *asp = &adapter_state[adapter];

	asp->line_status_reg.bits.tx_holding_empty=0;
	asp->line_status_reg.bits.tx_shift_empty=0;
}
#endif // NEC_98


#if defined(NEC_98)
static void do_wait_on_send IFN1(long, adapter)
{
	extern	void	host_com_send_delay_done IPT2(long, p1, int, p2);
	struct ADAPTER_STATE *asp;

	asp= &adapter_state[adapter];
	set_xmit_char_status(asp);
	host_com_send_delay_done(adapter, TX_delay[asp->com_baud_ind]);
}
#else // NEC_98
#ifndef NTVDM
static void do_wait_on_send IFN1(long, adapter)
{
	extern	void	host_com_send_delay_done IPT2(long, p1, int, p2);
	struct ADAPTER_STATE *asp;

	asp= &adapter_state[adapter];
	set_xmit_char_status(asp);
	host_com_send_delay_done(adapter, TX_delay[asp->com_baud_ind]);
}
#endif
#endif // NEC_98


#if defined(NEC_98)
void com_inb IFN2(io_addr, port, half_word *, value)
{
        int adapter = adapter_for_port(port);
        struct ADAPTER_STATE *asp = &adapter_state[adapter];
        long modem_status = 0;
        long input_ready = 0;
        boolean adapter_was_critical;

        host_com_lock(adapter);
        switch(port)
        {
        case RS232_CH1_TX_RX:   // CH.1 DATA READ
        case RS232_CH2_TX_RX:   // CH.2 DATA READ
        case RS232_CH3_TX_RX:   // CH.3 DATA READ
                IDLE_comlpt();
                /*
                 * Read of rx buffer
                 */
            //Flushing on first read removes characters from
            //the communications system that are needed !!!!
            //This assumes that the first read from the comms
            //system will return one character only. This is
            //a false assumption under NT windows.
                *value = asp->rx_buffer;

//              PRINTDBGNEC98( NEC98DBG_in_trace1,
//                            ("COMMS : Data PORT IN = %x, In data = %x \n",port,asp->rx_buffer) );

                adapter_was_critical =
                        (asp->read_status_reg.bits.rx_ready == 1);

                asp->read_status_reg.bits.rx_ready = 0;
                asp->rx_ready_interrupt_state = OFF;
                clear_interrupt(asp);

                    /*
                     * Adapter out of critical region,
                     * check for further input
                     */
                if (adapter_was_critical)
                {
                    host_com_char_read(adapter,                 // ADD 93.3.3
                     asp->command_write_reg.bits.rx_enable);    // ADD 93.3.3
                }
#ifndef PROD
                //DAB printf("%c",isprint(toascii(*value))?toascii(*value):'?');
                if (com_trace_fd)
                {
                        if (com_dbg_pollcount)
                        {
                                fprintf(com_trace_fd,"\n");
                                com_dbg_pollcount = 0;
                        }
                        fprintf(com_trace_fd,"RX %x (%c)\n",*value,
                                isprint(toascii(*value))?toascii(*value):'?');
                }
#endif
                break;

        case RS232_CH1_STATUS:  // CH.1 READ STATUS
        case RS232_CH2_STATUS:  // CH.2 READ STATUS
        case RS232_CH3_STATUS:  // CH.3 READ STATUS

                /* get current modem input state */
                host_com_ioctl(adapter, HOST_COM_MODEM, (long)&modem_status);
                asp->read_status_reg.bits.DR =
                                (modem_status & HOST_COM_MODEM_DSR)  ? 1 : 0;

                /* BREAK status is not supported. */
                asp->read_status_reg.bits.break_detect = 0;

                *value = asp->read_status_reg.all;

//              PRINTDBGNEC98( NEC98DBG_in_trace2,
//                            ("COMMS : Status PORT IN = %x, Status = %x \n",port,asp->read_status_reg.all) );

//      DbgPrint("COMMS : Status PORT IN = %x, Status = %x \n",port,asp->read_status_reg.all);

                if ((!asp->read_status_reg.bits.tx_ready) ||
                        (!asp->read_status_reg.bits.tx_empty))
                {
                        IDLE_comlpt();
                }

// This fix is used to get polling applications to work under the MS mult-
// threaded comms model. This fix calls host_com_poll if RX interrupts are
// disabled and the receive buffer is empty. Host_com_poll() will prime
// the adapter with RX data if any is available

                break;

        case RS232_CH1_MASK:    // CH.1 READ MASK (CH.1 ONLY)
                *value = (asp->int_mask_reg.all & 0x7);
//              PRINTDBGNEC98( NEC98DBG_in_trace1,
//                            ("COMMS : Mask PORT IN = %x, Mask = %x \n",port,(asp->int_mask_reg.all & 0x7)) );
                break;

        case RS232_CH1_SIG:     // CH.1 READ SIGNAL
                read_signal_8251(adapter);
                *value = asp->read_signal_reg.all;
//              PRINTDBGNEC98( NEC98DBG_in_trace3,
//                            ("COMMS : Status PORT IN = %x, Signal = %x \n",port,asp->read_signal_reg.all) );
                break;
        case RS232_CH2_SIG:     // CH.2 READ SIGNAL
                read_signal_8251(adapter);
                asp->read_signal_reg.bits.IR = CH2_INT(asp->hw_interrupt_priority);
                *value = asp->read_signal_reg.all;
//              PRINTDBGNEC98( NEC98DBG_in_trace3,
//                            ("COMMS : Status PORT IN = %x, Signal = %x \n",port,asp->read_signal_reg.all) );
                break;
        case RS232_CH3_SIG:     // CH.3 READ SIGNAL
                read_signal_8251(adapter);
                asp->read_signal_reg.bits.IR = CH3_INT(asp->hw_interrupt_priority);
                *value = asp->read_signal_reg.all;
//              PRINTDBGNEC98( NEC98DBG_in_trace3,
//                            ("COMMS : Status PORT IN = %x, Signal = %x \n",port,asp->read_signal_reg.all) );
                break;


        }
#ifndef PROD
        if (io_verbose & RS232_VERBOSE)
        {
                if (((port & 0xf) == 0xd) && (*value == 0x60))
                        fprintf(trace_file,".");
                else
                {
                        sprintf(buf, "com_inb() - port %x, returning val %x", port,
                                *value);
                        trace(buf, DUMP_REG);
                }
        }
#endif
    host_com_unlock(adapter);
}


void com_outb IFN2(io_addr, port, half_word, value)
{
        int adapter = adapter_for_port(port);
        struct ADAPTER_STATE *asp = &adapter_state[adapter];
        int i;
        int org_da;
// PORT C 37h
        int value2;
        if (port == 0x37)
            adapter = COM1;
//  PORT C 37h
        host_com_lock(adapter);
//      PRINTDBGNEC98( NEC98DBG_out_trace,
//                    ("COMMS : PORT OUT = %x\n            DATA = %x\n",port,value) );

#ifndef PROD
        if (io_verbose & RS232_VERBOSE)
        {
                sprintf(buf, "com_outb() - port %x, set to value %x",
                        port, value);
                trace(buf, DUMP_REG);
        }
#endif

        switch(port)
        {
        case RS232_CH1_TX_RX:   // CH.1 DATA WRITE
        case RS232_CH2_TX_RX:   // CH.2 DATA WRITE
        case RS232_CH3_TX_RX:   // CH.3 DATA WRITE
                IDLE_comlpt();
                /*
                 * Write char from tx buffer
                 */
                asp->tx_ready_interrupt_state = OFF;
                clear_interrupt(asp);
                asp->tx_buffer = value;
                asp->read_status_reg.bits.tx_ready = 0;
                asp->read_status_reg.bits.tx_empty = 0;
                if ( asp->command_write_reg.bits.send_break == 0 )
                host_com_write(adapter, asp->tx_buffer);
                    add_q_event_t(do_wait_on_send,
                    0 , adapter);
#ifdef SHORT_TRACE
                if ( io_verbose & RS232_VERBOSE )
                {
                        sprintf(buf,"%cTX  <- %x (%c)\n",
                                id_for_adapter(adapter), value,
                                isprint(toascii(value))?toascii(value):'?');
                        super_trace(buf);
                }
#endif
#ifndef PROD
                if (com_trace_fd)
                {
                        if (com_dbg_pollcount)
                        {
                                fprintf(com_trace_fd,"\n");
                                com_dbg_pollcount = 0;
                        }
                        fprintf(com_trace_fd,"TX %x (%c)\n",value,
                                isprint(toascii(value))?toascii(value):'?');
                }
#endif
                break;

        case RS232_CH1_CMD_MODE:    // CH.1 WRITE COMMAND/MODE
        case RS232_CH2_CMD_MODE:    // CH.2 WRITE COMMAND/MODE
        case RS232_CH3_CMD_MODE:    // CH.3 WRITE COMMAND/MODE
                if (asp->mode_set_state == OFF) { // command set
                    org_da = asp->command_write_reg.bits.rx_enable;
                    /*
                     * Optimisation - DOS keeps re-writing this register
                     */
                    asp->command_write_reg.all = value;

                    if ( asp->command_write_reg.bits.inter_reset == 1 ) { // Reset command
#ifdef NTVDM
                    {
                        extern int host_com_open(int adapter);

                        host_com_open(adapter);
                    }
#endif
//                      PRINTDBGNEC98( NEC98DBG_out_trace,
//                                    ("COMMS : RESET\n") );
                        asp->mode_set_state = ON;   // next OUT is mode
                        /*
                         *  STATUS is all clear
                         */
                        asp->read_status_reg.all = 0;
                        /*
                         *  STATUS tx_ready , tx_empty is ON
                         */
                        asp->read_status_reg.bits.tx_ready = 1;
                        asp->read_status_reg.bits.tx_empty = 1;
                        /*
                         *  TXR/RXR enable flag = OFF
                         */
                        asp->RXR_enable_state = OFF;
                        asp->TXR_enable_state = OFF;
                        /*
                         *  RS/ER clear
                         */
                        asp->command_write_reg.bits.RS = 0;
                        set_rts(adapter);
                        asp->command_write_reg.bits.ER = 0;
                        set_dtr(adapter);
                        /*
                         *  Break send OFF
                         */
                        asp->command_write_reg.bits.send_break = 0;
                        set_break(adapter);
                        /*
                         *  Timer mode clear. Next timer set is LSB.
                         */
                        asp->timer_mode_state = OFF;
                        /*
                         *  TX buffer clear
                         */
                        asp->tx_buffer = 0;
                        /*
                         * Reset adapter synchronisation
                         */
                        com_critical_reset(adapter);
                        /*
                         *
                         */

                    }
                    else { // other command
                        if ( asp->command_write_reg.bits.error_reset == 1 ) { // ERROR reset command
//                          PRINTDBGNEC98( NEC98DBG_out_trace,
//                                        ("COMMS : Line Error Reset\n") );
                            /*
                             * LINE ERROR flag clear
                             */
                            asp->read_status_reg.bits.overrun_error = 0;
                            asp->read_status_reg.bits.parity_error = 0;
                            asp->read_status_reg.bits.framing_error = 0;
                        }

                        /* Must be called before set_dtr */
                        set_dtr(adapter);
                        set_rts(adapter);
                        set_break(adapter);

                        asp->RXR_enable_state =
                        (asp->command_write_reg.bits.rx_enable == 1) ? ON :OFF;
                        asp->TXR_enable_state =
                        (asp->command_write_reg.bits.tx_enable == 1) ? ON :OFF;
                        if(org_da != asp->command_write_reg.bits.rx_enable)
                        {
                            host_com_da_int_change(adapter,
                                asp->command_write_reg.bits.rx_enable,
                                asp->read_status_reg.bits.rx_ready);
                        }
                    }
                }
                else { // mode set
//                  PRINTDBGNEC98( NEC98DBG_out_trace,
//                                ("COMMS : MODE SET\n") );
                    asp->mode_set_state = OFF;  // next OUT is command
                    set_mode_8251(adapter, value);
                }
                break;

        case RS232_CH1_MASK:        // CH.1 SET MASK
        case RS232_CH2_MASK:        // CH.2 SET MASK
        case RS232_CH3_MASK:        // CH.3 SET MASK

                set_mask_8251(adapter, value);
                break;

        case 0x37:                  // CH.1 SET MASK
                switch( value >> 1)
                {
                case 0:
                    value2 = asp->int_mask_reg.all & 0xfe;
                    value2 |= value;
                    set_mask_8251(adapter, value2);
                    break;

                case 1:
                    value2 = asp->int_mask_reg.all & 0xfd;
                    value2 |= ((value & 1) << 1);
                    set_mask_8251(adapter, value2);
                    break;

                case 2:
                    value2 = asp->int_mask_reg.all & 0xfb;
                    value2 |= ((value & 1) << 2);
                    set_mask_8251(adapter, value2);
                    break;
                }
                break;

        }

    host_com_unlock(adapter);
}
#else // NEC_98
void com_inb IFN2(io_addr, port, half_word *, value)
{
	int adapter = adapter_for_port(port);
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	long input_ready = 0;
	boolean adapter_was_critical;

#ifdef NTVDM
    if((port & 0x7) != RS232_MSR) host_com_lock(adapter);
#endif /* NTVDM */

	switch(port & 0x7)
	{
	case RS232_TX_RX:
		IDLE_comlpt();
		if (asp->line_control_reg.bits.DLAB == 0)
		{
			/*
			 * Read of rx buffer
			 */
#ifndef NTVDM
			if (!(asp->had_first_read))
			{
				com_flush_input(adapter);
				asp->had_first_read=TRUE;
			}
#else /* NTVDM is defined */
            //Flushing on first read removes characters from
            //the communications system that are needed !!!!
            //This assumes that the first read from the comms
            //system will return one character only. This is
            //a false assumption under NT windows.
#endif /* !NTVDM */
			*value = asp->rx_buffer;
		
			adapter_was_critical =
				(asp->line_status_reg.bits.data_ready == 1);
		
			asp->line_status_reg.bits.data_ready = 0;
			asp->data_available_interrupt_state = OFF;
			clear_interrupt(asp);

			if ( asp->loopback_state == OFF )
			{
				/*
				 * Adapter out of critical region,
				 * check for further input.  For IRET_HOOKS
				 * we don't need to do this, as receipt
				 * of the next character is kicked off
				 * by the IRET, however we do something
				 * else instead.  If this is the first
				 * character of a batch, we kick off a quick
				 * event for what will eventually be the
				 * start of the next batch (assuming there
				 * isn't already a quick event running).
				 * In any case we increment the count of
				 * characters in this batch.
				 */
				if (adapter_was_critical)
				{
#ifdef NTVDM
#ifdef FIFO_ON
                    if (asp->fifo_control_reg.bits.enabled) {
                    recv_char_from_fifo(asp);
                    *value = asp->rx_buffer;
                    host_com_fifo_char_read(adapter);
                    if (asp->rx_fifo_write_counter)
                        /* say this if we have more char in
                           the buffer to be deliveried
                        */
                        asp->line_status_reg.bits.data_ready = 1;
                    else
                        host_com_char_read(adapter,
                            asp->int_enable_reg.bits.data_available);
                    }
                    else
                    host_com_char_read(adapter,
                       asp->int_enable_reg.bits.data_available
                       );
#else /* !FIFO_ON */
                    host_com_char_read(adapter,
                    asp->int_enable_reg.bits.data_available
                    );
#endif /* !FIFO_ON */
#endif /* NTVDM */

#ifndef NTVDM
#ifdef IRET_HOOKS
					if (!asp->batch_running) {
						asp->batch_running = TRUE;
						asp->current_count = 1;
						asp->qev_running = TRUE;
						if (!qev_running) {
							qev_running = TRUE;
#ifdef GISP_CPU
							hg_add_comms_cb(next_batch, MIN_COMMS_RX_QEV);
#else
							add_q_event_t(next_batch, MIN_COMMS_RX_QEV, adapter);
#endif
						}
					} else { /* batch running */
						asp->current_count++;
					}
#else /* IRET_HOOKS */
					host_com_ioctl(adapter, HOST_COM_INPUT_READY,
						(long)&input_ready);
					if (input_ready)
#ifdef DELAYED_INTS
						recv_char((long)adapter);
#else
						add_q_event_t(recv_char,
							RX_delay[asp->com_baud_ind],
							adapter);
#endif /* DELAYED_INTS */
					else
						com_critical_reset(adapter);
#endif /* IRET_HOOKS */
#endif /* !NTVDM */
				}


			}
			else
			{
				set_xmit_char_status(asp);
			}
#ifdef IRET_HOOKS
			{
			LOCAL IBOOL	com_hook_again IPT1(IUM32, adapter);
			GLOBAL IBOOL is_hooked IPT1(IUM8, line_number);
				if(!is_hooked(asp->hw_interrupt_priority))
					com_hook_again(adapter);
			}
#endif /* IRET_HOOKS */
		}
		else
			*value = (IU8)(asp->divisor_latch.byte.LSByte);
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf, "%cRX  -> %x (%c)\n",
				id_for_adapter(adapter), *value,
				isprint(toascii(*value))?toascii(*value):'?');
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"RX %x (%c)\n",*value,
				isprint(toascii(*value))?toascii(*value):'?');
		}
#endif
		break;
																		
	case RS232_IER:
		if (asp->line_control_reg.bits.DLAB == 0)
			*value = asp->int_enable_reg.all;
		else
			*value = (IU8)(asp->divisor_latch.byte.MSByte);
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cIER -> %x\n", id_for_adapter(adapter),
				*value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"IER read %x \n",*value);
		}
#endif
		break;

	case RS232_IIR:
		generate_iir(asp);
		*value = asp->int_id_reg.all;

		if ( asp->int_id_reg.bits.interrupt_ID == THRE_INT )
		{
			asp->tx_holding_register_empty_interrupt_state = OFF;
			clear_interrupt(asp);
		}

#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cIIR -> %x\n", id_for_adapter(adapter),
				*value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"IIR read %x \n",*value);
		}
#endif
		break;
	
	case RS232_LCR:
#ifdef NTVDM
        /* Before returning the information on the current configuation
           of the serial link make sure the System comms port is open */

        {
            extern int host_com_open(int adapter);

            host_com_open(adapter);
        }
#endif


		*value = asp->line_control_reg.all;
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cLCR -> %x\n", id_for_adapter(adapter),
				*value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"LCR read %x \n",*value);
		}
#endif
		break;
	
	case RS232_MCR:
		*value = asp->modem_control_reg.all;
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cMCR -> %x\n", id_for_adapter(adapter),
				*value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"MCR read %x \n",*value);
		}
#endif
		break;
	
	case RS232_LSR:
		*value = asp->line_status_reg.all;
	
		asp->line_status_reg.bits.overrun_error = 0;
		asp->line_status_reg.bits.parity_error = 0;
		asp->line_status_reg.bits.framing_error = 0;
		asp->line_status_reg.bits.break_interrupt = 0;
		asp->receiver_line_status_interrupt_state = OFF;
		clear_interrupt(asp);
#if defined(NTVDM) && defined(FIFO_ON)
        asp->fifo_timeout_interrupt_state = OFF;
#endif
	
#ifdef SHORT_TRACE
		if ((!asp->line_status_reg.bits.tx_holding_empty) ||
			(!asp->line_status_reg.bits.tx_shift_empty))
		{
			IDLE_comlpt();
		}
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cLSR -> %x\n", id_for_adapter(adapter),
				*value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if ((*value & 0x9f) != 0x0)
			{
				if (com_dbg_pollcount)
				{
					fprintf(com_trace_fd,"\n");
					com_dbg_pollcount = 0;
				}
				fprintf(com_trace_fd,"LSR read %x \n",*value);
			}
			else
			{
				com_dbg_pollcount++;
				if (*value == 0)
					fprintf(com_trace_fd,"0");
				else
					fprintf(com_trace_fd,".");
				if (com_dbg_pollcount > 19)
				{
					fprintf(com_trace_fd,"\n");
					com_dbg_pollcount = 0;
				}
			}
		}
#endif
		break;
	
	case RS232_MSR:

#ifndef NTVDM
		if (asp->loopback_state == OFF)
		{
                com_modem_change(adapter);
		}
		else
		{
			asp->modem_status_reg.bits.CTS = asp->modem_control_reg.bits.RTS;
			asp->modem_status_reg.bits.DSR = asp->modem_control_reg.bits.DTR;
			asp->modem_status_reg.bits.RI = asp->modem_control_reg.bits.OUT1;
			asp->modem_status_reg.bits.RLSD = asp->modem_control_reg.bits.OUT2;
		}
		*value = asp->modem_status_reg.all;
		asp->modem_status_reg.bits.delta_CTS = 0;
		asp->modem_status_reg.bits.delta_DSR = 0;
		asp->modem_status_reg.bits.delta_RLSD = 0;
		asp->modem_status_reg.bits.TERI = 0;
		asp->modem_status_interrupt_state = OFF;

		host_com_msr_callback (adapter, asp->modem_status_reg.all);
		clear_interrupt(asp);
#else
		if(!asp->modem_status_changed && asp->loopback_state == OFF)
		{
		    *value = asp->last_modem_status_value.all;
		}
		else
		{
		    host_com_lock(adapter);
		    asp->modem_status_changed = TRUE;

		    /* if the adapter is not opened yet, just return POST
		       value.
		     */
		    if (host_com_check_adapter(adapter)) {
			if(asp->loopback_state == OFF)
			{
			    com_modem_change(adapter);
			    asp->modem_status_changed = FALSE;

			}
			else
			{
			    asp->modem_status_reg.bits.CTS = asp->modem_control_reg.bits.RTS;
			    asp->modem_status_reg.bits.DSR = asp->modem_control_reg.bits.DTR;
			    asp->modem_status_reg.bits.RI = asp->modem_control_reg.bits.OUT1;
			    asp->modem_status_reg.bits.RLSD = asp->modem_control_reg.bits.OUT2;
			}
		    }

		    *value = asp->modem_status_reg.all;

		    asp->modem_status_reg.bits.delta_CTS = 0;
		    asp->modem_status_reg.bits.delta_DSR = 0;
		    asp->modem_status_reg.bits.delta_RLSD = 0;
		    asp->modem_status_reg.bits.TERI = 0;
		    asp->modem_status_interrupt_state = OFF;
		    host_com_msr_callback (adapter, asp->modem_status_reg.all);
		    clear_interrupt(asp);
		    asp->last_modem_status_value.all = asp->modem_status_reg.all;
		    host_com_unlock(adapter);
		}
#endif /* ifndef NTVDM */


#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cMSR -> %x\n", id_for_adapter(adapter),
				*value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"MSR read %x \n",*value);
		}
#endif
		break;

/*
 * Scratch register.  Just output the value stored.
 */
	case RS232_SCRATCH:
		*value = asp->scratch;
		break;
	
	}

#ifndef PROD
	if (io_verbose & RS232_VERBOSE)
	{
		if (((port & 0xf) == 0xd) && (*value == 0x60))
			fprintf(trace_file,".");
		else
		{
			sprintf(buf, "com_inb() - port %x, returning val %x", port,
				*value);
			trace(buf, DUMP_REG);
		}
	}
#endif

#ifdef NTVDM
	if((port & 0x7) != RS232_MSR) host_com_unlock(adapter);
#endif NTVDM
}


void com_outb IFN2(io_addr, port, half_word, value)
{
	int adapter = adapter_for_port(port);
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	int	i;

#ifdef NTVDM
	host_com_lock(adapter);
#endif NTVDM


#ifndef PROD
	if (io_verbose & RS232_VERBOSE)
	{
		sprintf(buf, "com_outb() - port %x, set to value %x",
			port, value);
		trace(buf, DUMP_REG);
	}
#endif
	
	switch(port & 0x7)
	{
	case RS232_TX_RX:
		IDLE_comlpt();
		if (asp->line_control_reg.bits.DLAB == 0)
		{
			/*
			 * Write char from tx buffer
			 */
			asp->tx_holding_register_empty_interrupt_state = OFF;
			clear_interrupt(asp);
			asp->tx_buffer = value;
			asp->line_status_reg.bits.tx_holding_empty = 0;
			asp->line_status_reg.bits.tx_shift_empty = 0;
			if ( asp->loopback_state == OFF )
			{
#ifdef PS_FLUSHING
				/*
				 * If PostScript flushing is enabled for this
				 * port then we flush on a Ctrl-D
				 */
				if ( psFlushEnabled[adapter] &&
				     asp->tx_buffer == 0x04 /* ^D */ )
					host_com_ioctl(adapter,HOST_COM_FLUSH,
					              0);
				else {
#endif	/* PS_FLUSHING */
				host_com_write(adapter, asp->tx_buffer);
#if defined (DELAYED_INTS) || defined (NTVDM)
				set_xmit_char_status(asp);
#else
					if(tx_pacing_enabled)
						add_q_event_t(do_wait_on_send,
					            TX_delay[asp->com_baud_ind], adapter);
					else
						do_wait_on_send(adapter);

#endif /* DELAYED_INTS || NTVDM */
#ifdef PS_FLUSHING
				}
#endif	/* PS_FLUSHING */
			}
			else
			{	/* Loopback case requires masking off */
				/* of bits based upon word length.    */
				asp->rx_buffer = asp->tx_buffer & selectBits[asp->line_control_reg.bits.word_length] ;
				set_xmit_char_status(asp);
				set_recv_char_status(asp);
			}
		}
		else
		{
			asp->divisor_latch.byte.LSByte = value;
#ifndef NTVDM
			set_baud_rate(adapter);
#endif
		}
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cTX  <- %x (%c)\n",
				id_for_adapter(adapter), value,
				isprint(toascii(value))?toascii(value):'?');
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"TX %x (%c)\n",value,
				isprint(toascii(value))?toascii(value):'?');
		}
#endif
		break;
																		
	case RS232_IER:
		if (asp->line_control_reg.bits.DLAB == 0)
		{
#ifdef NTVDM
            int org_da = asp->int_enable_reg.bits.data_available;
#endif
			asp->int_enable_reg.all = value & 0xf;
			/*
			 * Kill off any pending interrupts for those items
			 * which are set now as disabled
			 */
			if ( asp->int_enable_reg.bits.data_available == 0 )
				asp->data_available_interrupt_state = OFF;
			if ( asp->int_enable_reg.bits.tx_holding == 0 )
				asp->tx_holding_register_empty_interrupt_state =
					OFF;
			if ( asp->int_enable_reg.bits.rx_line == 0 )
				asp->receiver_line_status_interrupt_state = OFF;
			if ( asp->int_enable_reg.bits.modem_status == 0 )
				asp->modem_status_interrupt_state = OFF;
			
			/*
			 * Check for immediately actionable interrupts
			 * If you change these, change the code for out2 as well.
			 */
			if ( asp->line_status_reg.bits.data_ready == 1 )
				raise_rda_interrupt(asp);
			if ( asp->line_status_reg.bits.tx_holding_empty == 1 )
				raise_thre_interrupt(asp);

			/* lower int line if no outstanding interrupts */
			clear_interrupt(asp);

#ifdef NTVDM
		       // Inform the host interface if the status of the
		       // data available interrupt has changed

		       if(org_da != asp->int_enable_reg.bits.data_available)
		       {
			       host_com_da_int_change(adapter,
					   asp->int_enable_reg.bits.data_available,
					   asp->line_status_reg.bits.data_ready);
		       }
#endif /* NTVDM */
		}
		else
		{
			asp->divisor_latch.byte.MSByte = value;
#ifndef NTVDM
			set_baud_rate(adapter);
#endif /* NTVDM */
		}
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cIER <- %x\n", id_for_adapter(adapter),
				value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"IER write %x \n",value);
		}
#endif
		break;
		
#if defined(NTVDM) && defined(FIFO_ON)
    case RS232_FIFO:
        {
        FIFO_CONTROL_REG    new_reg;
        new_reg.all = value;
        if (new_reg.bits.enabled != asp->fifo_control_reg.bits.enabled)
        {
            /* fifo enable state change, clear the fifo */
            asp->rx_fifo_write_counter = 0;
            asp->rx_fifo_read_counter = 0;

        }
        if (new_reg.bits.enabled != 0) {
            asp->fifo_trigger_counter = level_to_counter[new_reg.bits.trigger_le
vel];
            if (new_reg.bits.rx_reset) {
            asp->rx_fifo_write_counter = 0;
            asp->rx_fifo_read_counter = 0;
            }
            asp->int_id_reg.bits.fifo_enabled = 3;
        }
        else {
            asp->fifo_control_reg.bits.enabled = 0;
            asp->int_id_reg.bits.fifo_enabled = 0;
        }
        asp->fifo_control_reg.all = new_reg.all;
        break;
        }
#else /* !(NTVDM && FIFO_ON) */
	case RS232_IIR:
		/*
		 * Essentially a READ ONLY register
		 */
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cIIR <- READ ONLY\n",
				id_for_adapter(adapter));
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"IIR write %x \n",value);
		}
#endif
		break;
#endif /* NTVDM && FIFO_ON */

	case RS232_LCR:
#ifdef NTVDM
        /* The NT host code attempts to distinguish between applications
           that probe the UART and those that use it. Probes of the UART
           will not cause the systems comms port to be opened. The NT
           host code inherits the line settings from NT when the system
           comms port is opened. Therefore before an application reads
           or writes to the divisor bytes or the LCR the system
           comms port must be opened. This prevents the application
           reading incorrect values for the divisor bytes and writes
           to the divisor bytes getting overwritten by the system
           defaults. */

        {
            extern int host_com_open(int adapter);

            host_com_open(adapter);
        }
#endif /* NTVDM */

		if ((value & LCRFlushMask.all)
		!= (asp->line_control_reg.all & LCRFlushMask.all))
			com_flush_input(adapter);

		set_line_control(adapter, value);
		set_break(adapter);
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cLCR <- %x\n", id_for_adapter(adapter),
				value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"LCR write %x \n",value);
		}
#endif
		break;
		
	case RS232_MCR:
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cMCR <- %x\n", id_for_adapter(adapter),
				value);
			super_trace(buf);
		}
#endif
		/*
		 * Optimisation - DOS keeps re-writing this register
		 */
		if ( asp->modem_control_reg.all == value )
			break;
		
		asp->modem_control_reg.all = value;
		asp->modem_control_reg.bits.pad = 0;

		/* Must be called before set_dtr */
		set_loopback(adapter);
		set_dtr(adapter);
		set_rts(adapter);
		set_out1(adapter);
		set_out2(adapter);
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"MCR write %x \n",value);
		}
#endif
		break;
		
	case RS232_LSR:
		i = asp->line_status_reg.bits.tx_shift_empty;   /* READ ONLY */
		asp->line_status_reg.all = value;
		asp->line_status_reg.bits.tx_shift_empty = (unsigned char)i;
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cLSR <- %x\n", id_for_adapter(adapter),
				value);
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"LSR write %x \n",value);
		}
#endif
		break;
		
	case RS232_MSR:
		/*
		 * Essentially a READ ONLY register.
		 */
#ifdef SHORT_TRACE
		if ( io_verbose & RS232_VERBOSE )
		{
			sprintf(buf,"%cMSR <- READ ONLY\n",
				id_for_adapter(adapter));
			super_trace(buf);
		}
#endif
#ifndef PROD
		if (com_trace_fd)
		{
			if (com_dbg_pollcount)
			{
				fprintf(com_trace_fd,"\n");
				com_dbg_pollcount = 0;
			}
			fprintf(com_trace_fd,"MSR write %x \n",value);
		}
#endif
		/* DrDOS writes to this reg after setting int on MSR change
		 * and expects to get an interrupt back!!! So we will oblige.
		 * Writing to this reg only seems to affect the delta bits
		 * (bits 0-3) of the reg.
		 */
		if ((value & 0xf) != (asp->modem_status_reg.all & 0xf))
		{
			asp->modem_status_reg.all &= 0xf0;
			asp->modem_status_reg.all |= value & 0xf;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			if (asp->loopback_state == OFF)
				raise_ms_interrupt(asp);

			MODEM_STATE_CHANGE();
		}
		break;

/*
 * Scratch register.  Just store the value.
 */
	case RS232_SCRATCH:
		asp->scratch = value;
		break;
	
	}


#ifdef NTVDM
	host_com_unlock(adapter);
#endif
}
#endif // NEC_98


#ifdef IRET_HOOKS
/*(
 *========================== com_hook_again() ==================================
 * com_hook_again
 *
 * Purpose
 *	This is the function that we tell the ica to call when a comms
 *	interrupt service routine IRETs.
 *
 * Input
 *	adapter_id	The adapter id for the line. (Note the caller doesn't
 *			know what this is, he's just returning something
 *			we gave him earlier).
 *
 * Outputs
 *	return	TRUE if there are more interrupts to service, FALSE otherwise.
 *
 * Description
 *	First we call host_com_ioctl to find out if there are characters
 *	waiting.  If not, or we have reached the end of the current batch,
 *	we mark the end of batch and return FALSE.
 *	Otherwise we call recv_char() to kick-off the next character
 *	and return TRUE.
)*/

LOCAL IBOOL		/* local because we pass a pointer to it */
com_hook_again IFN1(IUM32, adapter)
{
	int input_ready;	/* the host wants a pointer to an 'int'! */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];

	host_com_ioctl(adapter, HOST_COM_INPUT_READY, (long)&input_ready);

#ifndef PROD
	if ((input_ready) && (asp->current_count >= asp->batch_size)) {
		sure_note_trace1(RS232_VERBOSE, "In hook again, adapter %d", adapter);
	}
#endif

	if((!input_ready)  || (asp->current_count >= asp->batch_size)) {
		asp->batch_running = FALSE;
		return(FALSE);
	} else {
		recv_char((long)adapter);
		return(TRUE);	/* more to do */
	}
}

/*(
 *========================== next_batch() ==================================
 * next_batch
 *
 * Purpose
 *	This function is called by the quick event system to kick-off the
 *	next batch of characters.
 *
 * Input
 *	dummy		Sometimes the adapter id, sometimes not.  Don't
 *			use it!
 *
 * Outputs
 *	None.
 *
 * Description
 *	If a batch is already running, now would not be a good time
 *	to start another, so we simply press the snooze button.
 *	Otherwise we check whether there is any data to process,
 *	and if so kick-off the next batch.
)*/

LOCAL void
next_batch IFN1 (long, dummy)
{
	int input_ready;	/* the host wants a pointer to an 'int'! */
	IUM8	adapter;	/* check all adapters */
	struct ADAPTER_STATE *asp;
	IBOOL	new_qe_reqd;	/* Do we need to restart the quick event */

	UNUSED(dummy);

	new_qe_reqd = FALSE;	/* Dont need another by default */

	for (adapter = 0; adapter < NUM_SERIAL_PORTS; adapter++) {
		asp = &adapter_state[adapter];


		if (asp->batch_running) {
			new_qe_reqd = TRUE;	/* not finished yet */
		} else if (asp->qev_running) {
			/*
			 * We need to set qev running to false, as it has now
			 * finished. If there is data to process, we call
			 * recv_char() which will start-off a new batch (and
			 * set the batch_running flag).
			 */
	
			asp->qev_running = FALSE;
			host_com_ioctl((int)adapter,HOST_COM_INPUT_READY, (long)&input_ready);
			if(input_ready) {
				recv_char((int)adapter);
			}
		}
	}
	if (new_qe_reqd) {
#ifdef GISP_CPU
		hg_add_comms_cb(next_batch, MIN_COMMS_RX_QEV);
#else
		add_q_event_t(next_batch, MIN_COMMS_RX_QEV, 0);
#endif
		sure_note_trace0(RS232_VERBOSE, "Reset batch quick event");
	} else {
		qev_running = FALSE;
	}
}

#endif /* of ifdef IRET_HOOKS */

/*
 * =====================================================================
 * Subsidiary functions - for transmitting characters
 * =====================================================================
 */

#if defined(NEC_98)

void com_recv_char(int adapter)
{
    struct ADAPTER_STATE *asp = &adapter_state[adapter];

#ifndef PROD
    if(asp->read_status_reg.bits.rx_ready ||
       asp->rx_ready_interrupt_state == ON)
    {
    printf("ntvdm : Data already in comms adapter (%s%s)\n",
               asp->read_status_reg.bits.rx_ready ? "Data" : "Int",
           asp->rx_ready_interrupt_state == ON ? ",Int" : "");

//      host_com_state(adapter);
    }
#endif

    recv_char((long)adapter);
}

GLOBAL void
recv_char IFN1(long, adapt_long)
{
        /*
         * Character available on input device, read char, format char
         * checking for parity and overrun errors, raise the appropriate
         * interrupt.
         */
        struct ADAPTER_STATE *asp = &adapter_state[adapt_long];
        int error_mask = 0;

        host_com_read(adapt_long, (char *)&asp->rx_buffer, &error_mask);

        if (error_mask)
        {
                /*
                 * Set line status register and raise line status interrupt
                 */
                if (error_mask & HOST_COM_OVERRUN_ERROR)
                        asp->read_status_reg.bits.overrun_error = 1;

                if (error_mask & HOST_COM_FRAMING_ERROR)
                        asp->read_status_reg.bits.framing_error = 1;

                if (error_mask & HOST_COM_PARITY_ERROR)
                        asp->read_status_reg.bits.parity_error = 1;

                if (error_mask & HOST_COM_BREAK_RECEIVED)
                        asp->read_status_reg.bits.break_detect = 1;

        }

        set_recv_char_status(asp);
}
#else // NEC_98

#ifdef  NTVDM
// This code has been added for the MS project!!!!!!!


void com_recv_char(int adapter)
{
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    int error;

#ifdef FIFO_ON
    if(asp->fifo_control_reg.bits.enabled) {
    /* pull data from serial driver until the fifo is full or
       there are no more data
    */
    asp->rx_fifo_read_counter = 0;

    asp->rx_fifo_write_counter = host_com_read_char(adapter,
                   asp->rx_fifo,
                   FIFO_BUFFER_SIZE
                   );
    /* if the total chars in the fifo is more than or equalt to the trigger
       count, raise a RDA int, otherwise, raise a fifo time out int.
       We will continue to delivery char available in the fifo until
       the rx_fifo_write_counter reaches zero every time the application
       read out the byte we put in rx_buffer
    */
    if (asp->rx_fifo_write_counter) {
        /* we have at least one byte to delivery */
        asp->line_status_reg.bits.data_ready = 1;
        if (asp->rx_fifo_write_counter >= asp->fifo_trigger_counter)
        raise_rda_interrupt(asp);
        else
        raise_fifo_timeout_interrupt(asp);
    }
    }
    else
#endif

    {
    error = 0;
    host_com_read(adapter, (char *)&asp->rx_buffer, &error);
    if (error != 0)
    {
        lsr_change(asp, error);
                raise_rls_interrupt(asp);
        }
    set_recv_char_status(asp);
    }
}
#ifdef FIFO_ON
static void recv_char_from_fifo(struct ADAPTER_STATE *asp)
{
    int error;

    asp->rx_buffer = asp->rx_fifo[asp->rx_fifo_read_counter].data;
    error = asp->rx_fifo[asp->rx_fifo_read_counter++].error;
    if (error != 0) {
    lsr_change(asp, error);
    raise_rls_interrupt(asp);
    }
    asp->rx_fifo_write_counter--;
}
#endif

#else /* NTVDM */

void com_recv_char IFN1(int, adapter)
{
	/*
	 * Character available on input device; process character if adapter
	 * is ready to receive it
	 */

	/* Check adapter not already in critical region */
	if (!is_com_critical(adapter))
	{
		com_critical_start(adapter);
		recv_char((long)adapter);
	}
}
#endif /* NTVDM */

/*
 * BCN 2151 - recv_char must use long param to match add_event function prototype
 */
GLOBAL void
recv_char IFN1(long, adapt_long)
{
	int adapter = adapt_long;

	/*
	 * Character available on input device, read char, format char
	 * checking for parity and overrun errors, raise the appropriate
	 * interrupt.
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	int error_mask = 0;
	
	host_com_read(adapter, (UTINY *)&asp->rx_buffer, &error_mask);
	
	if (error_mask)
	{
		/*
		 * Set line status register and raise line status interrupt
		 */
		if (error_mask & HOST_COM_OVERRUN_ERROR)
			asp->line_status_reg.bits.overrun_error = 1;
		
		if (error_mask & HOST_COM_FRAMING_ERROR)
			asp->line_status_reg.bits.framing_error = 1;
		
		if (error_mask & HOST_COM_PARITY_ERROR)
			asp->line_status_reg.bits.parity_error = 1;
		
		if (error_mask & HOST_COM_BREAK_RECEIVED)
			asp->line_status_reg.bits.break_interrupt = 1;
		
		raise_rls_interrupt(asp);
	}
	
	set_recv_char_status(asp);
	
#ifdef DOCUMENTATION
	/*
	 * I think this is wrong for polled comms applications WTGC BCN 354
	 */
	
	/*
	 * If the data available interrupt is not to be delivered to the CPU,
	 * then the adapter must come out of the critical region at once
	 */
	if (asp->data_available_interrupt_state != ON)
	{
		long	input_ready = 0;
		
		/* check for further input */
		host_com_ioctl(adapter, HOST_COM_INPUT_READY,
			(long)&input_ready);
		if (input_ready)
			recv_char((long)adapter);
		else
			com_critical_reset(adapter);
	}
#endif
}
#endif // NEC_98

#ifdef NTVDM
#ifndef NEC_98
static void lsr_change(struct ADAPTER_STATE *asp, unsigned int new_lsr)
{
    if (new_lsr & HOST_COM_OVERRUN_ERROR)
    asp->line_status_reg.bits.overrun_error = 1;
    if (new_lsr & HOST_COM_FRAMING_ERROR)
    asp->line_status_reg.bits.framing_error = 1;
    if (new_lsr & HOST_COM_PARITY_ERROR)
    asp->line_status_reg.bits.parity_error = 1;
    if (new_lsr & HOST_COM_BREAK_RECEIVED)
    asp->line_status_reg.bits.break_interrupt = 1;
/* we have no control of serial driver fifo enable/disabled states
   we may receive a fifo error even the application doesn't enable it.
   fake either framing or parity error
*/
    if (new_lsr & HOST_COM_FIFO_ERROR)
#ifdef FIFO_ON
    if (asp->fifo_control_reg.bits.enabled)
        asp->line_status_reg.bits.fifo_error = 1;
    else if (asp->line_control_reg.bits.parity_enabled == PARITYENABLE_OFF)
        asp->line_status_reg.bits.framing_error = 1;
    else
        asp->line_status_reg.bits.parity_error = 1;
#else
    if (asp->line_control_reg.bits.parity_enabled == PARITYENABLE_OFF)
        asp->line_status_reg.bits.framing_error = 1;
    else
        asp->line_status_reg.bits.parity_error = 1;
#endif

}
#endif // !NEC_98

void com_lsr_change(int adapter)
{
#ifndef NEC_98
    int new_lsr;
    struct ADAPTER_STATE *asp = &adapter_state[adapter];

    new_lsr = -1;
    host_com_ioctl(adapter, HOST_COM_LSR, (long)&new_lsr);
    if (new_lsr !=  -1)
    lsr_change(asp, new_lsr);
#endif  // !NEC_98
}

#endif /* NTVDM */

/*
 * One of the modem control input lines has changed state
 */
void com_modem_change IFN1(int, adapter)
{
	modem_change(adapter);
}

#if defined(NEC_98)

static void modem_change IFN1(int, adapter)
{
    /*
     * Update the modem status register after a change to one of the
     * modem control input lines
     */
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    long modem_status = 0;

    /* get current modem input state */
    host_com_ioctl(adapter, HOST_COM_MODEM, (long)&modem_status);
    asp->read_signal_reg.bits.CS = (modem_status & HOST_COM_MODEM_CTS)  ? 0 : 1;
    asp->read_status_reg.bits.DR = (modem_status & HOST_COM_MODEM_DSR)  ? 1 : 0;
    asp->read_signal_reg.bits.CD = (modem_status & HOST_COM_MODEM_RLSD) ? 0 : 1;
    asp->read_signal_reg.bits.RI = (modem_status & HOST_COM_MODEM_RI)   ? 0 : 1;
}
#else // NEC_98
static void modem_change IFN1(int, adapter)
{
	/*
	 * Update the modem status register after a change to one of the
	 * modem control input lines
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	long modem_status = 0;
	int cts_state, dsr_state, rlsd_state, ri_state;
	
	if (asp->loopback_state == OFF)
	{
		/* get current modem input state */
		host_com_ioctl(adapter, HOST_COM_MODEM, (long)&modem_status);
		cts_state  = (modem_status & HOST_COM_MODEM_CTS)  ? ON : OFF;
		dsr_state  = (modem_status & HOST_COM_MODEM_DSR)  ? ON : OFF;
		rlsd_state = (modem_status & HOST_COM_MODEM_RLSD) ? ON : OFF;
		ri_state   = (modem_status & HOST_COM_MODEM_RI)   ? ON : OFF;
		
		/*
		 * Establish CTS state
		 */
		switch(change_state(cts_state, asp->modem_status_reg.bits.CTS))
		{
		case ON:
			asp->modem_status_reg.bits.CTS = ON;
			asp->modem_status_reg.bits.delta_CTS = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
			MODEM_STATE_CHANGE();
			break;
		
		case OFF:
			asp->modem_status_reg.bits.CTS = OFF;
			asp->modem_status_reg.bits.delta_CTS = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
			MODEM_STATE_CHANGE();
			break;
		
		case LEAVE_ALONE:
			break;
		}
		
		/*
		 * Establish DSR state
		 */
		switch(change_state(dsr_state, asp->modem_status_reg.bits.DSR))
		{
		case ON:
			asp->modem_status_reg.bits.DSR = ON;
			asp->modem_status_reg.bits.delta_DSR = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
			MODEM_STATE_CHANGE();
			break;
		
		case OFF:
			asp->modem_status_reg.bits.DSR = OFF;
			asp->modem_status_reg.bits.delta_DSR = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
			MODEM_STATE_CHANGE();
			break;
		
		case LEAVE_ALONE:
			break;
		}
		
		/*
		 * Establish RLSD state
		 */
		switch(change_state(rlsd_state,
			asp->modem_status_reg.bits.RLSD))
		{
		case ON:
			asp->modem_status_reg.bits.RLSD = ON;
			asp->modem_status_reg.bits.delta_RLSD = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
			MODEM_STATE_CHANGE();
			break;
		
		case OFF:
			asp->modem_status_reg.bits.RLSD = OFF;
			asp->modem_status_reg.bits.delta_RLSD = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
			MODEM_STATE_CHANGE();
			break;
		
		case LEAVE_ALONE:
			break;
		}
		
		/*
		 * Establish RI state
		 */
		switch(change_state(ri_state, asp->modem_status_reg.bits.RI))
		{
		case ON:
			asp->modem_status_reg.bits.RI = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);
			MODEM_STATE_CHANGE();
			break;
		
		case OFF:
			asp->modem_status_reg.bits.RI = OFF;
			asp->modem_status_reg.bits.TERI = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
			MODEM_STATE_CHANGE();
			break;
		
		case LEAVE_ALONE:
			break;
		}
	}
}
#endif // NEC_98

#if defined(NEC_98)
static void set_recv_char_status IFN1(struct ADAPTER_STATE *, asp)
{
        /*
         * Check for data overrun and set up correct interrupt
         */
        if ( asp->read_status_reg.bits.rx_ready == 1 )
        {
                asp->read_status_reg.bits.overrun_error = 1;
        }
        else
        {
                asp->read_status_reg.bits.rx_ready = 1;
                raise_rxr_interrupt(asp);
        }
}
#else // NEC_98
static void set_recv_char_status IFN1(struct ADAPTER_STATE *, asp)
{
	/*
	 * Check for data overrun and set up correct interrupt
	 */
	if ( asp->line_status_reg.bits.data_ready == 1 )
	{
		sure_note_trace0(RS232_VERBOSE, "overrun error in set_recv_char_status");
		asp->line_status_reg.bits.overrun_error = 1;
		raise_rls_interrupt(asp);
	}
	else
	{
		asp->line_status_reg.bits.data_ready = 1;
		raise_rda_interrupt(asp);
	}
}
#endif // NEC_98

static void set_xmit_char_status IFN1(struct ADAPTER_STATE *, asp)
{
	/*
	 * Set line status register and raise interrupt
	 */
#if defined(NEC_98)
        asp->read_status_reg.bits.tx_empty = 1;
        asp->read_status_reg.bits.tx_ready = 1;
        raise_txr_interrupt(asp);
#else // NEC_98
	asp->line_status_reg.bits.tx_holding_empty = 1;
	asp->line_status_reg.bits.tx_shift_empty = 1;
	raise_thre_interrupt(asp);
#endif // NEC_98
}

#ifdef NTVDM
GLOBAL void tx_shift_register_empty(int adapter)
{
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
#if defined(NEC_98)
    asp->read_status_reg.bits.tx_ready = 1;
#else // NEC_98
    asp->line_status_reg.bits.tx_shift_empty = 1;
#endif // NEC_98
}
GLOBAL void tx_holding_register_empty(int adapter)
{
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
#if defined(NEC_98)
    asp->read_status_reg.bits.tx_empty = 1;
    raise_txr_interrupt(asp);
#else // NEC_98
    asp->line_status_reg.bits.tx_holding_empty = 1;
    raise_thre_interrupt(asp);
#endif // NEC_98
}
#endif

/*
 * =====================================================================
 * Subsidiary functions - for setting comms parameters
 * =====================================================================
 */

static void set_break IFN1(int, adapter)
{
	/*
	 * Process the set break control bit. Bit 6 of the Line Control
	 * Register.
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	
#if defined(NEC_98)
        switch ( change_state((int)asp->command_write_reg.bits.send_break,
                asp->break_state) )
#else // NEC_98
	switch ( change_state((int)asp->line_control_reg.bits.set_break,
		asp->break_state) )
#endif // NEC_98
	{
	case ON:
		asp->break_state = ON;
		host_com_ioctl(adapter, HOST_COM_SBRK, 0);
		break;
	
	case OFF:
		asp->break_state = OFF;
		host_com_ioctl(adapter, HOST_COM_CBRK, 0);
		break;
	
	case LEAVE_ALONE:
		break;
	}
}

/*
 * The following table is derived from page 1-200 of the XT Tech Ref 1st Ed
 * (except rates above 9600 which are not OFFICIALLY supported on the XT and
 * AT, but are theoretically possible) */

#if defined(NEC_98)
static word valid_latches8[] =
{
//     8MHz     baud
        0,              /* 115200 baud */
        0,              /* 57600 baud */
        0,              /* 38400 baud */
        0,              /* 19200 baud */
        13,             /* 9600 baud */
        0,              /* 7200 baud */
        26,             /* 4800 baud */
        0,    //39,      /* 3600 baud */
        52,             /* 2400 baud */
        0,              /* 2000 baud */
        0,    //78,      /* 1800 baud */
        104,            /* 1200 baud */
        208,            /* 600 baud */
        416,            /* 300 baud */
        832,            /* 150 baud */
        0,              /* 134 baud */
        1135,           /* 110 baud */
        1664,       /* 75 baud */
        2496,       /* 50 baud */
};
static word valid_latches10[] =
{
//    10MHz     baud
        0,              /* 115200 baud */
        0,              /* 57600 baud */
        4,              /* 38400 baud */
        8,              /* 19200 baud */
        16,             /* 9600 baud */
        0,    //24,      /* 7200 baud */
        32,             /* 4800 baud */
        0,    //48,      /* 3600 baud */
        64,             /* 2400 baud */
        0,              /* 2000 baud */
        0,    //96,      /* 1800 baud */
        128,            /* 1200 baud */
        256,            /* 600 baud */
        512,            /* 300 baud */
        1024,           /* 150 baud */
        0,              /* 134 baud */
        1396,           /* 110 baud */
        2048,           /* 75 baud */
        3072,           /* 50 baud */
};
#else // NEC_98
static word valid_latches[] =
{
	1, 	2, 	3, 	6, 	12, 	16, 	24, 	32,
	48, 	58, 	64, 	96, 	192,	384, 	768, 	857,
	1047, 	1536, 	2304
};
#endif // NEC_98

#if defined(NEC_98)
static long bauds[] =
{
        115200, /* 115200 baud */
        57600, /* 57600 baud */
        38400, /* 38400 baud */
        19200, /* 19200 baud */
        9600, /* 9600 baud */
        7200, /* 7200 baud */
        4800, /* 4800 baud */
        3600, /* 3600 baud */
        2400, /* 2400 baud */
        2000, /* 2000 baud */
        1800, /* 1800 baud */
        1200, /* 1200 baud */
        600, /* 600 baud */
        300, /* 300 baud */
        150, /* 150 baud */
        134, /* 134 baud */
        110, /* 110 baud */
        75, /* 75 baud */
        50  /* 50 baud */
};
#else // NEC_98
#if !defined(PROD) || defined(IRET_HOOKS)
static IUM32 bauds[] =
{
	115200, /* 115200 baud */
	57600, /* 57600 baud */
	38400, /* 38400 baud */
	19200, /* 19200 baud */
	9600, /* 9600 baud */
	7200, /* 7200 baud */
	4800, /* 4800 baud */
	3600, /* 3600 baud */
	2400, /* 2400 baud */
	2000, /* 2000 baud */
	1800, /* 1800 baud */
	1200, /* 1200 baud */
	600, /* 600 baud */
	300, /* 300 baud */
	150, /* 150 baud */
	134, /* 134 baud */
	110, /* 110 baud */
	75, /* 75 baud */
	50  /* 50 baud */
};
#endif /* !PROD or IRET_HOOKS*/
#endif // NEC_98

static word speeds[] =
{
	HOST_COM_B115200,
	HOST_COM_B57600,
	HOST_COM_B38400,
	HOST_COM_B19200,
	HOST_COM_B9600,
	HOST_COM_B7200,
	HOST_COM_B4800,
	HOST_COM_B3600,
	HOST_COM_B2400,
	HOST_COM_B2000,
	HOST_COM_B1800,
	HOST_COM_B1200,
	HOST_COM_B600,
	HOST_COM_B300,
	HOST_COM_B150,
	HOST_COM_B134,
	HOST_COM_B110,
	HOST_COM_B75,
	HOST_COM_B50
};

#if defined(NEC_98)
static int no_valid_latches =
        (int)(sizeof(valid_latches8)/sizeof(valid_latches8[0]));
#else // NEC_98
static int no_valid_latches =
	(int)(sizeof(valid_latches)/sizeof(valid_latches[0]));
#endif // NEC_98

#if defined(NEC_98)
void SetRSBaud( BaudRate )
word BaudRate;
{
    struct ADAPTER_STATE *asp = &adapter_state[COM1];
    int i;
    com_flush_input( COM1 );

    asp->divisor_latch.all = BaudRate;
    /*
     * Check for valid divisor latch
     */
    for (i = 0;
         i < no_valid_latches;
         i++)
        {
//      if (Bus_Clock == 8 )  {                  // add 93.9.14
        if (BaudRate == valid_latches8[i])
            break;
//      }                                        // add 93.9.14
//      else {                                   // add 93.9.14
        if (BaudRate == valid_latches10[i])
            break;
//      }                                        // add 93.9.14
        }
    if (i < no_valid_latches)       /* ie map found */
    {
#ifndef NTVDM
        host_com_ioctl(COM1, HOST_COM_BAUD, speeds[i]);
#else
        host_com_ioctl(COM1, HOST_COM_BAUD, bauds[i]);
#endif
            asp->com_baud_ind = i;
            sure_note_trace3(RS232_VERBOSE,
                    " delay for baud %d RX:%d TX:%d", bauds[i],
                    RX_delay[i], TX_delay[i]);
    }
}
#endif // NEC_98


#if defined(NEC_98)
static void set_baud_rate IFN1(int, adapter)
{
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    int i;

    if (adapter == COM1)
        SetRSBaud( asp->divisor_latch.all );
}
#else // NEC_98
static void set_baud_rate IFN1(int, adapter)
{
	/*
	 * Map divisor latch into a valid line speed and set our Unix
	 * device accordingly. Note as the sixteen bit divisor latch is
	 * likely to be written in two eight bit bytes, we ignore illegal
	 * values of the sixteen bit divisor latch - hoping a second
	 * byte will be written to produce a legal value. In addition
	 * the reset value (0) is illegal!
	 *
	 * For IRET hooks, we need to determine the batch size from
	 * the line speed, and an idea of how many quick events
	 * we can get per second. We add one to alow us to catch-up!
	 * Hence
	 * batch size = line_speed (in bits per second)
	 *	/ number of bits in a byte
	 *	* number of quick events ticks per second (normally 1000000)
	 *	/ the length in quick event ticks of a batch
	 *	+ 1
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	int i;

	com_flush_input(adapter);

#ifndef NTVDM

	/*
	 * Check for valid divisor latch
	 */
	for (i = 0; i < no_valid_latches && asp->divisor_latch.all !=
		valid_latches[i]; i++)
			;
	
	if (i < no_valid_latches)	/* ie map found */
	{
		host_com_ioctl(adapter, HOST_COM_BAUD, speeds[i]);
		asp->com_baud_ind = i;
		sure_note_trace3(RS232_VERBOSE,
			" delay for baud %d RX:%d TX:%d", bauds[i],
			RX_delay[i], TX_delay[i]);
#ifdef IRET_HOOKS
#ifdef VARIABLE_TICK_COMMS
		asp->batch_size = ((bauds[i] / BITS_PER_ASYNC_CHAR) /
							(COMMS_QEV_PER_SEC/2)) + 1;
		sure_note_trace2(RS232_VERBOSE,
					"baud %d asp->batch_size =%d",bauds[i],asp->batch_size);
#else /* VARIABLE_TICK_COMMS */
		asp->batch_size = ((bauds[i] / BITS_PER_ASYNC_CHAR) /
							COMMS_QEV_PER_SEC) + 1;
#endif /* VARIABLE_TICK_COMMS */
#endif /* IRET_HOOKS */
	}
#else /* NTVDM */
    //The host is not limited in the baud rates that it supports

    if(asp->divisor_latch.all)
        /* baudrate = clock frequency / (diviso * 16) by taking
           frequency as 1.8432 MHZ
        */
        host_com_ioctl(adapter,HOST_COM_BAUD,115200/asp->divisor_latch.all);
#endif /* NTVDM */
}
#endif // NEC_98

#if defined(NEC_98)
static void set_mask_8251(adapter, value)
int adapter;
int value;
{
        struct ADAPTER_STATE *asp = &adapter_state[adapter];
        asp->int_mask_reg.all = value & 0x7;
//      PRINTDBGNEC98( NEC98DBG_in_trace1,
//                    ("COMMS : set_mask_8251 : INT MASK = %x \n                        Status   = %x \n",asp->int_mask_reg.all,asp->read_status_reg.all) );
        /*
         * Kill off any pending interrupts for those items
         * which are set now as disabled
         */
        if ( asp->int_mask_reg.bits.RXR_enable == 0 )
                asp->rx_ready_interrupt_state = OFF;
        if ( asp->int_mask_reg.bits.TXE_enable == 0 )
                asp->tx_empty_interrupt_state = OFF;
        if ( asp->int_mask_reg.bits.TXR_enable == 0 )
                asp->tx_ready_interrupt_state = OFF;

        /*
         * Check for immediately actionable interrupts
         */
        if ( asp->read_status_reg.bits.rx_ready == 1 )
                raise_rxr_interrupt(asp);
        if ( asp->read_status_reg.bits.tx_ready == 1 )
                raise_txr_interrupt(asp);
        if ( asp->read_status_reg.bits.tx_empty == 1 )
                raise_txe_interrupt(asp);

        /* lower int line if no outstanding interrupts */
        clear_interrupt(asp);
}

static void read_signal_8251(adapter)
int adapter;
{
        long modem_status = 0;
        struct ADAPTER_STATE *asp = &adapter_state[adapter];
        /* get current modem input state */
        host_com_ioctl(adapter, HOST_COM_MODEM, (long)&modem_status);
        asp->read_signal_reg.bits.RI =
                        (modem_status & HOST_COM_MODEM_RI) ? 0 : 1;
        asp->read_signal_reg.bits.CS =
                        (modem_status & HOST_COM_MODEM_CTS) ? 0 : 1;
        asp->read_signal_reg.bits.CD =
                        (modem_status & HOST_COM_MODEM_RLSD) ? 0 : 1;
        asp->read_signal_reg.bits.pad = 0;
}

static void set_mode_8251(adapter, value)
int adapter;
int value;
{
        /*
         * Set Number of data bits
         *     Parity bits
         *     Number of stop bits
         */
        struct ADAPTER_STATE *asp = &adapter_state[adapter];
        MODE8251 newMODE;
        int newParity, parity;

        newMODE.all = value;

        /*
         * Set up the number of data bits
         */
        if (asp->mode_set_reg.bits.char_length != newMODE.bits.char_length)
                host_com_ioctl(adapter, HOST_COM_DATABITS,
                        newMODE.bits.char_length + 5);

        /*
         * Set up the number of stop bits
         */
        if (asp->mode_set_reg.bits.stop_bit
        != newMODE.bits.stop_bit)
                host_com_ioctl(adapter, HOST_COM_STOPBITS,
                        (newMODE.bits.stop_bit >> 1) + 1);

        /* What are new settings to check for a difference */
#ifdef NTVDM
        if (newMODE.bits.parity_enable == PARITYENABLE_OFF)
#else
        if (newMODE.bits.parity_enable == PARITY_OFF)
#endif
        {
                newParity = HOST_COM_PARITY_NONE;
        }
        else /* regular parity */
        {
#ifdef NTVDM
                newParity = newMODE.bits.parity_even == EVENPARITY_ODD ?
#else
                newParity = newMODE.bits.parity_even == PARITY_ODD ?
#endif
                        HOST_COM_PARITY_ODD : HOST_COM_PARITY_EVEN;
        }

        /*
         * Try to make sense of the current parity setting
         */
#ifdef NTVDM
        if (asp->mode_set_reg.bits.parity_enable == PARITYENABLE_OFF)
#else
        if (asp->mode_set_reg.bits.parity_enable == PARITY_OFF)
#endif
        {
                parity = HOST_COM_PARITY_NONE;
        }
        else /* regular parity */
        {
#ifdef NTVDM
                parity = asp->mode_set_reg.bits.parity_even == EVENPARITY_ODD ?
#else
                parity = asp->mode_set_reg.bits.parity_even == PARITY_ODD ?
#endif
                        HOST_COM_PARITY_ODD : HOST_COM_PARITY_EVEN;
        }

        if (newParity != parity)
                host_com_ioctl(adapter, HOST_COM_PARITY, newParity);

        /* finally update the current line control settings */
        asp->mode_set_reg.all = value;
}
#endif // NEC_98

#ifndef NEC_98
static void set_line_control IFN2(int, adapter, int, value)
{
	/*
	 * Set Number of data bits
	 *     Parity bits
	 *     Number of stop bits
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	LINE_CONTROL_REG newLCR;
	int newParity, parity;
	
	newLCR.all = (unsigned char)value;

	/*
	 * Set up the number of data bits
	 */
	if (asp->line_control_reg.bits.word_length != newLCR.bits.word_length)
		host_com_ioctl(adapter, HOST_COM_DATABITS,
			newLCR.bits.word_length + 5);
	
	/*
	 * Set up the number of stop bits
	 */
	if (asp->line_control_reg.bits.no_of_stop_bits
	!= newLCR.bits.no_of_stop_bits)
		host_com_ioctl(adapter, HOST_COM_STOPBITS,
			newLCR.bits.no_of_stop_bits + 1);

	/* What are new settings to check for a difference */
#ifdef NTVDM
	if (newLCR.bits.parity_enabled == PARITYENABLE_OFF)
#else
	if (newLCR.bits.parity_enabled == PARITY_OFF)
#endif
	{
		newParity = HOST_COM_PARITY_NONE;
	}
	else if (newLCR.bits.stick_parity == PARITY_STICK)
	{
#ifdef NTVDM
		newParity = newLCR.bits.even_parity == EVENPARITY_ODD ?
#else
		newParity = newLCR.bits.even_parity == PARITY_ODD ?
#endif
			HOST_COM_PARITY_MARK : HOST_COM_PARITY_SPACE;
	}
	else /* regular parity */
	{
#ifdef NTVDM
		newParity = newLCR.bits.even_parity == EVENPARITY_ODD ?
#else
		newParity = newLCR.bits.even_parity == PARITY_ODD ?
#endif
			HOST_COM_PARITY_ODD : HOST_COM_PARITY_EVEN;
	}

	/*
	 * Try to make sense of the current parity setting
	 */
#ifdef NTVDM
	if (asp->line_control_reg.bits.parity_enabled == PARITYENABLE_OFF)
#else
	if (asp->line_control_reg.bits.parity_enabled == PARITY_OFF)
#endif
	{
		parity = HOST_COM_PARITY_NONE;
	}
	else if (asp->line_control_reg.bits.stick_parity == PARITY_STICK)
	{
#ifdef NTVDM
		parity = asp->line_control_reg.bits.even_parity == EVENPARITY_ODD ?
#else
		parity = asp->line_control_reg.bits.even_parity == PARITY_ODD ?
#endif
			HOST_COM_PARITY_MARK : HOST_COM_PARITY_SPACE;
	}
	else /* regular parity */
	{
#ifdef NTVDM
		parity = asp->line_control_reg.bits.even_parity == EVENPARITY_ODD ?
#else
		parity = asp->line_control_reg.bits.even_parity == PARITY_ODD ?
#endif
			HOST_COM_PARITY_ODD : HOST_COM_PARITY_EVEN;
	}

	if (newParity != parity)
		host_com_ioctl(adapter, HOST_COM_PARITY, newParity);

#ifdef NTVDM
    //Change in the status of the DLAB selection bit, now is the time
    //to change the baud rate.

    if(!newLCR.bits.DLAB && asp->line_control_reg.bits.DLAB)
        set_baud_rate(adapter);
#endif

	/* finally update the current line control settings */
	asp->line_control_reg.all = (unsigned char)value;
}
#endif // NEC_98

#if defined(NEC_98)
static void set_dtr IFN1(int, adapter)
{
        /*
         * Process the DTR control bit, Bit 0 of the Modem Control
         * Register.
         */
        struct ADAPTER_STATE *asp = &adapter_state[adapter];

        switch ( change_state((int)asp->command_write_reg.bits.ER,
                                asp->dtr_state) )
        {
        case ON:
                asp->dtr_state = ON;
                /* set the real DTR modem output */
                host_com_ioctl(adapter, HOST_COM_SDTR, 0);
                break;

        case OFF:
                asp->dtr_state = OFF;
                /* clear the real DTR modem output */
                host_com_ioctl(adapter, HOST_COM_CDTR, 0);
                break;

        case LEAVE_ALONE:
                break;
        }
}
#else // NEC_98
static void set_dtr IFN1(int, adapter)
{
	/*
	 * Process the DTR control bit, Bit 0 of the Modem Control
	 * Register.
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	
	switch ( change_state((int)asp->modem_control_reg.bits.DTR,
				asp->dtr_state) )
	{
	case ON:
		asp->dtr_state = ON;
		if (asp->loopback_state == OFF)
		{
			/* set the real DTR modem output */
			host_com_ioctl(adapter, HOST_COM_SDTR, 0);
		}
		else
		{
			/*
			 * loopback the DTR modem output into the
			 * DSR modem input
			 */
			asp->modem_status_reg.bits.DSR = ON;
			asp->modem_status_reg.bits.delta_DSR = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
		}
		MODEM_STATE_CHANGE();
		break;
	
	case OFF:
		asp->dtr_state = OFF;
		if (asp->loopback_state == OFF)
		{
			/* clear the real DTR modem output */
			host_com_ioctl(adapter, HOST_COM_CDTR, 0);
		}
		else
		{
			/*
			 * loopback the DTR modem output into the
			 * DSR modem input
			 */
			asp->modem_status_reg.bits.DSR = OFF;
			asp->modem_status_reg.bits.delta_DSR = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
		}
		MODEM_STATE_CHANGE();
		break;
	
	case LEAVE_ALONE:
		break;
	}
}
#endif // NEC_98

#if defined(NEC_98)
static void set_rts IFN1(int, adapter)
{
        /*
         * Process the RTS control bit, Bit 1 of the Modem Control
         * Register.
         */
        struct ADAPTER_STATE *asp = &adapter_state[adapter];

        switch ( change_state((int)asp->command_write_reg.bits.RS,
                                asp->rts_state) )
        {
        case ON:
                asp->rts_state = ON;
                /* set the real RTS modem output */
                host_com_ioctl(adapter, HOST_COM_SRTS, 0);
                break;

        case OFF:
                asp->rts_state = OFF;
                /* clear the real RTS modem output */
                host_com_ioctl(adapter, HOST_COM_CRTS, 0);
                break;

        case LEAVE_ALONE:
                break;
        }
}
#else // NEC_98
static void set_rts IFN1(int, adapter)
{
	/*
	 * Process the RTS control bit, Bit 1 of the Modem Control
	 * Register.
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	
	switch ( change_state((int)asp->modem_control_reg.bits.RTS,
				asp->rts_state) )
	{
	case ON:
		asp->rts_state = ON;
		if (asp->loopback_state == OFF)
		{
			/* set the real RTS modem output */
			host_com_ioctl(adapter, HOST_COM_SRTS, 0);
		}
		else
		{
			/* loopback the RTS modem out into the CTS modem in */
			asp->modem_status_reg.bits.CTS = ON;
			asp->modem_status_reg.bits.delta_CTS = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
		}
		MODEM_STATE_CHANGE();
		break;
	
	case OFF:
		asp->rts_state = OFF;
		if (asp->loopback_state == OFF)
		{
			/* clear the real RTS modem output */
			host_com_ioctl(adapter, HOST_COM_CRTS, 0);
		}
		else
		{
			/* loopback the RTS modem out into the CTS modem in */
			asp->modem_status_reg.bits.CTS = OFF;
			asp->modem_status_reg.bits.delta_CTS = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
		}
		MODEM_STATE_CHANGE();
		break;
	
	case LEAVE_ALONE:
		break;
	}
}
#endif // NEC_98

#ifndef NEC_98
static void set_out1 IFN1(int, adapter)
{
	/*
	 * Process the OUT1 control bit, Bit 2 of the Modem Control
	 * Register.
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	
	switch ( change_state((int)asp->modem_control_reg.bits.OUT1,
				asp->out1_state) )
	{
	case ON:
		asp->out1_state = ON;
		if (asp->loopback_state == OFF)
		{
			/*
			 * In the real adapter, this modem control output
			 * signal is not connected; so no real modem
			 * control change is required
			 */
		}
		else
		{
			/* loopback the OUT1 modem out into the RI modem in */
			asp->modem_status_reg.bits.RI = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);
		}
		MODEM_STATE_CHANGE();
		break;
	
	case OFF:
		asp->out1_state = OFF;
		if (asp->loopback_state == OFF)
		{
			/*
			 * In the real adapter, this modem control output
			 * signal is not connected; so no real modem control
			 * change is required
			 */
		}
		else
		{
			/* loopback the OUT1 modem out into the RI modem in */
			asp->modem_status_reg.bits.RI = OFF;
			asp->modem_status_reg.bits.TERI = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
		}
		MODEM_STATE_CHANGE();
		break;
	
	case LEAVE_ALONE:
		break;
	}
}

static void set_out2 IFN1(int, adapter)
{
	/*
	 * Process the OUT2 control bit, Bit 3 of the Modem Control
	 * Register.
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	
	switch ( change_state((int)asp->modem_control_reg.bits.OUT2,
				asp->out2_state) )
	{
	case ON:
		asp->out2_state = ON;
		if (asp->loopback_state == OFF)
		{
			/*
			 * In the real adapter, this modem control output
			 * signal is used to determine whether the
			 * communications card should send interrupts; so
			 * check for immediately actionable interrupts.
			 * If you change this code, change the equivalent code
			 * for the interrupt enable register.
			 */
			if ( asp->line_status_reg.bits.data_ready == 1 )
				raise_rda_interrupt(asp);
			if ( asp->line_status_reg.bits.tx_holding_empty == 1 )
				raise_thre_interrupt(asp);
		}
		else
		{
			/* loopback the OUT2 modem output into the RLSD modem input */
			asp->modem_status_reg.bits.RLSD = ON;
			asp->modem_status_reg.bits.delta_RLSD = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
		}
		MODEM_STATE_CHANGE();
		break;
	
	case OFF:
		asp->out2_state = OFF;
		if (asp->loopback_state == OFF)
		{
			/*
			 * In the real adapter, this modem control output signal
			 * is used to determine whether the communications
			 * card should send interrupts; so no real modem
			 * control change is required
			 */
		}
		else
		{
			/* loopback the OUT2 modem out into the RLSD modem in */
			asp->modem_status_reg.bits.RLSD = OFF;
			asp->modem_status_reg.bits.delta_RLSD = ON;
			host_com_msr_callback (adapter, asp->modem_status_reg.all);

			raise_ms_interrupt(asp);
		}
		MODEM_STATE_CHANGE();
		break;
	
	case LEAVE_ALONE:
		break;
	}
}

static void set_loopback IFN1(int, adapter)
{
	/*
	 * Process the loopback control bit, Bit 4 of the Modem Control
	 * Register.
	 */
	struct ADAPTER_STATE *asp = &adapter_state[adapter];
	
	switch ( change_state((int)asp->modem_control_reg.bits.loop,
				asp->loopback_state) )
	{
		case ON:
		asp->loopback_state = ON;
		/*
		 * Subsequent calls to set_dtr(), set_rts(), set_out1() and
		 * set_out2() will cause the modem control inputs to be set
		 * according to the the modem control outputs
		 */
		break;
	
	case OFF:
		asp->loopback_state = OFF;
		/*
		 * Set the modem control inputs according to the real
		 * modem state
		 */
		modem_change(adapter);
		break;
	
	case LEAVE_ALONE:
		break;
	}
}
#endif // NEC_98

#ifdef SHORT_TRACE

static char last_buffer[80];
static int repeat_count = 0;

static void super_trace IFN1(char *, string)
{
	if ( strcmp(string, last_buffer) == 0 )
		repeat_count++;
	else
	{
		if ( repeat_count != 0 )
		{
			fprintf(trace_file,"repeated %d\n",repeat_count);
			repeat_count = 0;
		}
		fprintf(trace_file, "%s", string);
		strcpy(last_buffer, string);
	}
}
#endif


void com1_flush_printer IFN0()
{
#ifdef NTVDM
	host_com_lock(COM1);
#endif

	host_com_ioctl(COM1, HOST_COM_FLUSH, 0);

#ifdef NTVDM
       host_com_unlock(COM1);
#endif
}

void com2_flush_printer IFN0()
{
#ifdef NTVDM
	host_com_lock(COM2);
#endif

       host_com_ioctl(COM2, HOST_COM_FLUSH, 0);

#ifdef NTVDM
       host_com_unlock(COM2);
#endif
}


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#if defined(NEC_98)
static void com_reset IFN1(int, adapter)
{
        struct ADAPTER_STATE *asp = &adapter_state[adapter];

        /*
         * Set default state of all adapter registers
         */
        asp->int_mask_reg.all = 0;

        // Tell host side the state of the data available interrupt

        /* mode default = 0x4e */
        asp->mode_set_reg.all = 0x00;
        set_mode_8251(adapter, 0x4e );

        /*
         * set up modem control reg so next set_dtr etc.
         * Will produce required status
         */
        asp->command_write_reg.all = 0;
        asp->command_write_reg.bits.ER = ON;
        asp->command_write_reg.bits.RS = ON;
        host_com_ioctl(adapter, HOST_COM_SDTR, 0);
        host_com_ioctl(adapter, HOST_COM_SRTS, 0);
        asp->mode_set_state = OFF;          // next OUT is command
        asp->timer_mode_state = OFF; //Timer mode clear. Next timer set is LSB.

        asp->command_write_reg.bits.rx_enable = ON;
        host_com_da_int_change(adapter,asp->command_write_reg.bits.rx_enable,0);
        asp->read_status_reg.all = 0;
        asp->read_status_reg.bits.tx_ready = 1;
        asp->read_status_reg.bits.tx_empty = 1;

        asp->read_signal_reg.all = 0;

        /*
         * Set up default state of our state variables
         */
        asp->rx_ready_interrupt_state = OFF;
        asp->tx_ready_interrupt_state = OFF;
        asp->tx_empty_interrupt_state = OFF;
        asp->break_state = OFF;
        asp->dtr_state = ON;
        asp->rts_state = ON;

        /*
         * Reset adapter synchronisation
         */
        com_critical_reset(adapter);

        /*
         * Set Unix devices to default state
         */
        set_baud_rate(adapter);
        set_break(adapter);

        /* Must be called before set_dtr */
        set_dtr(adapter);
        set_rts(adapter);

}
#else // NEC_98
static void com_reset IFN1(int, adapter)
{
	struct ADAPTER_STATE *asp = &adapter_state[adapter];

	/* setup the LCRFlushMask if it has not already been setup */
	if (!LCRFlushMask.all)
	{
		LCRFlushMask.all = ~0;	 /* turn all bits on */

		/*
		 * Now turn off the bits that should NOT cause the input
		 * to be flushed.  Note set_break is handled seperately by
		 * the set_break() routine.
		 */
		LCRFlushMask.bits.DLAB = 0;
		LCRFlushMask.bits.no_of_stop_bits = 0;
		LCRFlushMask.bits.set_break = 0;
	}
		
	/*
	 * Set default state of all adapter registers
	 */
	asp->int_enable_reg.all = 0;

#ifdef NTVDM
        // Tell host side the state of the data available interrupt
    host_com_da_int_change(adapter,asp->int_enable_reg.bits.data_available,0);
#endif /* NTVDM */

	
	asp->int_id_reg.all = 0;
	asp->int_id_reg.bits.no_int_pending = 1;
	
	/* make sure a change occurs to 0 */
	asp->line_control_reg.all = ~0;
	
	/*
	 * set up modem control reg so next set_dtr etc.
	 * Will produce required status
	 */
	asp->modem_control_reg.all = 0;
	asp->modem_control_reg.bits.DTR = ON;
	asp->modem_control_reg.bits.RTS = ON;
	asp->modem_control_reg.bits.OUT1 = ON;
	asp->modem_control_reg.bits.OUT2 = ON;
	host_com_ioctl(adapter, HOST_COM_SDTR, 0);
	host_com_ioctl(adapter, HOST_COM_SRTS, 0);

	asp->line_status_reg.all = 0;
	asp->line_status_reg.bits.tx_holding_empty = 1;
	asp->line_status_reg.bits.tx_shift_empty = 1;
	
	asp->modem_status_reg.all = 0;
	MODEM_STATE_CHANGE();
	host_com_msr_callback (adapter, asp->modem_status_reg.all);
	
	/*
	 * Set up default state of our state variables
	 */
	asp->receiver_line_status_interrupt_state = OFF;
	asp->data_available_interrupt_state = OFF;
	asp->tx_holding_register_empty_interrupt_state = OFF;
	asp->modem_status_interrupt_state = OFF;
	asp->break_state = OFF;
	asp->loopback_state = OFF;
	asp->dtr_state = ON;
	asp->rts_state = ON;
	asp->out1_state = ON;
	asp->out2_state = ON;
#if defined(NTVDM) && defined(FIFO_ON)
    /* disable fifo */
    asp->fifo_control_reg.all = 0;
    asp->int_id_reg.bits.fifo_enabled = 0;
    asp->rx_fifo_write_counter = 0;
    asp->rx_fifo_read_counter = 0;
    asp->fifo_trigger_counter = 1;
    asp->fifo_timeout_interrupt_state = OFF;
#endif
		
	/*
	 * Reset adapter synchronisation
	 */
	com_critical_reset(adapter);

	/*
	 * Set Unix devices to default state
	 */
	set_baud_rate(adapter);
	set_line_control(adapter, 0);
	set_break(adapter);

	/* Must be called before set_dtr */
	set_loopback(adapter);
	set_dtr(adapter);
	set_rts(adapter);
	set_out1(adapter);
	set_out2(adapter);

#ifdef IRET_HOOKS
	/*
	 * Remove any existing hook call-back, and re-instate it afresh.
	 */

	Ica_enable_hooking(asp->hw_interrupt_priority, NULL, adapter);
	Ica_enable_hooking(asp->hw_interrupt_priority, com_hook_again, adapter);

	/*
	 * Clear the IRET status flags.
	 */

	asp->batch_running = FALSE;
	asp->qev_running = FALSE;
	asp->batch_size = 10;	/* sounds like a safe default ! */
#endif /* IRET_HOOKS */
}
#endif // NEC_98

#ifndef COM3_ADAPTOR
#define COM3_ADAPTOR 0
#endif
#ifndef COM4_ADAPTOR
#define COM4_ADAPTOR 0
#endif

#if defined(NEC_98)
static IU8 com_adaptor[4] = {COM1_ADAPTOR,COM2_ADAPTOR,COM3_ADAPTOR,0x00};
static io_addr port_start[4]  = {RS232_COM1_PORT_START,RS232_COM2_PORT_START,RS232_COM3_PORT_START,0x00};
static io_addr port_end[4]    = {RS232_COM1_PORT_END,RS232_COM2_PORT_END,RS232_COM3_PORT_END,0x00};
static int int_pri[4]     = {4,0,0,0};
static int timeout[4]     = {0,0,0,0};
#else // NEC_98
static IU8 com_adaptor[4] = {COM1_ADAPTOR,COM2_ADAPTOR,
                             COM3_ADAPTOR,COM4_ADAPTOR};
static io_addr port_start[4] = {RS232_COM1_PORT_START,
				RS232_COM2_PORT_START,
				RS232_COM3_PORT_START,
				RS232_COM4_PORT_START};
static io_addr port_end[4] = {RS232_COM1_PORT_END,
                          RS232_COM2_PORT_END,
                          RS232_COM3_PORT_END,
                          RS232_COM4_PORT_END};
static int int_pri[4] = {CPU_RS232_PRI_INT,
                         CPU_RS232_SEC_INT,
                         CPU_RS232_PRI_INT,
                         CPU_RS232_SEC_INT};
static int timeout[4] = {RS232_COM1_TIMEOUT,
                         RS232_COM2_TIMEOUT,
                         RS232_COM3_TIMEOUT,
                         RS232_COM4_TIMEOUT};
#endif // NEC_98


#if defined(NEC_98)
GLOBAL VOID com_init IFN1(int, adapter)
{

    host_com_lock(adapter);
    host_com_disable_open(adapter,TRUE);
        adapter_state[adapter].had_first_read = FALSE;

        /* Set up the IO chip select logic for this adaptor */
#ifdef NTVDM
    {
        extern BOOL VDMForWOW;
        extern void wow_com_outb(io_addr port, half_word value);
        extern void wow_com_inb(io_addr port, half_word *value);

            io_define_inb(com_adaptor[adapter],VDMForWOW ? wow_com_inb: com_inb);
            io_define_outb(com_adaptor[adapter],VDMForWOW ? wow_com_outb: com_outb);
        }
#else
        io_define_inb(com_adaptor[adapter], com_inb);
        io_define_outb(com_adaptor[adapter], com_outb);
#endif


// add 93.9.14 Bus-clock check!! -------------------------------------------
//      if ( Bus_Clock == 0 )
//          Bus_Clock = (int) ( ( *((unsigned char far *)(0x00000501)) & 0x80) == 0x80 ? 8 : 10 );
// add 93.9.14 end ---------------------------------------------------------
        switch (port_start[adapter])        // I/O trap & INT level set
        {
            case RS232_COM1_PORT_START:

                    io_connect_port((io_addr)0x30, com_adaptor[adapter], IO_READ_WRITE);
                    io_connect_port((io_addr)0x32, com_adaptor[adapter], IO_READ_WRITE);
#if 0
                    io_connect_port((io_addr)0x33, com_adaptor[adapter], IO_READ_WRITE);
                    io_connect_port((io_addr)0x35, com_adaptor[adapter], IO_READ_WRITE);
                    io_connect_port((io_addr)0x37, com_adaptor[adapter], IO_READ_WRITE);
#endif
                    adapter_state[adapter].hw_interrupt_priority = int_pri[adapter];
//                  PRINTDBGNEC98( NEC98DBG_init_msg,
//                                ("COMMS : COM1 Initialized.\n"));
            break;

            case RS232_COM2_PORT_START:
                int_pri[1] = find_rs232cex() ? CPU_RS232_SEC_INT : CPU_NO_DEVICE;
                if (int_pri[1] ==  CPU_NO_DEVICE ) {
                    host_com_disable_open(adapter,FALSE);
                    host_com_unlock(adapter);
                    return;
                }
                else {

//                  PRINTDBGNEC98( NEC98DBG_init_msg,
//                                ("COMMS : COM2 Read IRQ value = %d\n",(int)CmdLine[40]));
                    io_connect_port((io_addr)0xb0, com_adaptor[adapter], IO_READ_WRITE);
                    io_connect_port((io_addr)0xb1, com_adaptor[adapter], IO_READ_WRITE);
                    io_connect_port((io_addr)0xb3, com_adaptor[adapter], IO_READ_WRITE);

                    adapter_state[adapter].hw_interrupt_priority = int_pri[1];
//                    PRINTDBGNEC98( NEC98DBG_init_msg,
//                                  ("COMMS : COM2 Initialized.\n"));

                }
            break;
            case RS232_COM3_PORT_START:
                int_pri[2] = find_rs232cex() ? CPU_RS232_THIRD_INT : CPU_NO_DEVICE;
                if (int_pri[2] ==  CPU_NO_DEVICE ) {
                    host_com_disable_open(adapter,FALSE);
                    host_com_unlock(adapter);
                    return;
                }
                else {

//                  PRINTDBGNEC98( NEC98DBG_init_msg,
//                                ("COMMS : COM3 Read IRQ value = %d\n",(int)CmdLine[40]));
                    io_connect_port((io_addr)0xb2, com_adaptor[adapter], IO_READ_WRITE);
                    io_connect_port((io_addr)0xb9, com_adaptor[adapter], IO_READ_WRITE);
                    io_connect_port((io_addr)0xbb, com_adaptor[adapter], IO_READ_WRITE);

                    adapter_state[adapter].hw_interrupt_priority = int_pri[2];
//                  PRINTDBGNEC98( NEC98DBG_init_msg,
//                                ("COMMS : COM3 Initialized.\n"));

                }
            break;
        }

        /* reset adapter state */
        host_com_reset(adapter);

        /* reset adapter state */
        com_reset(adapter);

        host_com_disable_open(adapter,FALSE);
        host_com_unlock(adapter);
        return;
}
#else // NEC_98
GLOBAL VOID com_init IFN1(int, adapter)
{
	io_addr i;

#ifdef NTVDM
	host_com_lock(adapter);
	host_com_disable_open(adapter,TRUE);
#endif

	adapter_state[adapter].had_first_read = FALSE;
	
	/* Set up the IO chip select logic for this adaptor */
#ifdef NTVDM
    {
        extern BOOL VDMForWOW;
        extern void wow_com_outb(io_addr port, half_word value);
        extern void wow_com_inb(io_addr port, half_word *value);

            io_define_inb(com_adaptor[adapter],VDMForWOW ? wow_com_inb: com_inb);
            io_define_outb(com_adaptor[adapter],VDMForWOW ? wow_com_outb: com_outb);
        }
#else
	io_define_inb(com_adaptor[adapter], com_inb);
	io_define_outb(com_adaptor[adapter], com_outb);
#endif /* NTVDM */

	for(i = port_start[adapter]; i <= port_end[adapter]; i++)
		io_connect_port(i, com_adaptor[adapter], IO_READ_WRITE);


	adapter_state[adapter].hw_interrupt_priority = int_pri[adapter];

	/* reset adapter state */
	host_com_reset(adapter);

	/* reset adapter state */
	com_reset(adapter);

#ifndef NTVDM
	/* Should we enable TX pacing ? */
	tx_pacing_enabled = host_getenv("TX_PACING_ENABLED") ? TRUE : FALSE;
#else /* not NTVDM */
	host_com_disable_open(adapter,FALSE);
	host_com_unlock(adapter);
#endif

	return;
}
#endif // NEC_98

void com_post IFN1(int, adapter)
{
        /* Set up BIOS data area. */
	sas_storew( BIOS_VAR_START + (2*adapter), port_start[adapter]);
	sas_store(timeout[adapter] , (half_word)1 );
}

void com_close IFN1(int, adapter)
{
#ifdef NTVDM
	host_com_lock(adapter);
#endif

#ifndef PROD
	if (com_trace_fd)
		fclose (com_trace_fd);
	com_trace_fd = NULL;
#endif
	/* reset host specific communications channel */
	config_activate((UTINY)(C_COM1_NAME + adapter), FALSE);

#ifdef NTVDM
	host_com_unlock(adapter);
#endif
}

#ifdef NTVDM

/*********************************************************/
/* Com extentions - DAB (MS-project) */

#if defined(NEC_98)
GLOBAL void SyncBaseLineSettings(int adapter,DIVISOR_LATCH *divisor_latch,
                 LINE_CONTROL_REG *LCR_reg)
{
    register struct ADAPTER_STATE *asp = &adapter_state[adapter];

    //Setup baud rate control register
    asp->divisor_latch.all = (*divisor_latch).all;

    //Setup line control settings emuration.
    asp->mode_set_reg.bits.char_length   = (*LCR_reg).bits.word_length;
    asp->mode_set_reg.bits.parity_enable = (*LCR_reg).bits.parity_enabled;
    asp->mode_set_reg.bits.parity_even   = (*LCR_reg).bits.even_parity;
    /* Stop Bit emuration */
    //  +------+--------+-------+------+
    //  |AT STB|Char Len|StopBit|98 STB|
    //  +------+--------+-------+------+
    //  |   0  |  ----  |  1 bit|  01  |
    //  +------+--------+-------+------+
    //  |      |  5bit  |1.5 bit|  10  |
    //  |   1  +--------+-------+------+
    //  |      |6,7,8bit|  2 bit|  11  |
    //  +------+--------+-------+------+
    if ((*LCR_reg).bits.no_of_stop_bits == 0 )  /* STOP BIT = 1 ?       */
        asp->mode_set_reg.bits.stop_bit = 1;    /* Stop Bit = 1 SET     */
    else                                        /* Stop Bit is not 1    */
    {
        if ((*LCR_reg).bits.word_length == 0)   /* Char length = 5BIT ? */
            asp->mode_set_reg.bits.stop_bit = 2;/* Stop Bit = 1.5 SET   */
        else
            asp->mode_set_reg.bits.stop_bit = 3;/* Stop Bit = 2 Set     */
    }
}
#else // NEC_98
GLOBAL void SyncBaseLineSettings(int adapter,DIVISOR_LATCH *divisor_latch,
                 LINE_CONTROL_REG *LCR_reg)
{
    register struct ADAPTER_STATE *asp = &adapter_state[adapter];

    //Setup baud rate control register
    asp->divisor_latch.all = (*divisor_latch).all;

    //Setup line control settings
    asp->line_control_reg.bits.word_length = (*LCR_reg).bits.word_length;
    asp->line_control_reg.bits.no_of_stop_bits = (*LCR_reg).bits.no_of_stop_bits
;
    asp->line_control_reg.bits.parity_enabled = (*LCR_reg).bits.parity_enabled;
    asp->line_control_reg.bits.stick_parity = (*LCR_reg).bits.stick_parity;
    asp->line_control_reg.bits.even_parity = (*LCR_reg).bits.even_parity;
}
#endif // NEC_98

GLOBAL void setup_RTSDTR(int adapter)
{
    struct ADAPTER_STATE *asp = &adapter_state[adapter];

    host_com_ioctl(adapter,asp->dtr_state == ON ? HOST_COM_SDTR : HOST_COM_CDTR,
0);
    host_com_ioctl(adapter,asp->rts_state == ON ? HOST_COM_SRTS : HOST_COM_CRTS,
0);
}

GLOBAL int AdapterReadyForCharacter(int adapter)
{
    BOOL AdapterReady = FALSE;

    /*......................................... Are RX interrupts enabled */

#if defined(NEC_98)
    if(adapter_state[adapter].read_status_reg.bits.rx_ready == 0 &&
       adapter_state[adapter].RXR_enable_state == OFF)
#else // NEC_98
    if(adapter_state[adapter].line_status_reg.bits.data_ready == 0 &&
       adapter_state[adapter].data_available_interrupt_state == OFF)
#endif // NEC_98
    {
        AdapterReady = TRUE;
    }

    return(AdapterReady);
}

// This function returns the ICA controller and line used to generate
// interrupts on a adapter. This information is used to register a EOI
// hook.


GLOBAL void com_int_data(int adapter,int *controller, int *line)
{
    struct ADAPTER_STATE *asp = &adapter_state[adapter];

    *controller = 0;                            // Controller ints raised on
    *line = (int) asp->hw_interrupt_priority;   // Line ints raised on
}

#endif /* NTVDM */

#ifdef PS_FLUSHING
/*(
=========================== com_psflush_change ================================
PURPOSE:
	Handle change of PostScript flush configuration option for a serial
	port.
INPUT:
	hostID - Configuration item I.D.
	apply - TRUE if change to be applied
OUTPUT:
	None
ALGORITHM:
	If PostScript flushing is being enabled then;
		set the PostScript flush enable flag for the port;
		disable autoflush for the port;
	else;
		reset the PostScript flush enable flag for the port;
		enable autoflush for the port;
===============================================================================
)*/

GLOBAL void com_psflush_change IFN2(
    IU8, hostID,
    IBOOL, apply
) {
    IS32 adapter = hostID - C_COM1_PSFLUSH;

    assert1(adapter < NUM_SERIAL_PORTS,"Bad hostID %d",hostID);

    if ( apply )
        if ( psFlushEnabled[adapter] = (IBOOL)config_inquire(hostID,NULL) )
            host_com_disable_autoflush(adapter);
        else
            host_com_enable_autoflush(adapter);
}
#endif	/* PS_FLUSHING */



/********************************************************/
/* Com debugging shell - Ade Brownlow / Ian Wellock
 * NB: This stuff only works for COM1. It is called from yoda using 'cd'
 * - comdebug - from the yoda command line....
 */
#ifndef PROD
#define   YODA_LOOP       2
#define   RX_BYTE         1
#define   TX_BYTE         2
int       srxcount = 0, stxcount = 0;
int       com_save_rx = 0, com_save_tx = 0;
unsigned  char *rxtx_buff = NULL;

int       com_debug_help ();
void      psaved();

#if defined(NEC_98)
static char *port_debugs[] =
{
        "txrx","cmd","mode", "mask", "stat","sig", "tim"
};
#else // NEC_98
static char *port_debugs[] =
{
	"txrx","ier","iir", "lcr", "mcr","lsr", "msr"
};
#endif // NEC_98

static int do_inbs = 0; /* start with inb reporting OFF */

#if defined(NEC_98)
static unsigned char *locate_register ()
{
        int i;
        char ref[10],str[100];
        struct ADAPTER_STATE *asp = &adapter_state[COM1];

        printf ("COM.. reg? ");
        nt_gets(str);
        sscanf(str,"%s", ref);
        for (i=0; i<7; i++)
        {
                if (!strcmp (ref, port_debugs[i]))
                {
                        switch (i)
                        {
                                case 0:
                                        return (&asp->tx_buffer);
                                case 1:
                                        return (&(asp->command_write_reg.all));
                                case 2:
                                        return (&(asp->mode_set_reg.all));
                                case 3:
                                        return (&(asp->int_mask_reg.all));
                                case 4:
                                        return (&(asp->read_status_reg.all));
                                case 5:
                                        return (&(asp->read_signal_reg.all));
                                case 6:
                                        return (&(asp->timer_mode_set_reg.all));
                                default:
                                        return (NULL);
                        }
                }
        }
        return (NULL);
}
#else // NEC_98
static unsigned char *locate_register ()
{
	int i;
	char ref[10];
	struct ADAPTER_STATE *asp = &adapter_state[COM1];

	printf ("COM.. reg? ");
	scanf ("%s", ref);
	for (i=0; i<7; i++)
	{
		if (!strcmp (ref, port_debugs[i]))
		{
			switch (i)
			{	
				case 0:
					return (&asp->tx_buffer);
				case 1:
					return (&(asp->int_enable_reg.all));
				case 2:
					return (&(asp->int_id_reg.all));
				case 3:
					return (&(asp->line_control_reg.all));
				case 4:
					return (&(asp->modem_control_reg.all));
				case 5:
					return (&(asp->line_status_reg.all));
				case 6:
					return (&(asp->modem_status_reg.all));
				default:
					return (NULL);
			}
		}
	}
	return (NULL);
}
#endif // NEC_98

int com_debug_stat ()
{
	printf ("DEBUG STATUS...\n");
	printf ("INB mismatch reporting .... %s\n", do_inbs ? "ON" : "OFF");
	printf ("INB/OUTB tracing .......... %s\n", com_trace_fd ? "ON" : "OFF");
	return (0);
}

#if defined(NEC_98)
int com_reg_dump ()
{
        /* dump com1 emulations registers */
        struct ADAPTER_STATE *asp = &adapter_state[COM1];

        printf("Data available interrupt state %s\n",
               asp->RXR_enable_state == ON ? "ON" : "OFF");

        printf ("TX %2x RX %2x CMD %2x MODE %2x MASK %2x STATUS %2x SIGNAL %2x TIMER %2x \n",
                (asp->tx_buffer), (asp->rx_buffer), (asp->command_write_reg.all),
                (asp->mode_set_reg.all), (asp->int_mask_reg.all),
                (asp->read_status_reg.all), (asp->read_signal_reg.all),
                (asp->timer_mode_set_reg.all));

        printf (" break_state           %d\n dtr_state          %d\n rts_state          %d\n"
                " RXR_enable_state        %d\n TXR_enable_state      %d\n hw_interrupt_priority      %d\n"
                " TX_delay       %d\n Had first read     %d\n",
                asp->break_state, asp->dtr_state, asp->rts_state,
                asp->RXR_enable_state, asp->TXR_enable_state,
                asp->hw_interrupt_priority, TX_delay[asp->com_baud_ind], asp->had_first_read);

        return (0);
}
#else // NEC_98
int com_reg_dump ()
{
	/* dump com1 emulations registers */
	struct ADAPTER_STATE *asp = &adapter_state[COM1];

	printf ("TX %2x RX %2x IER %2x IIR %2x LCR %2x MCR %2x LSR %2x MSR %2x \n",
		(asp->tx_buffer), (asp->rx_buffer), (asp->int_enable_reg.all),
		(asp->int_id_reg.all), (asp->line_control_reg.all),
		(asp->modem_control_reg.all), (asp->line_status_reg.all),
		(asp->modem_status_reg.all));
	printf (" break_state		%d\n loopback_state		%d\n",
	        asp->break_state, asp->loopback_state);
	printf(" dtr_state		%d\n rts_state		%d\n",
	        asp->dtr_state, asp->rts_state);
	printf(" out1_state		%d\n out2_state		%d\n",
	        asp->out1_state, asp->out2_state);
	printf(" receiver_line_status_interrupt_state		%d\n",
	        asp->receiver_line_status_interrupt_state);
	printf(" data_available_interrupt_state		%d\n",
	       asp->data_available_interrupt_state);
	printf(" tx_holding_register_empty_interrupt_state		%d\n",
	        asp->tx_holding_register_empty_interrupt_state);
	printf(" modem_status_interrupt_state		%d\n",
	        asp->modem_status_interrupt_state);
	printf(" hw_interrupt_priority		%d\n",
	        asp->hw_interrupt_priority);
	printf(" com_baud_delay		%d\n had_first_read		%d\n",
	        TX_delay[asp->com_baud_ind], asp->had_first_read);
	return (0);
}
#endif // NEC_98

int com_s_reg ()
{
	unsigned char *creg;
	int val1;

	if (creg = locate_register())
	{
		printf ("SET to > ");
		scanf ("%x", &val1);

		*creg = (unsigned char)val1;
	}
	else
		printf ("Unknown reg\n");
	return (0);
}

int com_p_reg ()
{
	unsigned char *creg;

	if (creg = locate_register())
		printf ("%x\n", *creg);
	else
		printf ("Unknown reg\n");
	return (0);
}

io_addr conv_com_reg (com_reg)
char *com_reg;
{
	io_addr loop;

	for (loop = 0; loop < 7; loop++)
		if (!strcmp (port_debugs[loop], com_reg))
			return (loop+(io_addr)RS232_COM1_PORT_START);
	return (0);
}

int com_do_inb ()
{
	char com_reg[10];
	half_word val;
	io_addr port;

	printf ("Port > ");
	scanf ("%s", com_reg);
	if (!(port = conv_com_reg (com_reg)))
	{
		printf ("funny port %s\n", com_reg);
		return (0);
	}
	com_inb (port, &val);
	printf ("%s = %x\n", val);
	return (0);
}

int com_do_outb ()
{
	char com_reg[10];
	half_word val;
	io_addr port;

	printf ("Port > ");
	scanf ("%s", com_reg);
	if (!(port = conv_com_reg (com_reg)))
	{
		printf ("funny port %s\n", com_reg);
		return (0);
	}
	printf ("Value >> ");
	scanf ("%x", &val);
	com_outb (port, val);
	return (0);
}

int com_run_file ()
{
	char filename[100], com_reg[10], dir;
	int val, line;
	half_word spare_val;
	io_addr port;
	FILE *fd = NULL;

	printf ("FILE > ");
	scanf ("%s", filename);
	if (!(fd = fopen (filename, "r")))
	{
		printf ("Cannot open %s\n", filename);
		return (0);
	}
	line = 1;

	/* dump file is of format : %c-%x-%s
	 * 1 char I or O denotes inb or outb
	 * -
	 * Hex value the value expected in case of inb or value to write in
	 * case of outb.
	 * -
	 * string representing the register port to use..
	 *
	 * A typical entry would be
	 *	O-txrx-60 - which translates to outb(START_OF_COM1+txrx, 0x60);
	 *
	 * Files for this feature can be generated using the comdebug 'open' command.
	 */
	while (fscanf (fd, "%c-%x-%s", &dir, &val, com_reg) != EOF)
	{
		if (!(port = conv_com_reg (com_reg)))
		{
			printf ("funny port %s at line %d\n", com_reg, line);
			break;
		}
		switch (dir)
		{
			case 'I':
				/* inb */
				com_inb (port, &spare_val);
				if (spare_val != val && do_inbs)
				{
					printf ("INB no match at line %d %c-%s-%x val= %x\n",
						line, dir, com_reg, val, spare_val);
				}
				break;
			case 'O':
				/* outb */
				/* convert com_register to COM1 address com_register */
				com_outb (port, (IU8)val);
				printf ("outb (%s, %x)\n", com_reg, val);
				break;
			default:
				
				break;
		}
		line ++;
	}
	fclose (fd);
	return (0);
}
	
int com_debug_quit ()
{
	printf ("Returning to YODA\n");
	return (1);
}

int com_o_debug_file ()
{
	char filename[100];
	printf ("FILE > ");
	scanf ("%s", filename);
	if (!(com_trace_fd = fopen (filename, "w")))
	{
		printf ("Cannot open %s\n", filename);
		return (0);
	}
	printf ("Com debug file = '%s'\n", filename);
	return (0);
}

int com_c_debug_file ()
{
	if (com_trace_fd)
		fclose (com_trace_fd);
	com_trace_fd = NULL;
	return (0);
}

int com_forget_inb ()
{
	do_inbs = 1- do_inbs;
	if (do_inbs)
		printf ("INB mismatch reporting ON\n");
	else
		printf ("INB mismatch reporting OFF\n");
	return (0);
}

int com_s_rx()
{
	srxcount = stxcount = 0;
	com_save_rx = 1 - com_save_rx;
	printf("Save and Dump Received Bytes ");
	if (com_save_rx)
		printf("ON\n");
	else
		printf("OFF\n");
	return(0);
}

int com_s_tx()
{
	srxcount = stxcount = 0;
	com_save_tx = 1 - com_save_tx;
	printf("Save and Dump Transmitted Bytes ");
	if (com_save_tx)
		printf("ON\n");
	else
		printf("OFF\n");
	return(0);
}

int com_p_rx()
{
	printf("There are %d received bytes, out of %d bytes saved.\n",
	       srxcount, srxcount + stxcount);
	psaved(RX_BYTE, stdout);
	return(0);
}

int com_p_tx()
{
	printf("There are %d transmitted bytes, out of %d bytes saved.\n",
	       stxcount, srxcount + stxcount);
	psaved(TX_BYTE, stdout);
	return(0);
}

int com_p_all()
{
	printf("There are %d bytes saved.\n", srxcount + stxcount);
	psaved(RX_BYTE + TX_BYTE, stdout);
	return(0);
}

int com_d_all()
{
	int cl_fin = 0;

	if (!com_trace_fd)
	{
		com_o_debug_file();
		cl_fin = 1;
	}

	fprintf(com_trace_fd, "There are %d bytes saved.\n", srxcount + stxcount);
	psaved(RX_BYTE + TX_BYTE, com_trace_fd);

	if (cl_fin)
		com_c_debug_file();
	return(0);
}

void psaved(typ, fd)

int typ;
FILE *fd;
{
	int c, nc = 0;

	for (c = 0; c < srxcount + stxcount; c++)
	{
		if (rxtx_buff[c * 2] & typ)
		{
			if (typ == RX_BYTE + TX_BYTE)
				if (rxtx_buff[c * 2] & RX_BYTE)
			  		fprintf(fd, "R ");
				  else
				  	fprintf(fd, "T ");
			fprintf(fd, "%2x  ",rxtx_buff[c * 2 + 1]);
			nc++;
			if ((nc % 16) == 0)
				fprintf(fd, "\n");
		}
	}
	fprintf(fd, "\nAll bytes dumped.\n");
}

void com_save_rxbytes IFN2(int, n, CHAR *, buf)
{
	int tc, bs;

	if (com_save_rx)
	{
		bs = srxcount + stxcount;
		for (tc = 0; tc < n; tc++)
		{
			rxtx_buff[(tc + bs) * 2] = RX_BYTE;
			rxtx_buff[(tc + bs) * 2 + 1] = buf[tc];
		}
		srxcount += n;
	}
}

void com_save_txbyte IFN1(CHAR, value)
{
	if (com_save_tx)
	{
		rxtx_buff[(srxcount + stxcount) * 2] = TX_BYTE;
		rxtx_buff[(srxcount + stxcount) * 2 + 1] = value;
		stxcount++;
	}
}

static struct
{
	char *name;
	int (*fn)();
	char *comment;
} comtab[]=
{
	{"q",      com_debug_quit,   "	QUIT comdebug return to YODA"},
	{"h",      com_debug_help,   "	Print this message"},
	{"stat",   com_debug_stat,   "	Print status of comdebug"},
	{"s",      com_s_reg,        "	Set the specified register"},
	{"p",      com_p_reg,        "	Print specified register"},
	{"dump",   com_reg_dump,     "	Print all registers"},
	{"open",   com_o_debug_file, "	Open a debug file"},
	{"close",  com_c_debug_file, "	Close current debug file"},
	{"runf",   com_run_file,     "	'Run' a trace file"},
	{"toginb", com_forget_inb,   "	Toggle INB mismatch reporting"},
	{"inb",    com_do_inb,       "	Perform INB on port"},
	{"outb",   com_do_outb,      "	Perform OUTB on port"},
	{"srx",    com_s_rx,         "	Save all received bytes"},
	{"stx",    com_s_tx,         "	Save all transmitted bytes"},
	{"prx",    com_p_rx,         "	Print all received bytes"},
	{"ptx",    com_p_tx,         "	Print all transmitted bytes"},
	{"pall",   com_p_all,        "	Print all received/transmitted bytes"},
	{"dall",   com_d_all,        "	Dump all received/transmitted bytes"},
	{"", NULL, ""}
};

int com_debug_help ()
{
	int i;
	printf ("COMDEBUG COMMANDS\n");
	for (i=0; comtab[i].name[0]; i++)
		printf ("%s\t%s\n", comtab[i].name, comtab[i].comment);
	printf ("recognised registers :\n");
	for (i=0; i<7; i++)
		printf ("%s\n", port_debugs[i]);
	return (0);
}

int com_debug()
{
	char com[100];
	int i;

	if (rxtx_buff == NULL)
		check_malloc(rxtx_buff, 50000, unsigned char);

	printf ("COM1 debugging stuff...\n");
	while (TRUE)
	{
		printf ("COM> ");
		scanf ("%s", com);
		for (i=0; comtab[i].name[0]; i++)
		{	
			if (!strcmp (comtab[i].name, com))
			{
				if ((*comtab[i].fn) ())
					return(YODA_LOOP);
				break;
			}
		}
		if (comtab[i].name[0])
			continue;
		printf ("Unknown command %s\n", com);
	}
}
#endif /* !PROD */
/********************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cpu\src\evid\vglob.c ===
/*[
*************************************************************************

	Name:		Vglob.c
	Author:		Simon Frost
	Created:	October 1994
	Derived from:	Vglob.edl
	Sccs ID:	@(#)Vglob.c	1.1 10/24/94
	Purpose:	EXTERNAL interface to VGLOB record.
			Rewritten in C to save overhead of EDL/C context change
			for one memory read/write.

	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.

*************************************************************************
]*/

#include "insignia.h"
#include "host_def.h"
#include "Evid_c.h"
#include "gdpvar.h"

/*
 * Note: no interfaces produced for the following 3.0 VGlob entries as
 * unused in Evid.
 *      copy_func_pbp	( now video_base_lin_addr )
 *      route_reg1
 *      route_reg2
 */

/* {get,set}Videolatches still in EvPtrs.edl as required for pigging */

GLOBAL void
setVideorplane IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.VGA_rplane = value;
}
GLOBAL IU8 *
getVideorplane IFN0()
{
	return(GLOBAL_VGAGlobals.VGA_rplane);
}

GLOBAL void
setVideowplane IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.VGA_wplane = value;
}
GLOBAL IU8 *
getVideowplane IFN0()
{
	return(GLOBAL_VGAGlobals.VGA_wplane);
}

GLOBAL void
setVideoscratch IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.scratch = value;
}
GLOBAL IU8 *
getVideoscratch IFN0()
{
	return(GLOBAL_VGAGlobals.scratch);
}

GLOBAL void
setVideosr_masked_val IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.sr_masked_val = value;
}
GLOBAL IU32
getVideosr_masked_val IFN0()
{
	return(GLOBAL_VGAGlobals.sr_masked_val);
}

GLOBAL void
setVideosr_nmask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.sr_nmask = value;
}

GLOBAL IU32
getVideosr_nmask IFN0()
{
	return(GLOBAL_VGAGlobals.sr_nmask);
}

GLOBAL void
setVideodata_and_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.data_and_mask = value;
}

GLOBAL IU32
getVideodata_and_mask IFN0()
{
	return(GLOBAL_VGAGlobals.data_and_mask);
}

GLOBAL void
setVideodata_xor_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.data_xor_mask = value;
}
GLOBAL IU32
getVideodata_xor_mask IFN0()
{
	return(GLOBAL_VGAGlobals.data_xor_mask);
}

GLOBAL void
setVideolatch_xor_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.latch_xor_mask = value;
}
GLOBAL IU32
getVideolatch_xor_mask IFN0()
{
	return(GLOBAL_VGAGlobals.latch_xor_mask);
}

GLOBAL void
setVideobit_prot_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.bit_prot_mask = value;
}
GLOBAL IU32
getVideobit_prot_mask IFN0()
{
	return(GLOBAL_VGAGlobals.bit_prot_mask);
}

GLOBAL void
setVideoplane_enable IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.plane_enable = value;
}
GLOBAL IU32
getVideoplane_enable IFN0()
{
	return(GLOBAL_VGAGlobals.plane_enable);
}

GLOBAL void
setVideoplane_enable_mask IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.plane_enable_mask = value;
}
GLOBAL IU32
getVideoplane_enable_mask IFN0()
{
	return(GLOBAL_VGAGlobals.plane_enable_mask);
}

GLOBAL void
setVideosr_lookup IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.sr_lookup = value;
}
GLOBAL IUH *
getVideosr_lookup IFN0()
{
	return(GLOBAL_VGAGlobals.sr_lookup);
}

GLOBAL void
setVideofwd_str_read_addr IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.fwd_str_read_addr = value;
}
GLOBAL IUH *
getVideofwd_str_read_addr IFN0()
{
	return(GLOBAL_VGAGlobals.fwd_str_read_addr);
}

GLOBAL void
setVideobwd_str_read_addr IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.bwd_str_read_addr = value;
}
GLOBAL IUH *
getVideobwd_str_read_addr IFN0()
{
	return(GLOBAL_VGAGlobals.bwd_str_read_addr);
}

GLOBAL void
setVideodirty_total IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.dirty_total = value;
}
GLOBAL IU32
getVideodirty_total IFN0()
{
	return(GLOBAL_VGAGlobals.dirty_total);
}

GLOBAL void
setVideodirty_low IFN1(IS32, value)
{
	GLOBAL_VGAGlobals.dirty_low = value;
}
GLOBAL IS32
getVideodirty_low IFN0()
{
	return(GLOBAL_VGAGlobals.dirty_low);
}

GLOBAL void
setVideodirty_high IFN1(IS32, value)
{
	GLOBAL_VGAGlobals.dirty_high = value;
}
GLOBAL IS32
getVideodirty_high IFN0()
{
	return(GLOBAL_VGAGlobals.dirty_high);
}

GLOBAL void
setVideovideo_copy IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.video_copy = value;
}
GLOBAL IU8 *
getVideovideo_copy IFN0()
{
	return(GLOBAL_VGAGlobals.video_copy);
}

GLOBAL void
setVideomark_byte IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.mark_byte = value;
}
GLOBAL IUH *
getVideomark_byte IFN0()
{
	return(GLOBAL_VGAGlobals.mark_byte);
}

GLOBAL void
setVideomark_word IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.mark_word = value;
}
GLOBAL IUH *
getVideomark_word IFN0()
{
	return(GLOBAL_VGAGlobals.mark_word);
}

GLOBAL void
setVideomark_string IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.mark_string = value;
}
GLOBAL IUH *
getVideomark_string IFN0()
{
	return(GLOBAL_VGAGlobals.mark_string);
}

GLOBAL void
setVideoread_shift_count IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.read_shift_count = value;
}
GLOBAL IU32
getVideoread_shift_count IFN0()
{
	return(GLOBAL_VGAGlobals.read_shift_count);
}

GLOBAL void
setVideoread_mapped_plane IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.read_mapped_plane = value;
}
GLOBAL IU32
getVideoread_mapped_plane IFN0()
{
	return(GLOBAL_VGAGlobals.read_mapped_plane);
}

GLOBAL void
setVideocolour_comp IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.colour_comp = value;
}
GLOBAL IU32
getVideocolour_comp IFN0()
{
	return(GLOBAL_VGAGlobals.colour_comp);
}

GLOBAL void
setVideodont_care IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.dont_care = value;
}
GLOBAL IU32
getVideodont_care IFN0()
{
	return(GLOBAL_VGAGlobals.dont_care);
}

GLOBAL void
setVideov7_bank_vid_copy_off IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.v7_bank_vid_copy_off = value;
}
GLOBAL IU32
getVideov7_bank_vid_copy_off IFN0()
{
	return(GLOBAL_VGAGlobals.v7_bank_vid_copy_off);
}

GLOBAL void
setVideoscreen_ptr IFN1(IU8 *, value)
{
	GLOBAL_VGAGlobals.screen_ptr = value;
}
GLOBAL IU8 *
getVideoscreen_ptr IFN0()
{
	return(GLOBAL_VGAGlobals.screen_ptr);
}

GLOBAL void
setVideorotate IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.rotate = value;
}
GLOBAL IU32
getVideorotate IFN0()
{
	return(GLOBAL_VGAGlobals.rotate);
}

GLOBAL void
setVideocalc_data_xor IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.calc_data_xor = value;
}
GLOBAL IU32
getVideocalc_data_xor IFN0()
{
	return(GLOBAL_VGAGlobals.calc_data_xor);
}

GLOBAL void
setVideocalc_latch_xor IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.calc_latch_xor = value;
}
GLOBAL IU32
getVideocalc_latch_xor IFN0()
{
	return(GLOBAL_VGAGlobals.calc_latch_xor);
}

GLOBAL void
setVideoread_byte_addr IFN1(IUH *, value)
{
	GLOBAL_VGAGlobals.read_byte_addr = value;
}
GLOBAL IUH *
getVideoread_byte_addr IFN0()
{
	return(GLOBAL_VGAGlobals.read_byte_addr);
}

GLOBAL void
setVideov7_fg_latches IFN1(IU32, value)
{
	GLOBAL_VGAGlobals.v7_fg_latches = value;
}
GLOBAL IU32
getVideov7_fg_latches IFN0()
{
	return(GLOBAL_VGAGlobals.v7_fg_latches);
}

GLOBAL void
setVideoGC_regs IFN1(IUH **, value)
{
	GLOBAL_VGAGlobals.GCRegs = value;
}
GLOBAL IUH **
getVideoGC_regs IFN0()
{
	return(GLOBAL_VGAGlobals.GCRegs);
}

GLOBAL void
setVideolast_GC_index IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.lastGCindex = value;
}
GLOBAL IU8
getVideolast_GC_index IFN0()
{
	return(GLOBAL_VGAGlobals.lastGCindex);
}

GLOBAL void
setVideodither IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.dither = value;
}
GLOBAL IU8
getVideodither IFN0()
{
	return(GLOBAL_VGAGlobals.dither);
}

GLOBAL void
setVideowrmode IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.wrmode = value;
}
GLOBAL IU8
getVideowrmode IFN0()
{
	return(GLOBAL_VGAGlobals.wrmode);
}

GLOBAL void
setVideochain IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.chain = value;
}
GLOBAL IU8
getVideochain IFN0()
{
	return(GLOBAL_VGAGlobals.chain);
}

GLOBAL void
setVideowrstate IFN1(IU8, value)
{
	GLOBAL_VGAGlobals.wrstate = value;
}
GLOBAL IU8
getVideowrstate IFN0()
{
	return(GLOBAL_VGAGlobals.wrstate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\comms\printer.c ===
#include "insignia.h"
#include "host_def.h"
#ifdef PRINTER

/*
 * VPC-XT Revision 1.0
 *
 * Title:	Parallel Printer Port Emulation
 *
 * Description:	Emulates the IBM || Printer card as used in the original
 *		IBM XT, which is itself a H/W emulation of an Intel 8255.
 *
 * Author:	Henry Nash
 *
 * Notes:	None
 *
 * Mods:
 *		<chrisP 11Sep91>
 *		Allow transition to NOTBUSY in the OUTA state as well as the READY
 *		state.  i.e. at the leading edge of the ACK pulse after just one
 *		INB (STATUS) rather than two.  Our printer port emulation relies on
 *		these INB's to toggle the ACK line and set NOTBUSY true again.  So
 *		the port could be left in the BUSY condition at the end of an app's
 *		print job (which can confuse the next print request).  NOTE we could
 *		still have a problem if the PC app bypasses the BIOS and is too lazy
 *		to do even one INB(STATUS) after the last print byte.
 */



/* for NTVDM port -- williamh
 * There are such things called Dongles which many software companies have
 * used for copy protection. Each software comes with its dedicated Dongle
 * that records necessary indentification inforamtion. It is required
 * to plug the device onto the parallel port in order to run the software
 * correctly. The device has an outlet which can be connectted to parallel
 * port printer so the the user doesn't sacrifice his parallel port when
 * the device in plugged on the original connector.
 * There are several Dongle vendors and each one of them provides their
 * propietary library or driver for the applications to link to. These
 * drivers know how to read/WRITE the Dongle to verify a legitmate copy.
 * Since it has to maintain compatiblility with standard PC parallel port,
 * the devices are designed in a way that it can be programmed without
 * disturbing ordinary parallel port operation. To do this, it usually does
 * this:
 * (1) Turn off strobe.
 * (2) output data pattern to data port
 * (3) delay a little bit(looping in instructions) and then go to (2)
 *     until the chunk of data has been sent. NOTE THAT THE STROBE LINE
 *     IS NEVER "strobe"
 * (4). Read status port and by interpreting the line differently,
 *     the driver decodes any id information it is looking for.
 *
 * In order to support these devices, we have to do these:
 * (1). We can not fake printer status. We have to get the real
 *	status line states.
 * (2). we have to output data to the printer without waiting the data
 *	to be qualified(strobing).
 * (3). We must be smart enough to detect the application is done with
 *	its Dongle things and wants everything goes back to normal.
 *	We must adjust ourselves under this circumestances.
 * (4). Down level printer driver must provide function that we can call
 *	to control the port directly.
 * (5). Printer h/w interrupt is not allowed to be enabled under this
 *	circumstance --and how can we make sure of that?????
 *
 */

#ifdef SCCSID
static char SccsID[] = "@(#)printer.c	1.19 11/14/94 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_PRINTER.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#include TimeH
#ifdef SYSTEMV
#ifdef STINGER
#include <sys/termio.h>
#endif
#endif

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "printer.h"
#include "error.h"
#include "config.h"
#include "host_lpt.h"
#include "ica.h"
#include "quick_ev.h"

#include "debug.h"
#ifndef PROD
#include "trace.h"
#endif


/*
 * ============================================================================
 * Global data
 * ============================================================================
 */


/*
 * ============================================================================
 * Static data and defines
 * ============================================================================
 */

#ifndef NEC_98
#define PRINTER_BIT_MASK	0x3	/* bits decoded from address bus */
#define CONTROL_REG_MASK	0xE0;	/* unused bits drift to HIGH */
#define STATUS_REG_MASK		0x07;	/* unused bits drift to HIGH */
#endif // !NEC_98

#define DATA_OFFSET	0		/* ouput register */
#define STATUS_OFFSET	1		/* status register */
#define CONTROL_OFFSET	2		/* control register */

#ifdef	ERROR
#undef	ERROR
#endif

#if defined(NEC_98)
static half_word output_reg;
static half_word control_reg;
#define NOTBUSY         (IU8)0x04

static half_word status_reg;
#define IR8             (IU8)0x08
#define NOTPSTB         (IU8)0x80

BOOL is_busy = TRUE;
BOOL busy_flag = FALSE;
int busy_count = 0;
#define NEC98_BUSY 10
#define NEC98_BUSY_COUNT 1

BOOL    pstb_mask;
#define PSTBM           0x40
static int state;                       /* state control variable NEC98 */

static sys_addr timeout_address = BIOS_NEC98_PR_TIME;
static q_ev_handle handle_for_out_event;
static q_ev_handle handle_for_outa_event;

#else  // !NEC_98
static half_word output_reg[NUM_PARALLEL_PORTS];
static half_word control_reg[NUM_PARALLEL_PORTS];
#define NOTBUSY		(IU8)0x80
#define ACK		(IU8)0x40
#define PEND		(IU8)0x20
#define SELECT		(IU8)0x10
#define ERROR		(IU8)0x08

static half_word status_reg[NUM_PARALLEL_PORTS];
#define IRQ		(IU8)0x10
#define SELECT_IN	(IU8)0x08
#define INIT_P		(IU8)0x04
#define AUTO_FEED	(IU8)0x02
#define STROBE		(IU8)0x01

LOCAL IU8 retryErrorCount = 0;   /* num status inb before clearing ERROR */

static IU8 state[NUM_PARALLEL_PORTS]; /* state control variable */
/*
 * set up arrays of all port addresses
 */
static io_addr port_start[] = {LPT1_PORT_START,LPT2_PORT_START,LPT3_PORT_START};
static io_addr port_end[] = {LPT1_PORT_END, LPT2_PORT_END, LPT3_PORT_END};
static int port_no[] = {LPT1_PORT_START & LPT_MASK, LPT2_PORT_START & LPT_MASK,
			LPT3_PORT_START & LPT_MASK };
static half_word lpt_adapter[] = {LPT1_ADAPTER, LPT2_ADAPTER, LPT3_ADAPTER};
static sys_addr port_address[] = {LPT1_PORT_ADDRESS, LPT2_PORT_ADDRESS, LPT3_PORT_ADDRESS};
static sys_addr timeout_address[] = {LPT1_TIMEOUT_ADDRESS, LPT2_TIMEOUT_ADDRESS, LPT3_TIMEOUT_ADDRESS};
static q_ev_handle handle_for_out_event[NUM_PARALLEL_PORTS];
static q_ev_handle handle_for_outa_event[NUM_PARALLEL_PORTS];
#endif // !NEC_98

#ifndef NEC_98
#if defined(NTVDM) && defined(MONITOR)
/* sudeepb 24-Jan-1993 for printing performance for x86 */
sys_addr lp16BitPrtBuf;
sys_addr lp16BitPrtId;
sys_addr lp16BitPrtCount;
sys_addr lp16BitPrtBusy;
#endif
#endif // !NEC_98

#define STATE_READY     0
#define STATE_OUT       1
#define STATE_OUTA      2
#if defined(NTVDM)
#define STATE_DATA	3
#define STATE_DONGLE	4
#endif

/*
 * State transitions:
 *
 *	    +->	 STATE_READY
 *	    |	  |
 *          |     | ........ write char to output_reg, print on low-high strobe
 *	    |	  V          set NOTBUSY to false
 *	    |	 STATE_OUT
 *	    |	  |
 *	    |	  | ........ (read status) set ACK low
 *	    |	  V
 *	    |	 STATE_OUTA
 *	    |	  |
 *	    |	  | ........ (read status) set ACK high
 *	    +-----+
 *
 *	Caveat: if the control register interrupt request bit is set,
 *	we assume that the application isn't interested in getting the
 *	ACKs and just wants to know when the printer state changes back
 *	to NOTBUSY. I'm not sure to want extent you can get away with
 *	this: however, applications using the BIOS printer services
 *	should be OK.
 */

#ifdef PS_FLUSHING
LOCAL IBOOL psFlushEnabled[NUM_PARALLEL_PORTS];	/* TRUE if PostScript flushing
						is enabled */
#endif	/* PS_FLUSHING */


/*
 * ============================================================================
 * Internal functions & macros
 * ============================================================================
 */

#define set_low(val, bit)		val &= ~bit
#define set_high(val, bit)		val |=  bit
#define low_high(val1, val2, bit)	(!(val1 & bit) && (val2 & bit))
#define high_low(val1, val2, bit)	((val1 & bit) && !(val2 & bit))
#define toggled(val1, val2, bit)	((val1 & bit) != (val2 & bit))
#define negate(val, bit)		val ^= bit

/*
 * Defines and variables to handle tables stored in 16-bit code for NT
 * monitors.
 */
#if defined(NEC_98)
void printer_inb IPT2(io_addr, port, half_word *, value);
void printer_outb IPT2(io_addr, port, half_word, value);
void notbusy_check IPT0();
#else  // !NEC_98
#if defined(NTVDM) && defined(MONITOR)

static BOOL intel_setup = FALSE;

static sys_addr status_addr;
static sys_addr control_addr;
static sys_addr state_addr;

#define get_status(adap)	(sas_hw_at_no_check(status_addr+(adap)))
#define set_status(adap,val)	(sas_store_no_check(status_addr+(adap),(val)))

#define get_control(adap)	(sas_hw_at_no_check(control_addr+(adap)))
#define set_control(adap,val)	(sas_store_no_check(control_addr+(adap),(val)))

#define get_state(adap)		(sas_hw_at_no_check(state_addr+(adap)))
#define set_state(adap,val)	(sas_store_no_check(state_addr+(adap),(val)))

#else /* NTVDM && MONITOR */

#define get_status(adap)	(status_reg[adapter])
#define set_status(adap,val)	(status_reg[adapter] = (val))

#define get_control(adap)	(control_reg[adapter])
#define set_control(adap,val)	(control_reg[adapter] = (val))

#define get_state(adap)		(state[adapter])
#define set_state(adap,val)	(state[adapter] = (val))

#endif /* NTVDM && MONITOR */

static void printer_inb IPT2(io_addr, port, half_word *, value);
static void printer_outb IPT2(io_addr, port, half_word, value);
static void notbusy_check IPT1(int,adapter);
#endif // !NEC_98

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

void printer_post IFN1(int,adapter)
{
#if defined(NEC_98)
        sas_storew(timeout_address, 0x00);
#else  // !NEC_98
	/*
	 * Set up BIOS data area.
	 */
	sas_storew(port_address[adapter],(word)port_start[adapter]);
	sas_store(timeout_address[adapter], (half_word)0x14 );		/* timeout */
#endif // !NEC_98
}

#if defined(NEC_98)
static void lpr_state_outa_event IFN1(long,adapter)
{
        state=STATE_READY;
}

void lpr_state_out_event IFN1(long,adapter)
{
        state=STATE_OUTA;
        handle_for_outa_event=add_q_event_t(lpr_state_outa_event,HOST_PRINTER_DELAY,0);
}
#else  // !NEC_98
#if defined(NTVDM) && defined(MONITOR)
static void lpr_state_outa_event IFN1(long,adapter)
{
	set_status(adapter, (IU8)(get_status(adapter) | ACK));
	set_state(adapter, STATE_READY);
}

static void lpr_state_out_event IFN1(long,adapter)
{
	set_status(adapter, (IU8)(get_status(adapter) & ~ACK));
	set_state(adapter, STATE_OUTA);
	handle_for_outa_event[adapter]=add_q_event_t(lpr_state_outa_event,HOST_PRINTER_DELAY,adapter);
}

#else	/* NTVDM && MONITOR */

static void lpr_state_outa_event IFN1(long,adapter)
{
	set_high(status_reg[adapter],ACK);
	state[adapter]=STATE_READY;
}

static void lpr_state_out_event IFN1(long,adapter)
{
	set_low(status_reg[adapter], ACK);
	state[adapter]=STATE_OUTA;
	handle_for_outa_event[adapter]=add_q_event_t(lpr_state_outa_event,HOST_PRINTER_DELAY,adapter);
}
#endif	/* NTVDM && MONITOR */
#endif // !NEC_98

#if defined(NEC_98)
void printer_inb IFN2(io_addr,port, half_word *,value)
#else  // !NEC_98
static void printer_inb IFN2(io_addr,port, half_word *,value)
#endif // !NEC_98
{
#ifndef NEC_98
	int	adapter, i;

	note_trace1(PRINTER_VERBOSE,"inb from printer port %#x ",port);
	/*
	** Scan the ports to find out which one is used. NB the
	** port must be valid one because we only used io_define_inb()
	** for the valid ports
	*/
	for(i=0; i < NUM_PARALLEL_PORTS; i++)
		if((port & LPT_MASK) == port_no[i])
			break;
        adapter = i % NUM_PARALLEL_PORTS;
		
	port = port & PRINTER_BIT_MASK;		/* clear unused bits */
#endif // !NEC_98

	switch(port)
	{
#if defined(NEC_98)
        case LPT1_READ_DATA:
                *value = output_reg;
#else  // !NEC_98
	case DATA_OFFSET:
                *value = output_reg[adapter];
#endif // !NEC_98
		break;

#if defined(NEC_98)
        case LPT1_READ_SIGNAL1:
                notbusy_check();
                *value = status_reg;
                if(sas_hw_at(BIOS_NEC98_BIOS_FLAG+1)&0x80)
                    *value |= 0x20;
#else  // !NEC_98
	case STATUS_OFFSET:
		switch(get_state(adapter))
		{
#if defined(NTVDM)
		case STATE_DONGLE:
			/* read directly from the port for Dongle */
			*value = host_read_printer_status_port(adapter);
			set_status(adapter, *value);
			break;
		case STATE_DATA:

#endif

		case STATE_READY:
			notbusy_check(adapter);
                        *value = get_status(adapter) | STATUS_REG_MASK;


                        /* Clear ERROR as it will be set if we fail on the print. */
                        /* Clear after two inbs as DOS seems to require this. */
                        if (retryErrorCount > 0)
                            retryErrorCount--;
                        else
                            set_status(adapter, (IU8)(get_status(adapter) | ERROR));
			break;
    	case STATE_OUT:
			*value = get_status(adapter) | STATUS_REG_MASK;
#ifndef DELAYED_INTS
			delete_q_event(handle_for_out_event[adapter]);
                        lpr_state_out_event(adapter);
#else
			set_low(status_reg[adapter], ACK);
                        state[adapter] = STATE_OUTA;
#endif /* DELAYED INTS */
			break;
    	case STATE_OUTA:
			notbusy_check(adapter);		/* <chrisP 11Sep91> */
			*value = get_status(adapter) | STATUS_REG_MASK;
#ifndef DELAYED_INTS
			delete_q_event(handle_for_outa_event[adapter]);
			lpr_state_outa_event(adapter);
#else
			set_high(status_reg[adapter], ACK);
			state[adapter] = STATE_READY;
#endif
			break;
    	default:	
			note_trace1(PRINTER_VERBOSE,
			            "<pinb() - unknown state %x>",
			            get_state(adapter));
			break;
		}
#endif // !NEC_98
		break;
#if defined(NEC_98)
        case LPT1_READ_SIGNAL2:
                *value = control_reg;
#else  // !NEC_98
	case CONTROL_OFFSET:
		*value = get_control(adapter) | CONTROL_REG_MASK;
		negate(*value, STROBE);
		negate(*value, AUTO_FEED);
		negate(*value, SELECT_IN);
#endif // !NEC_98
		break;
	}
#ifndef NEC_98
	note_trace3(PRINTER_VERBOSE, "<pinb() %x, ret %x, state %x>",
		    port, *value, get_state(adapter));
#endif // !NEC_98
}

#if defined(NEC_98)
void printer_outb IFN2(io_addr,port, half_word,value)
#else  // !NEC_98
static void printer_outb IFN2(io_addr,port, half_word,value)
#endif // !NEC_98
{
#if defined(NEC_98)
        half_word old_control;
#else  // !NEC_98
	int	adapter, i;
	half_word old_control;
#ifdef PC_CONFIG
	char	variable_text[MAXPATHLEN];
	int softpcerr;
	int severity;

	softpcerr = 0;
	severity = 0;
#endif


	note_trace2(PRINTER_VERBOSE,"outb to printer port %#x with value %#x",
	            port, value);

	/*
	** Scan the ports to find out which one is used. NB the
	** port must be valid one because we only used io_define_inb()
	** for the valid ports
	*/
	for(i=0; i < NUM_PARALLEL_PORTS; i++)
		if((port & LPT_MASK) == port_no[i])
			break;
	adapter = i % NUM_PARALLEL_PORTS; 			

	note_trace3(PRINTER_VERBOSE, "<poutb() %x, val %x, state %x>",
		    port, value, get_state(adapter));

	port = port & PRINTER_BIT_MASK;		/* clear unused bits */

	switch(get_state(adapter))
	{
#if defined(NTVDM)
	case STATE_DONGLE:
	    if (port == DATA_OFFSET) {
		output_reg[adapter] = value;
		host_print_byte(adapter, value);
		break;
	    }
	    // fall through
	case STATE_DATA:
		if (port == DATA_OFFSET) {
		    if (host_set_lpt_direct_access(adapter, TRUE)) {
			host_print_byte(adapter, output_reg[adapter]);
			host_print_byte(adapter, value);
			set_state(adapter, STATE_DONGLE);
			/* Write char to internal buffer */
			output_reg[adapter] = value;
		    }
		    else {
			    /* unable to open the lpt for direct access,
			       mark the device busy */

#if !defined(MONITOR)
			set_low(status_reg[adapter], NOTBUSY);
#else /* NTVDM && !MONITOR */
			set_status(adapter, 0x7F);
#endif


		    }
		    break;
		}

	// fall through
#endif
	case STATE_OUT:
	case STATE_OUTA:
	case STATE_READY:
#endif // !NEC_98
		switch(port)
		{
#if defined(NEC_98)
                case LPT1_WRITE_DATA:
                        output_reg = value;
#else  // !NEC_98
		case DATA_OFFSET:
#if defined(NTVDM)
			set_state(adapter, STATE_DATA);
#endif
			/* Write char to internal buffer */
			output_reg[adapter] = value;
#endif // !NEC_98
			break;
#if defined(NEC_98)
                case LPT1_WRITE_SIGNAL2:
                case LPT1_WRITE_SIGNAL1:
                        old_control = control_reg;
                        if (port == LPT1_WRITE_SIGNAL2) {
                            control_reg =(value & (IR8 | NOTPSTB));
                        } else {
                            switch (value >>1)
                            {
                            case 1:
                            case 41:
                                break;
                            case 3:
                                if (value & 0x01)
                                    set_high(control_reg ,IR8);
                                else
                                    set_low(control_reg, IR8);
                                break;
                            case 7:
                                if (value & 0x01) {
                                set_high(control_reg, NOTPSTB);
//                                  is_busy = FALSE;
                                    if (busy_count<1) {
                                        status_reg |= NOTBUSY;
                                        busy_flag=FALSE;
                                    } else if (busy_count==NEC98_BUSY) {
                                        busy_count=NEC98_BUSY_COUNT;
                                        busy_flag=TRUE;
                                    }
                                } else {
                                    set_low(control_reg, NOTPSTB);
//                                  is_busy = TRUE;
                                    busy_count=NEC98_BUSY;
                                    status_reg &= ~NOTBUSY;
                                    busy_flag=FALSE;
                                }
                                break;
                            default:
                                break;
                            }
                        }
#else  // !NEC_98

		case STATUS_OFFSET:
			/* Not possible */
			break;

		case CONTROL_OFFSET:
			/* Write control bits */
			old_control = get_control(adapter);	/* Save old value to see what's changed */
			set_control(adapter, value);
#endif // !NEC_98
#if defined(NEC_98)
                        if (!pstb_mask) {
                                if (high_low(old_control, value, NOTPSTB))
#else  // !NEC_98
			if (low_high(old_control, value, INIT_P))
#ifdef PC_CONFIG
				/* this was a call to host_print_doc - <chrisP 28Aug91> */
				host_reset_print(&softpcerr, &severity);
			if (softpcerr != 0)
				host_error(softpcerr, severity, variable_text);
#else
				/* this was a call to host_print_doc - <chrisP 28Aug91> */
				host_reset_print(adapter);
#endif

			if (toggled(old_control, value, AUTO_FEED))
				host_print_auto_feed(adapter,
					((value & AUTO_FEED) != 0));

			if (low_high(old_control, value, STROBE))
#endif // !NEC_98
			{
#ifndef NEC_98
#if defined(NTVDM)
			    if (get_state(adapter) == STATE_DONGLE) {
				host_set_lpt_direct_access(adapter, FALSE);
				/* pass through to print out the last byte
				 * which we have sent it out the data port
				 * while we are in DONGLE state.
				 */

				set_state(adapter, STATE_READY);
			    }
#endif
#endif // !NEC_98

#ifdef PS_FLUSHING
				/*
				 * If PostScript flushing is enabled for this
				 * port then we flush on a Ctrl-D
				 */
				if ( psFlushEnabled[adapter] &&
				     output_reg[adapter] == 0x04 /* ^D */ ) {
					host_print_doc(adapter);
				} else {
#endif	/* PS_FLUSHING */
				       /*
				 	* Send the stored internal buffer to
				 	* the printer
				 	*/
#if defined(NEC_98)
                                        if(host_print_byte(output_reg) != FALSE)
                                        {
                                            status_reg &= ~NOTBUSY;
                                            state=STATE_OUT;
                                            handle_for_out_event=add_q_event_t(lpr_state_out_event,HOST_PRINTER_DELAY,0);
                                        }
#else  // !NEC_98
                                	if(host_print_byte(adapter,output_reg[adapter]) == FALSE)
					{
				    		set_status(adapter, (IU8)(get_status(adapter) & ~ERROR)); /* active Low */
				    		/* NTVDM had here(?): set_status(adapter, ACK|PEND|SELECT|ERROR); */
				    		/* two status inbs before we clear ERROR */
				    		retryErrorCount = 2;
					}
					else
					{
                                    		/* clear ERROR condition */
                                    		set_status(adapter, (IU8)(get_status(adapter) | ERROR));
#if defined(NTVDM) && !defined(MONITOR)
				    		set_low(status_reg[adapter], NOTBUSY);
#else /* NTVDM && !MONITOR */
				    		set_status(adapter,
					       	(IU8)(get_status(adapter) & ~NOTBUSY));
#endif /* NTVDM && !MONITOR */
				    		set_state(adapter, STATE_OUT);
#ifndef DELAYED_INTS
				    		handle_for_out_event[adapter]=add_q_event_t(lpr_state_out_event,HOST_PRINTER_DELAY,adapter);
#endif /* DELAYED_INTS */
					}
#endif // !NEC_98
#ifdef PS_FLUSHING
				}
#endif	/* PS_FLUSHING */
			}
#if defined(NEC_98)
                        else if (low_high(old_control, value, NOTPSTB)
                                        && state == STATE_OUT)
#else  // !NEC_98
			else if (high_low(old_control, value, STROBE)
				 	&& get_state(adapter) == STATE_OUT)
#endif // !NEC_98
			{
#if defined(NEC_98)
                                if (value & IR8)
#else  // !NEC_98
				if (value & IRQ)
#endif // !NEC_98
				{
					/*
					 * Application is using
					 * interrupts, so we can't
					 * rely on INBs being
					 * used to check the
					 * printer status.
					 */
#if defined(NEC_98)
                                        state =STATE_READY;
                                        notbusy_check();
                                }
#else  // !NEC_98
					set_state(adapter, STATE_READY);
					notbusy_check(adapter);
#endif // !NEC_98
				}
			}

#ifndef NEC_98
#if defined(NTVDM)
			else if (low_high(old_control, value, IRQ) &&
				 get_state(adapter) == STATE_DONGLE) {

				host_set_lpt_direct_access(adapter, FALSE);
				set_state(adapter, STATE_READY);
			}

#endif
#endif // !NEC_98

#ifndef NEC_98
#ifndef	PROD
			if (old_control & IRQ)
				note_trace1(PRINTER_VERBOSE, "Warning: LPT%d is being interrupt driven\n",
					number_for_adapter(adapter));
#endif
#endif // !NEC_98
			break;
		}
#ifndef NEC_98
		break;
	default:	
		note_trace1(PRINTER_VERBOSE, "<poutb() - unknown state %x>",
		            get_state(adapter));
		break;
	}
#endif // !NEC_98
}

void printer_status_changed IFN1(int,adapter)
{
	note_trace1(PRINTER_VERBOSE, "<printer_status_changed() adapter %d>",
	            adapter);

	/* check whether the printer has just changed state to NOTBUSY */
#if defined(NEC_98)
        notbusy_check();
#else  // !NEC_98
	notbusy_check(adapter);
#endif // !NEC_98
}

/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

#if defined(NEC_98)
void notbusy_check IFN0()
#else  // !NEC_98
static void notbusy_check IFN1(int,adapter)
#endif // !NEC_98
{
	/*
	 *	This function is used to detect when the printer
	 *	state transition to NOTBUSY occurs.
	 *
	 *	If the parallel port is being polled, the port
	 *	emulation will stop this transition occurring
	 *	until the application has detected the ACK
	 *	pulse. notbusy_check() is then called each time the
	 *	port status is read using the INB; when the host
	 *	says the printer is HOST_LPT_BUSY, the port status
	 *	returns to the NOTBUSY state.
	 *
	 *	If the parallel port is interrupt driven, we cannot
	 *	rely on the application using the INB: so we first
	 *	check the host printer status immediately after
	 *	outputting the character. If the host printer isn't
	 *	HOST_LPT_BUSY, then we interrupt immediately;
	 *	otherwise, we rely on the printer_status_changed()
	 *	call to notify us of when HOST_LPT_BUSY is cleared.
	 */

	/* <chrisP 11Sep91> allow not busy at leading edge of ack pulse too */
#if defined(NEC_98)
        if ( (state == STATE_READY
             ||  state == STATE_OUTA)
             && !(status_reg & NOTBUSY)
             && !(host_lpt_status() & HOST_LPT_BUSY))
        {
#if 1
            if(busy_count<1){
                        status_reg |= NOTBUSY;
                        busy_flag=FALSE;
                }
            else if(busy_count==NEC98_BUSY)status_reg &= ~NOTBUSY;
            else {
                status_reg &= ~NOTBUSY;
                busy_count--;
            }
#else
                if(is_busy)
                        status_reg &= ~NOTBUSY;
                else
                        status_reg |= NOTBUSY;
#endif

                if (control_reg & IR8)
                {
                        ica_hw_interrupt(0, CPU_PRINTER_INT, 1);
                }
        }
#else  // !NEC_98
	if (	 (get_state(adapter) == STATE_READY ||
#if defined(NTVDM)
		  get_state(adapter) == STATE_DATA ||
#endif
		  get_state(adapter) == STATE_OUTA)
	     &&	!(get_status(adapter) & NOTBUSY)
	     &&	!(host_lpt_status(adapter) & HOST_LPT_BUSY))
	{
#if defined(NTVDM) && !defined(MONITOR)
		set_high(status_reg[adapter], NOTBUSY);
#else /* NTVDM && !MONITOR */
		set_status(adapter, (IU8)(get_status(adapter) | NOTBUSY));
#endif /* NTVDM && !MONITOR */

#ifndef	PROD
		if (io_verbose & PRINTER_VERBOSE)
		    fprintf(trace_file, "<printer notbusy_check() - adapter %d changed to NOTBUSY>\n", adapter);
#endif

		if (get_control(adapter) & IRQ)
                {
			ica_hw_interrupt(0, CPU_PRINTER_INT, 1);
		}
	}
#endif // !NEC_98
}
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

/*
** Initialise the printer port required.
*/
void printer_init IFN1(int,adapter)
{
#if defined(NEC_98)
        unsigned char ch;
        io_define_inb( LPT1_ADAPTER, printer_inb );
        io_define_outb( LPT1_ADAPTER, printer_outb );
        io_connect_port( LPT1_READ_DATA, LPT1_ADAPTER, IO_READ_WRITE);
        io_connect_port( LPT1_READ_SIGNAL1, LPT1_ADAPTER, IO_READ);
        io_connect_port( LPT1_READ_SIGNAL2, LPT1_ADAPTER, IO_READ_WRITE);
        io_connect_port( LPT1_WRITE_SIGNAL1, LPT1_ADAPTER, IO_READ_WRITE);
        ch = sas_hw_at(BIOS_NEC98_BIOS_FLAG + 1);
        ch &= 0x80;
        status_reg = 0x94|(ch >>2);
        control_reg = 0x80;
        host_print_auto_feed(FALSE);
        state=STATE_READY;
#else  // !NEC_98
	io_addr i;

	io_define_inb( lpt_adapter[adapter], printer_inb );
	io_define_outb( lpt_adapter[adapter], printer_outb );
	for(i = port_start[adapter]; i < port_end[adapter]; i++)
		io_connect_port(i,lpt_adapter[adapter],IO_READ_WRITE);

#if defined(NTVDM) && defined(MONITOR)
	/*
	 * If we know the addresses of the 16-bit variables write directly
	 * to them, otherwise save the value until we do.
	 */
	if (intel_setup)
	{
	    set_status(adapter, 0xDF);
	    set_control(adapter, 0xEC);
	}
	else
#endif /* NTVDM && MONITOR */
	{
	    control_reg[adapter] = 0xEC;
	    status_reg[adapter] = 0xDF;
	}
        output_reg[adapter] = 0xAA;

	/*
	 * The call to host_print_doc has been removed since it is
	 * sensible to distinguish between a hard flush (on ctl-alt-del)
	 * or menu reset and a soft flush under user control or at end
	 * of PC application. The calls to host_lpt_close() followed
	 * by host_lpt_open() should already cause a flush to occur,
	 * so no functionality is lost. The first time printer_init is
	 * called host_lpt_close() is not called, but this cannot
	 * matter since host_print_doc() can only be a no-op.
	 */
	/* host_print_doc(adapter); */
	host_print_auto_feed(adapter, FALSE);

#if defined(NTVDM) && defined(MONITOR)
	if (intel_setup)
	    set_state(adapter, STATE_READY);
	else
#endif /* NTVDM && MONITOR */
	    state[adapter] = STATE_READY;

#endif // !NEC_98
} /* end of printer_init() */

#if defined(NTVDM) && defined(MONITOR)
/*
** Store 16-bit address of status table and fill it with current values.
*/
#ifdef ANSI
void printer_setup_table(sys_addr table_addr)
#else /* ANSI */
void printer_setup_table(table_addr)
sys_addr table_addr;
#endif /* ANSI */
{
#ifndef NEC_98
    int i;
    sys_addr lp16BufSize;
    unsigned int cbBuf;
    word    lptBasePortAddr[NUM_PARALLEL_PORTS];

    if (!intel_setup)
    {

	/*
	 * Store the addresses of the tables resident in 16-bit code. These
	 * are:
	 *	status register		(NUM_PARALLEL_PORTS bytes)
	 *	state register		(NUM_PARALLEL_PORTS bytes)
	 *	control register	(NUM_PARALLEL_PORTS bytes)
	 *	host_lpt_status		(NUM_PARALLEL_PORTS bytes)
	 *
	 * Then transfer any values which have already been set up into the
	 * variables. This is in case printer_init has been called prior to
	 * this function.
	 */
	status_addr = table_addr;
	state_addr = table_addr + NUM_PARALLEL_PORTS;
        control_addr = table_addr + 2 * NUM_PARALLEL_PORTS;
	for (i = 0; i < NUM_PARALLEL_PORTS; i++)
	{
	    set_status(i, status_reg[i]);
	    set_state(i, state[i]);
	    set_control(i, control_reg[i]);
	    lptBasePortAddr[i] = port_start[i];
	}

	/* Let host know where host_lpt_status is stored in 16-bit code. */
	host_printer_setup_table(table_addr, NUM_PARALLEL_PORTS, lptBasePortAddr);
/* sudeepb 24-Jan-1993 for printing performance for x86 */
        lp16BufSize = table_addr + 4 * NUM_PARALLEL_PORTS;
        cbBuf = (sas_w_at_no_check(lp16BufSize));
        lp16BitPrtBuf = table_addr + (4 * NUM_PARALLEL_PORTS) + 2;
        lp16BitPrtId  = lp16BitPrtBuf + cbBuf;
        lp16BitPrtCount = lp16BitPrtId + 1;
        lp16BitPrtBusy =  lp16BitPrtCount + 2;
	intel_setup = TRUE;
    }
#endif // !NEC_98
}
#endif /* NTVDM && MONITOR */

#endif

#ifndef NEC_98
#ifdef NTVDM
void printer_is_being_closed(int adapter)
{

#if defined(MONITOR)
	set_state(adapter, STATE_READY);
#else
	state[adapter] = STATE_READY;

#endif
}

#endif
#endif // !NEC_98

#ifdef PS_FLUSHING
/*(
=========================== printer_psflush_change ============================
PURPOSE:
	Handle change of PostScript flush configuration option for a printer
	port.
INPUT:
	hostID - Configuration item I.D.
	apply - TRUE if change to be applied
OUTPUT:
	None
ALGORITHM:
	If PostScript flushing is being enabled then;
		set the PostScript flush enable flag for the port;
		disable autoflush for the port;
	else;
		reset the PostScript flush enable flag for the port;
		enable autoflush for the port;
===============================================================================
)*/

GLOBAL void printer_psflush_change IFN2(
    IU8, hostID,
    IBOOL, apply
) {
    IS32 adapter = hostID - C_LPT1_PSFLUSH;

    assert1(adapter < NUM_PARALLEL_PORTS,"Bad hostID %d",hostID);

    if ( apply )
        if ( psFlushEnabled[adapter] = (IBOOL)config_inquire(hostID,NULL) )
            host_lpt_disable_autoflush(adapter);
        else
            host_lpt_enable_autoflush(adapter);
}
#endif	/* PS_FLUSHING */

#if defined(NEC_98)

void NEC98_out_port_37 IFN1(half_word, value)
{
        if (value & 1)
                pstb_mask = TRUE;
        else
                pstb_mask = FALSE;
}

void NEC98_out_port_35 IFN1(half_word, value)
{
        if (value & PSTBM)
                pstb_mask = TRUE;
        else
                pstb_mask = FALSE;
}

void NEC98_in_port_35 IFN1(half_word *, value)
{
        if (pstb_mask)
                *value |= PSTBM;
        else
                *value &= ~PSTBM;
}

void NEC98_lpt_busy_check(void)
{
        busy_flag=FALSE;
        if(busy_count==NEC98_BUSY){
                status_reg &= ~NOTBUSY;
        } else {
                busy_count=0;
                status_reg |= NOTBUSY;
        }
}

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\comms\rs232_io.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: rs232_io.c
 *
 * Description	: RS232 Asynchronous Adaptor BIOS functions.
 *
 * Notes	: None
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)rs232_io.c	1.7 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "trace.h"
#include "rs232.h"
#include "idetect.h"

static word divisors[] = { 1047,768, 384, 192, 96, 48, 24, 12, 6 };

/* workaround for IP32 and Tek43xx compiler bug follows: */
#if  defined(IP32) || defined(TK43) || defined(macintosh)
static int port;
#else
static io_addr port;
#endif

static half_word value;


static void return_status()
{
#if defined(NEC_98)
        setAH(0);
#else  // !NEC_98
	inb((io_addr)(port + RS232_LSR), (IU8 *)&value);
	setAH(value);
	inb((io_addr)(port + RS232_MSR), (IU8 *)&value);
	setAL(value);
#endif // !NEC_98
}


void rs232_io()
{
#ifndef NEC_98
#ifdef BIT_ORDER2
   union {
      half_word all;
      struct {
	 HALF_WORD_BIT_FIELD word_length:2;
	 HALF_WORD_BIT_FIELD stop_bit:1;
	 HALF_WORD_BIT_FIELD parity:2;
	 HALF_WORD_BIT_FIELD baud_rate:3;
      } bit;
   } parameters;
#endif
#ifdef BIT_ORDER1
   union {
      half_word all;
      struct {
	 HALF_WORD_BIT_FIELD baud_rate:3;
	 HALF_WORD_BIT_FIELD parity:2;
	 HALF_WORD_BIT_FIELD stop_bit:1;
	 HALF_WORD_BIT_FIELD word_length:2;
      } bit;
   } parameters;
#endif

   DIVISOR_LATCH divisor_latch;
   int j;
   half_word timeout;
   sys_addr timeout_location;

   /* clear com/lpt idle flag */
   IDLE_comlpt ();

   setIF(1);

   /*
    * Which adapter?
    */
   switch (getDX ())
   {
	case 0:
   		port = RS232_COM1_PORT_START;
		timeout_location = RS232_COM1_TIMEOUT;
		break;
	case 1:
   		port = RS232_COM2_PORT_START;
		timeout_location = RS232_COM2_TIMEOUT;
		break;
	case 2:
   		port = RS232_COM3_PORT_START;
		timeout_location = RS232_COM3_TIMEOUT;
		break;
	case 3:
   		port = RS232_COM4_PORT_START;
		timeout_location = RS232_COM4_TIMEOUT;
		break;
	default:
		break;
   }

   /*
    * Determine function
    */
   switch (getAH ())
   {
   case 0:
      /*
       * Initialise the communication port
       */
      value = 0x80;   /* set DLAB */
      outb((io_addr)(port + RS232_LCR), (IU8)value);
      /*
       * Set baud rate
       */
      parameters.all = getAL();
      divisor_latch.all = divisors[parameters.bit.baud_rate];
      outb((io_addr)(port + RS232_IER), (IU8)(divisor_latch.byte.MSByte));
      outb((io_addr)(port + RS232_TX_RX), (IU8)(divisor_latch.byte.LSByte));
      /*
       * Set word length, stop bits and parity
       */
      parameters.bit.baud_rate = 0;
      outb((io_addr)(port + RS232_LCR), parameters.all);
      /*
       * Disable interrupts
       */
      value = 0;
      outb((io_addr)(port + RS232_IER), (IU8)value);
      return_status();
      break;

   case 1:
      /*
       * Send char over the comms line
       */

      /*
       * Set DTR and RTS
       */
      outb((io_addr)(port + RS232_MCR), (IU8)3);
      /*
       * Real BIOS checks CTS and DSR - we know DSR ok.
       * Real BIOS check THRE - we know it's ok.
	   * We only check CTS - this is supported on a few ports, eg. Macintosh.
       */
      /*
       * Wait for CTS to go high, or timeout
       */
      sas_load(timeout_location, &timeout);
      for ( j = 0; j < timeout; j++)
      {
	  	inb((io_addr)(port + RS232_MSR), (IU8 *)&value);
		if(value & 0x10)break;	/* CTS High, all is well */
      }
	  if(j < timeout)
	  {
      	outb((io_addr)(port + RS232_TX_RX), getAL());	/* Send byte */
		inb((io_addr)(port + RS232_LSR), (IU8 *)&value);
		setAH(value);									/* Return Line Status Reg in AH */
	  }
      else
	  {
	    setAH((UCHAR)(value | 0x80));	/* Indicate time out */
	  }
      break;

   case 2:
      /*
       * Receive char over the comms line
       */
      /*
       * Set DTR
       */
      value = 1;
      outb((io_addr)(port + RS232_MCR), (IU8)value);
      /*
       * Real BIOS checks DSR - we know it's ok.
       */
      /*
       * Wait for data to appear, or timeout(just an empirical guess)
       */

      sas_load(timeout_location, &timeout);
      for ( j = 0; j < timeout; j++)
	 {
	 inb((io_addr)(port + RS232_LSR), (IU8 *)&value);
	 if ( (value & 1) == 1 )
	    {
	    /*
	     * Data ready go read it
	     */
	    value &= 0x1e;   /* keep error bits only */
	    setAH(value);

	    inb((io_addr)(port + RS232_TX_RX), (IU8 *)&value);
	    setAL(value);
	    return;
	    }
	 }

      /*
       * Set timeout
       */
      value |= 0x80;
      setAH(value);
      break;

   case 3:
      /*
       * Return the communication port status
       */
      return_status();
      break;
   case 4:
      /*
       * EXTENDED (PS/2) Initialise the communication port
       */
	value = 0x80;   /* set DLAB */
	outb((io_addr)(port + RS232_LCR), (IU8)value);
	parameters.bit.word_length = getCH();
	parameters.bit.stop_bit = getBL();
	parameters.bit.parity = getBH();
	parameters.bit.baud_rate = getCL();

	/*
        	Set baud rate
	*/
      divisor_latch.all = divisors[parameters.bit.baud_rate];
      outb((io_addr)(port + RS232_IER), (IU8)(divisor_latch.byte.MSByte));
      outb((io_addr)(port + RS232_TX_RX), (IU8)(divisor_latch.byte.LSByte));
      /*
       * Set word length, stop bits and parity
       */
      parameters.bit.baud_rate = 0;
      outb((io_addr)(port + RS232_LCR), parameters.all);
      /*
       * Disable interrupts
       */
      value = 0;
      outb((io_addr)(port + RS232_IER), (IU8)value);
      return_status();
      break;

   case 5:	/* EXTENDED Comms Port Control */
	switch( getAL() )
	{
		case 0:	/* Read modem control register */
			inb( (io_addr)(port + RS232_MCR), (IU8 *)&value);
			setBL(value);
			break;
		case 1: /* Write modem control register */
			outb( (io_addr)(port + RS232_MCR), getBL());
			break;
	}
	/*
		 Return the communication port status
	*/
	return_status();
	break;
   default:
	/*
	** Yes both XT and AT BIOS's really do this.
	*/
	setAH( (UCHAR)(getAH()-3) );
      	break;
   }
#endif // !NEC_98
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\comms\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=comms
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=com.c \
                        ..\printer.c     \
                        ..\printer_.c    \
                        ..\prt_scrn.c    \
                        ..\rs232_io.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC

UMTYPE=console

!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\comms\printer_.c ===
#if defined(NEC_98)
#else  // !NEC_98

#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC-AT Revision 2.0
 *
 * Title	: Parallel Printer BIOS functions.
 *
 * Description	: The Bios functions for printing a char, initializing the
 *		  printer and getting the printer status.  The low
 *		  level printer emulation is in printer.c.
 *
 * Author	: Henry Nash
 *
 * Mods: (r3.2) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 *
 *	(r3.3)	: Implement the real code, inside compile switch.
 */

#ifdef SCCSID
static char SccsID[]="@(#)printer_io.c	1.11 08/25/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#ifdef PRINTER
#include <stdio.h>

#include TypesH

#ifdef SYSTEMV
#include <sys/termio.h>
#endif

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "printer.h"
#include "trace.h"
#include "error.h"
#include "config.h"
#include "host_lpt.h"
#include "idetect.h"

#if defined(NTVDM) && defined(MONITOR)
void    printer_bop_flush (void);
#endif

#if defined(NTVDM)
void    printer_bop_openclose (int);
#endif

/*
 * Set up arrays of addresses in BIOS data area, pointing to LPT ports and timeout values
 */
static sys_addr port_address[] = {
			LPT1_PORT_ADDRESS,
			LPT2_PORT_ADDRESS,
			LPT3_PORT_ADDRESS };
static sys_addr timeout_address[] = {
			LPT1_TIMEOUT_ADDRESS,
			LPT2_TIMEOUT_ADDRESS,
			LPT3_TIMEOUT_ADDRESS };

#endif /* PRINTER */

#if defined(NTVDM) && defined(MONITOR)
void    printer_bop_flush (void);
#endif
/*
 * The printer bios consists of three functions:
 *
 * 	AH == 0		print char in AL
 *	AH == 1		initialize the printer
 *	AH == 2		get printer status
 *
 * The bios only supports programmed IO operations to the printer, although
 * the printer adaptor does support interrupts if Bit 4 is set in the control
 * register.
 */

void printer_io()
{
#ifdef PRINTER

    half_word time_out, status;
    word printer_io_address, printer_io_reg, printer_status_reg, printer_control_reg;
    boolean printer_busy = TRUE;
    unsigned long time_count;
    int adapter;

#ifdef NTVDM
    int bopsubfunction = getSI();

    switch (bopsubfunction) {
#ifdef MONITOR
        case 0:
            /* this is the bop to flush 16bit printer buffer */
            printer_bop_flush ();
            return;
#endif

        case 1:
        case 2:
            /* this is the bop to track a DOS open/close on LPTn */
            printer_bop_openclose (bopsubfunction);
            return;
   }
#endif

    setIF(1);
    adapter = getDX() % NUM_PARALLEL_PORTS;
    sas_loadw(port_address[adapter], &printer_io_address);
    printer_io_reg = printer_io_address;
    printer_status_reg = printer_io_address + 1;
    printer_control_reg = printer_io_address + 2;

    sas_load(timeout_address[adapter], &time_out);
    time_count = time_out * 0xFFFF;

    if (printer_io_address != 0)
    {
		IDLE_comlpt ();

        switch(getAH())
        {
        case 0:
		/* Check the port status for busy before sending the character*/
		while(printer_busy && time_count > 0)
		{
		    /* The host_lpt_status() should check for status changes */
		    /* possibly by calling AsyncEventManager() if it's using */
		    /* XON /XOFF flow control. */
		    inb(printer_status_reg, &status);
		    if (status & 0x80)
			printer_busy = FALSE;
		    else
			time_count--;
		}

		if (printer_busy)
		{
		    status &= 0xF8;			/* clear bottom unused bits */
		    status |= 1;			/* set error flag	    */
		}
		else
		{
                    /* Only send the character if the port isn't still busy */
                    outb(printer_io_reg, getAL());
		    outb(printer_control_reg, 0x0D);	/* strobe low-high  	    */
		    outb(printer_control_reg, 0x0C);	/* strobe high-low  	    */
		    inb(printer_status_reg, &status);
		    status &= 0xF8;			/* clear unused bits	    */
		}

		status ^= 0x48;				/* flip the odd bit	    */
		setAH(status);
	        break;

        case 1: outb(printer_control_reg, 0x08);	/* set init line low	    */
                outb(printer_control_reg, 0x0C);	/* set init line high	    */
		inb(printer_status_reg, &status);
		status &= 0xF8;				/* clear unused bits	    */
		status ^= 0x48;				/* flip the odd bit	    */
		setAH(status);
	        break;

        case 2: inb(printer_status_reg, &status);
		status &= 0xF8;				/* clear unused bits	    */
		status ^= 0x48;				/* flip the odd bit	    */
		setAH(status);
	        break;

        default:
	         break;
	}
    }
#endif
}

extern  void  host_lpt_dos_open(int);
extern  void  host_lpt_dos_close(int);

#if defined(NTVDM) && defined(MONITOR)
/* for printing performance on x86 */

extern  sys_addr lp16BitPrtId;
extern  boolean  host_print_buffer(int);

void printer_bop_flush(void)
{
#ifdef PRINTER
    int  adapter;

    adapter = sas_hw_at_no_check(lp16BitPrtId);

    if (host_print_buffer (adapter) == FALSE)
        setAH(0x08);        /* IO error */
    else
        setAH(0x90);        /* Success */
    return;

#endif
}
#endif

#if defined(NTVDM)
void printer_bop_openclose(int func)
{
#ifdef PRINTER
    int  adapter;

    adapter = getDX() % NUM_PARALLEL_PORTS;

    /* func must be 1 or 2 (open,close) */
    if (func == 1)
        host_lpt_dos_open(adapter);
    else
        host_lpt_dos_close(adapter);
    return;

#endif
}
#endif
#endif // !NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cpu\src\evid\ev_stubs.c ===
#include <insignia.h>
#include <host_def.h>
/*[
 *  Name:	ev_stubs.c
 *  SCCS ID:	@(#)ev_stubs.c	1.1 07/22/94
 *
 *  Purpose:	Provide the stub routines needed to give the a4+evid
 *		and ccpu+cevid libraries the same interface.
 *
 * (C) Copyright Insignia Solutions Ltd, 1994.
]*/

GLOBAL void setup_vga_globals IFN0()
{
}
GLOBAL IHPE setup_global_data_ptr IFN0()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cpu\src\evid\ev_glue.c ===
/*[
*************************************************************************

	Name:		ev_glue.c
	Author:		Simon Frost
	Created:	Janury 1994
	Derived from:	Original
	Sccs ID:	@(#)ev_glue.c	1.16 10/21/94
	Purpose:	Provides glue routines for C-E-vid functions
			and the Jcode calling conventions.

	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.

*************************************************************************
]*/

#include "insignia.h"
#include "host_def.h"

#ifdef CCPU
#include "gmi.h"
#endif

#include "cpu_vid.h"
#include "video.h"
#include "egacpu.h"	/* for Vglob fn defns */
#include "ga_mark.h"	/* for mark fn pointers struct defn */
#include "evidfunc.h"	/* generated by build process */
#include "gdpvar.h"	/* generated by build process */

#undef FORWARDS		/* all these redefined in EDL code */
#undef BACKWARDS
#undef UNCHAINED
#include "Evid_c.h"	/* generated from Evid.edl */
#include "j_c_lang.h"   /* jcode to ccode register definition header */

EVID_WRT_POINTERS c_ev_write_ptr;
EVID_READ_POINTERS c_ev_read_ptr;

/* defines in j_c_lang.h
 *extern IUH jccc_parm1, jccc_parm2, jccc_parm3, jccc_parm4,
 *		jccc_parm5, jccc_gdp;
 */
extern IHP Gdp;

extern IU32 gvi_pc_low_regen;

#ifdef CCPU
IUH ega_gc_outb_mask;

IHP Gdp;
#endif

#ifdef C_VID
IHPE modeLookup;	/* CEvid extern */
IHPE EvidPortFuncs;	/* CEvid extern */
IHPE AdapCOutb;		/* CEvid extern */

IHPE EvidWriteFuncs, EvidReadFuncs, EvidMarkFuncs;	/* CEvid refs */


/* let the c jcode know the addresses so it can lea them */
/* NOTE These things are not accessed the jcode version of the code 
 * has been substituted with a c version 
 * LEAVE in so as not to get unresolved references 
 */
IHPE j_modeLookup	= (IHPE) &modeLookup ;
IHPE j_EvidPortFuncs	= (IHPE) &EvidPortFuncs ;
IHPE j_AdapCOutb	= (IHPE) &AdapCOutb;
IHPE j_EvidWriteFuncs	= (IHPE) &EvidWriteFuncs; 
IHPE j_EvidReadFuncs	= (IHPE) &EvidReadFuncs;
IHPE j_EvidMarkFuncs	= (IHPE) &EvidMarkFuncs;
/* Gdp is referenced */
IHP j_Gdp;	/*	=  Gdp ;  SPECIAL CASE Gdp is the correct address  see below for init */
/*(
=========================== CrulesRuntimeError =======================

PURPOSE: resolve c-rules requirment to have a runtime error routine

INPUT: message string.

OUTPUT: To be Decided .
====================================================================
)*/
GLOBAL void
CrulesRuntimeError IFN1( char * , message ) 
{
	printf("cevid runtime error: %s\r\n", message);
}

/*(
=========================== write_byte_ev_glue =======================

PURPOSE: Set up C evid parameters and call byte write function pointer

INPUT: Write offset & value to write

OUTPUT: None.

====================================================================
)*/
GLOBAL void
write_byte_ev_glue IFN2(IU32, eaOff, IU8, eaVal)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.b_write)(eaOff, eaVal);
}

/*(
=========================== write_word_ev_glue =======================

PURPOSE: Set up C evid parameters and call word write function pointer

INPUT: Write offset & value to write

OUTPUT: None.

====================================================================
)*/
GLOBAL void
write_word_ev_glue IFN2(IU32, eaOff, IU16, eaVal)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.w_write)(eaOff, eaVal);
}

/*(
=========================== write_dword_ev_glue =======================

PURPOSE: Set up C evid parameters and call dword write function pointer

INPUT: Write offset & value to write

OUTPUT: None.

====================================================================
)*/
GLOBAL void
write_dword_ev_glue IFN2(IU32, eaOff, IU32, eaVal)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.d_write)(eaOff, eaVal);
}

/*(
=========================== fill_byte_ev_glue =======================

PURPOSE: Set up C evid parameters and call byte fill function pointer

INPUT: Write offset, value to write & fill count

OUTPUT: None.

====================================================================
*/
GLOBAL void
fill_byte_ev_glue IFN3(IU32, eaOff, IU8, eaVal, IU32, count)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_parm3 = (IUH)count;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.b_fill)(eaOff, eaVal, count);
}

/*(
=========================== fill_word_ev_glue =======================

PURPOSE: Set up C evid parameters and call word fill function pointer

INPUT: Write offset, value to write & fill count

OUTPUT: None.

====================================================================
*/
GLOBAL void
fill_word_ev_glue IFN3(IU32, eaOff, IU16, eaVal, IU32, count)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_parm3 = (IUH)count;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.w_fill)(eaOff, eaVal, count);
}

/*(
=========================== fill_dword_ev_glue =======================

PURPOSE: Set up C evid parameters and call dword fill function pointer

INPUT: Write offset, value to write & fill count

OUTPUT: None.

====================================================================
*/
GLOBAL void
fill_dword_ev_glue IFN3(IU32, eaOff, IU32, eaVal, IU32, count)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_parm3 = (IUH)count;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.d_fill)(eaOff, eaVal, count);
}

/*(
=========================== move_byte_fwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call byte fwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_byte_fwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.b_fwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_byte_bwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call byte bwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_byte_bwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.b_bwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_word_fwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call word fwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_word_fwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.w_fwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_word_bwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call word bwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_word_bwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.w_bwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_dword_fwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call dword fwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_dword_fwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.d_fwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_dword_bwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call dword bwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_dword_bwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.d_bwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== read_byte_ev_glue =======================

PURPOSE: Set up C evid parameters and call read byte function pointer

INPUT: read offset in planes

OUTPUT: value read

====================================================================
*/
GLOBAL IU32
read_byte_ev_glue IFN1(IU32, eaOff)
{
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.b_read)(eaOff);

	return((IU32)jccc_parm1);
}

/*(
=========================== read_word_ev_glue =======================

PURPOSE: Set up C evid parameters and call read word function pointer

INPUT: read offset in planes

OUTPUT: None.

====================================================================
*/
GLOBAL IU32
read_word_ev_glue IFN1(IU32, eaOff)
{
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.w_read)(eaOff);

	return((IU32)jccc_parm1);
}

/*(
=========================== read_dword_ev_glue =======================

PURPOSE: Set up C evid parameters and call read dword function pointer

INPUT: read offset in planes

OUTPUT: None.

====================================================================
*/
GLOBAL IU32
read_dword_ev_glue IFN1(IU32, eaOff)
{
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.d_read)(eaOff);

	return((IU32)jccc_parm1);
}

/*(
=========================== read_str_fwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call read string fwd function pointer

INPUT: destination pointer, read offset in planes, number of bytes to read.

OUTPUT: None.

====================================================================
*/
GLOBAL void
read_str_fwd_ev_glue IFN3(IU8 *, dest, IU32, eaOff, IU32, count)
{
	jccc_parm1 = (IUH)dest;
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)1;	/* destination in RAM */
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.str_fwd_read)(dest, eaOff, count);
}

/*(
=========================== read_str_bwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call read string bwd function pointer

INPUT: destination pointer, read offset in planes, number of bytes to read.

OUTPUT: None.

====================================================================
*/
GLOBAL void
read_str_bwd_ev_glue IFN3(IU8 *, dest, IU32, eaOff, IU32, count)
{
	jccc_parm1 = (IUH)dest;
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)1;	/* destination in RAM */
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.str_bwd_read)(dest, eaOff, count);
}

GLOBAL IBOOL cevid_verbose = FALSE;
/*(
=========================== setReadPointers =======================

PURPOSE: Set active struct entries for read functions. (c_ev_read_ptr).

INPUT: index used to select read set.

OUTPUT: None.

====================================================================
*/
GLOBAL void
setReadPointers IFN1(IUH, readset)
{
	IUH chain_index;	/* current chaining for read modes 0 & 1 */

	switch(readset)
	{
	case 0:	/* read mode 0 */
		chain_index = getVideochain();
		if (cevid_verbose) printf("Set Read Pointers Mode 0, chain %d\n", chain_index);
		c_ev_read_ptr.b_read = read_mode0_evid[chain_index].b_read;
		c_ev_read_ptr.w_read = read_mode0_evid[chain_index].w_read;
		c_ev_read_ptr.d_read = read_mode0_evid[chain_index].d_read;
		c_ev_read_ptr.str_fwd_read = read_mode0_evid[chain_index].str_fwd_read;
		c_ev_read_ptr.str_bwd_read = read_mode0_evid[chain_index].str_bwd_read;
		setVideoread_byte_addr(read_mode0_evid[chain_index].b_read);
		break;

	case 1:	/* read mode 1 */
		chain_index = getVideochain();
		if (cevid_verbose) printf("Set Read Pointers Mode 1, chain %d\n", chain_index);
		c_ev_read_ptr.b_read = read_mode1_evid[chain_index].b_read;
		c_ev_read_ptr.w_read = read_mode1_evid[chain_index].w_read;
		c_ev_read_ptr.d_read = read_mode1_evid[chain_index].d_read;
		c_ev_read_ptr.str_fwd_read = read_mode1_evid[chain_index].str_fwd_read;
		c_ev_read_ptr.str_bwd_read = read_mode1_evid[chain_index].str_bwd_read;
		setVideoread_byte_addr(read_mode1_evid[chain_index].b_read);
		break;

	case 2:	/* RAM disabled */
		if (cevid_verbose) printf("Set Read Pointers RAM disabled\n");
		c_ev_read_ptr.b_read = ram_dsbld_read_evid.b_read;
		c_ev_read_ptr.w_read = ram_dsbld_read_evid.w_read;
		c_ev_read_ptr.d_read = ram_dsbld_read_evid.d_read;
		c_ev_read_ptr.str_fwd_read = ram_dsbld_read_evid.str_fwd_read;
		c_ev_read_ptr.str_bwd_read = ram_dsbld_read_evid.str_bwd_read;
		setVideoread_byte_addr(ram_dsbld_read_evid.b_read);
		break;

	case 3:	/* Simple reads (non planed) */
		if (cevid_verbose) printf("Set Read Pointers Simple\n");
		c_ev_read_ptr.b_read = simple_read_evid.b_read;
		c_ev_read_ptr.w_read = simple_read_evid.w_read;
		c_ev_read_ptr.d_read = simple_read_evid.d_read;
		c_ev_read_ptr.str_fwd_read = simple_read_evid.str_fwd_read;
		c_ev_read_ptr.str_bwd_read = simple_read_evid.str_bwd_read;
		setVideoread_byte_addr(simple_read_evid.b_read);
		break;
	}
}

/*(
=========================== setWritePointers =======================

PURPOSE: Set active struct entries for write functions. (c_ev_write_ptr).

INPUT: None. (All information gleaned from Vglobs).

OUTPUT: None.

====================================================================
*/
GLOBAL void
setWritePointers IFN0()
{
	EVID_WRT_POINTERS *choice;	/* point to selected write set */
	IU8 chain;
	IU8 modelookup[] =
	      /*  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 */
		{ 0, 1, 2, 3, 2, 3, 2, 3, 0, 1, 2, 3, 2, 3, 2, 3,
	      /*  16 17 18  19  20  21  22 23 24 25 26  27  28  29  30  31 */
		  8, 9, 10, 11, 10, 11, 6, 7, 8, 9, 10, 11, 10, 11, 10, 11 };

	choice = (EVID_WRT_POINTERS *)0;	/* debug check */

	/* check for dithering 'override' of rest of checks */
	if (getVideodither() == 1)
	{
		if (cevid_verbose) printf("SetWritePointers Dither, Mode %d\n", getVideowrmode());	/*STF*/
		choice = &dith_evid[getVideowrmode()]; /* mode 0-3 */
	}
	else
	{
		chain = getVideochain();
		switch (chain)
		{
		case UNCHAINED:
		case CHAIN_4:
			if (getVideorotate() > 0)
			{
				if (cevid_verbose) printf("SetWritePointers Generic Override for Chain %d, Mode %d\n", chain, getVideowrmode());	/*STF*/
				if (cevid_verbose) printf("Rotates set to %d\n", getVideorotate());/*STF*/
				choice = &gricvid_evid;
			}
			else
			{
				if (chain == UNCHAINED)
				{
					if (cevid_verbose) printf("SetWritePointers Unchained, State %#x", getVideowrstate());	/*STF*/
					choice = &unchained_evid[0];
				}
				else
				{
					if (cevid_verbose) printf("SetWritePointers Chain4");	/*STF*/
					choice = &chain4_evid[0];
				}
				switch(getVideowrmode())
				{
					case MODE_0:
						if (cevid_verbose) printf(" Mode 0, index %d\n", modelookup[getVideowrstate()]);	/* STF */
						choice += modelookup[getVideowrstate()];
						break;

					case MODE_1:
						if (cevid_verbose) printf(" Mode 1\n");/* STF */
						choice += NUM_M0_WRITES;
						break;

					case MODE_2:
						if (cevid_verbose) printf(" Mode 2, index %d\n", modelookup[getVideowrstate() & 0xf]);/* STF */
						choice += NUM_M0_WRITES + NUM_M1_WRITES;
						choice += modelookup[getVideowrstate() & 0xf];
						break;

					case MODE_3:
						if (cevid_verbose) printf(" Mode 3, index %d\n", modelookup[getVideowrstate() & 0xf]);/* STF */
						choice += NUM_M0_WRITES + NUM_M1_WRITES + NUM_M23_WRITES;
						choice += modelookup[getVideowrstate() & 0xf];
						break;

					default:
						if (cevid_verbose) printf(" unknown write mode %d\n",getVideowrmode());
				}
			}
			break;

		case CHAIN_2:
			if (cevid_verbose) printf("SetWritePointers Chain2, Mode %d\n", getVideowrmode());	/*STF*/
			choice = &chain2_evid[getVideowrmode()];
			break;

		case SIMPLE_WRITES:
			if (cevid_verbose) printf("SetWritePointers Simple\n");	/*STF*/
			choice = &simple_evid;
			break;
		}
	}
	if (choice == (EVID_WRT_POINTERS *)0)
	{
		printf("setWritePointers: ERROR - BAD POINTER SELECTION\n");
		choice = &chain2_evid[4];
	}
	c_ev_write_ptr.b_write = choice->b_write;
	c_ev_write_ptr.w_write = choice->w_write;
	c_ev_write_ptr.d_write = choice->d_write;
	c_ev_write_ptr.b_fill = choice->b_fill;
	c_ev_write_ptr.w_fill = choice->w_fill;
	c_ev_write_ptr.d_fill = choice->d_fill;
	c_ev_write_ptr.b_fwd_move = choice->b_fwd_move;
	c_ev_write_ptr.b_bwd_move = choice->b_bwd_move;
	c_ev_write_ptr.w_fwd_move = choice->w_fwd_move;
	c_ev_write_ptr.w_bwd_move = choice->w_bwd_move;
	c_ev_write_ptr.d_fwd_move = choice->d_fwd_move;
	c_ev_write_ptr.d_bwd_move = choice->d_bwd_move;
}

/*(
=========================== setMarkPointers =======================

PURPOSE: Set VGlobs entries for mark functions

INPUT: index used to select mark set.

OUTPUT: None.

====================================================================
*/
GLOBAL void
setMarkPointers IFN1(IUH, markset)
{
	switch (markset)
	{

	case 0:	/* simple */
		if (cevid_verbose) printf("Set Mark Pointers Simple\n");
		setVideomark_byte(simple_mark_evid.b_mark);
		setVideomark_word(simple_mark_evid.w_mark);
		setVideomark_string(simple_mark_evid.str_mark);
		break;

	case 1:	/* CGA style */
		if (cevid_verbose) printf("Set Mark Pointers CGA\n");
		setVideomark_byte(cga_mark_evid.b_mark);
		setVideomark_word(cga_mark_evid.w_mark);
		setVideomark_string(cga_mark_evid.str_mark);
		break;

	case 2:	/* Unchained */
		if (cevid_verbose) printf("Set Mark Pointers Unchained\n");
		setVideomark_byte(unchained_mark_evid.b_mark);
		setVideomark_word(unchained_mark_evid.w_mark);
		setVideomark_string(unchained_mark_evid.str_mark);
		break;

	case 3:	/* Chain4 */
		if (cevid_verbose) printf("Set Mark Pointers Chain4\n");
		setVideomark_byte(chain4_mark_evid.b_mark);
		setVideomark_word(chain4_mark_evid.w_mark);
		setVideomark_string(chain4_mark_evid.str_mark);
		break;

	}
}

GLOBAL void
write_bios_byte IFN2(IU8, eaVal, IU32, eaOff)
{
	jccc_parm1 = (IUH)eaOff;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	chain2_evid[4].b_write(eaOff, eaVal);
}

GLOBAL void
write_bios_word IFN2(IU16, eaVal, IU32, eaOff)
{
	jccc_parm1 = (IUH)eaOff;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	chain2_evid[4].w_write(eaOff, eaVal);
}

/*(
=========================== SetBiosWrites =======================

PURPOSE: Set VGlobs entries for mark functions

INPUT: index used to select mark set.

OUTPUT: None.

====================================================================
*/
GLOBAL void
SetBiosWrites IFN1(IUH, markset)
{
	bios_ch2_byte_wrt_fn = write_bios_byte;
	bios_ch2_word_wrt_fn = write_bios_word;
}

#ifdef CCPU

#define SUBRRINGBUFFERSIZE 25
GLOBAL IUH SubrRingBuffer[SUBRRINGBUFFERSIZE];
/*(
=========================== setup_vga_globals =======================

PURPOSE: Point VGLOBS into correct portion on Gdp

INPUT: None.

OUTPUT: None.

====================================================================
*/

GLOBAL void
setup_vga_globals IFN0()
{
	EGA_CPU.globals = &(GLOBAL_VGAGlobals);

	/* support memory for subr id ring buffer */
        GLOBAL_SubrRingLowIncl = &SubrRingBuffer[0];
        GLOBAL_SubrRingHighIncl = GLOBAL_SubrRingLowIncl + (SUBRRINGBUFFERSIZE-1
);
        GLOBAL_SubrRingPtr = GLOBAL_SubrRingLowIncl;


#ifndef PROD
	if (getenv("CEVID_VERBOSE") != 0)
		cevid_verbose = TRUE;
#endif	/* PROD */
}

/*(
=========================== setup_global_data_ptr =======================

PURPOSE: Setup Gdp for CCPU/CEvid.

INPUT: None.

OUTPUT: None.

====================================================================
*/

GLOBAL IHP
setup_global_data_ptr IFN0()
{
	Gdp = (IHP)host_malloc(64 * 1024);
	/* Gdp holds the correct value so in jcode an lea wants the value not
         * the adrress of the data 
	 */
	j_Gdp = Gdp ;
	if (Gdp == (IHP)0)
		printf("Error - can't malloc memory for Gdp\n");

	return(Gdp);
}
#endif	/* CCPU */
#endif	/* C_VID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\access_c.h ===
#ifndef _Access_c_h
#define _Access_c_h
enum AccessShapeEnum
{
	AccessShapeRD_B = 0,
	AccessShapeRD_W = 1,
	AccessShapeRD_D = 2,
	AccessShapeWT_B = 3,
	AccessShapeWT_W = 4,
	AccessShapeWT_D = 5,
	AccessShapeRW_B = 6,
	AccessShapeRW_W = 7,
	AccessShapeRW_D = 8,
	AccessShapeRD_W2 = 9,
	AccessShapeRD_WD = 10,
	AccessShapeWT_WD = 11,
	AccessShapeRD_DW = 12,
	AccessShapeRD_8B = 13,
	AccessShapeWT_8B = 14,
	AccessShapeRD_10B = 15,
	AccessShapeWT_10B = 16,
	AccessShapeRD_14B = 17,
	AccessShapeWT_14B = 18,
	AccessShapeRD_94B = 19,
	AccessShapeWT_94B = 20
};
enum AccessCheckType
{
	DoNoCheck = 0,
	DoReadCheck = 1,
	DoWriteCheck = 2
};
struct OpndBuffREC
{
	IU32 dWords[32];
};
#endif /* ! _Access_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\add_c.h ===
#ifndef _Add_c_h
#define _Add_c_h
#endif /* ! _Add_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\adjust_c.h ===
#ifndef _Adjust_c_h
#define _Adjust_c_h
#define LOWER_4_BITS (15)
#define NULL_MASK (0)
#define AFCF_SET (17)
#define AFCF_RESET (0)
#endif /* ! _Adjust_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\axphst_c.h ===
#ifndef _Axphst_c_h
#define _Axphst_c_h
#define AXP_HOST_ZERO_REG (31)
#define AXP_HOST_DEST_REG (13)
#define AXP_HOST_CALL_REG (26)
#define AXP_HOST_GDP_REG (29)
#define AxpPureAddressAdjustment (0)
#define AxpCallToRetAddrAdjustment (0)
#define AxpFpuOverflowExceptionMask (36)
#define AxpFpuOverflowExceptionBit (-1)
#define AxpFpuUnderflowExceptionBit (3)
#define AxpFpuPrecisionExceptionBit (4)
#endif /* ! _Axphst_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\acc_efi.h ===
/*    0 0000  NA   SZ_B    DFLT   DS */		ACCESS_NA_NA,
/*    1 0001  NA   SZ_B    DFLT   SS */		ACCESS_NA_NA,
/*    2 0010  NA   SZ_B    ES     DS */		ACCESS_NA_NA,
/*    3 0011  NA   SZ_B    ES     SS */		ACCESS_NA_NA,
/*    4 0020  NA   SZ_B    CS     DS */		ACCESS_NA_NA,
/*    5 0021  NA   SZ_B    CS     SS */		ACCESS_NA_NA,
/*    6 0030  NA   SZ_B    SS     DS */		ACCESS_NA_NA,
/*    7 0031  NA   SZ_B    SS     SS */		ACCESS_NA_NA,
/*    8 0040  NA   SZ_B    DS     DS */		ACCESS_NA_NA,
/*    9 0041  NA   SZ_B    DS     SS */		ACCESS_NA_NA,
/*   10 0050  NA   SZ_B    FS     DS */		ACCESS_NA_NA,
/*   11 0051  NA   SZ_B    FS     SS */		ACCESS_NA_NA,
/*   12 0060  NA   SZ_B    GS     DS */		ACCESS_NA_NA,
/*   13 0061  NA   SZ_B    GS     SS */		ACCESS_NA_NA,
/*   14 0070  NA   SZ_B    -      DS */		ACCESS_NA_NA,
/*   15 0071  NA   SZ_B    -      SS */		ACCESS_NA_NA,
/*   16 0100  NA   SZ_B    DFLT   DS */		ACCESS_NA_NA,
/*   17 0101  NA   SZ_B    DFLT   SS */		ACCESS_NA_NA,
/*   18 0110  NA   SZ_B    ES     DS */		ACCESS_NA_NA,
/*   19 0111  NA   SZ_B    ES     SS */		ACCESS_NA_NA,
/*   20 0120  NA   SZ_B    CS     DS */		ACCESS_NA_NA,
/*   21 0121  NA   SZ_B    CS     SS */		ACCESS_NA_NA,
/*   22 0130  NA   SZ_B    SS     DS */		ACCESS_NA_NA,
/*   23 0131  NA   SZ_B    SS     SS */		ACCESS_NA_NA,
/*   24 0140  NA   SZ_B    DS     DS */		ACCESS_NA_NA,
/*   25 0141  NA   SZ_B    DS     SS */		ACCESS_NA_NA,
/*   26 0150  NA   SZ_B    FS     DS */		ACCESS_NA_NA,
/*   27 0151  NA   SZ_B    FS     SS */		ACCESS_NA_NA,
/*   28 0160  NA   SZ_B    GS     DS */		ACCESS_NA_NA,
/*   29 0161  NA   SZ_B    GS     SS */		ACCESS_NA_NA,
/*   30 0170  NA   SZ_B    -      DS */		ACCESS_NA_NA,
/*   31 0171  NA   SZ_B    -      SS */		ACCESS_NA_NA,
/*   32 0200  NA   SZ_W    DFLT   DS */		ACCESS_NA_NA,
/*   33 0201  NA   SZ_W    DFLT   SS */		ACCESS_NA_NA,
/*   34 0210  NA   SZ_W    ES     DS */		ACCESS_NA_NA,
/*   35 0211  NA   SZ_W    ES     SS */		ACCESS_NA_NA,
/*   36 0220  NA   SZ_W    CS     DS */		ACCESS_NA_NA,
/*   37 0221  NA   SZ_W    CS     SS */		ACCESS_NA_NA,
/*   38 0230  NA   SZ_W    SS     DS */		ACCESS_NA_NA,
/*   39 0231  NA   SZ_W    SS     SS */		ACCESS_NA_NA,
/*   40 0240  NA   SZ_W    DS     DS */		ACCESS_NA_NA,
/*   41 0241  NA   SZ_W    DS     SS */		ACCESS_NA_NA,
/*   42 0250  NA   SZ_W    FS     DS */		ACCESS_NA_NA,
/*   43 0251  NA   SZ_W    FS     SS */		ACCESS_NA_NA,
/*   44 0260  NA   SZ_W    GS     DS */		ACCESS_NA_NA,
/*   45 0261  NA   SZ_W    GS     SS */		ACCESS_NA_NA,
/*   46 0270  NA   SZ_W    -      DS */		ACCESS_NA_NA,
/*   47 0271  NA   SZ_W    -      SS */		ACCESS_NA_NA,
/*   48 0300  NA   SZ_D    DFLT   DS */		ACCESS_NA_NA,
/*   49 0301  NA   SZ_D    DFLT   SS */		ACCESS_NA_NA,
/*   50 0310  NA   SZ_D    ES     DS */		ACCESS_NA_NA,
/*   51 0311  NA   SZ_D    ES     SS */		ACCESS_NA_NA,
/*   52 0320  NA   SZ_D    CS     DS */		ACCESS_NA_NA,
/*   53 0321  NA   SZ_D    CS     SS */		ACCESS_NA_NA,
/*   54 0330  NA   SZ_D    SS     DS */		ACCESS_NA_NA,
/*   55 0331  NA   SZ_D    SS     SS */		ACCESS_NA_NA,
/*   56 0340  NA   SZ_D    DS     DS */		ACCESS_NA_NA,
/*   57 0341  NA   SZ_D    DS     SS */		ACCESS_NA_NA,
/*   58 0350  NA   SZ_D    FS     DS */		ACCESS_NA_NA,
/*   59 0351  NA   SZ_D    FS     SS */		ACCESS_NA_NA,
/*   60 0360  NA   SZ_D    GS     DS */		ACCESS_NA_NA,
/*   61 0361  NA   SZ_D    GS     SS */		ACCESS_NA_NA,
/*   62 0370  NA   SZ_D    -      DS */		ACCESS_NA_NA,
/*   63 0371  NA   SZ_D    -      SS */		ACCESS_NA_NA,
/*   64 0400  NA   SZ_W    DFLT   DS */		ACCESS_NA_NA,
/*   65 0401  NA   SZ_W    DFLT   SS */		ACCESS_NA_NA,
/*   66 0410  NA   SZ_W    ES     DS */		ACCESS_NA_NA,
/*   67 0411  NA   SZ_W    ES     SS */		ACCESS_NA_NA,
/*   68 0420  NA   SZ_W    CS     DS */		ACCESS_NA_NA,
/*   69 0421  NA   SZ_W    CS     SS */		ACCESS_NA_NA,
/*   70 0430  NA   SZ_W    SS     DS */		ACCESS_NA_NA,
/*   71 0431  NA   SZ_W    SS     SS */		ACCESS_NA_NA,
/*   72 0440  NA   SZ_W    DS     DS */		ACCESS_NA_NA,
/*   73 0441  NA   SZ_W    DS     SS */		ACCESS_NA_NA,
/*   74 0450  NA   SZ_W    FS     DS */		ACCESS_NA_NA,
/*   75 0451  NA   SZ_W    FS     SS */		ACCESS_NA_NA,
/*   76 0460  NA   SZ_W    GS     DS */		ACCESS_NA_NA,
/*   77 0461  NA   SZ_W    GS     SS */		ACCESS_NA_NA,
/*   78 0470  NA   SZ_W    -      DS */		ACCESS_NA_NA,
/*   79 0471  NA   SZ_W    -      SS */		ACCESS_NA_NA,
/*   80 0500  NA   -       DFLT   DS */		ACCESS_NA_NA,
/*   81 0501  NA   -       DFLT   SS */		ACCESS_NA_NA,
/*   82 0510  NA   -       ES     DS */		ACCESS_NA_NA,
/*   83 0511  NA   -       ES     SS */		ACCESS_NA_NA,
/*   84 0520  NA   -       CS     DS */		ACCESS_NA_NA,
/*   85 0521  NA   -       CS     SS */		ACCESS_NA_NA,
/*   86 0530  NA   -       SS     DS */		ACCESS_NA_NA,
/*   87 0531  NA   -       SS     SS */		ACCESS_NA_NA,
/*   88 0540  NA   -       DS     DS */		ACCESS_NA_NA,
/*   89 0541  NA   -       DS     SS */		ACCESS_NA_NA,
/*   90 0550  NA   -       FS     DS */		ACCESS_NA_NA,
/*   91 0551  NA   -       FS     SS */		ACCESS_NA_NA,
/*   92 0560  NA   -       GS     DS */		ACCESS_NA_NA,
/*   93 0561  NA   -       GS     SS */		ACCESS_NA_NA,
/*   94 0570  NA   -       -      DS */		ACCESS_NA_NA,
/*   95 0571  NA   -       -      SS */		ACCESS_NA_NA,
/*   96 0600  NA   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*   97 0601  NA   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*   98 0610  NA   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*   99 0611  NA   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  100 0620  NA   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  101 0621  NA   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  102 0630  NA   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  103 0631  NA   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  104 0640  NA   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  105 0641  NA   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  106 0650  NA   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  107 0651  NA   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  108 0660  NA   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  109 0661  NA   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  110 0670  NA   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  111 0671  NA   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  112 0700  NA   SZ_WD   DFLT   DS */		ACCESS_NA_NA,
/*  113 0701  NA   SZ_WD   DFLT   SS */		ACCESS_NA_NA,
/*  114 0710  NA   SZ_WD   ES     DS */		ACCESS_NA_NA,
/*  115 0711  NA   SZ_WD   ES     SS */		ACCESS_NA_NA,
/*  116 0720  NA   SZ_WD   CS     DS */		ACCESS_NA_NA,
/*  117 0721  NA   SZ_WD   CS     SS */		ACCESS_NA_NA,
/*  118 0730  NA   SZ_WD   SS     DS */		ACCESS_NA_NA,
/*  119 0731  NA   SZ_WD   SS     SS */		ACCESS_NA_NA,
/*  120 0740  NA   SZ_WD   DS     DS */		ACCESS_NA_NA,
/*  121 0741  NA   SZ_WD   DS     SS */		ACCESS_NA_NA,
/*  122 0750  NA   SZ_WD   FS     DS */		ACCESS_NA_NA,
/*  123 0751  NA   SZ_WD   FS     SS */		ACCESS_NA_NA,
/*  124 0760  NA   SZ_WD   GS     DS */		ACCESS_NA_NA,
/*  125 0761  NA   SZ_WD   GS     SS */		ACCESS_NA_NA,
/*  126 0770  NA   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  127 0771  NA   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  128 1000  RD   SZ_B    DFLT   DS */		ACCESS_DS_RD_B,
/*  129 1001  RD   SZ_B    DFLT   SS */		ACCESS_SS_RD_B,
/*  130 1010  RD   SZ_B    ES     DS */		ACCESS_ES_RD_B,
/*  131 1011  RD   SZ_B    ES     SS */		ACCESS_ES_RD_B,
/*  132 1020  RD   SZ_B    CS     DS */		ACCESS_CS_RD_B,
/*  133 1021  RD   SZ_B    CS     SS */		ACCESS_CS_RD_B,
/*  134 1030  RD   SZ_B    SS     DS */		ACCESS_SS_RD_B,
/*  135 1031  RD   SZ_B    SS     SS */		ACCESS_SS_RD_B,
/*  136 1040  RD   SZ_B    DS     DS */		ACCESS_DS_RD_B,
/*  137 1041  RD   SZ_B    DS     SS */		ACCESS_DS_RD_B,
/*  138 1050  RD   SZ_B    FS     DS */		ACCESS_FS_RD_B,
/*  139 1051  RD   SZ_B    FS     SS */		ACCESS_FS_RD_B,
/*  140 1060  RD   SZ_B    GS     DS */		ACCESS_GS_RD_B,
/*  141 1061  RD   SZ_B    GS     SS */		ACCESS_GS_RD_B,
/*  142 1070  RD   SZ_B    -      DS */		ACCESS_NA_NA,
/*  143 1071  RD   SZ_B    -      SS */		ACCESS_NA_NA,
/*  144 1100  RD   SZ_B    DFLT   DS */		ACCESS_DS_RD_B,
/*  145 1101  RD   SZ_B    DFLT   SS */		ACCESS_SS_RD_B,
/*  146 1110  RD   SZ_B    ES     DS */		ACCESS_ES_RD_B,
/*  147 1111  RD   SZ_B    ES     SS */		ACCESS_ES_RD_B,
/*  148 1120  RD   SZ_B    CS     DS */		ACCESS_CS_RD_B,
/*  149 1121  RD   SZ_B    CS     SS */		ACCESS_CS_RD_B,
/*  150 1130  RD   SZ_B    SS     DS */		ACCESS_SS_RD_B,
/*  151 1131  RD   SZ_B    SS     SS */		ACCESS_SS_RD_B,
/*  152 1140  RD   SZ_B    DS     DS */		ACCESS_DS_RD_B,
/*  153 1141  RD   SZ_B    DS     SS */		ACCESS_DS_RD_B,
/*  154 1150  RD   SZ_B    FS     DS */		ACCESS_FS_RD_B,
/*  155 1151  RD   SZ_B    FS     SS */		ACCESS_FS_RD_B,
/*  156 1160  RD   SZ_B    GS     DS */		ACCESS_GS_RD_B,
/*  157 1161  RD   SZ_B    GS     SS */		ACCESS_GS_RD_B,
/*  158 1170  RD   SZ_B    -      DS */		ACCESS_NA_NA,
/*  159 1171  RD   SZ_B    -      SS */		ACCESS_NA_NA,
/*  160 1200  RD   SZ_W    DFLT   DS */		ACCESS_DS_RD_W,
/*  161 1201  RD   SZ_W    DFLT   SS */		ACCESS_SS_RD_W,
/*  162 1210  RD   SZ_W    ES     DS */		ACCESS_ES_RD_W,
/*  163 1211  RD   SZ_W    ES     SS */		ACCESS_ES_RD_W,
/*  164 1220  RD   SZ_W    CS     DS */		ACCESS_CS_RD_W,
/*  165 1221  RD   SZ_W    CS     SS */		ACCESS_CS_RD_W,
/*  166 1230  RD   SZ_W    SS     DS */		ACCESS_SS_RD_W,
/*  167 1231  RD   SZ_W    SS     SS */		ACCESS_SS_RD_W,
/*  168 1240  RD   SZ_W    DS     DS */		ACCESS_DS_RD_W,
/*  169 1241  RD   SZ_W    DS     SS */		ACCESS_DS_RD_W,
/*  170 1250  RD   SZ_W    FS     DS */		ACCESS_FS_RD_W,
/*  171 1251  RD   SZ_W    FS     SS */		ACCESS_FS_RD_W,
/*  172 1260  RD   SZ_W    GS     DS */		ACCESS_GS_RD_W,
/*  173 1261  RD   SZ_W    GS     SS */		ACCESS_GS_RD_W,
/*  174 1270  RD   SZ_W    -      DS */		ACCESS_NA_NA,
/*  175 1271  RD   SZ_W    -      SS */		ACCESS_NA_NA,
/*  176 1300  RD   SZ_D    DFLT   DS */		ACCESS_DS_RD_D,
/*  177 1301  RD   SZ_D    DFLT   SS */		ACCESS_SS_RD_D,
/*  178 1310  RD   SZ_D    ES     DS */		ACCESS_ES_RD_D,
/*  179 1311  RD   SZ_D    ES     SS */		ACCESS_ES_RD_D,
/*  180 1320  RD   SZ_D    CS     DS */		ACCESS_CS_RD_D,
/*  181 1321  RD   SZ_D    CS     SS */		ACCESS_CS_RD_D,
/*  182 1330  RD   SZ_D    SS     DS */		ACCESS_SS_RD_D,
/*  183 1331  RD   SZ_D    SS     SS */		ACCESS_SS_RD_D,
/*  184 1340  RD   SZ_D    DS     DS */		ACCESS_DS_RD_D,
/*  185 1341  RD   SZ_D    DS     SS */		ACCESS_DS_RD_D,
/*  186 1350  RD   SZ_D    FS     DS */		ACCESS_FS_RD_D,
/*  187 1351  RD   SZ_D    FS     SS */		ACCESS_FS_RD_D,
/*  188 1360  RD   SZ_D    GS     DS */		ACCESS_GS_RD_D,
/*  189 1361  RD   SZ_D    GS     SS */		ACCESS_GS_RD_D,
/*  190 1370  RD   SZ_D    -      DS */		ACCESS_NA_NA,
/*  191 1371  RD   SZ_D    -      SS */		ACCESS_NA_NA,
/*  192 1400  RD   SZ_W    DFLT   DS */		ACCESS_DS_RD_W,
/*  193 1401  RD   SZ_W    DFLT   SS */		ACCESS_SS_RD_W,
/*  194 1410  RD   SZ_W    ES     DS */		ACCESS_ES_RD_W,
/*  195 1411  RD   SZ_W    ES     SS */		ACCESS_ES_RD_W,
/*  196 1420  RD   SZ_W    CS     DS */		ACCESS_CS_RD_W,
/*  197 1421  RD   SZ_W    CS     SS */		ACCESS_CS_RD_W,
/*  198 1430  RD   SZ_W    SS     DS */		ACCESS_SS_RD_W,
/*  199 1431  RD   SZ_W    SS     SS */		ACCESS_SS_RD_W,
/*  200 1440  RD   SZ_W    DS     DS */		ACCESS_DS_RD_W,
/*  201 1441  RD   SZ_W    DS     SS */		ACCESS_DS_RD_W,
/*  202 1450  RD   SZ_W    FS     DS */		ACCESS_FS_RD_W,
/*  203 1451  RD   SZ_W    FS     SS */		ACCESS_FS_RD_W,
/*  204 1460  RD   SZ_W    GS     DS */		ACCESS_GS_RD_W,
/*  205 1461  RD   SZ_W    GS     SS */		ACCESS_GS_RD_W,
/*  206 1470  RD   SZ_W    -      DS */		ACCESS_NA_NA,
/*  207 1471  RD   SZ_W    -      SS */		ACCESS_NA_NA,
/*  208 1500  RD   -       DFLT   DS */		ACCESS_NA_NA,
/*  209 1501  RD   -       DFLT   SS */		ACCESS_NA_NA,
/*  210 1510  RD   -       ES     DS */		ACCESS_NA_NA,
/*  211 1511  RD   -       ES     SS */		ACCESS_NA_NA,
/*  212 1520  RD   -       CS     DS */		ACCESS_NA_NA,
/*  213 1521  RD   -       CS     SS */		ACCESS_NA_NA,
/*  214 1530  RD   -       SS     DS */		ACCESS_NA_NA,
/*  215 1531  RD   -       SS     SS */		ACCESS_NA_NA,
/*  216 1540  RD   -       DS     DS */		ACCESS_NA_NA,
/*  217 1541  RD   -       DS     SS */		ACCESS_NA_NA,
/*  218 1550  RD   -       FS     DS */		ACCESS_NA_NA,
/*  219 1551  RD   -       FS     SS */		ACCESS_NA_NA,
/*  220 1560  RD   -       GS     DS */		ACCESS_NA_NA,
/*  221 1561  RD   -       GS     SS */		ACCESS_NA_NA,
/*  222 1570  RD   -       -      DS */		ACCESS_NA_NA,
/*  223 1571  RD   -       -      SS */		ACCESS_NA_NA,
/*  224 1600  RD   SZ_W2   DFLT   DS */		ACCESS_DS_RD_W2,
/*  225 1601  RD   SZ_W2   DFLT   SS */		ACCESS_SS_RD_W2,
/*  226 1610  RD   SZ_W2   ES     DS */		ACCESS_ES_RD_W2,
/*  227 1611  RD   SZ_W2   ES     SS */		ACCESS_ES_RD_W2,
/*  228 1620  RD   SZ_W2   CS     DS */		ACCESS_CS_RD_W2,
/*  229 1621  RD   SZ_W2   CS     SS */		ACCESS_CS_RD_W2,
/*  230 1630  RD   SZ_W2   SS     DS */		ACCESS_SS_RD_W2,
/*  231 1631  RD   SZ_W2   SS     SS */		ACCESS_SS_RD_W2,
/*  232 1640  RD   SZ_W2   DS     DS */		ACCESS_DS_RD_W2,
/*  233 1641  RD   SZ_W2   DS     SS */		ACCESS_DS_RD_W2,
/*  234 1650  RD   SZ_W2   FS     DS */		ACCESS_FS_RD_W2,
/*  235 1651  RD   SZ_W2   FS     SS */		ACCESS_FS_RD_W2,
/*  236 1660  RD   SZ_W2   GS     DS */		ACCESS_GS_RD_W2,
/*  237 1661  RD   SZ_W2   GS     SS */		ACCESS_GS_RD_W2,
/*  238 1670  RD   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  239 1671  RD   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  240 1700  RD   SZ_WD   DFLT   DS */		ACCESS_DS_RD_WD,
/*  241 1701  RD   SZ_WD   DFLT   SS */		ACCESS_SS_RD_WD,
/*  242 1710  RD   SZ_WD   ES     DS */		ACCESS_ES_RD_WD,
/*  243 1711  RD   SZ_WD   ES     SS */		ACCESS_ES_RD_WD,
/*  244 1720  RD   SZ_WD   CS     DS */		ACCESS_CS_RD_WD,
/*  245 1721  RD   SZ_WD   CS     SS */		ACCESS_CS_RD_WD,
/*  246 1730  RD   SZ_WD   SS     DS */		ACCESS_SS_RD_WD,
/*  247 1731  RD   SZ_WD   SS     SS */		ACCESS_SS_RD_WD,
/*  248 1740  RD   SZ_WD   DS     DS */		ACCESS_DS_RD_WD,
/*  249 1741  RD   SZ_WD   DS     SS */		ACCESS_DS_RD_WD,
/*  250 1750  RD   SZ_WD   FS     DS */		ACCESS_FS_RD_WD,
/*  251 1751  RD   SZ_WD   FS     SS */		ACCESS_FS_RD_WD,
/*  252 1760  RD   SZ_WD   GS     DS */		ACCESS_GS_RD_WD,
/*  253 1761  RD   SZ_WD   GS     SS */		ACCESS_GS_RD_WD,
/*  254 1770  RD   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  255 1771  RD   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  256 2000  WT   SZ_B    DFLT   DS */		ACCESS_DS_WT_B,
/*  257 2001  WT   SZ_B    DFLT   SS */		ACCESS_SS_WT_B,
/*  258 2010  WT   SZ_B    ES     DS */		ACCESS_ES_WT_B,
/*  259 2011  WT   SZ_B    ES     SS */		ACCESS_ES_WT_B,
/*  260 2020  WT   SZ_B    CS     DS */		ACCESS_CS_WT_B,
/*  261 2021  WT   SZ_B    CS     SS */		ACCESS_CS_WT_B,
/*  262 2030  WT   SZ_B    SS     DS */		ACCESS_SS_WT_B,
/*  263 2031  WT   SZ_B    SS     SS */		ACCESS_SS_WT_B,
/*  264 2040  WT   SZ_B    DS     DS */		ACCESS_DS_WT_B,
/*  265 2041  WT   SZ_B    DS     SS */		ACCESS_DS_WT_B,
/*  266 2050  WT   SZ_B    FS     DS */		ACCESS_FS_WT_B,
/*  267 2051  WT   SZ_B    FS     SS */		ACCESS_FS_WT_B,
/*  268 2060  WT   SZ_B    GS     DS */		ACCESS_GS_WT_B,
/*  269 2061  WT   SZ_B    GS     SS */		ACCESS_GS_WT_B,
/*  270 2070  WT   SZ_B    -      DS */		ACCESS_NA_NA,
/*  271 2071  WT   SZ_B    -      SS */		ACCESS_NA_NA,
/*  272 2100  WT   SZ_B    DFLT   DS */		ACCESS_DS_WT_B,
/*  273 2101  WT   SZ_B    DFLT   SS */		ACCESS_SS_WT_B,
/*  274 2110  WT   SZ_B    ES     DS */		ACCESS_ES_WT_B,
/*  275 2111  WT   SZ_B    ES     SS */		ACCESS_ES_WT_B,
/*  276 2120  WT   SZ_B    CS     DS */		ACCESS_CS_WT_B,
/*  277 2121  WT   SZ_B    CS     SS */		ACCESS_CS_WT_B,
/*  278 2130  WT   SZ_B    SS     DS */		ACCESS_SS_WT_B,
/*  279 2131  WT   SZ_B    SS     SS */		ACCESS_SS_WT_B,
/*  280 2140  WT   SZ_B    DS     DS */		ACCESS_DS_WT_B,
/*  281 2141  WT   SZ_B    DS     SS */		ACCESS_DS_WT_B,
/*  282 2150  WT   SZ_B    FS     DS */		ACCESS_FS_WT_B,
/*  283 2151  WT   SZ_B    FS     SS */		ACCESS_FS_WT_B,
/*  284 2160  WT   SZ_B    GS     DS */		ACCESS_GS_WT_B,
/*  285 2161  WT   SZ_B    GS     SS */		ACCESS_GS_WT_B,
/*  286 2170  WT   SZ_B    -      DS */		ACCESS_NA_NA,
/*  287 2171  WT   SZ_B    -      SS */		ACCESS_NA_NA,
/*  288 2200  WT   SZ_W    DFLT   DS */		ACCESS_DS_WT_W,
/*  289 2201  WT   SZ_W    DFLT   SS */		ACCESS_SS_WT_W,
/*  290 2210  WT   SZ_W    ES     DS */		ACCESS_ES_WT_W,
/*  291 2211  WT   SZ_W    ES     SS */		ACCESS_ES_WT_W,
/*  292 2220  WT   SZ_W    CS     DS */		ACCESS_CS_WT_W,
/*  293 2221  WT   SZ_W    CS     SS */		ACCESS_CS_WT_W,
/*  294 2230  WT   SZ_W    SS     DS */		ACCESS_SS_WT_W,
/*  295 2231  WT   SZ_W    SS     SS */		ACCESS_SS_WT_W,
/*  296 2240  WT   SZ_W    DS     DS */		ACCESS_DS_WT_W,
/*  297 2241  WT   SZ_W    DS     SS */		ACCESS_DS_WT_W,
/*  298 2250  WT   SZ_W    FS     DS */		ACCESS_FS_WT_W,
/*  299 2251  WT   SZ_W    FS     SS */		ACCESS_FS_WT_W,
/*  300 2260  WT   SZ_W    GS     DS */		ACCESS_GS_WT_W,
/*  301 2261  WT   SZ_W    GS     SS */		ACCESS_GS_WT_W,
/*  302 2270  WT   SZ_W    -      DS */		ACCESS_NA_NA,
/*  303 2271  WT   SZ_W    -      SS */		ACCESS_NA_NA,
/*  304 2300  WT   SZ_D    DFLT   DS */		ACCESS_DS_WT_D,
/*  305 2301  WT   SZ_D    DFLT   SS */		ACCESS_SS_WT_D,
/*  306 2310  WT   SZ_D    ES     DS */		ACCESS_ES_WT_D,
/*  307 2311  WT   SZ_D    ES     SS */		ACCESS_ES_WT_D,
/*  308 2320  WT   SZ_D    CS     DS */		ACCESS_CS_WT_D,
/*  309 2321  WT   SZ_D    CS     SS */		ACCESS_CS_WT_D,
/*  310 2330  WT   SZ_D    SS     DS */		ACCESS_SS_WT_D,
/*  311 2331  WT   SZ_D    SS     SS */		ACCESS_SS_WT_D,
/*  312 2340  WT   SZ_D    DS     DS */		ACCESS_DS_WT_D,
/*  313 2341  WT   SZ_D    DS     SS */		ACCESS_DS_WT_D,
/*  314 2350  WT   SZ_D    FS     DS */		ACCESS_FS_WT_D,
/*  315 2351  WT   SZ_D    FS     SS */		ACCESS_FS_WT_D,
/*  316 2360  WT   SZ_D    GS     DS */		ACCESS_GS_WT_D,
/*  317 2361  WT   SZ_D    GS     SS */		ACCESS_GS_WT_D,
/*  318 2370  WT   SZ_D    -      DS */		ACCESS_NA_NA,
/*  319 2371  WT   SZ_D    -      SS */		ACCESS_NA_NA,
/*  320 2400  WT   SZ_W    DFLT   DS */		ACCESS_DS_WT_W,
/*  321 2401  WT   SZ_W    DFLT   SS */		ACCESS_SS_WT_W,
/*  322 2410  WT   SZ_W    ES     DS */		ACCESS_ES_WT_W,
/*  323 2411  WT   SZ_W    ES     SS */		ACCESS_ES_WT_W,
/*  324 2420  WT   SZ_W    CS     DS */		ACCESS_CS_WT_W,
/*  325 2421  WT   SZ_W    CS     SS */		ACCESS_CS_WT_W,
/*  326 2430  WT   SZ_W    SS     DS */		ACCESS_SS_WT_W,
/*  327 2431  WT   SZ_W    SS     SS */		ACCESS_SS_WT_W,
/*  328 2440  WT   SZ_W    DS     DS */		ACCESS_DS_WT_W,
/*  329 2441  WT   SZ_W    DS     SS */		ACCESS_DS_WT_W,
/*  330 2450  WT   SZ_W    FS     DS */		ACCESS_FS_WT_W,
/*  331 2451  WT   SZ_W    FS     SS */		ACCESS_FS_WT_W,
/*  332 2460  WT   SZ_W    GS     DS */		ACCESS_GS_WT_W,
/*  333 2461  WT   SZ_W    GS     SS */		ACCESS_GS_WT_W,
/*  334 2470  WT   SZ_W    -      DS */		ACCESS_NA_NA,
/*  335 2471  WT   SZ_W    -      SS */		ACCESS_NA_NA,
/*  336 2500  WT   -       DFLT   DS */		ACCESS_NA_NA,
/*  337 2501  WT   -       DFLT   SS */		ACCESS_NA_NA,
/*  338 2510  WT   -       ES     DS */		ACCESS_NA_NA,
/*  339 2511  WT   -       ES     SS */		ACCESS_NA_NA,
/*  340 2520  WT   -       CS     DS */		ACCESS_NA_NA,
/*  341 2521  WT   -       CS     SS */		ACCESS_NA_NA,
/*  342 2530  WT   -       SS     DS */		ACCESS_NA_NA,
/*  343 2531  WT   -       SS     SS */		ACCESS_NA_NA,
/*  344 2540  WT   -       DS     DS */		ACCESS_NA_NA,
/*  345 2541  WT   -       DS     SS */		ACCESS_NA_NA,
/*  346 2550  WT   -       FS     DS */		ACCESS_NA_NA,
/*  347 2551  WT   -       FS     SS */		ACCESS_NA_NA,
/*  348 2560  WT   -       GS     DS */		ACCESS_NA_NA,
/*  349 2561  WT   -       GS     SS */		ACCESS_NA_NA,
/*  350 2570  WT   -       -      DS */		ACCESS_NA_NA,
/*  351 2571  WT   -       -      SS */		ACCESS_NA_NA,
/*  352 2600  WT   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*  353 2601  WT   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*  354 2610  WT   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*  355 2611  WT   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  356 2620  WT   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  357 2621  WT   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  358 2630  WT   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  359 2631  WT   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  360 2640  WT   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  361 2641  WT   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  362 2650  WT   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  363 2651  WT   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  364 2660  WT   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  365 2661  WT   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  366 2670  WT   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  367 2671  WT   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  368 2700  WT   SZ_WD   DFLT   DS */		ACCESS_DS_WT_WD,
/*  369 2701  WT   SZ_WD   DFLT   SS */		ACCESS_SS_WT_WD,
/*  370 2710  WT   SZ_WD   ES     DS */		ACCESS_ES_WT_WD,
/*  371 2711  WT   SZ_WD   ES     SS */		ACCESS_ES_WT_WD,
/*  372 2720  WT   SZ_WD   CS     DS */		ACCESS_CS_WT_WD,
/*  373 2721  WT   SZ_WD   CS     SS */		ACCESS_CS_WT_WD,
/*  374 2730  WT   SZ_WD   SS     DS */		ACCESS_SS_WT_WD,
/*  375 2731  WT   SZ_WD   SS     SS */		ACCESS_SS_WT_WD,
/*  376 2740  WT   SZ_WD   DS     DS */		ACCESS_DS_WT_WD,
/*  377 2741  WT   SZ_WD   DS     SS */		ACCESS_DS_WT_WD,
/*  378 2750  WT   SZ_WD   FS     DS */		ACCESS_FS_WT_WD,
/*  379 2751  WT   SZ_WD   FS     SS */		ACCESS_FS_WT_WD,
/*  380 2760  WT   SZ_WD   GS     DS */		ACCESS_GS_WT_WD,
/*  381 2761  WT   SZ_WD   GS     SS */		ACCESS_GS_WT_WD,
/*  382 2770  WT   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  383 2771  WT   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  384 3000  RW   SZ_B    DFLT   DS */		ACCESS_DS_RW_B,
/*  385 3001  RW   SZ_B    DFLT   SS */		ACCESS_SS_RW_B,
/*  386 3010  RW   SZ_B    ES     DS */		ACCESS_ES_RW_B,
/*  387 3011  RW   SZ_B    ES     SS */		ACCESS_ES_RW_B,
/*  388 3020  RW   SZ_B    CS     DS */		ACCESS_CS_RW_B,
/*  389 3021  RW   SZ_B    CS     SS */		ACCESS_CS_RW_B,
/*  390 3030  RW   SZ_B    SS     DS */		ACCESS_SS_RW_B,
/*  391 3031  RW   SZ_B    SS     SS */		ACCESS_SS_RW_B,
/*  392 3040  RW   SZ_B    DS     DS */		ACCESS_DS_RW_B,
/*  393 3041  RW   SZ_B    DS     SS */		ACCESS_DS_RW_B,
/*  394 3050  RW   SZ_B    FS     DS */		ACCESS_FS_RW_B,
/*  395 3051  RW   SZ_B    FS     SS */		ACCESS_FS_RW_B,
/*  396 3060  RW   SZ_B    GS     DS */		ACCESS_GS_RW_B,
/*  397 3061  RW   SZ_B    GS     SS */		ACCESS_GS_RW_B,
/*  398 3070  RW   SZ_B    -      DS */		ACCESS_NA_NA,
/*  399 3071  RW   SZ_B    -      SS */		ACCESS_NA_NA,
/*  400 3100  RW   SZ_B    DFLT   DS */		ACCESS_DS_RW_B,
/*  401 3101  RW   SZ_B    DFLT   SS */		ACCESS_SS_RW_B,
/*  402 3110  RW   SZ_B    ES     DS */		ACCESS_ES_RW_B,
/*  403 3111  RW   SZ_B    ES     SS */		ACCESS_ES_RW_B,
/*  404 3120  RW   SZ_B    CS     DS */		ACCESS_CS_RW_B,
/*  405 3121  RW   SZ_B    CS     SS */		ACCESS_CS_RW_B,
/*  406 3130  RW   SZ_B    SS     DS */		ACCESS_SS_RW_B,
/*  407 3131  RW   SZ_B    SS     SS */		ACCESS_SS_RW_B,
/*  408 3140  RW   SZ_B    DS     DS */		ACCESS_DS_RW_B,
/*  409 3141  RW   SZ_B    DS     SS */		ACCESS_DS_RW_B,
/*  410 3150  RW   SZ_B    FS     DS */		ACCESS_FS_RW_B,
/*  411 3151  RW   SZ_B    FS     SS */		ACCESS_FS_RW_B,
/*  412 3160  RW   SZ_B    GS     DS */		ACCESS_GS_RW_B,
/*  413 3161  RW   SZ_B    GS     SS */		ACCESS_GS_RW_B,
/*  414 3170  RW   SZ_B    -      DS */		ACCESS_NA_NA,
/*  415 3171  RW   SZ_B    -      SS */		ACCESS_NA_NA,
/*  416 3200  RW   SZ_W    DFLT   DS */		ACCESS_DS_RW_W,
/*  417 3201  RW   SZ_W    DFLT   SS */		ACCESS_SS_RW_W,
/*  418 3210  RW   SZ_W    ES     DS */		ACCESS_ES_RW_W,
/*  419 3211  RW   SZ_W    ES     SS */		ACCESS_ES_RW_W,
/*  420 3220  RW   SZ_W    CS     DS */		ACCESS_CS_RW_W,
/*  421 3221  RW   SZ_W    CS     SS */		ACCESS_CS_RW_W,
/*  422 3230  RW   SZ_W    SS     DS */		ACCESS_SS_RW_W,
/*  423 3231  RW   SZ_W    SS     SS */		ACCESS_SS_RW_W,
/*  424 3240  RW   SZ_W    DS     DS */		ACCESS_DS_RW_W,
/*  425 3241  RW   SZ_W    DS     SS */		ACCESS_DS_RW_W,
/*  426 3250  RW   SZ_W    FS     DS */		ACCESS_FS_RW_W,
/*  427 3251  RW   SZ_W    FS     SS */		ACCESS_FS_RW_W,
/*  428 3260  RW   SZ_W    GS     DS */		ACCESS_GS_RW_W,
/*  429 3261  RW   SZ_W    GS     SS */		ACCESS_GS_RW_W,
/*  430 3270  RW   SZ_W    -      DS */		ACCESS_NA_NA,
/*  431 3271  RW   SZ_W    -      SS */		ACCESS_NA_NA,
/*  432 3300  RW   SZ_D    DFLT   DS */		ACCESS_DS_RW_D,
/*  433 3301  RW   SZ_D    DFLT   SS */		ACCESS_SS_RW_D,
/*  434 3310  RW   SZ_D    ES     DS */		ACCESS_ES_RW_D,
/*  435 3311  RW   SZ_D    ES     SS */		ACCESS_ES_RW_D,
/*  436 3320  RW   SZ_D    CS     DS */		ACCESS_CS_RW_D,
/*  437 3321  RW   SZ_D    CS     SS */		ACCESS_CS_RW_D,
/*  438 3330  RW   SZ_D    SS     DS */		ACCESS_SS_RW_D,
/*  439 3331  RW   SZ_D    SS     SS */		ACCESS_SS_RW_D,
/*  440 3340  RW   SZ_D    DS     DS */		ACCESS_DS_RW_D,
/*  441 3341  RW   SZ_D    DS     SS */		ACCESS_DS_RW_D,
/*  442 3350  RW   SZ_D    FS     DS */		ACCESS_FS_RW_D,
/*  443 3351  RW   SZ_D    FS     SS */		ACCESS_FS_RW_D,
/*  444 3360  RW   SZ_D    GS     DS */		ACCESS_GS_RW_D,
/*  445 3361  RW   SZ_D    GS     SS */		ACCESS_GS_RW_D,
/*  446 3370  RW   SZ_D    -      DS */		ACCESS_NA_NA,
/*  447 3371  RW   SZ_D    -      SS */		ACCESS_NA_NA,
/*  448 3400  RW   SZ_W    DFLT   DS */		ACCESS_DS_RW_W,
/*  449 3401  RW   SZ_W    DFLT   SS */		ACCESS_SS_RW_W,
/*  450 3410  RW   SZ_W    ES     DS */		ACCESS_ES_RW_W,
/*  451 3411  RW   SZ_W    ES     SS */		ACCESS_ES_RW_W,
/*  452 3420  RW   SZ_W    CS     DS */		ACCESS_CS_RW_W,
/*  453 3421  RW   SZ_W    CS     SS */		ACCESS_CS_RW_W,
/*  454 3430  RW   SZ_W    SS     DS */		ACCESS_SS_RW_W,
/*  455 3431  RW   SZ_W    SS     SS */		ACCESS_SS_RW_W,
/*  456 3440  RW   SZ_W    DS     DS */		ACCESS_DS_RW_W,
/*  457 3441  RW   SZ_W    DS     SS */		ACCESS_DS_RW_W,
/*  458 3450  RW   SZ_W    FS     DS */		ACCESS_FS_RW_W,
/*  459 3451  RW   SZ_W    FS     SS */		ACCESS_FS_RW_W,
/*  460 3460  RW   SZ_W    GS     DS */		ACCESS_GS_RW_W,
/*  461 3461  RW   SZ_W    GS     SS */		ACCESS_GS_RW_W,
/*  462 3470  RW   SZ_W    -      DS */		ACCESS_NA_NA,
/*  463 3471  RW   SZ_W    -      SS */		ACCESS_NA_NA,
/*  464 3500  RW   -       DFLT   DS */		ACCESS_NA_NA,
/*  465 3501  RW   -       DFLT   SS */		ACCESS_NA_NA,
/*  466 3510  RW   -       ES     DS */		ACCESS_NA_NA,
/*  467 3511  RW   -       ES     SS */		ACCESS_NA_NA,
/*  468 3520  RW   -       CS     DS */		ACCESS_NA_NA,
/*  469 3521  RW   -       CS     SS */		ACCESS_NA_NA,
/*  470 3530  RW   -       SS     DS */		ACCESS_NA_NA,
/*  471 3531  RW   -       SS     SS */		ACCESS_NA_NA,
/*  472 3540  RW   -       DS     DS */		ACCESS_NA_NA,
/*  473 3541  RW   -       DS     SS */		ACCESS_NA_NA,
/*  474 3550  RW   -       FS     DS */		ACCESS_NA_NA,
/*  475 3551  RW   -       FS     SS */		ACCESS_NA_NA,
/*  476 3560  RW   -       GS     DS */		ACCESS_NA_NA,
/*  477 3561  RW   -       GS     SS */		ACCESS_NA_NA,
/*  478 3570  RW   -       -      DS */		ACCESS_NA_NA,
/*  479 3571  RW   -       -      SS */		ACCESS_NA_NA,
/*  480 3600  RW   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*  481 3601  RW   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*  482 3610  RW   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*  483 3611  RW   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  484 3620  RW   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  485 3621  RW   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  486 3630  RW   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  487 3631  RW   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  488 3640  RW   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  489 3641  RW   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  490 3650  RW   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  491 3651  RW   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  492 3660  RW   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  493 3661  RW   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  494 3670  RW   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  495 3671  RW   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  496 3700  RW   SZ_WD   DFLT   DS */		ACCESS_NA_NA,
/*  497 3701  RW   SZ_WD   DFLT   SS */		ACCESS_NA_NA,
/*  498 3710  RW   SZ_WD   ES     DS */		ACCESS_NA_NA,
/*  499 3711  RW   SZ_WD   ES     SS */		ACCESS_NA_NA,
/*  500 3720  RW   SZ_WD   CS     DS */		ACCESS_NA_NA,
/*  501 3721  RW   SZ_WD   CS     SS */		ACCESS_NA_NA,
/*  502 3730  RW   SZ_WD   SS     DS */		ACCESS_NA_NA,
/*  503 3731  RW   SZ_WD   SS     SS */		ACCESS_NA_NA,
/*  504 3740  RW   SZ_WD   DS     DS */		ACCESS_NA_NA,
/*  505 3741  RW   SZ_WD   DS     SS */		ACCESS_NA_NA,
/*  506 3750  RW   SZ_WD   FS     DS */		ACCESS_NA_NA,
/*  507 3751  RW   SZ_WD   FS     SS */		ACCESS_NA_NA,
/*  508 3760  RW   SZ_WD   GS     DS */		ACCESS_NA_NA,
/*  509 3761  RW   SZ_WD   GS     SS */		ACCESS_NA_NA,
/*  510 3770  RW   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  511 3771  RW   SZ_WD   -      SS */		ACCESS_NA_NA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\accessfn.c ===
/*[
 * Generated File: accessfn.c
 *
]*/

#ifndef	PROD
#include	"insignia.h"
#include	"host_inc.h"
#include	"host_def.h"
#include	"Fpu_c.h"
#include	"Pigger_c.h"
#include	"Univer_c.h"
#define	CPU_PRIVATE
#include	"cpu4.h"
#include	"sas.h"
#include	"evidgen.h"

void	cpu_simulate	IFN0()
{
	(*(Cpu.Simulate))();
}

void	cpu_interrupt	IFN2(CPU_INT_TYPE, intType, IU16, intNum)
{
	(*(Cpu.Interrupt))(intType, intNum);
}

void	cpu_clearHwInt	IFN0()
{
	(*(Cpu.ClearHwInt))();
}

void	cpu_EOA_hook	IFN0()
{
	(*(Cpu.EndOfApplication))();
}

void	cpu_terminate	IFN0()
{
	(*(Cpu.Terminate))();
}

void	cpu_init	IFN0()
{
	(*(Cpu.Initialise))();
}

void	host_q_ev_set_count	IFN1(IU32, val)
{
	(*(Cpu.SetQuickEventCount))(val);
}

IU32	host_q_ev_get_count	IFN0()
{
	IU32 count;
	count = (*(Cpu.GetQuickEventCount))();
	return count;
}

IU32	host_calc_q_ev_inst_for_time	IFN1(IU32, val)
{
	IU32 result;
	result = (*(Cpu.CalcQuickEventInstTime))(val);
	return result;
}

void	cpu_init_ios_in	IFN4(IHP, InTables, IHP, OutTables, IUH, maxAdaptor, IU16, portMask)
{
	(*(Cpu.InitIOS))(InTables, OutTables, maxAdaptor, portMask);
}

void	ios_define_inb	IFN2(IUH, adaptor, IHP, func)
{
	(*(Cpu.DefineInb))(adaptor, func);
}

void	ios_define_inw	IFN2(IUH, adaptor, IHP, func)
{
	(*(Cpu.DefineInw))(adaptor, func);
}

void	ios_define_ind	IFN2(IUH, adaptor, IHP, func)
{
	(*(Cpu.DefineInd))(adaptor, func);
}

void	ios_define_outb	IFN2(IUH, adaptor, IHP, func)
{
	(*(Cpu.DefineOutb))(adaptor, func);
}

void	ios_define_outw	IFN2(IUH, adaptor, IHP, func)
{
	(*(Cpu.DefineOutw))(adaptor, func);
}

void	ios_define_outd	IFN2(IUH, adaptor, IHP, func)
{
	(*(Cpu.DefineOutd))(adaptor, func);
}

void	setAL	IFN1(IU8, val)
{
	(*(Cpu.SetAL))(val);
}

void	setAH	IFN1(IU8, val)
{
	(*(Cpu.SetAH))(val);
}

void	setAX	IFN1(IU16, val)
{
	(*(Cpu.SetAX))(val);
}

void	setEAX	IFN1(IU32, val)
{
	(*(Cpu.SetEAX))(val);
}

void	setBL	IFN1(IU8, val)
{
	(*(Cpu.SetBL))(val);
}

void	setBH	IFN1(IU8, val)
{
	(*(Cpu.SetBH))(val);
}

void	setBX	IFN1(IU16, val)
{
	(*(Cpu.SetBX))(val);
}

void	setEBX	IFN1(IU32, val)
{
	(*(Cpu.SetEBX))(val);
}

void	setCL	IFN1(IU8, val)
{
	(*(Cpu.SetCL))(val);
}

void	setCH	IFN1(IU8, val)
{
	(*(Cpu.SetCH))(val);
}

void	setCX	IFN1(IU16, val)
{
	(*(Cpu.SetCX))(val);
}

void	setECX	IFN1(IU32, val)
{
	(*(Cpu.SetECX))(val);
}

void	setDL	IFN1(IU8, val)
{
	(*(Cpu.SetDL))(val);
}

void	setDH	IFN1(IU8, val)
{
	(*(Cpu.SetDH))(val);
}

void	setDX	IFN1(IU16, val)
{
	(*(Cpu.SetDX))(val);
}

void	setEDX	IFN1(IU32, val)
{
	(*(Cpu.SetEDX))(val);
}

void	setSI	IFN1(IU16, val)
{
	(*(Cpu.SetSI))(val);
}

void	setESI	IFN1(IU32, val)
{
	(*(Cpu.SetESI))(val);
}

void	setDI	IFN1(IU16, val)
{
	(*(Cpu.SetDI))(val);
}

void	setEDI	IFN1(IU32, val)
{
	(*(Cpu.SetEDI))(val);
}

void	setSP	IFN1(IU16, val)
{
	(*(Cpu.SetSP))(val);
}

void	setESP	IFN1(IU32, val)
{
	(*(Cpu.SetESP))(val);
}

void	setBP	IFN1(IU16, val)
{
	(*(Cpu.SetBP))(val);
}

void	setEBP	IFN1(IU32, val)
{
	(*(Cpu.SetEBP))(val);
}

void	setIP	IFN1(IU16, val)
{
	(*(Cpu.SetIP))(val);
}

void	setEIP	IFN1(IU32, val)
{
	(*(Cpu.SetEIP))(val);
}

IUH	setCS	IFN1(IU16, val)
{
	IUH err;
	err = (*(Cpu.SetCS))(val);
	return err;
}

IUH	setSS	IFN1(IU16, val)
{
	IUH err;
	err = (*(Cpu.SetSS))(val);
	return err;
}

IUH	setDS	IFN1(IU16, val)
{
	IUH err;
	err = (*(Cpu.SetDS))(val);
	return err;
}

IUH	setES	IFN1(IU16, val)
{
	IUH err;
	err = (*(Cpu.SetES))(val);
	return err;
}

IUH	setFS	IFN1(IU16, val)
{
	IUH err;
	err = (*(Cpu.SetFS))(val);
	return err;
}

IUH	setGS	IFN1(IU16, val)
{
	IUH err;
	err = (*(Cpu.SetGS))(val);
	return err;
}

void	setEFLAGS	IFN1(IU32, val)
{
	(*(Cpu.SetEFLAGS))(val);
}

void	setSTATUS	IFN1(IU16, val)
{
	(*(Cpu.SetSTATUS))(val);
}

void	setIOPL	IFN1(IU8, val)
{
	(*(Cpu.SetIOPL))(val);
}

void	setMSW	IFN1(IU16, val)
{
	(*(Cpu.SetMSW))(val);
}

void	setCR0	IFN1(IU32, val)
{
	(*(Cpu.SetCR0))(val);
}

void	setCR2	IFN1(IU32, val)
{
	(*(Cpu.SetCR2))(val);
}

void	setCR3	IFN1(IU32, val)
{
	(*(Cpu.SetCR3))(val);
}

void	setCF	IFN1(IBOOL, val)
{
	(*(Cpu.SetCF))(val);
}

void	setPF	IFN1(IBOOL, val)
{
	(*(Cpu.SetPF))(val);
}

void	setAF	IFN1(IBOOL, val)
{
	(*(Cpu.SetAF))(val);
}

void	setZF	IFN1(IBOOL, val)
{
	(*(Cpu.SetZF))(val);
}

void	setSF	IFN1(IBOOL, val)
{
	(*(Cpu.SetSF))(val);
}

void	setTF	IFN1(IBOOL, val)
{
	(*(Cpu.SetTF))(val);
}

void	setIF	IFN1(IBOOL, val)
{
	(*(Cpu.SetIF))(val);
}

void	setDF	IFN1(IBOOL, val)
{
	(*(Cpu.SetDF))(val);
}

void	setOF	IFN1(IBOOL, val)
{
	(*(Cpu.SetOF))(val);
}

void	setNT	IFN1(IBOOL, val)
{
	(*(Cpu.SetNT))(val);
}

void	setRF	IFN1(IBOOL, val)
{
	(*(Cpu.SetRF))(val);
}

void	setVM	IFN1(IBOOL, val)
{
	(*(Cpu.SetVM))(val);
}

void	setAC	IFN1(IBOOL, val)
{
	(*(Cpu.SetAC))(val);
}

void	setPE	IFN1(IBOOL, val)
{
	(*(Cpu.SetPE))(val);
}

void	setMP	IFN1(IBOOL, val)
{
	(*(Cpu.SetMP))(val);
}

void	setEM	IFN1(IBOOL, val)
{
	(*(Cpu.SetEM))(val);
}

void	setTS	IFN1(IBOOL, val)
{
	(*(Cpu.SetTS))(val);
}

void	setPG	IFN1(IBOOL, val)
{
	(*(Cpu.SetPG))(val);
}

void	setLDT_SELECTOR	IFN1(IU16, val)
{
	(*(Cpu.SetLDT_SELECTOR))(val);
}

void	setTR_SELECTOR	IFN1(IU16, val)
{
	(*(Cpu.SetTR_SELECTOR))(val);
}

IU8	getAL	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetAL))();
	return result;
}

IU8	getAH	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetAH))();
	return result;
}

IU16	getAX	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetAX))();
	return result;
}

IU32	getEAX	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetEAX))();
	return result;
}

IU8	getBL	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetBL))();
	return result;
}

IU8	getBH	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetBH))();
	return result;
}

IU16	getBX	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetBX))();
	return result;
}

IU32	getEBX	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetEBX))();
	return result;
}

IU8	getCL	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetCL))();
	return result;
}

IU8	getCH	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetCH))();
	return result;
}

IU16	getCX	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetCX))();
	return result;
}

IU32	getECX	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetECX))();
	return result;
}

IU8	getDL	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetDL))();
	return result;
}

IU8	getDH	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetDH))();
	return result;
}

IU16	getDX	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetDX))();
	return result;
}

IU32	getEDX	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetEDX))();
	return result;
}

IU16	getSI	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetSI))();
	return result;
}

IU32	getESI	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetESI))();
	return result;
}

IU16	getDI	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetDI))();
	return result;
}

IU32	getEDI	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetEDI))();
	return result;
}

IU16	getSP	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetSP))();
	return result;
}

IU32	getESP	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetESP))();
	return result;
}

IU16	getBP	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetBP))();
	return result;
}

IU32	getEBP	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetEBP))();
	return result;
}

IU16	getIP	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetIP))();
	return result;
}

IU32	getEIP	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetEIP))();
	return result;
}

IU16	getCS	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetCS))();
	return result;
}

IU16	getSS	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetSS))();
	return result;
}

IU16	getDS	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetDS))();
	return result;
}

IU16	getES	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetES))();
	return result;
}

IU16	getFS	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetFS))();
	return result;
}

IU16	getGS	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetGS))();
	return result;
}

IU32	getEFLAGS	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetEFLAGS))();
	return result;
}

IU16	getSTATUS	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetSTATUS))();
	return result;
}

IU8	getIOPL	IFN0()
{
	IU8 result;
	result = (*(Cpu.GetIOPL))();
	return result;
}

IU16	getMSW	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetMSW))();
	return result;
}

IU32	getCR0	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetCR0))();
	return result;
}

IU32	getCR2	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetCR2))();
	return result;
}

IU32	getCR3	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetCR3))();
	return result;
}

IBOOL	getCF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetCF))();
	return result;
}

IBOOL	getPF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetPF))();
	return result;
}

IBOOL	getAF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetAF))();
	return result;
}

IBOOL	getZF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetZF))();
	return result;
}

IBOOL	getSF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetSF))();
	return result;
}

IBOOL	getTF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetTF))();
	return result;
}

IBOOL	getIF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetIF))();
	return result;
}

IBOOL	getDF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetDF))();
	return result;
}

IBOOL	getOF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetOF))();
	return result;
}

IBOOL	getNT	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetNT))();
	return result;
}

IBOOL	getRF	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetRF))();
	return result;
}

IBOOL	getVM	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetVM))();
	return result;
}

IBOOL	getAC	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetAC))();
	return result;
}

IBOOL	getPE	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetPE))();
	return result;
}

IBOOL	getMP	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetMP))();
	return result;
}

IBOOL	getEM	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetEM))();
	return result;
}

IBOOL	getTS	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetTS))();
	return result;
}

IBOOL	getET	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetET))();
	return result;
}

IBOOL	getNE	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetNE))();
	return result;
}

IBOOL	getWP	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetWP))();
	return result;
}

IBOOL	getPG	IFN0()
{
	IBOOL result;
	result = (*(Cpu.GetPG))();
	return result;
}

IU32	getGDT_BASE	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetGDT_BASE))();
	return result;
}

IU16	getGDT_LIMIT	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetGDT_LIMIT))();
	return result;
}

IU32	getIDT_BASE	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetIDT_BASE))();
	return result;
}

IU16	getIDT_LIMIT	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetIDT_LIMIT))();
	return result;
}

IU16	getLDT_SELECTOR	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetLDT_SELECTOR))();
	return result;
}

IU32	getLDT_BASE	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetLDT_BASE))();
	return result;
}

IU32	getLDT_LIMIT	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetLDT_LIMIT))();
	return result;
}

IU16	getTR_SELECTOR	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetTR_SELECTOR))();
	return result;
}

IU32	getTR_BASE	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetTR_BASE))();
	return result;
}

IU32	getTR_LIMIT	IFN0()
{
	IU32 result;
	result = (*(Cpu.GetTR_LIMIT))();
	return result;
}

IU16	getTR_AR	IFN0()
{
	IU16 result;
	result = (*(Cpu.GetTR_AR))();
	return result;
}

IUH	host_get_q_calib_val	IFN0()
{
	IUH calibrate;
	calibrate = (*(Cpu.GetJumpCalibrateVal))();
	return calibrate;
}

IUH	host_get_jump_restart	IFN0()
{
	IUH initval;
	initval = (*(Cpu.GetJumpInitialVal))();
	return initval;
}

void	host_set_jump_restart	IFN1(IUH, initialVal)
{
	(*(Cpu.SetJumpInitialVal))(initialVal);
}

void	setEOIEnableAddr	IFN1(IU8 *, initialVal)
{
	(*(Cpu.SetEOIEnable))(initialVal);
}

void	setAddProfileDataPtr	IFN1(IHP, initialVal)
{
	(*(Cpu.SetAddProfileData))(initialVal);
}

void	setMaxProfileDataAddr	IFN1(IHP, initialVal)
{
	(*(Cpu.SetMaxProfileData))(initialVal);
}

IHP	getAddProfileDataAddr	IFN0()
{
	IHP result;
	result = (*(Cpu.GetAddProfileDataAddr))();
	return result;
}

void	PurgeLostIretHookLine	IFN1(IU16, lineNum)
{
	(*(Cpu.PurgeLostIretHookLine))(lineNum);
}

IHP	getSadInfoTable	IFN0()
{
	IHP tabPtr;
	tabPtr = (*((*(Cpu.Private)).GetSadInfoTable))();
	return tabPtr;
}

IBOOL	setGDT_BASE_LIMIT	IFN2(IU32, base, IU16, limit)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetGDT_BASE_LIMIT))(base, limit);
	return Success;
}

IBOOL	setIDT_BASE_LIMIT	IFN2(IU32, base, IU16, limit)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetIDT_BASE_LIMIT))(base, limit);
	return Success;
}

IBOOL	setLDT_BASE_LIMIT	IFN2(IU32, base, IU32, limit)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetLDT_BASE_LIMIT))(base, limit);
	return Success;
}

IBOOL	setTR_BASE_LIMIT	IFN2(IU32, base, IU32, limit)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetTR_BASE_LIMIT))(base, limit);
	return Success;
}

IBOOL	setTR_BASE_LIMIT_AR	IFN3(IU32, base, IU32, limit, IU16, ar)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetTR_BASE_LIMIT_AR))(base, limit, ar);
	return Success;
}

IBOOL	setCS_BASE_LIMIT_AR	IFN3(IU32, base, IU32, limit, IU16, ar)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetCS_BASE_LIMIT_AR))(base, limit, ar);
	return Success;
}

IBOOL	setSS_BASE_LIMIT_AR	IFN3(IU32, base, IU32, limit, IU16, ar)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetSS_BASE_LIMIT_AR))(base, limit, ar);
	return Success;
}

IBOOL	setDS_BASE_LIMIT_AR	IFN3(IU32, base, IU32, limit, IU16, ar)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetDS_BASE_LIMIT_AR))(base, limit, ar);
	return Success;
}

IBOOL	setES_BASE_LIMIT_AR	IFN3(IU32, base, IU32, limit, IU16, ar)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetES_BASE_LIMIT_AR))(base, limit, ar);
	return Success;
}

IBOOL	setFS_BASE_LIMIT_AR	IFN3(IU32, base, IU32, limit, IU16, ar)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetFS_BASE_LIMIT_AR))(base, limit, ar);
	return Success;
}

IBOOL	setGS_BASE_LIMIT_AR	IFN3(IU32, base, IU32, limit, IU16, ar)
{
	IBOOL Success;
	Success = (*((*(Cpu.Private)).SetGS_BASE_LIMIT_AR))(base, limit, ar);
	return Success;
}

void	setCS_SELECTOR	IFN1(IU16, val)
{
	(*((*(Cpu.Private)).SetCS_SELECTOR))(val);
}

void	setSS_SELECTOR	IFN1(IU16, val)
{
	(*((*(Cpu.Private)).SetSS_SELECTOR))(val);
}

void	setDS_SELECTOR	IFN1(IU16, val)
{
	(*((*(Cpu.Private)).SetDS_SELECTOR))(val);
}

void	setES_SELECTOR	IFN1(IU16, val)
{
	(*((*(Cpu.Private)).SetES_SELECTOR))(val);
}

void	setFS_SELECTOR	IFN1(IU16, val)
{
	(*((*(Cpu.Private)).SetFS_SELECTOR))(val);
}

void	setGS_SELECTOR	IFN1(IU16, val)
{
	(*((*(Cpu.Private)).SetGS_SELECTOR))(val);
}

IU16	getCS_SELECTOR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetCS_SELECTOR))();
	return result;
}

IU16	getSS_SELECTOR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetSS_SELECTOR))();
	return result;
}

IU16	getDS_SELECTOR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetDS_SELECTOR))();
	return result;
}

IU16	getES_SELECTOR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetES_SELECTOR))();
	return result;
}

IU16	getFS_SELECTOR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetFS_SELECTOR))();
	return result;
}

IU16	getGS_SELECTOR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetGS_SELECTOR))();
	return result;
}

IU32	getCS_BASE	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetCS_BASE))();
	return result;
}

IU32	getSS_BASE	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetSS_BASE))();
	return result;
}

IU32	getDS_BASE	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetDS_BASE))();
	return result;
}

IU32	getES_BASE	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetES_BASE))();
	return result;
}

IU32	getFS_BASE	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetFS_BASE))();
	return result;
}

IU32	getGS_BASE	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetGS_BASE))();
	return result;
}

IU32	getCS_LIMIT	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetCS_LIMIT))();
	return result;
}

IU32	getSS_LIMIT	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetSS_LIMIT))();
	return result;
}

IU32	getDS_LIMIT	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetDS_LIMIT))();
	return result;
}

IU32	getES_LIMIT	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetES_LIMIT))();
	return result;
}

IU32	getFS_LIMIT	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetFS_LIMIT))();
	return result;
}

IU32	getGS_LIMIT	IFN0()
{
	IU32 result;
	result = (*((*(Cpu.Private)).GetGS_LIMIT))();
	return result;
}

IU16	getCS_AR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetCS_AR))();
	return result;
}

IU16	getSS_AR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetSS_AR))();
	return result;
}

IU16	getDS_AR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetDS_AR))();
	return result;
}

IU16	getES_AR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetES_AR))();
	return result;
}

IU16	getFS_AR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetFS_AR))();
	return result;
}

IU16	getGS_AR	IFN0()
{
	IU16 result;
	result = (*((*(Cpu.Private)).GetGS_AR))();
	return result;
}

IUH	getCPL	IFN0()
{
	IUH result;
	result = (*((*(Cpu.Private)).GetCPL))();
	return result;
}

void	setCPL	IFN1(IUH, prot)
{
	(*((*(Cpu.Private)).SetCPL))(prot);
}

void	getCpuState	IFN1(TypeCpuStateRECptr, state)
{
	(*((*(Cpu.Private)).GetCpuState))(state);
}

void	setCpuState	IFN1(TypeCpuStateRECptr, state)
{
	(*((*(Cpu.Private)).SetCpuState))(state);
}

void	initNanoCpu	IFN1(IU32, variety)
{
	(*((*(Cpu.Private)).InitNanoCpu))(variety);
}

void	prepareBlocksToCompile	IFN1(IU32, variety)
{
	(*((*(Cpu.Private)).PrepareBlocksToCompile))(variety);
}

void	setRegConstraint	IFN2(IU32, regId, IU8, constraintType)
{
	(*((*(Cpu.Private)).SetRegConstraint))(regId, constraintType);
}

void	growRecPool	IFN0()
{
	(*((*(Cpu.Private)).GrowRecPool))();
}

void	BpiCompileBPI	IFN1(char *, instructions)
{
	(*((*(Cpu.Private)).BpiCompileBPI))(instructions);
}

void	trashIntelregisters	IFN0()
{
	(*((*(Cpu.Private)).TrashIntelRegisters))();
}

void	FmDeleteAllStructures	IFN1(IU32, newCR0)
{
	(*((*(Cpu.Private)).FmDeleteAllStructures))(newCR0);
}

TypeConstraintBitMapRECptr	constraintsFromUnivEpcPtr	IFN1(TypeEntryPointCacheRECptr, univ)
{
	TypeConstraintBitMapRECptr result;
	result = (*((*(Cpu.Private)).ConstraintsFromUnivEpcPtr))(univ);
	return result;
}

TypeConstraintBitMapRECptr	constraintsFromUnivHandle	IFN1(IU16, handle)
{
	TypeConstraintBitMapRECptr result;
	result = (*((*(Cpu.Private)).ConstraintsFromUnivHandle))(handle);
	return result;
}

IU32	sas_memory_size	IFN0()
{
	IU32 result;
	result = (*(Sas.Sas_memory_size))();
	return result;
}

void	sas_connect_memory	IFN3(IU32, lo_addr, IU32, Int_addr, SAS_MEM_TYPE, type)
{
	(*(Sas.Sas_connect_memory))(lo_addr, Int_addr, type);
}

void	sas_enable_20_bit_wrapping	IFN0()
{
	(*(Sas.Sas_enable_20_bit_wrapping))();
}

void	sas_disable_20_bit_wrapping	IFN0()
{
	(*(Sas.Sas_disable_20_bit_wrapping))();
}

IBOOL	sas_twenty_bit_wrapping_enabled	IFN0()
{
	IBOOL result;
	result = (*(Sas.Sas_twenty_bit_wrapping_enabled))();
	return result;
}

SAS_MEM_TYPE	sas_memory_type	IFN1(IU32, addr)
{
	SAS_MEM_TYPE result;
	result = (*(Sas.Sas_memory_type))(addr);
	return result;
}

IU8	sas_hw_at	IFN1(IU32, addr)
{
	IU8 result;
	result = (*(Sas.Sas_hw_at))(addr);
	return result;
}

IU16	sas_w_at	IFN1(IU32, addr)
{
	IU16 result;
	result = (*(Sas.Sas_w_at))(addr);
	return result;
}

IU32	sas_dw_at	IFN1(IU32, addr)
{
	IU32 result;
	result = (*(Sas.Sas_dw_at))(addr);
	return result;
}

IU8	sas_hw_at_no_check	IFN1(IU32, addr)
{
	IU8 result;
	result = (*(Sas.Sas_hw_at_no_check))(addr);
	return result;
}

IU16	sas_w_at_no_check	IFN1(IU32, addr)
{
	IU16 result;
	result = (*(Sas.Sas_w_at_no_check))(addr);
	return result;
}

IU32	sas_dw_at_no_check	IFN1(IU32, addr)
{
	IU32 result;
	result = (*(Sas.Sas_dw_at_no_check))(addr);
	return result;
}

void	sas_store	IFN2(IU32, addr, IU8, val)
{
	(*(Sas.Sas_store))(addr, val);
}

void	sas_storew	IFN2(IU32, addr, IU16, val)
{
	(*(Sas.Sas_storew))(addr, val);
}

void	sas_storedw	IFN2(IU32, addr, IU32, val)
{
	(*(Sas.Sas_storedw))(addr, val);
}

void	sas_store_no_check	IFN2(IU32, addr, IU8, val)
{
	(*(Sas.Sas_store_no_check))(addr, val);
}

void	sas_storew_no_check	IFN2(IU32, addr, IU16, val)
{
	(*(Sas.Sas_storew_no_check))(addr, val);
}

void	sas_storedw_no_check	IFN2(IU32, addr, IU32, val)
{
	(*(Sas.Sas_storedw_no_check))(addr, val);
}

void	sas_loads	IFN3(IU32, addr, IU8 *, stringptr, IU32, len)
{
	(*(Sas.Sas_loads))(addr, stringptr, len);
}

void	sas_stores	IFN3(IU32, addr, IU8 *, stringptr, IU32, len)
{
	(*(Sas.Sas_stores))(addr, stringptr, len);
}

void	sas_loads_no_check	IFN3(IU32, addr, IU8 *, stringptr, IU32, len)
{
	(*(Sas.Sas_loads_no_check))(addr, stringptr, len);
}

void	sas_stores_no_check	IFN3(IU32, addr, IU8 *, stringptr, IU32, len)
{
	(*(Sas.Sas_stores_no_check))(addr, stringptr, len);
}

void	sas_move_bytes_forward	IFN3(IU32, src, IU32, dest, IU32, len)
{
	(*(Sas.Sas_move_bytes_forward))(src, dest, len);
}

void	sas_move_words_forward	IFN3(IU32, src, IU32, dest, IU32, len)
{
	(*(Sas.Sas_move_words_forward))(src, dest, len);
}

void	sas_move_doubles_forward	IFN3(IU32, src, IU32, dest, IU32, len)
{
	(*(Sas.Sas_move_doubles_forward))(src, dest, len);
}

void	sas_move_bytes_backward	IFN3(IU32, src, IU32, dest, IU32, len)
{
	(*(Sas.Sas_move_bytes_backward))(src, dest, len);
}

void	sas_move_words_backward	IFN3(IU32, src, IU32, dest, IU32, len)
{
	(*(Sas.Sas_move_words_backward))(src, dest, len);
}

void	sas_move_doubles_backward	IFN3(IU32, src, IU32, dest, IU32, len)
{
	(*(Sas.Sas_move_doubles_backward))(src, dest, len);
}

void	sas_fills	IFN3(IU32, dest, IU8, val, IU32, len)
{
	(*(Sas.Sas_fills))(dest, val, len);
}

void	sas_fillsw	IFN3(IU32, dest, IU16, val, IU32, len)
{
	(*(Sas.Sas_fillsw))(dest, val, len);
}

void	sas_fillsdw	IFN3(IU32, dest, IU32, val, IU32, len)
{
	(*(Sas.Sas_fillsdw))(dest, val, len);
}

IU8 *	sas_scratch_address	IFN1(IU32, length)
{
	IU8 * addr;
	addr = (*(Sas.Sas_scratch_address))(length);
	return addr;
}

IU8 *	sas_transbuf_address	IFN2(IU32, dest_addr, IU32, length)
{
	IU8 * addr;
	addr = (*(Sas.Sas_transbuf_address))(dest_addr, length);
	return addr;
}

void	sas_loads_to_transbuf	IFN3(IU32, src_addr, IU8 *, dest_addr, IU32, length)
{
	(*(Sas.Sas_loads_to_transbuf))(src_addr, dest_addr, length);
}

void	sas_stores_from_transbuf	IFN3(IU32, dest_addr, IU8 *, src_addr, IU32, length)
{
	(*(Sas.Sas_stores_from_transbuf))(dest_addr, src_addr, length);
}

IU8	sas_PR8	IFN1(IU32, addr)
{
	IU8 result;
	result = (*(Sas.Sas_PR8))(addr);
	return result;
}

IU16	sas_PR16	IFN1(IU32, addr)
{
	IU16 result;
	result = (*(Sas.Sas_PR16))(addr);
	return result;
}

IU32	sas_PR32	IFN1(IU32, addr)
{
	IU32 result;
	result = (*(Sas.Sas_PR32))(addr);
	return result;
}

void	sas_PW8	IFN2(IU32, addr, IU8, val)
{
	(*(Sas.Sas_PW8))(addr, val);
}

void	sas_PW16	IFN2(IU32, addr, IU16, val)
{
	(*(Sas.Sas_PW16))(addr, val);
}

void	sas_PW32	IFN2(IU32, addr, IU32, val)
{
	(*(Sas.Sas_PW32))(addr, val);
}

void	sas_PW8_no_check	IFN2(IU32, addr, IU8, val)
{
	(*(Sas.Sas_PW8_no_check))(addr, val);
}

void	sas_PW16_no_check	IFN2(IU32, addr, IU16, val)
{
	(*(Sas.Sas_PW16_no_check))(addr, val);
}

void	sas_PW32_no_check	IFN2(IU32, addr, IU32, val)
{
	(*(Sas.Sas_PW32_no_check))(addr, val);
}

IU8 *	getPtrToPhysAddrByte	IFN1(IU32, phys_addr)
{
	IU8 * host_address;
	host_address = (*(Sas.SasPtrToPhysAddrByte))(phys_addr);
	return host_address;
}

IU8 *	get_byte_addr	IFN1(IU32, phys_addr)
{
	IU8 * host_address;
	host_address = (*(Sas.Sas_get_byte_addr))(phys_addr);
	return host_address;
}

IU8 *	getPtrToLinAddrByte	IFN1(IU32, lin_addr)
{
	IU8 * host_address;
	host_address = (*(Sas.SasPtrToLinAddrByte))(lin_addr);
	return host_address;
}

IBOOL	sas_init_pm_selectors	IFN2(IU16, sel1, IU16, sel2)
{
	IBOOL redundant;
	redundant = (*(Sas.SasRegisterVirtualSelectors))(sel1, sel2);
	return redundant;
}

void	sas_overwrite_memory	IFN2(IU32, addr, IU32, length)
{
	(*(Sas.Sas_overwrite_memory))(addr, length);
}

void	sas_PWS	IFN3(IU32, dest, IU8 *, src, IU32, len)
{
	(*(Sas.Sas_PWS))(dest, src, len);
}

void	sas_PWS_no_check	IFN3(IU32, dest, IU8 *, src, IU32, len)
{
	(*(Sas.Sas_PWS_no_check))(dest, src, len);
}

void	sas_PRS	IFN3(IU32, src, IU8 *, dest, IU32, len)
{
	(*(Sas.Sas_PRS))(src, dest, len);
}

void	sas_PRS_no_check	IFN3(IU32, src, IU8 *, dest, IU32, len)
{
	(*(Sas.Sas_PRS_no_check))(src, dest, len);
}

IBOOL	sas_PigCmpPage	IFN3(IU32, src, IU8 *, dest, IU32, len)
{
	IBOOL comp_OK;
	comp_OK = (*(Sas.Sas_PigCmpPage))(src, dest, len);
	return comp_OK;
}

IBOOL	IOVirtualised	IFN4(IU16, port, IU32 *, value, IU32, offset, IU8, width)
{
	IBOOL isVirtual;
	isVirtual = (*(Sas.IOVirtualised))(port, value, offset, width);
	return isVirtual;
}

#endif	/* PROD */
/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\bldr_c.h ===
#ifndef _Bldr_c_h
#define _Bldr_c_h
#define SizeByte (1)
#define SizeWord (2)
#define SizeTByte (3)
#define SizeDword (4)
#endif /* ! _Bldr_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\bodge_c.h ===
#ifndef _Bodge_c_h
#define _Bodge_c_h
#define AxpBranchCodeSizeAdjustment (1)
#define PpcBranchCodeSizeAdjustment (1)
#endif /* ! _Bodge_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\bswap_c.h ===
#ifndef _Bswap_c_h
#define _Bswap_c_h
#endif /* ! _Bswap_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\btest_c.h ===
#ifndef _BTest_c_h
#define _BTest_c_h
#endif /* ! _BTest_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\bound_c.h ===
#ifndef _Bound_c_h
#define _Bound_c_h
#endif /* ! _Bound_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\c2cpug_c.h ===
#ifndef _C2CpuG_c_h
#define _C2CpuG_c_h
#endif /* ! _C2CpuG_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\c2cput_c.h ===
#ifndef _C2CpuT_c_h
#define _C2CpuT_c_h
#endif /* ! _C2CpuT_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\bpi_c.h ===
#ifndef _Bpi_c_h
#define _Bpi_c_h
enum BpiInstruction
{
	BpiStart = 0,
	BpiImmediate = 1,
	BpiNeedsAL = 2,
	BpiNeedsAX = 3,
	BpiNeedsEAX = 4,
	BpiNeedsBL = 5,
	BpiNeedsBX = 6,
	BpiNeedsEBX = 7,
	BpiNeedsCL = 8,
	BpiNeedsCX = 9,
	BpiNeedsECX = 10,
	BpiNeedsDL = 11,
	BpiNeedsDX = 12,
	BpiNeedsEDX = 13,
	BpiNeedsBP = 14,
	BpiNeedsEBP = 15,
	BpiNeedsSP = 16,
	BpiNeedsESP = 17,
	BpiNeedsSI = 18,
	BpiNeedsESI = 19,
	BpiNeedsDI = 20,
	BpiNeedsEDI = 21,
	BpiNeedsEFLAGS = 22,
	BpiGeneric = 23,
	BpiAdd = 24,
	BpiSub = 25,
	BpiAnd = 26,
	BpiOr = 27,
	BpiXor = 28,
	BpiLshift = 29,
	BpiRshift = 30,
	BpiTestEQ = 31,
	BpiTestNE = 32,
	BpiTestGE = 33,
	BpiTestLE = 34,
	BpiTestGT = 35,
	BpiTestLT = 36,
	BpiGet = 37,
	BpiSwap = 38,
	BpiGetAL = 39,
	BpiGetAX = 40,
	BpiGetEAX = 41,
	BpiGetBL = 42,
	BpiGetBX = 43,
	BpiGetEBX = 44,
	BpiGetCL = 45,
	BpiGetCX = 46,
	BpiGetECX = 47,
	BpiGetDL = 48,
	BpiGetDX = 49,
	BpiGetEDX = 50,
	BpiGetBP = 51,
	BpiGetEBP = 52,
	BpiGetSP = 53,
	BpiGetESP = 54,
	BpiGetSI = 55,
	BpiGetESI = 56,
	BpiGetDI = 57,
	BpiGetEDI = 58,
	BpiGetEIP = 59,
	BpiGetEFLAGS = 60,
	BpiGetCSbase = 61,
	BpiGetCSsel = 62,
	BpiGetDSbase = 63,
	BpiGetDSsel = 64,
	BpiGetESbase = 65,
	BpiGetESsel = 66,
	BpiGetFSbase = 67,
	BpiGetFSsel = 68,
	BpiGetGSbase = 69,
	BpiGetGSsel = 70,
	BpiGetSSbase = 71,
	BpiGetSSsel = 72,
	BpiGetFragment = 73,
	BpiPrefixKnown = 74,
	BpiPrefixWork = 75,
	BpiPrefixLabel = 76,
	BpiReadHostLs8 = 77,
	BpiReadHostLs16 = 78,
	BpiReadHostLs32 = 79,
	BpiReadHostLsHbit = 80,
	BpiReadCpuLs8 = 81,
	BpiReadCpuLs16 = 82,
	BpiReadCpuLs32 = 83,
	BpiLabel = 84,
	BpiStore = 85,
	BpiCallC = 86,
	BpiCall = 87,
	BpiIfBranch = 88,
	BpiElseBranch = 89,
	BpiIfGoto = 90,
	BpiElseGoto = 91,
	BpiIfReturn = 92,
	BpiElseReturn = 93,
	BpiIfSad = 94,
	BpiElseSad = 95,
	BpiSad = 96,
	BpiReturn = 97,
	BpiCheckI = 98,
	BpiGoto = 99,
	BpiGetUNIV = 100,
	BpiLastEntry = 101
};
#endif /* ! _Bpi_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\buffer_c.h ===
#ifndef _Buffer_c_h
#define _Buffer_c_h
#define CodeOffsetScale (4)
#define CodeBufferSize (8192)
#define MaxCodeBufferOverrun (1500)
#define MaxCopiedCleanups (600)
#define BufferIndexNULL ((struct BufferIndexREC*)0)
#define nPartitionBits (5)
#define nPartitions (32)
#define DataHeaderNULL ((struct DataHeaderREC*)0)
#define FragmentIndexNULL ((struct FragmentIndexREC*)0)
#define FragmentDataNULL ((struct FragmentDataREC*)0)
#define CleanByteRemoveBase (207)
#define CleanByteAddBase (159)
#define CleanByteMaxFt (33)
#define CleanByteFtBase (126)
#define CleanByteMaxCodeUnits (125)
#define FragmentInfoNULL ((struct FragmentInfoREC*)0)
#define DebugInfoNULL ((struct DebugInfoREC*)0)
#define SavedIntelFragmentNULL ((struct SavedIntelFragmentREC*)0)
#define SavedIntelNULL ((struct SavedIntelREC*)0)
enum WhereAmItype
{
	CleanedWhereAmItype = 0,
	BopWhereAmItype = 1,
	CompileWhereAmItype = 2,
	NormalWhereAmItype = 3
};
enum CompilationBufferType
{
	BufferTypeUnused = 0,
	BufferTypeRecords = 1,
	BufferTypeChained = 2,
	BufferTypeCode = 3,
	BufferTypeCompilation = 4,
	BufferTypePendingDelete = 5,
	BufferTypeBpi = 6
};
struct BufferIndexREC
{
	struct BufferIndexREC *moreRecent;
	struct BufferIndexREC *lessRecent;
	struct BufferIndexREC *headOfLRUchain;
	IU8 type;
	IU16 bufferNumber;
	IU8 *dataBuffer;
	IU32 *codeBuffer;
	void *debugBuffer;
	struct PigSynchREC *pigSynchList;
};
struct DataHeaderREC
{
	struct FragmentIndexREC *partition[nPartitions];
};
struct FragmentIndexREC
{
	IU16 codeOffset;
	IS16 dataOffset;
};
struct FragmentDataREC
{
	IU32 linearAddress;
	IU32 eip;
	IU16 universe;
	IU8 span;
	IU8 vnum;
	IU8 cleanTable[1];
};
enum DebugInfoType
{
	DebugInfo_Other = 0,
	DebugInfo_Intel = 1
};
struct DebugInfoREC
{
	struct DebugInfoREC *next;
	IUH size;
	IUH type;
};
struct SavedIntelFragmentREC
{
	IU32 eip;
	IU8 *bytes;
};
struct SavedIntelREC
{
	struct DebugInfoREC header;
	IU8 *freePtr;
	IU16 nEntries;
	IU16 fragNumBase;
	struct SavedIntelFragmentREC fragments[1];
};
enum CleanupTypes
{
	cleanHostOffset = 0,
	cleanIntelOffset = 1,
	cleanAddConstraint = 2,
	cleanRemoveConstraint = 3,
	cleanSetFlagsType = 4,
	cleanFlagsNeeded = 5,
	cleanEndList = 6
};
#endif /* ! _Buffer_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\c2cpusad.h ===
/*[
 * Generated File: C2CpuSad.h
 *
]*/

char	*CpuVectorNames[] = {
	"Simulate",
	"Interrupt",
	"ClearHwInt",
	"EndOfApplication",
	"Terminate",
	"Initialise",
	"SetQuickEventCount",
	"GetQuickEventCount",
	"CalcQuickEventInstTime",
	"InitIOS",
	"DefineInb",
	"DefineInw",
	"DefineInd",
	"DefineOutb",
	"DefineOutw",
	"DefineOutd",
	"SetAL",
	"SetAH",
	"SetAX",
	"SetEAX",
	"SetBL",
	"SetBH",
	"SetBX",
	"SetEBX",
	"SetCL",
	"SetCH",
	"SetCX",
	"SetECX",
	"SetDL",
	"SetDH",
	"SetDX",
	"SetEDX",
	"SetSI",
	"SetESI",
	"SetDI",
	"SetEDI",
	"SetSP",
	"SetESP",
	"SetBP",
	"SetEBP",
	"SetIP",
	"SetEIP",
	"SetCS",
	"SetSS",
	"SetDS",
	"SetES",
	"SetFS",
	"SetGS",
	"SetEFLAGS",
	"SetSTATUS",
	"SetIOPL",
	"SetMSW",
	"SetCR0",
	"SetCR2",
	"SetCR3",
	"SetCF",
	"SetPF",
	"SetAF",
	"SetZF",
	"SetSF",
	"SetTF",
	"SetIF",
	"SetDF",
	"SetOF",
	"SetNT",
	"SetRF",
	"SetVM",
	"SetAC",
	"SetPE",
	"SetMP",
	"SetEM",
	"SetTS",
	"SetPG",
	"SetLDT_SELECTOR",
	"SetTR_SELECTOR",
	"GetAL",
	"GetAH",
	"GetAX",
	"GetEAX",
	"GetBL",
	"GetBH",
	"GetBX",
	"GetEBX",
	"GetCL",
	"GetCH",
	"GetCX",
	"GetECX",
	"GetDL",
	"GetDH",
	"GetDX",
	"GetEDX",
	"GetSI",
	"GetESI",
	"GetDI",
	"GetEDI",
	"GetSP",
	"GetESP",
	"GetBP",
	"GetEBP",
	"GetIP",
	"GetEIP",
	"GetCS",
	"GetSS",
	"GetDS",
	"GetES",
	"GetFS",
	"GetGS",
	"GetEFLAGS",
	"GetSTATUS",
	"GetIOPL",
	"GetMSW",
	"GetCR0",
	"GetCR2",
	"GetCR3",
	"GetCF",
	"GetPF",
	"GetAF",
	"GetZF",
	"GetSF",
	"GetTF",
	"GetIF",
	"GetDF",
	"GetOF",
	"GetNT",
	"GetRF",
	"GetVM",
	"GetAC",
	"GetPE",
	"GetMP",
	"GetEM",
	"GetTS",
	"GetET",
	"GetNE",
	"GetWP",
	"GetPG",
	"GetGDT_BASE",
	"GetGDT_LIMIT",
	"GetIDT_BASE",
	"GetIDT_LIMIT",
	"GetLDT_SELECTOR",
	"GetLDT_BASE",
	"GetLDT_LIMIT",
	"GetTR_SELECTOR",
	"GetTR_BASE",
	"GetTR_LIMIT",
	"GetTR_AR",
	"GetJumpCalibrateVal",
	"GetJumpInitialVal",
	"SetJumpInitialVal",
	"SetEOIEnable",
	"SetAddProfileData",
	"SetMaxProfileData",
	"GetAddProfileDataAddr",
	"PurgeLostIretHookLine"
};

char	*CpuPrivateVectorNames[] = {
	"GetSadInfoTable",
	"SetGDT_BASE_LIMIT",
	"SetIDT_BASE_LIMIT",
	"SetLDT_BASE_LIMIT",
	"SetTR_BASE_LIMIT",
	"SetTR_BASE_LIMIT_AR",
	"SetCS_BASE_LIMIT_AR",
	"SetSS_BASE_LIMIT_AR",
	"SetDS_BASE_LIMIT_AR",
	"SetES_BASE_LIMIT_AR",
	"SetFS_BASE_LIMIT_AR",
	"SetGS_BASE_LIMIT_AR",
	"SetCS_SELECTOR",
	"SetSS_SELECTOR",
	"SetDS_SELECTOR",
	"SetES_SELECTOR",
	"SetFS_SELECTOR",
	"SetGS_SELECTOR",
	"GetCS_SELECTOR",
	"GetSS_SELECTOR",
	"GetDS_SELECTOR",
	"GetES_SELECTOR",
	"GetFS_SELECTOR",
	"GetGS_SELECTOR",
	"GetCS_BASE",
	"GetSS_BASE",
	"GetDS_BASE",
	"GetES_BASE",
	"GetFS_BASE",
	"GetGS_BASE",
	"GetCS_LIMIT",
	"GetSS_LIMIT",
	"GetDS_LIMIT",
	"GetES_LIMIT",
	"GetFS_LIMIT",
	"GetGS_LIMIT",
	"GetCS_AR",
	"GetSS_AR",
	"GetDS_AR",
	"GetES_AR",
	"GetFS_AR",
	"GetGS_AR",
	"GetCPL",
	"SetCPL",
	"GetCpuState",
	"SetCpuState",
	"InitNanoCpu",
	"PrepareBlocksToCompile",
	"SetRegConstraint",
	"GrowRecPool",
	"BpiCompileBPI",
	"TrashIntelRegisters",
	"FmDeleteAllStructures",
	"ConstraintsFromUnivEpcPtr",
	"ConstraintsFromUnivHandle"
};

char	*SasVectorNames[] = {
	"Sas_memory_size",
	"Sas_connect_memory",
	"Sas_enable_20_bit_wrapping",
	"Sas_disable_20_bit_wrapping",
	"Sas_twenty_bit_wrapping_enabled",
	"Sas_memory_type",
	"Sas_hw_at",
	"Sas_w_at",
	"Sas_dw_at",
	"Sas_hw_at_no_check",
	"Sas_w_at_no_check",
	"Sas_dw_at_no_check",
	"Sas_store",
	"Sas_storew",
	"Sas_storedw",
	"Sas_store_no_check",
	"Sas_storew_no_check",
	"Sas_storedw_no_check",
	"Sas_loads",
	"Sas_stores",
	"Sas_loads_no_check",
	"Sas_stores_no_check",
	"Sas_move_bytes_forward",
	"Sas_move_words_forward",
	"Sas_move_doubles_forward",
	"Sas_move_bytes_backward",
	"Sas_move_words_backward",
	"Sas_move_doubles_backward",
	"Sas_fills",
	"Sas_fillsw",
	"Sas_fillsdw",
	"Sas_scratch_address",
	"Sas_transbuf_address",
	"Sas_loads_to_transbuf",
	"Sas_stores_from_transbuf",
	"Sas_PR8",
	"Sas_PR16",
	"Sas_PR32",
	"Sas_PW8",
	"Sas_PW16",
	"Sas_PW32",
	"Sas_PW8_no_check",
	"Sas_PW16_no_check",
	"Sas_PW32_no_check",
	"SasPtrToPhysAddrByte",
	"Sas_get_byte_addr",
	"SasPtrToLinAddrByte",
	"SasRegisterVirtualSelectors",
	"Sas_overwrite_memory",
	"Sas_PWS",
	"Sas_PWS_no_check",
	"Sas_PRS",
	"Sas_PRS_no_check",
	"Sas_PigCmpPage",
	"IOVirtualised"
};

char	*VideoVectorNames[] = {
	"GetVideolatches",
	"GetVideorplane",
	"GetVideowplane",
	"GetVideoscratch",
	"GetVideosr_masked_val",
	"GetVideosr_nmask",
	"GetVideodata_and_mask",
	"GetVideodata_xor_mask",
	"GetVideolatch_xor_mask",
	"GetVideobit_prot_mask",
	"GetVideoplane_enable",
	"GetVideoplane_enable_mask",
	"GetVideosr_lookup",
	"GetVideofwd_str_read_addr",
	"GetVideobwd_str_read_addr",
	"GetVideodirty_total",
	"GetVideodirty_low",
	"GetVideodirty_high",
	"GetVideovideo_copy",
	"GetVideomark_byte",
	"GetVideomark_word",
	"GetVideomark_string",
	"GetVideoread_shift_count",
	"GetVideoread_mapped_plane",
	"GetVideocolour_comp",
	"GetVideodont_care",
	"GetVideov7_bank_vid_copy_off",
	"GetVideoscreen_ptr",
	"GetVideorotate",
	"GetVideocalc_data_xor",
	"GetVideocalc_latch_xor",
	"GetVideoread_byte_addr",
	"GetVideov7_fg_latches",
	"GetVideoGC_regs",
	"GetVideolast_GC_index",
	"GetVideodither",
	"GetVideowrmode",
	"GetVideochain",
	"GetVideowrstate",
	"SetVideolatches",
	"SetVideorplane",
	"SetVideowplane",
	"SetVideoscratch",
	"SetVideosr_masked_val",
	"SetVideosr_nmask",
	"SetVideodata_and_mask",
	"SetVideodata_xor_mask",
	"SetVideolatch_xor_mask",
	"SetVideobit_prot_mask",
	"SetVideoplane_enable",
	"SetVideoplane_enable_mask",
	"SetVideosr_lookup",
	"SetVideofwd_str_read_addr",
	"SetVideobwd_str_read_addr",
	"SetVideodirty_total",
	"SetVideodirty_low",
	"SetVideodirty_high",
	"SetVideovideo_copy",
	"SetVideomark_byte",
	"SetVideomark_word",
	"SetVideomark_string",
	"SetVideoread_shift_count",
	"SetVideoread_mapped_plane",
	"SetVideocolour_comp",
	"SetVideodont_care",
	"SetVideov7_bank_vid_copy_off",
	"SetVideoscreen_ptr",
	"SetVideorotate",
	"SetVideocalc_data_xor",
	"SetVideocalc_latch_xor",
	"SetVideoread_byte_addr",
	"SetVideov7_fg_latches",
	"SetVideoGC_regs",
	"SetVideolast_GC_index",
	"SetVideodither",
	"SetVideowrmode",
	"SetVideochain",
	"SetVideowrstate",
	"setWritePointers",
	"setReadPointers",
	"setMarkPointers"
};

/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\chain2_c.h ===
#ifndef _Chain2_c_h
#define _Chain2_c_h
#endif /* ! _Chain2_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\chain4_c.h ===
#ifndef _Chain4_c_h
#define _Chain4_c_h
#define NotTrue (0)
#endif /* ! _Chain4_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\cmp_c.h ===
#ifndef _Cmp_c_h
#define _Cmp_c_h
#endif /* ! _Cmp_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\ccpudefs.inc ===
C_DEFINES= -DCPU_30_STYLE -DCPU_40_STYLE -DNEW_CPU -DCCPU -DSPC386 -DANSI -DNTVDM -DC_VID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\contxt_c.h ===
#ifndef _Contxt_c_h
#define _Contxt_c_h
#define ContextNULL ((struct ContextREC*)0)
#define MAX_CONTEXTS (64)
#define MAX_QUEUED_LDT_CONTEXTS (64)
#define ContextShift (6)
#define ContextMask (4032)
#define Context_S (11)
#define Context_E (6)
#define AnyContext (128)
struct ContextREC
{
	struct ContextREC *NextCntxt;
	struct ContextREC *PrevCntxt;
	IU32 PDBRVal;
	IU32 PDE0Val;
	IU32 LDTBase;
	IU32 GDTBase;
	IU32 LDTLimit;
	IU16 GDTLimit;
	IBOOL TwentyBitWrap;
	IBOOL Valid;
	IBOOL CheckedOnly;
	IU8 ThisCntxt;
};
#endif /* ! _Contxt_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\copies_c.h ===
#ifndef _Copies_c_h
#define _Copies_c_h
#endif /* ! _Copies_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\cpnote_c.h ===
#ifndef _CpNote_c_h
#define _CpNote_c_h
enum ConstraintChange
{
	ConstraintAdded = 0,
	ConstraintRemoved = 1
};
#endif /* ! _CpNote_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\conv_c.h ===
#ifndef _Conv_c_h
#define _Conv_c_h
#endif /* ! _Conv_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\cpuint_c.h ===
#ifndef _CpuInt_c_h
#define _CpuInt_c_h
#define ChipType (228)
#define WaferRevision (1)
#define nQuickTickerThreads (4)
struct InterruptREC
{
	IBOOL Activity;
	IBOOL Reset;
	IBOOL Hardware;
	IBOOL Interval;
	IBOOL AsynchIO;
	IBOOL QuickTickerScan;
	IBOOL SRCI;
	IBOOL Disabled;
};
struct QuickTickerThreadREC
{
	IBOOL Activity;
	IUH triggerPoint;
	IUH elapsed;
};
struct QuickTickerREC
{
	IUH triggerPoint;
	IUH elapsed;
	IUH perTickDelta;
	IUH averageRate;
	IUH averageError;
	struct QuickTickerThreadREC *threads;
};
enum CPU_INT_TYPE
{
	CPU_HW_RESET = 0,
	CPU_TIMER_TICK = 1,
	CPU_HW_INT = 2,
	CPU_SAD_INT = 3,
	CPU_SIGIO_EVENT = 4,
	CPU_NPX_INT = 5
};
#endif /* ! _CpuInt_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\cpumod_c.h ===
#ifndef _CpuMod_c_h
#define _CpuMod_c_h
#endif /* ! _CpuMod_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\cpureg_c.h ===
#ifndef _CpuReg_c_h
#define _CpuReg_c_h
#define J_EXX_SIMULATED (1)
enum IntelRegId
{
	EAX_id = 0,
	EBX_id = 1,
	ECX_id = 2,
	EDX_id = 3,
	ESP_id = 4,
	EBP_id = 5,
	ESI_id = 6,
	EDI_id = 7
};
#endif /* ! _CpuReg_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\dec_c.h ===
#ifndef _Dec_c_h
#define _Dec_c_h
#endif /* ! _Dec_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\ea_c.h ===
#ifndef _Ea_c_h
#define _Ea_c_h
#define SCALE_1 (1)
#define SCALE_2 (2)
#define SCALE_4 (4)
#define SCALE_8 (8)
#endif /* ! _Ea_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\cpu4gen.h ===
/*[
 * Generated File: cpu4gen.h
 *
]*/


struct	CpuVector	{
#ifdef	CPU_PRIVATE
	struct	CpuPrivateVector	*Private;
#else	/* !CPU_PRIVATE */
	IHP	Private;
#endif	/* CPU_PRIVATE */
#ifdef	CPU_PRIVATE
	struct	SasVector	*Sas;
#else	/* !CPU_PRIVATE */
	IHP	Sas;
#endif	/* CPU_PRIVATE */
#ifdef	CPU_PRIVATE
	struct	VideoVector	*Video;
#else	/* !CPU_PRIVATE */
	IHP	Video;
#endif	/* CPU_PRIVATE */
	void	(*Simulate)	IPT0();
	void	(*Interrupt)	IPT2(CPU_INT_TYPE,	intType, IU16,	intNum);
	void	(*ClearHwInt)	IPT0();
	void	(*EndOfApplication)	IPT0();
	void	(*Terminate)	IPT0();
	void	(*Initialise)	IPT0();
	void	(*SetQuickEventCount)	IPT1(IU32,	val);
	IU32	(*GetQuickEventCount)	IPT0();
	IU32	(*CalcQuickEventInstTime)	IPT1(IU32,	val);
	void	(*InitIOS)	IPT4(IHP,	InTables, IHP,	OutTables, IUH,	maxAdaptor, IU16,	portMask);
	void	(*DefineInb)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineInw)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineInd)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineOutb)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineOutw)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*DefineOutd)	IPT2(IUH,	adaptor, IHP,	func);
	void	(*SetAL)	IPT1(IU8,	val);
	void	(*SetAH)	IPT1(IU8,	val);
	void	(*SetAX)	IPT1(IU16,	val);
	void	(*SetEAX)	IPT1(IU32,	val);
	void	(*SetBL)	IPT1(IU8,	val);
	void	(*SetBH)	IPT1(IU8,	val);
	void	(*SetBX)	IPT1(IU16,	val);
	void	(*SetEBX)	IPT1(IU32,	val);
	void	(*SetCL)	IPT1(IU8,	val);
	void	(*SetCH)	IPT1(IU8,	val);
	void	(*SetCX)	IPT1(IU16,	val);
	void	(*SetECX)	IPT1(IU32,	val);
	void	(*SetDL)	IPT1(IU8,	val);
	void	(*SetDH)	IPT1(IU8,	val);
	void	(*SetDX)	IPT1(IU16,	val);
	void	(*SetEDX)	IPT1(IU32,	val);
	void	(*SetSI)	IPT1(IU16,	val);
	void	(*SetESI)	IPT1(IU32,	val);
	void	(*SetDI)	IPT1(IU16,	val);
	void	(*SetEDI)	IPT1(IU32,	val);
	void	(*SetSP)	IPT1(IU16,	val);
	void	(*SetESP)	IPT1(IU32,	val);
	void	(*SetBP)	IPT1(IU16,	val);
	void	(*SetEBP)	IPT1(IU32,	val);
	void	(*SetIP)	IPT1(IU16,	val);
	void	(*SetEIP)	IPT1(IU32,	val);
	IUH	(*SetCS)	IPT1(IU16,	val);
	IUH	(*SetSS)	IPT1(IU16,	val);
	IUH	(*SetDS)	IPT1(IU16,	val);
	IUH	(*SetES)	IPT1(IU16,	val);
	IUH	(*SetFS)	IPT1(IU16,	val);
	IUH	(*SetGS)	IPT1(IU16,	val);
	void	(*SetEFLAGS)	IPT1(IU32,	val);
	void	(*SetSTATUS)	IPT1(IU16,	val);
	void	(*SetIOPL)	IPT1(IU8,	val);
	void	(*SetMSW)	IPT1(IU16,	val);
	void	(*SetCR0)	IPT1(IU32,	val);
	void	(*SetCR2)	IPT1(IU32,	val);
	void	(*SetCR3)	IPT1(IU32,	val);
	void	(*SetCF)	IPT1(IBOOL,	val);
	void	(*SetPF)	IPT1(IBOOL,	val);
	void	(*SetAF)	IPT1(IBOOL,	val);
	void	(*SetZF)	IPT1(IBOOL,	val);
	void	(*SetSF)	IPT1(IBOOL,	val);
	void	(*SetTF)	IPT1(IBOOL,	val);
	void	(*SetIF)	IPT1(IBOOL,	val);
	void	(*SetDF)	IPT1(IBOOL,	val);
	void	(*SetOF)	IPT1(IBOOL,	val);
	void	(*SetNT)	IPT1(IBOOL,	val);
	void	(*SetRF)	IPT1(IBOOL,	val);
	void	(*SetVM)	IPT1(IBOOL,	val);
	void	(*SetAC)	IPT1(IBOOL,	val);
	void	(*SetPE)	IPT1(IBOOL,	val);
	void	(*SetMP)	IPT1(IBOOL,	val);
	void	(*SetEM)	IPT1(IBOOL,	val);
	void	(*SetTS)	IPT1(IBOOL,	val);
	void	(*SetPG)	IPT1(IBOOL,	val);
	void	(*SetLDT_SELECTOR)	IPT1(IU16,	val);
	void	(*SetTR_SELECTOR)	IPT1(IU16,	val);
	IU8	(*GetAL)	IPT0();
	IU8	(*GetAH)	IPT0();
	IU16	(*GetAX)	IPT0();
	IU32	(*GetEAX)	IPT0();
	IU8	(*GetBL)	IPT0();
	IU8	(*GetBH)	IPT0();
	IU16	(*GetBX)	IPT0();
	IU32	(*GetEBX)	IPT0();
	IU8	(*GetCL)	IPT0();
	IU8	(*GetCH)	IPT0();
	IU16	(*GetCX)	IPT0();
	IU32	(*GetECX)	IPT0();
	IU8	(*GetDL)	IPT0();
	IU8	(*GetDH)	IPT0();
	IU16	(*GetDX)	IPT0();
	IU32	(*GetEDX)	IPT0();
	IU16	(*GetSI)	IPT0();
	IU32	(*GetESI)	IPT0();
	IU16	(*GetDI)	IPT0();
	IU32	(*GetEDI)	IPT0();
	IU16	(*GetSP)	IPT0();
	IU32	(*GetESP)	IPT0();
	IU16	(*GetBP)	IPT0();
	IU32	(*GetEBP)	IPT0();
	IU16	(*GetIP)	IPT0();
	IU32	(*GetEIP)	IPT0();
	IU16	(*GetCS)	IPT0();
	IU16	(*GetSS)	IPT0();
	IU16	(*GetDS)	IPT0();
	IU16	(*GetES)	IPT0();
	IU16	(*GetFS)	IPT0();
	IU16	(*GetGS)	IPT0();
	IU32	(*GetEFLAGS)	IPT0();
	IU16	(*GetSTATUS)	IPT0();
	IU8	(*GetIOPL)	IPT0();
	IU16	(*GetMSW)	IPT0();
	IU32	(*GetCR0)	IPT0();
	IU32	(*GetCR2)	IPT0();
	IU32	(*GetCR3)	IPT0();
	IBOOL	(*GetCF)	IPT0();
	IBOOL	(*GetPF)	IPT0();
	IBOOL	(*GetAF)	IPT0();
	IBOOL	(*GetZF)	IPT0();
	IBOOL	(*GetSF)	IPT0();
	IBOOL	(*GetTF)	IPT0();
	IBOOL	(*GetIF)	IPT0();
	IBOOL	(*GetDF)	IPT0();
	IBOOL	(*GetOF)	IPT0();
	IBOOL	(*GetNT)	IPT0();
	IBOOL	(*GetRF)	IPT0();
	IBOOL	(*GetVM)	IPT0();
	IBOOL	(*GetAC)	IPT0();
	IBOOL	(*GetPE)	IPT0();
	IBOOL	(*GetMP)	IPT0();
	IBOOL	(*GetEM)	IPT0();
	IBOOL	(*GetTS)	IPT0();
	IBOOL	(*GetET)	IPT0();
	IBOOL	(*GetNE)	IPT0();
	IBOOL	(*GetWP)	IPT0();
	IBOOL	(*GetPG)	IPT0();
	IU32	(*GetGDT_BASE)	IPT0();
	IU16	(*GetGDT_LIMIT)	IPT0();
	IU32	(*GetIDT_BASE)	IPT0();
	IU16	(*GetIDT_LIMIT)	IPT0();
	IU16	(*GetLDT_SELECTOR)	IPT0();
	IU32	(*GetLDT_BASE)	IPT0();
	IU32	(*GetLDT_LIMIT)	IPT0();
	IU16	(*GetTR_SELECTOR)	IPT0();
	IU32	(*GetTR_BASE)	IPT0();
	IU32	(*GetTR_LIMIT)	IPT0();
	IU16	(*GetTR_AR)	IPT0();
	IUH	(*GetJumpCalibrateVal)	IPT0();
	IUH	(*GetJumpInitialVal)	IPT0();
	void	(*SetJumpInitialVal)	IPT1(IUH,	initialVal);
	void	(*SetEOIEnable)	IPT1(IU8 *,	initialVal);
	void	(*SetAddProfileData)	IPT1(IHP,	initialVal);
	void	(*SetMaxProfileData)	IPT1(IHP,	initialVal);
	IHP	(*GetAddProfileDataAddr)	IPT0();
	void	(*PurgeLostIretHookLine)	IPT1(IU16,	lineNum);
};

extern	struct	CpuVector	Cpu;

#ifdef	CCPU
IMPORT	void	c_cpu_simulate	IPT0();
#define	cpu_simulate	c_cpu_simulate
#else	/* CCPU */

#ifdef PROD
#define	cpu_simulate	(*(Cpu.Simulate))
#else /* PROD */
IMPORT	void	cpu_simulate	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_interrupt	IPT2(CPU_INT_TYPE, intType, IU16, intNum);
#define	cpu_interrupt	c_cpu_interrupt
#else	/* CCPU */

#ifdef PROD
#define	cpu_interrupt	(*(Cpu.Interrupt))
#else /* PROD */
IMPORT	void	cpu_interrupt	IPT2(CPU_INT_TYPE, intType, IU16, intNum);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_clearHwInt	IPT0();
#define	cpu_clearHwInt	c_cpu_clearHwInt
#else	/* CCPU */

#ifdef PROD
#define	cpu_clearHwInt	(*(Cpu.ClearHwInt))
#else /* PROD */
IMPORT	void	cpu_clearHwInt	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_EOA_hook	IPT0();
#define	cpu_EOA_hook	c_cpu_EOA_hook
#else	/* CCPU */

#ifdef PROD
#define	cpu_EOA_hook	(*(Cpu.EndOfApplication))
#else /* PROD */
IMPORT	void	cpu_EOA_hook	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_terminate	IPT0();
#define	cpu_terminate	c_cpu_terminate
#else	/* CCPU */

#ifdef PROD
#define	cpu_terminate	(*(Cpu.Terminate))
#else /* PROD */
IMPORT	void	cpu_terminate	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_init	IPT0();
#define	cpu_init	c_cpu_init
#else	/* CCPU */

#ifdef PROD
#define	cpu_init	(*(Cpu.Initialise))
#else /* PROD */
IMPORT	void	cpu_init	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_q_ev_set_count	IPT1(IU32, val);
#define	host_q_ev_set_count	c_cpu_q_ev_set_count
#else	/* CCPU */

#ifdef PROD
#define	host_q_ev_set_count	(*(Cpu.SetQuickEventCount))
#else /* PROD */
IMPORT	void	host_q_ev_set_count	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_cpu_q_ev_get_count	IPT0();
#define	host_q_ev_get_count	c_cpu_q_ev_get_count
#else	/* CCPU */

#ifdef PROD
#define	host_q_ev_get_count	(*(Cpu.GetQuickEventCount))
#else /* PROD */
IMPORT	IU32	host_q_ev_get_count	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_cpu_calc_q_ev_inst_for_time	IPT1(IU32, val);
#define	host_calc_q_ev_inst_for_time	c_cpu_calc_q_ev_inst_for_time
#else	/* CCPU */

#ifdef PROD
#define	host_calc_q_ev_inst_for_time	(*(Cpu.CalcQuickEventInstTime))
#else /* PROD */
IMPORT	IU32	host_calc_q_ev_inst_for_time	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_init_ios_in	IPT4(IHP, InTables, IHP, OutTables, IUH, maxAdaptor, IU16, portMask);
#define	cpu_init_ios_in	c_cpu_init_ios_in
#else	/* CCPU */

#ifdef PROD
#define	cpu_init_ios_in	(*(Cpu.InitIOS))
#else /* PROD */
IMPORT	void	cpu_init_ios_in	IPT4(IHP, InTables, IHP, OutTables, IUH, maxAdaptor, IU16, portMask);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_inb	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_inb	c_cpu_define_inb
#else	/* CCPU */

#ifdef PROD
#define	ios_define_inb	(*(Cpu.DefineInb))
#else /* PROD */
IMPORT	void	ios_define_inb	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_inw	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_inw	c_cpu_define_inw
#else	/* CCPU */

#ifdef PROD
#define	ios_define_inw	(*(Cpu.DefineInw))
#else /* PROD */
IMPORT	void	ios_define_inw	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_ind	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_ind	c_cpu_define_ind
#else	/* CCPU */

#ifdef PROD
#define	ios_define_ind	(*(Cpu.DefineInd))
#else /* PROD */
IMPORT	void	ios_define_ind	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_outb	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_outb	c_cpu_define_outb
#else	/* CCPU */

#ifdef PROD
#define	ios_define_outb	(*(Cpu.DefineOutb))
#else /* PROD */
IMPORT	void	ios_define_outb	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_outw	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_outw	c_cpu_define_outw
#else	/* CCPU */

#ifdef PROD
#define	ios_define_outw	(*(Cpu.DefineOutw))
#else /* PROD */
IMPORT	void	ios_define_outw	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_cpu_define_outd	IPT2(IUH, adaptor, IHP, func);
#define	ios_define_outd	c_cpu_define_outd
#else	/* CCPU */

#ifdef PROD
#define	ios_define_outd	(*(Cpu.DefineOutd))
#else /* PROD */
IMPORT	void	ios_define_outd	IPT2(IUH, adaptor, IHP, func);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAL	IPT1(IU8, val);
#define	setAL(val)	c_setAL(val)
#else	/* CCPU */

#ifdef PROD
#define	setAL(val)	(*(Cpu.SetAL))(val)
#else /* PROD */
IMPORT	void	setAL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAH	IPT1(IU8, val);
#define	setAH(val)	c_setAH(val)
#else	/* CCPU */

#ifdef PROD
#define	setAH(val)	(*(Cpu.SetAH))(val)
#else /* PROD */
IMPORT	void	setAH	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAX	IPT1(IU16, val);
#define	setAX(val)	c_setAX(val)
#else	/* CCPU */

#ifdef PROD
#define	setAX(val)	(*(Cpu.SetAX))(val)
#else /* PROD */
IMPORT	void	setAX	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEAX	IPT1(IU32, val);
#define	setEAX(val)	c_setEAX(val)
#else	/* CCPU */

#ifdef PROD
#define	setEAX(val)	(*(Cpu.SetEAX))(val)
#else /* PROD */
IMPORT	void	setEAX	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setBL	IPT1(IU8, val);
#define	setBL(val)	c_setBL(val)
#else	/* CCPU */

#ifdef PROD
#define	setBL(val)	(*(Cpu.SetBL))(val)
#else /* PROD */
IMPORT	void	setBL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setBH	IPT1(IU8, val);
#define	setBH(val)	c_setBH(val)
#else	/* CCPU */

#ifdef PROD
#define	setBH(val)	(*(Cpu.SetBH))(val)
#else /* PROD */
IMPORT	void	setBH	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setBX	IPT1(IU16, val);
#define	setBX(val)	c_setBX(val)
#else	/* CCPU */

#ifdef PROD
#define	setBX(val)	(*(Cpu.SetBX))(val)
#else /* PROD */
IMPORT	void	setBX	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEBX	IPT1(IU32, val);
#define	setEBX(val)	c_setEBX(val)
#else	/* CCPU */

#ifdef PROD
#define	setEBX(val)	(*(Cpu.SetEBX))(val)
#else /* PROD */
IMPORT	void	setEBX	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCL	IPT1(IU8, val);
#define	setCL(val)	c_setCL(val)
#else	/* CCPU */

#ifdef PROD
#define	setCL(val)	(*(Cpu.SetCL))(val)
#else /* PROD */
IMPORT	void	setCL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCH	IPT1(IU8, val);
#define	setCH(val)	c_setCH(val)
#else	/* CCPU */

#ifdef PROD
#define	setCH(val)	(*(Cpu.SetCH))(val)
#else /* PROD */
IMPORT	void	setCH	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCX	IPT1(IU16, val);
#define	setCX(val)	c_setCX(val)
#else	/* CCPU */

#ifdef PROD
#define	setCX(val)	(*(Cpu.SetCX))(val)
#else /* PROD */
IMPORT	void	setCX	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setECX	IPT1(IU32, val);
#define	setECX(val)	c_setECX(val)
#else	/* CCPU */

#ifdef PROD
#define	setECX(val)	(*(Cpu.SetECX))(val)
#else /* PROD */
IMPORT	void	setECX	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDL	IPT1(IU8, val);
#define	setDL(val)	c_setDL(val)
#else	/* CCPU */

#ifdef PROD
#define	setDL(val)	(*(Cpu.SetDL))(val)
#else /* PROD */
IMPORT	void	setDL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDH	IPT1(IU8, val);
#define	setDH(val)	c_setDH(val)
#else	/* CCPU */

#ifdef PROD
#define	setDH(val)	(*(Cpu.SetDH))(val)
#else /* PROD */
IMPORT	void	setDH	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDX	IPT1(IU16, val);
#define	setDX(val)	c_setDX(val)
#else	/* CCPU */

#ifdef PROD
#define	setDX(val)	(*(Cpu.SetDX))(val)
#else /* PROD */
IMPORT	void	setDX	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEDX	IPT1(IU32, val);
#define	setEDX(val)	c_setEDX(val)
#else	/* CCPU */

#ifdef PROD
#define	setEDX(val)	(*(Cpu.SetEDX))(val)
#else /* PROD */
IMPORT	void	setEDX	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSI	IPT1(IU16, val);
#define	setSI(val)	c_setSI(val)
#else	/* CCPU */

#ifdef PROD
#define	setSI(val)	(*(Cpu.SetSI))(val)
#else /* PROD */
IMPORT	void	setSI	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setESI	IPT1(IU32, val);
#define	setESI(val)	c_setESI(val)
#else	/* CCPU */

#ifdef PROD
#define	setESI(val)	(*(Cpu.SetESI))(val)
#else /* PROD */
IMPORT	void	setESI	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDI	IPT1(IU16, val);
#define	setDI(val)	c_setDI(val)
#else	/* CCPU */

#ifdef PROD
#define	setDI(val)	(*(Cpu.SetDI))(val)
#else /* PROD */
IMPORT	void	setDI	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEDI	IPT1(IU32, val);
#define	setEDI(val)	c_setEDI(val)
#else	/* CCPU */

#ifdef PROD
#define	setEDI(val)	(*(Cpu.SetEDI))(val)
#else /* PROD */
IMPORT	void	setEDI	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSP	IPT1(IU16, val);
#define	setSP(val)	c_setSP(val)
#else	/* CCPU */

#ifdef PROD
#define	setSP(val)	(*(Cpu.SetSP))(val)
#else /* PROD */
IMPORT	void	setSP	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setESP	IPT1(IU32, val);
#define	setESP(val)	c_setESP(val)
#else	/* CCPU */

#ifdef PROD
#define	setESP(val)	(*(Cpu.SetESP))(val)
#else /* PROD */
IMPORT	void	setESP	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setBP	IPT1(IU16, val);
#define	setBP(val)	c_setBP(val)
#else	/* CCPU */

#ifdef PROD
#define	setBP(val)	(*(Cpu.SetBP))(val)
#else /* PROD */
IMPORT	void	setBP	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEBP	IPT1(IU32, val);
#define	setEBP(val)	c_setEBP(val)
#else	/* CCPU */

#ifdef PROD
#define	setEBP(val)	(*(Cpu.SetEBP))(val)
#else /* PROD */
IMPORT	void	setEBP	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setIP	IPT1(IU16, val);
#define	setIP(val)	c_setIP(val)
#else	/* CCPU */

#ifdef PROD
#define	setIP(val)	(*(Cpu.SetIP))(val)
#else /* PROD */
IMPORT	void	setIP	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEIP	IPT1(IU32, val);
#define	setEIP(val)	c_setEIP(val)
#else	/* CCPU */

#ifdef PROD
#define	setEIP(val)	(*(Cpu.SetEIP))(val)
#else /* PROD */
IMPORT	void	setEIP	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setCS	IPT1(IU16, val);
#define	setCS(val)	c_setCS(val)
#else	/* CCPU */

#ifdef PROD
#define	setCS(val)	(*(Cpu.SetCS))(val)
#else /* PROD */
IMPORT	IUH	setCS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setSS	IPT1(IU16, val);
#define	setSS(val)	c_setSS(val)
#else	/* CCPU */

#ifdef PROD
#define	setSS(val)	(*(Cpu.SetSS))(val)
#else /* PROD */
IMPORT	IUH	setSS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setDS	IPT1(IU16, val);
#define	setDS(val)	c_setDS(val)
#else	/* CCPU */

#ifdef PROD
#define	setDS(val)	(*(Cpu.SetDS))(val)
#else /* PROD */
IMPORT	IUH	setDS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setES	IPT1(IU16, val);
#define	setES(val)	c_setES(val)
#else	/* CCPU */

#ifdef PROD
#define	setES(val)	(*(Cpu.SetES))(val)
#else /* PROD */
IMPORT	IUH	setES	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setFS	IPT1(IU16, val);
#define	setFS(val)	c_setFS(val)
#else	/* CCPU */

#ifdef PROD
#define	setFS(val)	(*(Cpu.SetFS))(val)
#else /* PROD */
IMPORT	IUH	setFS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_setGS	IPT1(IU16, val);
#define	setGS(val)	c_setGS(val)
#else	/* CCPU */

#ifdef PROD
#define	setGS(val)	(*(Cpu.SetGS))(val)
#else /* PROD */
IMPORT	IUH	setGS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEFLAGS	IPT1(IU32, val);
#define	setEFLAGS(val)	c_setEFLAGS(val)
#else	/* CCPU */

#ifdef PROD
#define	setEFLAGS(val)	(*(Cpu.SetEFLAGS))(val)
#else /* PROD */
IMPORT	void	setEFLAGS	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSTATUS	IPT1(IU16, val);
#define	setSTATUS(val)	c_setSTATUS(val)
#else	/* CCPU */

#ifdef PROD
#define	setSTATUS(val)	(*(Cpu.SetSTATUS))(val)
#else /* PROD */
IMPORT	void	setSTATUS	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setIOPL	IPT1(IU8, val);
#define	setIOPL(val)	c_setIOPL(val)
#else	/* CCPU */

#ifdef PROD
#define	setIOPL(val)	(*(Cpu.SetIOPL))(val)
#else /* PROD */
IMPORT	void	setIOPL	IPT1(IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setMSW	IPT1(IU16, val);
#define	setMSW(val)	c_setMSW(val)
#else	/* CCPU */

#ifdef PROD
#define	setMSW(val)	(*(Cpu.SetMSW))(val)
#else /* PROD */
IMPORT	void	setMSW	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCR0	IPT1(IU32, val);
#define	setCR0(val)	c_setCR0(val)
#else	/* CCPU */

#ifdef PROD
#define	setCR0(val)	(*(Cpu.SetCR0))(val)
#else /* PROD */
IMPORT	void	setCR0	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCR2	IPT1(IU32, val);
#define	setCR2(val)	c_setCR2(val)
#else	/* CCPU */

#ifdef PROD
#define	setCR2(val)	(*(Cpu.SetCR2))(val)
#else /* PROD */
IMPORT	void	setCR2	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCR3	IPT1(IU32, val);
#define	setCR3(val)	c_setCR3(val)
#else	/* CCPU */

#ifdef PROD
#define	setCR3(val)	(*(Cpu.SetCR3))(val)
#else /* PROD */
IMPORT	void	setCR3	IPT1(IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCF	IPT1(IBOOL, val);
#define	setCF(val)	c_setCF(val)
#else	/* CCPU */

#ifdef PROD
#define	setCF(val)	(*(Cpu.SetCF))(val)
#else /* PROD */
IMPORT	void	setCF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setPF	IPT1(IBOOL, val);
#define	setPF(val)	c_setPF(val)
#else	/* CCPU */

#ifdef PROD
#define	setPF(val)	(*(Cpu.SetPF))(val)
#else /* PROD */
IMPORT	void	setPF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAF	IPT1(IBOOL, val);
#define	setAF(val)	c_setAF(val)
#else	/* CCPU */

#ifdef PROD
#define	setAF(val)	(*(Cpu.SetAF))(val)
#else /* PROD */
IMPORT	void	setAF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setZF	IPT1(IBOOL, val);
#define	setZF(val)	c_setZF(val)
#else	/* CCPU */

#ifdef PROD
#define	setZF(val)	(*(Cpu.SetZF))(val)
#else /* PROD */
IMPORT	void	setZF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSF	IPT1(IBOOL, val);
#define	setSF(val)	c_setSF(val)
#else	/* CCPU */

#ifdef PROD
#define	setSF(val)	(*(Cpu.SetSF))(val)
#else /* PROD */
IMPORT	void	setSF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setTF	IPT1(IBOOL, val);
#define	setTF(val)	c_setTF(val)
#else	/* CCPU */

#ifdef PROD
#define	setTF(val)	(*(Cpu.SetTF))(val)
#else /* PROD */
IMPORT	void	setTF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setIF	IPT1(IBOOL, val);
#define	setIF(val)	c_setIF(val)
#else	/* CCPU */

#ifdef PROD
#define	setIF(val)	(*(Cpu.SetIF))(val)
#else /* PROD */
IMPORT	void	setIF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDF	IPT1(IBOOL, val);
#define	setDF(val)	c_setDF(val)
#else	/* CCPU */

#ifdef PROD
#define	setDF(val)	(*(Cpu.SetDF))(val)
#else /* PROD */
IMPORT	void	setDF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setOF	IPT1(IBOOL, val);
#define	setOF(val)	c_setOF(val)
#else	/* CCPU */

#ifdef PROD
#define	setOF(val)	(*(Cpu.SetOF))(val)
#else /* PROD */
IMPORT	void	setOF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setNT	IPT1(IBOOL, val);
#define	setNT(val)	c_setNT(val)
#else	/* CCPU */

#ifdef PROD
#define	setNT(val)	(*(Cpu.SetNT))(val)
#else /* PROD */
IMPORT	void	setNT	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setRF	IPT1(IBOOL, val);
#define	setRF(val)	c_setRF(val)
#else	/* CCPU */

#ifdef PROD
#define	setRF(val)	(*(Cpu.SetRF))(val)
#else /* PROD */
IMPORT	void	setRF	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setVM	IPT1(IBOOL, val);
#define	setVM(val)	c_setVM(val)
#else	/* CCPU */

#ifdef PROD
#define	setVM(val)	(*(Cpu.SetVM))(val)
#else /* PROD */
IMPORT	void	setVM	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setAC	IPT1(IBOOL, val);
#define	setAC(val)	c_setAC(val)
#else	/* CCPU */

#ifdef PROD
#define	setAC(val)	(*(Cpu.SetAC))(val)
#else /* PROD */
IMPORT	void	setAC	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setPE	IPT1(IBOOL, val);
#define	setPE(val)	c_setPE(val)
#else	/* CCPU */

#ifdef PROD
#define	setPE(val)	(*(Cpu.SetPE))(val)
#else /* PROD */
IMPORT	void	setPE	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setMP	IPT1(IBOOL, val);
#define	setMP(val)	c_setMP(val)
#else	/* CCPU */

#ifdef PROD
#define	setMP(val)	(*(Cpu.SetMP))(val)
#else /* PROD */
IMPORT	void	setMP	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setEM	IPT1(IBOOL, val);
#define	setEM(val)	c_setEM(val)
#else	/* CCPU */

#ifdef PROD
#define	setEM(val)	(*(Cpu.SetEM))(val)
#else /* PROD */
IMPORT	void	setEM	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setTS	IPT1(IBOOL, val);
#define	setTS(val)	c_setTS(val)
#else	/* CCPU */

#ifdef PROD
#define	setTS(val)	(*(Cpu.SetTS))(val)
#else /* PROD */
IMPORT	void	setTS	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setPG	IPT1(IBOOL, val);
#define	setPG(val)	c_setPG(val)
#else	/* CCPU */

#ifdef PROD
#define	setPG(val)	(*(Cpu.SetPG))(val)
#else /* PROD */
IMPORT	void	setPG	IPT1(IBOOL, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setLDT_SELECTOR	IPT1(IU16, val);
#define	setLDT_SELECTOR(val)	c_setLDT_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setLDT_SELECTOR(val)	(*(Cpu.SetLDT_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setLDT_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setTR_SELECTOR	IPT1(IU16, val);
#define	setTR_SELECTOR(val)	c_setTR_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setTR_SELECTOR(val)	(*(Cpu.SetTR_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setTR_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getAL	IPT0();
#define	getAL()	c_getAL()
#else	/* CCPU */

#ifdef PROD
#define	getAL()	(*(Cpu.GetAL))()
#else /* PROD */
IMPORT	IU8	getAL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getAH	IPT0();
#define	getAH()	c_getAH()
#else	/* CCPU */

#ifdef PROD
#define	getAH()	(*(Cpu.GetAH))()
#else /* PROD */
IMPORT	IU8	getAH	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getAX	IPT0();
#define	getAX()	c_getAX()
#else	/* CCPU */

#ifdef PROD
#define	getAX()	(*(Cpu.GetAX))()
#else /* PROD */
IMPORT	IU16	getAX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEAX	IPT0();
#define	getEAX()	c_getEAX()
#else	/* CCPU */

#ifdef PROD
#define	getEAX()	(*(Cpu.GetEAX))()
#else /* PROD */
IMPORT	IU32	getEAX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getBL	IPT0();
#define	getBL()	c_getBL()
#else	/* CCPU */

#ifdef PROD
#define	getBL()	(*(Cpu.GetBL))()
#else /* PROD */
IMPORT	IU8	getBL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getBH	IPT0();
#define	getBH()	c_getBH()
#else	/* CCPU */

#ifdef PROD
#define	getBH()	(*(Cpu.GetBH))()
#else /* PROD */
IMPORT	IU8	getBH	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getBX	IPT0();
#define	getBX()	c_getBX()
#else	/* CCPU */

#ifdef PROD
#define	getBX()	(*(Cpu.GetBX))()
#else /* PROD */
IMPORT	IU16	getBX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEBX	IPT0();
#define	getEBX()	c_getEBX()
#else	/* CCPU */

#ifdef PROD
#define	getEBX()	(*(Cpu.GetEBX))()
#else /* PROD */
IMPORT	IU32	getEBX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getCL	IPT0();
#define	getCL()	c_getCL()
#else	/* CCPU */

#ifdef PROD
#define	getCL()	(*(Cpu.GetCL))()
#else /* PROD */
IMPORT	IU8	getCL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getCH	IPT0();
#define	getCH()	c_getCH()
#else	/* CCPU */

#ifdef PROD
#define	getCH()	(*(Cpu.GetCH))()
#else /* PROD */
IMPORT	IU8	getCH	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getCX	IPT0();
#define	getCX()	c_getCX()
#else	/* CCPU */

#ifdef PROD
#define	getCX()	(*(Cpu.GetCX))()
#else /* PROD */
IMPORT	IU16	getCX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getECX	IPT0();
#define	getECX()	c_getECX()
#else	/* CCPU */

#ifdef PROD
#define	getECX()	(*(Cpu.GetECX))()
#else /* PROD */
IMPORT	IU32	getECX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getDL	IPT0();
#define	getDL()	c_getDL()
#else	/* CCPU */

#ifdef PROD
#define	getDL()	(*(Cpu.GetDL))()
#else /* PROD */
IMPORT	IU8	getDL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getDH	IPT0();
#define	getDH()	c_getDH()
#else	/* CCPU */

#ifdef PROD
#define	getDH()	(*(Cpu.GetDH))()
#else /* PROD */
IMPORT	IU8	getDH	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDX	IPT0();
#define	getDX()	c_getDX()
#else	/* CCPU */

#ifdef PROD
#define	getDX()	(*(Cpu.GetDX))()
#else /* PROD */
IMPORT	IU16	getDX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEDX	IPT0();
#define	getEDX()	c_getEDX()
#else	/* CCPU */

#ifdef PROD
#define	getEDX()	(*(Cpu.GetEDX))()
#else /* PROD */
IMPORT	IU32	getEDX	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSI	IPT0();
#define	getSI()	c_getSI()
#else	/* CCPU */

#ifdef PROD
#define	getSI()	(*(Cpu.GetSI))()
#else /* PROD */
IMPORT	IU16	getSI	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getESI	IPT0();
#define	getESI()	c_getESI()
#else	/* CCPU */

#ifdef PROD
#define	getESI()	(*(Cpu.GetESI))()
#else /* PROD */
IMPORT	IU32	getESI	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDI	IPT0();
#define	getDI()	c_getDI()
#else	/* CCPU */

#ifdef PROD
#define	getDI()	(*(Cpu.GetDI))()
#else /* PROD */
IMPORT	IU16	getDI	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEDI	IPT0();
#define	getEDI()	c_getEDI()
#else	/* CCPU */

#ifdef PROD
#define	getEDI()	(*(Cpu.GetEDI))()
#else /* PROD */
IMPORT	IU32	getEDI	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSP	IPT0();
#define	getSP()	c_getSP()
#else	/* CCPU */

#ifdef PROD
#define	getSP()	(*(Cpu.GetSP))()
#else /* PROD */
IMPORT	IU16	getSP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getESP	IPT0();
#define	getESP()	c_getESP()
#else	/* CCPU */

#ifdef PROD
#define	getESP()	(*(Cpu.GetESP))()
#else /* PROD */
IMPORT	IU32	getESP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getBP	IPT0();
#define	getBP()	c_getBP()
#else	/* CCPU */

#ifdef PROD
#define	getBP()	(*(Cpu.GetBP))()
#else /* PROD */
IMPORT	IU16	getBP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEBP	IPT0();
#define	getEBP()	c_getEBP()
#else	/* CCPU */

#ifdef PROD
#define	getEBP()	(*(Cpu.GetEBP))()
#else /* PROD */
IMPORT	IU32	getEBP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getIP	IPT0();
#define	getIP()	c_getIP()
#else	/* CCPU */

#ifdef PROD
#define	getIP()	(*(Cpu.GetIP))()
#else /* PROD */
IMPORT	IU16	getIP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEIP	IPT0();
#define	getEIP()	c_getEIP()
#else	/* CCPU */

#ifdef PROD
#define	getEIP()	(*(Cpu.GetEIP))()
#else /* PROD */
IMPORT	IU32	getEIP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getCS	IPT0();
#define	getCS()	c_getCS()
#else	/* CCPU */

#ifdef PROD
#define	getCS()	(*(Cpu.GetCS))()
#else /* PROD */
IMPORT	IU16	getCS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSS	IPT0();
#define	getSS()	c_getSS()
#else	/* CCPU */

#ifdef PROD
#define	getSS()	(*(Cpu.GetSS))()
#else /* PROD */
IMPORT	IU16	getSS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDS	IPT0();
#define	getDS()	c_getDS()
#else	/* CCPU */

#ifdef PROD
#define	getDS()	(*(Cpu.GetDS))()
#else /* PROD */
IMPORT	IU16	getDS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getES	IPT0();
#define	getES()	c_getES()
#else	/* CCPU */

#ifdef PROD
#define	getES()	(*(Cpu.GetES))()
#else /* PROD */
IMPORT	IU16	getES	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getFS	IPT0();
#define	getFS()	c_getFS()
#else	/* CCPU */

#ifdef PROD
#define	getFS()	(*(Cpu.GetFS))()
#else /* PROD */
IMPORT	IU16	getFS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getGS	IPT0();
#define	getGS()	c_getGS()
#else	/* CCPU */

#ifdef PROD
#define	getGS()	(*(Cpu.GetGS))()
#else /* PROD */
IMPORT	IU16	getGS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getEFLAGS	IPT0();
#define	getEFLAGS()	c_getEFLAGS()
#else	/* CCPU */

#ifdef PROD
#define	getEFLAGS()	(*(Cpu.GetEFLAGS))()
#else /* PROD */
IMPORT	IU32	getEFLAGS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSTATUS	IPT0();
#define	getSTATUS()	c_getSTATUS()
#else	/* CCPU */

#ifdef PROD
#define	getSTATUS()	(*(Cpu.GetSTATUS))()
#else /* PROD */
IMPORT	IU16	getSTATUS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_getIOPL	IPT0();
#define	getIOPL()	c_getIOPL()
#else	/* CCPU */

#ifdef PROD
#define	getIOPL()	(*(Cpu.GetIOPL))()
#else /* PROD */
IMPORT	IU8	getIOPL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getMSW	IPT0();
#define	getMSW()	c_getMSW()
#else	/* CCPU */

#ifdef PROD
#define	getMSW()	(*(Cpu.GetMSW))()
#else /* PROD */
IMPORT	IU16	getMSW	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCR0	IPT0();
#define	getCR0()	c_getCR0()
#else	/* CCPU */

#ifdef PROD
#define	getCR0()	(*(Cpu.GetCR0))()
#else /* PROD */
IMPORT	IU32	getCR0	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCR2	IPT0();
#define	getCR2()	c_getCR2()
#else	/* CCPU */

#ifdef PROD
#define	getCR2()	(*(Cpu.GetCR2))()
#else /* PROD */
IMPORT	IU32	getCR2	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCR3	IPT0();
#define	getCR3()	c_getCR3()
#else	/* CCPU */

#ifdef PROD
#define	getCR3()	(*(Cpu.GetCR3))()
#else /* PROD */
IMPORT	IU32	getCR3	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getCF	IPT0();
#define	getCF()	c_getCF()
#else	/* CCPU */

#ifdef PROD
#define	getCF()	(*(Cpu.GetCF))()
#else /* PROD */
IMPORT	IBOOL	getCF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getPF	IPT0();
#define	getPF()	c_getPF()
#else	/* CCPU */

#ifdef PROD
#define	getPF()	(*(Cpu.GetPF))()
#else /* PROD */
IMPORT	IBOOL	getPF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getAF	IPT0();
#define	getAF()	c_getAF()
#else	/* CCPU */

#ifdef PROD
#define	getAF()	(*(Cpu.GetAF))()
#else /* PROD */
IMPORT	IBOOL	getAF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getZF	IPT0();
#define	getZF()	c_getZF()
#else	/* CCPU */

#ifdef PROD
#define	getZF()	(*(Cpu.GetZF))()
#else /* PROD */
IMPORT	IBOOL	getZF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getSF	IPT0();
#define	getSF()	c_getSF()
#else	/* CCPU */

#ifdef PROD
#define	getSF()	(*(Cpu.GetSF))()
#else /* PROD */
IMPORT	IBOOL	getSF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getTF	IPT0();
#define	getTF()	c_getTF()
#else	/* CCPU */

#ifdef PROD
#define	getTF()	(*(Cpu.GetTF))()
#else /* PROD */
IMPORT	IBOOL	getTF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getIF	IPT0();
#define	getIF()	c_getIF()
#else	/* CCPU */

#ifdef PROD
#define	getIF()	(*(Cpu.GetIF))()
#else /* PROD */
IMPORT	IBOOL	getIF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getDF	IPT0();
#define	getDF()	c_getDF()
#else	/* CCPU */

#ifdef PROD
#define	getDF()	(*(Cpu.GetDF))()
#else /* PROD */
IMPORT	IBOOL	getDF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getOF	IPT0();
#define	getOF()	c_getOF()
#else	/* CCPU */

#ifdef PROD
#define	getOF()	(*(Cpu.GetOF))()
#else /* PROD */
IMPORT	IBOOL	getOF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getNT	IPT0();
#define	getNT()	c_getNT()
#else	/* CCPU */

#ifdef PROD
#define	getNT()	(*(Cpu.GetNT))()
#else /* PROD */
IMPORT	IBOOL	getNT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getRF	IPT0();
#define	getRF()	c_getRF()
#else	/* CCPU */

#ifdef PROD
#define	getRF()	(*(Cpu.GetRF))()
#else /* PROD */
IMPORT	IBOOL	getRF	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getVM	IPT0();
#define	getVM()	c_getVM()
#else	/* CCPU */

#ifdef PROD
#define	getVM()	(*(Cpu.GetVM))()
#else /* PROD */
IMPORT	IBOOL	getVM	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getAC	IPT0();
#define	getAC()	c_getAC()
#else	/* CCPU */

#ifdef PROD
#define	getAC()	(*(Cpu.GetAC))()
#else /* PROD */
IMPORT	IBOOL	getAC	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getPE	IPT0();
#define	getPE()	c_getPE()
#else	/* CCPU */

#ifdef PROD
#define	getPE()	(*(Cpu.GetPE))()
#else /* PROD */
IMPORT	IBOOL	getPE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getMP	IPT0();
#define	getMP()	c_getMP()
#else	/* CCPU */

#ifdef PROD
#define	getMP()	(*(Cpu.GetMP))()
#else /* PROD */
IMPORT	IBOOL	getMP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getEM	IPT0();
#define	getEM()	c_getEM()
#else	/* CCPU */

#ifdef PROD
#define	getEM()	(*(Cpu.GetEM))()
#else /* PROD */
IMPORT	IBOOL	getEM	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getTS	IPT0();
#define	getTS()	c_getTS()
#else	/* CCPU */

#ifdef PROD
#define	getTS()	(*(Cpu.GetTS))()
#else /* PROD */
IMPORT	IBOOL	getTS	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getET	IPT0();
#define	getET()	c_getET()
#else	/* CCPU */

#ifdef PROD
#define	getET()	(*(Cpu.GetET))()
#else /* PROD */
IMPORT	IBOOL	getET	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getNE	IPT0();
#define	getNE()	c_getNE()
#else	/* CCPU */

#ifdef PROD
#define	getNE()	(*(Cpu.GetNE))()
#else /* PROD */
IMPORT	IBOOL	getNE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getWP	IPT0();
#define	getWP()	c_getWP()
#else	/* CCPU */

#ifdef PROD
#define	getWP()	(*(Cpu.GetWP))()
#else /* PROD */
IMPORT	IBOOL	getWP	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_getPG	IPT0();
#define	getPG()	c_getPG()
#else	/* CCPU */

#ifdef PROD
#define	getPG()	(*(Cpu.GetPG))()
#else /* PROD */
IMPORT	IBOOL	getPG	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getGDT_BASE	IPT0();
#define	getGDT_BASE()	c_getGDT_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getGDT_BASE()	(*(Cpu.GetGDT_BASE))()
#else /* PROD */
IMPORT	IU32	getGDT_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getGDT_LIMIT	IPT0();
#define	getGDT_LIMIT()	c_getGDT_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getGDT_LIMIT()	(*(Cpu.GetGDT_LIMIT))()
#else /* PROD */
IMPORT	IU16	getGDT_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getIDT_BASE	IPT0();
#define	getIDT_BASE()	c_getIDT_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getIDT_BASE()	(*(Cpu.GetIDT_BASE))()
#else /* PROD */
IMPORT	IU32	getIDT_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getIDT_LIMIT	IPT0();
#define	getIDT_LIMIT()	c_getIDT_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getIDT_LIMIT()	(*(Cpu.GetIDT_LIMIT))()
#else /* PROD */
IMPORT	IU16	getIDT_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getLDT_SELECTOR	IPT0();
#define	getLDT_SELECTOR()	c_getLDT_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getLDT_SELECTOR()	(*(Cpu.GetLDT_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getLDT_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getLDT_BASE	IPT0();
#define	getLDT_BASE()	c_getLDT_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getLDT_BASE()	(*(Cpu.GetLDT_BASE))()
#else /* PROD */
IMPORT	IU32	getLDT_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getLDT_LIMIT	IPT0();
#define	getLDT_LIMIT()	c_getLDT_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getLDT_LIMIT()	(*(Cpu.GetLDT_LIMIT))()
#else /* PROD */
IMPORT	IU32	getLDT_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getTR_SELECTOR	IPT0();
#define	getTR_SELECTOR()	c_getTR_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getTR_SELECTOR()	(*(Cpu.GetTR_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getTR_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getTR_BASE	IPT0();
#define	getTR_BASE()	c_getTR_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getTR_BASE()	(*(Cpu.GetTR_BASE))()
#else /* PROD */
IMPORT	IU32	getTR_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getTR_LIMIT	IPT0();
#define	getTR_LIMIT()	c_getTR_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getTR_LIMIT()	(*(Cpu.GetTR_LIMIT))()
#else /* PROD */
IMPORT	IU32	getTR_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getTR_AR	IPT0();
#define	getTR_AR()	c_getTR_AR()
#else	/* CCPU */

#ifdef PROD
#define	getTR_AR()	(*(Cpu.GetTR_AR))()
#else /* PROD */
IMPORT	IU16	getTR_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	host_get_q_calib_val	IPT0();
#define	host_get_q_calib_val	host_get_q_calib_val
#else	/* CCPU */

#ifdef PROD
#define	host_get_q_calib_val	(*(Cpu.GetJumpCalibrateVal))
#else /* PROD */
IMPORT	IUH	host_get_q_calib_val	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	host_get_jump_restart	IPT0();
#define	host_get_jump_restart	host_get_jump_restart
#else	/* CCPU */

#ifdef PROD
#define	host_get_jump_restart	(*(Cpu.GetJumpInitialVal))
#else /* PROD */
IMPORT	IUH	host_get_jump_restart	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	host_set_jump_restart	IPT1(IUH, initialVal);
#define	host_set_jump_restart(initialVal)	host_set_jump_restart(initialVal)
#else	/* CCPU */

#ifdef PROD
#define	host_set_jump_restart(initialVal)	(*(Cpu.SetJumpInitialVal))(initialVal)
#else /* PROD */
IMPORT	void	host_set_jump_restart	IPT1(IUH, initialVal);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	setEOIEnableAddr	IPT1(IU8 *, initialVal);
#define	setEOIEnableAddr(initialVal)	setEOIEnableAddr(initialVal)
#else	/* CCPU */

#ifdef PROD
#define	setEOIEnableAddr(initialVal)	(*(Cpu.SetEOIEnable))(initialVal)
#else /* PROD */
IMPORT	void	setEOIEnableAddr	IPT1(IU8 *, initialVal);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	setAddProfileDataPtr	IPT1(IHP, initialVal);
#define	setAddProfileDataPtr(initialVal)	setAddProfileDataPtr(initialVal)
#else	/* CCPU */

#ifdef PROD
#define	setAddProfileDataPtr(initialVal)	(*(Cpu.SetAddProfileData))(initialVal)
#else /* PROD */
IMPORT	void	setAddProfileDataPtr	IPT1(IHP, initialVal);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	setMaxProfileDataAddr	IPT1(IHP, initialVal);
#define	setMaxProfileDataAddr(initialVal)	setMaxProfileDataAddr(initialVal)
#else	/* CCPU */

#ifdef PROD
#define	setMaxProfileDataAddr(initialVal)	(*(Cpu.SetMaxProfileData))(initialVal)
#else /* PROD */
IMPORT	void	setMaxProfileDataAddr	IPT1(IHP, initialVal);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IHP	getAddProfileDataAddr	IPT0();
#define	getAddProfileDataAddr()	getAddProfileDataAddr()
#else	/* CCPU */

#ifdef PROD
#define	getAddProfileDataAddr()	(*(Cpu.GetAddProfileDataAddr))()
#else /* PROD */
IMPORT	IHP	getAddProfileDataAddr	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	PurgeLostIretHookLine	IPT1(IU16, lineNum);
#define	PurgeLostIretHookLine(lineNum)	PurgeLostIretHookLine(lineNum)
#else	/* CCPU */

#ifdef PROD
#define	PurgeLostIretHookLine(lineNum)	(*(Cpu.PurgeLostIretHookLine))(lineNum)
#else /* PROD */
IMPORT	void	PurgeLostIretHookLine	IPT1(IU16, lineNum);
#endif /*PROD*/

#endif	/* CCPU */

typedef struct CpuStateREC * TypeCpuStateRECptr;
typedef struct ConstraintBitMapREC * TypeConstraintBitMapRECptr;
typedef struct EntryPointCacheREC * TypeEntryPointCacheRECptr;

struct	CpuPrivateVector	{
	IHP	(*GetSadInfoTable)	IPT0();
	IBOOL	(*SetGDT_BASE_LIMIT)	IPT2(IU32,	base, IU16,	limit);
	IBOOL	(*SetIDT_BASE_LIMIT)	IPT2(IU32,	base, IU16,	limit);
	IBOOL	(*SetLDT_BASE_LIMIT)	IPT2(IU32,	base, IU32,	limit);
	IBOOL	(*SetTR_BASE_LIMIT)	IPT2(IU32,	base, IU32,	limit);
	IBOOL	(*SetTR_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetCS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetSS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetDS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetES_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetFS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	IBOOL	(*SetGS_BASE_LIMIT_AR)	IPT3(IU32,	base, IU32,	limit, IU16,	ar);
	void	(*SetCS_SELECTOR)	IPT1(IU16,	val);
	void	(*SetSS_SELECTOR)	IPT1(IU16,	val);
	void	(*SetDS_SELECTOR)	IPT1(IU16,	val);
	void	(*SetES_SELECTOR)	IPT1(IU16,	val);
	void	(*SetFS_SELECTOR)	IPT1(IU16,	val);
	void	(*SetGS_SELECTOR)	IPT1(IU16,	val);
	IU16	(*GetCS_SELECTOR)	IPT0();
	IU16	(*GetSS_SELECTOR)	IPT0();
	IU16	(*GetDS_SELECTOR)	IPT0();
	IU16	(*GetES_SELECTOR)	IPT0();
	IU16	(*GetFS_SELECTOR)	IPT0();
	IU16	(*GetGS_SELECTOR)	IPT0();
	IU32	(*GetCS_BASE)	IPT0();
	IU32	(*GetSS_BASE)	IPT0();
	IU32	(*GetDS_BASE)	IPT0();
	IU32	(*GetES_BASE)	IPT0();
	IU32	(*GetFS_BASE)	IPT0();
	IU32	(*GetGS_BASE)	IPT0();
	IU32	(*GetCS_LIMIT)	IPT0();
	IU32	(*GetSS_LIMIT)	IPT0();
	IU32	(*GetDS_LIMIT)	IPT0();
	IU32	(*GetES_LIMIT)	IPT0();
	IU32	(*GetFS_LIMIT)	IPT0();
	IU32	(*GetGS_LIMIT)	IPT0();
	IU16	(*GetCS_AR)	IPT0();
	IU16	(*GetSS_AR)	IPT0();
	IU16	(*GetDS_AR)	IPT0();
	IU16	(*GetES_AR)	IPT0();
	IU16	(*GetFS_AR)	IPT0();
	IU16	(*GetGS_AR)	IPT0();
	IUH	(*GetCPL)	IPT0();
	void	(*SetCPL)	IPT1(IUH,	prot);
	void	(*GetCpuState)	IPT1(TypeCpuStateRECptr,	state);
	void	(*SetCpuState)	IPT1(TypeCpuStateRECptr,	state);
	void	(*InitNanoCpu)	IPT1(IU32,	variety);
	void	(*PrepareBlocksToCompile)	IPT1(IU32,	variety);
	void	(*SetRegConstraint)	IPT2(IU32,	regId, IU8,	constraintType);
	void	(*GrowRecPool)	IPT0();
	void	(*BpiCompileBPI)	IPT1(char *,	instructions);
	void	(*TrashIntelRegisters)	IPT0();
	void	(*FmDeleteAllStructures)	IPT1(IU32,	newCR0);
	TypeConstraintBitMapRECptr	(*ConstraintsFromUnivEpcPtr)	IPT1(TypeEntryPointCacheRECptr,	univ);
	TypeConstraintBitMapRECptr	(*ConstraintsFromUnivHandle)	IPT1(IU16,	handle);
};

#ifdef	CCPU
IMPORT	IHP	c_getSadInfoTable	IPT0();
#define	getSadInfoTable()	c_getSadInfoTable()
#else	/* CCPU */

#ifdef PROD
#define	getSadInfoTable()	(*((*(Cpu.Private)).GetSadInfoTable))()
#else /* PROD */
IMPORT	IHP	getSadInfoTable	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setGDT_BASE_LIMIT	IPT2(IU32, base, IU16, limit);
#define	setGDT_BASE_LIMIT(base, limit)	c_setGDT_BASE_LIMIT(base, limit)
#else	/* CCPU */

#ifdef PROD
#define	setGDT_BASE_LIMIT(base, limit)	(*((*(Cpu.Private)).SetGDT_BASE_LIMIT))(base, limit)
#else /* PROD */
IMPORT	IBOOL	setGDT_BASE_LIMIT	IPT2(IU32, base, IU16, limit);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setIDT_BASE_LIMIT	IPT2(IU32, base, IU16, limit);
#define	setIDT_BASE_LIMIT(base, limit)	c_setIDT_BASE_LIMIT(base, limit)
#else	/* CCPU */

#ifdef PROD
#define	setIDT_BASE_LIMIT(base, limit)	(*((*(Cpu.Private)).SetIDT_BASE_LIMIT))(base, limit)
#else /* PROD */
IMPORT	IBOOL	setIDT_BASE_LIMIT	IPT2(IU32, base, IU16, limit);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setLDT_BASE_LIMIT	IPT2(IU32, base, IU32, limit);
#define	setLDT_BASE_LIMIT(base, limit)	c_setLDT_BASE_LIMIT(base, limit)
#else	/* CCPU */

#ifdef PROD
#define	setLDT_BASE_LIMIT(base, limit)	(*((*(Cpu.Private)).SetLDT_BASE_LIMIT))(base, limit)
#else /* PROD */
IMPORT	IBOOL	setLDT_BASE_LIMIT	IPT2(IU32, base, IU32, limit);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setTR_BASE_LIMIT	IPT2(IU32, base, IU32, limit);
#define	setTR_BASE_LIMIT(base, limit)	c_setTR_BASE_LIMIT(base, limit)
#else	/* CCPU */

#ifdef PROD
#define	setTR_BASE_LIMIT(base, limit)	(*((*(Cpu.Private)).SetTR_BASE_LIMIT))(base, limit)
#else /* PROD */
IMPORT	IBOOL	setTR_BASE_LIMIT	IPT2(IU32, base, IU32, limit);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setTR_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setTR_BASE_LIMIT_AR(base, limit, ar)	c_setTR_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setTR_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetTR_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setTR_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setCS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setCS_BASE_LIMIT_AR(base, limit, ar)	c_setCS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setCS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetCS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setCS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setSS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setSS_BASE_LIMIT_AR(base, limit, ar)	c_setSS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setSS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetSS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setSS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setDS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setDS_BASE_LIMIT_AR(base, limit, ar)	c_setDS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setDS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetDS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setDS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setES_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setES_BASE_LIMIT_AR(base, limit, ar)	c_setES_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setES_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetES_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setES_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setFS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setFS_BASE_LIMIT_AR(base, limit, ar)	c_setFS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setFS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetFS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setFS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_setGS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#define	setGS_BASE_LIMIT_AR(base, limit, ar)	c_setGS_BASE_LIMIT_AR(base, limit, ar)
#else	/* CCPU */

#ifdef PROD
#define	setGS_BASE_LIMIT_AR(base, limit, ar)	(*((*(Cpu.Private)).SetGS_BASE_LIMIT_AR))(base, limit, ar)
#else /* PROD */
IMPORT	IBOOL	setGS_BASE_LIMIT_AR	IPT3(IU32, base, IU32, limit, IU16, ar);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCS_SELECTOR	IPT1(IU16, val);
#define	setCS_SELECTOR(val)	c_setCS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setCS_SELECTOR(val)	(*((*(Cpu.Private)).SetCS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setCS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setSS_SELECTOR	IPT1(IU16, val);
#define	setSS_SELECTOR(val)	c_setSS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setSS_SELECTOR(val)	(*((*(Cpu.Private)).SetSS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setSS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setDS_SELECTOR	IPT1(IU16, val);
#define	setDS_SELECTOR(val)	c_setDS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setDS_SELECTOR(val)	(*((*(Cpu.Private)).SetDS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setDS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setES_SELECTOR	IPT1(IU16, val);
#define	setES_SELECTOR(val)	c_setES_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setES_SELECTOR(val)	(*((*(Cpu.Private)).SetES_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setES_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setFS_SELECTOR	IPT1(IU16, val);
#define	setFS_SELECTOR(val)	c_setFS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setFS_SELECTOR(val)	(*((*(Cpu.Private)).SetFS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setFS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setGS_SELECTOR	IPT1(IU16, val);
#define	setGS_SELECTOR(val)	c_setGS_SELECTOR(val)
#else	/* CCPU */

#ifdef PROD
#define	setGS_SELECTOR(val)	(*((*(Cpu.Private)).SetGS_SELECTOR))(val)
#else /* PROD */
IMPORT	void	setGS_SELECTOR	IPT1(IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getCS_SELECTOR	IPT0();
#define	getCS_SELECTOR()	c_getCS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getCS_SELECTOR()	(*((*(Cpu.Private)).GetCS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getCS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSS_SELECTOR	IPT0();
#define	getSS_SELECTOR()	c_getSS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getSS_SELECTOR()	(*((*(Cpu.Private)).GetSS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getSS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDS_SELECTOR	IPT0();
#define	getDS_SELECTOR()	c_getDS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getDS_SELECTOR()	(*((*(Cpu.Private)).GetDS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getDS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getES_SELECTOR	IPT0();
#define	getES_SELECTOR()	c_getES_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getES_SELECTOR()	(*((*(Cpu.Private)).GetES_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getES_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getFS_SELECTOR	IPT0();
#define	getFS_SELECTOR()	c_getFS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getFS_SELECTOR()	(*((*(Cpu.Private)).GetFS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getFS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getGS_SELECTOR	IPT0();
#define	getGS_SELECTOR()	c_getGS_SELECTOR()
#else	/* CCPU */

#ifdef PROD
#define	getGS_SELECTOR()	(*((*(Cpu.Private)).GetGS_SELECTOR))()
#else /* PROD */
IMPORT	IU16	getGS_SELECTOR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCS_BASE	IPT0();
#define	getCS_BASE()	c_getCS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getCS_BASE()	(*((*(Cpu.Private)).GetCS_BASE))()
#else /* PROD */
IMPORT	IU32	getCS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getSS_BASE	IPT0();
#define	getSS_BASE()	c_getSS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getSS_BASE()	(*((*(Cpu.Private)).GetSS_BASE))()
#else /* PROD */
IMPORT	IU32	getSS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getDS_BASE	IPT0();
#define	getDS_BASE()	c_getDS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getDS_BASE()	(*((*(Cpu.Private)).GetDS_BASE))()
#else /* PROD */
IMPORT	IU32	getDS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getES_BASE	IPT0();
#define	getES_BASE()	c_getES_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getES_BASE()	(*((*(Cpu.Private)).GetES_BASE))()
#else /* PROD */
IMPORT	IU32	getES_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getFS_BASE	IPT0();
#define	getFS_BASE()	c_getFS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getFS_BASE()	(*((*(Cpu.Private)).GetFS_BASE))()
#else /* PROD */
IMPORT	IU32	getFS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getGS_BASE	IPT0();
#define	getGS_BASE()	c_getGS_BASE()
#else	/* CCPU */

#ifdef PROD
#define	getGS_BASE()	(*((*(Cpu.Private)).GetGS_BASE))()
#else /* PROD */
IMPORT	IU32	getGS_BASE	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getCS_LIMIT	IPT0();
#define	getCS_LIMIT()	c_getCS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getCS_LIMIT()	(*((*(Cpu.Private)).GetCS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getCS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getSS_LIMIT	IPT0();
#define	getSS_LIMIT()	c_getSS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getSS_LIMIT()	(*((*(Cpu.Private)).GetSS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getSS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getDS_LIMIT	IPT0();
#define	getDS_LIMIT()	c_getDS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getDS_LIMIT()	(*((*(Cpu.Private)).GetDS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getDS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getES_LIMIT	IPT0();
#define	getES_LIMIT()	c_getES_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getES_LIMIT()	(*((*(Cpu.Private)).GetES_LIMIT))()
#else /* PROD */
IMPORT	IU32	getES_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getFS_LIMIT	IPT0();
#define	getFS_LIMIT()	c_getFS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getFS_LIMIT()	(*((*(Cpu.Private)).GetFS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getFS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_getGS_LIMIT	IPT0();
#define	getGS_LIMIT()	c_getGS_LIMIT()
#else	/* CCPU */

#ifdef PROD
#define	getGS_LIMIT()	(*((*(Cpu.Private)).GetGS_LIMIT))()
#else /* PROD */
IMPORT	IU32	getGS_LIMIT	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getCS_AR	IPT0();
#define	getCS_AR()	c_getCS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getCS_AR()	(*((*(Cpu.Private)).GetCS_AR))()
#else /* PROD */
IMPORT	IU16	getCS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getSS_AR	IPT0();
#define	getSS_AR()	c_getSS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getSS_AR()	(*((*(Cpu.Private)).GetSS_AR))()
#else /* PROD */
IMPORT	IU16	getSS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getDS_AR	IPT0();
#define	getDS_AR()	c_getDS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getDS_AR()	(*((*(Cpu.Private)).GetDS_AR))()
#else /* PROD */
IMPORT	IU16	getDS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getES_AR	IPT0();
#define	getES_AR()	c_getES_AR()
#else	/* CCPU */

#ifdef PROD
#define	getES_AR()	(*((*(Cpu.Private)).GetES_AR))()
#else /* PROD */
IMPORT	IU16	getES_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getFS_AR	IPT0();
#define	getFS_AR()	c_getFS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getFS_AR()	(*((*(Cpu.Private)).GetFS_AR))()
#else /* PROD */
IMPORT	IU16	getFS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_getGS_AR	IPT0();
#define	getGS_AR()	c_getGS_AR()
#else	/* CCPU */

#ifdef PROD
#define	getGS_AR()	(*((*(Cpu.Private)).GetGS_AR))()
#else /* PROD */
IMPORT	IU16	getGS_AR	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IUH	c_getCPL	IPT0();
#define	getCPL()	c_getCPL()
#else	/* CCPU */

#ifdef PROD
#define	getCPL()	(*((*(Cpu.Private)).GetCPL))()
#else /* PROD */
IMPORT	IUH	getCPL	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCPL	IPT1(IUH, prot);
#define	setCPL(prot)	c_setCPL(prot)
#else	/* CCPU */

#ifdef PROD
#define	setCPL(prot)	(*((*(Cpu.Private)).SetCPL))(prot)
#else /* PROD */
IMPORT	void	setCPL	IPT1(IUH, prot);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_getCpuState	IPT1(TypeCpuStateRECptr, state);
#define	getCpuState(state)	c_getCpuState(state)
#else	/* CCPU */

#ifdef PROD
#define	getCpuState(state)	(*((*(Cpu.Private)).GetCpuState))(state)
#else /* PROD */
IMPORT	void	getCpuState	IPT1(TypeCpuStateRECptr, state);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setCpuState	IPT1(TypeCpuStateRECptr, state);
#define	setCpuState(state)	c_setCpuState(state)
#else	/* CCPU */

#ifdef PROD
#define	setCpuState(state)	(*((*(Cpu.Private)).SetCpuState))(state)
#else /* PROD */
IMPORT	void	setCpuState	IPT1(TypeCpuStateRECptr, state);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_InitNanoCpu	IPT1(IU32, variety);
#define	initNanoCpu(variety)	c_InitNanoCpu(variety)
#else	/* CCPU */

#ifdef PROD
#define	initNanoCpu(variety)	(*((*(Cpu.Private)).InitNanoCpu))(variety)
#else /* PROD */
IMPORT	void	initNanoCpu	IPT1(IU32, variety);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_PrepareBlocksToCompile	IPT1(IU32, variety);
#define	prepareBlocksToCompile(variety)	c_PrepareBlocksToCompile(variety)
#else	/* CCPU */

#ifdef PROD
#define	prepareBlocksToCompile(variety)	(*((*(Cpu.Private)).PrepareBlocksToCompile))(variety)
#else /* PROD */
IMPORT	void	prepareBlocksToCompile	IPT1(IU32, variety);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_setRegConstraint	IPT2(IU32, regId, IU8, constraintType);
#define	setRegConstraint(regId, constraintType)	c_setRegConstraint(regId, constraintType)
#else	/* CCPU */

#ifdef PROD
#define	setRegConstraint(regId, constraintType)	(*((*(Cpu.Private)).SetRegConstraint))(regId, constraintType)
#else /* PROD */
IMPORT	void	setRegConstraint	IPT2(IU32, regId, IU8, constraintType);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_growRecPool	IPT0();
#define	growRecPool	c_growRecPool
#else	/* CCPU */

#ifdef PROD
#define	growRecPool	(*((*(Cpu.Private)).GrowRecPool))
#else /* PROD */
IMPORT	void	growRecPool	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	BpiCompileBPI(instructions)	(*((*(Cpu.Private)).BpiCompileBPI))(instructions)
#else /* PROD */
IMPORT	void	BpiCompileBPI	IPT1(char *, instructions);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_trashIntelRegisters	IPT0();
#define	trashIntelregisters	c_trashIntelRegisters
#else	/* CCPU */

#ifdef PROD
#define	trashIntelregisters	(*((*(Cpu.Private)).TrashIntelRegisters))
#else /* PROD */
IMPORT	void	trashIntelregisters	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	FmDeleteAllStructures(newCR0)	(*((*(Cpu.Private)).FmDeleteAllStructures))(newCR0)
#else /* PROD */
IMPORT	void	FmDeleteAllStructures	IPT1(IU32, newCR0);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	constraintsFromUnivEpcPtr(univ)	(*((*(Cpu.Private)).ConstraintsFromUnivEpcPtr))(univ)
#else /* PROD */
IMPORT	TypeConstraintBitMapRECptr	constraintsFromUnivEpcPtr	IPT1(TypeEntryPointCacheRECptr, univ);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	constraintsFromUnivHandle(handle)	(*((*(Cpu.Private)).ConstraintsFromUnivHandle))(handle)
#else /* PROD */
IMPORT	TypeConstraintBitMapRECptr	constraintsFromUnivHandle	IPT1(IU16, handle);
#endif /*PROD*/

#endif	/* CCPU */

/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\enter_c.h ===
#ifndef _Enter_c_h
#define _Enter_c_h
#endif /* ! _Enter_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\ev_stubs.c ===
#include <insignia.h>
#include <host_def.h>
/*[
 *  Name:	ev_stubs.c
 *  SCCS ID:	@(#)ev_stubs.c	1.1 07/22/94
 *
 *  Purpose:	Provide the stub routines needed to give the a4+evid
 *		and ccpu+cevid libraries the same interface.
 *
 * (C) Copyright Insignia Solutions Ltd, 1994.
]*/

GLOBAL void setup_vga_globals IFN0()
{
}
GLOBAL IHPE setup_global_data_ptr IFN0()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\cpu_c.h ===
#ifndef _Cpu_c_h
#define _Cpu_c_h
#define NANO_STATE_HIGH_BIT (14)
#define LAZY_FT (1)
enum cv
{
	SAFE_SEGMENT,
	PUSH_SAFE,
	POP_SAFE,
	BP_RELATED_SAFE,
	PROTECTED,
	VIRTUAL_8086,
	FLAT_SEGMENT,
	DF_BACKWARDS,
	NO_FLAGS,
	ALIGN_2,
	ALIGN_4,
	ADDRESS_SIZE_32,
	ACCESS_IS_READ,
	EXPAND_UP,
	COMPILE_TIME_FT,
	COMPILE_TIME_FT_PAD1,
	COMPILE_TIME_FT_PAD2,
	COMPILE_TIME_FT_PAD3,
	COMPILE_TIME_FT_PAD4,
	COMPILE_TIME_FT_PAD5,
	BEFORE_SINGLE,
	AFTER_SINGLE,
	COPIER_CHECK_OK,
	SF_UNCHECKED,
	SF_IOACCESS,
	INVERT_JCOND,
	LAST_CV
};
enum Constraints
{
	ConstraintPROTECTED = 0,
	ConstraintVIRTUAL_8086 = 1,
	ConstraintBIG_CODE = 2,
	ConstraintDF = 3,
	ConstraintRAX_LS16 = 4,
	ConstraintRAL_LS8 = 5,
	ConstraintRBX_LS16 = 6,
	ConstraintRBL_LS8 = 7,
	ConstraintRCX_LS16 = 8,
	ConstraintRCL_LS8 = 9,
	ConstraintRDX_LS16 = 10,
	ConstraintRDL_LS8 = 11,
	ConstraintRBP_LS16 = 12,
	ConstraintRSI_LS16 = 13,
	ConstraintRDI_LS16 = 14,
	ConstraintSfUnchecked = 15,
	ConstraintSfIOAccess = 16,
	ConstraintDS_SAFE = 17,
	ConstraintES_SAFE = 18,
	ConstraintFS_SAFE = 19,
	ConstraintGS_SAFE = 20,
	ConstraintPUSH_SAFE = 21,
	ConstraintPOP_SAFE = 22,
	ConstraintBP_RELATED_SAFE = 23,
	ConstraintBEFORE_SINGLE = 24,
	ConstraintAFTER_SINGLE = 25,
	ConstraintCS_FLAT = 26,
	ConstraintDS_FLAT = 27,
	ConstraintES_FLAT = 28,
	ConstraintFS_FLAT = 29,
	ConstraintGS_FLAT = 30,
	ConstraintSS_FLAT = 31,
	ConstraintODD_SEGMENT = 32,
	ConstraintNPX_DOES_INT7 = 33,
	ConstraintDEBUGGING = 34,
	ConstraintContext0 = 35,
	ConstraintContext1 = 36,
	ConstraintContext2 = 37,
	ConstraintContext3 = 38,
	ConstraintContext4 = 39,
	ConstraintContext5 = 40
};
enum Targets
{
	TargetUNKNOWN = 0,
	TargetALPHA64 = 1,
	TargetALPHA32 = 2,
	TargetHPP = 3,
	TargetPPC = 4,
	TargetSPARC = 5
};
#define Prod (0)
#define SwappedM (0)
#define Bigendian (1)
#define Asserts (1)
#define Pig (1)
#define Tracing (1)
#define Sad (1)
#define SyncTimer (0)
#define TargetArch (3)
#define Ic (0)
#define MustAlign (1)
#define BWOP (0)

/* #defines generated by tremit.c for maniplulating pointers
 * to Intel memory (that the caller knows will remain within a 4k page
 */
#ifndef SWAPPED_M /* This will be visible to mk -V checking*/
#define ConvertHostToCpuPtrLS0(base, size, offset) ((IHP)(((IU8 *)(base))+(size)-(offset)-1))
#define ConvertCpuPtrLS0toCpuPtrLS8(ls0ptr) ((IU8 *)(ls0ptr))
#define AddCpuPtrLS8(ptr, amount) ((ptr) - (amount))
#define IncCpuPtrLS8(ptr) (ptr)--
#define DecCpuPtrLS8(ptr) (ptr)++
#define DiffCpuPtrsLS8(lo, hi) ((lo) - (hi))
#define BelowCpuPtrsLS8(p1, p2) ((p1) > (p2))
#define BelowOrEqualCpuPtrsLS8(p1, p2) ((p1) >= (p2))
#define FloorIntelPageLS8(ptr) ((IU8 *) (((IHPE)(ptr)) | 0xFFF))
#define CeilingIntelPageLS8(ptr) ((IU8 *) (((IHPE)(ptr)) & ~((IHPE)0xFFF)))
#endif /* SWAPPED_M */

#define GDP_OFFSET	(0)
#endif /* ! _Cpu_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\evidgen.h ===
/*[
 * Generated File: evidgen.h
 *
]*/


struct	VideoVector	{
	IU32	(*GetVideolatches)	IPT0();
	IU8 *	(*GetVideorplane)	IPT0();
	IU8 *	(*GetVideowplane)	IPT0();
	IU8 *	(*GetVideoscratch)	IPT0();
	IU32	(*GetVideosr_masked_val)	IPT0();
	IU32	(*GetVideosr_nmask)	IPT0();
	IU32	(*GetVideodata_and_mask)	IPT0();
	IU32	(*GetVideodata_xor_mask)	IPT0();
	IU32	(*GetVideolatch_xor_mask)	IPT0();
	IU32	(*GetVideobit_prot_mask)	IPT0();
	IU32	(*GetVideoplane_enable)	IPT0();
	IU32	(*GetVideoplane_enable_mask)	IPT0();
	IHP	(*GetVideosr_lookup)	IPT0();
	IHP	(*GetVideofwd_str_read_addr)	IPT0();
	IHP	(*GetVideobwd_str_read_addr)	IPT0();
	IU32	(*GetVideodirty_total)	IPT0();
	IU32	(*GetVideodirty_low)	IPT0();
	IU32	(*GetVideodirty_high)	IPT0();
	IU8 *	(*GetVideovideo_copy)	IPT0();
	IHP	(*GetVideomark_byte)	IPT0();
	IHP	(*GetVideomark_word)	IPT0();
	IHP	(*GetVideomark_string)	IPT0();
	IU32	(*GetVideoread_shift_count)	IPT0();
	IU32	(*GetVideoread_mapped_plane)	IPT0();
	IU32	(*GetVideocolour_comp)	IPT0();
	IU32	(*GetVideodont_care)	IPT0();
	IU32	(*GetVideov7_bank_vid_copy_off)	IPT0();
	IU8 *	(*GetVideoscreen_ptr)	IPT0();
	IU32	(*GetVideorotate)	IPT0();
	IU32	(*GetVideocalc_data_xor)	IPT0();
	IU32	(*GetVideocalc_latch_xor)	IPT0();
	IHP	(*GetVideoread_byte_addr)	IPT0();
	IU32	(*GetVideov7_fg_latches)	IPT0();
	IHP	(*GetVideoGC_regs)	IPT0();
	IU8	(*GetVideolast_GC_index)	IPT0();
	IU8	(*GetVideodither)	IPT0();
	IU8	(*GetVideowrmode)	IPT0();
	IU8	(*GetVideochain)	IPT0();
	IU8	(*GetVideowrstate)	IPT0();
	void	(*SetVideolatches)	IPT1(IU32,	value);
	void	(*SetVideorplane)	IPT1(IU8 *,	value);
	void	(*SetVideowplane)	IPT1(IU8 *,	value);
	void	(*SetVideoscratch)	IPT1(IU8 *,	value);
	void	(*SetVideosr_masked_val)	IPT1(IU32,	value);
	void	(*SetVideosr_nmask)	IPT1(IU32,	value);
	void	(*SetVideodata_and_mask)	IPT1(IU32,	value);
	void	(*SetVideodata_xor_mask)	IPT1(IU32,	value);
	void	(*SetVideolatch_xor_mask)	IPT1(IU32,	value);
	void	(*SetVideobit_prot_mask)	IPT1(IU32,	value);
	void	(*SetVideoplane_enable)	IPT1(IU32,	value);
	void	(*SetVideoplane_enable_mask)	IPT1(IU32,	value);
	void	(*SetVideosr_lookup)	IPT1(IHP,	value);
	void	(*SetVideofwd_str_read_addr)	IPT1(IHP,	value);
	void	(*SetVideobwd_str_read_addr)	IPT1(IHP,	value);
	void	(*SetVideodirty_total)	IPT1(IU32,	value);
	void	(*SetVideodirty_low)	IPT1(IU32,	value);
	void	(*SetVideodirty_high)	IPT1(IU32,	value);
	void	(*SetVideovideo_copy)	IPT1(IU8 *,	value);
	void	(*SetVideomark_byte)	IPT1(IHP,	value);
	void	(*SetVideomark_word)	IPT1(IHP,	value);
	void	(*SetVideomark_string)	IPT1(IHP,	value);
	void	(*SetVideoread_shift_count)	IPT1(IU32,	value);
	void	(*SetVideoread_mapped_plane)	IPT1(IU32,	value);
	void	(*SetVideocolour_comp)	IPT1(IU32,	value);
	void	(*SetVideodont_care)	IPT1(IU32,	value);
	void	(*SetVideov7_bank_vid_copy_off)	IPT1(IU32,	value);
	void	(*SetVideoscreen_ptr)	IPT1(IU8 *,	value);
	void	(*SetVideorotate)	IPT1(IU32,	value);
	void	(*SetVideocalc_data_xor)	IPT1(IU32,	value);
	void	(*SetVideocalc_latch_xor)	IPT1(IU32,	value);
	void	(*SetVideoread_byte_addr)	IPT1(IHP,	value);
	void	(*SetVideov7_fg_latches)	IPT1(IU32,	value);
	void	(*SetVideoGC_regs)	IPT1(IHP,	value);
	void	(*SetVideolast_GC_index)	IPT1(IU8,	value);
	void	(*SetVideodither)	IPT1(IU8,	value);
	void	(*SetVideowrmode)	IPT1(IU8,	value);
	void	(*SetVideochain)	IPT1(IU8,	value);
	void	(*SetVideowrstate)	IPT1(IU8,	value);
	void	(*setWritePointers)	IPT0();
	void	(*setReadPointers)	IPT1(IUH,	readset);
	void	(*setMarkPointers)	IPT1(IUH,	markset);
};

extern	struct	VideoVector	Video;

#define	getVideolatches()	(*(Video.GetVideolatches))()
#define	getVideorplane()	(*(Video.GetVideorplane))()
#define	getVideowplane()	(*(Video.GetVideowplane))()
#define	getVideoscratch()	(*(Video.GetVideoscratch))()
#define	getVideosr_masked_val()	(*(Video.GetVideosr_masked_val))()
#define	getVideosr_nmask()	(*(Video.GetVideosr_nmask))()
#define	getVideodata_and_mask()	(*(Video.GetVideodata_and_mask))()
#define	getVideodata_xor_mask()	(*(Video.GetVideodata_xor_mask))()
#define	getVideolatch_xor_mask()	(*(Video.GetVideolatch_xor_mask))()
#define	getVideobit_prot_mask()	(*(Video.GetVideobit_prot_mask))()
#define	getVideoplane_enable()	(*(Video.GetVideoplane_enable))()
#define	getVideoplane_enable_mask()	(*(Video.GetVideoplane_enable_mask))()
#define	getVideosr_lookup()	(*(Video.GetVideosr_lookup))()
#define	getVideofwd_str_read_addr()	(*(Video.GetVideofwd_str_read_addr))()
#define	getVideobwd_str_read_addr()	(*(Video.GetVideobwd_str_read_addr))()
#define	getVideodirty_total()	(*(Video.GetVideodirty_total))()
#define	getVideodirty_low()	(*(Video.GetVideodirty_low))()
#define	getVideodirty_high()	(*(Video.GetVideodirty_high))()
#define	getVideovideo_copy()	(*(Video.GetVideovideo_copy))()
#define	getVideomark_byte()	(*(Video.GetVideomark_byte))()
#define	getVideomark_word()	(*(Video.GetVideomark_word))()
#define	getVideomark_string()	(*(Video.GetVideomark_string))()
#define	getVideoread_shift_count()	(*(Video.GetVideoread_shift_count))()
#define	getVideoread_mapped_plane()	(*(Video.GetVideoread_mapped_plane))()
#define	getVideocolour_comp()	(*(Video.GetVideocolour_comp))()
#define	getVideodont_care()	(*(Video.GetVideodont_care))()
#define	getVideov7_bank_vid_copy_off()	(*(Video.GetVideov7_bank_vid_copy_off))()
#define	getVideoscreen_ptr()	(*(Video.GetVideoscreen_ptr))()
#define	getVideorotate()	(*(Video.GetVideorotate))()
#define	getVideocalc_data_xor()	(*(Video.GetVideocalc_data_xor))()
#define	getVideocalc_latch_xor()	(*(Video.GetVideocalc_latch_xor))()
#define	getVideoread_byte_addr()	(*(Video.GetVideoread_byte_addr))()
#define	getVideov7_fg_latches()	(*(Video.GetVideov7_fg_latches))()
#define	getVideoGC_regs()	(*(Video.GetVideoGC_regs))()
#define	getVideolast_GC_index()	(*(Video.GetVideolast_GC_index))()
#define	getVideodither()	(*(Video.GetVideodither))()
#define	getVideowrmode()	(*(Video.GetVideowrmode))()
#define	getVideochain()	(*(Video.GetVideochain))()
#define	getVideowrstate()	(*(Video.GetVideowrstate))()
#define	setVideolatches(value)	(*(Video.SetVideolatches))(value)
#define	setVideorplane(value)	(*(Video.SetVideorplane))(value)
#define	setVideowplane(value)	(*(Video.SetVideowplane))(value)
#define	setVideoscratch(value)	(*(Video.SetVideoscratch))(value)
#define	setVideosr_masked_val(value)	(*(Video.SetVideosr_masked_val))(value)
#define	setVideosr_nmask(value)	(*(Video.SetVideosr_nmask))(value)
#define	setVideodata_and_mask(value)	(*(Video.SetVideodata_and_mask))(value)
#define	setVideodata_xor_mask(value)	(*(Video.SetVideodata_xor_mask))(value)
#define	setVideolatch_xor_mask(value)	(*(Video.SetVideolatch_xor_mask))(value)
#define	setVideobit_prot_mask(value)	(*(Video.SetVideobit_prot_mask))(value)
#define	setVideoplane_enable(value)	(*(Video.SetVideoplane_enable))(value)
#define	setVideoplane_enable_mask(value)	(*(Video.SetVideoplane_enable_mask))(value)
#define	setVideosr_lookup(value)	(*(Video.SetVideosr_lookup))(value)
#define	setVideofwd_str_read_addr(value)	(*(Video.SetVideofwd_str_read_addr))(value)
#define	setVideobwd_str_read_addr(value)	(*(Video.SetVideobwd_str_read_addr))(value)
#define	setVideodirty_total(value)	(*(Video.SetVideodirty_total))(value)
#define	setVideodirty_low(value)	(*(Video.SetVideodirty_low))(value)
#define	setVideodirty_high(value)	(*(Video.SetVideodirty_high))(value)
#define	setVideovideo_copy(value)	(*(Video.SetVideovideo_copy))(value)
#define	setVideomark_byte(value)	(*(Video.SetVideomark_byte))(value)
#define	setVideomark_word(value)	(*(Video.SetVideomark_word))(value)
#define	setVideomark_string(value)	(*(Video.SetVideomark_string))(value)
#define	setVideoread_shift_count(value)	(*(Video.SetVideoread_shift_count))(value)
#define	setVideoread_mapped_plane(value)	(*(Video.SetVideoread_mapped_plane))(value)
#define	setVideocolour_comp(value)	(*(Video.SetVideocolour_comp))(value)
#define	setVideodont_care(value)	(*(Video.SetVideodont_care))(value)
#define	setVideov7_bank_vid_copy_off(value)	(*(Video.SetVideov7_bank_vid_copy_off))(value)
#define	setVideoscreen_ptr(value)	(*(Video.SetVideoscreen_ptr))(value)
#define	setVideorotate(value)	(*(Video.SetVideorotate))(value)
#define	setVideocalc_data_xor(value)	(*(Video.SetVideocalc_data_xor))(value)
#define	setVideocalc_latch_xor(value)	(*(Video.SetVideocalc_latch_xor))(value)
#define	setVideoread_byte_addr(value)	(*(Video.SetVideoread_byte_addr))(value)
#define	setVideov7_fg_latches(value)	(*(Video.SetVideov7_fg_latches))(value)
#define	setVideoGC_regs(value)	(*(Video.SetVideoGC_regs))(value)
#define	setVideolast_GC_index(value)	(*(Video.SetVideolast_GC_index))(value)
#define	setVideodither(value)	(*(Video.SetVideodither))(value)
#define	setVideowrmode(value)	(*(Video.SetVideowrmode))(value)
#define	setVideochain(value)	(*(Video.SetVideochain))(value)
#define	setVideowrstate(value)	(*(Video.SetVideowrstate))(value)
#define	SetWritePointers()	(*(Video.setWritePointers))()
#define	SetReadPointers(readset)	(*(Video.setReadPointers))(readset)
#define	SetMarkPointers(markset)	(*(Video.setMarkPointers))(markset)

/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\evidfunc.c ===
#include "insignia.h"
#include "host_def.h"
#include "ga_mark.h"
#include "cpu_vid.h"
#include "evidfunc.h"


EVID_WRT_POINTERS simple_evid = 
	{
	S_2139_SimpleByteWrite,
	S_2142_SimpleWordWrite,
	S_2145_SimpleDwordWrite,
	S_2140_SimpleByteFill,
	S_2143_SimpleWordFill,
	S_2146_SimpleDwordFill,
	S_2141_SimpleByteMove_Fwd,
	S_2148_SimpleByteMove_Bwd,
	S_2144_SimpleWordMove_Fwd,
	S_2149_SimpleWordMove_Bwd,
	S_2147_SimpleDwordMove_Fwd,
	S_2150_SimpleDwordMove_Bwd
	};

EVID_WRT_POINTERS gricvid_evid = 
	{
	S_2238_GenericByteWrite,
	S_2241_GenericWordWrite,
	S_2244_GenericDwordWrite,
	S_2239_GenericByteFill,
	S_2242_GenericWordFill,
	S_2245_GenericDwordFill,
	S_2240_GenericByteMove_Fwd,
	S_2247_GenericByteMove_Bwd,
	S_2243_GenericWordMove_Fwd,
	S_2248_GenericWordMove_Bwd,
	S_2246_GenericDwordMove_Fwd,
	S_2249_GenericDwordMove_Bwd
	};

EVID_WRT_POINTERS dith_evid[] = {
	{
	S_2151_UnchainedByteWrite_00000000_0000000e_00000001,
	S_2157_UnchainedWordWrite_00000000_0000000e_00000001,
	S_2163_UnchainedDwordWrite_00000000_0000000e_00000001,
	S_2152_UnchainedByteFill_00000000_0000000e_00000001,
	S_2158_UnchainedWordFill_00000000_0000000e_00000001,
	S_2164_UnchainedDwordFill_00000000_0000000e_00000001,
	S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000,
	S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001,
	S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000,
	S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001,
	S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000,
	S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001
	},
	{
	S_2166_UnchainedByteWrite_00000001_0000000e_00000001,
	S_2171_UnchainedWordWrite_00000001_0000000e_00000001,
	S_2176_UnchainedDwordWrite_00000001_0000000e_00000001,
	S_2167_UnchainedByteFill_00000001_0000000e_00000001,
	S_2172_UnchainedWordFill_00000001_0000000e_00000001,
	S_2177_UnchainedDwordFill_00000001_0000000e_00000001,
	S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000,
	S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001,
	S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000,
	S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001,
	S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000,
	S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001
	},
	{
	S_2179_UnchainedByteWrite_00000002_0000000e_00000001,
	S_2184_UnchainedWordWrite_00000002_0000000e_00000001,
	S_2189_UnchainedDwordWrite_00000002_0000000e_00000001,
	S_2180_UnchainedByteFill_00000002_0000000e_00000001,
	S_2185_UnchainedWordFill_00000002_0000000e_00000001,
	S_2190_UnchainedDwordFill_00000002_0000000e_00000001,
	S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000,
	S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001,
	S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000,
	S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001,
	S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000,
	S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001
	},
	{
	S_2192_UnchainedByteWrite_00000003_0000000e_00000001,
	S_2197_UnchainedWordWrite_00000003_0000000e_00000001,
	S_2202_UnchainedDwordWrite_00000003_0000000e_00000001,
	S_2193_UnchainedByteFill_00000003_0000000e_00000001,
	S_2198_UnchainedWordFill_00000003_0000000e_00000001,
	S_2203_UnchainedDwordFill_00000003_0000000e_00000001,
	S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000,
	S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001,
	S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000,
	S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001,
	S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000,
	S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001
	}
};

EVID_WRT_POINTERS chain2_evid[] = {
	{
	S_2624_Chain2ByteWrite_00000000,
	S_2630_Chain2WordWrite_00000000,
	S_2636_Chain2DwordWrite_00000000,
	S_2626_Chain2ByteFill_00000000,
	S_2632_Chain2WordFill_00000000,
	S_2638_Chain2DwordFill_00000000,
	S_2628_Chain2ByteMove_00000000_Fwd,
	S_2705_Chain2ByteMove_00000000_Bwd,
	S_2634_Chain2WordMove_00000000_Fwd,
	S_2707_Chain2WordMove_00000000_Bwd,
	S_2640_Chain2DwordMove_00000000_Fwd,
	S_2709_Chain2DwordMove_00000000_Bwd
	},
	{
	S_2642_Chain2ByteWrite_00000001,
	S_2648_Chain2WordWrite_00000001,
	S_2654_Chain2DwordWrite_00000001,
	S_2644_Chain2ByteFill_00000001,
	S_2650_Chain2WordFill_00000001,
	S_2656_Chain2DwordFill_00000001,
	S_2646_Chain2ByteMove_00000001_Fwd,
	S_2711_Chain2ByteMove_00000001_Bwd,
	S_2652_Chain2WordMove_00000001_Fwd,
	S_2713_Chain2WordMove_00000001_Bwd,
	S_2658_Chain2DwordMove_00000001_Fwd,
	S_2715_Chain2DwordMove_00000001_Bwd
	},
	{
	S_2660_Chain2ByteWrite_00000002,
	S_2666_Chain2WordWrite_00000002,
	S_2672_Chain2DwordWrite_00000002,
	S_2662_Chain2ByteFill_00000002,
	S_2668_Chain2WordFill_00000002,
	S_2674_Chain2DwordFill_00000002,
	S_2664_Chain2ByteMove_00000002_Fwd,
	S_2717_Chain2ByteMove_00000002_Bwd,
	S_2670_Chain2WordMove_00000002_Fwd,
	S_2719_Chain2WordMove_00000002_Bwd,
	S_2676_Chain2DwordMove_00000002_Fwd,
	S_2721_Chain2DwordMove_00000002_Bwd
	},
	{
	S_2678_Chain2ByteWrite_00000003,
	S_2684_Chain2WordWrite_00000003,
	S_2690_Chain2DwordWrite_00000003,
	S_2680_Chain2ByteFill_00000003,
	S_2686_Chain2WordFill_00000003,
	S_2692_Chain2DwordFill_00000003,
	S_2682_Chain2ByteMove_00000003_Fwd,
	S_2723_Chain2ByteMove_00000003_Bwd,
	S_2688_Chain2WordMove_00000003_Fwd,
	S_2725_Chain2WordMove_00000003_Bwd,
	S_2694_Chain2DwordMove_00000003_Fwd,
	S_2727_Chain2DwordMove_00000003_Bwd
	},
	{
	S_2696_Chain2ByteWrite_Copy,
	S_2699_Chain2WordWrite_Copy,
	S_2702_Chain2DwordWrite_Copy,
	S_2697_Chain2ByteFill_Copy,
	S_2700_Chain2WordFill_Copy,
	S_2703_Chain2DwordFill_Copy,
	S_2698_Chain2ByteMove_Copy_Fwd,
	S_2729_Chain2ByteMove_Copy_Bwd,
	S_2701_Chain2WordMove_Copy_Fwd,
	S_2730_Chain2WordMove_Copy_Bwd,
	S_2704_Chain2DwordMove_Copy_Fwd,
	S_2731_Chain2DwordMove_Copy_Bwd
	}
};

EVID_WRT_POINTERS unchained_evid[] = {
	{
	S_2250_UnchainedByteWrite_00000000_00000008_00000000,
	S_2305_UnchainedWordWrite_00000000_00000008_00000000,
	S_2360_UnchainedDwordWrite_00000000_00000008_00000000,
	S_2262_UnchainedByteFill_00000000_00000008_00000000,
	S_2317_UnchainedWordFill_00000000_00000008_00000000,
	S_2372_UnchainedDwordFill_00000000_00000008_00000000,
	S_2275_UnchainedByteMove_00000000_00000008_00000000_00000000,
	S_2501_UnchainedByteMove_00000000_00000008_00000000_00000001,
	S_2330_UnchainedWordMove_00000000_00000008_00000000_00000000,
	S_2531_UnchainedWordMove_00000000_00000008_00000000_00000001,
	S_2384_UnchainedDwordMove_00000000_00000008_00000000_00000000,
	S_2561_UnchainedDwordMove_00000000_00000008_00000000_00000001
	},
	{
	S_2251_UnchainedByteWrite_00000000_00000009_00000000,
	S_2306_UnchainedWordWrite_00000000_00000009_00000000,
	S_2361_UnchainedDwordWrite_00000000_00000009_00000000,
	S_2263_UnchainedByteFill_00000000_00000009_00000000,
	S_2318_UnchainedWordFill_00000000_00000009_00000000,
	S_2373_UnchainedDwordFill_00000000_00000009_00000000,
	S_2278_UnchainedByteMove_00000000_00000009_00000000_00000000,
	S_2504_UnchainedByteMove_00000000_00000009_00000000_00000001,
	S_2333_UnchainedWordMove_00000000_00000009_00000000_00000000,
	S_2534_UnchainedWordMove_00000000_00000009_00000000_00000001,
	S_2385_UnchainedDwordMove_00000000_00000009_00000000_00000000,
	S_2562_UnchainedDwordMove_00000000_00000009_00000000_00000001
	},
	{
	S_2252_UnchainedByteWrite_00000000_0000000e_00000000,
	S_2307_UnchainedWordWrite_00000000_0000000e_00000000,
	S_2362_UnchainedDwordWrite_00000000_0000000e_00000000,
	S_2265_UnchainedByteFill_00000000_0000000e_00000000,
	S_2320_UnchainedWordFill_00000000_0000000e_00000000,
	S_2374_UnchainedDwordFill_00000000_0000000e_00000000,
	S_2280_UnchainedByteMove_00000000_0000000e_00000000_00000000,
	S_2506_UnchainedByteMove_00000000_0000000e_00000000_00000001,
	S_2335_UnchainedWordMove_00000000_0000000e_00000000_00000000,
	S_2536_UnchainedWordMove_00000000_0000000e_00000000_00000001,
	S_2386_UnchainedDwordMove_00000000_0000000e_00000000_00000000,
	S_2563_UnchainedDwordMove_00000000_0000000e_00000000_00000001
	},
	{
	S_2253_UnchainedByteWrite_00000000_0000000f_00000000,
	S_2308_UnchainedWordWrite_00000000_0000000f_00000000,
	S_2363_UnchainedDwordWrite_00000000_0000000f_00000000,
	S_2266_UnchainedByteFill_00000000_0000000f_00000000,
	S_2321_UnchainedWordFill_00000000_0000000f_00000000,
	S_2375_UnchainedDwordFill_00000000_0000000f_00000000,
	S_2283_UnchainedByteMove_00000000_0000000f_00000000_00000000,
	S_2509_UnchainedByteMove_00000000_0000000f_00000000_00000001,
	S_2338_UnchainedWordMove_00000000_0000000f_00000000_00000000,
	S_2539_UnchainedWordMove_00000000_0000000f_00000000_00000001,
	S_2387_UnchainedDwordMove_00000000_0000000f_00000000_00000000,
	S_2564_UnchainedDwordMove_00000000_0000000f_00000000_00000001
	},
	{
	S_2254_UnchainedByteWrite_00000000_00000010_00000000,
	S_2309_UnchainedWordWrite_00000000_00000010_00000000,
	S_2364_UnchainedDwordWrite_00000000_00000010_00000000,
	S_2267_UnchainedByteFill_00000000_00000010_00000000,
	S_2322_UnchainedWordFill_00000000_00000010_00000000,
	S_2376_UnchainedDwordFill_00000000_00000010_00000000,
	S_2285_UnchainedByteMove_00000000_00000010_00000000_00000000,
	S_2511_UnchainedByteMove_00000000_00000010_00000000_00000001,
	S_2340_UnchainedWordMove_00000000_00000010_00000000_00000000,
	S_2541_UnchainedWordMove_00000000_00000010_00000000_00000001,
	S_2388_UnchainedDwordMove_00000000_00000010_00000000_00000000,
	S_2565_UnchainedDwordMove_00000000_00000010_00000000_00000001
	},
	{
	S_2255_UnchainedByteWrite_00000000_00000011_00000000,
	S_2310_UnchainedWordWrite_00000000_00000011_00000000,
	S_2365_UnchainedDwordWrite_00000000_00000011_00000000,
	S_2268_UnchainedByteFill_00000000_00000011_00000000,
	S_2323_UnchainedWordFill_00000000_00000011_00000000,
	S_2377_UnchainedDwordFill_00000000_00000011_00000000,
	S_2288_UnchainedByteMove_00000000_00000011_00000000_00000000,
	S_2514_UnchainedByteMove_00000000_00000011_00000000_00000001,
	S_2343_UnchainedWordMove_00000000_00000011_00000000_00000000,
	S_2544_UnchainedWordMove_00000000_00000011_00000000_00000001,
	S_2389_UnchainedDwordMove_00000000_00000011_00000000_00000000,
	S_2566_UnchainedDwordMove_00000000_00000011_00000000_00000001
	},
	{
	S_2256_UnchainedByteWrite_00000000_00000016_00000000,
	S_2311_UnchainedWordWrite_00000000_00000016_00000000,
	S_2366_UnchainedDwordWrite_00000000_00000016_00000000,
	S_2269_UnchainedByteFill_00000000_00000016_00000000,
	S_2324_UnchainedWordFill_00000000_00000016_00000000,
	S_2378_UnchainedDwordFill_00000000_00000016_00000000,
	S_2290_UnchainedByteMove_00000000_00000016_00000000_00000000,
	S_2516_UnchainedByteMove_00000000_00000016_00000000_00000001,
	S_2345_UnchainedWordMove_00000000_00000016_00000000_00000000,
	S_2546_UnchainedWordMove_00000000_00000016_00000000_00000001,
	S_2390_UnchainedDwordMove_00000000_00000016_00000000_00000000,
	S_2567_UnchainedDwordMove_00000000_00000016_00000000_00000001
	},
	{
	S_2257_UnchainedByteWrite_00000000_00000017_00000000,
	S_2312_UnchainedWordWrite_00000000_00000017_00000000,
	S_2367_UnchainedDwordWrite_00000000_00000017_00000000,
	S_2270_UnchainedByteFill_00000000_00000017_00000000,
	S_2325_UnchainedWordFill_00000000_00000017_00000000,
	S_2379_UnchainedDwordFill_00000000_00000017_00000000,
	S_2293_UnchainedByteMove_00000000_00000017_00000000_00000000,
	S_2519_UnchainedByteMove_00000000_00000017_00000000_00000001,
	S_2348_UnchainedWordMove_00000000_00000017_00000000_00000000,
	S_2549_UnchainedWordMove_00000000_00000017_00000000_00000001,
	S_2391_UnchainedDwordMove_00000000_00000017_00000000_00000000,
	S_2568_UnchainedDwordMove_00000000_00000017_00000000_00000001
	},
	{
	S_2258_UnchainedByteWrite_00000000_00000018_00000000,
	S_2313_UnchainedWordWrite_00000000_00000018_00000000,
	S_2368_UnchainedDwordWrite_00000000_00000018_00000000,
	S_2271_UnchainedByteFill_00000000_00000018_00000000,
	S_2326_UnchainedWordFill_00000000_00000018_00000000,
	S_2380_UnchainedDwordFill_00000000_00000018_00000000,
	S_2295_UnchainedByteMove_00000000_00000018_00000000_00000000,
	S_2521_UnchainedByteMove_00000000_00000018_00000000_00000001,
	S_2350_UnchainedWordMove_00000000_00000018_00000000_00000000,
	S_2551_UnchainedWordMove_00000000_00000018_00000000_00000001,
	S_2392_UnchainedDwordMove_00000000_00000018_00000000_00000000,
	S_2569_UnchainedDwordMove_00000000_00000018_00000000_00000001
	},
	{
	S_2259_UnchainedByteWrite_00000000_00000019_00000000,
	S_2314_UnchainedWordWrite_00000000_00000019_00000000,
	S_2369_UnchainedDwordWrite_00000000_00000019_00000000,
	S_2272_UnchainedByteFill_00000000_00000019_00000000,
	S_2327_UnchainedWordFill_00000000_00000019_00000000,
	S_2381_UnchainedDwordFill_00000000_00000019_00000000,
	S_2298_UnchainedByteMove_00000000_00000019_00000000_00000000,
	S_2524_UnchainedByteMove_00000000_00000019_00000000_00000001,
	S_2353_UnchainedWordMove_00000000_00000019_00000000_00000000,
	S_2554_UnchainedWordMove_00000000_00000019_00000000_00000001,
	S_2393_UnchainedDwordMove_00000000_00000019_00000000_00000000,
	S_2570_UnchainedDwordMove_00000000_00000019_00000000_00000001
	},
	{
	S_2260_UnchainedByteWrite_00000000_0000001e_00000000,
	S_2315_UnchainedWordWrite_00000000_0000001e_00000000,
	S_2370_UnchainedDwordWrite_00000000_0000001e_00000000,
	S_2273_UnchainedByteFill_00000000_0000001e_00000000,
	S_2328_UnchainedWordFill_00000000_0000001e_00000000,
	S_2382_UnchainedDwordFill_00000000_0000001e_00000000,
	S_2300_UnchainedByteMove_00000000_0000001e_00000000_00000000,
	S_2526_UnchainedByteMove_00000000_0000001e_00000000_00000001,
	S_2355_UnchainedWordMove_00000000_0000001e_00000000_00000000,
	S_2556_UnchainedWordMove_00000000_0000001e_00000000_00000001,
	S_2394_UnchainedDwordMove_00000000_0000001e_00000000_00000000,
	S_2571_UnchainedDwordMove_00000000_0000001e_00000000_00000001
	},
	{
	S_2261_UnchainedByteWrite_00000000_0000001f_00000000,
	S_2316_UnchainedWordWrite_00000000_0000001f_00000000,
	S_2371_UnchainedDwordWrite_00000000_0000001f_00000000,
	S_2274_UnchainedByteFill_00000000_0000001f_00000000,
	S_2329_UnchainedWordFill_00000000_0000001f_00000000,
	S_2383_UnchainedDwordFill_00000000_0000001f_00000000,
	S_2303_UnchainedByteMove_00000000_0000001f_00000000_00000000,
	S_2529_UnchainedByteMove_00000000_0000001f_00000000_00000001,
	S_2358_UnchainedWordMove_00000000_0000001f_00000000_00000000,
	S_2559_UnchainedWordMove_00000000_0000001f_00000000_00000001,
	S_2395_UnchainedDwordMove_00000000_0000001f_00000000_00000000,
	S_2572_UnchainedDwordMove_00000000_0000001f_00000000_00000001
	},
	{
	S_2396_UnchainedByteWrite_00000001_00000000_00000000,
	S_2399_UnchainedWordWrite_00000001_00000000_00000000,
	S_2402_UnchainedDwordWrite_00000001_00000000_00000000,
	S_2397_UnchainedByteFill_00000001_00000000_00000000,
	S_2400_UnchainedWordFill_00000001_00000000_00000000,
	S_2403_UnchainedDwordFill_00000001_00000000_00000000,
	S_2398_UnchainedByteMove_00000001_00000000_00000000_00000000,
	S_2573_UnchainedByteMove_00000001_00000000_00000000_00000001,
	S_2401_UnchainedWordMove_00000001_00000000_00000000_00000000,
	S_2574_UnchainedWordMove_00000001_00000000_00000000_00000001,
	S_2404_UnchainedDwordMove_00000001_00000000_00000000_00000000,
	S_2575_UnchainedDwordMove_00000001_00000000_00000000_00000001
	},
	{
	S_2405_UnchainedByteWrite_00000002_00000008_00000000,
	S_2423_UnchainedWordWrite_00000002_00000008_00000000,
	S_2441_UnchainedDwordWrite_00000002_00000008_00000000,
	S_2409_UnchainedByteFill_00000002_00000008_00000000,
	S_2427_UnchainedWordFill_00000002_00000008_00000000,
	S_2445_UnchainedDwordFill_00000002_00000008_00000000,
	S_2413_UnchainedByteMove_00000002_00000008_00000000_00000000,
	S_2576_UnchainedByteMove_00000002_00000008_00000000_00000001,
	S_2431_UnchainedWordMove_00000002_00000008_00000000_00000000,
	S_2586_UnchainedWordMove_00000002_00000008_00000000_00000001,
	S_2449_UnchainedDwordMove_00000002_00000008_00000000_00000000,
	S_2596_UnchainedDwordMove_00000002_00000008_00000000_00000001
	},
	{
	S_2406_UnchainedByteWrite_00000002_00000009_00000000,
	S_2424_UnchainedWordWrite_00000002_00000009_00000000,
	S_2442_UnchainedDwordWrite_00000002_00000009_00000000,
	S_2410_UnchainedByteFill_00000002_00000009_00000000,
	S_2428_UnchainedWordFill_00000002_00000009_00000000,
	S_2446_UnchainedDwordFill_00000002_00000009_00000000,
	S_2416_UnchainedByteMove_00000002_00000009_00000000_00000000,
	S_2579_UnchainedByteMove_00000002_00000009_00000000_00000001,
	S_2434_UnchainedWordMove_00000002_00000009_00000000_00000000,
	S_2589_UnchainedWordMove_00000002_00000009_00000000_00000001,
	S_2450_UnchainedDwordMove_00000002_00000009_00000000_00000000,
	S_2597_UnchainedDwordMove_00000002_00000009_00000000_00000001
	},
	{
	S_2407_UnchainedByteWrite_00000002_0000000e_00000000,
	S_2425_UnchainedWordWrite_00000002_0000000e_00000000,
	S_2443_UnchainedDwordWrite_00000002_0000000e_00000000,
	S_2411_UnchainedByteFill_00000002_0000000e_00000000,
	S_2429_UnchainedWordFill_00000002_0000000e_00000000,
	S_2447_UnchainedDwordFill_00000002_0000000e_00000000,
	S_2418_UnchainedByteMove_00000002_0000000e_00000000_00000000,
	S_2581_UnchainedByteMove_00000002_0000000e_00000000_00000001,
	S_2436_UnchainedWordMove_00000002_0000000e_00000000_00000000,
	S_2591_UnchainedWordMove_00000002_0000000e_00000000_00000001,
	S_2451_UnchainedDwordMove_00000002_0000000e_00000000_00000000,
	S_2598_UnchainedDwordMove_00000002_0000000e_00000000_00000001
	},
	{
	S_2408_UnchainedByteWrite_00000002_0000000f_00000000,
	S_2426_UnchainedWordWrite_00000002_0000000f_00000000,
	S_2444_UnchainedDwordWrite_00000002_0000000f_00000000,
	S_2412_UnchainedByteFill_00000002_0000000f_00000000,
	S_2430_UnchainedWordFill_00000002_0000000f_00000000,
	S_2448_UnchainedDwordFill_00000002_0000000f_00000000,
	S_2421_UnchainedByteMove_00000002_0000000f_00000000_00000000,
	S_2584_UnchainedByteMove_00000002_0000000f_00000000_00000001,
	S_2439_UnchainedWordMove_00000002_0000000f_00000000_00000000,
	S_2594_UnchainedWordMove_00000002_0000000f_00000000_00000001,
	S_2452_UnchainedDwordMove_00000002_0000000f_00000000_00000000,
	S_2599_UnchainedDwordMove_00000002_0000000f_00000000_00000001
	},
	{
	S_2453_UnchainedByteWrite_00000003_00000008_00000000,
	S_2471_UnchainedWordWrite_00000003_00000008_00000000,
	S_2489_UnchainedDwordWrite_00000003_00000008_00000000,
	S_2457_UnchainedByteFill_00000003_00000008_00000000,
	S_2475_UnchainedWordFill_00000003_00000008_00000000,
	S_2493_UnchainedDwordFill_00000003_00000008_00000000,
	S_2461_UnchainedByteMove_00000003_00000008_00000000_00000000,
	S_2600_UnchainedByteMove_00000003_00000008_00000000_00000001,
	S_2479_UnchainedWordMove_00000003_00000008_00000000_00000000,
	S_2610_UnchainedWordMove_00000003_00000008_00000000_00000001,
	S_2497_UnchainedDwordMove_00000003_00000008_00000000_00000000,
	S_2620_UnchainedDwordMove_00000003_00000008_00000000_00000001
	},
	{
	S_2454_UnchainedByteWrite_00000003_00000009_00000000,
	S_2472_UnchainedWordWrite_00000003_00000009_00000000,
	S_2490_UnchainedDwordWrite_00000003_00000009_00000000,
	S_2458_UnchainedByteFill_00000003_00000009_00000000,
	S_2476_UnchainedWordFill_00000003_00000009_00000000,
	S_2494_UnchainedDwordFill_00000003_00000009_00000000,
	S_2464_UnchainedByteMove_00000003_00000009_00000000_00000000,
	S_2603_UnchainedByteMove_00000003_00000009_00000000_00000001,
	S_2482_UnchainedWordMove_00000003_00000009_00000000_00000000,
	S_2613_UnchainedWordMove_00000003_00000009_00000000_00000001,
	S_2498_UnchainedDwordMove_00000003_00000009_00000000_00000000,
	S_2621_UnchainedDwordMove_00000003_00000009_00000000_00000001
	},
	{
	S_2455_UnchainedByteWrite_00000003_0000000e_00000000,
	S_2473_UnchainedWordWrite_00000003_0000000e_00000000,
	S_2491_UnchainedDwordWrite_00000003_0000000e_00000000,
	S_2459_UnchainedByteFill_00000003_0000000e_00000000,
	S_2477_UnchainedWordFill_00000003_0000000e_00000000,
	S_2495_UnchainedDwordFill_00000003_0000000e_00000000,
	S_2466_UnchainedByteMove_00000003_0000000e_00000000_00000000,
	S_2605_UnchainedByteMove_00000003_0000000e_00000000_00000001,
	S_2484_UnchainedWordMove_00000003_0000000e_00000000_00000000,
	S_2615_UnchainedWordMove_00000003_0000000e_00000000_00000001,
	S_2499_UnchainedDwordMove_00000003_0000000e_00000000_00000000,
	S_2622_UnchainedDwordMove_00000003_0000000e_00000000_00000001
	},
	{
	S_2456_UnchainedByteWrite_00000003_0000000f_00000000,
	S_2474_UnchainedWordWrite_00000003_0000000f_00000000,
	S_2492_UnchainedDwordWrite_00000003_0000000f_00000000,
	S_2460_UnchainedByteFill_00000003_0000000f_00000000,
	S_2478_UnchainedWordFill_00000003_0000000f_00000000,
	S_2496_UnchainedDwordFill_00000003_0000000f_00000000,
	S_2469_UnchainedByteMove_00000003_0000000f_00000000_00000000,
	S_2608_UnchainedByteMove_00000003_0000000f_00000000_00000001,
	S_2487_UnchainedWordMove_00000003_0000000f_00000000_00000000,
	S_2618_UnchainedWordMove_00000003_0000000f_00000000_00000001,
	S_2500_UnchainedDwordMove_00000003_0000000f_00000000_00000000,
	S_2623_UnchainedDwordMove_00000003_0000000f_00000000_00000001
	}
};

EVID_WRT_POINTERS chain4_evid[] = {
	{
	S_2732_Chain4ByteWrite_00000000_00000008,
	S_2782_Chain4WordWrite_00000000_00000008,
	S_2831_Chain4DwordWrite_00000000_00000008,
	S_2744_Chain4ByteFill_00000000_00000008,
	S_2794_Chain4WordFill_00000000_00000008,
	S_2843_Chain4DwordFill_00000000_00000008,
	S_2758_Chain4ByteMove_00000000_00000008_00000000,
	S_2965_Chain4ByteMove_00000000_00000008_00000001,
	S_2807_Chain4WordMove_00000000_00000008_00000000,
	S_2989_Chain4WordMove_00000000_00000008_00000001,
	S_2855_Chain4DwordMove_00000000_00000008_00000000,
	S_3013_Chain4DwordMove_00000000_00000008_00000001
	},
	{
	S_2733_Chain4ByteWrite_00000000_00000009,
	S_2783_Chain4WordWrite_00000000_00000009,
	S_2832_Chain4DwordWrite_00000000_00000009,
	S_2746_Chain4ByteFill_00000000_00000009,
	S_2795_Chain4WordFill_00000000_00000009,
	S_2844_Chain4DwordFill_00000000_00000009,
	S_2760_Chain4ByteMove_00000000_00000009_00000000,
	S_2967_Chain4ByteMove_00000000_00000009_00000001,
	S_2809_Chain4WordMove_00000000_00000009_00000000,
	S_2991_Chain4WordMove_00000000_00000009_00000001,
	S_2856_Chain4DwordMove_00000000_00000009_00000000,
	S_3014_Chain4DwordMove_00000000_00000009_00000001
	},
	{
	S_2734_Chain4ByteWrite_00000000_0000000e,
	S_2784_Chain4WordWrite_00000000_0000000e,
	S_2833_Chain4DwordWrite_00000000_0000000e,
	S_2748_Chain4ByteFill_00000000_0000000e,
	S_2797_Chain4WordFill_00000000_0000000e,
	S_2845_Chain4DwordFill_00000000_0000000e,
	S_2762_Chain4ByteMove_00000000_0000000e_00000000,
	S_2969_Chain4ByteMove_00000000_0000000e_00000001,
	S_2811_Chain4WordMove_00000000_0000000e_00000000,
	S_2993_Chain4WordMove_00000000_0000000e_00000001,
	S_2857_Chain4DwordMove_00000000_0000000e_00000000,
	S_3015_Chain4DwordMove_00000000_0000000e_00000001
	},
	{
	S_2735_Chain4ByteWrite_00000000_0000000f,
	S_2785_Chain4WordWrite_00000000_0000000f,
	S_2834_Chain4DwordWrite_00000000_0000000f,
	S_2749_Chain4ByteFill_00000000_0000000f,
	S_2798_Chain4WordFill_00000000_0000000f,
	S_2846_Chain4DwordFill_00000000_0000000f,
	S_2764_Chain4ByteMove_00000000_0000000f_00000000,
	S_2971_Chain4ByteMove_00000000_0000000f_00000001,
	S_2813_Chain4WordMove_00000000_0000000f_00000000,
	S_2995_Chain4WordMove_00000000_0000000f_00000001,
	S_2858_Chain4DwordMove_00000000_0000000f_00000000,
	S_3016_Chain4DwordMove_00000000_0000000f_00000001
	},
	{
	S_2736_Chain4ByteWrite_00000000_00000010,
	S_2786_Chain4WordWrite_00000000_00000010,
	S_2835_Chain4DwordWrite_00000000_00000010,
	S_2750_Chain4ByteFill_00000000_00000010,
	S_2799_Chain4WordFill_00000000_00000010,
	S_2847_Chain4DwordFill_00000000_00000010,
	S_2766_Chain4ByteMove_00000000_00000010_00000000,
	S_2973_Chain4ByteMove_00000000_00000010_00000001,
	S_2815_Chain4WordMove_00000000_00000010_00000000,
	S_2997_Chain4WordMove_00000000_00000010_00000001,
	S_2859_Chain4DwordMove_00000000_00000010_00000000,
	S_3017_Chain4DwordMove_00000000_00000010_00000001
	},
	{
	S_2737_Chain4ByteWrite_00000000_00000011,
	S_2787_Chain4WordWrite_00000000_00000011,
	S_2836_Chain4DwordWrite_00000000_00000011,
	S_2751_Chain4ByteFill_00000000_00000011,
	S_2800_Chain4WordFill_00000000_00000011,
	S_2848_Chain4DwordFill_00000000_00000011,
	S_2768_Chain4ByteMove_00000000_00000011_00000000,
	S_2975_Chain4ByteMove_00000000_00000011_00000001,
	S_2817_Chain4WordMove_00000000_00000011_00000000,
	S_2999_Chain4WordMove_00000000_00000011_00000001,
	S_2860_Chain4DwordMove_00000000_00000011_00000000,
	S_3018_Chain4DwordMove_00000000_00000011_00000001
	},
	{
	S_2738_Chain4ByteWrite_00000000_00000016,
	S_2788_Chain4WordWrite_00000000_00000016,
	S_2837_Chain4DwordWrite_00000000_00000016,
	S_2752_Chain4ByteFill_00000000_00000016,
	S_2801_Chain4WordFill_00000000_00000016,
	S_2849_Chain4DwordFill_00000000_00000016,
	S_2770_Chain4ByteMove_00000000_00000016_00000000,
	S_2977_Chain4ByteMove_00000000_00000016_00000001,
	S_2819_Chain4WordMove_00000000_00000016_00000000,
	S_3001_Chain4WordMove_00000000_00000016_00000001,
	S_2861_Chain4DwordMove_00000000_00000016_00000000,
	S_3019_Chain4DwordMove_00000000_00000016_00000001
	},
	{
	S_2739_Chain4ByteWrite_00000000_00000017,
	S_2789_Chain4WordWrite_00000000_00000017,
	S_2838_Chain4DwordWrite_00000000_00000017,
	S_2753_Chain4ByteFill_00000000_00000017,
	S_2802_Chain4WordFill_00000000_00000017,
	S_2850_Chain4DwordFill_00000000_00000017,
	S_2772_Chain4ByteMove_00000000_00000017_00000000,
	S_2979_Chain4ByteMove_00000000_00000017_00000001,
	S_2821_Chain4WordMove_00000000_00000017_00000000,
	S_3003_Chain4WordMove_00000000_00000017_00000001,
	S_2862_Chain4DwordMove_00000000_00000017_00000000,
	S_3020_Chain4DwordMove_00000000_00000017_00000001
	},
	{
	S_2740_Chain4ByteWrite_00000000_00000018,
	S_2790_Chain4WordWrite_00000000_00000018,
	S_2839_Chain4DwordWrite_00000000_00000018,
	S_2754_Chain4ByteFill_00000000_00000018,
	S_2803_Chain4WordFill_00000000_00000018,
	S_2851_Chain4DwordFill_00000000_00000018,
	S_2774_Chain4ByteMove_00000000_00000018_00000000,
	S_2981_Chain4ByteMove_00000000_00000018_00000001,
	S_2823_Chain4WordMove_00000000_00000018_00000000,
	S_3005_Chain4WordMove_00000000_00000018_00000001,
	S_2863_Chain4DwordMove_00000000_00000018_00000000,
	S_3021_Chain4DwordMove_00000000_00000018_00000001
	},
	{
	S_2741_Chain4ByteWrite_00000000_00000019,
	S_2791_Chain4WordWrite_00000000_00000019,
	S_2840_Chain4DwordWrite_00000000_00000019,
	S_2755_Chain4ByteFill_00000000_00000019,
	S_2804_Chain4WordFill_00000000_00000019,
	S_2852_Chain4DwordFill_00000000_00000019,
	S_2776_Chain4ByteMove_00000000_00000019_00000000,
	S_2983_Chain4ByteMove_00000000_00000019_00000001,
	S_2825_Chain4WordMove_00000000_00000019_00000000,
	S_3007_Chain4WordMove_00000000_00000019_00000001,
	S_2864_Chain4DwordMove_00000000_00000019_00000000,
	S_3022_Chain4DwordMove_00000000_00000019_00000001
	},
	{
	S_2742_Chain4ByteWrite_00000000_0000001e,
	S_2792_Chain4WordWrite_00000000_0000001e,
	S_2841_Chain4DwordWrite_00000000_0000001e,
	S_2756_Chain4ByteFill_00000000_0000001e,
	S_2805_Chain4WordFill_00000000_0000001e,
	S_2853_Chain4DwordFill_00000000_0000001e,
	S_2778_Chain4ByteMove_00000000_0000001e_00000000,
	S_2985_Chain4ByteMove_00000000_0000001e_00000001,
	S_2827_Chain4WordMove_00000000_0000001e_00000000,
	S_3009_Chain4WordMove_00000000_0000001e_00000001,
	S_2865_Chain4DwordMove_00000000_0000001e_00000000,
	S_3023_Chain4DwordMove_00000000_0000001e_00000001
	},
	{
	S_2743_Chain4ByteWrite_00000000_0000001f,
	S_2793_Chain4WordWrite_00000000_0000001f,
	S_2842_Chain4DwordWrite_00000000_0000001f,
	S_2757_Chain4ByteFill_00000000_0000001f,
	S_2806_Chain4WordFill_00000000_0000001f,
	S_2854_Chain4DwordFill_00000000_0000001f,
	S_2780_Chain4ByteMove_00000000_0000001f_00000000,
	S_2987_Chain4ByteMove_00000000_0000001f_00000001,
	S_2829_Chain4WordMove_00000000_0000001f_00000000,
	S_3011_Chain4WordMove_00000000_0000001f_00000001,
	S_2866_Chain4DwordMove_00000000_0000001f_00000000,
	S_3024_Chain4DwordMove_00000000_0000001f_00000001
	},
	{
	S_2867_Chain4ByteWrite_00000001_00000000,
	S_2871_Chain4WordWrite_00000001_00000000,
	S_2874_Chain4DwordWrite_00000001_00000000,
	S_2868_Chain4ByteFill_00000001_00000000,
	S_2872_Chain4WordFill_00000001_00000000,
	S_2875_Chain4DwordFill_00000001_00000000,
	S_2869_Chain4ByteMove_00000001_00000000_00000000,
	S_3025_Chain4ByteMove_00000001_00000000_00000001,
	S_2873_Chain4WordMove_00000001_00000000_00000000,
	S_3027_Chain4WordMove_00000001_00000000_00000001,
	S_2876_Chain4DwordMove_00000001_00000000_00000000,
	S_3028_Chain4DwordMove_00000001_00000000_00000001
	},
	{
	S_2877_Chain4ByteWrite_00000002_00000008,
	S_2893_Chain4WordWrite_00000002_00000008,
	S_2909_Chain4DwordWrite_00000002_00000008,
	S_2881_Chain4ByteFill_00000002_00000008,
	S_2897_Chain4WordFill_00000002_00000008,
	S_2913_Chain4DwordFill_00000002_00000008,
	S_2885_Chain4ByteMove_00000002_00000008_00000000,
	S_3029_Chain4ByteMove_00000002_00000008_00000001,
	S_2901_Chain4WordMove_00000002_00000008_00000000,
	S_3037_Chain4WordMove_00000002_00000008_00000001,
	S_2917_Chain4DwordMove_00000002_00000008_00000000,
	S_3045_Chain4DwordMove_00000002_00000008_00000001
	},
	{
	S_2878_Chain4ByteWrite_00000002_00000009,
	S_2894_Chain4WordWrite_00000002_00000009,
	S_2910_Chain4DwordWrite_00000002_00000009,
	S_2882_Chain4ByteFill_00000002_00000009,
	S_2898_Chain4WordFill_00000002_00000009,
	S_2914_Chain4DwordFill_00000002_00000009,
	S_2887_Chain4ByteMove_00000002_00000009_00000000,
	S_3031_Chain4ByteMove_00000002_00000009_00000001,
	S_2903_Chain4WordMove_00000002_00000009_00000000,
	S_3039_Chain4WordMove_00000002_00000009_00000001,
	S_2918_Chain4DwordMove_00000002_00000009_00000000,
	S_3046_Chain4DwordMove_00000002_00000009_00000001
	},
	{
	S_2879_Chain4ByteWrite_00000002_0000000e,
	S_2895_Chain4WordWrite_00000002_0000000e,
	S_2911_Chain4DwordWrite_00000002_0000000e,
	S_2883_Chain4ByteFill_00000002_0000000e,
	S_2899_Chain4WordFill_00000002_0000000e,
	S_2915_Chain4DwordFill_00000002_0000000e,
	S_2889_Chain4ByteMove_00000002_0000000e_00000000,
	S_3033_Chain4ByteMove_00000002_0000000e_00000001,
	S_2905_Chain4WordMove_00000002_0000000e_00000000,
	S_3041_Chain4WordMove_00000002_0000000e_00000001,
	S_2919_Chain4DwordMove_00000002_0000000e_00000000,
	S_3047_Chain4DwordMove_00000002_0000000e_00000001
	},
	{
	S_2880_Chain4ByteWrite_00000002_0000000f,
	S_2896_Chain4WordWrite_00000002_0000000f,
	S_2912_Chain4DwordWrite_00000002_0000000f,
	S_2884_Chain4ByteFill_00000002_0000000f,
	S_2900_Chain4WordFill_00000002_0000000f,
	S_2916_Chain4DwordFill_00000002_0000000f,
	S_2891_Chain4ByteMove_00000002_0000000f_00000000,
	S_3035_Chain4ByteMove_00000002_0000000f_00000001,
	S_2907_Chain4WordMove_00000002_0000000f_00000000,
	S_3043_Chain4WordMove_00000002_0000000f_00000001,
	S_2920_Chain4DwordMove_00000002_0000000f_00000000,
	S_3048_Chain4DwordMove_00000002_0000000f_00000001
	},
	{
	S_2921_Chain4ByteWrite_00000003_00000008,
	S_2937_Chain4WordWrite_00000003_00000008,
	S_2953_Chain4DwordWrite_00000003_00000008,
	S_2925_Chain4ByteFill_00000003_00000008,
	S_2941_Chain4WordFill_00000003_00000008,
	S_2957_Chain4DwordFill_00000003_00000008,
	S_2929_Chain4ByteMove_00000003_00000008_00000000,
	S_3049_Chain4ByteMove_00000003_00000008_00000001,
	S_2945_Chain4WordMove_00000003_00000008_00000000,
	S_3057_Chain4WordMove_00000003_00000008_00000001,
	S_2961_Chain4DwordMove_00000003_00000008_00000000,
	S_3065_Chain4DwordMove_00000003_00000008_00000001
	},
	{
	S_2922_Chain4ByteWrite_00000003_00000009,
	S_2938_Chain4WordWrite_00000003_00000009,
	S_2954_Chain4DwordWrite_00000003_00000009,
	S_2926_Chain4ByteFill_00000003_00000009,
	S_2942_Chain4WordFill_00000003_00000009,
	S_2958_Chain4DwordFill_00000003_00000009,
	S_2931_Chain4ByteMove_00000003_00000009_00000000,
	S_3051_Chain4ByteMove_00000003_00000009_00000001,
	S_2947_Chain4WordMove_00000003_00000009_00000000,
	S_3059_Chain4WordMove_00000003_00000009_00000001,
	S_2962_Chain4DwordMove_00000003_00000009_00000000,
	S_3066_Chain4DwordMove_00000003_00000009_00000001
	},
	{
	S_2923_Chain4ByteWrite_00000003_0000000e,
	S_2939_Chain4WordWrite_00000003_0000000e,
	S_2955_Chain4DwordWrite_00000003_0000000e,
	S_2927_Chain4ByteFill_00000003_0000000e,
	S_2943_Chain4WordFill_00000003_0000000e,
	S_2959_Chain4DwordFill_00000003_0000000e,
	S_2933_Chain4ByteMove_00000003_0000000e_00000000,
	S_3053_Chain4ByteMove_00000003_0000000e_00000001,
	S_2949_Chain4WordMove_00000003_0000000e_00000000,
	S_3061_Chain4WordMove_00000003_0000000e_00000001,
	S_2963_Chain4DwordMove_00000003_0000000e_00000000,
	S_3067_Chain4DwordMove_00000003_0000000e_00000001
	},
	{
	S_2924_Chain4ByteWrite_00000003_0000000f,
	S_2940_Chain4WordWrite_00000003_0000000f,
	S_2956_Chain4DwordWrite_00000003_0000000f,
	S_2928_Chain4ByteFill_00000003_0000000f,
	S_2944_Chain4WordFill_00000003_0000000f,
	S_2960_Chain4DwordFill_00000003_0000000f,
	S_2935_Chain4ByteMove_00000003_0000000f_00000000,
	S_3055_Chain4ByteMove_00000003_0000000f_00000001,
	S_2951_Chain4WordMove_00000003_0000000f_00000000,
	S_3063_Chain4WordMove_00000003_0000000f_00000001,
	S_2964_Chain4DwordMove_00000003_0000000f_00000000,
	S_3068_Chain4DwordMove_00000003_0000000f_00000001
	}
};


EVID_READ_POINTERS simple_read_evid = 
	{
	S_2115_SimpleByteRead,
	S_2116_SimpleWordRead,
	S_2117_SimpleDwordRead,
	S_2118_SimpleStringRead,
	S_2118_SimpleStringRead
	};

EVID_READ_POINTERS ram_dsbld_read_evid = 
	{
	S_2111_DisabledRAMByteRead,
	S_2112_DisabledRAMWordRead,
	S_2113_DisabledRAMDwordRead,
	S_2114_DisabledRAMStringReadFwd,
	S_2125_DisabledRAMStringReadBwd
	};

EVID_READ_POINTERS read_mode0_evid[] = {
	{
	S_2095_RdMode0UnchainedByteRead,
	S_2096_RdMode0UnchainedWordRead,
	S_2097_RdMode0UnchainedDwordRead,
	S_2098_RdMode0UnchainedStringReadFwd,
	S_2121_RdMode0UnchainedStringReadBwd
	},
	{
	S_2087_RdMode0Chain2ByteRead,
	S_2088_RdMode0Chain2WordRead,
	S_2089_RdMode0Chain2DwordRead,
	S_2090_RdMode0Chain2StringReadFwd,
	S_2119_RdMode0Chain2StringReadBwd
	},
	{
	S_2091_RdMode0Chain4ByteRead,
	S_2092_RdMode0Chain4WordRead,
	S_2093_RdMode0Chain4DwordRead,
	S_2094_RdMode0Chain4StringReadFwd,
	S_2120_RdMode0Chain4StringReadBwd
	}
};

EVID_READ_POINTERS read_mode1_evid[] = {
	{
	S_2107_RdMode1UnchainedByteRead,
	S_2108_RdMode1UnchainedWordRead,
	S_2109_RdMode1UnchainedDwordRead,
	S_2110_RdMode1UnchainedStringReadFwd,
	S_2124_RdMode1UnchainedStringReadBwd
	},
	{
	S_2099_RdMode1Chain2ByteRead,
	S_2100_RdMode1Chain2WordRead,
	S_2101_RdMode1Chain2DwordRead,
	S_2102_RdMode1Chain2StringReadFwd,
	S_2122_RdMode1Chain2StringReadBwd
	},
	{
	S_2103_RdMode1Chain4ByteRead,
	S_2104_RdMode1Chain4WordRead,
	S_2105_RdMode1Chain4DwordRead,
	S_2106_RdMode1Chain4StringReadFwd,
	S_2123_RdMode1Chain4StringReadBwd
	}
};

EVID_MARK_POINTERS simple_mark_evid = 
	{
	S_2126_SimpleMark,
	S_2126_SimpleMark,
	S_2126_SimpleMark,
	S_2126_SimpleMark
	};

EVID_MARK_POINTERS cga_mark_evid = 
	{
	S_2127_CGAMarkByte,
	S_2128_CGAMarkWord,
	S_2129_CGAMarkDword,
	S_2130_CGAMarkString
	};

EVID_MARK_POINTERS unchained_mark_evid = 
	{
	S_2131_UnchainedMarkByte,
	S_2132_UnchainedMarkWord,
	S_2133_UnchainedMarkDword,
	S_2134_UnchainedMarkString
	};

EVID_MARK_POINTERS chain4_mark_evid = 
	{
	S_2135_Chain4MarkByte,
	S_2136_Chain4MarkWord,
	S_2137_Chain4MarkDword,
	S_2138_Chain4MarkString
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\ev_glue.c ===
/*[
*************************************************************************

	Name:		ev_glue.c
	Author:		Simon Frost
	Created:	Janury 1994
	Derived from:	Original
	Sccs ID:	@(#)ev_glue.c	1.15 08/23/94
	Purpose:	Provides glue routines for C-E-vid functions
			and the Jcode calling conventions.

	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.

*************************************************************************
]*/

#include "insignia.h"
#include "host_def.h"

#ifdef CCPU
#include "gmi.h"
#endif

#include "cpu_vid.h"
#include "video.h"
#include "egacpu.h"	/* for Vglob fn defns */
#include "ga_mark.h"	/* for mark fn pointers struct defn */
#include "evidfunc.h"	/* generated by build process */
#include "gdpvar.h"	/* generated by build process */

#undef FORWARDS		/* all these redefined in EDL code */
#undef BACKWARDS
#undef UNCHAINED
#include "Evid_c.h"	/* generated from Evid.edl */
#include "j_c_lang.h"   /* jcode to ccode register definition header */

EVID_WRT_POINTERS c_ev_write_ptr;
EVID_READ_POINTERS c_ev_read_ptr;

/* defines in j_c_lang.h
 *extern IUH jccc_parm1, jccc_parm2, jccc_parm3, jccc_parm4,
 *		jccc_parm5, jccc_gdp;
 */
extern IHP Gdp;

extern IU32 gvi_pc_low_regen;

#ifdef CCPU
IUH ega_gc_outb_mask;

IHP Gdp;
#endif

#ifdef C_VID
IHPE modeLookup;	/* CEvid extern */
IHPE EvidPortFuncs;	/* CEvid extern */
IHPE AdapCOutb;		/* CEvid extern */

IHPE EvidWriteFuncs, EvidReadFuncs, EvidMarkFuncs;	/* CEvid refs */


/* let the c jcode know the addresses so it can lea them */
/* NOTE These things are not accessed the jcode version of the code 
 * has been substituted with a c version 
 * LEAVE in so as not to get unresolved references 
 */
IHPE j_modeLookup	= (IHPE) &modeLookup ;
IHPE j_EvidPortFuncs	= (IHPE) &EvidPortFuncs ;
IHPE j_AdapCOutb	= (IHPE) &AdapCOutb;
IHPE j_EvidWriteFuncs	= (IHPE) &EvidWriteFuncs; 
IHPE j_EvidReadFuncs	= (IHPE) &EvidReadFuncs;
IHPE j_EvidMarkFuncs	= (IHPE) &EvidMarkFuncs;
/* Gdp is referenced */
IHP j_Gdp;	/*	=  Gdp ;  SPECIAL CASE Gdp is the correct address  see below for init */
/*(
=========================== CrulesRuntimeError =======================

PURPOSE: resolve c-rules requirment to have a runtime error routine

INPUT: message string.

OUTPUT: To be Decided .
====================================================================
)*/
GLOBAL void
CrulesRuntimeError IFN1( char * , message ) 
{
	printf("cevid runtime error: %s\r\n", message);
}

/*(
=========================== write_byte_ev_glue =======================

PURPOSE: Set up C evid parameters and call byte write function pointer

INPUT: Write offset & value to write

OUTPUT: None.

====================================================================
)*/
GLOBAL void
write_byte_ev_glue IFN2(IU32, eaOff, IU8, eaVal)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.b_write)(eaOff, eaVal);
}

/*(
=========================== write_word_ev_glue =======================

PURPOSE: Set up C evid parameters and call word write function pointer

INPUT: Write offset & value to write

OUTPUT: None.

====================================================================
)*/
GLOBAL void
write_word_ev_glue IFN2(IU32, eaOff, IU16, eaVal)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.w_write)(eaOff, eaVal);
}

/*(
=========================== write_dword_ev_glue =======================

PURPOSE: Set up C evid parameters and call dword write function pointer

INPUT: Write offset & value to write

OUTPUT: None.

====================================================================
)*/
GLOBAL void
write_dword_ev_glue IFN2(IU32, eaOff, IU32, eaVal)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.d_write)(eaOff, eaVal);
}

/*(
=========================== fill_byte_ev_glue =======================

PURPOSE: Set up C evid parameters and call byte fill function pointer

INPUT: Write offset, value to write & fill count

OUTPUT: None.

====================================================================
*/
GLOBAL void
fill_byte_ev_glue IFN3(IU32, eaOff, IU8, eaVal, IU32, count)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_parm3 = (IUH)count;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.b_fill)(eaOff, eaVal, count);
}

/*(
=========================== fill_word_ev_glue =======================

PURPOSE: Set up C evid parameters and call word fill function pointer

INPUT: Write offset, value to write & fill count

OUTPUT: None.

====================================================================
*/
GLOBAL void
fill_word_ev_glue IFN3(IU32, eaOff, IU16, eaVal, IU32, count)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_parm3 = (IUH)count;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.w_fill)(eaOff, eaVal, count);
}

/*(
=========================== fill_dword_ev_glue =======================

PURPOSE: Set up C evid parameters and call dword fill function pointer

INPUT: Write offset, value to write & fill count

OUTPUT: None.

====================================================================
*/
GLOBAL void
fill_dword_ev_glue IFN3(IU32, eaOff, IU32, eaVal, IU32, count)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)eaVal;
	jccc_parm3 = (IUH)count;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.d_fill)(eaOff, eaVal, count);
}

/*(
=========================== move_byte_fwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call byte fwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_byte_fwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.b_fwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_byte_bwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call byte bwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_byte_bwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.b_bwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_word_fwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call word fwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_word_fwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.w_fwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_word_bwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call word bwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_word_bwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.w_bwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_dword_fwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call dword fwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_dword_fwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.d_fwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== move_dword_bwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call dword bwd move function pointer

INPUT: Write dest offset, src offset, move count & src type indicator

OUTPUT: None.

====================================================================
*/
GLOBAL void
move_dword_bwd_ev_glue IFN4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM)
{
	jccc_parm1 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm2 = (IUH)fromOff;
	if (!srcInRAM)
		jccc_parm2 -= gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)srcInRAM;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_write_ptr.d_bwd_move)(eaOff, fromOff, count, srcInRAM);
}

/*(
=========================== read_byte_ev_glue =======================

PURPOSE: Set up C evid parameters and call read byte function pointer

INPUT: read offset in planes

OUTPUT: value read

====================================================================
*/
GLOBAL IU32
read_byte_ev_glue IFN1(IU32, eaOff)
{
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.b_read)(eaOff);

	return((IU32)jccc_parm1);
}

/*(
=========================== read_word_ev_glue =======================

PURPOSE: Set up C evid parameters and call read word function pointer

INPUT: read offset in planes

OUTPUT: None.

====================================================================
*/
GLOBAL IU32
read_word_ev_glue IFN1(IU32, eaOff)
{
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.w_read)(eaOff);

	return((IU32)jccc_parm1);
}

/*(
=========================== read_dword_ev_glue =======================

PURPOSE: Set up C evid parameters and call read dword function pointer

INPUT: read offset in planes

OUTPUT: None.

====================================================================
*/
GLOBAL IU32
read_dword_ev_glue IFN1(IU32, eaOff)
{
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.d_read)(eaOff);

	return((IU32)jccc_parm1);
}

/*(
=========================== read_str_fwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call read string fwd function pointer

INPUT: destination pointer, read offset in planes, number of bytes to read.

OUTPUT: None.

====================================================================
*/
GLOBAL void
read_str_fwd_ev_glue IFN3(IU8 *, dest, IU32, eaOff, IU32, count)
{
	jccc_parm1 = (IUH)dest;
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)1;	/* destination in RAM */
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.str_fwd_read)(dest, eaOff, count);
}

/*(
=========================== read_str_bwd_ev_glue =======================

PURPOSE: Set up C evid parameters and call read string bwd function pointer

INPUT: destination pointer, read offset in planes, number of bytes to read.

OUTPUT: None.

====================================================================
*/
GLOBAL void
read_str_bwd_ev_glue IFN3(IU8 *, dest, IU32, eaOff, IU32, count)
{
	jccc_parm1 = (IUH)dest;
	jccc_parm2 = (IUH)eaOff - gvi_pc_low_regen;
	jccc_parm3 = (IUH)count;
	jccc_parm4 = (IUH)1;	/* destination in RAM */
	jccc_gdp = (IUH)Gdp;

	(*c_ev_read_ptr.str_bwd_read)(dest, eaOff, count);
}

GLOBAL IBOOL cevid_verbose = FALSE;
/*(
=========================== setReadPointers =======================

PURPOSE: Set active struct entries for read functions. (c_ev_read_ptr).

INPUT: index used to select read set.

OUTPUT: None.

====================================================================
*/
GLOBAL void
setReadPointers IFN1(IUH, readset)
{
	IUH chain_index;	/* current chaining for read modes 0 & 1 */

	switch(readset)
	{
	case 0:	/* read mode 0 */
		chain_index = getVideochain();
		if (cevid_verbose) printf("Set Read Pointers Mode 0, chain %d\n", chain_index);
		c_ev_read_ptr.b_read = read_mode0_evid[chain_index].b_read;
		c_ev_read_ptr.w_read = read_mode0_evid[chain_index].w_read;
		c_ev_read_ptr.d_read = read_mode0_evid[chain_index].d_read;
		c_ev_read_ptr.str_fwd_read = read_mode0_evid[chain_index].str_fwd_read;
		c_ev_read_ptr.str_bwd_read = read_mode0_evid[chain_index].str_bwd_read;
		setVideoread_byte_addr(read_mode0_evid[chain_index].b_read);
		break;

	case 1:	/* read mode 1 */
		chain_index = getVideochain();
		if (cevid_verbose) printf("Set Read Pointers Mode 1, chain %d\n", chain_index);
		c_ev_read_ptr.b_read = read_mode1_evid[chain_index].b_read;
		c_ev_read_ptr.w_read = read_mode1_evid[chain_index].w_read;
		c_ev_read_ptr.d_read = read_mode1_evid[chain_index].d_read;
		c_ev_read_ptr.str_fwd_read = read_mode1_evid[chain_index].str_fwd_read;
		c_ev_read_ptr.str_bwd_read = read_mode1_evid[chain_index].str_bwd_read;
		setVideoread_byte_addr(read_mode1_evid[chain_index].b_read);
		break;

	case 2:	/* RAM disabled */
		if (cevid_verbose) printf("Set Read Pointers RAM disabled\n");
		c_ev_read_ptr.b_read = ram_dsbld_read_evid.b_read;
		c_ev_read_ptr.w_read = ram_dsbld_read_evid.w_read;
		c_ev_read_ptr.d_read = ram_dsbld_read_evid.d_read;
		c_ev_read_ptr.str_fwd_read = ram_dsbld_read_evid.str_fwd_read;
		c_ev_read_ptr.str_bwd_read = ram_dsbld_read_evid.str_bwd_read;
		setVideoread_byte_addr(ram_dsbld_read_evid.b_read);
		break;

	case 3:	/* Simple reads (non planed) */
		if (cevid_verbose) printf("Set Read Pointers Simple\n");
		c_ev_read_ptr.b_read = simple_read_evid.b_read;
		c_ev_read_ptr.w_read = simple_read_evid.w_read;
		c_ev_read_ptr.d_read = simple_read_evid.d_read;
		c_ev_read_ptr.str_fwd_read = simple_read_evid.str_fwd_read;
		c_ev_read_ptr.str_bwd_read = simple_read_evid.str_bwd_read;
		setVideoread_byte_addr(simple_read_evid.b_read);
		break;
	}
}

/*(
=========================== setWritePointers =======================

PURPOSE: Set active struct entries for write functions. (c_ev_write_ptr).

INPUT: None. (All information gleaned from Vglobs).

OUTPUT: None.

====================================================================
*/
GLOBAL void
setWritePointers IFN0()
{
	EVID_WRT_POINTERS *choice;	/* point to selected write set */
	IU8 chain;
	IU8 modelookup[] =
	      /*  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 */
		{ 0, 1, 2, 3, 2, 3, 2, 3, 0, 1, 2, 3, 2, 3, 2, 3,
	      /*  16 17 18  19  20  21  22 23 24 25 26  27  28  29  30  31 */
		  8, 9, 10, 11, 10, 11, 6, 7, 8, 9, 10, 11, 10, 11, 10, 11 };

	choice = (EVID_WRT_POINTERS *)0;	/* debug check */

	/* check for dithering 'override' of rest of checks */
	if (getVideodither() == 1)
	{
		if (cevid_verbose) printf("SetWritePointers Dither, Mode %d\n", getVideowrmode());	/*STF*/
		choice = &dith_evid[getVideowrmode()]; /* mode 0-3 */
	}
	else
	{
		chain = getVideochain();
		switch (chain)
		{
		case UNCHAINED:
		case CHAIN_4:
			if (getVideorotate() > 0)
			{
				if (cevid_verbose) printf("SetWritePointers Generic Override for Chain %d, Mode %d\n", chain, getVideowrmode());	/*STF*/
				if (cevid_verbose) printf("Rotates set to %d\n", getVideorotate());/*STF*/
				choice = &gricvid_evid;
			}
			else
			{
				if (chain == UNCHAINED)
				{
					if (cevid_verbose) printf("SetWritePointers Unchained, State %#x", getVideowrstate());	/*STF*/
					choice = &unchained_evid[0];
				}
				else
				{
					if (cevid_verbose) printf("SetWritePointers Chain4");	/*STF*/
					choice = &chain4_evid[0];
				}
				switch(getVideowrmode())
				{
					case MODE_0:
						if (cevid_verbose) printf(" Mode 0, index %d\n", modelookup[getVideowrstate()]);	/* STF */
						choice += modelookup[getVideowrstate()];
						break;

					case MODE_1:
						if (cevid_verbose) printf(" Mode 1\n");/* STF */
						choice += NUM_M0_WRITES;
						break;

					case MODE_2:
						if (cevid_verbose) printf(" Mode 2, index %d\n", modelookup[getVideowrstate() & 0xf]);/* STF */
						choice += NUM_M0_WRITES + NUM_M1_WRITES;
						choice += modelookup[getVideowrstate() & 0xf];
						break;

					case MODE_3:
						if (cevid_verbose) printf(" Mode 3, index %d\n", modelookup[getVideowrstate() & 0xf]);/* STF */
						choice += NUM_M0_WRITES + NUM_M1_WRITES + NUM_M23_WRITES;
						choice += modelookup[getVideowrstate() & 0xf];
						break;

					default:
						if (cevid_verbose) printf(" unknown write mode %d\n",getVideowrmode());
				}
			}
			break;

		case CHAIN_2:
			if (cevid_verbose) printf("SetWritePointers Chain2, Mode %d\n", getVideowrmode());	/*STF*/
			choice = &chain2_evid[getVideowrmode()];
			break;

		case SIMPLE_WRITES:
			if (cevid_verbose) printf("SetWritePointers Simple\n");	/*STF*/
			choice = &simple_evid;
			break;
		}
	}
	if (choice == (EVID_WRT_POINTERS *)0)
	{
		printf("setWritePointers: ERROR - BAD POINTER SELECTION\n");
		choice = &chain2_evid[4];
	}
	c_ev_write_ptr.b_write = choice->b_write;
	c_ev_write_ptr.w_write = choice->w_write;
	c_ev_write_ptr.d_write = choice->d_write;
	c_ev_write_ptr.b_fill = choice->b_fill;
	c_ev_write_ptr.w_fill = choice->w_fill;
	c_ev_write_ptr.d_fill = choice->d_fill;
	c_ev_write_ptr.b_fwd_move = choice->b_fwd_move;
	c_ev_write_ptr.b_bwd_move = choice->b_bwd_move;
	c_ev_write_ptr.w_fwd_move = choice->w_fwd_move;
	c_ev_write_ptr.w_bwd_move = choice->w_bwd_move;
	c_ev_write_ptr.d_fwd_move = choice->d_fwd_move;
	c_ev_write_ptr.d_bwd_move = choice->d_bwd_move;
}

/*(
=========================== setMarkPointers =======================

PURPOSE: Set VGlobs entries for mark functions

INPUT: index used to select mark set.

OUTPUT: None.

====================================================================
*/
GLOBAL void
setMarkPointers IFN1(IUH, markset)
{
	switch (markset)
	{

	case 0:	/* simple */
		if (cevid_verbose) printf("Set Mark Pointers Simple\n");
		setVideomark_byte(simple_mark_evid.b_mark);
		setVideomark_word(simple_mark_evid.w_mark);
		setVideomark_string(simple_mark_evid.str_mark);
		break;

	case 1:	/* CGA style */
		if (cevid_verbose) printf("Set Mark Pointers CGA\n");
		setVideomark_byte(cga_mark_evid.b_mark);
		setVideomark_word(cga_mark_evid.w_mark);
		setVideomark_string(cga_mark_evid.str_mark);
		break;

	case 2:	/* Unchained */
		if (cevid_verbose) printf("Set Mark Pointers Unchained\n");
		setVideomark_byte(unchained_mark_evid.b_mark);
		setVideomark_word(unchained_mark_evid.w_mark);
		setVideomark_string(unchained_mark_evid.str_mark);
		break;

	case 3:	/* Chain4 */
		if (cevid_verbose) printf("Set Mark Pointers Chain4\n");
		setVideomark_byte(chain4_mark_evid.b_mark);
		setVideomark_word(chain4_mark_evid.w_mark);
		setVideomark_string(chain4_mark_evid.str_mark);
		break;

	}
}

GLOBAL void
write_bios_byte IFN2(IU8, eaVal, IU32, eaOff)
{
	jccc_parm1 = (IUH)eaOff;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	chain2_evid[4].b_write(eaOff, eaVal);
}

GLOBAL void
write_bios_word IFN2(IU16, eaVal, IU32, eaOff)
{
	jccc_parm1 = (IUH)eaOff;
	jccc_parm2 = (IUH)eaVal;
	jccc_gdp = (IUH)Gdp;

	chain2_evid[4].w_write(eaOff, eaVal);
}

/*(
=========================== SetBiosWrites =======================

PURPOSE: Set VGlobs entries for mark functions

INPUT: index used to select mark set.

OUTPUT: None.

====================================================================
*/
GLOBAL void
SetBiosWrites IFN1(IUH, markset)
{
	bios_ch2_byte_wrt_fn = write_bios_byte;
	bios_ch2_word_wrt_fn = write_bios_word;
}

#ifdef CCPU

#define SUBRRINGBUFFERSIZE 25
GLOBAL IUH SubrRingBuffer[SUBRRINGBUFFERSIZE];
/*(
=========================== setup_vga_globals =======================

PURPOSE: Point VGLOBS into correct portion on Gdp

INPUT: None.

OUTPUT: None.

====================================================================
*/

GLOBAL void
setup_vga_globals IFN0()
{
	EGA_CPU.globals = &(GLOBAL_VGAGlobals);
        GLOBAL_SubrRingLowIncl = &SubrRingBuffer[0];
        GLOBAL_SubrRingHighIncl = GLOBAL_SubrRingLowIncl + (SUBRRINGBUFFERSIZE-1
);
        GLOBAL_SubrRingPtr = GLOBAL_SubrRingLowIncl;

#ifndef PROD
	if (getenv("CEVID_VERBOSE") != 0)
		cevid_verbose = TRUE;
#endif	/* PROD */
}

/*(
=========================== setup_global_data_ptr =======================

PURPOSE: Setup Gdp for CCPU/CEvid.

INPUT: None.

OUTPUT: None.

====================================================================
*/

GLOBAL IHP
setup_global_data_ptr IFN0()
{
	Gdp = (IHP)host_malloc(64 * 1024);
	/* Gdp holds the correct value so in jcode an lea wants the value not
         * the adrress of the data 
	 */
	j_Gdp = Gdp ;
	if (Gdp == (IHP)0)
		printf("Error - can't malloc memory for Gdp\n");

	return(Gdp);
}
#endif	/* CCPU */
#endif	/* C_VID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\flagtb_c.h ===
#ifndef _FlagTb_c_h
#define _FlagTb_c_h
#define NO_PARAM (0)
#define LogCF (0)
#define ZeroPF (1)
#define LogAF (0)
#define ZeroZF (1)
#define ShrSF (0)
#define LogOF (0)
#define ZeroAllF (68)
#define ZeroBE (1)
#define ZeroL (0)
#define ZeroLE (1)
#endif /* ! _FlagTb_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\evid_c.h ===
#ifndef _Evid_c_h
#define _Evid_c_h
#define MODE_0 (0)
#define MODE_1 (1)
#define MODE_2 (2)
#define MODE_3 (3)
#define COPY_MODE (4)
#define VGA_SRC (0)
#define RAM_SRC (1)
#define FORWARDS (0)
#define BACKWARDS (1)
#define FWD_BYTE (0)
#define BWD_BYTE (1)
#define FWD_WORD (2)
#define BWD_WORD (3)
#define UNCHAINED (0)
#define CHAIN_2 (1)
#define CHAIN_4 (2)
#define SIMPLE_WRITES (3)
#define FUNC_COPY (0)
#define FUNC_AND (1)
#define FUNC_OR (2)
#define FUNC_XOR (3)
#define FUNC_SHIFT (1)
#define PLANE_ENABLE (1)
#define FUNC_CODE (6)
#define BIT_PROT (8)
#define SET_RESET (16)
#define PROT_OR_FUNC (14)
#define READ_MODE_0 (0)
#define READ_MODE_1 (1)
#define DISABLED_RAM (2)
#define SIMPLE_READ (3)
#define SIMPLE_MARK (0)
#define CGA_MARK (1)
#define UNCHAINED_MARK (2)
#define CHAIN_4_MARK (3)
#define BYTE_SIZE (0)
#define WORD_SIZE (1)
#define DWORD_SIZE (2)
#define STRING_SIZE (3)
#define WRITE_RTN (0)
#define FILL_RTN (1)
#define MOVE_RTN (2)
#define READ_RTN (3)
#define EGA_INDEX (0)
#define VGA_INDEX (1)
#define GC_MASK (2)
#define GC_MASK_FF (3)
#define NUM_UNCHAINED_WRITES (21)
#define NUM_CHAIN4_WRITES (21)
#define NUM_CHAIN2_WRITES (5)
#define NUM_DITHER_WRITES (4)
#define NUM_M0_WRITES (12)
#define NUM_M1_WRITES (1)
#define NUM_M23_WRITES (4)
#define NUM_READ_M0_READS (3)
#define NUM_READ_M1_READS (3)
struct VGAGLOBALSETTINGS
{
	IU32 latches;
	IU8 *VGA_rplane;
	IU8 *VGA_wplane;
	IU8 *scratch;
	IU32 sr_masked_val;
	IU32 sr_nmask;
	IU32 data_and_mask;
	IU32 data_xor_mask;
	IU32 latch_xor_mask;
	IU32 bit_prot_mask;
	IU32 plane_enable;
	IU32 plane_enable_mask;
	IUH *sr_lookup;
	IUH *fwd_str_read_addr;
	IUH *bwd_str_read_addr;
	IU32 dirty_total;
	IS32 dirty_low;
	IS32 dirty_high;
	IU8 *video_copy;
	IUH *mark_byte;
	IUH *mark_word;
	IUH *mark_string;
	IU32 read_shift_count;
	IU32 read_mapped_plane;
	IU32 colour_comp;
	IU32 dont_care;
	IU32 v7_bank_vid_copy_off;
	IU32 video_base_lin_addr;
	IU8 *route_reg1;
	IU8 *route_reg2;
	IU8 *screen_ptr;
	IU32 rotate;
	IU32 calc_data_xor;
	IU32 calc_latch_xor;
	IUH *read_byte_addr;
	IU32 v7_fg_latches;
	IUH **GCRegs;
	IU8 lastGCindex;
	IU8 dither;
	IU8 wrmode;
	IU8 chain;
	IU8 wrstate;
};
struct EVIDWRITES
{
	IUH *byte_write;
	IUH *word_write;
	IUH *dword_write;
	IUH *byte_fill;
	IUH *word_fill;
	IUH *dword_fill;
	IUH *byte_fwd_move;
	IUH *byte_bwd_move;
	IUH *word_fwd_move;
	IUH *word_bwd_move;
	IUH *dword_fwd_move;
	IUH *dword_bwd_move;
};
struct EVIDREADS
{
	IUH *byte_read;
	IUH *word_read;
	IUH *dword_read;
	IUH *str_fwd_read;
	IUH *str_bwd_read;
};
struct EVIDMARKS
{
	IUH *byte_mark;
	IUH *word_mark;
	IUH *dword_mark;
	IUH *str_mark;
};
enum VidSections
{
	READ_FUNC = 0,
	MARK_FUNC = 1,
	SIMPLE_FUNC = 2,
	DITHER_FUNC = 3,
	PORT_FUNC = 4,
	GENERIC_WRITES = 5,
	UNCHAINED_WRITES = 6,
	CHAIN4_WRITES = 7,
	CHAIN2_WRITES = 8
};
#endif /* ! _Evid_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\evidfunc.h ===
extern void S_2139_SimpleByteWrite IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2142_SimpleWordWrite IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2145_SimpleDwordWrite IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2140_SimpleByteFill IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2143_SimpleWordFill IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2146_SimpleDwordFill IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2141_SimpleByteMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2144_SimpleWordMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2147_SimpleDwordMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2148_SimpleByteMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2149_SimpleWordMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2150_SimpleDwordMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2238_GenericByteWrite IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2241_GenericWordWrite IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2244_GenericDwordWrite IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2239_GenericByteFill IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2242_GenericWordFill IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2245_GenericDwordFill IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2240_GenericByteMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2243_GenericWordMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2246_GenericDwordMove_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2247_GenericByteMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2248_GenericWordMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2249_GenericDwordMove_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2151_UnchainedByteWrite_00000000_0000000e_00000001 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2157_UnchainedWordWrite_00000000_0000000e_00000001 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2163_UnchainedDwordWrite_00000000_0000000e_00000001 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2152_UnchainedByteFill_00000000_0000000e_00000001 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2158_UnchainedWordFill_00000000_0000000e_00000001 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2164_UnchainedDwordFill_00000000_0000000e_00000001 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2166_UnchainedByteWrite_00000001_0000000e_00000001 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2171_UnchainedWordWrite_00000001_0000000e_00000001 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2176_UnchainedDwordWrite_00000001_0000000e_00000001 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2167_UnchainedByteFill_00000001_0000000e_00000001 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2172_UnchainedWordFill_00000001_0000000e_00000001 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2177_UnchainedDwordFill_00000001_0000000e_00000001 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2179_UnchainedByteWrite_00000002_0000000e_00000001 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2184_UnchainedWordWrite_00000002_0000000e_00000001 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2189_UnchainedDwordWrite_00000002_0000000e_00000001 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2180_UnchainedByteFill_00000002_0000000e_00000001 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2185_UnchainedWordFill_00000002_0000000e_00000001 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2190_UnchainedDwordFill_00000002_0000000e_00000001 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2192_UnchainedByteWrite_00000003_0000000e_00000001 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2197_UnchainedWordWrite_00000003_0000000e_00000001 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2202_UnchainedDwordWrite_00000003_0000000e_00000001 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2193_UnchainedByteFill_00000003_0000000e_00000001 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2198_UnchainedWordFill_00000003_0000000e_00000001 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2203_UnchainedDwordFill_00000003_0000000e_00000001 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2624_Chain2ByteWrite_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2630_Chain2WordWrite_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2636_Chain2DwordWrite_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2626_Chain2ByteFill_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2632_Chain2WordFill_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2638_Chain2DwordFill_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2628_Chain2ByteMove_00000000_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2634_Chain2WordMove_00000000_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2640_Chain2DwordMove_00000000_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2705_Chain2ByteMove_00000000_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2707_Chain2WordMove_00000000_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2709_Chain2DwordMove_00000000_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2642_Chain2ByteWrite_00000001 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2648_Chain2WordWrite_00000001 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2654_Chain2DwordWrite_00000001 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2644_Chain2ByteFill_00000001 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2650_Chain2WordFill_00000001 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2656_Chain2DwordFill_00000001 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2646_Chain2ByteMove_00000001_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2652_Chain2WordMove_00000001_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2658_Chain2DwordMove_00000001_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2711_Chain2ByteMove_00000001_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2713_Chain2WordMove_00000001_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2715_Chain2DwordMove_00000001_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2660_Chain2ByteWrite_00000002 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2666_Chain2WordWrite_00000002 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2672_Chain2DwordWrite_00000002 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2662_Chain2ByteFill_00000002 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2668_Chain2WordFill_00000002 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2674_Chain2DwordFill_00000002 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2664_Chain2ByteMove_00000002_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2670_Chain2WordMove_00000002_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2676_Chain2DwordMove_00000002_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2717_Chain2ByteMove_00000002_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2719_Chain2WordMove_00000002_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2721_Chain2DwordMove_00000002_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2678_Chain2ByteWrite_00000003 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2684_Chain2WordWrite_00000003 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2690_Chain2DwordWrite_00000003 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2680_Chain2ByteFill_00000003 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2686_Chain2WordFill_00000003 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2692_Chain2DwordFill_00000003 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2682_Chain2ByteMove_00000003_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2688_Chain2WordMove_00000003_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2694_Chain2DwordMove_00000003_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2723_Chain2ByteMove_00000003_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2725_Chain2WordMove_00000003_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2727_Chain2DwordMove_00000003_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2696_Chain2ByteWrite_Copy IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2699_Chain2WordWrite_Copy IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2702_Chain2DwordWrite_Copy IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2697_Chain2ByteFill_Copy IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2700_Chain2WordFill_Copy IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2703_Chain2DwordFill_Copy IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2698_Chain2ByteMove_Copy_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2701_Chain2WordMove_Copy_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2704_Chain2DwordMove_Copy_Fwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2729_Chain2ByteMove_Copy_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2730_Chain2WordMove_Copy_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2731_Chain2DwordMove_Copy_Bwd IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2250_UnchainedByteWrite_00000000_00000008_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2305_UnchainedWordWrite_00000000_00000008_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2360_UnchainedDwordWrite_00000000_00000008_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2262_UnchainedByteFill_00000000_00000008_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2317_UnchainedWordFill_00000000_00000008_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2372_UnchainedDwordFill_00000000_00000008_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2275_UnchainedByteMove_00000000_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2330_UnchainedWordMove_00000000_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2384_UnchainedDwordMove_00000000_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2501_UnchainedByteMove_00000000_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2531_UnchainedWordMove_00000000_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2561_UnchainedDwordMove_00000000_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2251_UnchainedByteWrite_00000000_00000009_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2306_UnchainedWordWrite_00000000_00000009_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2361_UnchainedDwordWrite_00000000_00000009_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2263_UnchainedByteFill_00000000_00000009_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2318_UnchainedWordFill_00000000_00000009_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2373_UnchainedDwordFill_00000000_00000009_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2278_UnchainedByteMove_00000000_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2333_UnchainedWordMove_00000000_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2385_UnchainedDwordMove_00000000_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2504_UnchainedByteMove_00000000_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2534_UnchainedWordMove_00000000_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2562_UnchainedDwordMove_00000000_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2252_UnchainedByteWrite_00000000_0000000e_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2307_UnchainedWordWrite_00000000_0000000e_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2362_UnchainedDwordWrite_00000000_0000000e_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2265_UnchainedByteFill_00000000_0000000e_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2320_UnchainedWordFill_00000000_0000000e_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2374_UnchainedDwordFill_00000000_0000000e_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2280_UnchainedByteMove_00000000_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2335_UnchainedWordMove_00000000_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2386_UnchainedDwordMove_00000000_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2506_UnchainedByteMove_00000000_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2536_UnchainedWordMove_00000000_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2563_UnchainedDwordMove_00000000_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2253_UnchainedByteWrite_00000000_0000000f_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2308_UnchainedWordWrite_00000000_0000000f_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2363_UnchainedDwordWrite_00000000_0000000f_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2266_UnchainedByteFill_00000000_0000000f_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2321_UnchainedWordFill_00000000_0000000f_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2375_UnchainedDwordFill_00000000_0000000f_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2283_UnchainedByteMove_00000000_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2338_UnchainedWordMove_00000000_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2387_UnchainedDwordMove_00000000_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2509_UnchainedByteMove_00000000_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2539_UnchainedWordMove_00000000_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2564_UnchainedDwordMove_00000000_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2254_UnchainedByteWrite_00000000_00000010_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2309_UnchainedWordWrite_00000000_00000010_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2364_UnchainedDwordWrite_00000000_00000010_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2267_UnchainedByteFill_00000000_00000010_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2322_UnchainedWordFill_00000000_00000010_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2376_UnchainedDwordFill_00000000_00000010_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2285_UnchainedByteMove_00000000_00000010_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2340_UnchainedWordMove_00000000_00000010_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2388_UnchainedDwordMove_00000000_00000010_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2511_UnchainedByteMove_00000000_00000010_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2541_UnchainedWordMove_00000000_00000010_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2565_UnchainedDwordMove_00000000_00000010_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2255_UnchainedByteWrite_00000000_00000011_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2310_UnchainedWordWrite_00000000_00000011_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2365_UnchainedDwordWrite_00000000_00000011_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2268_UnchainedByteFill_00000000_00000011_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2323_UnchainedWordFill_00000000_00000011_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2377_UnchainedDwordFill_00000000_00000011_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2288_UnchainedByteMove_00000000_00000011_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2343_UnchainedWordMove_00000000_00000011_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2389_UnchainedDwordMove_00000000_00000011_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2514_UnchainedByteMove_00000000_00000011_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2544_UnchainedWordMove_00000000_00000011_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2566_UnchainedDwordMove_00000000_00000011_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2256_UnchainedByteWrite_00000000_00000016_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2311_UnchainedWordWrite_00000000_00000016_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2366_UnchainedDwordWrite_00000000_00000016_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2269_UnchainedByteFill_00000000_00000016_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2324_UnchainedWordFill_00000000_00000016_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2378_UnchainedDwordFill_00000000_00000016_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2290_UnchainedByteMove_00000000_00000016_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2345_UnchainedWordMove_00000000_00000016_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2390_UnchainedDwordMove_00000000_00000016_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2516_UnchainedByteMove_00000000_00000016_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2546_UnchainedWordMove_00000000_00000016_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2567_UnchainedDwordMove_00000000_00000016_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2257_UnchainedByteWrite_00000000_00000017_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2312_UnchainedWordWrite_00000000_00000017_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2367_UnchainedDwordWrite_00000000_00000017_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2270_UnchainedByteFill_00000000_00000017_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2325_UnchainedWordFill_00000000_00000017_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2379_UnchainedDwordFill_00000000_00000017_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2293_UnchainedByteMove_00000000_00000017_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2348_UnchainedWordMove_00000000_00000017_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2391_UnchainedDwordMove_00000000_00000017_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2519_UnchainedByteMove_00000000_00000017_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2549_UnchainedWordMove_00000000_00000017_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2568_UnchainedDwordMove_00000000_00000017_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2258_UnchainedByteWrite_00000000_00000018_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2313_UnchainedWordWrite_00000000_00000018_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2368_UnchainedDwordWrite_00000000_00000018_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2271_UnchainedByteFill_00000000_00000018_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2326_UnchainedWordFill_00000000_00000018_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2380_UnchainedDwordFill_00000000_00000018_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2295_UnchainedByteMove_00000000_00000018_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2350_UnchainedWordMove_00000000_00000018_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2392_UnchainedDwordMove_00000000_00000018_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2521_UnchainedByteMove_00000000_00000018_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2551_UnchainedWordMove_00000000_00000018_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2569_UnchainedDwordMove_00000000_00000018_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2259_UnchainedByteWrite_00000000_00000019_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2314_UnchainedWordWrite_00000000_00000019_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2369_UnchainedDwordWrite_00000000_00000019_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2272_UnchainedByteFill_00000000_00000019_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2327_UnchainedWordFill_00000000_00000019_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2381_UnchainedDwordFill_00000000_00000019_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2298_UnchainedByteMove_00000000_00000019_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2353_UnchainedWordMove_00000000_00000019_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2393_UnchainedDwordMove_00000000_00000019_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2524_UnchainedByteMove_00000000_00000019_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2554_UnchainedWordMove_00000000_00000019_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2570_UnchainedDwordMove_00000000_00000019_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2260_UnchainedByteWrite_00000000_0000001e_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2315_UnchainedWordWrite_00000000_0000001e_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2370_UnchainedDwordWrite_00000000_0000001e_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2273_UnchainedByteFill_00000000_0000001e_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2328_UnchainedWordFill_00000000_0000001e_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2382_UnchainedDwordFill_00000000_0000001e_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2300_UnchainedByteMove_00000000_0000001e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2355_UnchainedWordMove_00000000_0000001e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2394_UnchainedDwordMove_00000000_0000001e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2526_UnchainedByteMove_00000000_0000001e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2556_UnchainedWordMove_00000000_0000001e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2571_UnchainedDwordMove_00000000_0000001e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2261_UnchainedByteWrite_00000000_0000001f_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2316_UnchainedWordWrite_00000000_0000001f_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2371_UnchainedDwordWrite_00000000_0000001f_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2274_UnchainedByteFill_00000000_0000001f_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2329_UnchainedWordFill_00000000_0000001f_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2383_UnchainedDwordFill_00000000_0000001f_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2303_UnchainedByteMove_00000000_0000001f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2358_UnchainedWordMove_00000000_0000001f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2395_UnchainedDwordMove_00000000_0000001f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2529_UnchainedByteMove_00000000_0000001f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2559_UnchainedWordMove_00000000_0000001f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2572_UnchainedDwordMove_00000000_0000001f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2396_UnchainedByteWrite_00000001_00000000_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2399_UnchainedWordWrite_00000001_00000000_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2402_UnchainedDwordWrite_00000001_00000000_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2397_UnchainedByteFill_00000001_00000000_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2400_UnchainedWordFill_00000001_00000000_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2403_UnchainedDwordFill_00000001_00000000_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2398_UnchainedByteMove_00000001_00000000_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2401_UnchainedWordMove_00000001_00000000_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2404_UnchainedDwordMove_00000001_00000000_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2573_UnchainedByteMove_00000001_00000000_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2574_UnchainedWordMove_00000001_00000000_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2575_UnchainedDwordMove_00000001_00000000_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2405_UnchainedByteWrite_00000002_00000008_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2423_UnchainedWordWrite_00000002_00000008_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2441_UnchainedDwordWrite_00000002_00000008_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2409_UnchainedByteFill_00000002_00000008_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2427_UnchainedWordFill_00000002_00000008_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2445_UnchainedDwordFill_00000002_00000008_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2413_UnchainedByteMove_00000002_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2431_UnchainedWordMove_00000002_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2449_UnchainedDwordMove_00000002_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2576_UnchainedByteMove_00000002_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2586_UnchainedWordMove_00000002_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2596_UnchainedDwordMove_00000002_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2406_UnchainedByteWrite_00000002_00000009_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2424_UnchainedWordWrite_00000002_00000009_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2442_UnchainedDwordWrite_00000002_00000009_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2410_UnchainedByteFill_00000002_00000009_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2428_UnchainedWordFill_00000002_00000009_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2446_UnchainedDwordFill_00000002_00000009_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2416_UnchainedByteMove_00000002_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2434_UnchainedWordMove_00000002_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2450_UnchainedDwordMove_00000002_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2579_UnchainedByteMove_00000002_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2589_UnchainedWordMove_00000002_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2597_UnchainedDwordMove_00000002_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2407_UnchainedByteWrite_00000002_0000000e_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2425_UnchainedWordWrite_00000002_0000000e_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2443_UnchainedDwordWrite_00000002_0000000e_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2411_UnchainedByteFill_00000002_0000000e_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2429_UnchainedWordFill_00000002_0000000e_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2447_UnchainedDwordFill_00000002_0000000e_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2418_UnchainedByteMove_00000002_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2436_UnchainedWordMove_00000002_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2451_UnchainedDwordMove_00000002_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2581_UnchainedByteMove_00000002_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2591_UnchainedWordMove_00000002_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2598_UnchainedDwordMove_00000002_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2408_UnchainedByteWrite_00000002_0000000f_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2426_UnchainedWordWrite_00000002_0000000f_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2444_UnchainedDwordWrite_00000002_0000000f_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2412_UnchainedByteFill_00000002_0000000f_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2430_UnchainedWordFill_00000002_0000000f_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2448_UnchainedDwordFill_00000002_0000000f_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2421_UnchainedByteMove_00000002_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2439_UnchainedWordMove_00000002_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2452_UnchainedDwordMove_00000002_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2584_UnchainedByteMove_00000002_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2594_UnchainedWordMove_00000002_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2599_UnchainedDwordMove_00000002_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2453_UnchainedByteWrite_00000003_00000008_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2471_UnchainedWordWrite_00000003_00000008_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2489_UnchainedDwordWrite_00000003_00000008_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2457_UnchainedByteFill_00000003_00000008_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2475_UnchainedWordFill_00000003_00000008_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2493_UnchainedDwordFill_00000003_00000008_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2461_UnchainedByteMove_00000003_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2479_UnchainedWordMove_00000003_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2497_UnchainedDwordMove_00000003_00000008_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2600_UnchainedByteMove_00000003_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2610_UnchainedWordMove_00000003_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2620_UnchainedDwordMove_00000003_00000008_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2454_UnchainedByteWrite_00000003_00000009_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2472_UnchainedWordWrite_00000003_00000009_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2490_UnchainedDwordWrite_00000003_00000009_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2458_UnchainedByteFill_00000003_00000009_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2476_UnchainedWordFill_00000003_00000009_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2494_UnchainedDwordFill_00000003_00000009_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2464_UnchainedByteMove_00000003_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2482_UnchainedWordMove_00000003_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2498_UnchainedDwordMove_00000003_00000009_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2603_UnchainedByteMove_00000003_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2613_UnchainedWordMove_00000003_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2621_UnchainedDwordMove_00000003_00000009_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2455_UnchainedByteWrite_00000003_0000000e_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2473_UnchainedWordWrite_00000003_0000000e_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2491_UnchainedDwordWrite_00000003_0000000e_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2459_UnchainedByteFill_00000003_0000000e_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2477_UnchainedWordFill_00000003_0000000e_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2495_UnchainedDwordFill_00000003_0000000e_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2466_UnchainedByteMove_00000003_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2484_UnchainedWordMove_00000003_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2499_UnchainedDwordMove_00000003_0000000e_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2605_UnchainedByteMove_00000003_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2615_UnchainedWordMove_00000003_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2622_UnchainedDwordMove_00000003_0000000e_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2456_UnchainedByteWrite_00000003_0000000f_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2474_UnchainedWordWrite_00000003_0000000f_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2492_UnchainedDwordWrite_00000003_0000000f_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2460_UnchainedByteFill_00000003_0000000f_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2478_UnchainedWordFill_00000003_0000000f_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2496_UnchainedDwordFill_00000003_0000000f_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2469_UnchainedByteMove_00000003_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2487_UnchainedWordMove_00000003_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2500_UnchainedDwordMove_00000003_0000000f_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2608_UnchainedByteMove_00000003_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2618_UnchainedWordMove_00000003_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2623_UnchainedDwordMove_00000003_0000000f_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2732_Chain4ByteWrite_00000000_00000008 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2782_Chain4WordWrite_00000000_00000008 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2831_Chain4DwordWrite_00000000_00000008 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2744_Chain4ByteFill_00000000_00000008 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2794_Chain4WordFill_00000000_00000008 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2843_Chain4DwordFill_00000000_00000008 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2758_Chain4ByteMove_00000000_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2807_Chain4WordMove_00000000_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2855_Chain4DwordMove_00000000_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2965_Chain4ByteMove_00000000_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2989_Chain4WordMove_00000000_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3013_Chain4DwordMove_00000000_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2733_Chain4ByteWrite_00000000_00000009 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2783_Chain4WordWrite_00000000_00000009 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2832_Chain4DwordWrite_00000000_00000009 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2746_Chain4ByteFill_00000000_00000009 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2795_Chain4WordFill_00000000_00000009 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2844_Chain4DwordFill_00000000_00000009 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2760_Chain4ByteMove_00000000_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2809_Chain4WordMove_00000000_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2856_Chain4DwordMove_00000000_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2967_Chain4ByteMove_00000000_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2991_Chain4WordMove_00000000_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3014_Chain4DwordMove_00000000_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2734_Chain4ByteWrite_00000000_0000000e IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2784_Chain4WordWrite_00000000_0000000e IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2833_Chain4DwordWrite_00000000_0000000e IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2748_Chain4ByteFill_00000000_0000000e IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2797_Chain4WordFill_00000000_0000000e IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2845_Chain4DwordFill_00000000_0000000e IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2762_Chain4ByteMove_00000000_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2811_Chain4WordMove_00000000_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2857_Chain4DwordMove_00000000_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2969_Chain4ByteMove_00000000_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2993_Chain4WordMove_00000000_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3015_Chain4DwordMove_00000000_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2735_Chain4ByteWrite_00000000_0000000f IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2785_Chain4WordWrite_00000000_0000000f IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2834_Chain4DwordWrite_00000000_0000000f IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2749_Chain4ByteFill_00000000_0000000f IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2798_Chain4WordFill_00000000_0000000f IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2846_Chain4DwordFill_00000000_0000000f IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2764_Chain4ByteMove_00000000_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2813_Chain4WordMove_00000000_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2858_Chain4DwordMove_00000000_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2971_Chain4ByteMove_00000000_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2995_Chain4WordMove_00000000_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3016_Chain4DwordMove_00000000_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2736_Chain4ByteWrite_00000000_00000010 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2786_Chain4WordWrite_00000000_00000010 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2835_Chain4DwordWrite_00000000_00000010 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2750_Chain4ByteFill_00000000_00000010 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2799_Chain4WordFill_00000000_00000010 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2847_Chain4DwordFill_00000000_00000010 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2766_Chain4ByteMove_00000000_00000010_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2815_Chain4WordMove_00000000_00000010_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2859_Chain4DwordMove_00000000_00000010_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2973_Chain4ByteMove_00000000_00000010_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2997_Chain4WordMove_00000000_00000010_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3017_Chain4DwordMove_00000000_00000010_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2737_Chain4ByteWrite_00000000_00000011 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2787_Chain4WordWrite_00000000_00000011 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2836_Chain4DwordWrite_00000000_00000011 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2751_Chain4ByteFill_00000000_00000011 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2800_Chain4WordFill_00000000_00000011 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2848_Chain4DwordFill_00000000_00000011 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2768_Chain4ByteMove_00000000_00000011_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2817_Chain4WordMove_00000000_00000011_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2860_Chain4DwordMove_00000000_00000011_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2975_Chain4ByteMove_00000000_00000011_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2999_Chain4WordMove_00000000_00000011_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3018_Chain4DwordMove_00000000_00000011_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2738_Chain4ByteWrite_00000000_00000016 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2788_Chain4WordWrite_00000000_00000016 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2837_Chain4DwordWrite_00000000_00000016 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2752_Chain4ByteFill_00000000_00000016 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2801_Chain4WordFill_00000000_00000016 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2849_Chain4DwordFill_00000000_00000016 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2770_Chain4ByteMove_00000000_00000016_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2819_Chain4WordMove_00000000_00000016_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2861_Chain4DwordMove_00000000_00000016_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2977_Chain4ByteMove_00000000_00000016_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3001_Chain4WordMove_00000000_00000016_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3019_Chain4DwordMove_00000000_00000016_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2739_Chain4ByteWrite_00000000_00000017 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2789_Chain4WordWrite_00000000_00000017 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2838_Chain4DwordWrite_00000000_00000017 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2753_Chain4ByteFill_00000000_00000017 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2802_Chain4WordFill_00000000_00000017 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2850_Chain4DwordFill_00000000_00000017 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2772_Chain4ByteMove_00000000_00000017_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2821_Chain4WordMove_00000000_00000017_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2862_Chain4DwordMove_00000000_00000017_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2979_Chain4ByteMove_00000000_00000017_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3003_Chain4WordMove_00000000_00000017_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3020_Chain4DwordMove_00000000_00000017_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2740_Chain4ByteWrite_00000000_00000018 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2790_Chain4WordWrite_00000000_00000018 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2839_Chain4DwordWrite_00000000_00000018 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2754_Chain4ByteFill_00000000_00000018 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2803_Chain4WordFill_00000000_00000018 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2851_Chain4DwordFill_00000000_00000018 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2774_Chain4ByteMove_00000000_00000018_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2823_Chain4WordMove_00000000_00000018_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2863_Chain4DwordMove_00000000_00000018_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2981_Chain4ByteMove_00000000_00000018_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3005_Chain4WordMove_00000000_00000018_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3021_Chain4DwordMove_00000000_00000018_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2741_Chain4ByteWrite_00000000_00000019 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2791_Chain4WordWrite_00000000_00000019 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2840_Chain4DwordWrite_00000000_00000019 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2755_Chain4ByteFill_00000000_00000019 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2804_Chain4WordFill_00000000_00000019 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2852_Chain4DwordFill_00000000_00000019 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2776_Chain4ByteMove_00000000_00000019_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2825_Chain4WordMove_00000000_00000019_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2864_Chain4DwordMove_00000000_00000019_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2983_Chain4ByteMove_00000000_00000019_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3007_Chain4WordMove_00000000_00000019_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3022_Chain4DwordMove_00000000_00000019_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2742_Chain4ByteWrite_00000000_0000001e IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2792_Chain4WordWrite_00000000_0000001e IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2841_Chain4DwordWrite_00000000_0000001e IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2756_Chain4ByteFill_00000000_0000001e IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2805_Chain4WordFill_00000000_0000001e IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2853_Chain4DwordFill_00000000_0000001e IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2778_Chain4ByteMove_00000000_0000001e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2827_Chain4WordMove_00000000_0000001e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2865_Chain4DwordMove_00000000_0000001e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2985_Chain4ByteMove_00000000_0000001e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3009_Chain4WordMove_00000000_0000001e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3023_Chain4DwordMove_00000000_0000001e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2743_Chain4ByteWrite_00000000_0000001f IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2793_Chain4WordWrite_00000000_0000001f IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2842_Chain4DwordWrite_00000000_0000001f IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2757_Chain4ByteFill_00000000_0000001f IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2806_Chain4WordFill_00000000_0000001f IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2854_Chain4DwordFill_00000000_0000001f IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2780_Chain4ByteMove_00000000_0000001f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2829_Chain4WordMove_00000000_0000001f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2866_Chain4DwordMove_00000000_0000001f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2987_Chain4ByteMove_00000000_0000001f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3011_Chain4WordMove_00000000_0000001f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3024_Chain4DwordMove_00000000_0000001f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2867_Chain4ByteWrite_00000001_00000000 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2871_Chain4WordWrite_00000001_00000000 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2874_Chain4DwordWrite_00000001_00000000 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2868_Chain4ByteFill_00000001_00000000 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2872_Chain4WordFill_00000001_00000000 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2875_Chain4DwordFill_00000001_00000000 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2869_Chain4ByteMove_00000001_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2873_Chain4WordMove_00000001_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2876_Chain4DwordMove_00000001_00000000_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3025_Chain4ByteMove_00000001_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3027_Chain4WordMove_00000001_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3028_Chain4DwordMove_00000001_00000000_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2877_Chain4ByteWrite_00000002_00000008 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2893_Chain4WordWrite_00000002_00000008 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2909_Chain4DwordWrite_00000002_00000008 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2881_Chain4ByteFill_00000002_00000008 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2897_Chain4WordFill_00000002_00000008 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2913_Chain4DwordFill_00000002_00000008 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2885_Chain4ByteMove_00000002_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2901_Chain4WordMove_00000002_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2917_Chain4DwordMove_00000002_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3029_Chain4ByteMove_00000002_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3037_Chain4WordMove_00000002_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3045_Chain4DwordMove_00000002_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2878_Chain4ByteWrite_00000002_00000009 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2894_Chain4WordWrite_00000002_00000009 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2910_Chain4DwordWrite_00000002_00000009 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2882_Chain4ByteFill_00000002_00000009 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2898_Chain4WordFill_00000002_00000009 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2914_Chain4DwordFill_00000002_00000009 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2887_Chain4ByteMove_00000002_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2903_Chain4WordMove_00000002_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2918_Chain4DwordMove_00000002_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3031_Chain4ByteMove_00000002_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3039_Chain4WordMove_00000002_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3046_Chain4DwordMove_00000002_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2879_Chain4ByteWrite_00000002_0000000e IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2895_Chain4WordWrite_00000002_0000000e IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2911_Chain4DwordWrite_00000002_0000000e IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2883_Chain4ByteFill_00000002_0000000e IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2899_Chain4WordFill_00000002_0000000e IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2915_Chain4DwordFill_00000002_0000000e IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2889_Chain4ByteMove_00000002_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2905_Chain4WordMove_00000002_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2919_Chain4DwordMove_00000002_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3033_Chain4ByteMove_00000002_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3041_Chain4WordMove_00000002_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3047_Chain4DwordMove_00000002_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2880_Chain4ByteWrite_00000002_0000000f IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2896_Chain4WordWrite_00000002_0000000f IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2912_Chain4DwordWrite_00000002_0000000f IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2884_Chain4ByteFill_00000002_0000000f IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2900_Chain4WordFill_00000002_0000000f IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2916_Chain4DwordFill_00000002_0000000f IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2891_Chain4ByteMove_00000002_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2907_Chain4WordMove_00000002_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2920_Chain4DwordMove_00000002_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3035_Chain4ByteMove_00000002_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3043_Chain4WordMove_00000002_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3048_Chain4DwordMove_00000002_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2921_Chain4ByteWrite_00000003_00000008 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2937_Chain4WordWrite_00000003_00000008 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2953_Chain4DwordWrite_00000003_00000008 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2925_Chain4ByteFill_00000003_00000008 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2941_Chain4WordFill_00000003_00000008 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2957_Chain4DwordFill_00000003_00000008 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2929_Chain4ByteMove_00000003_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2945_Chain4WordMove_00000003_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2961_Chain4DwordMove_00000003_00000008_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3049_Chain4ByteMove_00000003_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3057_Chain4WordMove_00000003_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3065_Chain4DwordMove_00000003_00000008_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2922_Chain4ByteWrite_00000003_00000009 IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2938_Chain4WordWrite_00000003_00000009 IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2954_Chain4DwordWrite_00000003_00000009 IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2926_Chain4ByteFill_00000003_00000009 IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2942_Chain4WordFill_00000003_00000009 IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2958_Chain4DwordFill_00000003_00000009 IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2931_Chain4ByteMove_00000003_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2947_Chain4WordMove_00000003_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2962_Chain4DwordMove_00000003_00000009_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3051_Chain4ByteMove_00000003_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3059_Chain4WordMove_00000003_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3066_Chain4DwordMove_00000003_00000009_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2923_Chain4ByteWrite_00000003_0000000e IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2939_Chain4WordWrite_00000003_0000000e IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2955_Chain4DwordWrite_00000003_0000000e IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2927_Chain4ByteFill_00000003_0000000e IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2943_Chain4WordFill_00000003_0000000e IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2959_Chain4DwordFill_00000003_0000000e IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2933_Chain4ByteMove_00000003_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2949_Chain4WordMove_00000003_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2963_Chain4DwordMove_00000003_0000000e_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3053_Chain4ByteMove_00000003_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3061_Chain4WordMove_00000003_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3067_Chain4DwordMove_00000003_0000000e_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2924_Chain4ByteWrite_00000003_0000000f IPT2(IU32, eaOff, IU8, eaVal);
extern void S_2940_Chain4WordWrite_00000003_0000000f IPT2(IU32, eaOff, IU16, eaVal);
extern void S_2956_Chain4DwordWrite_00000003_0000000f IPT2(IU32, eaOff, IU32, eaVal);
extern void S_2928_Chain4ByteFill_00000003_0000000f IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
extern void S_2944_Chain4WordFill_00000003_0000000f IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
extern void S_2960_Chain4DwordFill_00000003_0000000f IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
extern void S_2935_Chain4ByteMove_00000003_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2951_Chain4WordMove_00000003_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_2964_Chain4DwordMove_00000003_0000000f_00000000 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3055_Chain4ByteMove_00000003_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3063_Chain4WordMove_00000003_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);
extern void S_3068_Chain4DwordMove_00000003_0000000f_00000001 IPT4(IU32, eaOff, IHPE, fromOff, IU32, count, IBOOL, srcInRAM);


/*========= Mark Functions ============ */

extern S_2126_SimpleMark IPT0();
extern S_2127_CGAMarkByte IPT1(IU32, eaOff);
extern S_2128_CGAMarkWord IPT1(IU32, eaOff);
extern S_2129_CGAMarkDword IPT1(IU32, eaOff);
extern S_2130_CGAMarkString IPT2(IU32, eaOff, IU32, count);
extern S_2131_UnchainedMarkByte IPT1(IU32, eaOff);
extern S_2132_UnchainedMarkWord IPT1(IU32, eaOff);
extern S_2133_UnchainedMarkDword IPT1(IU32, eaOff);
extern S_2134_UnchainedMarkString IPT2(IU32, eaOff, IU32, count);
extern S_2135_Chain4MarkByte IPT1(IU32, eaOff);
extern S_2136_Chain4MarkWord IPT1(IU32, eaOff);
extern S_2137_Chain4MarkDword IPT1(IU32, eaOff);
extern S_2138_Chain4MarkString IPT2(IU32, eaOff, IU32, count);
extern S_2135_Chain4MarkByte IPT1(IU32, eaOff);
extern S_2136_Chain4MarkWord IPT1(IU32, eaOff);
extern S_2137_Chain4MarkDword IPT1(IU32, eaOff);
extern S_2138_Chain4MarkString IPT2(IU32, eaOff, IU32, count);


/*========= Read Functions ============ */

extern IU32 S_2115_SimpleByteRead IPT1(IU32, eaOff);
extern IU32 S_2116_SimpleWordRead IPT1(IU32, eaOff);
extern IU32 S_2117_SimpleDwordRead IPT1(IU32, eaOff);
extern void S_2118_SimpleStringRead IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2118_SimpleStringRead IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2111_DisabledRAMByteRead IPT1(IU32, eaOff);
extern IU32 S_2112_DisabledRAMWordRead IPT1(IU32, eaOff);
extern IU32 S_2113_DisabledRAMDwordRead IPT1(IU32, eaOff);
extern void S_2114_DisabledRAMStringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2125_DisabledRAMStringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2095_RdMode0UnchainedByteRead IPT1(IU32, eaOff);
extern IU32 S_2096_RdMode0UnchainedWordRead IPT1(IU32, eaOff);
extern IU32 S_2097_RdMode0UnchainedDwordRead IPT1(IU32, eaOff);
extern void S_2098_RdMode0UnchainedStringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2121_RdMode0UnchainedStringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2107_RdMode1UnchainedByteRead IPT1(IU32, eaOff);
extern IU32 S_2108_RdMode1UnchainedWordRead IPT1(IU32, eaOff);
extern IU32 S_2109_RdMode1UnchainedDwordRead IPT1(IU32, eaOff);
extern void S_2110_RdMode1UnchainedStringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2124_RdMode1UnchainedStringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2087_RdMode0Chain2ByteRead IPT1(IU32, eaOff);
extern IU32 S_2088_RdMode0Chain2WordRead IPT1(IU32, eaOff);
extern IU32 S_2089_RdMode0Chain2DwordRead IPT1(IU32, eaOff);
extern void S_2090_RdMode0Chain2StringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2119_RdMode0Chain2StringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2099_RdMode1Chain2ByteRead IPT1(IU32, eaOff);
extern IU32 S_2100_RdMode1Chain2WordRead IPT1(IU32, eaOff);
extern IU32 S_2101_RdMode1Chain2DwordRead IPT1(IU32, eaOff);
extern void S_2102_RdMode1Chain2StringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2122_RdMode1Chain2StringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2091_RdMode0Chain4ByteRead IPT1(IU32, eaOff);
extern IU32 S_2092_RdMode0Chain4WordRead IPT1(IU32, eaOff);
extern IU32 S_2093_RdMode0Chain4DwordRead IPT1(IU32, eaOff);
extern void S_2094_RdMode0Chain4StringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2120_RdMode0Chain4StringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern IU32 S_2103_RdMode1Chain4ByteRead IPT1(IU32, eaOff);
extern IU32 S_2104_RdMode1Chain4WordRead IPT1(IU32, eaOff);
extern IU32 S_2105_RdMode1Chain4DwordRead IPT1(IU32, eaOff);
extern void S_2106_RdMode1Chain4StringReadFwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern void S_2123_RdMode1Chain4StringReadBwd IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
extern EVID_WRT_POINTERS simple_evid;
extern EVID_WRT_POINTERS gricvid_evid;
extern EVID_WRT_POINTERS dith_evid[];
extern EVID_WRT_POINTERS chain2_evid[];
extern EVID_WRT_POINTERS unchained_evid[];
extern EVID_WRT_POINTERS chain4_evid[];
extern EVID_READ_POINTERS simple_read_evid;
extern EVID_READ_POINTERS ram_dsbld_read_evid;
extern EVID_READ_POINTERS read_mode0_evid[];
extern EVID_READ_POINTERS read_mode1_evid[];
extern EVID_MARK_POINTERS simple_mark_evid;
extern EVID_MARK_POINTERS cga_mark_evid;
extern EVID_MARK_POINTERS unchained_mark_evid;
extern EVID_MARK_POINTERS chain4_mark_evid;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\fmevid_c.h ===
#ifndef _FmEvid_c_h
#define _FmEvid_c_h
#endif /* ! _FmEvid_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\flags_c.h ===
#ifndef _Flags_c_h
#define _Flags_c_h
#define MSBB (128)
#define MSBW (32768)
#define MSBD (-2147483648)
#define MSBM1B (127)
#define MSBM1W (32767)
#define MSBM1D (2147483647)
#define ALLB0B (254)
#define ALLB0W (65534)
#define ALLB0D (-2)
#define MSB_OFFB (7)
#define MSB_OFFW (15)
#define MSB_OFFD (31)
#define FtZeroFlagSettings (68)
#define BYTE_SHIFT (24)
#define WORD_SHIFT (16)
#define DOUBLE_SHIFT (0)
#endif /* ! _Flags_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\fm_c.h ===
#ifndef _Fm_c_h
#define _Fm_c_h
#define epcNBits (10)
#define epcMask (1023)
#define DataBufferSize (4000)
#define ConstraintBitMapNULL ((struct ConstraintBitMapREC*)0)
#define CleanedNULL ((struct CleanedREC*)0)
#define EntryPointCacheNULL ((struct EntryPointCacheREC*)0)
#define MAX_IHOOK_DEPTH (32)
struct ConstraintBitMapREC
{
	IU32 first32;
	IU16 last16;
	IU16 CodeSegSelector;
};
struct CleanedREC
{
	IU32 EIP;
	IU32 nextEIP;
	struct ConstraintBitMapREC constraints;
	IU8 flagsType;
};
struct EntryPointCacheREC
{
	IU32 eip;
	IU32*hostCode;
};
struct FragmentInfoREC
{
	IU32 *hostAddress;
	struct EntryPointCacheREC *copierUniv;
	struct EntryPointCacheREC *lastSetCopierUniv;
	struct ConstraintBitMapREC constraints;
	IU32 eip;
	IBOOL setFt;
	IU8 control;
	IU8 intelLength;
	IUH flagsType;
	IU8 *copierCleanups;
};
struct BLOCK_TO_COMPILE
{
	struct ConstraintBitMapREC constraints;
	IU32 linearAddress;
	IU32 eip;
	struct EntryPointCacheREC *univ;
	IU8 *intelPtr;
	IU16 nanoBlockNr;
	IU16 infoRecNr;
	IBOOL univValid;
	IU8 intelLength;
	IU8 isEntryPoint;
	IU8 execCount;
};
struct IretHookStackREC
{
	IU16 cs;
	IU32 eip;
	void *hsp;
	IU16 line;
};
#endif /* ! _Fm_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\fpu_c.h ===
#ifndef _Fpu_c_h
#define _Fpu_c_h
#define HOST_BIAS (1023)
#define MIN_EXP (-1023)
#define MAX_EXP (1024)
#define STACKENTRYSIZE (16)
#define STACKSIZE (128)
#define STACKWRAP (-129)
#define TAG_NEGATIVE_BIT (0)
#define TAG_ZERO_BIT (1)
#define TAG_INFINITY_BIT (2)
#define TAG_DENORMAL_BIT (3)
#define TAG_NAN_BIT (4)
#define TAG_SNAN_BIT (5)
#define TAG_UNSUPPORTED_BIT (6)
#define TAG_EMPTY_BIT (7)
#define TAG_FSCALE_BIT (8)
#define TAG_BCD_BIT (9)
#define TAG_R80_BIT (10)
#define TAG_UNEVAL_BIT_E (9)
#define TAG_UNEVAL_BIT_S (10)
#define TAG_REAL_POSITIVE_MASK (0)
#define TAG_NEGATIVE_MASK (1)
#define TAG_ZERO_MASK (2)
#define TAG_INFINITY_MASK (4)
#define TAG_DENORMAL_MASK (8)
#define TAG_NAN_MASK (16)
#define TAG_SNAN_MASK (32)
#define TAG_UNSUPPORTED_MASK (64)
#define TAG_EMPTY_MASK (128)
#define TAG_FSCALE_MASK (256)
#define TAG_BCD_MASK (512)
#define TAG_R80_MASK (1024)
#define TAG_UNEVAL_MASK (1536)
#define ST_IE_BIT (0)
#define ST_DE_BIT (1)
#define ST_ZE_BIT (2)
#define ST_OE_BIT (3)
#define ST_UE_BIT (4)
#define ST_PE_BIT (5)
#define ST_SF_BIT (6)
#define ST_ES_BIT (7)
#define ST_IE_MASK (1)
#define ST_DE_MASK (2)
#define ST_ZE_MASK (4)
#define ST_OE_MASK (8)
#define ST_UE_MASK (16)
#define ST_PE_MASK (32)
#define ST_SF_MASK (64)
#define ST_ES_MASK (128)
#define ST_C0_BIT (8)
#define ST_C1_BIT (9)
#define ST_C2_BIT (10)
#define ST_C3_BIT (14)
#define ST_C0_MASK (65279)
#define ST_C1_MASK (65023)
#define ST_C2_MASK (64511)
#define ST_C3_MASK (49151)
#define ST_B_BIT (15)
#define ST_ST_BIT_S (13)
#define ST_ST_BIT_E (11)
#define ST_B_MASK (61439)
#define ST_ST_MASK (51199)
#define TW_TAG_0_S (1)
#define TW_TAG_0_E (0)
#define TW_TAG_LENGTH (2)
#define TW_TAG_0_MASK (3)
#define TW_TAG_VALID (0)
#define TW_TAG_ZERO (1)
#define TW_TAG_INVALID (2)
#define TW_TAG_EMPTY (3)
#define CW_IM_BIT (0)
#define CW_DM_BIT (1)
#define CW_ZM_BIT (2)
#define CW_OM_BIT (3)
#define CW_UM_BIT (4)
#define CW_PM_BIT (5)
#define CW_PC_BIT_E (8)
#define CW_PC_BIT_S (9)
#define CW_RC_BIT_E (10)
#define CW_RC_BIT_S (11)
#define CW_IC_BIT (12)
#define CW_IM_MASK (1)
#define CW_DM_MASK (2)
#define CW_ZM_MASK (4)
#define CW_OM_MASK (8)
#define CW_UM_MASK (16)
#define CW_PM_MASK (32)
#define CW_PC_MASK (768)
#define CW_RC_MASK (3072)
#define CW_IC_MASK (4096)
#define ROUND_NEAREST (0)
#define ROUND_NEG_INFINITY (1)
#define ROUND_POS_INFINITY (2)
#define ROUND_TO_ZERO (3)
#define INTEL_I16_SIGN_BIT (15)
#define INTEL_I16_SIGN_MASK (32768)
#define INTEL_I32_SIGN_BIT (31)
#define INTEL_I32_SIGN_MASK (-2147483648)
#define INTEL_I64_SIGN_BIT (31)
#define INTEL_BCD_SIGN_BIT (15)
#define INTEL_SR_SIGN_BIT (31)
#define INTEL_SR_SIGN_MASK (-2147483648)
#define INTEL_SR_EXP_S (30)
#define INTEL_SR_EXP_E (23)
#define INTEL_SR_EXP_MASK (2139095040)
#define INTEL_SR_EXP_MAX (255)
#define INTEL_SR_MANT_S (22)
#define INTEL_SR_MANT_E (0)
#define INTEL_SR_MANT_MASK (8388607)
#define INTEL_LR_SIGN_BIT (31)
#define INTEL_LR_SIGN_MASK (-2147483648)
#define INTEL_LR_EXP_S (30)
#define INTEL_LR_EXP_E (20)
#define INTEL_LR_EXP_MASK (2146435072)
#define INTEL_LR_EXP_MAX (2047)
#define INTEL_LR_MANT_S (19)
#define INTEL_LR_MANT_E (0)
#define INTEL_LR_MANT_MASK (1048575)
#define INTEL_TR_SIGN_BIT (15)
#define INTEL_TR_SIGN_MASK (32768)
#define INTEL_TR_EXP_S (14)
#define INTEL_TR_EXP_E (0)
#define INTEL_TR_EXP_MASK (32767)
#define INTEL_COMP_NC (17664)
#define INTEL_COMP_GT (0)
#define INTEL_COMP_LT_BIT (8)
#define INTEL_COMP_EQ_BIT (14)
#define INTEL_COMP_LT (256)
#define INTEL_COMP_EQ (16384)
#define FPTEMP_INDEX (16)
#define C3C2C0MASK (47359)
#define FCLEX_MASK (32512)
#define COMP_LT (0)
#define COMP_GT (1)
#define COMP_EQ (2)
#define FPBASE_OFFSET (8)
#define CONST_ONE_OFFSET (0)
#define CONST_LOG2_E_OFFSET (1)
#define CONST_LOG2_10_OFFSET (2)
#define CONST_LOG10_2_OFFSET (3)
#define CONST_LOGE_2_OFFSET (4)
#define CONST_PI_OFFSET (5)
#define CONST_ZERO_OFFSET (6)
#define CONST_TWO_OFFSET (7)
#define CONST_MINUS_ONE_OFFSET (8)
struct FPSTACKENTRY
{
	double fpvalue;
	IUH padding;
	IUH tagvalue;
};
struct FP_I64
{
	IU32 word1;
	IU32 word2;
};
struct FP_R64
{
	IU32 word1;
	IU32 word2;
};
struct FP_R80
{
	struct FP_I64 mantissa;
	IU16 exponent;
};
#endif /* ! _Fpu_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\gdmain_c.h ===
#ifndef _GdMain_c_h
#define _GdMain_c_h
#endif /* ! _GdMain_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\gdinit_c.h ===
#ifndef _GdInit_c_h
#define _GdInit_c_h
#endif /* ! _GdInit_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\gdebug.h ===
#ifndef _gdebug_h
#define _gdebug_h
struct gdp_struct {
	/*    0 */	IUH HookNumber;
	/*    4 */	IUH EfiNumber;
	/*    8 */	IUH* SubrRingPtr;
	/*   12 */	IUH* SubrRingLowIncl;
	/*   16 */	IUH* SubrRingHighIncl;
	/*   20 */	IUH WhichAssertion;
	/*   24 */	IU32* WhereAmI;
	/*   28 */	IUH CoRoRet;
	/*   32 */	IUH ErrorNumber;
	/*   36 */	IUH EDL_WORKSPACE_0;
	/*   40 */	IUH EDL_WORKSPACE_1;
	/*   44 */	IUH EDL_WORKSPACE_2;
	/*   48 */	IUH EDL_WORKSPACE_3;
	/*   52 */	IUH EDL_WORKSPACE_4;
	/*   56 */	IUH EDL_WORKSPACE_5;
	/*   60 */	IUH EDL_WORKSPACE_6;
	/*   64 */	IUH EDL_WORKSPACE_7;
	/*   68 */	IUH EDL_WORKSPACE_8;
	/*   72 */	IUH EDL_WORKSPACE_9;
	/*   76 */	IUH EDL_WORKSPACE_10;
	/*   80 */	IUH EDL_WORKSPACE_11;
	/*   84 */	IUH EDL_WORKSPACE_12;
	/*   88 */	IUH EDL_WORKSPACE_13;
	/*   92 */	IUH EDL_WORKSPACE_14;
	/*   96 */	IUH EDL_WORKSPACE_15;
	/*  100 */	IUH EDL_WORKSPACE_16;
	/*  104 */	IUH EDL_WORKSPACE_17;
	/*  108 */	IUH EDL_WORKSPACE_18;
	/*  112 */	IUH EDL_WORKSPACE_19;
	/*  116 */	IUH EDL_WORKSPACE_20;
	/*  120 */	IUH EDL_WORKSPACE_21;
	/*  124 */	IUH EDL_WORKSPACE_22;
	/*  128 */	IUH EDL_WORKSPACE_23;
	/*  132 */	IUH EDL_WORKSPACE_24;
	/*  136 */	IUH EDL_WORKSPACE_25;
	/*  140 */	IUH EDL_WORKSPACE_26;
	/*  144 */	IUH EDL_WORKSPACE_27;
	/*  148 */	IUH EDL_WORKSPACE_28;
	/*  152 */	IUH EDL_WORKSPACE_29;
	/*  156 */	IUH EDL_WORKSPACE_30;
	/*  160 */	IUH EDL_WORKSPACE_31;
	/*  164 */	IUH R_EAX;
	/*  168 */	IUH R_EBX;
	/*  172 */	IUH R_ECX;
	/*  176 */	IUH R_EDX;
	/*  180 */	IUH R_EBP;
	/*  184 */	IUH R_ESI;
	/*  188 */	IUH R_EDI;
	/*  192 */	IUH EsSel;
	/*  196 */	IU32 EsBase;
	/*  200 */	struct GLDC_REC* EsDesc;
	/*  204 */	IU32 EsStruct_rlimit;
	/*  208 */	IU32 EsStruct_wlimit;
	/*  212 */	struct GLDC_REC* EsDescSanctuary;
	/*  216 */	IUH CsSel;
	/*  220 */	IU32 CsBase;
	/*  224 */	struct GLDC_REC* CsDesc;
	/*  228 */	IU32 CsStruct_rlimit;
	/*  232 */	IU32 CsStruct_wlimit;
	/*  236 */	struct GLDC_REC* CsDescSanctuary;
	/*  240 */	IUH SsSel;
	/*  244 */	IU32 SsBase;
	/*  248 */	struct GLDC_REC* SsDesc;
	/*  252 */	IU32 SsStruct_rlimit;
	/*  256 */	IU32 SsStruct_wlimit;
	/*  260 */	struct GLDC_REC* SsDescSanctuary;
	/*  264 */	IUH DsSel;
	/*  268 */	IU32 DsBase;
	/*  272 */	struct GLDC_REC* DsDesc;
	/*  276 */	IU32 DsStruct_rlimit;
	/*  280 */	IU32 DsStruct_wlimit;
	/*  284 */	struct GLDC_REC* DsDescSanctuary;
	/*  288 */	IUH FsSel;
	/*  292 */	IU32 FsBase;
	/*  296 */	struct GLDC_REC* FsDesc;
	/*  300 */	IU32 FsStruct_rlimit;
	/*  304 */	IU32 FsStruct_wlimit;
	/*  308 */	struct GLDC_REC* FsDescSanctuary;
	/*  312 */	IUH GsSel;
	/*  316 */	IU32 GsBase;
	/*  320 */	struct GLDC_REC* GsDesc;
	/*  324 */	IU32 GsStruct_rlimit;
	/*  328 */	IU32 GsStruct_wlimit;
	/*  332 */	struct GLDC_REC* GsDescSanctuary;
	/*  336 */	IUH CPL;
	/*  340 */	IU32 GdtrBase;
	/*  344 */	IUH GdtrLimit;
	/*  348 */	IUH LdtSel;
	/*  352 */	IU32 LdtrBase;
	/*  356 */	IU32 LdtrLimit;
	/*  360 */	IUH TrSel;
	/*  364 */	IU32 TrBase;
	/*  368 */	IU32 TrLimit;
	/*  372 */	IUH TrDescSt;
	/*  376 */	IU32 TrIoBase;
	/*  380 */	IS32 TrIoLimit;
	/*  384 */	IU32 IdtrBase;
	/*  388 */	IUH IdtrLimit;
	/*  392 */	IUH AbortPigRun;
	/*  396 */	IUH RegsAndFlagsUndefined;
	/*  400 */	IUH SigalrmOccurred;
	/*  404 */	IUH PigEnabled;
	/*  408 */	IUH EFLAGS;
	/*  412 */	IUH Ft;
	/*  416 */	IUH F1;
	/*  420 */	IUH F2;
	/*  424 */	IUH F3;
	/*  428 */	IUH R_CR0;
	/*  432 */	IUH R_CR1;
	/*  436 */	IUH R_CR2;
	/*  440 */	IUH R_CR3;
	/*  444 */	IUH R_CR4;
	/*  448 */	IUH R_CR5;
	/*  452 */	IUH R_CR6;
	/*  456 */	IUH R_CR7;
	/*  460 */	IUH R_TR0;
	/*  464 */	IUH R_TR1;
	/*  468 */	IUH R_TR2;
	/*  472 */	IUH R_TR3;
	/*  476 */	IUH R_TR4;
	/*  480 */	IUH R_TR5;
	/*  484 */	IUH R_TR6;
	/*  488 */	IUH R_TR7;
	/*  492 */	IUH R_DR0;
	/*  496 */	IUH R_DR1;
	/*  500 */	IUH R_DR2;
	/*  504 */	IUH R_DR3;
	/*  508 */	IUH R_DR4;
	/*  512 */	IUH R_DR5;
	/*  516 */	IUH R_DR6;
	/*  520 */	IUH R_DR7;
	/*  524 */	IUH PARAM1;
	/*  528 */	IUH PARAM2;
	/*  532 */	IUH PARAM3;
	/*  536 */	IU8* BytePtr;
	/*  540 */	IU16* WordPtr;
	/*  544 */	IU32* DwordPtr;
	/*  548 */	IUH EaOffs;
	/*  552 */	IUH DATA1;
	/*  556 */	IUH DATA2;
	/*  560 */	IUH InNanoCpu;
	/*  564 */	IUH UseNanoCpu;
	/*  568 */	IUH UseLightCompiler;
	/*  572 */	IUH UseCCodeCopier;
	/*  576 */	IUH seenWithFlags;
	/*  580 */	IUH needNextIntelEip;
	/*  584 */	struct EntryPointCacheREC* LastSetCopierUniverse;
	/*  588 */	struct EntryPointCacheREC* CopierUniverse;
	/*  592 */	struct ConstraintBitMapREC* CopierBitMap;
	/*  596 */	struct ConstraintBitMapREC* lastCopierBitMap;
	/*  600 */	struct FragmentInfoREC* currPFragInfoRec;
	/*  604 */	IU8* copierCleanups;
	/*  608 */	IU8* lastHostCleanup;
	/*  612 */	IU32* lastHostAddress;
	/*  616 */	IU32 lastIntelAddress;
	/*  620 */	struct JUMP_REC** destHashTable;
	/*  624 */	struct JUMP_REC** jumpHashTable;
	/*  628 */	struct JUMP_REC* freeJumpRecPtr;
	/*  632 */	struct JUMP_REC* nextFreeJumpRec;
	/*  636 */	IU32 freeJumpRecCount;
	/*  640 */	IU32 poolJumpRecCount;
	/*  644 */	struct VCT_NODE_REC** vctPtrs;
	/*  648 */	struct VCT_NODE_REC** anonPtrs;
	/*  652 */	struct TUPLE_REC* tuples;
	/*  656 */	struct TUPLE_REC* cursor;
	/*  660 */	struct TUPLE_REC* tuplePtr;
	/*  664 */	IU8* patchRecPtr;
	/*  668 */	IU32* srcPtr;
	/*  672 */	IU32* dstPtr;
	/*  676 */	IU32* PatchMeBodyAddr;
	/*  680 */	IU32** patchTable;
	/*  684 */	IU8** patchNames;
	/*  688 */	IUH CopierFt;
	/*  692 */	IUH FtIsLazy;
	/*  696 */	IUH lastLazyFt;
	/*  700 */	IU32 univVarMask;
	/*  704 */	IUH zCoRoRetEFI;
	/*  708 */	IUH zPatchMeEFI;
	/*  712 */	IUH zPostPopEFI;
	/*  716 */	IUH zAdjustHspEFI;
	/*  720 */	ISH cumulativeStackMovement;
	/*  724 */	IUH lastInstructionInFragment;
	/*  728 */	IUH lateInInstruction;
	/*  732 */	IUH ReSelectVariant;
	/*  736 */	ISH ReSelectTupleSkipCnt;
	/*  740 */	IUH postPopPending;
	/*  744 */	IU32 postPopSize;
	/*  748 */	IU32 compTimeFtBitNum;
	/*  752 */	IU32 accIsReadBitMask;
	/*  756 */	IU32 noFlagsBitMask;
	/*  760 */	IU32* OutlyingDispatchEIPAddr;
	/*  764 */	IU32 PARAM1RegId;
	/*  768 */	IUH stashedImmed1;
	/*  772 */	IUH stashedImmed2;
	/*  776 */	IUH stashedImmed3;
	/*  780 */	IUH stashedImmed4;
	/*  784 */	IUH stashedImmed5;
	/*  788 */	IUH EDL_WORKSPACE_32;
	/*  792 */	IUH EDL_WORKSPACE_33;
	/*  796 */	IUH EDL_WORKSPACE_34;
	/*  800 */	struct CleanedREC CleanedRec;
	/*  820 */	struct EntryPointCacheREC* Universe;
	/*  824 */	struct EntryPointCacheREC* EntryPointCache;
	/*  828 */	IU32 CsLinear;
	/*  832 */	ISH JumpCounter;
	/*  836 */	ISH JumpRestart;
	/*  840 */	ISH JumpCalibrate;
	/*  844 */	ISH InitialJumpCounter;
	/*  848 */	IUH minimumInitialVal;
	/*  852 */	struct IretHookStackREC* IretHookStack;
	/*  856 */	ISH IretHookStackIndex;
	/*  860 */	IUH InstructionCount;
	/*  864 */	struct CsSelectorHashREC* CsSelectorHashTable;
	/*  868 */	IUH NextFreeUniverseHandle;
	/*  872 */	struct UniHashREC* UniHashTable;
	/*  876 */	struct UniHashREC* NextFreeUniHashEntry;
	/*  880 */	struct ConstraintBitMapREC NewUniverseBitMapRec;
	/*  888 */	IU32* Constraint2CvMap;
	/*  892 */	IUH InsertBPIs;
	/*  896 */	IUH UseUniverseHash;
	/*  900 */	IUH VirtualiseDataSel;
	/*  904 */	IUH VirtualiseCodeSel;
	/*  908 */	IUH VirtualiseSelsSet;
	/*  912 */	IUH EDL_WORKSPACE_35;
	/*  916 */	IUH EDL_WORKSPACE_36;
	/*  920 */	IUH EDL_WORKSPACE_37;
	/*  924 */	IUH EDL_WORKSPACE_38;
	/*  928 */	struct TraceRingREC TraceRingRec;
	/*  948 */	IUH EAXsaved;
	/*  952 */	IUH EBXsaved;
	/*  956 */	IUH ECXsaved;
	/*  960 */	IUH EDXsaved;
	/*  964 */	IUH ESIsaved;
	/*  968 */	IUH EDIsaved;
	/*  972 */	IUH EBPsaved;
	/*  976 */	IUH SafeToReturnToFragment;
	/*  980 */	IUH InsideTheCpu;
	/*  984 */	IUH* SimulateContext;
	/*  988 */	IUH SimulateNestingLevel;
	/*  992 */	IUH Pigging;
	/*  996 */	IU32 tempEIP;
	/* 1000 */	IUH UseEntryPointCache;
	/* 1004 */	IUH CpuIsInitialised;
	/* 1008 */	IUH AR_FixupWanted;
	/* 1012 */	IUH D6isBop;
	/* 1016 */	IU8** BopTable;
	/* 1020 */	IUH LxS_hackyfix;
	/* 1024 */	IUH SavedFt;
	/* 1028 */	IUH SavedCF;
	/* 1032 */	IUH SavedZF;
	/* 1036 */	IUH SavedOF;
	/* 1040 */	IUH UsedD6;
	/* 1044 */	IUH buildOp1;
	/* 1048 */	IUH buildOp2;
	/* 1052 */	IU32 buildOp3;
	/* 1056 */	IU32 buildOp4;
	/* 1060 */	IUH buildOp5;
	/* 1064 */	IUH buildOp6;
	/* 1068 */	IUH EDL_WORKSPACE_39;
	/* 1072 */	IUH EDL_WORKSPACE_40;
	/* 1076 */	IUH EDL_WORKSPACE_41;
	/* 1080 */	IUH EDL_WORKSPACE_42;
	/* 1084 */	IUH EDL_WORKSPACE_43;
	/* 1088 */	IUH EDL_WORKSPACE_44;
	/* 1092 */	IUH EDL_WORKSPACE_45;
	/* 1096 */	IUH EDL_WORKSPACE_46;
	/* 1100 */	IUH EDL_WORKSPACE_47;
	/* 1104 */	IUH EDL_WORKSPACE_48;
	/* 1108 */	IUH EDL_WORKSPACE_49;
	/* 1112 */	IUH EDL_WORKSPACE_50;
	/* 1116 */	IUH EDL_WORKSPACE_51;
	/* 1120 */	IUH EDL_WORKSPACE_52;
	/* 1124 */	IUH EDL_WORKSPACE_53;
	/* 1128 */	IUH EDL_WORKSPACE_54;
	/* 1132 */	IUH EDL_WORKSPACE_55;
	/* 1136 */	IUH EDL_WORKSPACE_56;
	/* 1140 */	IUH EDL_WORKSPACE_57;
	/* 1144 */	IUH EDL_WORKSPACE_58;
	/* 1148 */	IUH EDL_WORKSPACE_59;
	/* 1152 */	IUH EDL_WORKSPACE_60;
	/* 1156 */	IUH EDL_WORKSPACE_61;
	/* 1160 */	IUH EDL_WORKSPACE_62;
	/* 1164 */	IUH EDL_WORKSPACE_63;
	/* 1168 */	IUH EDL_WORKSPACE_64;
	/* 1172 */	IUH EDL_WORKSPACE_65;
	/* 1176 */	IUH EDL_WORKSPACE_66;
	/* 1180 */	IUH EDL_WORKSPACE_67;
	/* 1184 */	IUH EDL_WORKSPACE_68;
	/* 1188 */	IUH EDL_WORKSPACE_69;
	/* 1192 */	IUH EDL_WORKSPACE_70;
	/* 1196 */	IUH EDL_WORKSPACE_71;
	/* 1200 */	IUH EDL_WORKSPACE_72;
	/* 1204 */	IUH EDL_WORKSPACE_73;
	/* 1208 */	IUH EDL_WORKSPACE_74;
	/* 1212 */	IUH EDL_WORKSPACE_75;
	/* 1216 */	IUH EDL_WORKSPACE_76;
	/* 1220 */	IUH EDL_WORKSPACE_77;
	/* 1224 */	IUH EDL_WORKSPACE_78;
	/* 1228 */	IUH EDL_WORKSPACE_79;
	/* 1232 */	IUH EDL_WORKSPACE_80;
	/* 1236 */	IUH EDL_WORKSPACE_81;
	/* 1240 */	IUH EDL_WORKSPACE_82;
	/* 1244 */	IUH EDL_WORKSPACE_83;
	/* 1248 */	IUH EDL_WORKSPACE_84;
	/* 1252 */	IUH EDL_WORKSPACE_85;
	/* 1256 */	IUH EDL_WORKSPACE_86;
	/* 1260 */	IUH EDL_WORKSPACE_87;
	/* 1264 */	IUH EDL_WORKSPACE_88;
	/* 1268 */	IUH EDL_WORKSPACE_89;
	/* 1272 */	IUH EDL_WORKSPACE_90;
	/* 1276 */	IUH EDL_WORKSPACE_91;
	/* 1280 */	struct VGAGLOBALSETTINGS VGAGlobals;
	/* 1436 */	IUH** VidMarkFuncTable;
	/* 1440 */	IUH** VidReadFuncTable;
	/* 1444 */	IUH** VidWriteFuncTable;
	/* 1448 */	IUH EDL_WORKSPACE_92;
	/* 1452 */	IUH EDL_WORKSPACE_93;
	/* 1456 */	IUH EDL_WORKSPACE_94;
	/* 1460 */	IUH EDL_WORKSPACE_95;
	/* 1464 */	IUH EDL_WORKSPACE_96;
	/* 1468 */	IUH EDL_WORKSPACE_97;
	/* 1472 */	struct EVIDWRITES ActiveVideoWrites;
	/* 1520 */	IUH EDL_WORKSPACE_98;
	/* 1524 */	IUH EDL_WORKSPACE_99;
	/* 1528 */	IUH EDL_WORKSPACE_100;
	/* 1532 */	IUH EDL_WORKSPACE_101;
	/* 1536 */	struct EVIDREADS ActiveVideoReads;
	/* 1556 */	IUH EDL_WORKSPACE_102;
	/* 1560 */	IUH EDL_WORKSPACE_103;
	/* 1564 */	IUH EDL_WORKSPACE_104;
	/* 1568 */	struct EVIDMARKS ActiveVideoMarks;
	/* 1584 */	IU32 MaxIntelPageNumber;
	/* 1588 */	IU32* PageDirectoryPtr;
	/* 1592 */	IU32 DebuggerPFLA;
	/* 1596 */	IUH DebuggerFaultAction;
	/* 1600 */	ISH InsideDebugger;
	/* 1604 */	IUH EDL_WORKSPACE_105;
	/* 1608 */	IUH EDL_WORKSPACE_106;
	/* 1612 */	IUH EDL_WORKSPACE_107;
	/* 1616 */	IUH EDL_WORKSPACE_108;
	/* 1620 */	IUH EDL_WORKSPACE_109;
	/* 1624 */	IUH EDL_WORKSPACE_110;
	/* 1628 */	IUH EDL_WORKSPACE_111;
	/* 1632 */	IUH EDL_WORKSPACE_112;
	/* 1636 */	IUH EDL_WORKSPACE_113;
	/* 1640 */	IUH EDL_WORKSPACE_114;
	/* 1644 */	IUH EDL_WORKSPACE_115;
	/* 1648 */	IUH EDL_WORKSPACE_116;
	/* 1652 */	IUH EDL_WORKSPACE_117;
	/* 1656 */	IUH EDL_WORKSPACE_118;
	/* 1660 */	IUH EDL_WORKSPACE_119;
	/* 1664 */	struct VirtualisationBIOSOffsetsREC VirtualisationBIOSOffsets;
	/* 1712 */	struct DelayedPDTEoverwiteREC* DelayedPDTEoverwiteList;
	/* 1716 */	IU8* SasMemoryType;
	/* 1720 */	struct PhysicalPageREC* PhysicalPageRecords;
	/* 1724 */	IU8** PhysicalPageMemory;
	/* 1728 */	IUH TwentyBitWrapStatus;
	/* 1732 */	IUH MultipleRecompilationCount;
	/* 1736 */	IUH MaxMultipleRecompilation;
	/* 1740 */	IUH HideCompiledFragment;
	/* 1744 */	IUH RestartAfterCodeOverwrite;
	/* 1748 */	IUH DoingCompilation;
	/* 1752 */	IUH SanityCheckStructures;
	/* 1756 */	IU8* FragCounts;
	/* 1760 */	struct CompilationControlREC ControlBlock;
	/* 1776 */	IUH EDL_WORKSPACE_120;
	/* 1780 */	IUH EDL_WORKSPACE_121;
	/* 1784 */	IUH EDL_WORKSPACE_122;
	/* 1788 */	IUH EDL_WORKSPACE_123;
	/* 1792 */	struct BLOCK_TO_COMPILE CompilationBlock;
	/* 1824 */	IUH EDL_WORKSPACE_124;
	/* 1828 */	IUH EDL_WORKSPACE_125;
	/* 1832 */	IUH EDL_WORKSPACE_126;
	/* 1836 */	IUH EDL_WORKSPACE_127;
	/* 1840 */	IUH EDL_WORKSPACE_128;
	/* 1844 */	IUH EDL_WORKSPACE_129;
	/* 1848 */	IUH EDL_WORKSPACE_130;
	/* 1852 */	IUH EDL_WORKSPACE_131;
	/* 1856 */	IUH EDL_WORKSPACE_132;
	/* 1860 */	IUH EDL_WORKSPACE_133;
	/* 1864 */	IUH EDL_WORKSPACE_134;
	/* 1868 */	IUH EDL_WORKSPACE_135;
	/* 1872 */	IUH EDL_WORKSPACE_136;
	/* 1876 */	IUH EDL_WORKSPACE_137;
	/* 1880 */	IUH EDL_WORKSPACE_138;
	/* 1884 */	IUH EDL_WORKSPACE_139;
	/* 1888 */	IUH EDL_WORKSPACE_140;
	/* 1892 */	IUH EDL_WORKSPACE_141;
	/* 1896 */	IUH EDL_WORKSPACE_142;
	/* 1900 */	IUH EDL_WORKSPACE_143;
	/* 1904 */	IUH EDL_WORKSPACE_144;
	/* 1908 */	IUH EDL_WORKSPACE_145;
	/* 1912 */	IUH EDL_WORKSPACE_146;
	/* 1916 */	IUH EDL_WORKSPACE_147;
	/* 1920 */	struct ProtAllocationREC ProtAllocationRec;
	/* 2016 */	struct BufferIndexREC* LightCompiledLRUrec;
	/* 2020 */	IUH NextPhysicalPage;
	/* 2024 */	struct TranslationMapREC* FreeMaps;
	/* 2028 */	struct TranslationCacheREC* TranslationCache;
	/* 2032 */	IU8* CrossPageInstructions;
	/* 2036 */	IU32 IHook;
	/* 2040 */	struct InterruptREC InterruptRec;
	/* 2048 */	IUH SasReInitNow;
	/* 2052 */	IU32 SasReInitSize;
	/* 2056 */	IUH EDL_WORKSPACE_148;
	/* 2060 */	IUH EDL_WORKSPACE_149;
	/* 2064 */	IUH EDL_WORKSPACE_150;
	/* 2068 */	IUH EDL_WORKSPACE_151;
	/* 2072 */	IUH EDL_WORKSPACE_152;
	/* 2076 */	IUH EDL_WORKSPACE_153;
	/* 2080 */	struct QuickTickerREC QuickTickerRec;
	/* 2104 */	IUH PigSynchCount;
	/* 2108 */	IUH CodeBufferNoRepair;
	/* 2112 */	IU32* OutLinePatchBlock;
	/* 2116 */	IU32 OutLinePatchBlockSize;
	/* 2120 */	struct BufferIndexREC* AllBuffers;
	/* 2124 */	struct BufferIndexREC* LightBufferLRU;
	/* 2128 */	struct BufferIndexREC* CompilationBuffer;
	/* 2132 */	struct BufferIndexREC* PendingDeletions;
	/* 2136 */	struct FragmentInfoREC* FragmentInfoArray;
	/* 2140 */	IU32* HostCodeBufferLimit;
	/* 2144 */	IU8* CopiedCleanups;
	/* 2148 */	struct DebugInfoREC* FreeDebugInfoList;
	/* 2152 */	IU32* CodeBufferOverrun;
	/* 2156 */	IU32* OverrunHighWaterMark;
	/* 2160 */	IUH NumberOfBuffers;
	/* 2164 */	struct BufferIndexREC* BpiCompilationBuffer;
	/* 2168 */	struct FragmentIndexREC* NextFragmentIndex;
	/* 2172 */	struct FragmentDataREC* NextFragmentData;
	/* 2176 */	IUH FpuDisabled;
	/* 2180 */	IUH NpxControl;
	/* 2184 */	IUH NpxStatus;
	/* 2188 */	IUH NpxFEA;
	/* 2192 */	IUH NpxFDS;
	/* 2196 */	IUH NpxFIP;
	/* 2200 */	IUH NpxFOP;
	/* 2204 */	IUH NpxFCS;
	/* 2208 */	IUH NpxLastSel;
	/* 2212 */	IUH NpxLastOff;
	/* 2216 */	IUH DoAPop;
	/* 2220 */	IUH NpxException;
	/* 2224 */	IUH npxRounding;
	/* 2228 */	IUH tag_or;
	/* 2232 */	IUH tag_xor;
	/* 2236 */	IUH hostFpuExceptions;
	/* 2240 */	struct FPSTACKENTRY MaxBCDValue;
	/* 2256 */	struct FPSTACKENTRY FPUpload;
	/* 2272 */	struct FPSTACKENTRY* ConstTable;
	/* 2276 */	struct FPSTACKENTRY* FPTemp;
	/* 2280 */	struct FPSTACKENTRY* FPUStackBase;
	/* 2284 */	struct FPSTACKENTRY* TOSPtr;
	/* 2288 */	struct FP_I64 Npx64BitZero;
	/* 2296 */	struct FP_I64 Npx64BitMaxNeg;
	/* 2304 */	struct FP_I64 Npx64BitHalfMaxNeg;
	/* 2312 */	struct FP_I64 Npx64BitVal1;
	/* 2320 */	IUH* FscaleTable;
	/* 2324 */	IU32* CompZeroTable;
	/* 2328 */	struct FP_I64* BCDLowNibble;
	/* 2332 */	struct FP_I64* BCDHighNibble;
	/* 2336 */	struct FPSTACKENTRY* FpatanTable;
	/* 2340 */	struct PigSynchREC* PigSynchTable;
	/* 2344 */	struct PigSynchREC* PigMissTable;
	/* 2348 */	struct PigSynchREC* PigSynchPool;
	/* 2352 */	IUH EDL_WORKSPACE_154;
	/* 2356 */	IUH EDL_WORKSPACE_155;
	/* 2360 */	IUH EDL_WORKSPACE_156;
	/* 2364 */	IUH EDL_WORKSPACE_157;
	/* 2368 */	struct CleanedREC PigCleanedRec;
	/* 2388 */	IUH PigSynchWanted;
	/* 2392 */	ISH SadAX;
	/* 2396 */	ISH SadBX;
	/* 2400 */	ISH SadCX;
	/* 2404 */	ISH SadDX;
	/* 2408 */	ISH SadBP;
	/* 2412 */	ISH SadSP;
	/* 2416 */	ISH SadSI;
	/* 2420 */	ISH SadDI;
	/* 2424 */	ISH SadEIP;
	/* 2428 */	ISH SadEFLAGS;
	/* 2432 */	ISH Parameter1;
	/* 2436 */	ISH Parameter2;
	/* 2440 */	ISH* BpiKnownTable;
	/* 2444 */	ISH* BpiWorkTable;
	/* 2448 */	ISH* BpiLabelTable;
	/* 2452 */	struct FragmentDataREC* BpiFragment;
	/* 2456 */	IU32* BpiCompiledCode;
	/* 2460 */	IU32* BpiCompiledStep;
	/* 2464 */	IU32* BpiCompiledUser;
	/* 2468 */	IUH OpBpirealFt;
	/* 2472 */	IUH OpBpirealF1;
	/* 2476 */	IUH OpBpirealF2;
	/* 2480 */	IUH OpBpirealF3;
	/* 2484 */	struct EntryPointCacheREC* OpBpirealUniv;
	/* 2488 */	IU32* OpBpirealWhereAmI;
	/* 2492 */	IUH EDL_WORKSPACE_158;
	/* 2496 */	IUH EDL_WORKSPACE_159;
	/* 2500 */	IUH EDL_WORKSPACE_160;
	/* 2504 */	IUH EDL_WORKSPACE_161;
	/* 2508 */	IUH EDL_WORKSPACE_162;
	/* 2512 */	IUH EDL_WORKSPACE_163;
	/* 2516 */	IUH EDL_WORKSPACE_164;
	/* 2520 */	IUH EDL_WORKSPACE_165;
	/* 2524 */	IUH EDL_WORKSPACE_166;
	/* 2528 */	IUH EDL_WORKSPACE_167;
	/* 2532 */	IUH EDL_WORKSPACE_168;
	/* 2536 */	IUH EDL_WORKSPACE_169;
	/* 2540 */	IUH EDL_WORKSPACE_170;
	/* 2544 */	IUH EDL_WORKSPACE_171;
	/* 2548 */	IUH EDL_WORKSPACE_172;
	/* 2552 */	IUH EDL_WORKSPACE_173;
	/* 2556 */	IUH EDL_WORKSPACE_174;
	/* 2560 */	struct OpndBuffREC NpxOpndBuff;
	/* 2688 */	struct GLDC_REC* GLDC_FreeRecs;
	/* 2692 */	struct GLDC_REC* GLDC_UsedBuffs;
	/* 2696 */	struct GLDC_REC* GLDC_FreeBuffs;
	/* 2700 */	IUH* NewRingOffsetPtr;
	/* 2704 */	IUH GLDC_Index_High_Water;
	/* 2708 */	IUH GLDC_Context_High_Water;
	/* 2712 */	struct GLDC_REC** GLDC_IndexPtr;
	/* 2716 */	IUH* GLDC_CrBase;
	/* 2720 */	IUH EDL_WORKSPACE_175;
	/* 2724 */	IUH EDL_WORKSPACE_176;
	/* 2728 */	IUH EDL_WORKSPACE_177;
	/* 2732 */	IUH EDL_WORKSPACE_178;
	/* 2736 */	IUH EDL_WORKSPACE_179;
	/* 2740 */	IUH EDL_WORKSPACE_180;
	/* 2744 */	IUH EDL_WORKSPACE_181;
	/* 2748 */	IUH EDL_WORKSPACE_182;
	/* 2752 */	struct GLDC_REC GLDC_DUMMY_STORE;
	/* 2792 */	IUH EDL_WORKSPACE_183;
	/* 2796 */	IUH EDL_WORKSPACE_184;
	/* 2800 */	IUH EDL_WORKSPACE_185;
	/* 2804 */	IUH EDL_WORKSPACE_186;
	/* 2808 */	IUH EDL_WORKSPACE_187;
	/* 2812 */	IUH EDL_WORKSPACE_188;
	/* 2816 */	struct GLDC_REC GLDC_NULL_STORE;
	/* 2856 */	IUH hackyfix;
	/* 2860 */	struct IDC_REC* IDC_ArrayPtr;
	/* 2864 */	struct IDC_ENTRY* IDC_EntryTableBase;
	/* 2868 */	IUH IDC_IdtSeqVal;
	/* 2872 */	IUH IDC_IdtHighWater;
	/* 2876 */	IUH IDC_IdtCntrlVal;
	/* 2880 */	IUH IDC_IdtCntrlValNoCheck;
	/* 2884 */	IUH PX_trace;
	/* 2888 */	IUH PX_doing_contributory;
	/* 2892 */	IUH PX_doing_page_fault;
	/* 2896 */	IUH PX_doing_double_fault;
	/* 2900 */	IUH PX_doing_fault;
	/* 2904 */	IUH PX_source;
	/* 2908 */	IUH RF_OnXcptnWanted;
	/* 2912 */	IU32 PX_Cleaned_Eip;
	/* 2916 */	IUH** CInbTable;
	/* 2920 */	IUH** CInwTable;
	/* 2924 */	IUH** CIndTable;
	/* 2928 */	IUH** COutbTable;
	/* 2932 */	IUH** COutwTable;
	/* 2936 */	IUH** COutdTable;
	/* 2940 */	IU8* InAdapFromPort;
	/* 2944 */	IU8* OutAdapFromPort;
	/* 2948 */	IUH** InbFuncWrapper;
	/* 2952 */	IUH** InwFuncWrapper;
	/* 2956 */	IUH** IndFuncWrapper;
	/* 2960 */	IUH** OutbFuncWrapper;
	/* 2964 */	IUH** OutwFuncWrapper;
	/* 2968 */	IUH** OutdFuncWrapper;
	/* 2972 */	IUH TempByteDest;
	/* 2976 */	IUH TempWordDest;
	/* 2980 */	IU32 TempDoubleDest;
	/* 2984 */	IUH MaxValidAdaptor;
	/* 2988 */	IUH IOSPortMask;
	/* 2992 */	IUH EDL_WORKSPACE_189;
	/* 2996 */	IUH EDL_WORKSPACE_190;
	/* 3000 */	IUH EDL_WORKSPACE_191;
	/* 3004 */	IUH EDL_WORKSPACE_192;
	/* 3008 */	struct DYNAMIC_DESC_PTR_LOOKUP SegDescPtrLookupREC;
	/* 3032 */	IUH EDL_WORKSPACE_193;
	/* 3036 */	IUH EDL_WORKSPACE_194;
	/* 3040 */	struct DYNAMIC_SEG_BASE_LOOKUP SegBaseLookupREC;
	/* 3064 */	IU8* HSP;
	/* 3068 */	IU32 ESPsanctuary;
	/* 3072 */	IU8* truePopLimit;
	/* 3076 */	IU8* innerPopLimit;
	/* 3080 */	IU8* truePushLimit;
	/* 3084 */	IU8* innerPushLimit;
	/* 3088 */	IU8* notionalSsBase;
	/* 3092 */	IUH stackIsWrappable;
	/* 3096 */	IUH stackIsBig;
	/* 3100 */	IU32 stackMask;
	/* 3104 */	IUH stackNeedsNormalising;
	/* 3108 */	IU32 laInTopPage;
	/* 3112 */	IU32 laInBottomPage;
	/* 3116 */	IUH hspOK;
	/* 3120 */	IU8* pushScratch;
	/* 3124 */	IUH pushScratchInUse;
	/* 3128 */	IU8* popScratch;
	/* 3132 */	IUH popScratchInUse;
	/* 3136 */	ISH stackJumpCounterCeiling;
	/* 3140 */	ISH stackJumpCounterDebt;
	/* 3144 */	ISH prevJumpCounter;
	/* 3148 */	IUH SafeStackEnabled;
	/* 3152 */	IUH SafeStackIronFrig;
	/* 3156 */	IU32 newNanoSafeLow;
	/* 3160 */	IU32 newNanoSafeSpan;
	/* 3164 */	IU8* newHSP;
	/* 3168 */	IU8* newTruePopLimit;
	/* 3172 */	IU8* newTruePushLimit;
	/* 3176 */	IU8* newNotionalSsBase;
	/* 3180 */	IUH newStackIsWrappable;
	/* 3184 */	IUH newStackIsBig;
	/* 3188 */	IU32 newStackMask;
	/* 3192 */	IU32 newLaInBottomPage;
	/* 3196 */	IUH newHspOK;
	/* 3200 */	IU8* newPushScratch;
	/* 3204 */	IUH newPushScratchInUse;
	/* 3208 */	IU8* EOIEnable;
	/* 3212 */	IUH* AddProfilePtr;
	/* 3216 */	IUH* MaxProfileData;
	/* 3220 */	struct ContextREC* FreeContextHead;
	/* 3224 */	struct ContextREC* ValidContextHead;
	/* 3228 */	IUH CurrentContext;
	/* 3232 */	IUH SeenGDTUse;
	/* 3236 */	IUH SeenLDTUse;
	/* 3240 */	struct ContextREC* Context;
	/* 3244 */	IUH tmpESP;
	/* 3248 */	IU8* intelPtr;
	/* 3252 */	IU32** functions;
	/* 3256 */	ISH instrCountdown;
	/* 3260 */	IU32* nextPlace;
	/* 3264 */	IUH cutBackStackCounter;
	/* 3268 */	IUH nanoCompParameter;
	/* 3272 */	IU8* intelCopyPtrComp;
	/* 3276 */	IUH nrOfBlocksToCompile;
	/* 3280 */	IU32 first32constraints;
	/* 3284 */	IUH last16constraints;
	/* 3288 */	struct BLOCK_RECORD* successorBlockPtr;
	/* 3292 */	IUH successorBlockNr;
	/* 3296 */	IUH nrOfInstrsParsed;
	/* 3300 */	IU8* intelPtrLimit;
	/* 3304 */	IU8* blockStartIntelPtr;
	/* 3308 */	IUH blockStartCodeOffset;
	/* 3312 */	IUH finalCodeOffset;
	/* 3316 */	IUH blockExitCondition;
	/* 3320 */	IUH blockNr;
	/* 3324 */	struct BLOCK_RECORD* blockPtr;
	/* 3328 */	IU32* nextPlaceAgain;
	/* 3332 */	IUH nanoOp3;
	/* 3336 */	IUH sibByte;
	/* 3340 */	IU32 dynamicOffset;
	/* 3344 */	IUH eaSegCode;
	/* 3348 */	IU8* instrStartIntelPtr;
	/* 3352 */	IUH* topLevel;
	/* 3356 */	IU32** defaultPrimaryActions;
	/* 3360 */	IU32** actualPrimaryActions;
	/* 3364 */	IUH codeSegment;
	/* 3368 */	IUH codeOffset;
	/* 3372 */	IUH codeSegmentBase;
	/* 3376 */	IUH codeSegmentLimit;
	/* 3380 */	IUH destCodeSegment;
	/* 3384 */	IUH destCodeOffset;
	/* 3388 */	IU32 linearAddress;
	/* 3392 */	IU32 nanoEax;
	/* 3396 */	IU32 nanoEcx;
	/* 3400 */	IU32 nanoEdx;
	/* 3404 */	IU32 nanoEbx;
	/* 3408 */	IU32 nanoEsp;
	/* 3412 */	IU32 nanoEbp;
	/* 3416 */	IU32 nanoEsi;
	/* 3420 */	IU32 nanoEdi;
	/* 3424 */	IU32 espToRestore;
	/* 3428 */	IU32 entryExitCount;
	/* 3432 */	IU32 instructionCount;
	/* 3436 */	IU32 nanoDebugControl;
	/* 3440 */	IU32 compilationThreshold;
	/* 3444 */	IUH hashTableMask;
	/* 3448 */	IUH blockFreeList;
	/* 3452 */	IUH maxBlocksToCompile;
	/* 3456 */	IU32* bases;
	/* 3460 */	struct GLDC_REC** descriptors;
	/* 3464 */	struct BLOCK_TO_COMPILE* blocksToCompile;
	/* 3468 */	IU8* byteMemory;
	/* 3472 */	IU16* wordMemory;
	/* 3476 */	IU32* longMemory;
	/* 3480 */	IU16* blockHashChains;
	/* 3484 */	struct BLOCK_RECORD* blockRecords;
	/* 3488 */	IU8* intelCopyMemoryExec;
	/* 3492 */	IU8* intelCopyMemoryComp;
	/* 3496 */	IU8* intelCopyMemoryCompEnd;
	/* 3500 */	IUH SfDecrementerVal;
	/* 3504 */	IUH SfQEventPending;
	/* 3508 */	IU8* LogicalBaseAddrForIO;
};
#endif /* _gdebug_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\gicvid_c.h ===
#ifndef _Gicvid_c_h
#define _Gicvid_c_h
#endif /* ! _Gicvid_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\gdpvar.h ===
#ifndef _gdpvar_h
#define _gdpvar_h
#define GLOBAL_HookNumber (*(IUH *)((IUH)Gdp + 0))
#define GLOBAL_EfiNumber (*(IUH *)((IUH)Gdp + 4))
#define GLOBAL_SubrRingPtr (*(IUH* *)((IUH)Gdp + 8))
#define GLOBAL_SubrRingLowIncl (*(IUH* *)((IUH)Gdp + 12))
#define GLOBAL_SubrRingHighIncl (*(IUH* *)((IUH)Gdp + 16))
#define GLOBAL_WhichAssertion (*(IUH *)((IUH)Gdp + 20))
#define GLOBAL_WhereAmI (*(IU32* *)((IUH)Gdp + 24))
#define GLOBAL_CoRoRet (*(IUH *)((IUH)Gdp + 28))
#define GLOBAL_ErrorNumber (*(IUH *)((IUH)Gdp + 32))
#define GLOBAL_EDL_WORKSPACE_0 (*(IUH *)((IUH)Gdp + 36))
#define GLOBAL_EDL_WORKSPACE_1 (*(IUH *)((IUH)Gdp + 40))
#define GLOBAL_EDL_WORKSPACE_2 (*(IUH *)((IUH)Gdp + 44))
#define GLOBAL_EDL_WORKSPACE_3 (*(IUH *)((IUH)Gdp + 48))
#define GLOBAL_EDL_WORKSPACE_4 (*(IUH *)((IUH)Gdp + 52))
#define GLOBAL_EDL_WORKSPACE_5 (*(IUH *)((IUH)Gdp + 56))
#define GLOBAL_EDL_WORKSPACE_6 (*(IUH *)((IUH)Gdp + 60))
#define GLOBAL_EDL_WORKSPACE_7 (*(IUH *)((IUH)Gdp + 64))
#define GLOBAL_EDL_WORKSPACE_8 (*(IUH *)((IUH)Gdp + 68))
#define GLOBAL_EDL_WORKSPACE_9 (*(IUH *)((IUH)Gdp + 72))
#define GLOBAL_EDL_WORKSPACE_10 (*(IUH *)((IUH)Gdp + 76))
#define GLOBAL_EDL_WORKSPACE_11 (*(IUH *)((IUH)Gdp + 80))
#define GLOBAL_EDL_WORKSPACE_12 (*(IUH *)((IUH)Gdp + 84))
#define GLOBAL_EDL_WORKSPACE_13 (*(IUH *)((IUH)Gdp + 88))
#define GLOBAL_EDL_WORKSPACE_14 (*(IUH *)((IUH)Gdp + 92))
#define GLOBAL_EDL_WORKSPACE_15 (*(IUH *)((IUH)Gdp + 96))
#define GLOBAL_EDL_WORKSPACE_16 (*(IUH *)((IUH)Gdp + 100))
#define GLOBAL_EDL_WORKSPACE_17 (*(IUH *)((IUH)Gdp + 104))
#define GLOBAL_EDL_WORKSPACE_18 (*(IUH *)((IUH)Gdp + 108))
#define GLOBAL_EDL_WORKSPACE_19 (*(IUH *)((IUH)Gdp + 112))
#define GLOBAL_EDL_WORKSPACE_20 (*(IUH *)((IUH)Gdp + 116))
#define GLOBAL_EDL_WORKSPACE_21 (*(IUH *)((IUH)Gdp + 120))
#define GLOBAL_EDL_WORKSPACE_22 (*(IUH *)((IUH)Gdp + 124))
#define GLOBAL_EDL_WORKSPACE_23 (*(IUH *)((IUH)Gdp + 128))
#define GLOBAL_EDL_WORKSPACE_24 (*(IUH *)((IUH)Gdp + 132))
#define GLOBAL_EDL_WORKSPACE_25 (*(IUH *)((IUH)Gdp + 136))
#define GLOBAL_EDL_WORKSPACE_26 (*(IUH *)((IUH)Gdp + 140))
#define GLOBAL_EDL_WORKSPACE_27 (*(IUH *)((IUH)Gdp + 144))
#define GLOBAL_EDL_WORKSPACE_28 (*(IUH *)((IUH)Gdp + 148))
#define GLOBAL_EDL_WORKSPACE_29 (*(IUH *)((IUH)Gdp + 152))
#define GLOBAL_EDL_WORKSPACE_30 (*(IUH *)((IUH)Gdp + 156))
#define GLOBAL_EDL_WORKSPACE_31 (*(IUH *)((IUH)Gdp + 160))
#define GLOBAL_R_EAX (*(IUH *)((IUH)Gdp + 164))
#define GLOBAL_R_EBX (*(IUH *)((IUH)Gdp + 168))
#define GLOBAL_R_ECX (*(IUH *)((IUH)Gdp + 172))
#define GLOBAL_R_EDX (*(IUH *)((IUH)Gdp + 176))
#define GLOBAL_R_EBP (*(IUH *)((IUH)Gdp + 180))
#define GLOBAL_R_ESI (*(IUH *)((IUH)Gdp + 184))
#define GLOBAL_R_EDI (*(IUH *)((IUH)Gdp + 188))
#define GLOBAL_EsSel (*(IU16 *)((IUH)Gdp + 192 + 2))
#define GLOBAL_EsBase (*(IU32 *)((IUH)Gdp + 196))
#define GLOBAL_EsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 200))
#define GLOBAL_EsStruct_rlimit (*(IU32 *)((IUH)Gdp + 204))
#define GLOBAL_EsStruct_wlimit (*(IU32 *)((IUH)Gdp + 208))
#define GLOBAL_EsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 212))
#define GLOBAL_CsSel (*(IU16 *)((IUH)Gdp + 216 + 2))
#define GLOBAL_CsBase (*(IU32 *)((IUH)Gdp + 220))
#define GLOBAL_CsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 224))
#define GLOBAL_CsStruct_rlimit (*(IU32 *)((IUH)Gdp + 228))
#define GLOBAL_CsStruct_wlimit (*(IU32 *)((IUH)Gdp + 232))
#define GLOBAL_CsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 236))
#define GLOBAL_SsSel (*(IU16 *)((IUH)Gdp + 240 + 2))
#define GLOBAL_SsBase (*(IU32 *)((IUH)Gdp + 244))
#define GLOBAL_SsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 248))
#define GLOBAL_SsStruct_rlimit (*(IU32 *)((IUH)Gdp + 252))
#define GLOBAL_SsStruct_wlimit (*(IU32 *)((IUH)Gdp + 256))
#define GLOBAL_SsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 260))
#define GLOBAL_DsSel (*(IU16 *)((IUH)Gdp + 264 + 2))
#define GLOBAL_DsBase (*(IU32 *)((IUH)Gdp + 268))
#define GLOBAL_DsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 272))
#define GLOBAL_DsStruct_rlimit (*(IU32 *)((IUH)Gdp + 276))
#define GLOBAL_DsStruct_wlimit (*(IU32 *)((IUH)Gdp + 280))
#define GLOBAL_DsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 284))
#define GLOBAL_FsSel (*(IU16 *)((IUH)Gdp + 288 + 2))
#define GLOBAL_FsBase (*(IU32 *)((IUH)Gdp + 292))
#define GLOBAL_FsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 296))
#define GLOBAL_FsStruct_rlimit (*(IU32 *)((IUH)Gdp + 300))
#define GLOBAL_FsStruct_wlimit (*(IU32 *)((IUH)Gdp + 304))
#define GLOBAL_FsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 308))
#define GLOBAL_GsSel (*(IU16 *)((IUH)Gdp + 312 + 2))
#define GLOBAL_GsBase (*(IU32 *)((IUH)Gdp + 316))
#define GLOBAL_GsDesc (*(struct GLDC_REC* *)((IUH)Gdp + 320))
#define GLOBAL_GsStruct_rlimit (*(IU32 *)((IUH)Gdp + 324))
#define GLOBAL_GsStruct_wlimit (*(IU32 *)((IUH)Gdp + 328))
#define GLOBAL_GsDescSanctuary (*(struct GLDC_REC* *)((IUH)Gdp + 332))
#define GLOBAL_CPL (*(IUH *)((IUH)Gdp + 336))
#define GLOBAL_GdtrBase (*(IU32 *)((IUH)Gdp + 340))
#define GLOBAL_GdtrLimit (*(IU16 *)((IUH)Gdp + 344 + 2))
#define GLOBAL_LdtSel (*(IU16 *)((IUH)Gdp + 348 + 2))
#define GLOBAL_LdtrBase (*(IU32 *)((IUH)Gdp + 352))
#define GLOBAL_LdtrLimit (*(IU32 *)((IUH)Gdp + 356))
#define GLOBAL_TrSel (*(IU16 *)((IUH)Gdp + 360 + 2))
#define GLOBAL_TrBase (*(IU32 *)((IUH)Gdp + 364))
#define GLOBAL_TrLimit (*(IU32 *)((IUH)Gdp + 368))
#define GLOBAL_TrDescSt (*(IUH *)((IUH)Gdp + 372))
#define GLOBAL_TrIoBase (*(IU32 *)((IUH)Gdp + 376))
#define GLOBAL_TrIoLimit (*(IS32 *)((IUH)Gdp + 380))
#define GLOBAL_IdtrBase (*(IU32 *)((IUH)Gdp + 384))
#define GLOBAL_IdtrLimit (*(IU16 *)((IUH)Gdp + 388 + 2))
#define GLOBAL_AbortPigRun (*(IUH *)((IUH)Gdp + 392))
#define GLOBAL_RegsAndFlagsUndefined (*(IUH *)((IUH)Gdp + 396))
#define GLOBAL_SigalrmOccurred (*(IUH *)((IUH)Gdp + 400))
#define GLOBAL_PigEnabled (*(IUH *)((IUH)Gdp + 404))
#define GLOBAL_EFLAGS (*(IUH *)((IUH)Gdp + 408))
#define GLOBAL_Ft (*(IUH *)((IUH)Gdp + 412))
#define GLOBAL_F1 (*(IUH *)((IUH)Gdp + 416))
#define GLOBAL_F2 (*(IUH *)((IUH)Gdp + 420))
#define GLOBAL_F3 (*(IUH *)((IUH)Gdp + 424))
#define GLOBAL_R_CR0 (*(IUH *)((IUH)Gdp + 428))
#define GLOBAL_R_CR1 (*(IUH *)((IUH)Gdp + 432))
#define GLOBAL_R_CR2 (*(IUH *)((IUH)Gdp + 436))
#define GLOBAL_R_CR3 (*(IUH *)((IUH)Gdp + 440))
#define GLOBAL_R_CR4 (*(IUH *)((IUH)Gdp + 444))
#define GLOBAL_R_CR5 (*(IUH *)((IUH)Gdp + 448))
#define GLOBAL_R_CR6 (*(IUH *)((IUH)Gdp + 452))
#define GLOBAL_R_CR7 (*(IUH *)((IUH)Gdp + 456))
#define GLOBAL_R_TR0 (*(IUH *)((IUH)Gdp + 460))
#define GLOBAL_R_TR1 (*(IUH *)((IUH)Gdp + 464))
#define GLOBAL_R_TR2 (*(IUH *)((IUH)Gdp + 468))
#define GLOBAL_R_TR3 (*(IUH *)((IUH)Gdp + 472))
#define GLOBAL_R_TR4 (*(IUH *)((IUH)Gdp + 476))
#define GLOBAL_R_TR5 (*(IUH *)((IUH)Gdp + 480))
#define GLOBAL_R_TR6 (*(IUH *)((IUH)Gdp + 484))
#define GLOBAL_R_TR7 (*(IUH *)((IUH)Gdp + 488))
#define GLOBAL_R_DR0 (*(IUH *)((IUH)Gdp + 492))
#define GLOBAL_R_DR1 (*(IUH *)((IUH)Gdp + 496))
#define GLOBAL_R_DR2 (*(IUH *)((IUH)Gdp + 500))
#define GLOBAL_R_DR3 (*(IUH *)((IUH)Gdp + 504))
#define GLOBAL_R_DR4 (*(IUH *)((IUH)Gdp + 508))
#define GLOBAL_R_DR5 (*(IUH *)((IUH)Gdp + 512))
#define GLOBAL_R_DR6 (*(IUH *)((IUH)Gdp + 516))
#define GLOBAL_R_DR7 (*(IUH *)((IUH)Gdp + 520))
#define GLOBAL_PARAM1 (*(IUH *)((IUH)Gdp + 524))
#define GLOBAL_PARAM2 (*(IUH *)((IUH)Gdp + 528))
#define GLOBAL_PARAM3 (*(IUH *)((IUH)Gdp + 532))
#define GLOBAL_BytePtr (*(IU8* *)((IUH)Gdp + 536))
#define GLOBAL_WordPtr (*(IU16* *)((IUH)Gdp + 540))
#define GLOBAL_DwordPtr (*(IU32* *)((IUH)Gdp + 544))
#define GLOBAL_EaOffs (*(IUH *)((IUH)Gdp + 548))
#define GLOBAL_DATA1 (*(IUH *)((IUH)Gdp + 552))
#define GLOBAL_DATA2 (*(IUH *)((IUH)Gdp + 556))
#define GLOBAL_InNanoCpu (*(IBOOL *)((IUH)Gdp + 560 + 3))
#define GLOBAL_UseNanoCpu (*(IBOOL *)((IUH)Gdp + 564 + 3))
#define GLOBAL_UseLightCompiler (*(IBOOL *)((IUH)Gdp + 568 + 3))
#define GLOBAL_UseCCodeCopier (*(IBOOL *)((IUH)Gdp + 572 + 3))
#define GLOBAL_seenWithFlags (*(IBOOL *)((IUH)Gdp + 576 + 3))
#define GLOBAL_needNextIntelEip (*(IBOOL *)((IUH)Gdp + 580 + 3))
#define GLOBAL_LastSetCopierUniverse (*(struct EntryPointCacheREC* *)((IUH)Gdp + 584))
#define GLOBAL_CopierUniverse (*(struct EntryPointCacheREC* *)((IUH)Gdp + 588))
#define GLOBAL_CopierBitMap (*(struct ConstraintBitMapREC* *)((IUH)Gdp + 592))
#define GLOBAL_lastCopierBitMap (*(struct ConstraintBitMapREC* *)((IUH)Gdp + 596))
#define GLOBAL_currPFragInfoRec (*(struct FragmentInfoREC* *)((IUH)Gdp + 600))
#define GLOBAL_copierCleanups (*(IU8* *)((IUH)Gdp + 604))
#define GLOBAL_lastHostCleanup (*(IU8* *)((IUH)Gdp + 608))
#define GLOBAL_lastHostAddress (*(IU32* *)((IUH)Gdp + 612))
#define GLOBAL_lastIntelAddress (*(IU32 *)((IUH)Gdp + 616))
#define GLOBAL_destHashTable (*(struct JUMP_REC** *)((IUH)Gdp + 620))
#define GLOBAL_jumpHashTable (*(struct JUMP_REC** *)((IUH)Gdp + 624))
#define GLOBAL_freeJumpRecPtr (*(struct JUMP_REC* *)((IUH)Gdp + 628))
#define GLOBAL_nextFreeJumpRec (*(struct JUMP_REC* *)((IUH)Gdp + 632))
#define GLOBAL_freeJumpRecCount (*(IU32 *)((IUH)Gdp + 636))
#define GLOBAL_poolJumpRecCount (*(IU32 *)((IUH)Gdp + 640))
#define GLOBAL_vctPtrs (*(struct VCT_NODE_REC** *)((IUH)Gdp + 644))
#define GLOBAL_anonPtrs (*(struct VCT_NODE_REC** *)((IUH)Gdp + 648))
#define GLOBAL_tuples (*(struct TUPLE_REC* *)((IUH)Gdp + 652))
#define GLOBAL_cursor (*(struct TUPLE_REC* *)((IUH)Gdp + 656))
#define GLOBAL_tuplePtr (*(struct TUPLE_REC* *)((IUH)Gdp + 660))
#define GLOBAL_patchRecPtr (*(IU8* *)((IUH)Gdp + 664))
#define GLOBAL_srcPtr (*(IU32* *)((IUH)Gdp + 668))
#define GLOBAL_dstPtr (*(IU32* *)((IUH)Gdp + 672))
#define GLOBAL_PatchMeBodyAddr (*(IU32* *)((IUH)Gdp + 676))
#define GLOBAL_patchTable (*(IU32** *)((IUH)Gdp + 680))
#define GLOBAL_patchNames (*(IU8** *)((IUH)Gdp + 684))
#define GLOBAL_CopierFt (*(IUH *)((IUH)Gdp + 688))
#define GLOBAL_FtIsLazy (*(IBOOL *)((IUH)Gdp + 692 + 3))
#define GLOBAL_lastLazyFt (*(IUH *)((IUH)Gdp + 696))
#define GLOBAL_univVarMask (*(IU32 *)((IUH)Gdp + 700))
#define GLOBAL_zCoRoRetEFI (*(IU16 *)((IUH)Gdp + 704 + 2))
#define GLOBAL_zPatchMeEFI (*(IU16 *)((IUH)Gdp + 708 + 2))
#define GLOBAL_zPostPopEFI (*(IU16 *)((IUH)Gdp + 712 + 2))
#define GLOBAL_zAdjustHspEFI (*(IU16 *)((IUH)Gdp + 716 + 2))
#define GLOBAL_cumulativeStackMovement (*(ISH *)((IUH)Gdp + 720))
#define GLOBAL_lastInstructionInFragment (*(IBOOL *)((IUH)Gdp + 724 + 3))
#define GLOBAL_lateInInstruction (*(IBOOL *)((IUH)Gdp + 728 + 3))
#define GLOBAL_ReSelectVariant (*(IBOOL *)((IUH)Gdp + 732 + 3))
#define GLOBAL_ReSelectTupleSkipCnt (*(ISH *)((IUH)Gdp + 736))
#define GLOBAL_postPopPending (*(IBOOL *)((IUH)Gdp + 740 + 3))
#define GLOBAL_postPopSize (*(IU32 *)((IUH)Gdp + 744))
#define GLOBAL_compTimeFtBitNum (*(IU32 *)((IUH)Gdp + 748))
#define GLOBAL_accIsReadBitMask (*(IU32 *)((IUH)Gdp + 752))
#define GLOBAL_noFlagsBitMask (*(IU32 *)((IUH)Gdp + 756))
#define GLOBAL_OutlyingDispatchEIPAddr (*(IU32* *)((IUH)Gdp + 760))
#define GLOBAL_PARAM1RegId (*(IU32 *)((IUH)Gdp + 764))
#define GLOBAL_stashedImmed1 (*(IUH *)((IUH)Gdp + 768))
#define GLOBAL_stashedImmed2 (*(IUH *)((IUH)Gdp + 772))
#define GLOBAL_stashedImmed3 (*(IUH *)((IUH)Gdp + 776))
#define GLOBAL_stashedImmed4 (*(IUH *)((IUH)Gdp + 780))
#define GLOBAL_stashedImmed5 (*(IUH *)((IUH)Gdp + 784))
#define GLOBAL_EDL_WORKSPACE_32 (*(IUH *)((IUH)Gdp + 788))
#define GLOBAL_EDL_WORKSPACE_33 (*(IUH *)((IUH)Gdp + 792))
#define GLOBAL_EDL_WORKSPACE_34 (*(IUH *)((IUH)Gdp + 796))
#define GLOBAL_CleanedRec (*(struct CleanedREC *)((IUH)Gdp + 800))
#define GLOBAL_Universe (*(struct EntryPointCacheREC* *)((IUH)Gdp + 820))
#define GLOBAL_EntryPointCache (*(struct EntryPointCacheREC* *)((IUH)Gdp + 824))
#define GLOBAL_CsLinear (*(IU32 *)((IUH)Gdp + 828))
#define GLOBAL_JumpCounter (*(ISH *)((IUH)Gdp + 832))
#define GLOBAL_JumpRestart (*(ISH *)((IUH)Gdp + 836))
#define GLOBAL_JumpCalibrate (*(ISH *)((IUH)Gdp + 840))
#define GLOBAL_InitialJumpCounter (*(ISH *)((IUH)Gdp + 844))
#define GLOBAL_minimumInitialVal (*(IUH *)((IUH)Gdp + 848))
#define GLOBAL_IretHookStack (*(struct IretHookStackREC* *)((IUH)Gdp + 852))
#define GLOBAL_IretHookStackIndex (*(ISH *)((IUH)Gdp + 856))
#define GLOBAL_InstructionCount (*(IUH *)((IUH)Gdp + 860))
#define GLOBAL_CsSelectorHashTable (*(struct CsSelectorHashREC* *)((IUH)Gdp + 864))
#define GLOBAL_NextFreeUniverseHandle (*(IUH *)((IUH)Gdp + 868))
#define GLOBAL_UniHashTable (*(struct UniHashREC* *)((IUH)Gdp + 872))
#define GLOBAL_NextFreeUniHashEntry (*(struct UniHashREC* *)((IUH)Gdp + 876))
#define GLOBAL_NewUniverseBitMapRec (*(struct ConstraintBitMapREC *)((IUH)Gdp + 880))
#define GLOBAL_Constraint2CvMap (*(IU32* *)((IUH)Gdp + 888))
#define GLOBAL_InsertBPIs (*(IBOOL *)((IUH)Gdp + 892 + 3))
#define GLOBAL_UseUniverseHash (*(IBOOL *)((IUH)Gdp + 896 + 3))
#define GLOBAL_VirtualiseDataSel (*(IU16 *)((IUH)Gdp + 900 + 2))
#define GLOBAL_VirtualiseCodeSel (*(IU16 *)((IUH)Gdp + 904 + 2))
#define GLOBAL_VirtualiseSelsSet (*(IBOOL *)((IUH)Gdp + 908 + 3))
#define GLOBAL_EDL_WORKSPACE_35 (*(IUH *)((IUH)Gdp + 912))
#define GLOBAL_EDL_WORKSPACE_36 (*(IUH *)((IUH)Gdp + 916))
#define GLOBAL_EDL_WORKSPACE_37 (*(IUH *)((IUH)Gdp + 920))
#define GLOBAL_EDL_WORKSPACE_38 (*(IUH *)((IUH)Gdp + 924))
#define GLOBAL_TraceRingRec (*(struct TraceRingREC *)((IUH)Gdp + 928))
#define GLOBAL_EAXsaved (*(IUH *)((IUH)Gdp + 948))
#define GLOBAL_EBXsaved (*(IUH *)((IUH)Gdp + 952))
#define GLOBAL_ECXsaved (*(IUH *)((IUH)Gdp + 956))
#define GLOBAL_EDXsaved (*(IUH *)((IUH)Gdp + 960))
#define GLOBAL_ESIsaved (*(IUH *)((IUH)Gdp + 964))
#define GLOBAL_EDIsaved (*(IUH *)((IUH)Gdp + 968))
#define GLOBAL_EBPsaved (*(IUH *)((IUH)Gdp + 972))
#define GLOBAL_SafeToReturnToFragment (*(IBOOL *)((IUH)Gdp + 976 + 3))
#define GLOBAL_InsideTheCpu (*(IBOOL *)((IUH)Gdp + 980 + 3))
#define GLOBAL_SimulateContext (*(IUH* *)((IUH)Gdp + 984))
#define GLOBAL_SimulateNestingLevel (*(IUH *)((IUH)Gdp + 988))
#define GLOBAL_Pigging (*(IBOOL *)((IUH)Gdp + 992 + 3))
#define GLOBAL_tempEIP (*(IU32 *)((IUH)Gdp + 996))
#define GLOBAL_UseEntryPointCache (*(IBOOL *)((IUH)Gdp + 1000 + 3))
#define GLOBAL_CpuIsInitialised (*(IBOOL *)((IUH)Gdp + 1004 + 3))
#define GLOBAL_AR_FixupWanted (*(IBOOL *)((IUH)Gdp + 1008 + 3))
#define GLOBAL_D6isBop (*(IBOOL *)((IUH)Gdp + 1012 + 3))
#define GLOBAL_BopTable (*(IU8** *)((IUH)Gdp + 1016))
#define GLOBAL_LxS_hackyfix (*(IUH *)((IUH)Gdp + 1020))
#define GLOBAL_SavedFt (*(IUH *)((IUH)Gdp + 1024))
#define GLOBAL_SavedCF (*(IUH *)((IUH)Gdp + 1028))
#define GLOBAL_SavedZF (*(IUH *)((IUH)Gdp + 1032))
#define GLOBAL_SavedOF (*(IUH *)((IUH)Gdp + 1036))
#define GLOBAL_UsedD6 (*(IUH *)((IUH)Gdp + 1040))
#define GLOBAL_buildOp1 (*(IUH *)((IUH)Gdp + 1044))
#define GLOBAL_buildOp2 (*(IUH *)((IUH)Gdp + 1048))
#define GLOBAL_buildOp3 (*(IU32 *)((IUH)Gdp + 1052))
#define GLOBAL_buildOp4 (*(IU32 *)((IUH)Gdp + 1056))
#define GLOBAL_buildOp5 (*(IUH *)((IUH)Gdp + 1060))
#define GLOBAL_buildOp6 (*(IBOOL *)((IUH)Gdp + 1064 + 3))
#define GLOBAL_EDL_WORKSPACE_39 (*(IUH *)((IUH)Gdp + 1068))
#define GLOBAL_EDL_WORKSPACE_40 (*(IUH *)((IUH)Gdp + 1072))
#define GLOBAL_EDL_WORKSPACE_41 (*(IUH *)((IUH)Gdp + 1076))
#define GLOBAL_EDL_WORKSPACE_42 (*(IUH *)((IUH)Gdp + 1080))
#define GLOBAL_EDL_WORKSPACE_43 (*(IUH *)((IUH)Gdp + 1084))
#define GLOBAL_EDL_WORKSPACE_44 (*(IUH *)((IUH)Gdp + 1088))
#define GLOBAL_EDL_WORKSPACE_45 (*(IUH *)((IUH)Gdp + 1092))
#define GLOBAL_EDL_WORKSPACE_46 (*(IUH *)((IUH)Gdp + 1096))
#define GLOBAL_EDL_WORKSPACE_47 (*(IUH *)((IUH)Gdp + 1100))
#define GLOBAL_EDL_WORKSPACE_48 (*(IUH *)((IUH)Gdp + 1104))
#define GLOBAL_EDL_WORKSPACE_49 (*(IUH *)((IUH)Gdp + 1108))
#define GLOBAL_EDL_WORKSPACE_50 (*(IUH *)((IUH)Gdp + 1112))
#define GLOBAL_EDL_WORKSPACE_51 (*(IUH *)((IUH)Gdp + 1116))
#define GLOBAL_EDL_WORKSPACE_52 (*(IUH *)((IUH)Gdp + 1120))
#define GLOBAL_EDL_WORKSPACE_53 (*(IUH *)((IUH)Gdp + 1124))
#define GLOBAL_EDL_WORKSPACE_54 (*(IUH *)((IUH)Gdp + 1128))
#define GLOBAL_EDL_WORKSPACE_55 (*(IUH *)((IUH)Gdp + 1132))
#define GLOBAL_EDL_WORKSPACE_56 (*(IUH *)((IUH)Gdp + 1136))
#define GLOBAL_EDL_WORKSPACE_57 (*(IUH *)((IUH)Gdp + 1140))
#define GLOBAL_EDL_WORKSPACE_58 (*(IUH *)((IUH)Gdp + 1144))
#define GLOBAL_EDL_WORKSPACE_59 (*(IUH *)((IUH)Gdp + 1148))
#define GLOBAL_EDL_WORKSPACE_60 (*(IUH *)((IUH)Gdp + 1152))
#define GLOBAL_EDL_WORKSPACE_61 (*(IUH *)((IUH)Gdp + 1156))
#define GLOBAL_EDL_WORKSPACE_62 (*(IUH *)((IUH)Gdp + 1160))
#define GLOBAL_EDL_WORKSPACE_63 (*(IUH *)((IUH)Gdp + 1164))
#define GLOBAL_EDL_WORKSPACE_64 (*(IUH *)((IUH)Gdp + 1168))
#define GLOBAL_EDL_WORKSPACE_65 (*(IUH *)((IUH)Gdp + 1172))
#define GLOBAL_EDL_WORKSPACE_66 (*(IUH *)((IUH)Gdp + 1176))
#define GLOBAL_EDL_WORKSPACE_67 (*(IUH *)((IUH)Gdp + 1180))
#define GLOBAL_EDL_WORKSPACE_68 (*(IUH *)((IUH)Gdp + 1184))
#define GLOBAL_EDL_WORKSPACE_69 (*(IUH *)((IUH)Gdp + 1188))
#define GLOBAL_EDL_WORKSPACE_70 (*(IUH *)((IUH)Gdp + 1192))
#define GLOBAL_EDL_WORKSPACE_71 (*(IUH *)((IUH)Gdp + 1196))
#define GLOBAL_EDL_WORKSPACE_72 (*(IUH *)((IUH)Gdp + 1200))
#define GLOBAL_EDL_WORKSPACE_73 (*(IUH *)((IUH)Gdp + 1204))
#define GLOBAL_EDL_WORKSPACE_74 (*(IUH *)((IUH)Gdp + 1208))
#define GLOBAL_EDL_WORKSPACE_75 (*(IUH *)((IUH)Gdp + 1212))
#define GLOBAL_EDL_WORKSPACE_76 (*(IUH *)((IUH)Gdp + 1216))
#define GLOBAL_EDL_WORKSPACE_77 (*(IUH *)((IUH)Gdp + 1220))
#define GLOBAL_EDL_WORKSPACE_78 (*(IUH *)((IUH)Gdp + 1224))
#define GLOBAL_EDL_WORKSPACE_79 (*(IUH *)((IUH)Gdp + 1228))
#define GLOBAL_EDL_WORKSPACE_80 (*(IUH *)((IUH)Gdp + 1232))
#define GLOBAL_EDL_WORKSPACE_81 (*(IUH *)((IUH)Gdp + 1236))
#define GLOBAL_EDL_WORKSPACE_82 (*(IUH *)((IUH)Gdp + 1240))
#define GLOBAL_EDL_WORKSPACE_83 (*(IUH *)((IUH)Gdp + 1244))
#define GLOBAL_EDL_WORKSPACE_84 (*(IUH *)((IUH)Gdp + 1248))
#define GLOBAL_EDL_WORKSPACE_85 (*(IUH *)((IUH)Gdp + 1252))
#define GLOBAL_EDL_WORKSPACE_86 (*(IUH *)((IUH)Gdp + 1256))
#define GLOBAL_EDL_WORKSPACE_87 (*(IUH *)((IUH)Gdp + 1260))
#define GLOBAL_EDL_WORKSPACE_88 (*(IUH *)((IUH)Gdp + 1264))
#define GLOBAL_EDL_WORKSPACE_89 (*(IUH *)((IUH)Gdp + 1268))
#define GLOBAL_EDL_WORKSPACE_90 (*(IUH *)((IUH)Gdp + 1272))
#define GLOBAL_EDL_WORKSPACE_91 (*(IUH *)((IUH)Gdp + 1276))
#define GLOBAL_VGAGlobals (*(struct VGAGLOBALSETTINGS *)((IUH)Gdp + 1280))
#define GLOBAL_VidMarkFuncTable (*(IUH** *)((IUH)Gdp + 1436))
#define GLOBAL_VidReadFuncTable (*(IUH** *)((IUH)Gdp + 1440))
#define GLOBAL_VidWriteFuncTable (*(IUH** *)((IUH)Gdp + 1444))
#define GLOBAL_EDL_WORKSPACE_92 (*(IUH *)((IUH)Gdp + 1448))
#define GLOBAL_EDL_WORKSPACE_93 (*(IUH *)((IUH)Gdp + 1452))
#define GLOBAL_EDL_WORKSPACE_94 (*(IUH *)((IUH)Gdp + 1456))
#define GLOBAL_EDL_WORKSPACE_95 (*(IUH *)((IUH)Gdp + 1460))
#define GLOBAL_EDL_WORKSPACE_96 (*(IUH *)((IUH)Gdp + 1464))
#define GLOBAL_EDL_WORKSPACE_97 (*(IUH *)((IUH)Gdp + 1468))
#define GLOBAL_ActiveVideoWrites (*(struct EVIDWRITES *)((IUH)Gdp + 1472))
#define GLOBAL_EDL_WORKSPACE_98 (*(IUH *)((IUH)Gdp + 1520))
#define GLOBAL_EDL_WORKSPACE_99 (*(IUH *)((IUH)Gdp + 1524))
#define GLOBAL_EDL_WORKSPACE_100 (*(IUH *)((IUH)Gdp + 1528))
#define GLOBAL_EDL_WORKSPACE_101 (*(IUH *)((IUH)Gdp + 1532))
#define GLOBAL_ActiveVideoReads (*(struct EVIDREADS *)((IUH)Gdp + 1536))
#define GLOBAL_EDL_WORKSPACE_102 (*(IUH *)((IUH)Gdp + 1556))
#define GLOBAL_EDL_WORKSPACE_103 (*(IUH *)((IUH)Gdp + 1560))
#define GLOBAL_EDL_WORKSPACE_104 (*(IUH *)((IUH)Gdp + 1564))
#define GLOBAL_ActiveVideoMarks (*(struct EVIDMARKS *)((IUH)Gdp + 1568))
#define GLOBAL_MaxIntelPageNumber (*(IU32 *)((IUH)Gdp + 1584))
#define GLOBAL_PageDirectoryPtr (*(IU32* *)((IUH)Gdp + 1588))
#define GLOBAL_DebuggerPFLA (*(IU32 *)((IUH)Gdp + 1592))
#define GLOBAL_DebuggerFaultAction (*(IUH *)((IUH)Gdp + 1596))
#define GLOBAL_InsideDebugger (*(ISH *)((IUH)Gdp + 1600))
#define GLOBAL_EDL_WORKSPACE_105 (*(IUH *)((IUH)Gdp + 1604))
#define GLOBAL_EDL_WORKSPACE_106 (*(IUH *)((IUH)Gdp + 1608))
#define GLOBAL_EDL_WORKSPACE_107 (*(IUH *)((IUH)Gdp + 1612))
#define GLOBAL_EDL_WORKSPACE_108 (*(IUH *)((IUH)Gdp + 1616))
#define GLOBAL_EDL_WORKSPACE_109 (*(IUH *)((IUH)Gdp + 1620))
#define GLOBAL_EDL_WORKSPACE_110 (*(IUH *)((IUH)Gdp + 1624))
#define GLOBAL_EDL_WORKSPACE_111 (*(IUH *)((IUH)Gdp + 1628))
#define GLOBAL_EDL_WORKSPACE_112 (*(IUH *)((IUH)Gdp + 1632))
#define GLOBAL_EDL_WORKSPACE_113 (*(IUH *)((IUH)Gdp + 1636))
#define GLOBAL_EDL_WORKSPACE_114 (*(IUH *)((IUH)Gdp + 1640))
#define GLOBAL_EDL_WORKSPACE_115 (*(IUH *)((IUH)Gdp + 1644))
#define GLOBAL_EDL_WORKSPACE_116 (*(IUH *)((IUH)Gdp + 1648))
#define GLOBAL_EDL_WORKSPACE_117 (*(IUH *)((IUH)Gdp + 1652))
#define GLOBAL_EDL_WORKSPACE_118 (*(IUH *)((IUH)Gdp + 1656))
#define GLOBAL_EDL_WORKSPACE_119 (*(IUH *)((IUH)Gdp + 1660))
#define GLOBAL_VirtualisationBIOSOffsets (*(struct VirtualisationBIOSOffsetsREC *)((IUH)Gdp + 1664))
#define GLOBAL_DelayedPDTEoverwiteList (*(struct DelayedPDTEoverwiteREC* *)((IUH)Gdp + 1712))
#define GLOBAL_SasMemoryType (*(IU8* *)((IUH)Gdp + 1716))
#define GLOBAL_PhysicalPageRecords (*(struct PhysicalPageREC* *)((IUH)Gdp + 1720))
#define GLOBAL_PhysicalPageMemory (*(IU8** *)((IUH)Gdp + 1724))
#define GLOBAL_TwentyBitWrapStatus (*(IBOOL *)((IUH)Gdp + 1728 + 3))
#define GLOBAL_MultipleRecompilationCount (*(IUH *)((IUH)Gdp + 1732))
#define GLOBAL_MaxMultipleRecompilation (*(IUH *)((IUH)Gdp + 1736))
#define GLOBAL_HideCompiledFragment (*(IBOOL *)((IUH)Gdp + 1740 + 3))
#define GLOBAL_RestartAfterCodeOverwrite (*(IBOOL *)((IUH)Gdp + 1744 + 3))
#define GLOBAL_DoingCompilation (*(IBOOL *)((IUH)Gdp + 1748 + 3))
#define GLOBAL_SanityCheckStructures (*(IBOOL *)((IUH)Gdp + 1752 + 3))
#define GLOBAL_FragCounts (*(IU8* *)((IUH)Gdp + 1756))
#define GLOBAL_ControlBlock (*(struct CompilationControlREC *)((IUH)Gdp + 1760))
#define GLOBAL_EDL_WORKSPACE_120 (*(IUH *)((IUH)Gdp + 1776))
#define GLOBAL_EDL_WORKSPACE_121 (*(IUH *)((IUH)Gdp + 1780))
#define GLOBAL_EDL_WORKSPACE_122 (*(IUH *)((IUH)Gdp + 1784))
#define GLOBAL_EDL_WORKSPACE_123 (*(IUH *)((IUH)Gdp + 1788))
#define GLOBAL_CompilationBlock (*(struct BLOCK_TO_COMPILE *)((IUH)Gdp + 1792))
#define GLOBAL_EDL_WORKSPACE_124 (*(IUH *)((IUH)Gdp + 1824))
#define GLOBAL_EDL_WORKSPACE_125 (*(IUH *)((IUH)Gdp + 1828))
#define GLOBAL_EDL_WORKSPACE_126 (*(IUH *)((IUH)Gdp + 1832))
#define GLOBAL_EDL_WORKSPACE_127 (*(IUH *)((IUH)Gdp + 1836))
#define GLOBAL_EDL_WORKSPACE_128 (*(IUH *)((IUH)Gdp + 1840))
#define GLOBAL_EDL_WORKSPACE_129 (*(IUH *)((IUH)Gdp + 1844))
#define GLOBAL_EDL_WORKSPACE_130 (*(IUH *)((IUH)Gdp + 1848))
#define GLOBAL_EDL_WORKSPACE_131 (*(IUH *)((IUH)Gdp + 1852))
#define GLOBAL_EDL_WORKSPACE_132 (*(IUH *)((IUH)Gdp + 1856))
#define GLOBAL_EDL_WORKSPACE_133 (*(IUH *)((IUH)Gdp + 1860))
#define GLOBAL_EDL_WORKSPACE_134 (*(IUH *)((IUH)Gdp + 1864))
#define GLOBAL_EDL_WORKSPACE_135 (*(IUH *)((IUH)Gdp + 1868))
#define GLOBAL_EDL_WORKSPACE_136 (*(IUH *)((IUH)Gdp + 1872))
#define GLOBAL_EDL_WORKSPACE_137 (*(IUH *)((IUH)Gdp + 1876))
#define GLOBAL_EDL_WORKSPACE_138 (*(IUH *)((IUH)Gdp + 1880))
#define GLOBAL_EDL_WORKSPACE_139 (*(IUH *)((IUH)Gdp + 1884))
#define GLOBAL_EDL_WORKSPACE_140 (*(IUH *)((IUH)Gdp + 1888))
#define GLOBAL_EDL_WORKSPACE_141 (*(IUH *)((IUH)Gdp + 1892))
#define GLOBAL_EDL_WORKSPACE_142 (*(IUH *)((IUH)Gdp + 1896))
#define GLOBAL_EDL_WORKSPACE_143 (*(IUH *)((IUH)Gdp + 1900))
#define GLOBAL_EDL_WORKSPACE_144 (*(IUH *)((IUH)Gdp + 1904))
#define GLOBAL_EDL_WORKSPACE_145 (*(IUH *)((IUH)Gdp + 1908))
#define GLOBAL_EDL_WORKSPACE_146 (*(IUH *)((IUH)Gdp + 1912))
#define GLOBAL_EDL_WORKSPACE_147 (*(IUH *)((IUH)Gdp + 1916))
#define GLOBAL_ProtAllocationRec (*(struct ProtAllocationREC *)((IUH)Gdp + 1920))
#define GLOBAL_LightCompiledLRUrec (*(struct BufferIndexREC* *)((IUH)Gdp + 2016))
#define GLOBAL_NextPhysicalPage (*(IUH *)((IUH)Gdp + 2020))
#define GLOBAL_FreeMaps (*(struct TranslationMapREC* *)((IUH)Gdp + 2024))
#define GLOBAL_TranslationCache (*(struct TranslationCacheREC* *)((IUH)Gdp + 2028))
#define GLOBAL_CrossPageInstructions (*(IU8* *)((IUH)Gdp + 2032))
#define GLOBAL_IHook (*(IU32 *)((IUH)Gdp + 2036))
#define GLOBAL_InterruptRec (*(struct InterruptREC *)((IUH)Gdp + 2040))
#define GLOBAL_SasReInitNow (*(IBOOL *)((IUH)Gdp + 2048 + 3))
#define GLOBAL_SasReInitSize (*(IU32 *)((IUH)Gdp + 2052))
#define GLOBAL_EDL_WORKSPACE_148 (*(IUH *)((IUH)Gdp + 2056))
#define GLOBAL_EDL_WORKSPACE_149 (*(IUH *)((IUH)Gdp + 2060))
#define GLOBAL_EDL_WORKSPACE_150 (*(IUH *)((IUH)Gdp + 2064))
#define GLOBAL_EDL_WORKSPACE_151 (*(IUH *)((IUH)Gdp + 2068))
#define GLOBAL_EDL_WORKSPACE_152 (*(IUH *)((IUH)Gdp + 2072))
#define GLOBAL_EDL_WORKSPACE_153 (*(IUH *)((IUH)Gdp + 2076))
#define GLOBAL_QuickTickerRec (*(struct QuickTickerREC *)((IUH)Gdp + 2080))
#define GLOBAL_PigSynchCount (*(IUH *)((IUH)Gdp + 2104))
#define GLOBAL_CodeBufferNoRepair (*(IBOOL *)((IUH)Gdp + 2108 + 3))
#define GLOBAL_OutLinePatchBlock (*(IU32* *)((IUH)Gdp + 2112))
#define GLOBAL_OutLinePatchBlockSize (*(IU32 *)((IUH)Gdp + 2116))
#define GLOBAL_AllBuffers (*(struct BufferIndexREC* *)((IUH)Gdp + 2120))
#define GLOBAL_LightBufferLRU (*(struct BufferIndexREC* *)((IUH)Gdp + 2124))
#define GLOBAL_CompilationBuffer (*(struct BufferIndexREC* *)((IUH)Gdp + 2128))
#define GLOBAL_PendingDeletions (*(struct BufferIndexREC* *)((IUH)Gdp + 2132))
#define GLOBAL_FragmentInfoArray (*(struct FragmentInfoREC* *)((IUH)Gdp + 2136))
#define GLOBAL_HostCodeBufferLimit (*(IU32* *)((IUH)Gdp + 2140))
#define GLOBAL_CopiedCleanups (*(IU8* *)((IUH)Gdp + 2144))
#define GLOBAL_FreeDebugInfoList (*(struct DebugInfoREC* *)((IUH)Gdp + 2148))
#define GLOBAL_CodeBufferOverrun (*(IU32* *)((IUH)Gdp + 2152))
#define GLOBAL_OverrunHighWaterMark (*(IU32* *)((IUH)Gdp + 2156))
#define GLOBAL_NumberOfBuffers (*(IU16 *)((IUH)Gdp + 2160 + 2))
#define GLOBAL_BpiCompilationBuffer (*(struct BufferIndexREC* *)((IUH)Gdp + 2164))
#define GLOBAL_NextFragmentIndex (*(struct FragmentIndexREC* *)((IUH)Gdp + 2168))
#define GLOBAL_NextFragmentData (*(struct FragmentDataREC* *)((IUH)Gdp + 2172))
#define GLOBAL_FpuDisabled (*(IBOOL *)((IUH)Gdp + 2176 + 3))
#define GLOBAL_NpxControl (*(IUH *)((IUH)Gdp + 2180))
#define GLOBAL_NpxStatus (*(IUH *)((IUH)Gdp + 2184))
#define GLOBAL_NpxFEA (*(IUH *)((IUH)Gdp + 2188))
#define GLOBAL_NpxFDS (*(IUH *)((IUH)Gdp + 2192))
#define GLOBAL_NpxFIP (*(IUH *)((IUH)Gdp + 2196))
#define GLOBAL_NpxFOP (*(IUH *)((IUH)Gdp + 2200))
#define GLOBAL_NpxFCS (*(IUH *)((IUH)Gdp + 2204))
#define GLOBAL_NpxLastSel (*(IUH *)((IUH)Gdp + 2208))
#define GLOBAL_NpxLastOff (*(IUH *)((IUH)Gdp + 2212))
#define GLOBAL_DoAPop (*(IBOOL *)((IUH)Gdp + 2216 + 3))
#define GLOBAL_NpxException (*(IBOOL *)((IUH)Gdp + 2220 + 3))
#define GLOBAL_npxRounding (*(IUH *)((IUH)Gdp + 2224))
#define GLOBAL_tag_or (*(IUH *)((IUH)Gdp + 2228))
#define GLOBAL_tag_xor (*(IUH *)((IUH)Gdp + 2232))
#define GLOBAL_hostFpuExceptions (*(IUH *)((IUH)Gdp + 2236))
#define GLOBAL_MaxBCDValue (*(struct FPSTACKENTRY *)((IUH)Gdp + 2240))
#define GLOBAL_FPUpload (*(struct FPSTACKENTRY *)((IUH)Gdp + 2256))
#define GLOBAL_ConstTable (*(struct FPSTACKENTRY* *)((IUH)Gdp + 2272))
#define GLOBAL_FPTemp (*(struct FPSTACKENTRY* *)((IUH)Gdp + 2276))
#define GLOBAL_FPUStackBase (*(struct FPSTACKENTRY* *)((IUH)Gdp + 2280))
#define GLOBAL_TOSPtr (*(struct FPSTACKENTRY* *)((IUH)Gdp + 2284))
#define GLOBAL_Npx64BitZero (*(struct FP_I64 *)((IUH)Gdp + 2288))
#define GLOBAL_Npx64BitMaxNeg (*(struct FP_I64 *)((IUH)Gdp + 2296))
#define GLOBAL_Npx64BitHalfMaxNeg (*(struct FP_I64 *)((IUH)Gdp + 2304))
#define GLOBAL_Npx64BitVal1 (*(struct FP_I64 *)((IUH)Gdp + 2312))
#define GLOBAL_FscaleTable (*(IUH* *)((IUH)Gdp + 2320))
#define GLOBAL_CompZeroTable (*(IU32* *)((IUH)Gdp + 2324))
#define GLOBAL_BCDLowNibble (*(struct FP_I64* *)((IUH)Gdp + 2328))
#define GLOBAL_BCDHighNibble (*(struct FP_I64* *)((IUH)Gdp + 2332))
#define GLOBAL_FpatanTable (*(struct FPSTACKENTRY* *)((IUH)Gdp + 2336))
#define GLOBAL_PigSynchTable (*(struct PigSynchREC* *)((IUH)Gdp + 2340))
#define GLOBAL_PigMissTable (*(struct PigSynchREC* *)((IUH)Gdp + 2344))
#define GLOBAL_PigSynchPool (*(struct PigSynchREC* *)((IUH)Gdp + 2348))
#define GLOBAL_EDL_WORKSPACE_154 (*(IUH *)((IUH)Gdp + 2352))
#define GLOBAL_EDL_WORKSPACE_155 (*(IUH *)((IUH)Gdp + 2356))
#define GLOBAL_EDL_WORKSPACE_156 (*(IUH *)((IUH)Gdp + 2360))
#define GLOBAL_EDL_WORKSPACE_157 (*(IUH *)((IUH)Gdp + 2364))
#define GLOBAL_PigCleanedRec (*(struct CleanedREC *)((IUH)Gdp + 2368))
#define GLOBAL_PigSynchWanted (*(IBOOL *)((IUH)Gdp + 2388 + 3))
#define GLOBAL_SadAX (*(ISH *)((IUH)Gdp + 2392))
#define GLOBAL_SadBX (*(ISH *)((IUH)Gdp + 2396))
#define GLOBAL_SadCX (*(ISH *)((IUH)Gdp + 2400))
#define GLOBAL_SadDX (*(ISH *)((IUH)Gdp + 2404))
#define GLOBAL_SadBP (*(ISH *)((IUH)Gdp + 2408))
#define GLOBAL_SadSP (*(ISH *)((IUH)Gdp + 2412))
#define GLOBAL_SadSI (*(ISH *)((IUH)Gdp + 2416))
#define GLOBAL_SadDI (*(ISH *)((IUH)Gdp + 2420))
#define GLOBAL_SadEIP (*(ISH *)((IUH)Gdp + 2424))
#define GLOBAL_SadEFLAGS (*(ISH *)((IUH)Gdp + 2428))
#define GLOBAL_Parameter1 (*(ISH *)((IUH)Gdp + 2432))
#define GLOBAL_Parameter2 (*(ISH *)((IUH)Gdp + 2436))
#define GLOBAL_BpiKnownTable (*(ISH* *)((IUH)Gdp + 2440))
#define GLOBAL_BpiWorkTable (*(ISH* *)((IUH)Gdp + 2444))
#define GLOBAL_BpiLabelTable (*(ISH* *)((IUH)Gdp + 2448))
#define GLOBAL_BpiFragment (*(struct FragmentDataREC* *)((IUH)Gdp + 2452))
#define GLOBAL_BpiCompiledCode (*(IU32* *)((IUH)Gdp + 2456))
#define GLOBAL_BpiCompiledStep (*(IU32* *)((IUH)Gdp + 2460))
#define GLOBAL_BpiCompiledUser (*(IU32* *)((IUH)Gdp + 2464))
#define GLOBAL_OpBpirealFt (*(IUH *)((IUH)Gdp + 2468))
#define GLOBAL_OpBpirealF1 (*(IUH *)((IUH)Gdp + 2472))
#define GLOBAL_OpBpirealF2 (*(IUH *)((IUH)Gdp + 2476))
#define GLOBAL_OpBpirealF3 (*(IUH *)((IUH)Gdp + 2480))
#define GLOBAL_OpBpirealUniv (*(struct EntryPointCacheREC* *)((IUH)Gdp + 2484))
#define GLOBAL_OpBpirealWhereAmI (*(IU32* *)((IUH)Gdp + 2488))
#define GLOBAL_EDL_WORKSPACE_158 (*(IUH *)((IUH)Gdp + 2492))
#define GLOBAL_EDL_WORKSPACE_159 (*(IUH *)((IUH)Gdp + 2496))
#define GLOBAL_EDL_WORKSPACE_160 (*(IUH *)((IUH)Gdp + 2500))
#define GLOBAL_EDL_WORKSPACE_161 (*(IUH *)((IUH)Gdp + 2504))
#define GLOBAL_EDL_WORKSPACE_162 (*(IUH *)((IUH)Gdp + 2508))
#define GLOBAL_EDL_WORKSPACE_163 (*(IUH *)((IUH)Gdp + 2512))
#define GLOBAL_EDL_WORKSPACE_164 (*(IUH *)((IUH)Gdp + 2516))
#define GLOBAL_EDL_WORKSPACE_165 (*(IUH *)((IUH)Gdp + 2520))
#define GLOBAL_EDL_WORKSPACE_166 (*(IUH *)((IUH)Gdp + 2524))
#define GLOBAL_EDL_WORKSPACE_167 (*(IUH *)((IUH)Gdp + 2528))
#define GLOBAL_EDL_WORKSPACE_168 (*(IUH *)((IUH)Gdp + 2532))
#define GLOBAL_EDL_WORKSPACE_169 (*(IUH *)((IUH)Gdp + 2536))
#define GLOBAL_EDL_WORKSPACE_170 (*(IUH *)((IUH)Gdp + 2540))
#define GLOBAL_EDL_WORKSPACE_171 (*(IUH *)((IUH)Gdp + 2544))
#define GLOBAL_EDL_WORKSPACE_172 (*(IUH *)((IUH)Gdp + 2548))
#define GLOBAL_EDL_WORKSPACE_173 (*(IUH *)((IUH)Gdp + 2552))
#define GLOBAL_EDL_WORKSPACE_174 (*(IUH *)((IUH)Gdp + 2556))
#define GLOBAL_NpxOpndBuff (*(struct OpndBuffREC *)((IUH)Gdp + 2560))
#define GLOBAL_GLDC_FreeRecs (*(struct GLDC_REC* *)((IUH)Gdp + 2688))
#define GLOBAL_GLDC_UsedBuffs (*(struct GLDC_REC* *)((IUH)Gdp + 2692))
#define GLOBAL_GLDC_FreeBuffs (*(struct GLDC_REC* *)((IUH)Gdp + 2696))
#define GLOBAL_NewRingOffsetPtr (*(IUH* *)((IUH)Gdp + 2700))
#define GLOBAL_GLDC_Index_High_Water (*(IUH *)((IUH)Gdp + 2704))
#define GLOBAL_GLDC_Context_High_Water (*(IUH *)((IUH)Gdp + 2708))
#define GLOBAL_GLDC_IndexPtr (*(struct GLDC_REC** *)((IUH)Gdp + 2712))
#define GLOBAL_GLDC_CrBase (*(IUH* *)((IUH)Gdp + 2716))
#define GLOBAL_EDL_WORKSPACE_175 (*(IUH *)((IUH)Gdp + 2720))
#define GLOBAL_EDL_WORKSPACE_176 (*(IUH *)((IUH)Gdp + 2724))
#define GLOBAL_EDL_WORKSPACE_177 (*(IUH *)((IUH)Gdp + 2728))
#define GLOBAL_EDL_WORKSPACE_178 (*(IUH *)((IUH)Gdp + 2732))
#define GLOBAL_EDL_WORKSPACE_179 (*(IUH *)((IUH)Gdp + 2736))
#define GLOBAL_EDL_WORKSPACE_180 (*(IUH *)((IUH)Gdp + 2740))
#define GLOBAL_EDL_WORKSPACE_181 (*(IUH *)((IUH)Gdp + 2744))
#define GLOBAL_EDL_WORKSPACE_182 (*(IUH *)((IUH)Gdp + 2748))
#define GLOBAL_GLDC_DUMMY_STORE (*(struct GLDC_REC *)((IUH)Gdp + 2752))
#define GLOBAL_EDL_WORKSPACE_183 (*(IUH *)((IUH)Gdp + 2792))
#define GLOBAL_EDL_WORKSPACE_184 (*(IUH *)((IUH)Gdp + 2796))
#define GLOBAL_EDL_WORKSPACE_185 (*(IUH *)((IUH)Gdp + 2800))
#define GLOBAL_EDL_WORKSPACE_186 (*(IUH *)((IUH)Gdp + 2804))
#define GLOBAL_EDL_WORKSPACE_187 (*(IUH *)((IUH)Gdp + 2808))
#define GLOBAL_EDL_WORKSPACE_188 (*(IUH *)((IUH)Gdp + 2812))
#define GLOBAL_GLDC_NULL_STORE (*(struct GLDC_REC *)((IUH)Gdp + 2816))
#define GLOBAL_hackyfix (*(IUH *)((IUH)Gdp + 2856))
#define GLOBAL_IDC_ArrayPtr (*(struct IDC_REC* *)((IUH)Gdp + 2860))
#define GLOBAL_IDC_EntryTableBase (*(struct IDC_ENTRY* *)((IUH)Gdp + 2864))
#define GLOBAL_IDC_IdtSeqVal (*(IUH *)((IUH)Gdp + 2868))
#define GLOBAL_IDC_IdtHighWater (*(IUH *)((IUH)Gdp + 2872))
#define GLOBAL_IDC_IdtCntrlVal (*(IUH *)((IUH)Gdp + 2876))
#define GLOBAL_IDC_IdtCntrlValNoCheck (*(IUH *)((IUH)Gdp + 2880))
#define GLOBAL_PX_trace (*(IBOOL *)((IUH)Gdp + 2884 + 3))
#define GLOBAL_PX_doing_contributory (*(IBOOL *)((IUH)Gdp + 2888 + 3))
#define GLOBAL_PX_doing_page_fault (*(IBOOL *)((IUH)Gdp + 2892 + 3))
#define GLOBAL_PX_doing_double_fault (*(IBOOL *)((IUH)Gdp + 2896 + 3))
#define GLOBAL_PX_doing_fault (*(IBOOL *)((IUH)Gdp + 2900 + 3))
#define GLOBAL_PX_source (*(IUH *)((IUH)Gdp + 2904))
#define GLOBAL_RF_OnXcptnWanted (*(IBOOL *)((IUH)Gdp + 2908 + 3))
#define GLOBAL_PX_Cleaned_Eip (*(IU32 *)((IUH)Gdp + 2912))
#define GLOBAL_CInbTable (*(IUH** *)((IUH)Gdp + 2916))
#define GLOBAL_CInwTable (*(IUH** *)((IUH)Gdp + 2920))
#define GLOBAL_CIndTable (*(IUH** *)((IUH)Gdp + 2924))
#define GLOBAL_COutbTable (*(IUH** *)((IUH)Gdp + 2928))
#define GLOBAL_COutwTable (*(IUH** *)((IUH)Gdp + 2932))
#define GLOBAL_COutdTable (*(IUH** *)((IUH)Gdp + 2936))
#define GLOBAL_InAdapFromPort (*(IU8* *)((IUH)Gdp + 2940))
#define GLOBAL_OutAdapFromPort (*(IU8* *)((IUH)Gdp + 2944))
#define GLOBAL_InbFuncWrapper (*(IUH** *)((IUH)Gdp + 2948))
#define GLOBAL_InwFuncWrapper (*(IUH** *)((IUH)Gdp + 2952))
#define GLOBAL_IndFuncWrapper (*(IUH** *)((IUH)Gdp + 2956))
#define GLOBAL_OutbFuncWrapper (*(IUH** *)((IUH)Gdp + 2960))
#define GLOBAL_OutwFuncWrapper (*(IUH** *)((IUH)Gdp + 2964))
#define GLOBAL_OutdFuncWrapper (*(IUH** *)((IUH)Gdp + 2968))
#define GLOBAL_TempByteDest (*(IU8 *)((IUH)Gdp + 2972 + 3))
#define GLOBAL_TempWordDest (*(IU16 *)((IUH)Gdp + 2976 + 2))
#define GLOBAL_TempDoubleDest (*(IU32 *)((IUH)Gdp + 2980))
#define GLOBAL_MaxValidAdaptor (*(IUH *)((IUH)Gdp + 2984))
#define GLOBAL_IOSPortMask (*(IU16 *)((IUH)Gdp + 2988 + 2))
#define GLOBAL_EDL_WORKSPACE_189 (*(IUH *)((IUH)Gdp + 2992))
#define GLOBAL_EDL_WORKSPACE_190 (*(IUH *)((IUH)Gdp + 2996))
#define GLOBAL_EDL_WORKSPACE_191 (*(IUH *)((IUH)Gdp + 3000))
#define GLOBAL_EDL_WORKSPACE_192 (*(IUH *)((IUH)Gdp + 3004))
#define GLOBAL_SegDescPtrLookupREC (*(struct DYNAMIC_DESC_PTR_LOOKUP *)((IUH)Gdp + 3008))
#define GLOBAL_EDL_WORKSPACE_193 (*(IUH *)((IUH)Gdp + 3032))
#define GLOBAL_EDL_WORKSPACE_194 (*(IUH *)((IUH)Gdp + 3036))
#define GLOBAL_SegBaseLookupREC (*(struct DYNAMIC_SEG_BASE_LOOKUP *)((IUH)Gdp + 3040))
#define GLOBAL_HSP (*(IU8* *)((IUH)Gdp + 3064))
#define GLOBAL_ESPsanctuary (*(IU32 *)((IUH)Gdp + 3068))
#define GLOBAL_truePopLimit (*(IU8* *)((IUH)Gdp + 3072))
#define GLOBAL_innerPopLimit (*(IU8* *)((IUH)Gdp + 3076))
#define GLOBAL_truePushLimit (*(IU8* *)((IUH)Gdp + 3080))
#define GLOBAL_innerPushLimit (*(IU8* *)((IUH)Gdp + 3084))
#define GLOBAL_notionalSsBase (*(IU8* *)((IUH)Gdp + 3088))
#define GLOBAL_stackIsWrappable (*(IBOOL *)((IUH)Gdp + 3092 + 3))
#define GLOBAL_stackIsBig (*(IBOOL *)((IUH)Gdp + 3096 + 3))
#define GLOBAL_stackMask (*(IU32 *)((IUH)Gdp + 3100))
#define GLOBAL_stackNeedsNormalising (*(IBOOL *)((IUH)Gdp + 3104 + 3))
#define GLOBAL_laInTopPage (*(IU32 *)((IUH)Gdp + 3108))
#define GLOBAL_laInBottomPage (*(IU32 *)((IUH)Gdp + 3112))
#define GLOBAL_hspOK (*(IBOOL *)((IUH)Gdp + 3116 + 3))
#define GLOBAL_pushScratch (*(IU8* *)((IUH)Gdp + 3120))
#define GLOBAL_pushScratchInUse (*(IBOOL *)((IUH)Gdp + 3124 + 3))
#define GLOBAL_popScratch (*(IU8* *)((IUH)Gdp + 3128))
#define GLOBAL_popScratchInUse (*(IBOOL *)((IUH)Gdp + 3132 + 3))
#define GLOBAL_stackJumpCounterCeiling (*(ISH *)((IUH)Gdp + 3136))
#define GLOBAL_stackJumpCounterDebt (*(ISH *)((IUH)Gdp + 3140))
#define GLOBAL_prevJumpCounter (*(ISH *)((IUH)Gdp + 3144))
#define GLOBAL_SafeStackEnabled (*(IBOOL *)((IUH)Gdp + 3148 + 3))
#define GLOBAL_SafeStackIronFrig (*(IBOOL *)((IUH)Gdp + 3152 + 3))
#define GLOBAL_newNanoSafeLow (*(IU32 *)((IUH)Gdp + 3156))
#define GLOBAL_newNanoSafeSpan (*(IU32 *)((IUH)Gdp + 3160))
#define GLOBAL_newHSP (*(IU8* *)((IUH)Gdp + 3164))
#define GLOBAL_newTruePopLimit (*(IU8* *)((IUH)Gdp + 3168))
#define GLOBAL_newTruePushLimit (*(IU8* *)((IUH)Gdp + 3172))
#define GLOBAL_newNotionalSsBase (*(IU8* *)((IUH)Gdp + 3176))
#define GLOBAL_newStackIsWrappable (*(IBOOL *)((IUH)Gdp + 3180 + 3))
#define GLOBAL_newStackIsBig (*(IBOOL *)((IUH)Gdp + 3184 + 3))
#define GLOBAL_newStackMask (*(IU32 *)((IUH)Gdp + 3188))
#define GLOBAL_newLaInBottomPage (*(IU32 *)((IUH)Gdp + 3192))
#define GLOBAL_newHspOK (*(IBOOL *)((IUH)Gdp + 3196 + 3))
#define GLOBAL_newPushScratch (*(IU8* *)((IUH)Gdp + 3200))
#define GLOBAL_newPushScratchInUse (*(IBOOL *)((IUH)Gdp + 3204 + 3))
#define GLOBAL_EOIEnable (*(IU8* *)((IUH)Gdp + 3208))
#define GLOBAL_AddProfilePtr (*(IUH* *)((IUH)Gdp + 3212))
#define GLOBAL_MaxProfileData (*(IUH* *)((IUH)Gdp + 3216))
#define GLOBAL_FreeContextHead (*(struct ContextREC* *)((IUH)Gdp + 3220))
#define GLOBAL_ValidContextHead (*(struct ContextREC* *)((IUH)Gdp + 3224))
#define GLOBAL_CurrentContext (*(IU8 *)((IUH)Gdp + 3228 + 3))
#define GLOBAL_SeenGDTUse (*(IBOOL *)((IUH)Gdp + 3232 + 3))
#define GLOBAL_SeenLDTUse (*(IBOOL *)((IUH)Gdp + 3236 + 3))
#define GLOBAL_Context (*(struct ContextREC* *)((IUH)Gdp + 3240))
#define GLOBAL_tmpESP (*(IUH *)((IUH)Gdp + 3244))
#define GLOBAL_intelPtr (*(IU8* *)((IUH)Gdp + 3248))
#define GLOBAL_functions (*(IU32** *)((IUH)Gdp + 3252))
#define GLOBAL_instrCountdown (*(ISH *)((IUH)Gdp + 3256))
#define GLOBAL_nextPlace (*(IU32* *)((IUH)Gdp + 3260))
#define GLOBAL_cutBackStackCounter (*(IUH *)((IUH)Gdp + 3264))
#define GLOBAL_nanoCompParameter (*(IUH *)((IUH)Gdp + 3268))
#define GLOBAL_intelCopyPtrComp (*(IU8* *)((IUH)Gdp + 3272))
#define GLOBAL_nrOfBlocksToCompile (*(IUH *)((IUH)Gdp + 3276))
#define GLOBAL_first32constraints (*(IU32 *)((IUH)Gdp + 3280))
#define GLOBAL_last16constraints (*(IU16 *)((IUH)Gdp + 3284 + 2))
#define GLOBAL_successorBlockPtr (*(struct BLOCK_RECORD* *)((IUH)Gdp + 3288))
#define GLOBAL_successorBlockNr (*(IUH *)((IUH)Gdp + 3292))
#define GLOBAL_nrOfInstrsParsed (*(IUH *)((IUH)Gdp + 3296))
#define GLOBAL_intelPtrLimit (*(IU8* *)((IUH)Gdp + 3300))
#define GLOBAL_blockStartIntelPtr (*(IU8* *)((IUH)Gdp + 3304))
#define GLOBAL_blockStartCodeOffset (*(IUH *)((IUH)Gdp + 3308))
#define GLOBAL_finalCodeOffset (*(IUH *)((IUH)Gdp + 3312))
#define GLOBAL_blockExitCondition (*(IUH *)((IUH)Gdp + 3316))
#define GLOBAL_blockNr (*(IUH *)((IUH)Gdp + 3320))
#define GLOBAL_blockPtr (*(struct BLOCK_RECORD* *)((IUH)Gdp + 3324))
#define GLOBAL_nextPlaceAgain (*(IU32* *)((IUH)Gdp + 3328))
#define GLOBAL_nanoOp3 (*(IUH *)((IUH)Gdp + 3332))
#define GLOBAL_sibByte (*(IUH *)((IUH)Gdp + 3336))
#define GLOBAL_dynamicOffset (*(IU32 *)((IUH)Gdp + 3340))
#define GLOBAL_eaSegCode (*(IUH *)((IUH)Gdp + 3344))
#define GLOBAL_instrStartIntelPtr (*(IU8* *)((IUH)Gdp + 3348))
#define GLOBAL_topLevel (*(IUH* *)((IUH)Gdp + 3352))
#define GLOBAL_defaultPrimaryActions (*(IU32** *)((IUH)Gdp + 3356))
#define GLOBAL_actualPrimaryActions (*(IU32** *)((IUH)Gdp + 3360))
#define GLOBAL_codeSegment (*(IUH *)((IUH)Gdp + 3364))
#define GLOBAL_codeOffset (*(IUH *)((IUH)Gdp + 3368))
#define GLOBAL_codeSegmentBase (*(IUH *)((IUH)Gdp + 3372))
#define GLOBAL_codeSegmentLimit (*(IUH *)((IUH)Gdp + 3376))
#define GLOBAL_destCodeSegment (*(IUH *)((IUH)Gdp + 3380))
#define GLOBAL_destCodeOffset (*(IUH *)((IUH)Gdp + 3384))
#define GLOBAL_linearAddress (*(IU32 *)((IUH)Gdp + 3388))
#define GLOBAL_nanoEax (*(IU32 *)((IUH)Gdp + 3392))
#define GLOBAL_nanoEcx (*(IU32 *)((IUH)Gdp + 3396))
#define GLOBAL_nanoEdx (*(IU32 *)((IUH)Gdp + 3400))
#define GLOBAL_nanoEbx (*(IU32 *)((IUH)Gdp + 3404))
#define GLOBAL_nanoEsp (*(IU32 *)((IUH)Gdp + 3408))
#define GLOBAL_nanoEbp (*(IU32 *)((IUH)Gdp + 3412))
#define GLOBAL_nanoEsi (*(IU32 *)((IUH)Gdp + 3416))
#define GLOBAL_nanoEdi (*(IU32 *)((IUH)Gdp + 3420))
#define GLOBAL_espToRestore (*(IU32 *)((IUH)Gdp + 3424))
#define GLOBAL_entryExitCount (*(IU32 *)((IUH)Gdp + 3428))
#define GLOBAL_instructionCount (*(IU32 *)((IUH)Gdp + 3432))
#define GLOBAL_nanoDebugControl (*(IU32 *)((IUH)Gdp + 3436))
#define GLOBAL_compilationThreshold (*(IU32 *)((IUH)Gdp + 3440))
#define GLOBAL_hashTableMask (*(IUH *)((IUH)Gdp + 3444))
#define GLOBAL_blockFreeList (*(IUH *)((IUH)Gdp + 3448))
#define GLOBAL_maxBlocksToCompile (*(IUH *)((IUH)Gdp + 3452))
#define GLOBAL_bases (*(IU32* *)((IUH)Gdp + 3456))
#define GLOBAL_descriptors (*(struct GLDC_REC** *)((IUH)Gdp + 3460))
#define GLOBAL_blocksToCompile (*(struct BLOCK_TO_COMPILE* *)((IUH)Gdp + 3464))
#define GLOBAL_byteMemory (*(IU8* *)((IUH)Gdp + 3468))
#define GLOBAL_wordMemory (*(IU16* *)((IUH)Gdp + 3472))
#define GLOBAL_longMemory (*(IU32* *)((IUH)Gdp + 3476))
#define GLOBAL_blockHashChains (*(IU16* *)((IUH)Gdp + 3480))
#define GLOBAL_blockRecords (*(struct BLOCK_RECORD* *)((IUH)Gdp + 3484))
#define GLOBAL_intelCopyMemoryExec (*(IU8* *)((IUH)Gdp + 3488))
#define GLOBAL_intelCopyMemoryComp (*(IU8* *)((IUH)Gdp + 3492))
#define GLOBAL_intelCopyMemoryCompEnd (*(IU8* *)((IUH)Gdp + 3496))
#define GLOBAL_SfDecrementerVal (*(IUH *)((IUH)Gdp + 3500))
#define GLOBAL_SfQEventPending (*(IBOOL *)((IUH)Gdp + 3504 + 3))
#define GLOBAL_LogicalBaseAddrForIO (*(IU8* *)((IUH)Gdp + 3508))
#define GLOBAL_TraceVector ((IU8 *)((IUH)Gdp + 3512))
#define GLOBAL_TraceVectorSize (40001)
#define GDP_SIZE 43513
#define GDP_CHECKSUM 23234201
extern IHP Gdp;
#endif /* _gdpvar_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\gldc_c.h ===
#ifndef _Gldc_c_h
#define _Gldc_c_h
#define N_RPL_BITS (2)
#define RPL_MASK (3)
#define NOT_RPL_MASK (65532)
#define N_GL_SELECTORS (16384)
#define N_IDT_SELECTORS (256)
#define N_CPLS (4)
#define N_RPLS (4)
#define TI_P (2)
#define SEL_S (15)
#define SEL_E (2)
#define INTEL_SEL_S (31)
#define INTEL_SEL_E (16)
#define INTEL_P (15)
#define INTEL_X (22)
#define INTEL_G (23)
#define INTEL_AR_ZERO (21)
#define INTEL_AVL (20)
#define INTEL_HI_LIMIT_S (19)
#define INTEL_HI_LIMIT_E (16)
#define INTEL_HI_LIMIT_SHIFT (16)
#define INTEL_LO_LIMIT_S (15)
#define INTEL_LO_LIMIT_E (0)
#define INTEL_DPL_S (14)
#define INTEL_DPL_E (13)
#define INTEL_SUPERTYPE_S (12)
#define INTEL_SUPERTYPE_E (8)
#define INTEL_HI_BASE_S (31)
#define INTEL_HI_BASE_E (24)
#define INTEL_MID_BASE_S (7)
#define INTEL_MID_BASE_E (0)
#define INTEL_LO_BASE_S (31)
#define INTEL_LO_BASE_E (16)
#define INTEL_HI_BASE_SHIFT (24)
#define INTEL_MID_BASE_SHIFT (16)
#define INTEL_SELECTOR_S (31)
#define INTEL_SELECTOR_E (16)
#define INTEL_HI_OFFSET_S (31)
#define INTEL_HI_OFFSET_E (16)
#define INTEL_TOP_AR_S (23)
#define INTEL_TOP_AR_E (16)
#define INTEL_BOTTOM_AR_S (15)
#define INTEL_BOTTOM_AR_E (8)
#define AR_G (15)
#define AR2_X_BIT (6)
#define AR2_G_BIT (7)
#define AR_SUPERTYPE_S (4)
#define AR_SUPERTYPE_E (0)
#define EAR_SUPERTYPE_MASK (31)
#define EAR_SUPERTYPE_S (4)
#define EAR_SUPERTYPE_E (0)
#define EAR_A_MASK (1)
#define EAR_A (0)
#define EAR_DPL_MASK (96)
#define EAR_DPL_S (6)
#define EAR_DPL_E (5)
#define EAR_P_MASK (128)
#define EAR_P (7)
#define EAR_AR_MASK (255)
#define EAR_AR_S (7)
#define EAR_AR_E (0)
#define EAR_NR_BITS_MASK (3840)
#define EAR_NR_BITS_S (11)
#define EAR_NR_BITS_E (8)
#define EAR_CD_MASK (4096)
#define EAR_CD (12)
#define EAR_NG_BITS_MASK (57344)
#define EAR_NG_BITS_S (15)
#define EAR_NG_BITS_E (13)
#define EAR_NX_BITS_MASK (983040)
#define EAR_NX_BITS_S (19)
#define EAR_NX_BITS_E (16)
#define EAR_NC_MASK (1048576)
#define EAR_NC (20)
#define EAR_NW_MASK (2097152)
#define EAR_NW (21)
#define EAR_NA_MASK (4194304)
#define EAR_NA (22)
#define EAR_NP_MASK (8388608)
#define EAR_NP (23)
#define EAR_NCD_MASK (16777216)
#define EAR_NCD (24)
#define EAR_CONTEXT_MASK (2113929216)
#define EAR_CONTEXT_S (30)
#define EAR_CONTEXT_E (25)
#define EAR_CDODGY_MASK (-2147483648)
#define EAR_CDODGY (31)
#define GPH_LDTH_MASK (1032192)
#define GPH_LDTH_BITS_S (19)
#define GPH_LDTH_BITS_E (14)
#define GPH_SEL_MASK (16383)
#define GPH_SEL_BITS_S (13)
#define GPH_SEL_BITS_E (0)
#define ST_AVAILABLE_TSS (1)
#define ST_LDT_SEGMENT (2)
#define ST_BUSY_TSS (3)
#define ST_CALL_GATE (4)
#define ST_TASK_GATE (5)
#define ST_INTERRUPT_GATE (6)
#define ST_TRAP_GATE (7)
#define ST_INVALID (8)
#define ST_XTND_AVAILABLE_TSS (9)
#define ST_GLDC_DUMMY (10)
#define ST_XTND_BUSY_TSS (11)
#define ST_XTND_CALL_GATE (12)
#define ST_GLDC_NULL (13)
#define ST_XTND_INTERRUPT_GATE (14)
#define ST_XTND_TRAP_GATE (15)
#define ST_EXPANDUP_READONLY_DATA (17)
#define ST_EXPANDUP_WRITEABLE_DATA (19)
#define ST_EXPANDDOWN_READONLY_DATA (21)
#define ST_EXPANDDOWN_WRITEABLE_DATA (23)
#define ST_NONCONFORM_NOREAD_CODE (25)
#define ST_NONCONFORM_READABLE_CODE (27)
#define ST_CONFORM_NOREAD_CODE (29)
#define ST_CONFORM_READABLE_CODE (31)
#define NUM_LDTS (7)
#define LDT_NOT_IN_USE (65535)
#define GLDC_INDEX_TABLE_SIZE (16384)
#define GLDC_RECNULL ((struct GLDC_REC*)0)
#define IDC_RECNULL ((struct IDC_REC*)0)
#define CR_GUARANTEED_BAD (-2147483617)
#define NUM_RECS_IN_BUFFER (204)
#define GLDC_LdDs (0)
#define GLDC_LdSs (4)
#define GLDC_LdCsForCJ (8)
#define GLDC_LdCsForRet (12)
#define GLDC_LdCsForRetRing (16)
#define GLDC_GtCJ (20)
#define GLDC_GtDestCall (21)
#define GLDC_CrCPLSize (22)
#define GLDC_CrLDTSize (88)
#define IDC_NIS_MASK (-16)
#define IDC_NIS_S (31)
#define IDC_NIS_E (4)
#define IDC_NP (3)
#define IDC_NP_MASK (8)
#define IDC_CPL_MASK (3)
#define IDC_CPL_S (2)
#define IDC_CPL_E (0)
#define IDC_IDT_NUM_S (12)
#define IDC_IDT_NUM_E (8)
#define IDC_INT_NUM_S (7)
#define IDC_INT_NUM_E (0)
#define IDC_LOWEST_SEQ_VAL (0)
#define IDC_INITIAL_CONTROL_VAL (-8)
#define NO_PARAMS (0)
struct GLDC_REC
{
	IUH ear;
	IU8 *intelArPtr;
	IU32 base;
	IU32 rlimit;
	IU32 rlimit2;
	IU32 wlimit;
	IU32 wlimit2;
	IU8 arTopByte;
	IU32 glimit;
	struct GLDC_REC *next;
};
struct IDC_REC
{
	IUH eiar;
	IU16 type;
	IU16 sel;
	IU32 offset;
};
struct SEG_STRUCT
{
	IU32 rlimit2;
	IU32 wlimit2;
};
struct IDC_ENTRY
{
	IU32 base;
	IU16 limit;
};
#endif /* ! _Gldc_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\frag_c.h ===
#ifndef _Frag_c_h
#define _Frag_c_h
#define CR0_VALID_BITS (-536543169)
#define EFLAGS_AC (18)
#define EFLAGS_VM (17)
#define EFLAGS_RF (16)
#define EFLAGS_NT (14)
#define EFLAGS_OF (11)
#define EFLAGS_DF (10)
#define EFLAGS_IEF (9)
#define EFLAGS_TF (8)
#define EFLAGS_SF (7)
#define EFLAGS_ZF (6)
#define EFLAGS_AF (4)
#define EFLAGS_PF (2)
#define EFLAGS_CF (0)
#define ARITH_FLAGS_MASK (2261)
#define BaseEFLAGS (2)
#define PermanentEFLAGSbits (-491478)
#define MAIN_CPU (0)
#define NANO_CPU (1)
#define AtNextInstruction (1)
#define AtThisInstruction (0)
#define FtLog (1)
#define FtAdd (4)
#define FtSub (7)
#define FtInc (10)
#define FtDec (13)
#define FtAdc (16)
#define FtSbb (19)
#define FtSar (22)
#define FtShr (25)
#define FtShl (28)
#define FtShd (31)
enum SegmentRegister
{
	SEG_ES = 0,
	SEG_CS = 1,
	SEG_SS = 2,
	SEG_DS = 3,
	SEG_FS = 4,
	SEG_GS = 5
};
enum SpecialRegister
{
	CREG_0 = 0,
	CREG_1 = 1,
	CREG_2 = 2,
	CREG_3 = 3,
	CREG_4 = 4,
	CREG_5 = 5,
	CREG_6 = 6,
	CREG_7 = 7,
	DREG_0 = 8,
	DREG_1 = 9,
	DREG_2 = 10,
	DREG_3 = 11,
	DREG_4 = 12,
	DREG_5 = 13,
	DREG_6 = 14,
	DREG_7 = 15,
	TREG_0 = 16,
	TREG_1 = 17,
	TREG_2 = 18,
	TREG_3 = 19,
	TREG_4 = 20,
	TREG_5 = 21,
	TREG_6 = 22,
	TREG_7 = 23
};
enum FtType
{
	FtZero = 0,
	FtLogB = 1,
	FtLogW = 2,
	FtLogD = 3,
	FtAddB = 4,
	FtAddW = 5,
	FtAddD = 6,
	FtSubB = 7,
	FtSubW = 8,
	FtSubD = 9,
	FtIncB = 10,
	FtIncW = 11,
	FtIncD = 12,
	FtDecB = 13,
	FtDecW = 14,
	FtDecD = 15,
	FtAdcB = 16,
	FtAdcW = 17,
	FtAdcD = 18,
	FtSbbB = 19,
	FtSbbW = 20,
	FtSbbD = 21,
	FtSarB = 22,
	FtSarW = 23,
	FtSarD = 24,
	FtShrB = 25,
	FtShrW = 26,
	FtShrD = 27,
	FtShlB = 28,
	FtShlW = 29,
	FtShlD = 30,
	FtPopf = 31,
	FtShdW = 32,
	FtShdD = 33,
	FtZf = 34,
	FtCf = 35,
	FtCfOf = 36,
	FtCfZf = 37,
	FtCfOfZf = 38,
	FtUnknown = 39
};
enum FtSize
{
	FtB = 0,
	FtW = 1,
	FtD = 2
};
enum CondType
{
	COND_O = 0,
	COND_NO = 1,
	COND_B = 2,
	COND_NB = 3,
	COND_Z = 4,
	COND_NZ = 5,
	COND_BE = 6,
	COND_NBE = 7,
	COND_S = 8,
	COND_NS = 9,
	COND_P = 10,
	COND_NP = 11,
	COND_L = 12,
	COND_NL = 13,
	COND_LE = 14,
	COND_NLE = 15
};
enum EaShapes
{
	EA_DUMMY_ZERO = 0,
	EBX_AL = 1,
	DISP = 2,
	REG = 3,
	REG_DISP = 4,
	REG_REG = 5,
	REG_REG_DISP = 6,
	BASE_SI = 7,
	BASE_SI_DISP = 8,
	OFFS_REG = 9
};
enum CodeShapes
{
	CODE_DUMMY_ZERO = 0,
	AAA = 1,
	AAD = 2,
	AAM = 3,
	AAS = 4,
	ADC = 5,
	ADD = 6,
	AND = 7,
	ARPL = 8,
	BOUND = 9,
	BSF = 10,
	BSR = 11,
	BSWAP = 12,
	BT = 13,
	BTC = 14,
	BTR = 15,
	BTS = 16,
	CALLN_IMM = 17,
	CALLN_VIA = 18,
	CALLF_IMM = 19,
	CALLF_VIA = 20,
	CBW = 21,
	CDQ = 22,
	CLC = 23,
	CLD = 24,
	CLI = 25,
	CLTS = 26,
	CMC = 27,
	CMP = 28,
	CMPXCHG = 29,
	CWD = 30,
	CWDE = 31,
	DAA = 32,
	DAS = 33,
	DEC = 34,
	DIV = 35,
	ENTER = 36,
	ENTER0 = 37,
	ENTER1 = 38,
	F2XM1 = 39,
	FABS = 40,
	FADD = 41,
	FADDP = 42,
	FBLD = 43,
	FBSTP = 44,
	FCHS = 45,
	FCOM = 46,
	FCOMP = 47,
	FCOMPP = 48,
	FCOS = 49,
	FDECSTP = 50,
	FDIV = 51,
	FDIVP = 52,
	FDIVRP = 53,
	FDIVR = 54,
	FFREE = 55,
	FFREEP = 56,
	FINCSTP = 57,
	FLD = 58,
	FLD1 = 59,
	FLDCW = 60,
	FLDENV = 61,
	FLDL2E = 62,
	FLDL2T = 63,
	FLDLG2 = 64,
	FLDLN2 = 65,
	FLDPI = 66,
	FLDZ = 67,
	FMUL = 68,
	FMULP = 69,
	FNCLEX = 70,
	FNINIT = 71,
	FNOP = 72,
	FNSAVE = 73,
	FNSTCW = 74,
	FNSTENV = 75,
	FNSTSW = 76,
	FPATAN = 77,
	FPREM = 78,
	FPREM1 = 79,
	FPTAN = 80,
	FRNDINT = 81,
	FRSTOR = 82,
	FSCALE = 83,
	FSIN = 84,
	FSINCOS = 85,
	FSQRT = 86,
	FST = 87,
	FSTP = 88,
	FSUB = 89,
	FSUBP = 90,
	FSUBRP = 91,
	FSUBR = 92,
	FTST = 93,
	FUCOM = 94,
	FUCOMP = 95,
	FUCOMPP = 96,
	FXAM = 97,
	FXCH = 98,
	FXTRACT = 99,
	FYL2X = 100,
	FYL2XP1 = 101,
	HLT = 102,
	IDIV = 103,
	IMULA = 104,
	IMULI = 105,
	IMUL2 = 106,
	INP = 107,
	INC = 108,
	INT1 = 109,
	INT3 = 110,
	INT7 = 111,
	INTO = 112,
	INTR = 113,
	INVD = 114,
	INVLPG = 115,
	IRET = 116,
	JO = 117,
	JNO = 118,
	JB = 119,
	JNB = 120,
	JZ = 121,
	JNZ = 122,
	JBE = 123,
	JNBE = 124,
	JS = 125,
	JNS = 126,
	JP = 127,
	JNP = 128,
	JL = 129,
	JNL = 130,
	JLE = 131,
	JNLE = 132,
	JCXZ = 133,
	JMPN_IMM = 134,
	JMPN_VIA = 135,
	JMPF_IMM = 136,
	JMPF_VIA = 137,
	LAHF = 138,
	LALCY = 139,
	LAR = 140,
	LDS = 141,
	LEA = 142,
	LEAVE = 143,
	LES = 144,
	LFS = 145,
	LGDT = 146,
	LGS = 147,
	LIDT = 148,
	LLDT = 149,
	LMSW = 150,
	LOOP = 151,
	LOOPE = 152,
	LOOPNE = 153,
	LSL = 154,
	LSS = 155,
	LTR = 156,
	MOV = 157,
	MOVSX = 158,
	MOVZX = 159,
	MUL = 160,
	NEG = 161,
	NOT = 162,
	NOP = 163,
	OR = 164,
	OUTP = 165,
	POP = 166,
	POP_MEM = 167,
	POP_SR = 168,
	POPA = 169,
	POPF = 170,
	PUSH = 171,
	PUSH_SR = 172,
	PUSHA = 173,
	PUSHF = 174,
	RCL = 175,
	RCR = 176,
	RETF = 177,
	RETF_IMM = 178,
	RETN = 179,
	RETN_IMM = 180,
	ROL = 181,
	ROR = 182,
	SAHF = 183,
	SAR = 184,
	SBB = 185,
	SETO = 186,
	SETNO = 187,
	SETB = 188,
	SETNB = 189,
	SETZ = 190,
	SETNZ = 191,
	SETBE = 192,
	SETNBE = 193,
	SETS = 194,
	SETNS = 195,
	SETP = 196,
	SETNP = 197,
	SETL = 198,
	SETNL = 199,
	SETLE = 200,
	SETNLE = 201,
	SGDT = 202,
	SHL = 203,
	SHLD_CL = 204,
	SHLD_IMM = 205,
	SHR = 206,
	SHRD_CL = 207,
	SHRD_IMM = 208,
	SIDT = 209,
	SLDT = 210,
	SMSW = 211,
	STC = 212,
	STD = 213,
	STI = 214,
	STR = 215,
	SUB = 216,
	TEST = 217,
	VERR = 218,
	VERW = 219,
	WAIT = 220,
	WBINVD = 221,
	XADD = 222,
	XCHG = 223,
	XLAT = 224,
	XOR = 225,
	BOP = 226,
	ZBADOP = 227,
	STOS = 228,
	INS = 229,
	LODS = 230,
	MOVS = 231,
	CMPS = 232,
	SCAS = 233,
	OUTS = 234,
	R_STOS = 235,
	R_INS = 236,
	R_LODS = 237,
	R_MOVS = 238,
	RE_CMPS = 239,
	RNE_CMPS = 240,
	RE_SCAS = 241,
	RNE_SCAS = 242,
	R_OUTS = 243,
	RSRVD = 244,
	FRSRVD = 245,
	RD_SEGR = 246,
	WT_SEGR = 247,
	RD_CDT = 248,
	WT_CDT = 249,
	ZADJUST_HSP = 250,
	ZBPI = 251,
	ZDISPATCH_EIP = 252,
	ZJC_PROC = 253,
	ZPAGE_BOUNDARY = 254,
	ZPATCH_ME = 255,
	ZPOST_POP = 256,
	ZRET_TO_COROUTINE = 257,
	ZRESULT_ZERO = 258,
	ZUNSIM = 259
};
#endif /* ! _Frag_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\hpphst_c.h ===
#ifndef _Hpphst_c_h
#define _Hpphst_c_h
#define HppBranchCodeSizeAdjustment (2)
#define HPP_HOST_REG_ZERO (0)
#define HPP_HOST_DEST_REG_ID (13)
#define HPP_HOST_CALL_REG_ID (19)
#define HppFpuOverflowExceptionBit (29)
#define HppFpuUnderflowExceptionBit (28)
#define HppFpuPrecisionExceptionBit (27)
#define HppPureAddressAdjustment (-3)
#define HppCallToRetAddrAdjustment (0)
#endif /* ! _Hpphst_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\io_c.h ===
#ifndef _IO_c_h
#define _IO_c_h
struct PortTablesRec
{
	IU8 *PortToAdaptor;
	IUH **AdaptorToEdlByteFunc;
	IUH **AdaptorToEdlWordFunc;
	IUH **AdaptorToEdlDoubleFunc;
	IUH **AdaptorToCByteFunc;
	IUH **AdaptorToCWordFunc;
	IUH **AdaptorToCDoubleFunc;
};
#endif /* ! _IO_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\inst_c.h ===
#ifndef _Inst_c_h
#define _Inst_c_h
enum NpxOpnds
{
	M16I = 0,
	M32I = 1,
	M64I = 2,
	M32R = 3,
	M64R = 4,
	M80R = 5,
	FPSTACK = 6,
	STACKTOP = 7
};
#endif /* ! _Inst_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\inc_c.h ===
#ifndef _Inc_c_h
#define _Inc_c_h
#endif /* ! _Inc_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\j_c_lang.c ===
#include "insignia.h"
#include "host_def.h"

/*[
 *      Name:           j_c_lang.c
 *
 *      Derived From:   (original)
 *
 *      Author:         Simon Frost
 *
 *      Created On:     December 1993
 *
 *	Sccs ID:	@(#)j_c_lang.c	1.3 07/28/94
 *
 *      Purpose:        Suppory routines for C rule translated J code.
 *			This file must be linked in with any such code.
 *
 *	Design document:
 *			None.
 *
 *	Test document:
 *			None.
 *
 *      (c) Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/

/* variables to represent register usage */
IUH  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,r11,r12,r13,r14,r15,
     r16,r17,r18,r19,r20,r21,r22,r23,r24,r25,r26,r27,r28,r29,r30,r31;
IUH rnull ; /* holder for NULL args */

#define NUM_HBITS	(sizeof(IUH)*8)
#define MAX_BITPOS	(NUM_HBITS - 1)


/*(
=============================== mask =============================
PURPOSE: Build bit mask for use in Jcode operations.
INPUT: bitpos : IUH starting bit position. (0 LSB, MSB at other end)
       len : IUH no of bits in mask.
OUTPUT: Return IUH bitmask.
=========================================================================
)*/
GLOBAL IUH
mask IFN2(IUH, bitpos, IUH, len)
{
    IUH movebit, res;

    if (len == 0)
	return(0);

    if (bitpos > MAX_BITPOS || bitpos < 0)
    {
	printf("mask: bitpos %d out of range\n", bitpos);
	return(0);
    }

    if (len > NUM_HBITS - bitpos)
    {
	printf("mask: len %d too great for starting bitpos %d\n", len, bitpos);
	return(0);
    }

    /* set first bit for mask */
    movebit = (IUH)1 << bitpos;
    res = movebit;
    /* now fill in bits to left */
    while(--len)
    {
	movebit <<= 1;
	res |= movebit;
    }
    return(res);
}

/*(
=============================== rorl =============================
PURPOSE: Rotate a long (IUH) right.
INPUT: src : IUH initial value.
       rots : IUH no of bit places to rotate.
OUTPUT: Return IUH rotated result.
=========================================================================
)*/
GLOBAL IUH
rorl IFN2(IUH, src, IUH, rots)
{
	IUH temp, res;

	rots %= 32;
	temp = src & mask(rots - 1, rots);
	res = (src >> rots) | (temp << (32 - rots));
	return(res);
}

/*(
=============================== rorw =============================
PURPOSE: Rotate the bottom word of an IUH right.
INPUT: src : IUH initial value.
       rots : IUH no of bit places to rotate.
OUTPUT: Return IUH rotated result.
=========================================================================
)*/
GLOBAL IUH
rorw IFN2(IUH, src, IUH, rots)
{
	IUH temp, res;

	/* make copy of word and into two halves of temp & do one shift */
	rots %= 16;

	temp = src & 0xffff;
	temp |= temp << 16;
	temp >>= rots;
	res = src & (IUH)-65536; /* 0xffff0000 or 64 bit equiv */
	res |= temp & 0xffff;
	return(res);
}

/*(
=============================== rorb =============================
PURPOSE: Rotate the bottom byte of an IUH right.
INPUT: src : IUH initial value.
       rots : IUH no of bit places to rotate.
OUTPUT: Return IUH rotated result.
=========================================================================
)*/
GLOBAL IUH
rorb IFN2(IUH, src, IUH, rots)
{
	IUH res;
	IU16 temp;

	/* make copy of byte and into two halves of temp & do one shift */
	rots %= 8;

	temp = src & 0xff;
	temp |= temp << 8;
	temp >>= rots;
	res = src & (IUH)-256; /* 0xffffff00 or 64 bit equiv */
	res |= temp & 0xff;
	return(res);
}

/*(
=============================== roll =============================
PURPOSE: Rotate a long (IUH) left.
INPUT: src : IUH initial value.
       rots : IUH no of bit places to rotate.
OUTPUT: Return IUH rotated result.
=========================================================================
)*/
GLOBAL IUH
roll IFN2(IUH, src, IUH, rots)
{
	IUH temp, res;

	rots %= 32;
	temp = src & mask(31, rots);
	res = (src << rots) | (temp >> (32 - rots));
	return(res);
}

/*(
=============================== rolw =============================
PURPOSE: Rotate the bottom word of an IUH left.
INPUT: src : IUH initial value.
       rots : IUH no of bit places to rotate.
OUTPUT: Return IUH rotated result.
=========================================================================
)*/
GLOBAL IUH
rolw IFN2(IUH, src, IUH, rots)
{
	IUH temp, res;

	/* make copy of word and into two halves of temp & do one shift */
	rots %= 16;

	temp = src & 0xffff;
	temp |= temp << 16;
	temp <<= rots;
	res = src & (IUH)-65536; /* 0xffff0000 or 64 bit equiv */
	res |= temp >> 16;
	return(res);
}

/*(
=============================== rolb =============================
PURPOSE: Rotate the bottom byte of an IUH left.
INPUT: src : IUH initial value.
       rots : IUH no of bit places to rotate.
OUTPUT: Return IUH rotated result.
=========================================================================
)*/
GLOBAL IUH
rolb IFN2(IUH, src, IUH, rots)
{
	IUH res;
	IU16 temp;

	/* make copy of byte and into two halves of temp & do one shift */
	rots %= 8;

	temp = src & 0xff;
	temp |= temp << 8;
	temp <<= rots;
	res = src & (IUH)-256; /* 0xffffff00 or 64 bit equiv */
	res |= temp >> 8;
	return(res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\idmain_c.h ===
#ifndef _IdMain_c_h
#define _IdMain_c_h
#endif /* ! _IdMain_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\light_c.h ===
#ifndef _Light_c_h
#define _Light_c_h
#endif /* ! _Light_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\j_c_lang.h ===
/*
 *      Name:           j_c_lang.h
 *
 *      Author:         Simon Frost
 *
 *      Created on:     February 1994
 *
 *      SccsID:         @(#)j_c_lang.h	1.2 06/17/94
 *
 *      Purpose:        This file contains the necessary declarations for C
 *                      files generated from J-code.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 */
/* defines needed for basic types */
#define	jccc_parm1 r2 
#define	jccc_parm2 r3 
#define	jccc_parm3 r4 
#define	jccc_parm4 r5 
#define	jccc_gdp r1 
/* define variables (register replacements) used */
extern IUH	rnull ; /* holder for a null arg in calls and null return args */
extern IUH	r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,r11,r12,r13,r14,r15,
		r16,r17,r18,r19,r20,r21,r22,r23,r24,r25,r26,r27,r28,r29,r30,r31;

/* prototypes for support functions - see j_c_lang.c ? how many are used */
extern IUH mask IPT2(IUH, bitpos, IUH, len);
extern IUH rorl IPT2(IUH, src, IUH, rots);
extern IUH rorw IPT2(IUH, src, IUH, rots);
extern IUH rorb IPT2(IUH, src, IUH, rots);
extern IUH roll IPT2(IUH, src, IUH, rots);
extern IUH rolw IPT2(IUH, src, IUH, rots);
extern IUH rolb IPT2(IUH, src, IUH, rots);

#ifdef LITTLEND
#define	UOFF_15_8(a)	(((IU8 *)(a))+1)
#define	SOFF_15_8(a)	(((IS8 *)(a))+1)
#define	REGBYTE		0
#define	REGWORD		0
#define	REGLONG		0
#endif
#ifdef BIGEND
#define UOFF_15_8(a)	((IU8 *)(a) + sizeof(IUH)-2)
#define SOFF_15_8(a)	((IS8 *)(a) + sizeof(IUH)-2)
#define	REGBYTE		(sizeof(IUH) -1)
#define	REGWORD		(sizeof(IUH)/2 -1)
#define	REGLONG		(sizeof(IUH)/4 -1)
#endif
#define __J_C_LANG	/* mark as already included */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\lc_c.h ===
#ifndef _Lc_c_h
#define _Lc_c_h
#define NUM_HASH_BITS (6)
#define HASH_MASK (63)
#define BYTES_PER_HCU (4)
#define MORE_PRS_MASK (128)
#define JUMP_REC_NULL ((struct JUMP_REC*)0)
#define CODE_ELEM_NULL ((IU32*)0)
#define MAX_JUMP_REC_PER_FRAG (33)
#define VCT_NODE_REC_NULL ((struct VCT_NODE_REC*)0)
enum AccessType
{
	ACCESS_NA = 0,
	ACCESS_READ = 1,
	ACCESS_WRITE = 2,
	ACCESS_READ_WRITE = 3
};
enum CopierActionPhase
{
	CpActionPhaseInstruction = 0,
	CpActionPhaseCopying = 1,
	CpActionPhaseExecute = 2
};
enum CopierAction
{
	CopierActionCopyZero = 0,
	CopierActionCopyOne = 1,
	CopierActionCopyTwo = 2,
	CopierActionCopyThree = 3,
	CopierActionCopyFour = 4,
	CopierActionCopyFive = 5,
	CopierActionCopySix = 6,
	CopierActionCopyVariable = 7,
	CopierActionPatchBlock = 8,
	CopierActionPatchBlockEnd = 9,
	CopierActionPatchMeBody = 10,
	CopierActionSubrId = 11,
	CopierActionSubrIdEnd = 12,
	CopierActionNpxExceptionData = 13,
	CopierActionNeedNextIntelEip = 14,
	CopierActionTupleImm = 15,
	CopierActionTupleDisp = 16,
	CopierActionTupleImm2 = 17,
	CopierActionTupleRetEIP = 18,
	CopierActionTearOffFlags = 19,
	CopierActionSetsFt = 20,
	CopierActionTrackFt = 21,
	CopierActionSrcFt = 22,
	CopierNoteSrcEAX = 23,
	CopierNoteSrcAX = 24,
	CopierNoteDstEAX = 25,
	CopierNoteDstAX = 26,
	CopierNoteDstAL = 27,
	CopierNoteSrcEBX = 28,
	CopierNoteSrcBX = 29,
	CopierNoteDstEBX = 30,
	CopierNoteDstBX = 31,
	CopierNoteDstBL = 32,
	CopierNoteSrcECX = 33,
	CopierNoteSrcCX = 34,
	CopierNoteDstECX = 35,
	CopierNoteDstCX = 36,
	CopierNoteDstCL = 37,
	CopierNoteSrcEDX = 38,
	CopierNoteSrcDX = 39,
	CopierNoteDstEDX = 40,
	CopierNoteDstDX = 41,
	CopierNoteDstDL = 42,
	CopierNoteSrcEBP = 43,
	CopierNoteDstEBP = 44,
	CopierNoteDstBP = 45,
	CopierNoteSrcEDI = 46,
	CopierNoteDstEDI = 47,
	CopierNoteDstDI = 48,
	CopierNoteSrcESI = 49,
	CopierNoteDstESI = 50,
	CopierNoteDstSI = 51,
	CopierNoteAddConstraintEAX = 52,
	CopierNoteRemoveConstraintEAX = 53,
	CopierNoteAddConstraintAX = 54,
	CopierNoteRemoveConstraintAX = 55,
	CopierNoteAddConstraintEBX = 56,
	CopierNoteRemoveConstraintEBX = 57,
	CopierNoteAddConstraintBX = 58,
	CopierNoteRemoveConstraintBX = 59,
	CopierNoteAddConstraintECX = 60,
	CopierNoteRemoveConstraintECX = 61,
	CopierNoteAddConstraintCX = 62,
	CopierNoteRemoveConstraintCX = 63,
	CopierNoteAddConstraintEDX = 64,
	CopierNoteRemoveConstraintEDX = 65,
	CopierNoteAddConstraintDX = 66,
	CopierNoteRemoveConstraintDX = 67,
	CopierNoteAddSingleInstruction = 68,
	CopierNoteProcessSingleInstruction = 69,
	CopierNoteSrcESP = 70,
	UnusedCopierNoteSrcSP = 71,
	CopierNotePostDstSP = 72,
	CopierNotePostDstESP = 73,
	CopierNotePostCommitPop = 74,
	CopierNoteHspTrackAbs = 75,
	CopierNoteHspTrackOpnd = 76,
	CopierNoteHspTrackReset = 77,
	CopierNoteHspAdjust = 78,
	CopierNotePigSynch = 79,
	CopierNoteMissPigSynch = 80,
	CopierNoteSrcUniverse = 81,
	CopierNoteSetDF = 82,
	CopierNoteClearDF = 83,
	CopierNoteBPILabel = 84,
	CopierActionLast = 85
};
enum CopyEnum
{
	CopyOne = 0,
	CopyTwo = 1,
	CopyThree = 2,
	CopyFour = 3,
	CopyFive = 4,
	CopySix = 5
};
struct VCT_NODE_REC
{
	IU8 actionRecord[3];
	IU8 nextNode;
	IU32 vsMask;
	IU32 vsMatch;
	IU32 codeRecord[1];
};
struct TUPLE_REC
{
	IS32 disp;
	IU32 immed;
	IU32 immed2;
	IU32 start_eip;
	IU32 ret_eip;
	IU32 flags;
	IU32 cvs;
	IU8 control;
	IU8 intel_length;
	IU16 ea_EFI;
	IU16 aux_ea_EFI;
	IU16 access_EFI;
	IU16 access_type;
	IU16 business_EFI;
	IBOOL opnd32;
};
struct JUMP_REC
{
	IU32 intelEa;
	IU32 *hostAddr;
	struct EntryPointCacheREC *univ;
	struct JUMP_REC *next;
	struct JUMP_REC *prev;
};
#endif /* ! _Lc_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\lxs_c.h ===
#ifndef _LxS_c_h
#define _LxS_c_h
#endif /* ! _LxS_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\mark_c.h ===
#ifndef _Mark_c_h
#define _Mark_c_h
#endif /* ! _Mark_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\logic_c.h ===
#ifndef _Logic_c_h
#define _Logic_c_h
#endif /* ! _Logic_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\move_c.h ===
#ifndef _Move_c_h
#define _Move_c_h
#endif /* ! _Move_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\misc_c.h ===
#ifndef _Misc_c_h
#define _Misc_c_h
#endif /* ! _Misc_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\muldiv_c.h ===
#ifndef _MulDiv_c_h
#define _MulDiv_c_h
#define UNDEF_FLAG (0)
#define CF_OF_CLEAR (0)
#define CF_OF_SET (2049)
#define SF_ZF_PF_AF_UNDEF (0)
#define ALL_UNDEF (0)
#endif /* ! _MulDiv_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\nanoa_c.h ===
#ifndef _NanoA_c_h
#define _NanoA_c_h
#endif /* ! _NanoA_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\nanoc_c.h ===
#ifndef _NanoC_c_h
#define _NanoC_c_h
#endif /* ! _NanoC_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\nanoe_c.h ===
#ifndef _NanoE_c_h
#define _NanoE_c_h
#endif /* ! _NanoE_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\nanob_c.h ===
#ifndef _NanoB_c_h
#define _NanoB_c_h
#endif /* ! _NanoB_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\page_c.h ===
#ifndef _Page_c_h
#define _Page_c_h
#define PDTE_Present (0)
#define PDTE_Writeable (1)
#define PDTE_User (2)
#define PDTE_Pwt (3)
#define PDTE_Pcd (4)
#define PDTE_Accessed (5)
#define PDTE_Dirty (6)
#define PDTE_Ignore_E (7)
#define PDTE_Ignore_S (11)
#define PDTE_IgnoreMask (3992)
#define CanSetAccessedDirty (1)
#define PreserveAccessedDirty (0)
#define VirtualiseRmCodeSel (61440)
#define DelayedPDTEoverwiteNULL ((struct DelayedPDTEoverwiteREC*)0)
enum VirtualisationKind
{
	VirtualiseRead = 0,
	VirtualiseWrite = 1,
	VirtualiseInput = 2,
	VirtualiseOutput = 3,
	VirtualiseSti = 4,
	VirtualiseCli = 5,
	VirtualiseNone = 6
};
struct VirtEntryPointsBySizeREC
{
	IU16 bySize[4];
};
struct VirtualisationBIOSOffsetsREC
{
	struct VirtEntryPointsBySizeREC byKind[6];
};
struct DelayedPDTEoverwiteREC
{
	IU32 address;
	IU16 next;
};
#endif /* ! _Page_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\nanod_c.h ===
#ifndef _NanoD_c_h
#define _NanoD_c_h
#endif /* ! _NanoD_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\nano_c.h ===
#ifndef _Nano_c_h
#define _Nano_c_h
#define BYTE_SIZED (0)
#define WORD_SIZED (1)
#define LONG_SIZED (2)
#define ES_CODE (0)
#define CS_CODE (1)
#define SS_CODE (2)
#define DS_CODE (3)
#define FS_CODE (4)
#define GS_CODE (5)
#define EAX_CODE (0)
#define ECX_CODE (1)
#define EDX_CODE (2)
#define EBX_CODE (3)
#define ESP_CODE (4)
#define EBP_CODE (5)
#define ESI_CODE (6)
#define EDI_CODE (7)
#define MEM_CODE (8)
#define JUMP (0)
#define FALLTHROUGH (1)
#define TRUNCATION (2)
#define LEAVING (3)
#define NOT_APPLICABLE (4)
#define COMPILE_BLOCK (1)
#define LOG_SF_BREAK (2)
#define LOG_NORMAL_FLOW (3)
#define LOG_ABNORMAL_FLOW (4)
#define PARSE_AHEAD (5)
#define MONITOR_DS_CHANGE (6)
#define MONITOR_DS_USE (7)
#define BLOCK_LENGTH_CHANGE (8)
#define PROT_BIT (0)
#define V86_BIT (1)
#define BIG_CODE_BIT (2)
#define DF_BIT (3)
#define EAX_FORM_16 (4)
#define EAX_FORM_8 (5)
#define EBX_FORM_16 (6)
#define EBX_FORM_8 (7)
#define ECX_FORM_16 (8)
#define ECX_FORM_8 (9)
#define EDX_FORM_16 (10)
#define EDX_FORM_8 (11)
#define EBP_FORM_16 (12)
#define ESI_FORM_16 (13)
#define EDI_FORM_16 (14)
#define BIG_STACK_BIT (15)
#define DS_DEFAULT_SEG_BOT (16)
#define DS_DEFAULT_SEG_TOP (18)
#define SS_DEFAULT_SEG_BOT (19)
#define SS_DEFAULT_SEG_TOP (21)
#define ADDRESS_SIZE_TOGGLE_BIT (22)
#define OPERAND_SIZE_TOGGLE_BIT (23)
#define RESTORE_ESP_ON_EXCEPTION_BIT (24)
#define REP_E_BIT (25)
#define REP_NE_BIT (26)
#define EAX_BITMAP_BIT (0)
#define ECX_BITMAP_BIT (1)
#define EDX_BITMAP_BIT (2)
#define EBX_BITMAP_BIT (3)
#define ESP_BITMAP_BIT (4)
#define EBP_BITMAP_BIT (5)
#define ESI_BITMAP_BIT (6)
#define EDI_BITMAP_BIT (7)
#define ES_BITMAP_BIT (8)
#define CS_BITMAP_BIT (9)
#define SS_BITMAP_BIT (10)
#define DS_BITMAP_BIT (11)
#define FS_BITMAP_BIT (12)
#define GS_BITMAP_BIT (13)
#define HAS_AN_EA_REC_BIT (14)
#define INSTR_CONTINUATION_BIT (15)
#define NOTHING_BASE (1)
#define AX_BASE (2)
#define CX_BASE (3)
#define DX_BASE (4)
#define BX_BASE (5)
#define SP_BASE (6)
#define BP_BASE (7)
#define SI_BASE (8)
#define DI_BASE (9)
#define EAX_BASE (10)
#define ECX_BASE (11)
#define EDX_BASE (12)
#define EBX_BASE (13)
#define ESP_BASE (14)
#define EBP_BASE (15)
#define ESI_BASE (16)
#define EDI_BASE (17)
#define NOTHING_INDEX (0)
#define AX_INDEX (64)
#define CX_INDEX (96)
#define DX_INDEX (128)
#define BX_INDEX (160)
#define SP_INDEX (192)
#define BP_INDEX (224)
#define SI_INDEX (256)
#define DI_INDEX (288)
#define EAX_INDEX (320)
#define ECX_INDEX (352)
#define EDX_INDEX (384)
#define EBX_INDEX (416)
#define ESP_INDEX (448)
#define EBP_INDEX (480)
#define ESI_INDEX (512)
#define EDI_INDEX (544)
#define ES_SEGFORM (0)
#define CS_SEGFORM (1024)
#define SS_SEGFORM (2048)
#define DS_SEGFORM (3072)
#define FS_SEGFORM (4096)
#define GS_SEGFORM (5120)
#define NOTHING_MUL (0)
#define MUL_2 (8192)
#define MUL_4 (16384)
#define MUL_8 (24576)
#define READ_ACCESS_BIT (0)
#define WRITE_ACCESS_BIT (1)
#define ACCESS_LENGTH_BOT (2)
#define ACCESS_LENGTH_TOP (7)
#define GET_AXBX_FORM (0)
#define GET_CXDX_FORM (16)
#define GET_BPSIDI_FORM (32)
#define PUT_AXBX_FORM (40)
#define PUT_CXDX_FORM (56)
#define PUT_BPSIDI_FORM (72)
#define READ_OP1 (80)
#define WRITE_OP1 (107)
#define READ_SEG_OP1 (134)
#define WRITE_SEG_OP1 (142)
#define WRITE_SEG_OP2 (150)
#define WRITE_OP2 (158)
#define READ_OP1_RETURN (185)
#define WRITE_OP1_BYTE_RETURN (212)
#define PUSH_OP1 (221)
#define POP_OP1 (223)
#define EA_OPERATIONS (225)
#define SIB_BASE_FUNCTIONS (281)
#define SIB_INDEX_FUNCTIONS (305)
#define ADD_OPERATIONS (337)
#define TEST_OPERATIONS (553)
#define JCC_OPERATIONS (580)
#define INC_OPERATIONS (596)
#define DEC_OPERATIONS (623)
#define NEG_OPERATIONS (650)
#define NOT_OPERATIONS (677)
#define MUL_OPERATIONS (704)
#define IMUL_OPERATIONS (707)
#define DIV_OPERATIONS (710)
#define IDIV_OPERATIONS (713)
#define IMUL3_OPERATIONS (716)
#define IMUL2_OPERATIONS (734)
#define SHIFT_OPERATIONS (752)
#define ARPL_OPERATIONS (968)
#define SETCC_OPERATIONS (977)
#define SHLD_OPERATIONS (993)
#define SHRD_OPERATIONS (1011)
#define BT_OPERATIONS (1029)
#define BTS_OPERATIONS (1047)
#define BTR_OPERATIONS (1065)
#define BTC_OPERATIONS (1083)
struct DEST_RECORD
{
	IU16 block;
	IU8 version;
	IU8 count;
};
struct BLOCK_RECORD
{
	IU16 hashNext;
	IU8 intelLength;
	IU8 compiled;
	IU32 linearAddress;
	IU32 first32constraints;
	IU16 last16constraints;
	IU16 codeSegment;
	IU16 hashPrev;
	IU16 moreRecent;
	IU16 lessRecent;
	IU8 version;
	IU8 execCount;
	struct DEST_RECORD dest1;
	struct DEST_RECORD dest2;
};
#endif /* ! _Nano_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\pigger_c.h ===
#ifndef _Pigger_c_h
#define _Pigger_c_h
#define ValidEAX (3)
#define ValidEBX (7)
#define ValidECX (15)
#define ValidEDX (11)
#define ValidEBP (13)
#define ValidESP (15)
#define ValidESI (17)
#define ValidEDI (19)
#define PigSynchNULL ((struct PigSynchREC*)0)
#define PigHashTableShift (12)
#define PigHashTableSize (4096)
#define PigHashTableMask (4095)
enum PigValidItems
{
	ValidAL = 0,
	ValidAH = 1,
	ValidEAX_MS16 = 2,
	ValidBL = 3,
	ValidBH = 4,
	ValidEBX_MS16 = 5,
	ValidCL = 6,
	ValidCH = 7,
	ValidECX_MS16 = 8,
	ValidDL = 9,
	ValidDH = 10,
	ValidEDX_MS16 = 11,
	ValidBP = 12,
	ValidEBP_MS16 = 13,
	ValidSP = 14,
	ValidESP_MS16 = 15,
	ValidSI = 16,
	ValidESI_MS16 = 17,
	ValidDI = 18,
	ValidEDI_MS16 = 19,
	ValidDS = 20,
	ValidES = 21,
	ValidFS = 22,
	ValidGS = 23,
	ValidCF = 24,
	ValidPF = 25,
	ValidAF = 26,
	ValidZF = 27,
	ValidSF = 28,
	ValidOF = 29
};
struct PigSynchREC
{
	IU32 linearAddress;
	void *hostAddress;
	void *hostDestination;
	IU32 trueCode0;
	IU32 trueCode1;
	IU32 validRegAndFlags;
	struct PigSyncREC *nextList;
	struct PigSyncREC *prevList;
	struct PigSyncREC *deleteList;
};
struct CpuRegsREC
{
	IU32 CR0;
	IU32 PFLA;
	IU32 PDBR;
	IU8 CPL;
	IU32 EIP;
	IU32 EAX;
	IU32 EBX;
	IU32 ECX;
	IU32 EDX;
	IU32 ESP;
	IU32 EBP;
	IU32 ESI;
	IU32 EDI;
	IU32 EFLAGS;
	IU32 GDT_base;
	IU16 GDT_limit;
	IU32 IDT_base;
	IU16 IDT_limit;
	IU32 LDT_base;
	IU32 LDT_limit;
	IU16 LDT_selector;
	IU32 TR_base;
	IU32 TR_limit;
	IU16 TR_ar;
	IU16 TR_selector;
	IU32 DS_base;
	IU32 DS_limit;
	IU16 DS_ar;
	IU16 DS_selector;
	IU32 ES_base;
	IU32 ES_limit;
	IU16 ES_ar;
	IU16 ES_selector;
	IU32 SS_base;
	IU32 SS_limit;
	IU16 SS_ar;
	IU16 SS_selector;
	IU32 CS_base;
	IU32 CS_limit;
	IU16 CS_ar;
	IU16 CS_selector;
	IU32 FS_base;
	IU32 FS_limit;
	IU16 FS_ar;
	IU16 FS_selector;
	IU32 GS_base;
	IU32 GS_limit;
	IU16 GS_ar;
	IU16 GS_selector;
};
struct NpxRegsREC
{
	IU32 NPX_control;
	IU32 NPX_status;
	IU32 NPX_tagword;
	struct FPSTACKENTRY NPX_ST[8];
};
struct CpuStateREC
{
	struct CpuRegsREC cpu_regs;
	IU32 video_latches;
	IBOOL twenty_bit_wrap;
	IBOOL NPX_valid;
	struct NpxRegsREC NPX_regs;
	IUH synch_index;
};
#endif /* ! _Pigger_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\parser.h ===
#ifndef LC_HARN
#define EBX_AL_BX_AL 1
#define EBX_AL_EBX_AL 2
#define DISP_DISPW 3
#define DISP_DISPD 4
#define REG_SI 5
#define REG_DI 6
#define REG_BX 7
#define REG_EAX 8
#define REG_ECX 9
#define REG_EDX 10
#define REG_EBX 11
#define REG_ESI 12
#define REG_EDI 13
#define REG_BLDR_ESP 14
#define REG_DISP_SI_DISPW 15
#define REG_DISP_DI_DISPW 16
#define REG_DISP_BP_DISPW 17
#define REG_DISP_BX_DISPW 18
#define REG_DISP_EAX_DISPD 19
#define REG_DISP_ECX_DISPD 20
#define REG_DISP_EDX_DISPD 21
#define REG_DISP_EBX_DISPD 22
#define REG_DISP_BLDR_ESP_DISPD 23
#define REG_DISP_EBP_DISPD 24
#define REG_DISP_ESI_DISPD 25
#define REG_DISP_EDI_DISPD 26
#define REG_REG_BX_SI 27
#define REG_REG_BP_SI 28
#define REG_REG_BX_DI 29
#define REG_REG_BP_DI 30
#define REG_REG_DISP_BX_SI_DISPW 31
#define REG_REG_DISP_BP_SI_DISPW 32
#define REG_REG_DISP_BX_DI_DISPW 33
#define REG_REG_DISP_BP_DI_DISPW 34
#define BASE_SI_EAX_EAX_CONST_1 35
#define BASE_SI_ECX_EAX_CONST_1 36
#define BASE_SI_EDX_EAX_CONST_1 37
#define BASE_SI_EBX_EAX_CONST_1 38
#define BASE_SI_BLDR_ESP_EAX_CONST_1 39
#define BASE_SI_DISPD_EAX_CONST_1 40
#define BASE_SI_ESI_EAX_CONST_1 41
#define BASE_SI_EDI_EAX_CONST_1 42
#define BASE_SI_EAX_ECX_CONST_1 43
#define BASE_SI_ECX_ECX_CONST_1 44
#define BASE_SI_EDX_ECX_CONST_1 45
#define BASE_SI_EBX_ECX_CONST_1 46
#define BASE_SI_BLDR_ESP_ECX_CONST_1 47
#define BASE_SI_DISPD_ECX_CONST_1 48
#define BASE_SI_ESI_ECX_CONST_1 49
#define BASE_SI_EDI_ECX_CONST_1 50
#define BASE_SI_EAX_EDX_CONST_1 51
#define BASE_SI_ECX_EDX_CONST_1 52
#define BASE_SI_EDX_EDX_CONST_1 53
#define BASE_SI_EBX_EDX_CONST_1 54
#define BASE_SI_BLDR_ESP_EDX_CONST_1 55
#define BASE_SI_DISPD_EDX_CONST_1 56
#define BASE_SI_ESI_EDX_CONST_1 57
#define BASE_SI_EDI_EDX_CONST_1 58
#define BASE_SI_EAX_EBX_CONST_1 59
#define BASE_SI_ECX_EBX_CONST_1 60
#define BASE_SI_EDX_EBX_CONST_1 61
#define BASE_SI_EBX_EBX_CONST_1 62
#define BASE_SI_BLDR_ESP_EBX_CONST_1 63
#define BASE_SI_DISPD_EBX_CONST_1 64
#define BASE_SI_ESI_EBX_CONST_1 65
#define BASE_SI_EDI_EBX_CONST_1 66
#define BASE_SI_EAX_UNDEF_CONST_1 67
#define BASE_SI_ECX_UNDEF_CONST_1 68
#define BASE_SI_EDX_UNDEF_CONST_1 69
#define BASE_SI_EBX_UNDEF_CONST_1 70
#define BASE_SI_BLDR_ESP_UNDEF_CONST_1 71
#define BASE_SI_DISPD_UNDEF_CONST_1 72
#define BASE_SI_ESI_UNDEF_CONST_1 73
#define BASE_SI_EDI_UNDEF_CONST_1 74
#define BASE_SI_EAX_EBP_CONST_1 75
#define BASE_SI_ECX_EBP_CONST_1 76
#define BASE_SI_EDX_EBP_CONST_1 77
#define BASE_SI_EBX_EBP_CONST_1 78
#define BASE_SI_BLDR_ESP_EBP_CONST_1 79
#define BASE_SI_DISPD_EBP_CONST_1 80
#define BASE_SI_ESI_EBP_CONST_1 81
#define BASE_SI_EDI_EBP_CONST_1 82
#define BASE_SI_EAX_ESI_CONST_1 83
#define BASE_SI_ECX_ESI_CONST_1 84
#define BASE_SI_EDX_ESI_CONST_1 85
#define BASE_SI_EBX_ESI_CONST_1 86
#define BASE_SI_BLDR_ESP_ESI_CONST_1 87
#define BASE_SI_DISPD_ESI_CONST_1 88
#define BASE_SI_ESI_ESI_CONST_1 89
#define BASE_SI_EDI_ESI_CONST_1 90
#define BASE_SI_EAX_EDI_CONST_1 91
#define BASE_SI_ECX_EDI_CONST_1 92
#define BASE_SI_EDX_EDI_CONST_1 93
#define BASE_SI_EBX_EDI_CONST_1 94
#define BASE_SI_BLDR_ESP_EDI_CONST_1 95
#define BASE_SI_DISPD_EDI_CONST_1 96
#define BASE_SI_ESI_EDI_CONST_1 97
#define BASE_SI_EDI_EDI_CONST_1 98
#define BASE_SI_EAX_EAX_CONST_2 99
#define BASE_SI_ECX_EAX_CONST_2 100
#define BASE_SI_EDX_EAX_CONST_2 101
#define BASE_SI_EBX_EAX_CONST_2 102
#define BASE_SI_BLDR_ESP_EAX_CONST_2 103
#define BASE_SI_DISPD_EAX_CONST_2 104
#define BASE_SI_ESI_EAX_CONST_2 105
#define BASE_SI_EDI_EAX_CONST_2 106
#define BASE_SI_EAX_ECX_CONST_2 107
#define BASE_SI_ECX_ECX_CONST_2 108
#define BASE_SI_EDX_ECX_CONST_2 109
#define BASE_SI_EBX_ECX_CONST_2 110
#define BASE_SI_BLDR_ESP_ECX_CONST_2 111
#define BASE_SI_DISPD_ECX_CONST_2 112
#define BASE_SI_ESI_ECX_CONST_2 113
#define BASE_SI_EDI_ECX_CONST_2 114
#define BASE_SI_EAX_EDX_CONST_2 115
#define BASE_SI_ECX_EDX_CONST_2 116
#define BASE_SI_EDX_EDX_CONST_2 117
#define BASE_SI_EBX_EDX_CONST_2 118
#define BASE_SI_BLDR_ESP_EDX_CONST_2 119
#define BASE_SI_DISPD_EDX_CONST_2 120
#define BASE_SI_ESI_EDX_CONST_2 121
#define BASE_SI_EDI_EDX_CONST_2 122
#define BASE_SI_EAX_EBX_CONST_2 123
#define BASE_SI_ECX_EBX_CONST_2 124
#define BASE_SI_EDX_EBX_CONST_2 125
#define BASE_SI_EBX_EBX_CONST_2 126
#define BASE_SI_BLDR_ESP_EBX_CONST_2 127
#define BASE_SI_DISPD_EBX_CONST_2 128
#define BASE_SI_ESI_EBX_CONST_2 129
#define BASE_SI_EDI_EBX_CONST_2 130
#define BASE_SI_EAX_UNDEF_CONST_2 131
#define BASE_SI_ECX_UNDEF_CONST_2 132
#define BASE_SI_EDX_UNDEF_CONST_2 133
#define BASE_SI_EBX_UNDEF_CONST_2 134
#define BASE_SI_BLDR_ESP_UNDEF_CONST_2 135
#define BASE_SI_DISPD_UNDEF_CONST_2 136
#define BASE_SI_ESI_UNDEF_CONST_2 137
#define BASE_SI_EDI_UNDEF_CONST_2 138
#define BASE_SI_EAX_EBP_CONST_2 139
#define BASE_SI_ECX_EBP_CONST_2 140
#define BASE_SI_EDX_EBP_CONST_2 141
#define BASE_SI_EBX_EBP_CONST_2 142
#define BASE_SI_BLDR_ESP_EBP_CONST_2 143
#define BASE_SI_DISPD_EBP_CONST_2 144
#define BASE_SI_ESI_EBP_CONST_2 145
#define BASE_SI_EDI_EBP_CONST_2 146
#define BASE_SI_EAX_ESI_CONST_2 147
#define BASE_SI_ECX_ESI_CONST_2 148
#define BASE_SI_EDX_ESI_CONST_2 149
#define BASE_SI_EBX_ESI_CONST_2 150
#define BASE_SI_BLDR_ESP_ESI_CONST_2 151
#define BASE_SI_DISPD_ESI_CONST_2 152
#define BASE_SI_ESI_ESI_CONST_2 153
#define BASE_SI_EDI_ESI_CONST_2 154
#define BASE_SI_EAX_EDI_CONST_2 155
#define BASE_SI_ECX_EDI_CONST_2 156
#define BASE_SI_EDX_EDI_CONST_2 157
#define BASE_SI_EBX_EDI_CONST_2 158
#define BASE_SI_BLDR_ESP_EDI_CONST_2 159
#define BASE_SI_DISPD_EDI_CONST_2 160
#define BASE_SI_ESI_EDI_CONST_2 161
#define BASE_SI_EDI_EDI_CONST_2 162
#define BASE_SI_EAX_EAX_CONST_4 163
#define BASE_SI_ECX_EAX_CONST_4 164
#define BASE_SI_EDX_EAX_CONST_4 165
#define BASE_SI_EBX_EAX_CONST_4 166
#define BASE_SI_BLDR_ESP_EAX_CONST_4 167
#define BASE_SI_DISPD_EAX_CONST_4 168
#define BASE_SI_ESI_EAX_CONST_4 169
#define BASE_SI_EDI_EAX_CONST_4 170
#define BASE_SI_EAX_ECX_CONST_4 171
#define BASE_SI_ECX_ECX_CONST_4 172
#define BASE_SI_EDX_ECX_CONST_4 173
#define BASE_SI_EBX_ECX_CONST_4 174
#define BASE_SI_BLDR_ESP_ECX_CONST_4 175
#define BASE_SI_DISPD_ECX_CONST_4 176
#define BASE_SI_ESI_ECX_CONST_4 177
#define BASE_SI_EDI_ECX_CONST_4 178
#define BASE_SI_EAX_EDX_CONST_4 179
#define BASE_SI_ECX_EDX_CONST_4 180
#define BASE_SI_EDX_EDX_CONST_4 181
#define BASE_SI_EBX_EDX_CONST_4 182
#define BASE_SI_BLDR_ESP_EDX_CONST_4 183
#define BASE_SI_DISPD_EDX_CONST_4 184
#define BASE_SI_ESI_EDX_CONST_4 185
#define BASE_SI_EDI_EDX_CONST_4 186
#define BASE_SI_EAX_EBX_CONST_4 187
#define BASE_SI_ECX_EBX_CONST_4 188
#define BASE_SI_EDX_EBX_CONST_4 189
#define BASE_SI_EBX_EBX_CONST_4 190
#define BASE_SI_BLDR_ESP_EBX_CONST_4 191
#define BASE_SI_DISPD_EBX_CONST_4 192
#define BASE_SI_ESI_EBX_CONST_4 193
#define BASE_SI_EDI_EBX_CONST_4 194
#define BASE_SI_EAX_UNDEF_CONST_4 195
#define BASE_SI_ECX_UNDEF_CONST_4 196
#define BASE_SI_EDX_UNDEF_CONST_4 197
#define BASE_SI_EBX_UNDEF_CONST_4 198
#define BASE_SI_BLDR_ESP_UNDEF_CONST_4 199
#define BASE_SI_DISPD_UNDEF_CONST_4 200
#define BASE_SI_ESI_UNDEF_CONST_4 201
#define BASE_SI_EDI_UNDEF_CONST_4 202
#define BASE_SI_EAX_EBP_CONST_4 203
#define BASE_SI_ECX_EBP_CONST_4 204
#define BASE_SI_EDX_EBP_CONST_4 205
#define BASE_SI_EBX_EBP_CONST_4 206
#define BASE_SI_BLDR_ESP_EBP_CONST_4 207
#define BASE_SI_DISPD_EBP_CONST_4 208
#define BASE_SI_ESI_EBP_CONST_4 209
#define BASE_SI_EDI_EBP_CONST_4 210
#define BASE_SI_EAX_ESI_CONST_4 211
#define BASE_SI_ECX_ESI_CONST_4 212
#define BASE_SI_EDX_ESI_CONST_4 213
#define BASE_SI_EBX_ESI_CONST_4 214
#define BASE_SI_BLDR_ESP_ESI_CONST_4 215
#define BASE_SI_DISPD_ESI_CONST_4 216
#define BASE_SI_ESI_ESI_CONST_4 217
#define BASE_SI_EDI_ESI_CONST_4 218
#define BASE_SI_EAX_EDI_CONST_4 219
#define BASE_SI_ECX_EDI_CONST_4 220
#define BASE_SI_EDX_EDI_CONST_4 221
#define BASE_SI_EBX_EDI_CONST_4 222
#define BASE_SI_BLDR_ESP_EDI_CONST_4 223
#define BASE_SI_DISPD_EDI_CONST_4 224
#define BASE_SI_ESI_EDI_CONST_4 225
#define BASE_SI_EDI_EDI_CONST_4 226
#define BASE_SI_EAX_EAX_CONST_8 227
#define BASE_SI_ECX_EAX_CONST_8 228
#define BASE_SI_EDX_EAX_CONST_8 229
#define BASE_SI_EBX_EAX_CONST_8 230
#define BASE_SI_BLDR_ESP_EAX_CONST_8 231
#define BASE_SI_DISPD_EAX_CONST_8 232
#define BASE_SI_ESI_EAX_CONST_8 233
#define BASE_SI_EDI_EAX_CONST_8 234
#define BASE_SI_EAX_ECX_CONST_8 235
#define BASE_SI_ECX_ECX_CONST_8 236
#define BASE_SI_EDX_ECX_CONST_8 237
#define BASE_SI_EBX_ECX_CONST_8 238
#define BASE_SI_BLDR_ESP_ECX_CONST_8 239
#define BASE_SI_DISPD_ECX_CONST_8 240
#define BASE_SI_ESI_ECX_CONST_8 241
#define BASE_SI_EDI_ECX_CONST_8 242
#define BASE_SI_EAX_EDX_CONST_8 243
#define BASE_SI_ECX_EDX_CONST_8 244
#define BASE_SI_EDX_EDX_CONST_8 245
#define BASE_SI_EBX_EDX_CONST_8 246
#define BASE_SI_BLDR_ESP_EDX_CONST_8 247
#define BASE_SI_DISPD_EDX_CONST_8 248
#define BASE_SI_ESI_EDX_CONST_8 249
#define BASE_SI_EDI_EDX_CONST_8 250
#define BASE_SI_EAX_EBX_CONST_8 251
#define BASE_SI_ECX_EBX_CONST_8 252
#define BASE_SI_EDX_EBX_CONST_8 253
#define BASE_SI_EBX_EBX_CONST_8 254
#define BASE_SI_BLDR_ESP_EBX_CONST_8 255
#define BASE_SI_DISPD_EBX_CONST_8 256
#define BASE_SI_ESI_EBX_CONST_8 257
#define BASE_SI_EDI_EBX_CONST_8 258
#define BASE_SI_EAX_UNDEF_CONST_8 259
#define BASE_SI_ECX_UNDEF_CONST_8 260
#define BASE_SI_EDX_UNDEF_CONST_8 261
#define BASE_SI_EBX_UNDEF_CONST_8 262
#define BASE_SI_BLDR_ESP_UNDEF_CONST_8 263
#define BASE_SI_DISPD_UNDEF_CONST_8 264
#define BASE_SI_ESI_UNDEF_CONST_8 265
#define BASE_SI_EDI_UNDEF_CONST_8 266
#define BASE_SI_EAX_EBP_CONST_8 267
#define BASE_SI_ECX_EBP_CONST_8 268
#define BASE_SI_EDX_EBP_CONST_8 269
#define BASE_SI_EBX_EBP_CONST_8 270
#define BASE_SI_BLDR_ESP_EBP_CONST_8 271
#define BASE_SI_DISPD_EBP_CONST_8 272
#define BASE_SI_ESI_EBP_CONST_8 273
#define BASE_SI_EDI_EBP_CONST_8 274
#define BASE_SI_EAX_ESI_CONST_8 275
#define BASE_SI_ECX_ESI_CONST_8 276
#define BASE_SI_EDX_ESI_CONST_8 277
#define BASE_SI_EBX_ESI_CONST_8 278
#define BASE_SI_BLDR_ESP_ESI_CONST_8 279
#define BASE_SI_DISPD_ESI_CONST_8 280
#define BASE_SI_ESI_ESI_CONST_8 281
#define BASE_SI_EDI_ESI_CONST_8 282
#define BASE_SI_EAX_EDI_CONST_8 283
#define BASE_SI_ECX_EDI_CONST_8 284
#define BASE_SI_EDX_EDI_CONST_8 285
#define BASE_SI_EBX_EDI_CONST_8 286
#define BASE_SI_BLDR_ESP_EDI_CONST_8 287
#define BASE_SI_DISPD_EDI_CONST_8 288
#define BASE_SI_ESI_EDI_CONST_8 289
#define BASE_SI_EDI_EDI_CONST_8 290
#define BASE_SI_DISP_EAX_EAX_DISPD_CONST_1 291
#define BASE_SI_DISP_ECX_EAX_DISPD_CONST_1 292
#define BASE_SI_DISP_EDX_EAX_DISPD_CONST_1 293
#define BASE_SI_DISP_EBX_EAX_DISPD_CONST_1 294
#define BASE_SI_DISP_BLDR_ESP_EAX_DISPD_CONST_1 295
#define BASE_SI_DISP_EBP_EAX_DISPD_CONST_1 296
#define BASE_SI_DISP_ESI_EAX_DISPD_CONST_1 297
#define BASE_SI_DISP_EDI_EAX_DISPD_CONST_1 298
#define BASE_SI_DISP_EAX_ECX_DISPD_CONST_1 299
#define BASE_SI_DISP_ECX_ECX_DISPD_CONST_1 300
#define BASE_SI_DISP_EDX_ECX_DISPD_CONST_1 301
#define BASE_SI_DISP_EBX_ECX_DISPD_CONST_1 302
#define BASE_SI_DISP_BLDR_ESP_ECX_DISPD_CONST_1 303
#define BASE_SI_DISP_EBP_ECX_DISPD_CONST_1 304
#define BASE_SI_DISP_ESI_ECX_DISPD_CONST_1 305
#define BASE_SI_DISP_EDI_ECX_DISPD_CONST_1 306
#define BASE_SI_DISP_EAX_EDX_DISPD_CONST_1 307
#define BASE_SI_DISP_ECX_EDX_DISPD_CONST_1 308
#define BASE_SI_DISP_EDX_EDX_DISPD_CONST_1 309
#define BASE_SI_DISP_EBX_EDX_DISPD_CONST_1 310
#define BASE_SI_DISP_BLDR_ESP_EDX_DISPD_CONST_1 311
#define BASE_SI_DISP_EBP_EDX_DISPD_CONST_1 312
#define BASE_SI_DISP_ESI_EDX_DISPD_CONST_1 313
#define BASE_SI_DISP_EDI_EDX_DISPD_CONST_1 314
#define BASE_SI_DISP_EAX_EBX_DISPD_CONST_1 315
#define BASE_SI_DISP_ECX_EBX_DISPD_CONST_1 316
#define BASE_SI_DISP_EDX_EBX_DISPD_CONST_1 317
#define BASE_SI_DISP_EBX_EBX_DISPD_CONST_1 318
#define BASE_SI_DISP_BLDR_ESP_EBX_DISPD_CONST_1 319
#define BASE_SI_DISP_EBP_EBX_DISPD_CONST_1 320
#define BASE_SI_DISP_ESI_EBX_DISPD_CONST_1 321
#define BASE_SI_DISP_EDI_EBX_DISPD_CONST_1 322
#define BASE_SI_DISP_EAX_UNDEF_DISPD_CONST_1 323
#define BASE_SI_DISP_ECX_UNDEF_DISPD_CONST_1 324
#define BASE_SI_DISP_EDX_UNDEF_DISPD_CONST_1 325
#define BASE_SI_DISP_EBX_UNDEF_DISPD_CONST_1 326
#define BASE_SI_DISP_BLDR_ESP_UNDEF_DISPD_CONST_1 327
#define BASE_SI_DISP_EBP_UNDEF_DISPD_CONST_1 328
#define BASE_SI_DISP_ESI_UNDEF_DISPD_CONST_1 329
#define BASE_SI_DISP_EDI_UNDEF_DISPD_CONST_1 330
#define BASE_SI_DISP_EAX_EBP_DISPD_CONST_1 331
#define BASE_SI_DISP_ECX_EBP_DISPD_CONST_1 332
#define BASE_SI_DISP_EDX_EBP_DISPD_CONST_1 333
#define BASE_SI_DISP_EBX_EBP_DISPD_CONST_1 334
#define BASE_SI_DISP_BLDR_ESP_EBP_DISPD_CONST_1 335
#define BASE_SI_DISP_EBP_EBP_DISPD_CONST_1 336
#define BASE_SI_DISP_ESI_EBP_DISPD_CONST_1 337
#define BASE_SI_DISP_EDI_EBP_DISPD_CONST_1 338
#define BASE_SI_DISP_EAX_ESI_DISPD_CONST_1 339
#define BASE_SI_DISP_ECX_ESI_DISPD_CONST_1 340
#define BASE_SI_DISP_EDX_ESI_DISPD_CONST_1 341
#define BASE_SI_DISP_EBX_ESI_DISPD_CONST_1 342
#define BASE_SI_DISP_BLDR_ESP_ESI_DISPD_CONST_1 343
#define BASE_SI_DISP_EBP_ESI_DISPD_CONST_1 344
#define BASE_SI_DISP_ESI_ESI_DISPD_CONST_1 345
#define BASE_SI_DISP_EDI_ESI_DISPD_CONST_1 346
#define BASE_SI_DISP_EAX_EDI_DISPD_CONST_1 347
#define BASE_SI_DISP_ECX_EDI_DISPD_CONST_1 348
#define BASE_SI_DISP_EDX_EDI_DISPD_CONST_1 349
#define BASE_SI_DISP_EBX_EDI_DISPD_CONST_1 350
#define BASE_SI_DISP_BLDR_ESP_EDI_DISPD_CONST_1 351
#define BASE_SI_DISP_EBP_EDI_DISPD_CONST_1 352
#define BASE_SI_DISP_ESI_EDI_DISPD_CONST_1 353
#define BASE_SI_DISP_EDI_EDI_DISPD_CONST_1 354
#define BASE_SI_DISP_EAX_EAX_DISPD_CONST_2 355
#define BASE_SI_DISP_ECX_EAX_DISPD_CONST_2 356
#define BASE_SI_DISP_EDX_EAX_DISPD_CONST_2 357
#define BASE_SI_DISP_EBX_EAX_DISPD_CONST_2 358
#define BASE_SI_DISP_BLDR_ESP_EAX_DISPD_CONST_2 359
#define BASE_SI_DISP_EBP_EAX_DISPD_CONST_2 360
#define BASE_SI_DISP_ESI_EAX_DISPD_CONST_2 361
#define BASE_SI_DISP_EDI_EAX_DISPD_CONST_2 362
#define BASE_SI_DISP_EAX_ECX_DISPD_CONST_2 363
#define BASE_SI_DISP_ECX_ECX_DISPD_CONST_2 364
#define BASE_SI_DISP_EDX_ECX_DISPD_CONST_2 365
#define BASE_SI_DISP_EBX_ECX_DISPD_CONST_2 366
#define BASE_SI_DISP_BLDR_ESP_ECX_DISPD_CONST_2 367
#define BASE_SI_DISP_EBP_ECX_DISPD_CONST_2 368
#define BASE_SI_DISP_ESI_ECX_DISPD_CONST_2 369
#define BASE_SI_DISP_EDI_ECX_DISPD_CONST_2 370
#define BASE_SI_DISP_EAX_EDX_DISPD_CONST_2 371
#define BASE_SI_DISP_ECX_EDX_DISPD_CONST_2 372
#define BASE_SI_DISP_EDX_EDX_DISPD_CONST_2 373
#define BASE_SI_DISP_EBX_EDX_DISPD_CONST_2 374
#define BASE_SI_DISP_BLDR_ESP_EDX_DISPD_CONST_2 375
#define BASE_SI_DISP_EBP_EDX_DISPD_CONST_2 376
#define BASE_SI_DISP_ESI_EDX_DISPD_CONST_2 377
#define BASE_SI_DISP_EDI_EDX_DISPD_CONST_2 378
#define BASE_SI_DISP_EAX_EBX_DISPD_CONST_2 379
#define BASE_SI_DISP_ECX_EBX_DISPD_CONST_2 380
#define BASE_SI_DISP_EDX_EBX_DISPD_CONST_2 381
#define BASE_SI_DISP_EBX_EBX_DISPD_CONST_2 382
#define BASE_SI_DISP_BLDR_ESP_EBX_DISPD_CONST_2 383
#define BASE_SI_DISP_EBP_EBX_DISPD_CONST_2 384
#define BASE_SI_DISP_ESI_EBX_DISPD_CONST_2 385
#define BASE_SI_DISP_EDI_EBX_DISPD_CONST_2 386
#define BASE_SI_DISP_EAX_UNDEF_DISPD_CONST_2 387
#define BASE_SI_DISP_ECX_UNDEF_DISPD_CONST_2 388
#define BASE_SI_DISP_EDX_UNDEF_DISPD_CONST_2 389
#define BASE_SI_DISP_EBX_UNDEF_DISPD_CONST_2 390
#define BASE_SI_DISP_BLDR_ESP_UNDEF_DISPD_CONST_2 391
#define BASE_SI_DISP_EBP_UNDEF_DISPD_CONST_2 392
#define BASE_SI_DISP_ESI_UNDEF_DISPD_CONST_2 393
#define BASE_SI_DISP_EDI_UNDEF_DISPD_CONST_2 394
#define BASE_SI_DISP_EAX_EBP_DISPD_CONST_2 395
#define BASE_SI_DISP_ECX_EBP_DISPD_CONST_2 396
#define BASE_SI_DISP_EDX_EBP_DISPD_CONST_2 397
#define BASE_SI_DISP_EBX_EBP_DISPD_CONST_2 398
#define BASE_SI_DISP_BLDR_ESP_EBP_DISPD_CONST_2 399
#define BASE_SI_DISP_EBP_EBP_DISPD_CONST_2 400
#define BASE_SI_DISP_ESI_EBP_DISPD_CONST_2 401
#define BASE_SI_DISP_EDI_EBP_DISPD_CONST_2 402
#define BASE_SI_DISP_EAX_ESI_DISPD_CONST_2 403
#define BASE_SI_DISP_ECX_ESI_DISPD_CONST_2 404
#define BASE_SI_DISP_EDX_ESI_DISPD_CONST_2 405
#define BASE_SI_DISP_EBX_ESI_DISPD_CONST_2 406
#define BASE_SI_DISP_BLDR_ESP_ESI_DISPD_CONST_2 407
#define BASE_SI_DISP_EBP_ESI_DISPD_CONST_2 408
#define BASE_SI_DISP_ESI_ESI_DISPD_CONST_2 409
#define BASE_SI_DISP_EDI_ESI_DISPD_CONST_2 410
#define BASE_SI_DISP_EAX_EDI_DISPD_CONST_2 411
#define BASE_SI_DISP_ECX_EDI_DISPD_CONST_2 412
#define BASE_SI_DISP_EDX_EDI_DISPD_CONST_2 413
#define BASE_SI_DISP_EBX_EDI_DISPD_CONST_2 414
#define BASE_SI_DISP_BLDR_ESP_EDI_DISPD_CONST_2 415
#define BASE_SI_DISP_EBP_EDI_DISPD_CONST_2 416
#define BASE_SI_DISP_ESI_EDI_DISPD_CONST_2 417
#define BASE_SI_DISP_EDI_EDI_DISPD_CONST_2 418
#define BASE_SI_DISP_EAX_EAX_DISPD_CONST_4 419
#define BASE_SI_DISP_ECX_EAX_DISPD_CONST_4 420
#define BASE_SI_DISP_EDX_EAX_DISPD_CONST_4 421
#define BASE_SI_DISP_EBX_EAX_DISPD_CONST_4 422
#define BASE_SI_DISP_BLDR_ESP_EAX_DISPD_CONST_4 423
#define BASE_SI_DISP_EBP_EAX_DISPD_CONST_4 424
#define BASE_SI_DISP_ESI_EAX_DISPD_CONST_4 425
#define BASE_SI_DISP_EDI_EAX_DISPD_CONST_4 426
#define BASE_SI_DISP_EAX_ECX_DISPD_CONST_4 427
#define BASE_SI_DISP_ECX_ECX_DISPD_CONST_4 428
#define BASE_SI_DISP_EDX_ECX_DISPD_CONST_4 429
#define BASE_SI_DISP_EBX_ECX_DISPD_CONST_4 430
#define BASE_SI_DISP_BLDR_ESP_ECX_DISPD_CONST_4 431
#define BASE_SI_DISP_EBP_ECX_DISPD_CONST_4 432
#define BASE_SI_DISP_ESI_ECX_DISPD_CONST_4 433
#define BASE_SI_DISP_EDI_ECX_DISPD_CONST_4 434
#define BASE_SI_DISP_EAX_EDX_DISPD_CONST_4 435
#define BASE_SI_DISP_ECX_EDX_DISPD_CONST_4 436
#define BASE_SI_DISP_EDX_EDX_DISPD_CONST_4 437
#define BASE_SI_DISP_EBX_EDX_DISPD_CONST_4 438
#define BASE_SI_DISP_BLDR_ESP_EDX_DISPD_CONST_4 439
#define BASE_SI_DISP_EBP_EDX_DISPD_CONST_4 440
#define BASE_SI_DISP_ESI_EDX_DISPD_CONST_4 441
#define BASE_SI_DISP_EDI_EDX_DISPD_CONST_4 442
#define BASE_SI_DISP_EAX_EBX_DISPD_CONST_4 443
#define BASE_SI_DISP_ECX_EBX_DISPD_CONST_4 444
#define BASE_SI_DISP_EDX_EBX_DISPD_CONST_4 445
#define BASE_SI_DISP_EBX_EBX_DISPD_CONST_4 446
#define BASE_SI_DISP_BLDR_ESP_EBX_DISPD_CONST_4 447
#define BASE_SI_DISP_EBP_EBX_DISPD_CONST_4 448
#define BASE_SI_DISP_ESI_EBX_DISPD_CONST_4 449
#define BASE_SI_DISP_EDI_EBX_DISPD_CONST_4 450
#define BASE_SI_DISP_EAX_UNDEF_DISPD_CONST_4 451
#define BASE_SI_DISP_ECX_UNDEF_DISPD_CONST_4 452
#define BASE_SI_DISP_EDX_UNDEF_DISPD_CONST_4 453
#define BASE_SI_DISP_EBX_UNDEF_DISPD_CONST_4 454
#define BASE_SI_DISP_BLDR_ESP_UNDEF_DISPD_CONST_4 455
#define BASE_SI_DISP_EBP_UNDEF_DISPD_CONST_4 456
#define BASE_SI_DISP_ESI_UNDEF_DISPD_CONST_4 457
#define BASE_SI_DISP_EDI_UNDEF_DISPD_CONST_4 458
#define BASE_SI_DISP_EAX_EBP_DISPD_CONST_4 459
#define BASE_SI_DISP_ECX_EBP_DISPD_CONST_4 460
#define BASE_SI_DISP_EDX_EBP_DISPD_CONST_4 461
#define BASE_SI_DISP_EBX_EBP_DISPD_CONST_4 462
#define BASE_SI_DISP_BLDR_ESP_EBP_DISPD_CONST_4 463
#define BASE_SI_DISP_EBP_EBP_DISPD_CONST_4 464
#define BASE_SI_DISP_ESI_EBP_DISPD_CONST_4 465
#define BASE_SI_DISP_EDI_EBP_DISPD_CONST_4 466
#define BASE_SI_DISP_EAX_ESI_DISPD_CONST_4 467
#define BASE_SI_DISP_ECX_ESI_DISPD_CONST_4 468
#define BASE_SI_DISP_EDX_ESI_DISPD_CONST_4 469
#define BASE_SI_DISP_EBX_ESI_DISPD_CONST_4 470
#define BASE_SI_DISP_BLDR_ESP_ESI_DISPD_CONST_4 471
#define BASE_SI_DISP_EBP_ESI_DISPD_CONST_4 472
#define BASE_SI_DISP_ESI_ESI_DISPD_CONST_4 473
#define BASE_SI_DISP_EDI_ESI_DISPD_CONST_4 474
#define BASE_SI_DISP_EAX_EDI_DISPD_CONST_4 475
#define BASE_SI_DISP_ECX_EDI_DISPD_CONST_4 476
#define BASE_SI_DISP_EDX_EDI_DISPD_CONST_4 477
#define BASE_SI_DISP_EBX_EDI_DISPD_CONST_4 478
#define BASE_SI_DISP_BLDR_ESP_EDI_DISPD_CONST_4 479
#define BASE_SI_DISP_EBP_EDI_DISPD_CONST_4 480
#define BASE_SI_DISP_ESI_EDI_DISPD_CONST_4 481
#define BASE_SI_DISP_EDI_EDI_DISPD_CONST_4 482
#define BASE_SI_DISP_EAX_EAX_DISPD_CONST_8 483
#define BASE_SI_DISP_ECX_EAX_DISPD_CONST_8 484
#define BASE_SI_DISP_EDX_EAX_DISPD_CONST_8 485
#define BASE_SI_DISP_EBX_EAX_DISPD_CONST_8 486
#define BASE_SI_DISP_BLDR_ESP_EAX_DISPD_CONST_8 487
#define BASE_SI_DISP_EBP_EAX_DISPD_CONST_8 488
#define BASE_SI_DISP_ESI_EAX_DISPD_CONST_8 489
#define BASE_SI_DISP_EDI_EAX_DISPD_CONST_8 490
#define BASE_SI_DISP_EAX_ECX_DISPD_CONST_8 491
#define BASE_SI_DISP_ECX_ECX_DISPD_CONST_8 492
#define BASE_SI_DISP_EDX_ECX_DISPD_CONST_8 493
#define BASE_SI_DISP_EBX_ECX_DISPD_CONST_8 494
#define BASE_SI_DISP_BLDR_ESP_ECX_DISPD_CONST_8 495
#define BASE_SI_DISP_EBP_ECX_DISPD_CONST_8 496
#define BASE_SI_DISP_ESI_ECX_DISPD_CONST_8 497
#define BASE_SI_DISP_EDI_ECX_DISPD_CONST_8 498
#define BASE_SI_DISP_EAX_EDX_DISPD_CONST_8 499
#define BASE_SI_DISP_ECX_EDX_DISPD_CONST_8 500
#define BASE_SI_DISP_EDX_EDX_DISPD_CONST_8 501
#define BASE_SI_DISP_EBX_EDX_DISPD_CONST_8 502
#define BASE_SI_DISP_BLDR_ESP_EDX_DISPD_CONST_8 503
#define BASE_SI_DISP_EBP_EDX_DISPD_CONST_8 504
#define BASE_SI_DISP_ESI_EDX_DISPD_CONST_8 505
#define BASE_SI_DISP_EDI_EDX_DISPD_CONST_8 506
#define BASE_SI_DISP_EAX_EBX_DISPD_CONST_8 507
#define BASE_SI_DISP_ECX_EBX_DISPD_CONST_8 508
#define BASE_SI_DISP_EDX_EBX_DISPD_CONST_8 509
#define BASE_SI_DISP_EBX_EBX_DISPD_CONST_8 510
#define BASE_SI_DISP_BLDR_ESP_EBX_DISPD_CONST_8 511
#define BASE_SI_DISP_EBP_EBX_DISPD_CONST_8 512
#define BASE_SI_DISP_ESI_EBX_DISPD_CONST_8 513
#define BASE_SI_DISP_EDI_EBX_DISPD_CONST_8 514
#define BASE_SI_DISP_EAX_UNDEF_DISPD_CONST_8 515
#define BASE_SI_DISP_ECX_UNDEF_DISPD_CONST_8 516
#define BASE_SI_DISP_EDX_UNDEF_DISPD_CONST_8 517
#define BASE_SI_DISP_EBX_UNDEF_DISPD_CONST_8 518
#define BASE_SI_DISP_BLDR_ESP_UNDEF_DISPD_CONST_8 519
#define BASE_SI_DISP_EBP_UNDEF_DISPD_CONST_8 520
#define BASE_SI_DISP_ESI_UNDEF_DISPD_CONST_8 521
#define BASE_SI_DISP_EDI_UNDEF_DISPD_CONST_8 522
#define BASE_SI_DISP_EAX_EBP_DISPD_CONST_8 523
#define BASE_SI_DISP_ECX_EBP_DISPD_CONST_8 524
#define BASE_SI_DISP_EDX_EBP_DISPD_CONST_8 525
#define BASE_SI_DISP_EBX_EBP_DISPD_CONST_8 526
#define BASE_SI_DISP_BLDR_ESP_EBP_DISPD_CONST_8 527
#define BASE_SI_DISP_EBP_EBP_DISPD_CONST_8 528
#define BASE_SI_DISP_ESI_EBP_DISPD_CONST_8 529
#define BASE_SI_DISP_EDI_EBP_DISPD_CONST_8 530
#define BASE_SI_DISP_EAX_ESI_DISPD_CONST_8 531
#define BASE_SI_DISP_ECX_ESI_DISPD_CONST_8 532
#define BASE_SI_DISP_EDX_ESI_DISPD_CONST_8 533
#define BASE_SI_DISP_EBX_ESI_DISPD_CONST_8 534
#define BASE_SI_DISP_BLDR_ESP_ESI_DISPD_CONST_8 535
#define BASE_SI_DISP_EBP_ESI_DISPD_CONST_8 536
#define BASE_SI_DISP_ESI_ESI_DISPD_CONST_8 537
#define BASE_SI_DISP_EDI_ESI_DISPD_CONST_8 538
#define BASE_SI_DISP_EAX_EDI_DISPD_CONST_8 539
#define BASE_SI_DISP_ECX_EDI_DISPD_CONST_8 540
#define BASE_SI_DISP_EDX_EDI_DISPD_CONST_8 541
#define BASE_SI_DISP_EBX_EDI_DISPD_CONST_8 542
#define BASE_SI_DISP_BLDR_ESP_EDI_DISPD_CONST_8 543
#define BASE_SI_DISP_EBP_EDI_DISPD_CONST_8 544
#define BASE_SI_DISP_ESI_EDI_DISPD_CONST_8 545
#define BASE_SI_DISP_EDI_EDI_DISPD_CONST_8 546
#define OFFS_REG_AX 547
#define OFFS_REG_CX 548
#define OFFS_REG_DX 549
#define OFFS_REG_BX 550
#define OFFS_REG_BLDR_SP 551
#define OFFS_REG_BP 552
#define OFFS_REG_SI 553
#define OFFS_REG_DI 554
#define OFFS_REG_EAX 555
#define OFFS_REG_ECX 556
#define OFFS_REG_EDX 557
#define OFFS_REG_EBX 558
#define OFFS_REG_BLDR_ESP 559
#define OFFS_REG_EBP 560
#define OFFS_REG_ESI 561
#define OFFS_REG_EDI 562
#define ACCESS_ES_RW_B 563
#define ACCESS_CS_RW_B 564
#define ACCESS_SS_RW_B 565
#define ACCESS_DS_RW_B 566
#define ACCESS_FS_RW_B 567
#define ACCESS_GS_RW_B 568
#define ACCESS_ES_RW_W 569
#define ACCESS_CS_RW_W 570
#define ACCESS_SS_RW_W 571
#define ACCESS_DS_RW_W 572
#define ACCESS_FS_RW_W 573
#define ACCESS_GS_RW_W 574
#define ACCESS_ES_RW_D 575
#define ACCESS_CS_RW_D 576
#define ACCESS_SS_RW_D 577
#define ACCESS_DS_RW_D 578
#define ACCESS_FS_RW_D 579
#define ACCESS_GS_RW_D 580
#define ACCESS_ES_RD_B 581
#define ACCESS_CS_RD_B 582
#define ACCESS_SS_RD_B 583
#define ACCESS_DS_RD_B 584
#define ACCESS_FS_RD_B 585
#define ACCESS_GS_RD_B 586
#define ACCESS_ES_RD_W 587
#define ACCESS_CS_RD_W 588
#define ACCESS_SS_RD_W 589
#define ACCESS_DS_RD_W 590
#define ACCESS_FS_RD_W 591
#define ACCESS_GS_RD_W 592
#define ACCESS_ES_RD_D 593
#define ACCESS_CS_RD_D 594
#define ACCESS_SS_RD_D 595
#define ACCESS_DS_RD_D 596
#define ACCESS_FS_RD_D 597
#define ACCESS_GS_RD_D 598
#define ACCESS_ES_WT_B 599
#define ACCESS_CS_WT_B 600
#define ACCESS_SS_WT_B 601
#define ACCESS_DS_WT_B 602
#define ACCESS_FS_WT_B 603
#define ACCESS_GS_WT_B 604
#define ACCESS_ES_WT_W 605
#define ACCESS_CS_WT_W 606
#define ACCESS_SS_WT_W 607
#define ACCESS_DS_WT_W 608
#define ACCESS_FS_WT_W 609
#define ACCESS_GS_WT_W 610
#define ACCESS_ES_WT_D 611
#define ACCESS_CS_WT_D 612
#define ACCESS_SS_WT_D 613
#define ACCESS_DS_WT_D 614
#define ACCESS_FS_WT_D 615
#define ACCESS_GS_WT_D 616
#define ACCESS_ES_RD_W2 617
#define ACCESS_CS_RD_W2 618
#define ACCESS_SS_RD_W2 619
#define ACCESS_DS_RD_W2 620
#define ACCESS_FS_RD_W2 621
#define ACCESS_GS_RD_W2 622
#define ACCESS_ES_RD_WD 623
#define ACCESS_CS_RD_WD 624
#define ACCESS_SS_RD_WD 625
#define ACCESS_DS_RD_WD 626
#define ACCESS_FS_RD_WD 627
#define ACCESS_GS_RD_WD 628
#define ACCESS_ES_RD_DW 629
#define ACCESS_CS_RD_DW 630
#define ACCESS_SS_RD_DW 631
#define ACCESS_DS_RD_DW 632
#define ACCESS_FS_RD_DW 633
#define ACCESS_GS_RD_DW 634
#define ACCESS_ES_WT_WD 635
#define ACCESS_CS_WT_WD 636
#define ACCESS_SS_WT_WD 637
#define ACCESS_DS_WT_WD 638
#define ACCESS_FS_WT_WD 639
#define ACCESS_GS_WT_WD 640
#define ACCESS_ES_RD_8B 641
#define ACCESS_CS_RD_8B 642
#define ACCESS_SS_RD_8B 643
#define ACCESS_DS_RD_8B 644
#define ACCESS_FS_RD_8B 645
#define ACCESS_GS_RD_8B 646
#define ACCESS_ES_WT_8B 647
#define ACCESS_CS_WT_8B 648
#define ACCESS_SS_WT_8B 649
#define ACCESS_DS_WT_8B 650
#define ACCESS_FS_WT_8B 651
#define ACCESS_GS_WT_8B 652
#define ACCESS_ES_RD_10B 653
#define ACCESS_CS_RD_10B 654
#define ACCESS_SS_RD_10B 655
#define ACCESS_DS_RD_10B 656
#define ACCESS_FS_RD_10B 657
#define ACCESS_GS_RD_10B 658
#define ACCESS_ES_WT_10B 659
#define ACCESS_CS_WT_10B 660
#define ACCESS_SS_WT_10B 661
#define ACCESS_DS_WT_10B 662
#define ACCESS_FS_WT_10B 663
#define ACCESS_GS_WT_10B 664
#define ACCESS_ES_RD_14B 665
#define ACCESS_CS_RD_14B 666
#define ACCESS_SS_RD_14B 667
#define ACCESS_DS_RD_14B 668
#define ACCESS_FS_RD_14B 669
#define ACCESS_GS_RD_14B 670
#define ACCESS_ES_WT_14B 671
#define ACCESS_CS_WT_14B 672
#define ACCESS_SS_WT_14B 673
#define ACCESS_DS_WT_14B 674
#define ACCESS_FS_WT_14B 675
#define ACCESS_GS_WT_14B 676
#define ACCESS_ES_RD_94B 677
#define ACCESS_CS_RD_94B 678
#define ACCESS_SS_RD_94B 679
#define ACCESS_DS_RD_94B 680
#define ACCESS_FS_RD_94B 681
#define ACCESS_GS_RD_94B 682
#define ACCESS_ES_WT_94B 683
#define ACCESS_CS_WT_94B 684
#define ACCESS_SS_WT_94B 685
#define ACCESS_DS_WT_94B 686
#define ACCESS_FS_WT_94B 687
#define ACCESS_GS_WT_94B 688
#define I_CLC 689
#define I_CLD 690
#define I_CLI 691
#define I_CLTS 692
#define I_CMC 693
#define I_INVD 694
#define I_NOP 695
#define I_STC 696
#define I_STD 697
#define I_STI 698
#define I_WAIT 699
#define I_WBINVD 700
#define I_ZBADOP 701
#define I_RSRVD 702
#define I_INT1 703
#define I_INT3 704
#define I_INT7 705
#define I_JMPN_IMM 706
#define I_ZDISPATCH_EIP 707
#define I_ZPATCH_ME 708
#define I_ZPAGE_BOUNDARY 709
#define I_ZPOST_POP 710
#define I_ZRET_TO_COROUTINE 711
#define I_ZUNSIM 712
#define I_F2XM1 713
#define I_FABS 714
#define I_FCHS 715
#define I_FNCLEX 716
#define I_FCOMPP 717
#define I_FCOS 718
#define I_FDECSTP 719
#define I_FINCSTP 720
#define I_FNINIT 721
#define I_FLD1 722
#define I_FLDL2T 723
#define I_FLDL2E 724
#define I_FLDPI 725
#define I_FLDLG2 726
#define I_FLDLN2 727
#define I_FLDZ 728
#define I_FNOP 729
#define I_FPATAN 730
#define I_FPREM 731
#define I_FPREM1 732
#define I_FPTAN 733
#define I_FRNDINT 734
#define I_FSCALE 735
#define I_FSIN 736
#define I_FSINCOS 737
#define I_FSQRT 738
#define I_FTST 739
#define I_FUCOMPP 740
#define I_FXAM 741
#define I_FXTRACT 742
#define I_FYL2X 743
#define I_FYL2XP1 744
#define I_FRSRVD 745
#define I_AAA_Ax_n 746
#define I_AAS_Ax_n 747
#define I_SAHF_Ax_n 748
#define I_LAHF_Ax_n 749
#define I_AAD_Ax_ib 750
#define I_AAM_Ax_ib 751
#define I_ADD_rmV_iV 752
#define I_ADD_rmV_rmV 779
#define I_ADC_rmV_iV 1019
#define I_ADC_rmV_rmV 1046
#define I_SUB_rmV_iV 1286
#define I_SUB_rmV_rmV 1313
#define I_SBB_rmV_iV 1553
#define I_SBB_rmV_rmV 1580
#define I_AND_rmV_iV 1820
#define I_AND_rmV_rmV 1847
#define I_XOR_rmV_iV 2087
#define I_XOR_rmV_rmV 2114
#define I_OR_rmV_iV 2354
#define I_OR_rmV_rmV 2381
#define I_CMP_rmV_iV 2621
#define I_CMP_rmV_rmV 2648
#define I_ARPL_rmw_rw 2888
#define I_BOP_ib_n 2960
#define I_BSF_rv_rmv 2961
#define I_BSR_rv_rmv 3105
#define I_BSWAP_rd_n 3249
#define I_BT_rmv_rv 3257
#define I_BT_rmv_ib 3401
#define I_BTC_rmv_rv 3419
#define I_BTC_rmv_ib 3563
#define I_BTR_rmv_rv 3581
#define I_BTR_rmv_ib 3725
#define I_BTS_rmv_rv 3743
#define I_BTS_rmv_ib 3887
#define I_CALLF_IMM_id_ipv 3905
#define I_CALLF_VIA_mwv_ipv 3907
#define I_CALLN_VIA_id_ipv 3909
#define I_CALLN_VIA_rmv_ipv 3911
#define I_CBW_Ax_Al 3929
#define I_CWDE_eAx_Ax 3930
#define I_CWD_Dx_Ax 3931
#define I_CDQ_eDx_eAx 3932
#define I_DAA_Al_n 3933
#define I_DAS_Al_n 3934
#define I_LALCY_Al_n 3935
#define I_DEC_rmV_n 3936
#define I_INC_rmV_n 3963
#define I_DIV_rmV_n 3990
#define I_IDIV_rmV_n 4017
#define I_NEG_rmV_n 4044
#define I_NOT_rmV_n 4071
#define I_ENTER_i1v_i2b 4098
#define I_IMULA_Al_rmb 4100
#define I_IMULA_rv_rmv 4109
#define I_IMULI_rv_rmv 4253
#define I_IMUL2_rv_rmv 4397
#define I_INP_AxV_ib 4541
#define I_INP_AxV_Dx 4544
#define I_INS_V_Dx 4547
#define I_R_INS_V_Dx 4550
#define I_INTR_v_ib 4553
#define I_JO_id_n 4555
#define I_JNO_id_n 4556
#define I_JB_id_n 4557
#define I_JNB_id_n 4558
#define I_JZ_id_n 4559
#define I_JNZ_id_n 4560
#define I_JBE_id_n 4561
#define I_JNBE_id_n 4562
#define I_JS_id_n 4563
#define I_JNS_id_n 4564
#define I_JP_id_n 4565
#define I_JNP_id_n 4566
#define I_JL_id_n 4567
#define I_JNL_id_n 4568
#define I_JLE_id_n 4569
#define I_JNLE_id_n 4570
#define I_ZADJUST_HSP_id_n 4571
#define I_ZJC_PROC_id_n 4572
#define I_ZBPI_id_n 4573
#define I_JMPN_VIA_rmv_n 4574
#define I_JMPF_VIA_i1d_i2w 4592
#define I_JMPF_VIA_mv_m2w 4593
#define I_LAR_rv_rmw 4595
#define I_LSL_rv_rmw 4739
#define I_LDS_rv_mv 4883
#define I_LES_rv_mv 4899
#define I_LFS_rv_mv 4915
#define I_LGS_rv_mv 4931
#define I_LSS_rv_mv 4947
#define I_LEA_rv_eao 4963
#define I_BOUND_rv_eao 4979
#define I_LGDT_mw_td 4995
#define I_LIDT_mw_td 4997
#define I_SGDT_mw_td 4999
#define I_SIDT_mw_td 5001
#define I_LLDT_rmw_n 5003
#define I_LMSW_rmw_n 5012
#define I_LTR_rmw_n 5021
#define I_SLDT_rmw_n 5030
#define I_SMSW_rmw_n 5039
#define I_STR_rmw_n 5048
#define I_VERR_rmw_n 5057
#define I_VERW_rmw_n 5066
#define I_LOOP_Cxv_id 5075
#define I_LOOPE_Cxv_id 5077
#define I_LOOPNE_Cxv_id 5079
#define I_JCXZ_Cxv_id 5081
#define I_MOV_rmV_rmV 5083
#define I_MOV_rmV_iV 5323
#define I_MOVS_V_n 5350
#define I_R_MOVS_V_n 5353
#define I_CMPS_V_n 5356
#define I_RNE_CMPS_V_n 5359
#define I_RE_CMPS_V_n 5362
#define I_LODS_AxV_n 5365
#define I_R_LODS_AxV_n 5368
#define I_MOVSX_rv_rmb 5371
#define I_MOVSX_rd_rmw 5515
#define I_MOVZX_rv_rmb 5587
#define I_MOVZX_rd_rmw 5731
#define I_MUL_AxV_rmV 5803
#define I_OUTP_ib_AxV 5830
#define I_OUTP_Dx_AxV 5833
#define I_OUTS_V_n 5836
#define I_R_OUTS_V_n 5839
#define I_POP_rv_n 5842
#define I_POP_MEM_mv_n 5858
#define I_POPA_v_n 5860
#define I_POPF_v_n 5862
#define I_PUSHA_v_n 5864
#define I_PUSHF_v_n 5866
#define I_LEAVE_v_n 5868
#define I_HLT_v_n 5870
#define I_INTO_v_n 5872
#define I_IRET_v_n 5874
#define I_POP_SR_segr_v 5876
#define I_PUSH_SR_segr_v 5888
#define I_PUSH_rmv_n 5900
#define I_PUSH_iv_n 5918
#define I_RCL_rmV_one 5920
#define I_RCL_rmV_Cl 5947
#define I_RCL_rmV_ib 5974
#define I_RCR_rmV_one 6001
#define I_RCR_rmV_Cl 6028
#define I_RCR_rmV_ib 6055
#define I_ROL_rmV_one 6082
#define I_ROL_rmV_Cl 6109
#define I_ROL_rmV_ib 6136
#define I_ROR_rmV_one 6163
#define I_ROR_rmV_Cl 6190
#define I_ROR_rmV_ib 6217
#define I_SAR_rmV_one 6244
#define I_SAR_rmV_Cl 6271
#define I_SAR_rmV_ib 6298
#define I_SHL_rmV_one 6325
#define I_SHL_rmV_Cl 6352
#define I_SHL_rmV_ib 6379
#define I_SHR_rmV_one 6406
#define I_SHR_rmV_Cl 6433
#define I_SHR_rmV_ib 6460
#define I_RETN_v_n 6487
#define I_RETF_v_n 6489
#define I_RETN_IMM_v_iw 6491
#define I_RETF_IMM_v_iw 6493
#define I_ENTER0_v_iw 6495
#define I_SCAS_AxV_n 6497
#define I_RE_SCAS_AxV_n 6500
#define I_RNE_SCAS_AxV_n 6503
#define I_STOS_AxV_n 6506
#define I_R_STOS_AxV_n 6509
#define I_SETO_rmb_n 6512
#define I_SETNO_rmb_n 6521
#define I_SETB_rmb_n 6530
#define I_SETNB_rmb_n 6539
#define I_SETZ_rmb_n 6548
#define I_SETNZ_rmb_n 6557
#define I_SETBE_rmb_n 6566
#define I_SETNBE_rmb_n 6575
#define I_SETS_rmb_n 6584
#define I_SETNS_rmb_n 6593
#define I_SETP_rmb_n 6602
#define I_SETNP_rmb_n 6611
#define I_SETL_rmb_n 6620
#define I_SETNL_rmb_n 6629
#define I_SETLE_rmb_n 6638
#define I_SETNLE_rmb_n 6647
#define I_SHLD_IMM_rmv_rv 6656
#define I_SHLD_CL_rmv_rv 6800
#define I_SHRD_IMM_rmv_rv 6944
#define I_SHRD_CL_rmv_rv 7088
#define I_TEST_rmV_iV 7232
#define I_TEST_rmV_rV 7259
#define I_CMPXCHG_rmXV_rXV 7475
#define I_XADD_rmXV_rXV 7691
#define I_XCHG_rmXV_rXV 7907
#define I_XLAT_Al_mb 8123
#define I_INVLPG_Al_mb 8124
#define I_RD_SEGR_rmv_segr 8125
#define I_WT_SEGR_segr_rmw 8233
#define I_RD_CDT_rd_CDTn 8287
#define I_WT_CDT_CDTn_rd 8479
#define I_ZRESULT_ZERO_rV_n 8671
#define I_FADD_st_mri 8695
#define I_FADD_fr_st 8699
#define I_FADD_st_fr 8700
#define I_FDIV_st_mri 8701
#define I_FDIV_fr_st 8705
#define I_FDIV_st_fr 8706
#define I_FDIVR_st_mri 8707
#define I_FDIVR_fr_st 8711
#define I_FDIVR_st_fr 8712
#define I_FMUL_st_mri 8713
#define I_FMUL_fr_st 8717
#define I_FMUL_st_fr 8718
#define I_FSUB_st_mri 8719
#define I_FSUB_fr_st 8723
#define I_FSUB_st_fr 8724
#define I_FSUBR_st_mri 8725
#define I_FSUBR_fr_st 8729
#define I_FSUBR_st_fr 8730
#define I_FADDP_fr_st 8731
#define I_FDIVP_fr_st 8732
#define I_FDIVRP_fr_st 8733
#define I_FMULP_fr_st 8734
#define I_FSUBP_fr_st 8735
#define I_FSUBRP_fr_st 8736
#define I_FUCOM_fr_st 8737
#define I_FUCOMP_fr_st 8738
#define I_FBLD_m10_n 8739
#define I_FBSTP_m10_n 8740
#define I_FCOM_st_mri 8741
#define I_FCOM_st_fr 8745
#define I_FCOMP_st_mri 8746
#define I_FCOMP_st_fr 8750
#define I_FFREE_fr_n 8751
#define I_FFREEP_fr_n 8752
#define I_FLD_mRI_n 8753
#define I_FLD_fr_n 8759
#define I_FSTP_mRI_n 8760
#define I_FSTP_fr_n 8766
#define I_FLDCW_m2_n 8767
#define I_FNSTCW_m2_n 8768
#define I_FNSTSW_m2_n 8769
#define I_FNSTSW_Ax_n 8770
#define I_FLDENV_m14_n 8771
#define I_FNSTENV_m14_n 8772
#define I_FRSTOR_m94_n 8773
#define I_FNSAVE_m94_n 8774
#define I_FST_mri_n 8775
#define I_FST_fr_n 8779
#define I_FXCH_fr_n 8780
#define PTI_EFI_BASE 8781
#define BPI_EFI_BASE 8847
#define BLDR_CHECKSUM 0x1a46fc
#define NUM_RELOC_SUBRS 887
#endif /* LC_HARN */
#define VCT_SIZE 8948
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\pm_c.h ===
#ifndef _PM_c_h
#define _PM_c_h
#endif /* ! _PM_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\ppchst_c.h ===
#ifndef _Ppchst_c_h
#define _Ppchst_c_h
#define PpcPureAddressAdjustment (0)
#define PpcCallToRetAddrAdjustment (0)
#define PpcFpuOverflowExceptionBit (8)
#define PpcFpuUnderflowExceptionBit (7)
#define PpcFpuPrecisionExceptionBit (5)
#define PPC_HOST_DEST_REG_ID (23)
#endif /* ! _Ppchst_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\ports_c.h ===
#ifndef _Ports_c_h
#define _Ports_c_h
#define EGA_GC_ADAP_DATA (18)
#endif /* ! _Ports_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\prof_c.h ===
#ifndef _Prof_c_h
#define _Prof_c_h
#define EOI_DEFAULTS (0)
#define EOI_DISABLED (1)
#define EOI_KEEP_GRAPH (2)
#define EOI_KEEP_ARGS (4)
#define EOI_ENABLE_ALL (8)
#define EOI_DISABLE_ALL (16)
#define EOI_AUTOSOI (32)
#define EOI_HOSTHOOK (64)
#define EOI_NOTIME (128)
#endif /* ! _Prof_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\pti_c.h ===
#ifndef _Pti_c_h
#define _Pti_c_h
#endif /* ! _Pti_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\rdwr_c.h ===
#ifndef _RdWr_c_h
#define _RdWr_c_h
#define LS0_NULL ((IU8*)0)
#define SAFE_FORWARDS (1)
#define SAFE_BACKWARDS (0)
#endif /* ! _RdWr_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\prot_c.h ===
#ifndef _Prot_c_h
#define _Prot_c_h
#define ParanoidTranslationCheck (0)
#define DYNAMIC_ALIGNMENT_CHECK (1)
#define DISJOINT_ALIGNMENT_CHECK (1)
#define ProtTypeMask (4092)
#define ProtTypeAlignmentOnly (0)
#define ProtTypeNotPresentBit (2)
#define ProtTypeNotPresentMask (4)
#define ProtTypeNotWritableBit (3)
#define ProtTypeNotWritableMask (8)
#define ProtTypeNotDirtyBit (4)
#define ProtTypeNotDirtyMask (16)
#define ProtTypeNotAccessedBit (5)
#define ProtTypeNotAccessedMask (32)
#define ProtTypePageTableBit (6)
#define ProtTypePageTableMask (64)
#define ProtTypePageDirBit (7)
#define ProtTypePageDirMask (128)
#define ProtTypeNotMemoryBit (8)
#define ProtTypeNotMemoryMask (256)
#define ProtTypeProtectedBit (9)
#define ProtTypeProtectedMask (512)
#define ProtTypeSupervisorBit (10)
#define ProtTypeSupervisorMask (1024)
#define ProtType_A_D_W_P_Mask (60)
#define ProtTypeMemoryTypeMask (448)
#define ProtTypeVideo (256)
#define ProtTypeIO (320)
#define ProtTypeRom (384)
#define ProtTypeBeyondMemory (448)
#define ProtTypeReadTagMask (-729)
#define ProtTypeWriteTagMask (-1)
#define ValidateOK (8)
#define CoarseProtNULL ((struct CoarseProtREC*)0)
#define FineProtNULL ((struct FineProtREC*)0)
#define SlotProtNULL ((struct SlotProtREC*)0)
#define Slot_Base_S (31)
#define Slot_Base_E (26)
#define Slot_Vnum_S (25)
#define Slot_Vnum_E (23)
#define Slot_Univ_S (22)
#define Slot_Univ_E (11)
#define Slot_UnivMaxHandle (4095)
#define Slot_Code_S (10)
#define Slot_Code_E (0)
#define Slot_CodeMaxOffset (2047)
#define Slot_Top_S (31)
#define Slot_Top_E (26)
#define Slot_Buff_S (25)
#define Slot_Buff_E (16)
#define MaxNumberOfBuffers (1023)
#define Slot_Next_S (15)
#define Slot_Next_E (0)
#define Slot_Type_S (25)
#define Slot_Type_E (22)
#define Slot_Context_S (21)
#define Slot_Context_E (16)
#define Slot_Info_S (15)
#define Slot_Info_E (0)
#define ProtInfoNULL ((struct ProtInfoREC*)0)
#define ProtAllocationNULL ((struct ProtAllocationREC*)0)
#define ProtFreeListNULL ((struct ProtFreeListREC*)0)
#define MIN_NUM_FREE_MAPS (10)
#define TranslationCacheMask (1023)
#define TranslationCacheNULL ((struct TranslationCacheREC*)0)
#define TranslationMapNULL ((struct TranslationMapREC*)0)
#define TranslationCacheSize (1024)
struct CompilationControlREC
{
	IU8 blockCounts[16];
};
struct PhysicalPageREC
{
	IU16 fineItems[8];
	IU8 fineUsed[8];
	struct TranslationMapREC *physLoop;
	IU8 vnums;
	IU8 padding;
	IU16 shelvedLoop;
	IU16 readWriteTag;
	IU16 coarseIndex;
};
struct CoarseProtREC
{
	IU16 fineItems[8];
	IU8 fineUsed[8];
	IU16 physLoop;
	IU16 dirPage;
	IU16 supervisorList;
	IU16 readWriteTag;
};
struct FineProtREC
{
	IU16 protItems[16];
};
struct SlotProtREC
{
	IU32 baseUnivCode;
	IU32 topBuffNext;
};
enum SpecialProtectionType
{
	SpecialProtectionGLDC = 0,
	SpecialProtectionIDT = 1,
	SpecialProtectionDirPTE = 2,
	SpecialProtectionPagePTE = 3
};
struct ProtInfoREC
{
	void *table;
	struct ProtFreeListREC *freeList;
	IUH freeCount;
	IUH freeEnough;
	IUH totalAllocated;
	struct ProtInfoREC *largestPtr;
};
struct ProtAllocationREC
{
	struct ProtInfoREC coarse;
	struct ProtInfoREC csHash;
	struct ProtInfoREC fine;
	struct ProtInfoREC slot;
};
struct ProtFreeListREC
{
	struct ProtFreeListREC *next;
};
struct TranslationCacheREC
{
	IU32 readTag;
	void *translation;
	IU32 writeTag;
	struct TranslationMapREC *miss;
};
struct TranslationMapREC
{
	IU32 readWriteTag;
	void *translation;
	struct TranslationMapREC *missLoop;
	struct TranslationMapREC *physLoop;
	IU16 tagBits;
	IU8 vnum;
	IU16 physPage;
	IU16 coarseIndex;
	struct TranslationCacheREC *cached;
};
#endif /* ! _Prot_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\pxcptn_c.h ===
#ifndef _PXcptn_c_h
#define _PXcptn_c_h
#define PX_INT_00 (0)
#define PX_INT_01 (1)
#define PX_INT_04 (4)
#define PX_INT_05 (5)
#define PX_INT_06 (6)
#define PX_INT_07 (7)
#define PX_INT_DF (8)
#define PX_INT_TS (10)
#define PX_INT_NP (11)
#define PX_INT_SF (12)
#define PX_INT_GP (13)
#define PX_INT_PF (14)
#define PX_INT_16 (16)
#define PX_INTERNAL (0)
#define PX_EXTERNAL (1)
#define PX_EC_VEC_SHIFT (3)
#define PX_EC_IDT_IND (2)
#define PX_EC_NULL (0)
#define PX_ACCESS_CHK (1)
#define PX_NO_ACCESS_CHK (0)
#define PX_ERROR_CODE (1)
#define PX_NO_ERROR_CODE (0)
#define PX_HOOK_IRET (1)
#define PX_DONT_HOOK_IRET (0)
#endif /* ! _PXcptn_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\rotate_c.h ===
#ifndef _Rotate_c_h
#define _Rotate_c_h
#endif /* ! _Rotate_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\sascdef.c ===
/*[
 * Generated File: sasCdef.c
 *
]*/

#include	"insignia.h"
#include	"host_inc.h"
#include	"host_def.h"
#include	"Fpu_c.h"
#include	"Pigger_c.h"
#include	"Univer_c.h"
#define	CPU_PRIVATE
#include	"cpu4.h"
#include	"sas.h"
#include	"evidgen.h"

extern TYPE_sas_memory_size c_sas_memory_size;
extern TYPE_sas_connect_memory c_sas_connect_memory;
extern TYPE_sas_enable_20_bit_wrapping c_sas_enable_20_bit_wrapping;
extern TYPE_sas_disable_20_bit_wrapping c_sas_disable_20_bit_wrapping;
extern TYPE_sas_twenty_bit_wrapping_enabled c_sas_twenty_bit_wrapping_enabled;
extern TYPE_sas_memory_type c_sas_memory_type;
extern TYPE_sas_hw_at c_sas_hw_at;
extern TYPE_sas_w_at c_sas_w_at;
extern TYPE_sas_dw_at c_sas_dw_at;
extern TYPE_sas_hw_at_no_check c_sas_hw_at;
extern TYPE_sas_w_at_no_check c_sas_w_at;
extern TYPE_sas_dw_at_no_check c_sas_dw_at;
extern TYPE_sas_store c_sas_store;
extern TYPE_sas_storew c_sas_storew;
extern TYPE_sas_storedw c_sas_storedw;
extern TYPE_sas_store_no_check c_sas_store;
extern TYPE_sas_storew_no_check c_sas_storew;
extern TYPE_sas_storedw_no_check c_sas_storedw;
extern TYPE_sas_loads c_sas_loads;
extern TYPE_sas_stores c_sas_stores;
extern TYPE_sas_loads_no_check c_sas_loads_no_check;
extern TYPE_sas_stores_no_check c_sas_stores_no_check;
extern TYPE_sas_move_bytes_forward c_sas_move_bytes_forward;
extern TYPE_sas_move_words_forward c_sas_move_words_forward;
extern TYPE_sas_move_doubles_forward c_sas_move_doubles_forward;
extern TYPE_sas_move_bytes_backward c_sas_move_bytes_backward;
extern TYPE_sas_move_words_backward c_sas_move_words_backward;
extern TYPE_sas_move_doubles_backward c_sas_move_doubles_backward;
extern TYPE_sas_fills c_sas_fills;
extern TYPE_sas_fillsw c_sas_fillsw;
extern TYPE_sas_fillsdw c_sas_fillsdw;
extern TYPE_sas_scratch_address c_sas_scratch_address;
extern TYPE_sas_transbuf_address c_sas_transbuf_address;
extern TYPE_sas_loads_to_transbuf c_sas_loads;
extern TYPE_sas_stores_from_transbuf c_sas_stores;
extern TYPE_sas_PR8 phy_r8;
extern TYPE_sas_PR16 phy_r16;
extern TYPE_sas_PR32 phy_r32;
extern TYPE_sas_PW8 phy_w8;
extern TYPE_sas_PW16 phy_w16;
extern TYPE_sas_PW32 phy_w32;
extern TYPE_sas_PW8_no_check phy_w8_no_check;
extern TYPE_sas_PW16_no_check phy_w16_no_check;
extern TYPE_sas_PW32_no_check phy_w32_no_check;
extern TYPE_getPtrToPhysAddrByte c_GetPhyAdd;
extern TYPE_get_byte_addr c_get_byte_addr;
extern TYPE_getPtrToLinAddrByte c_GetLinAdd;
extern TYPE_sas_init_pm_selectors c_SasRegisterVirtualSelectors;
extern TYPE_sas_PWS c_sas_PWS;
extern TYPE_sas_PWS_no_check c_sas_PWS_no_check;
extern TYPE_sas_PRS c_sas_PRS;
extern TYPE_sas_PRS_no_check c_sas_PRS_no_check;
extern TYPE_sas_PigCmpPage c_sas_PigCmpPage;
extern TYPE_IOVirtualised c_IOVirtualised;


struct SasVector cSasPtrs = {
	c_sas_memory_size,
	c_sas_connect_memory,
	c_sas_enable_20_bit_wrapping,
	c_sas_disable_20_bit_wrapping,
	c_sas_twenty_bit_wrapping_enabled,
	c_sas_memory_type,
	c_sas_hw_at,
	c_sas_w_at,
	c_sas_dw_at,
	c_sas_hw_at,
	c_sas_w_at,
	c_sas_dw_at,
	c_sas_store,
	c_sas_storew,
	c_sas_storedw,
	c_sas_store,
	c_sas_storew,
	c_sas_storedw,
	c_sas_loads,
	c_sas_stores,
	c_sas_loads_no_check,
	c_sas_stores_no_check,
	c_sas_move_bytes_forward,
	c_sas_move_words_forward,
	c_sas_move_doubles_forward,
	c_sas_move_bytes_backward,
	c_sas_move_words_backward,
	c_sas_move_doubles_backward,
	c_sas_fills,
	c_sas_fillsw,
	c_sas_fillsdw,
	c_sas_scratch_address,
	c_sas_transbuf_address,
	c_sas_loads,
	c_sas_stores,
	phy_r8,
	phy_r16,
	phy_r32,
	phy_w8,
	phy_w16,
	phy_w32,
	phy_w8_no_check,
	phy_w16_no_check,
	phy_w32_no_check,
	c_GetPhyAdd,
	c_get_byte_addr,
	c_GetLinAdd,
	c_SasRegisterVirtualSelectors,
	(void (*)()) 0,
	c_sas_PWS,
	c_sas_PWS_no_check,
	c_sas_PRS,
	c_sas_PRS_no_check,
	c_sas_PigCmpPage,
	c_IOVirtualised
};

/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\read_c.h ===
#ifndef _Read_c_h
#define _Read_c_h
#endif /* ! _Read_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\sas4gen.h ===
/*[
 * Generated File: sas4gen.h
 *
]*/

typedef	IU32	TYPE_sas_memory_size	IPT0();
typedef	void	TYPE_sas_connect_memory	IPT3(IU32,	lo_addr, IU32,	Int_addr, SAS_MEM_TYPE,	type);
typedef	void	TYPE_sas_enable_20_bit_wrapping	IPT0();
typedef	void	TYPE_sas_disable_20_bit_wrapping	IPT0();
typedef	IBOOL	TYPE_sas_twenty_bit_wrapping_enabled	IPT0();
typedef	SAS_MEM_TYPE	TYPE_sas_memory_type	IPT1(IU32,	addr);
typedef	IU8	TYPE_sas_hw_at	IPT1(IU32,	addr);
typedef	IU16	TYPE_sas_w_at	IPT1(IU32,	addr);
typedef	IU32	TYPE_sas_dw_at	IPT1(IU32,	addr);
typedef	IU8	TYPE_sas_hw_at_no_check	IPT1(IU32,	addr);
typedef	IU16	TYPE_sas_w_at_no_check	IPT1(IU32,	addr);
typedef	IU32	TYPE_sas_dw_at_no_check	IPT1(IU32,	addr);
typedef	void	TYPE_sas_store	IPT2(IU32,	addr, IU8,	val);
typedef	void	TYPE_sas_storew	IPT2(IU32,	addr, IU16,	val);
typedef	void	TYPE_sas_storedw	IPT2(IU32,	addr, IU32,	val);
typedef	void	TYPE_sas_store_no_check	IPT2(IU32,	addr, IU8,	val);
typedef	void	TYPE_sas_storew_no_check	IPT2(IU32,	addr, IU16,	val);
typedef	void	TYPE_sas_storedw_no_check	IPT2(IU32,	addr, IU32,	val);
typedef	void	TYPE_sas_loads	IPT3(IU32,	addr, IU8 *,	stringptr, IU32,	len);
typedef	void	TYPE_sas_stores	IPT3(IU32,	addr, IU8 *,	stringptr, IU32,	len);
typedef	void	TYPE_sas_loads_no_check	IPT3(IU32,	addr, IU8 *,	stringptr, IU32,	len);
typedef	void	TYPE_sas_stores_no_check	IPT3(IU32,	addr, IU8 *,	stringptr, IU32,	len);
typedef	void	TYPE_sas_move_bytes_forward	IPT3(IU32,	src, IU32,	dest, IU32,	len);
typedef	void	TYPE_sas_move_words_forward	IPT3(IU32,	src, IU32,	dest, IU32,	len);
typedef	void	TYPE_sas_move_doubles_forward	IPT3(IU32,	src, IU32,	dest, IU32,	len);
typedef	void	TYPE_sas_move_bytes_backward	IPT3(IU32,	src, IU32,	dest, IU32,	len);
typedef	void	TYPE_sas_move_words_backward	IPT3(IU32,	src, IU32,	dest, IU32,	len);
typedef	void	TYPE_sas_move_doubles_backward	IPT3(IU32,	src, IU32,	dest, IU32,	len);
typedef	void	TYPE_sas_fills	IPT3(IU32,	dest, IU8,	val, IU32,	len);
typedef	void	TYPE_sas_fillsw	IPT3(IU32,	dest, IU16,	val, IU32,	len);
typedef	void	TYPE_sas_fillsdw	IPT3(IU32,	dest, IU32,	val, IU32,	len);
typedef	IU8 *	TYPE_sas_scratch_address	IPT1(IU32,	length);
typedef	IU8 *	TYPE_sas_transbuf_address	IPT2(IU32,	dest_addr, IU32,	length);
typedef	void	TYPE_sas_loads_to_transbuf	IPT3(IU32,	src_addr, IU8 *,	dest_addr, IU32,	length);
typedef	void	TYPE_sas_stores_from_transbuf	IPT3(IU32,	dest_addr, IU8 *,	src_addr, IU32,	length);
typedef	IU8	TYPE_sas_PR8	IPT1(IU32,	addr);
typedef	IU16	TYPE_sas_PR16	IPT1(IU32,	addr);
typedef	IU32	TYPE_sas_PR32	IPT1(IU32,	addr);
typedef	void	TYPE_sas_PW8	IPT2(IU32,	addr, IU8,	val);
typedef	void	TYPE_sas_PW16	IPT2(IU32,	addr, IU16,	val);
typedef	void	TYPE_sas_PW32	IPT2(IU32,	addr, IU32,	val);
typedef	void	TYPE_sas_PW8_no_check	IPT2(IU32,	addr, IU8,	val);
typedef	void	TYPE_sas_PW16_no_check	IPT2(IU32,	addr, IU16,	val);
typedef	void	TYPE_sas_PW32_no_check	IPT2(IU32,	addr, IU32,	val);
typedef	IU8 *	TYPE_getPtrToPhysAddrByte	IPT1(IU32,	phys_addr);
typedef	IU8 *	TYPE_get_byte_addr	IPT1(IU32,	phys_addr);
typedef	IU8 *	TYPE_getPtrToLinAddrByte	IPT1(IU32,	lin_addr);
typedef	IBOOL	TYPE_sas_init_pm_selectors	IPT2(IU16,	sel1, IU16,	sel2);
typedef	void	TYPE_sas_overwrite_memory	IPT2(IU32,	addr, IU32,	length);
typedef	void	TYPE_sas_PWS	IPT3(IU32,	dest, IU8 *,	src, IU32,	len);
typedef	void	TYPE_sas_PWS_no_check	IPT3(IU32,	dest, IU8 *,	src, IU32,	len);
typedef	void	TYPE_sas_PRS	IPT3(IU32,	src, IU8 *,	dest, IU32,	len);
typedef	void	TYPE_sas_PRS_no_check	IPT3(IU32,	src, IU8 *,	dest, IU32,	len);
typedef	IBOOL	TYPE_sas_PigCmpPage	IPT3(IU32,	src, IU8 *,	dest, IU32,	len);
typedef	IBOOL	TYPE_IOVirtualised	IPT4(IU16,	port, IU32 *,	value, IU32,	offset, IU8,	width);

struct	SasVector	{
	IU32	(*Sas_memory_size)	IPT0();
	void	(*Sas_connect_memory)	IPT3(IU32,	lo_addr, IU32,	Int_addr, SAS_MEM_TYPE,	type);
	void	(*Sas_enable_20_bit_wrapping)	IPT0();
	void	(*Sas_disable_20_bit_wrapping)	IPT0();
	IBOOL	(*Sas_twenty_bit_wrapping_enabled)	IPT0();
	SAS_MEM_TYPE	(*Sas_memory_type)	IPT1(IU32,	addr);
	IU8	(*Sas_hw_at)	IPT1(IU32,	addr);
	IU16	(*Sas_w_at)	IPT1(IU32,	addr);
	IU32	(*Sas_dw_at)	IPT1(IU32,	addr);
	IU8	(*Sas_hw_at_no_check)	IPT1(IU32,	addr);
	IU16	(*Sas_w_at_no_check)	IPT1(IU32,	addr);
	IU32	(*Sas_dw_at_no_check)	IPT1(IU32,	addr);
	void	(*Sas_store)	IPT2(IU32,	addr, IU8,	val);
	void	(*Sas_storew)	IPT2(IU32,	addr, IU16,	val);
	void	(*Sas_storedw)	IPT2(IU32,	addr, IU32,	val);
	void	(*Sas_store_no_check)	IPT2(IU32,	addr, IU8,	val);
	void	(*Sas_storew_no_check)	IPT2(IU32,	addr, IU16,	val);
	void	(*Sas_storedw_no_check)	IPT2(IU32,	addr, IU32,	val);
	void	(*Sas_loads)	IPT3(IU32,	addr, IU8 *,	stringptr, IU32,	len);
	void	(*Sas_stores)	IPT3(IU32,	addr, IU8 *,	stringptr, IU32,	len);
	void	(*Sas_loads_no_check)	IPT3(IU32,	addr, IU8 *,	stringptr, IU32,	len);
	void	(*Sas_stores_no_check)	IPT3(IU32,	addr, IU8 *,	stringptr, IU32,	len);
	void	(*Sas_move_bytes_forward)	IPT3(IU32,	src, IU32,	dest, IU32,	len);
	void	(*Sas_move_words_forward)	IPT3(IU32,	src, IU32,	dest, IU32,	len);
	void	(*Sas_move_doubles_forward)	IPT3(IU32,	src, IU32,	dest, IU32,	len);
	void	(*Sas_move_bytes_backward)	IPT3(IU32,	src, IU32,	dest, IU32,	len);
	void	(*Sas_move_words_backward)	IPT3(IU32,	src, IU32,	dest, IU32,	len);
	void	(*Sas_move_doubles_backward)	IPT3(IU32,	src, IU32,	dest, IU32,	len);
	void	(*Sas_fills)	IPT3(IU32,	dest, IU8,	val, IU32,	len);
	void	(*Sas_fillsw)	IPT3(IU32,	dest, IU16,	val, IU32,	len);
	void	(*Sas_fillsdw)	IPT3(IU32,	dest, IU32,	val, IU32,	len);
	IU8 *	(*Sas_scratch_address)	IPT1(IU32,	length);
	IU8 *	(*Sas_transbuf_address)	IPT2(IU32,	dest_addr, IU32,	length);
	void	(*Sas_loads_to_transbuf)	IPT3(IU32,	src_addr, IU8 *,	dest_addr, IU32,	length);
	void	(*Sas_stores_from_transbuf)	IPT3(IU32,	dest_addr, IU8 *,	src_addr, IU32,	length);
	IU8	(*Sas_PR8)	IPT1(IU32,	addr);
	IU16	(*Sas_PR16)	IPT1(IU32,	addr);
	IU32	(*Sas_PR32)	IPT1(IU32,	addr);
	void	(*Sas_PW8)	IPT2(IU32,	addr, IU8,	val);
	void	(*Sas_PW16)	IPT2(IU32,	addr, IU16,	val);
	void	(*Sas_PW32)	IPT2(IU32,	addr, IU32,	val);
	void	(*Sas_PW8_no_check)	IPT2(IU32,	addr, IU8,	val);
	void	(*Sas_PW16_no_check)	IPT2(IU32,	addr, IU16,	val);
	void	(*Sas_PW32_no_check)	IPT2(IU32,	addr, IU32,	val);
	IU8 *	(*SasPtrToPhysAddrByte)	IPT1(IU32,	phys_addr);
	IU8 *	(*Sas_get_byte_addr)	IPT1(IU32,	phys_addr);
	IU8 *	(*SasPtrToLinAddrByte)	IPT1(IU32,	lin_addr);
	IBOOL	(*SasRegisterVirtualSelectors)	IPT2(IU16,	sel1, IU16,	sel2);
	void	(*Sas_overwrite_memory)	IPT2(IU32,	addr, IU32,	length);
	void	(*Sas_PWS)	IPT3(IU32,	dest, IU8 *,	src, IU32,	len);
	void	(*Sas_PWS_no_check)	IPT3(IU32,	dest, IU8 *,	src, IU32,	len);
	void	(*Sas_PRS)	IPT3(IU32,	src, IU8 *,	dest, IU32,	len);
	void	(*Sas_PRS_no_check)	IPT3(IU32,	src, IU8 *,	dest, IU32,	len);
	IBOOL	(*Sas_PigCmpPage)	IPT3(IU32,	src, IU8 *,	dest, IU32,	len);
	IBOOL	(*IOVirtualised)	IPT4(IU16,	port, IU32 *,	value, IU32,	offset, IU8,	width);
};

extern	struct	SasVector	Sas;

#ifdef	CCPU
IMPORT	IU32	c_sas_memory_size	IPT0();
#define	sas_memory_size()	c_sas_memory_size()
#else	/* CCPU */

#ifdef PROD
#define	sas_memory_size()	(*(Sas.Sas_memory_size))()
#else /* PROD */
IMPORT	IU32	sas_memory_size	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_connect_memory	IPT3(IU32, lo_addr, IU32, Int_addr, SAS_MEM_TYPE, type);
#define	sas_connect_memory(lo_addr, Int_addr, type)	c_sas_connect_memory(lo_addr, Int_addr, type)
#else	/* CCPU */

#ifdef PROD
#define	sas_connect_memory(lo_addr, Int_addr, type)	(*(Sas.Sas_connect_memory))(lo_addr, Int_addr, type)
#else /* PROD */
IMPORT	void	sas_connect_memory	IPT3(IU32, lo_addr, IU32, Int_addr, SAS_MEM_TYPE, type);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_enable_20_bit_wrapping	IPT0();
#define	sas_enable_20_bit_wrapping()	c_sas_enable_20_bit_wrapping()
#else	/* CCPU */

#ifdef PROD
#define	sas_enable_20_bit_wrapping()	(*(Sas.Sas_enable_20_bit_wrapping))()
#else /* PROD */
IMPORT	void	sas_enable_20_bit_wrapping	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_disable_20_bit_wrapping	IPT0();
#define	sas_disable_20_bit_wrapping()	c_sas_disable_20_bit_wrapping()
#else	/* CCPU */

#ifdef PROD
#define	sas_disable_20_bit_wrapping()	(*(Sas.Sas_disable_20_bit_wrapping))()
#else /* PROD */
IMPORT	void	sas_disable_20_bit_wrapping	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_sas_twenty_bit_wrapping_enabled	IPT0();
#define	sas_twenty_bit_wrapping_enabled()	c_sas_twenty_bit_wrapping_enabled()
#else	/* CCPU */

#ifdef PROD
#define	sas_twenty_bit_wrapping_enabled()	(*(Sas.Sas_twenty_bit_wrapping_enabled))()
#else /* PROD */
IMPORT	IBOOL	sas_twenty_bit_wrapping_enabled	IPT0();
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	SAS_MEM_TYPE	c_sas_memory_type	IPT1(IU32, addr);
#define	sas_memory_type(addr)	c_sas_memory_type(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_memory_type(addr)	(*(Sas.Sas_memory_type))(addr)
#else /* PROD */
IMPORT	SAS_MEM_TYPE	sas_memory_type	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_sas_hw_at	IPT1(IU32, addr);
#define	sas_hw_at(addr)	c_sas_hw_at(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_hw_at(addr)	(*(Sas.Sas_hw_at))(addr)
#else /* PROD */
IMPORT	IU8	sas_hw_at	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_sas_w_at	IPT1(IU32, addr);
#define	sas_w_at(addr)	c_sas_w_at(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_w_at(addr)	(*(Sas.Sas_w_at))(addr)
#else /* PROD */
IMPORT	IU16	sas_w_at	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_sas_dw_at	IPT1(IU32, addr);
#define	sas_dw_at(addr)	c_sas_dw_at(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_dw_at(addr)	(*(Sas.Sas_dw_at))(addr)
#else /* PROD */
IMPORT	IU32	sas_dw_at	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	c_sas_hw_at	IPT1(IU32, addr);
#define	sas_hw_at_no_check(addr)	c_sas_hw_at(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_hw_at_no_check(addr)	(*(Sas.Sas_hw_at_no_check))(addr)
#else /* PROD */
IMPORT	IU8	sas_hw_at_no_check	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	c_sas_w_at	IPT1(IU32, addr);
#define	sas_w_at_no_check(addr)	c_sas_w_at(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_w_at_no_check(addr)	(*(Sas.Sas_w_at_no_check))(addr)
#else /* PROD */
IMPORT	IU16	sas_w_at_no_check	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	c_sas_dw_at	IPT1(IU32, addr);
#define	sas_dw_at_no_check(addr)	c_sas_dw_at(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_dw_at_no_check(addr)	(*(Sas.Sas_dw_at_no_check))(addr)
#else /* PROD */
IMPORT	IU32	sas_dw_at_no_check	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_store	IPT2(IU32, addr, IU8, val);
#define	sas_store(addr, val)	c_sas_store(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_store(addr, val)	(*(Sas.Sas_store))(addr, val)
#else /* PROD */
IMPORT	void	sas_store	IPT2(IU32, addr, IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_storew	IPT2(IU32, addr, IU16, val);
#define	sas_storew(addr, val)	c_sas_storew(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_storew(addr, val)	(*(Sas.Sas_storew))(addr, val)
#else /* PROD */
IMPORT	void	sas_storew	IPT2(IU32, addr, IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_storedw	IPT2(IU32, addr, IU32, val);
#define	sas_storedw(addr, val)	c_sas_storedw(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_storedw(addr, val)	(*(Sas.Sas_storedw))(addr, val)
#else /* PROD */
IMPORT	void	sas_storedw	IPT2(IU32, addr, IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_store	IPT2(IU32, addr, IU8, val);
#define	sas_store_no_check(addr, val)	c_sas_store(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_store_no_check(addr, val)	(*(Sas.Sas_store_no_check))(addr, val)
#else /* PROD */
IMPORT	void	sas_store_no_check	IPT2(IU32, addr, IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_storew	IPT2(IU32, addr, IU16, val);
#define	sas_storew_no_check(addr, val)	c_sas_storew(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_storew_no_check(addr, val)	(*(Sas.Sas_storew_no_check))(addr, val)
#else /* PROD */
IMPORT	void	sas_storew_no_check	IPT2(IU32, addr, IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_storedw	IPT2(IU32, addr, IU32, val);
#define	sas_storedw_no_check(addr, val)	c_sas_storedw(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_storedw_no_check(addr, val)	(*(Sas.Sas_storedw_no_check))(addr, val)
#else /* PROD */
IMPORT	void	sas_storedw_no_check	IPT2(IU32, addr, IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_loads	IPT3(IU32, addr, IU8 *, stringptr, IU32, len);
#define	sas_loads(addr, stringptr, len)	c_sas_loads(addr, stringptr, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_loads(addr, stringptr, len)	(*(Sas.Sas_loads))(addr, stringptr, len)
#else /* PROD */
IMPORT	void	sas_loads	IPT3(IU32, addr, IU8 *, stringptr, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_stores	IPT3(IU32, addr, IU8 *, stringptr, IU32, len);
#define	sas_stores(addr, stringptr, len)	c_sas_stores(addr, stringptr, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_stores(addr, stringptr, len)	(*(Sas.Sas_stores))(addr, stringptr, len)
#else /* PROD */
IMPORT	void	sas_stores	IPT3(IU32, addr, IU8 *, stringptr, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_loads_no_check	IPT3(IU32, addr, IU8 *, stringptr, IU32, len);
#define	sas_loads_no_check(addr, stringptr, len)	c_sas_loads_no_check(addr, stringptr, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_loads_no_check(addr, stringptr, len)	(*(Sas.Sas_loads_no_check))(addr, stringptr, len)
#else /* PROD */
IMPORT	void	sas_loads_no_check	IPT3(IU32, addr, IU8 *, stringptr, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_stores_no_check	IPT3(IU32, addr, IU8 *, stringptr, IU32, len);
#define	sas_stores_no_check(addr, stringptr, len)	c_sas_stores_no_check(addr, stringptr, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_stores_no_check(addr, stringptr, len)	(*(Sas.Sas_stores_no_check))(addr, stringptr, len)
#else /* PROD */
IMPORT	void	sas_stores_no_check	IPT3(IU32, addr, IU8 *, stringptr, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_move_bytes_forward	IPT3(IU32, src, IU32, dest, IU32, len);
#define	sas_move_bytes_forward(src, dest, len)	c_sas_move_bytes_forward(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_move_bytes_forward(src, dest, len)	(*(Sas.Sas_move_bytes_forward))(src, dest, len)
#else /* PROD */
IMPORT	void	sas_move_bytes_forward	IPT3(IU32, src, IU32, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_move_words_forward	IPT3(IU32, src, IU32, dest, IU32, len);
#define	sas_move_words_forward(src, dest, len)	c_sas_move_words_forward(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_move_words_forward(src, dest, len)	(*(Sas.Sas_move_words_forward))(src, dest, len)
#else /* PROD */
IMPORT	void	sas_move_words_forward	IPT3(IU32, src, IU32, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_move_doubles_forward	IPT3(IU32, src, IU32, dest, IU32, len);
#define	sas_move_doubles_forward(src, dest, len)	c_sas_move_doubles_forward(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_move_doubles_forward(src, dest, len)	(*(Sas.Sas_move_doubles_forward))(src, dest, len)
#else /* PROD */
IMPORT	void	sas_move_doubles_forward	IPT3(IU32, src, IU32, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_move_bytes_backward	IPT3(IU32, src, IU32, dest, IU32, len);
#define	sas_move_bytes_backward(src, dest, len)	c_sas_move_bytes_backward(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_move_bytes_backward(src, dest, len)	(*(Sas.Sas_move_bytes_backward))(src, dest, len)
#else /* PROD */
IMPORT	void	sas_move_bytes_backward	IPT3(IU32, src, IU32, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_move_words_backward	IPT3(IU32, src, IU32, dest, IU32, len);
#define	sas_move_words_backward(src, dest, len)	c_sas_move_words_backward(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_move_words_backward(src, dest, len)	(*(Sas.Sas_move_words_backward))(src, dest, len)
#else /* PROD */
IMPORT	void	sas_move_words_backward	IPT3(IU32, src, IU32, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_move_doubles_backward	IPT3(IU32, src, IU32, dest, IU32, len);
#define	sas_move_doubles_backward(src, dest, len)	c_sas_move_doubles_backward(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_move_doubles_backward(src, dest, len)	(*(Sas.Sas_move_doubles_backward))(src, dest, len)
#else /* PROD */
IMPORT	void	sas_move_doubles_backward	IPT3(IU32, src, IU32, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_fills	IPT3(IU32, dest, IU8, val, IU32, len);
#define	sas_fills(dest, val, len)	c_sas_fills(dest, val, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_fills(dest, val, len)	(*(Sas.Sas_fills))(dest, val, len)
#else /* PROD */
IMPORT	void	sas_fills	IPT3(IU32, dest, IU8, val, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_fillsw	IPT3(IU32, dest, IU16, val, IU32, len);
#define	sas_fillsw(dest, val, len)	c_sas_fillsw(dest, val, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_fillsw(dest, val, len)	(*(Sas.Sas_fillsw))(dest, val, len)
#else /* PROD */
IMPORT	void	sas_fillsw	IPT3(IU32, dest, IU16, val, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_fillsdw	IPT3(IU32, dest, IU32, val, IU32, len);
#define	sas_fillsdw(dest, val, len)	c_sas_fillsdw(dest, val, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_fillsdw(dest, val, len)	(*(Sas.Sas_fillsdw))(dest, val, len)
#else /* PROD */
IMPORT	void	sas_fillsdw	IPT3(IU32, dest, IU32, val, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8 *	c_sas_scratch_address	IPT1(IU32, length);
#define	sas_scratch_address(length)	c_sas_scratch_address(length)
#else	/* CCPU */

#ifdef PROD
#define	sas_scratch_address(length)	(*(Sas.Sas_scratch_address))(length)
#else /* PROD */
IMPORT	IU8 *	sas_scratch_address	IPT1(IU32, length);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8 *	c_sas_transbuf_address	IPT2(IU32, dest_addr, IU32, length);
#define	sas_transbuf_address(dest_addr, length)	c_sas_transbuf_address(dest_addr, length)
#else	/* CCPU */

#ifdef PROD
#define	sas_transbuf_address(dest_addr, length)	(*(Sas.Sas_transbuf_address))(dest_addr, length)
#else /* PROD */
IMPORT	IU8 *	sas_transbuf_address	IPT2(IU32, dest_addr, IU32, length);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_loads	IPT3(IU32, src_addr, IU8 *, dest_addr, IU32, length);
#define	sas_loads_to_transbuf(src_addr, dest_addr, length)	c_sas_loads(src_addr, dest_addr, length)
#else	/* CCPU */

#ifdef PROD
#define	sas_loads_to_transbuf(src_addr, dest_addr, length)	(*(Sas.Sas_loads_to_transbuf))(src_addr, dest_addr, length)
#else /* PROD */
IMPORT	void	sas_loads_to_transbuf	IPT3(IU32, src_addr, IU8 *, dest_addr, IU32, length);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_stores	IPT3(IU32, dest_addr, IU8 *, src_addr, IU32, length);
#define	sas_stores_from_transbuf(dest_addr, src_addr, length)	c_sas_stores(dest_addr, src_addr, length)
#else	/* CCPU */

#ifdef PROD
#define	sas_stores_from_transbuf(dest_addr, src_addr, length)	(*(Sas.Sas_stores_from_transbuf))(dest_addr, src_addr, length)
#else /* PROD */
IMPORT	void	sas_stores_from_transbuf	IPT3(IU32, dest_addr, IU8 *, src_addr, IU32, length);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8	phy_r8	IPT1(IU32, addr);
#define	sas_PR8(addr)	phy_r8(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_PR8(addr)	(*(Sas.Sas_PR8))(addr)
#else /* PROD */
IMPORT	IU8	sas_PR8	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU16	phy_r16	IPT1(IU32, addr);
#define	sas_PR16(addr)	phy_r16(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_PR16(addr)	(*(Sas.Sas_PR16))(addr)
#else /* PROD */
IMPORT	IU16	sas_PR16	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU32	phy_r32	IPT1(IU32, addr);
#define	sas_PR32(addr)	phy_r32(addr)
#else	/* CCPU */

#ifdef PROD
#define	sas_PR32(addr)	(*(Sas.Sas_PR32))(addr)
#else /* PROD */
IMPORT	IU32	sas_PR32	IPT1(IU32, addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	phy_w8	IPT2(IU32, addr, IU8, val);
#define	sas_PW8(addr, val)	phy_w8(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_PW8(addr, val)	(*(Sas.Sas_PW8))(addr, val)
#else /* PROD */
IMPORT	void	sas_PW8	IPT2(IU32, addr, IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	phy_w16	IPT2(IU32, addr, IU16, val);
#define	sas_PW16(addr, val)	phy_w16(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_PW16(addr, val)	(*(Sas.Sas_PW16))(addr, val)
#else /* PROD */
IMPORT	void	sas_PW16	IPT2(IU32, addr, IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	phy_w32	IPT2(IU32, addr, IU32, val);
#define	sas_PW32(addr, val)	phy_w32(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_PW32(addr, val)	(*(Sas.Sas_PW32))(addr, val)
#else /* PROD */
IMPORT	void	sas_PW32	IPT2(IU32, addr, IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	phy_w8_no_check	IPT2(IU32, addr, IU8, val);
#define	sas_PW8_no_check(addr, val)	phy_w8_no_check(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_PW8_no_check(addr, val)	(*(Sas.Sas_PW8_no_check))(addr, val)
#else /* PROD */
IMPORT	void	sas_PW8_no_check	IPT2(IU32, addr, IU8, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	phy_w16_no_check	IPT2(IU32, addr, IU16, val);
#define	sas_PW16_no_check(addr, val)	phy_w16_no_check(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_PW16_no_check(addr, val)	(*(Sas.Sas_PW16_no_check))(addr, val)
#else /* PROD */
IMPORT	void	sas_PW16_no_check	IPT2(IU32, addr, IU16, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	phy_w32_no_check	IPT2(IU32, addr, IU32, val);
#define	sas_PW32_no_check(addr, val)	phy_w32_no_check(addr, val)
#else	/* CCPU */

#ifdef PROD
#define	sas_PW32_no_check(addr, val)	(*(Sas.Sas_PW32_no_check))(addr, val)
#else /* PROD */
IMPORT	void	sas_PW32_no_check	IPT2(IU32, addr, IU32, val);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8 *	c_GetPhyAdd	IPT1(IU32, phys_addr);
#define	getPtrToPhysAddrByte(phys_addr)	c_GetPhyAdd(phys_addr)
#else	/* CCPU */

#ifdef PROD
#define	getPtrToPhysAddrByte(phys_addr)	(*(Sas.SasPtrToPhysAddrByte))(phys_addr)
#else /* PROD */
IMPORT	IU8 *	getPtrToPhysAddrByte	IPT1(IU32, phys_addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8 *	c_get_byte_addr	IPT1(IU32, phys_addr);
#define	get_byte_addr(phys_addr)	c_get_byte_addr(phys_addr)
#else	/* CCPU */

#ifdef PROD
#define	get_byte_addr(phys_addr)	(*(Sas.Sas_get_byte_addr))(phys_addr)
#else /* PROD */
IMPORT	IU8 *	get_byte_addr	IPT1(IU32, phys_addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IU8 *	c_GetLinAdd	IPT1(IU32, lin_addr);
#define	getPtrToLinAddrByte(lin_addr)	c_GetLinAdd(lin_addr)
#else	/* CCPU */

#ifdef PROD
#define	getPtrToLinAddrByte(lin_addr)	(*(Sas.SasPtrToLinAddrByte))(lin_addr)
#else /* PROD */
IMPORT	IU8 *	getPtrToLinAddrByte	IPT1(IU32, lin_addr);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_SasRegisterVirtualSelectors	IPT2(IU16, sel1, IU16, sel2);
#define	sas_init_pm_selectors(sel1, sel2)	c_SasRegisterVirtualSelectors(sel1, sel2)
#else	/* CCPU */

#ifdef PROD
#define	sas_init_pm_selectors(sel1, sel2)	(*(Sas.SasRegisterVirtualSelectors))(sel1, sel2)
#else /* PROD */
IMPORT	IBOOL	sas_init_pm_selectors	IPT2(IU16, sel1, IU16, sel2);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU

#else	/* CCPU */

#ifdef PROD
#define	sas_overwrite_memory(addr, length)	(*(Sas.Sas_overwrite_memory))(addr, length)
#else /* PROD */
IMPORT	void	sas_overwrite_memory	IPT2(IU32, addr, IU32, length);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_PWS	IPT3(IU32, dest, IU8 *, src, IU32, len);
#define	sas_PWS(dest, src, len)	c_sas_PWS(dest, src, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_PWS(dest, src, len)	(*(Sas.Sas_PWS))(dest, src, len)
#else /* PROD */
IMPORT	void	sas_PWS	IPT3(IU32, dest, IU8 *, src, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_PWS_no_check	IPT3(IU32, dest, IU8 *, src, IU32, len);
#define	sas_PWS_no_check(dest, src, len)	c_sas_PWS_no_check(dest, src, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_PWS_no_check(dest, src, len)	(*(Sas.Sas_PWS_no_check))(dest, src, len)
#else /* PROD */
IMPORT	void	sas_PWS_no_check	IPT3(IU32, dest, IU8 *, src, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_PRS	IPT3(IU32, src, IU8 *, dest, IU32, len);
#define	sas_PRS(src, dest, len)	c_sas_PRS(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_PRS(src, dest, len)	(*(Sas.Sas_PRS))(src, dest, len)
#else /* PROD */
IMPORT	void	sas_PRS	IPT3(IU32, src, IU8 *, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	void	c_sas_PRS_no_check	IPT3(IU32, src, IU8 *, dest, IU32, len);
#define	sas_PRS_no_check(src, dest, len)	c_sas_PRS_no_check(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_PRS_no_check(src, dest, len)	(*(Sas.Sas_PRS_no_check))(src, dest, len)
#else /* PROD */
IMPORT	void	sas_PRS_no_check	IPT3(IU32, src, IU8 *, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_sas_PigCmpPage	IPT3(IU32, src, IU8 *, dest, IU32, len);
#define	sas_PigCmpPage(src, dest, len)	c_sas_PigCmpPage(src, dest, len)
#else	/* CCPU */

#ifdef PROD
#define	sas_PigCmpPage(src, dest, len)	(*(Sas.Sas_PigCmpPage))(src, dest, len)
#else /* PROD */
IMPORT	IBOOL	sas_PigCmpPage	IPT3(IU32, src, IU8 *, dest, IU32, len);
#endif /*PROD*/

#endif	/* CCPU */

#ifdef	CCPU
IMPORT	IBOOL	c_IOVirtualised	IPT4(IU16, port, IU32 *, value, IU32, offset, IU8, width);
#define	IOVirtualised(port, value, offset, width)	c_IOVirtualised(port, value, offset, width)
#else	/* CCPU */

#ifdef PROD
#define	IOVirtualised(port, value, offset, width)	(*(Sas.IOVirtualised))(port, value, offset, width)
#else /* PROD */
IMPORT	IBOOL	IOVirtualised	IPT4(IU16, port, IU32 *, value, IU32, offset, IU8, width);
#endif /*PROD*/

#endif	/* CCPU */

/*======================================== END ========================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\sas_c.h ===
#ifndef _Sas_c_h
#define _Sas_c_h
enum SAS_MEM_TYPE
{
	SAS_RAM = 0,
	SAS_VIDEO = 1,
	SAS_ROM = 2,
	SAS_WRAP = 3,
	SAS_IO = 4,
	SAS_MM_LIM = 5,
	SAS_INACCESSIBLE = 6,
	SAS_DANGEROUS = 7
};
#endif /* ! _Sas_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\segreg_c.h ===
#ifndef _SegReg_c_h
#define _SegReg_c_h
#define SELECTOR_OK (0)
#define TAKE_EXCEPTIONS (0)
#define DONT_TAKE_EXCEPTIONS (1)
enum SR_CLASS_ENUM
{
	SR_CLASS_A = 0,
	SR_CLASS_B = 1,
	SR_CLASS_C = 2,
	SR_CLASS_D = 3
};
struct DYNAMIC_DESC_PTR_LOOKUP
{
	struct GLDC_REC **segDescPtr[6];
};
struct DYNAMIC_SEG_BASE_LOOKUP
{
	IU32 *segBasePtr[6];
};
enum SEG_LOAD_ACTION_ENUM
{
	SEG_LOAD_ACTION_NONE = 0,
	SEG_LOAD_ACTION_NEXT = 1,
	SEG_LOAD_ACTION_PREV = 2
};
#endif /* ! _SegReg_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\sevid000.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_2087_RdMode0Chain2ByteRead_id,
L13_2067if_f_id,
S_2088_RdMode0Chain2WordRead_id,
L13_2068if_f_id,
L26_0if_f_id,
L26_1if_d_id,
S_2089_RdMode0Chain2DwordRead_id,
L13_2069if_f_id,
S_2090_RdMode0Chain2StringReadFwd_id,
L13_2070if_f_id,
L26_2if_f_id,
L26_3if_d_id,
L26_6w_t_id,
L26_7w_d_id,
L26_4if_f_id,
L26_8w_t_id,
L26_9w_d_id,
L26_5if_d_id,
S_2091_RdMode0Chain4ByteRead_id,
L13_2071if_f_id,
S_2092_RdMode0Chain4WordRead_id,
L13_2072if_f_id,
S_2093_RdMode0Chain4DwordRead_id,
L13_2073if_f_id,
S_2094_RdMode0Chain4StringReadFwd_id,
L13_2074if_f_id,
L26_12w_t_id,
L26_13w_d_id,
L26_10if_f_id,
L26_14w_t_id,
L26_15w_d_id,
L26_11if_d_id,
S_2095_RdMode0UnchainedByteRead_id,
L13_2075if_f_id,
S_2096_RdMode0UnchainedWordRead_id,
L13_2076if_f_id,
S_2097_RdMode0UnchainedDwordRead_id,
L13_2077if_f_id,
S_2098_RdMode0UnchainedStringReadFwd_id,
L13_2078if_f_id,
L26_18w_t_id,
L26_19w_d_id,
L26_16if_f_id,
L26_20w_t_id,
L26_21w_d_id,
L26_17if_d_id,
S_2099_RdMode1Chain2ByteRead_id,
L13_2079if_f_id,
L26_22if_f_id,
S_2100_RdMode1Chain2WordRead_id,
L13_2080if_f_id,
L26_23if_f_id,
L26_24if_d_id,
S_2101_RdMode1Chain2DwordRead_id,
L13_2081if_f_id,
S_2102_RdMode1Chain2StringReadFwd_id,
L13_2082if_f_id,
L26_25if_f_id,
L26_26if_d_id,
L26_29w_t_id,
L26_30w_d_id,
L26_27if_f_id,
L26_31w_t_id,
L26_32w_d_id,
L26_28if_d_id,
S_2103_RdMode1Chain4ByteRead_id,
L13_2083if_f_id,
S_2104_RdMode1Chain4WordRead_id,
L13_2084if_f_id,
S_2105_RdMode1Chain4DwordRead_id,
L13_2085if_f_id,
S_2106_RdMode1Chain4StringReadFwd_id,
L13_2086if_f_id,
L26_35w_t_id,
L26_36w_d_id,
L26_33if_f_id,
L26_37w_t_id,
L26_38w_d_id,
L26_34if_d_id,
S_2107_RdMode1UnchainedByteRead_id,
L13_2087if_f_id,
S_2108_RdMode1UnchainedWordRead_id,
L13_2088if_f_id,
S_2109_RdMode1UnchainedDwordRead_id,
L13_2089if_f_id,
S_2110_RdMode1UnchainedStringReadFwd_id,
L13_2090if_f_id,
L26_41w_t_id,
L26_42w_d_id,
L26_39if_f_id,
L26_43w_t_id,
L26_44w_d_id,
L26_40if_d_id,
S_2111_DisabledRAMByteRead_id,
L13_2091if_f_id,
S_2112_DisabledRAMWordRead_id,
L13_2092if_f_id,
S_2113_DisabledRAMDwordRead_id,
L13_2093if_f_id,
S_2114_DisabledRAMStringReadFwd_id,
L13_2094if_f_id,
L26_47w_t_id,
L26_48w_d_id,
L26_45if_f_id,
L26_49w_t_id,
L26_50w_d_id,
L26_46if_d_id,
S_2115_SimpleByteRead_id,
L13_2095if_f_id,
S_2116_SimpleWordRead_id,
L13_2096if_f_id,
S_2117_SimpleDwordRead_id,
L13_2097if_f_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_2087_RdMode0Chain2ByteRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2087_RdMode0Chain2ByteRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2087_RdMode0Chain2ByteRead = (IHPE)S_2087_RdMode0Chain2ByteRead ;
LOCAL IUH L13_2067if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2067if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2067if_f = (IHPE)L13_2067if_f ;
GLOBAL IUH S_2088_RdMode0Chain2WordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2088_RdMode0Chain2WordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2088_RdMode0Chain2WordRead = (IHPE)S_2088_RdMode0Chain2WordRead ;
LOCAL IUH L13_2068if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2068if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2068if_f = (IHPE)L13_2068if_f ;
LOCAL IUH L26_0if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_0if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_0if_f = (IHPE)L26_0if_f ;
LOCAL IUH L26_1if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_1if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_1if_d = (IHPE)L26_1if_d ;
GLOBAL IUH S_2089_RdMode0Chain2DwordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2089_RdMode0Chain2DwordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2089_RdMode0Chain2DwordRead = (IHPE)S_2089_RdMode0Chain2DwordRead ;
LOCAL IUH L13_2069if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2069if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2069if_f = (IHPE)L13_2069if_f ;
GLOBAL IUH S_2090_RdMode0Chain2StringReadFwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2090_RdMode0Chain2StringReadFwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2090_RdMode0Chain2StringReadFwd = (IHPE)S_2090_RdMode0Chain2StringReadFwd ;
LOCAL IUH L13_2070if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2070if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2070if_f = (IHPE)L13_2070if_f ;
LOCAL IUH L26_2if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_2if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_2if_f = (IHPE)L26_2if_f ;
LOCAL IUH L26_3if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_3if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_3if_d = (IHPE)L26_3if_d ;
LOCAL IUH L26_6w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_6w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_6w_t = (IHPE)L26_6w_t ;
LOCAL IUH L26_7w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_7w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_7w_d = (IHPE)L26_7w_d ;
LOCAL IUH L26_4if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_4if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_4if_f = (IHPE)L26_4if_f ;
LOCAL IUH L26_8w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_8w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_8w_t = (IHPE)L26_8w_t ;
LOCAL IUH L26_9w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_9w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_9w_d = (IHPE)L26_9w_d ;
LOCAL IUH L26_5if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_5if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_5if_d = (IHPE)L26_5if_d ;
GLOBAL IUH S_2091_RdMode0Chain4ByteRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2091_RdMode0Chain4ByteRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2091_RdMode0Chain4ByteRead = (IHPE)S_2091_RdMode0Chain4ByteRead ;
LOCAL IUH L13_2071if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2071if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2071if_f = (IHPE)L13_2071if_f ;
GLOBAL IUH S_2092_RdMode0Chain4WordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2092_RdMode0Chain4WordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2092_RdMode0Chain4WordRead = (IHPE)S_2092_RdMode0Chain4WordRead ;
LOCAL IUH L13_2072if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2072if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2072if_f = (IHPE)L13_2072if_f ;
GLOBAL IUH S_2093_RdMode0Chain4DwordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2093_RdMode0Chain4DwordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2093_RdMode0Chain4DwordRead = (IHPE)S_2093_RdMode0Chain4DwordRead ;
LOCAL IUH L13_2073if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2073if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2073if_f = (IHPE)L13_2073if_f ;
GLOBAL IUH S_2094_RdMode0Chain4StringReadFwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2094_RdMode0Chain4StringReadFwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2094_RdMode0Chain4StringReadFwd = (IHPE)S_2094_RdMode0Chain4StringReadFwd ;
LOCAL IUH L13_2074if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2074if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2074if_f = (IHPE)L13_2074if_f ;
LOCAL IUH L26_12w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_12w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_12w_t = (IHPE)L26_12w_t ;
LOCAL IUH L26_13w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_13w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_13w_d = (IHPE)L26_13w_d ;
LOCAL IUH L26_10if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_10if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_10if_f = (IHPE)L26_10if_f ;
LOCAL IUH L26_14w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_14w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_14w_t = (IHPE)L26_14w_t ;
LOCAL IUH L26_15w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_15w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_15w_d = (IHPE)L26_15w_d ;
LOCAL IUH L26_11if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_11if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_11if_d = (IHPE)L26_11if_d ;
GLOBAL IUH S_2095_RdMode0UnchainedByteRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2095_RdMode0UnchainedByteRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2095_RdMode0UnchainedByteRead = (IHPE)S_2095_RdMode0UnchainedByteRead ;
LOCAL IUH L13_2075if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2075if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2075if_f = (IHPE)L13_2075if_f ;
GLOBAL IUH S_2096_RdMode0UnchainedWordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2096_RdMode0UnchainedWordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2096_RdMode0UnchainedWordRead = (IHPE)S_2096_RdMode0UnchainedWordRead ;
LOCAL IUH L13_2076if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2076if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2076if_f = (IHPE)L13_2076if_f ;
GLOBAL IUH S_2097_RdMode0UnchainedDwordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2097_RdMode0UnchainedDwordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2097_RdMode0UnchainedDwordRead = (IHPE)S_2097_RdMode0UnchainedDwordRead ;
LOCAL IUH L13_2077if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2077if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2077if_f = (IHPE)L13_2077if_f ;
GLOBAL IUH S_2098_RdMode0UnchainedStringReadFwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2098_RdMode0UnchainedStringReadFwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2098_RdMode0UnchainedStringReadFwd = (IHPE)S_2098_RdMode0UnchainedStringReadFwd ;
LOCAL IUH L13_2078if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2078if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2078if_f = (IHPE)L13_2078if_f ;
LOCAL IUH L26_18w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_18w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_18w_t = (IHPE)L26_18w_t ;
LOCAL IUH L26_19w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_19w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_19w_d = (IHPE)L26_19w_d ;
LOCAL IUH L26_16if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_16if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_16if_f = (IHPE)L26_16if_f ;
LOCAL IUH L26_20w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_20w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_20w_t = (IHPE)L26_20w_t ;
LOCAL IUH L26_21w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_21w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_21w_d = (IHPE)L26_21w_d ;
LOCAL IUH L26_17if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_17if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_17if_d = (IHPE)L26_17if_d ;
GLOBAL IUH S_2099_RdMode1Chain2ByteRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2099_RdMode1Chain2ByteRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2099_RdMode1Chain2ByteRead = (IHPE)S_2099_RdMode1Chain2ByteRead ;
LOCAL IUH L13_2079if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2079if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2079if_f = (IHPE)L13_2079if_f ;
LOCAL IUH L26_22if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_22if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_22if_f = (IHPE)L26_22if_f ;
GLOBAL IUH S_2100_RdMode1Chain2WordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2100_RdMode1Chain2WordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2100_RdMode1Chain2WordRead = (IHPE)S_2100_RdMode1Chain2WordRead ;
LOCAL IUH L13_2080if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2080if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2080if_f = (IHPE)L13_2080if_f ;
LOCAL IUH L26_23if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_23if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_23if_f = (IHPE)L26_23if_f ;
LOCAL IUH L26_24if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_24if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_24if_d = (IHPE)L26_24if_d ;
GLOBAL IUH S_2101_RdMode1Chain2DwordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2101_RdMode1Chain2DwordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2101_RdMode1Chain2DwordRead = (IHPE)S_2101_RdMode1Chain2DwordRead ;
LOCAL IUH L13_2081if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2081if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2081if_f = (IHPE)L13_2081if_f ;
GLOBAL IUH S_2102_RdMode1Chain2StringReadFwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2102_RdMode1Chain2StringReadFwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2102_RdMode1Chain2StringReadFwd = (IHPE)S_2102_RdMode1Chain2StringReadFwd ;
LOCAL IUH L13_2082if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2082if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2082if_f = (IHPE)L13_2082if_f ;
LOCAL IUH L26_25if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_25if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_25if_f = (IHPE)L26_25if_f ;
LOCAL IUH L26_26if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_26if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_26if_d = (IHPE)L26_26if_d ;
LOCAL IUH L26_29w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_29w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_29w_t = (IHPE)L26_29w_t ;
LOCAL IUH L26_30w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_30w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_30w_d = (IHPE)L26_30w_d ;
LOCAL IUH L26_27if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_27if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_27if_f = (IHPE)L26_27if_f ;
LOCAL IUH L26_31w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_31w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_31w_t = (IHPE)L26_31w_t ;
LOCAL IUH L26_32w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_32w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_32w_d = (IHPE)L26_32w_d ;
LOCAL IUH L26_28if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_28if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_28if_d = (IHPE)L26_28if_d ;
GLOBAL IUH S_2103_RdMode1Chain4ByteRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2103_RdMode1Chain4ByteRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2103_RdMode1Chain4ByteRead = (IHPE)S_2103_RdMode1Chain4ByteRead ;
LOCAL IUH L13_2083if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2083if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2083if_f = (IHPE)L13_2083if_f ;
GLOBAL IUH S_2104_RdMode1Chain4WordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2104_RdMode1Chain4WordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2104_RdMode1Chain4WordRead = (IHPE)S_2104_RdMode1Chain4WordRead ;
LOCAL IUH L13_2084if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2084if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2084if_f = (IHPE)L13_2084if_f ;
GLOBAL IUH S_2105_RdMode1Chain4DwordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2105_RdMode1Chain4DwordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2105_RdMode1Chain4DwordRead = (IHPE)S_2105_RdMode1Chain4DwordRead ;
LOCAL IUH L13_2085if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2085if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2085if_f = (IHPE)L13_2085if_f ;
GLOBAL IUH S_2106_RdMode1Chain4StringReadFwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2106_RdMode1Chain4StringReadFwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2106_RdMode1Chain4StringReadFwd = (IHPE)S_2106_RdMode1Chain4StringReadFwd ;
LOCAL IUH L13_2086if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2086if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2086if_f = (IHPE)L13_2086if_f ;
LOCAL IUH L26_35w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_35w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_35w_t = (IHPE)L26_35w_t ;
LOCAL IUH L26_36w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_36w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_36w_d = (IHPE)L26_36w_d ;
LOCAL IUH L26_33if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_33if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_33if_f = (IHPE)L26_33if_f ;
LOCAL IUH L26_37w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_37w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_37w_t = (IHPE)L26_37w_t ;
LOCAL IUH L26_38w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_38w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_38w_d = (IHPE)L26_38w_d ;
LOCAL IUH L26_34if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_34if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_34if_d = (IHPE)L26_34if_d ;
GLOBAL IUH S_2107_RdMode1UnchainedByteRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2107_RdMode1UnchainedByteRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2107_RdMode1UnchainedByteRead = (IHPE)S_2107_RdMode1UnchainedByteRead ;
LOCAL IUH L13_2087if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2087if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2087if_f = (IHPE)L13_2087if_f ;
GLOBAL IUH S_2108_RdMode1UnchainedWordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2108_RdMode1UnchainedWordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2108_RdMode1UnchainedWordRead = (IHPE)S_2108_RdMode1UnchainedWordRead ;
LOCAL IUH L13_2088if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2088if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2088if_f = (IHPE)L13_2088if_f ;
GLOBAL IUH S_2109_RdMode1UnchainedDwordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2109_RdMode1UnchainedDwordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2109_RdMode1UnchainedDwordRead = (IHPE)S_2109_RdMode1UnchainedDwordRead ;
LOCAL IUH L13_2089if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2089if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2089if_f = (IHPE)L13_2089if_f ;
GLOBAL IUH S_2110_RdMode1UnchainedStringReadFwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2110_RdMode1UnchainedStringReadFwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2110_RdMode1UnchainedStringReadFwd = (IHPE)S_2110_RdMode1UnchainedStringReadFwd ;
LOCAL IUH L13_2090if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2090if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2090if_f = (IHPE)L13_2090if_f ;
LOCAL IUH L26_41w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_41w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_41w_t = (IHPE)L26_41w_t ;
LOCAL IUH L26_42w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_42w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_42w_d = (IHPE)L26_42w_d ;
LOCAL IUH L26_39if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_39if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_39if_f = (IHPE)L26_39if_f ;
LOCAL IUH L26_43w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_43w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_43w_t = (IHPE)L26_43w_t ;
LOCAL IUH L26_44w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_44w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_44w_d = (IHPE)L26_44w_d ;
LOCAL IUH L26_40if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_40if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_40if_d = (IHPE)L26_40if_d ;
GLOBAL IUH S_2111_DisabledRAMByteRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2111_DisabledRAMByteRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2111_DisabledRAMByteRead = (IHPE)S_2111_DisabledRAMByteRead ;
LOCAL IUH L13_2091if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2091if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2091if_f = (IHPE)L13_2091if_f ;
GLOBAL IUH S_2112_DisabledRAMWordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2112_DisabledRAMWordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2112_DisabledRAMWordRead = (IHPE)S_2112_DisabledRAMWordRead ;
LOCAL IUH L13_2092if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2092if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2092if_f = (IHPE)L13_2092if_f ;
GLOBAL IUH S_2113_DisabledRAMDwordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2113_DisabledRAMDwordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2113_DisabledRAMDwordRead = (IHPE)S_2113_DisabledRAMDwordRead ;
LOCAL IUH L13_2093if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2093if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2093if_f = (IHPE)L13_2093if_f ;
GLOBAL IUH S_2114_DisabledRAMStringReadFwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2114_DisabledRAMStringReadFwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2114_DisabledRAMStringReadFwd = (IHPE)S_2114_DisabledRAMStringReadFwd ;
LOCAL IUH L13_2094if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2094if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2094if_f = (IHPE)L13_2094if_f ;
LOCAL IUH L26_47w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_47w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_47w_t = (IHPE)L26_47w_t ;
LOCAL IUH L26_48w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_48w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_48w_d = (IHPE)L26_48w_d ;
LOCAL IUH L26_45if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_45if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_45if_f = (IHPE)L26_45if_f ;
LOCAL IUH L26_49w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_49w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_49w_t = (IHPE)L26_49w_t ;
LOCAL IUH L26_50w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_50w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_50w_d = (IHPE)L26_50w_d ;
LOCAL IUH L26_46if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_46if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_46if_d = (IHPE)L26_46if_d ;
GLOBAL IUH S_2115_SimpleByteRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2115_SimpleByteRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2115_SimpleByteRead = (IHPE)S_2115_SimpleByteRead ;
LOCAL IUH L13_2095if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2095if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2095if_f = (IHPE)L13_2095if_f ;
GLOBAL IUH S_2116_SimpleWordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2116_SimpleWordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2116_SimpleWordRead = (IHPE)S_2116_SimpleWordRead ;
LOCAL IUH L13_2096if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2096if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2096if_f = (IHPE)L13_2096if_f ;
GLOBAL IUH S_2117_SimpleDwordRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2117_SimpleDwordRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2117_SimpleDwordRead = (IHPE)S_2117_SimpleDwordRead ;
LOCAL IUH L13_2097if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2097if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2097if_f = (IHPE)L13_2097if_f ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	case	S_2087_RdMode0Chain2ByteRead_id	:
		S_2087_RdMode0Chain2ByteRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2087)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2067if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2067if_f_id	:
		L13_2067if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)&(r2)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r22))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	;	
	*((IU8	*)&(r2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2088_RdMode0Chain2WordRead_id	:
		S_2088_RdMode0Chain2WordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2088)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2068if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2068if_f_id	:
		L13_2068if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)&(r22)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)&(r22))	+	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r22))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	(1	<<	*((IU32	*)&(r21)	+	REGLONG)))	==	0)	goto	L26_0if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	;	
	{	extern	IUH	L26_1if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_1if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_0if_f_id	:
		L26_0if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	;	
	case	L26_1if_d_id	:
		L26_1if_d:	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+2)	+	REGWORD)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2089_RdMode0Chain2DwordRead_id	:
		S_2089_RdMode0Chain2DwordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2089)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2069if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2069if_f_id	:
		L13_2069if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16206)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2088_RdMode0Chain2WordRead()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2088_RdMode0Chain2WordRead(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004277),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IU16	*)(LocalIUH+2)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16207)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16206)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2088_RdMode0Chain2WordRead()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2088_RdMode0Chain2WordRead(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004277),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r20)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16207)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2090_RdMode0Chain2StringReadFwd_id	:
		S_2090_RdMode0Chain2StringReadFwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	28	>	0	)	LocalIUH	=	(IUH	*)malloc	(	28	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2090)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2070if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2070if_f_id	:
		L13_2070if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	(1	<<	*((IU32	*)&(r20)	+	REGLONG)))	==	0)	goto	L26_2if_f;	
	*((IUH	*)(LocalIUH+4))	=	(IS32)(3)	;	
	{	extern	IUH	L26_3if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_3if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_2if_f_id	:
		L26_2if_f:	;	
	*((IUH	*)(LocalIUH+4))	=	(IS32)(1)	;	
	case	L26_3if_d_id	:
		L26_3if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r22))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L26_4if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_7w_d;	
	case	L26_6w_t_id	:
		L26_6w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1284)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	^	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_6w_t;	
	case	L26_7w_d_id	:
		L26_7w_d:	;	
	{	extern	IUH	L26_5if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_5if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_4if_f_id	:
		L26_4if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_9w_d;	
	case	L26_8w_t_id	:
		L26_8w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1284)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	^	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_8w_t;	
	case	L26_9w_d_id	:
		L26_9w_d:	;	
	case	L26_5if_d_id	:
		L26_5if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2091_RdMode0Chain4ByteRead_id	:
		S_2091_RdMode0Chain4ByteRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2091)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2071if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2071if_f_id	:
		L13_2071if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	+	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IU8	*)&(r2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2092_RdMode0Chain4WordRead_id	:
		S_2092_RdMode0Chain4WordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2092)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2072if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2072if_f_id	:
		L13_2072if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*(UOFF_15_8(	(LocalIUH+1)	))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	+	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2093_RdMode0Chain4DwordRead_id	:
		S_2093_RdMode0Chain4DwordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2093)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2073if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2073if_f_id	:
		L13_2073if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*(UOFF_15_8(	(LocalIUH+1)	))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r22))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	+	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2094_RdMode0Chain4StringReadFwd_id	:
		S_2094_RdMode0Chain4StringReadFwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2094)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2074if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2074if_f_id	:
		L13_2074if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L26_10if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_13w_d;	
	case	L26_12w_t_id	:
		L26_12w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1284)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_12w_t;	
	case	L26_13w_d_id	:
		L26_13w_d:	;	
	{	extern	IUH	L26_11if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_11if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_10if_f_id	:
		L26_10if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_15w_d;	
	case	L26_14w_t_id	:
		L26_14w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1284)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_14w_t;	
	case	L26_15w_d_id	:
		L26_15w_d:	;	
	case	L26_11if_d_id	:
		L26_11if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2095_RdMode0UnchainedByteRead_id	:
		S_2095_RdMode0UnchainedByteRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2095)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2075if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2075if_f_id	:
		L13_2075if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1368)	;	
	if(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	>>	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU8	*)&(r2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2096_RdMode0UnchainedWordRead_id	:
		S_2096_RdMode0UnchainedWordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2096)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2076if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2076if_f_id	:
		L13_2076if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r22))	=	(IS32)(1368)	;	
	if(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	>>	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1368)	;	
	if(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	>>	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*(UOFF_15_8(	(LocalIUH+1)	))	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2097_RdMode0UnchainedDwordRead_id	:
		S_2097_RdMode0UnchainedDwordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2097)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2077if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2077if_f_id	:
		L13_2077if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16224)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2096_RdMode0UnchainedWordRead()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2096_RdMode0UnchainedWordRead(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004277),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IU16	*)(LocalIUH+2)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16225)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16224)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2096_RdMode0UnchainedWordRead()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2096_RdMode0UnchainedWordRead(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004277),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IU16	*)(LocalIUH+3)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16225)	;	
	*((IUH	*)&(r20))	=	*((IU16	*)(LocalIUH+3)	+	REGWORD);	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+2)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r21)	+	REGLONG)),	(IUH)(*((IU32	*)&(r22)	+	REGLONG))	))	|	((*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r21)	+	REGLONG)),	(IUH)(*((IU32	*)&(r22)	+	REGLONG))))	;
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2098_RdMode0UnchainedStringReadFwd_id	:
		S_2098_RdMode0UnchainedStringReadFwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2098)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2078if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2078if_f_id	:
		L13_2078if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L26_16if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_19w_d;	
	case	L26_18w_t_id	:
		L26_18w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1284)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_18w_t;	
	case	L26_19w_d_id	:
		L26_19w_d:	;	
	{	extern	IUH	L26_17if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_17if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_16if_f_id	:
		L26_16if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_21w_d;	
	case	L26_20w_t_id	:
		L26_20w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1284)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_20w_t;	
	case	L26_21w_d_id	:
		L26_21w_d:	;	
	case	L26_17if_d_id	:
		L26_17if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2099_RdMode1Chain2ByteRead_id	:
		S_2099_RdMode1Chain2ByteRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2099)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2079if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2079if_f_id	:
		L13_2079if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r22))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+1)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	(1	<<	*((IU32	*)&(r20)	+	REGLONG)))	==	0)	goto	L26_22if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	case	L26_22if_f_id	:
		L26_22if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r21))	=	(IS32)(1379)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1383)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	&	*((IU8	*)(LocalIUH+1)	+	REGBYTE);	
	*((IU8	*)&(r2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2100_RdMode1Chain2WordRead_id	:
		S_2100_RdMode1Chain2WordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2100)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2080if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2080if_f_id	:
		L13_2080if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)&(r22)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)&(r22))	+	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r22))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	(1	<<	*((IU32	*)&(r21)	+	REGLONG)))	==	0)	goto	L26_23if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	&	*((IU8	*)(LocalIUH+3)	+	REGBYTE);	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(6)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*(UOFF_15_8(	(LocalIUH+2)	))	&	*((IU8	*)(LocalIUH+3)	+	REGBYTE);	
	{	extern	IUH	L26_24if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_24if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_23if_f_id	:
		L26_23if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	&	*((IU8	*)(LocalIUH+3)	+	REGBYTE);	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1383)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*(UOFF_15_8(	(LocalIUH+2)	))	&	*((IU8	*)(LocalIUH+3)	+	REGBYTE);	
	case	L26_24if_d_id	:
		L26_24if_d:	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+2)	+	REGWORD)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2101_RdMode1Chain2DwordRead_id	:
		S_2101_RdMode1Chain2DwordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2101)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2081if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2081if_f_id	:
		L13_2081if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16236)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2100_RdMode1Chain2WordRead()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2100_RdMode1Chain2WordRead(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004277),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IU16	*)(LocalIUH+2)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16237)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16236)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2100_RdMode1Chain2WordRead()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2100_RdMode1Chain2WordRead(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004277),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r20)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16237)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2102_RdMode1Chain2StringReadFwd_id	:
		S_2102_RdMode1Chain2StringReadFwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	32	>	0	)	LocalIUH	=	(IUH	*)malloc	(	32	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2102)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2082if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2082if_f_id	:
		L13_2082if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	(1	<<	*((IU32	*)&(r21)	+	REGLONG)))	==	0)	goto	L26_25if_f;	
	*((IUH	*)(LocalIUH+4))	=	(IS32)(3)	;	
	{	extern	IUH	L26_26if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_26if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_25if_f_id	:
		L26_25if_f:	;	
	*((IUH	*)(LocalIUH+4))	=	(IS32)(1)	;	
	case	L26_26if_d_id	:
		L26_26if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r22))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;		
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L26_27if_f;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_30w_d;	
	case	L26_29w_t_id	:
		L26_29w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1383)	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)&(r22)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+7)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)(*((IHPE	*)&(r20)))	)	&	*((IU8	*)(LocalIUH+7)	+	REGBYTE);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	^	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_29w_t;	
	case	L26_30w_d_id	:
		L26_30w_d:	;	
	{	extern	IUH	L26_28if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_28if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_27if_f_id	:
		L26_27if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_32w_d;	
	case	L26_31w_t_id	:
		L26_31w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1383)	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)&(r22)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+7)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)(*((IHPE	*)&(r20)))	)	&	*((IU8	*)(LocalIUH+7)	+	REGBYTE);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	^	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_31w_t;	
	case	L26_32w_d_id	:
		L26_32w_d:	;	
	case	L26_28if_d_id	:
		L26_28if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2103_RdMode1Chain4ByteRead_id	:
		S_2103_RdMode1Chain4ByteRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2103)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2083if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2083if_f_id	:
		L13_2083if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)&(r22))	+	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r21))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1383)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IU8	*)&(r2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2104_RdMode1Chain4WordRead_id	:
		S_2104_RdMode1Chain4WordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2104)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2084if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2084if_f_id	:
		L13_2084if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*(UOFF_15_8(	(LocalIUH+1)	))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)&(r22))	+	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1378)	;	
	*((IU16	*)&(r20)	+	REGWORD	)	=	*((IU16	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
	*((IUH	*)&(r21))	=	(IS32)(1382)	;	
	*((IU16	*)&(r20)	+	REGWORD)	=	*((IU16	*)&(r20)	+	REGWORD)	|	*((IU16	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r20)	+	REGWORD	)	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2105_RdMode1Chain4DwordRead_id	:
		S_2105_RdMode1Chain4DwordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2105)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2085if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2085if_f_id	:
		L13_2085if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*(UOFF_15_8(	(LocalIUH+1)	))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(9)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r22))	=	(IS32)(23)	;	
	*((IUH	*)&(r23))	=	(IS32)(9)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)&(r22))	+	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1376)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1380)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2106_RdMode1Chain4StringReadFwd_id	:
		S_2106_RdMode1Chain4StringReadFwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2106)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2086if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2086if_f_id	:
		L13_2086if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L26_33if_f;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_36w_d;	
	case	L26_35w_t_id	:
		L26_35w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)&(r23)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1383)	;	
	*((IU8	*)&(r23)	+	REGBYTE)	=	*((IU8	*)&(r23)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)&(r23)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_35w_t;	
	case	L26_36w_d_id	:
		L26_36w_d:	;	
	{	extern	IUH	L26_34if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_34if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_33if_f_id	:
		L26_33if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_38w_d;	
	case	L26_37w_t_id	:
		L26_37w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)&(r23)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1383)	;	
	*((IU8	*)&(r23)	+	REGBYTE)	=	*((IU8	*)&(r23)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)&(r23)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_37w_t;	
	case	L26_38w_d_id	:
		L26_38w_d:	;	
	case	L26_34if_d_id	:
		L26_34if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2107_RdMode1UnchainedByteRead_id	:
		S_2107_RdMode1UnchainedByteRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2107)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2087if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2087if_f_id	:
		L13_2087if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1376)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1380)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IU8	*)&(r2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2108_RdMode1UnchainedWordRead_id	:
		S_2108_RdMode1UnchainedWordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2108)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2088if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2088if_f_id	:
		L13_2088if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1376)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1380)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1376)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1380)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*(UOFF_15_8(	(LocalIUH+3)	))	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+3)	+	REGWORD)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2109_RdMode1UnchainedDwordRead_id	:
		S_2109_RdMode1UnchainedDwordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	36	>	0	)	LocalIUH	=	(IUH	*)malloc	(	36	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2109)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2089if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2089if_f_id	:
		L13_2089if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1376)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1380)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1376)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1380)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*(UOFF_15_8(	(LocalIUH+3)	))	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1376)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1380)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r24))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r24)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r24)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r23)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r24)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r24)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r24))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r24)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r24)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r24)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r24)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r23))	=	(IS32)(24)	;	
	*((IUH	*)&(r24))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r24)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)	>	32	||	*((IU32	*)&(r24)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r24)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r24)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+6)	+	REGLONG);	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(12)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1376)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1380)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(0)	;	
	*((IUH	*)&(r24))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r24)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)	>	32	||	*((IU32	*)&(r24)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r24)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r24)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	*((IUH	*)&(r24))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r24)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)	>	32	||	*((IU32	*)&(r24)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r24)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r24)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+7)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2110_RdMode1UnchainedStringReadFwd_id	:
		S_2110_RdMode1UnchainedStringReadFwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	36	>	0	)	LocalIUH	=	(IUH	*)malloc	(	36	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2110)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2090if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2090if_f_id	:
		L13_2090if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1372)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L26_39if_f;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_42w_d;	
	case	L26_41w_t_id	:
		L26_41w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)&(r21)	+	REGBYTE);	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r21)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r21)	+	REGLONG));	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+7)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_41w_t;	
	case	L26_42w_d_id	:
		L26_42w_d:	;	
	{	extern	IUH	L26_40if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_40if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_39if_f_id	:
		L26_39if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_44w_d;	
	case	L26_43w_t_id	:
		L26_43w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)&(r21)	+	REGBYTE);	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r21)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r21)	+	REGLONG));	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_43w_t;	
	case	L26_44w_d_id	:
		L26_44w_d:	;	
	case	L26_40if_d_id	:
		L26_40if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2111_DisabledRAMByteRead_id	:
		S_2111_DisabledRAMByteRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2111)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2091if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2091if_f_id	:
		L13_2091if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	(IS32)(-1)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	(IS32)(-1)	;	
	*((IU8	*)&(r2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2112_DisabledRAMWordRead_id	:
		S_2112_DisabledRAMWordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2112)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2092if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2092if_f_id	:
		L13_2092if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	(IS32)(-1)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	(IS32)(-1)	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2113_DisabledRAMDwordRead_id	:
		S_2113_DisabledRAMDwordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2113)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2093if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2093if_f_id	:
		L13_2093if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	(IS32)(-1)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2114_DisabledRAMStringReadFwd_id	:
		S_2114_DisabledRAMStringReadFwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2114)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2094if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2094if_f_id	:
		L13_2094if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L26_45if_f;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_48w_d;	
	case	L26_47w_t_id	:
		L26_47w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(-1)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_47w_t;	
	case	L26_48w_d_id	:
		L26_48w_d:	;	
	{	extern	IUH	L26_46if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_46if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_45if_f_id	:
		L26_45if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_50w_d;	
	case	L26_49w_t_id	:
		L26_49w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(-1)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_49w_t;	
	case	L26_50w_d_id	:
		L26_50w_d:	;	
	case	L26_46if_d_id	:
		L26_46if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	(IS32)(-1)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2115_SimpleByteRead_id	:
		S_2115_SimpleByteRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2115)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2095if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2095if_f_id	:
		L13_2095if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)(*((IHPE	*)&(r20)))	)	;	
	*((IU8	*)&(r2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2116_SimpleWordRead_id	:
		S_2116_SimpleWordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2116)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2096if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2096if_f_id	:
		L13_2096if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1400)	;	
	*(UOFF_15_8(	(LocalIUH+1)	))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2117_SimpleDwordRead_id	:
		S_2117_SimpleDwordRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2117)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2097if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2097if_f_id	:
		L13_2097if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*(UOFF_15_8(	(LocalIUH+1)	))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r21)	+	REGLONG)),	(IUH)(*((IU32	*)&(r22)	+	REGLONG))	))	|	((*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r21)	+	REGLONG)),	(IUH)(*((IU32	*)&(r22)	+	REGLONG))))	;
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\sevid002.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_2150_SimpleDwordMove_Bwd_id,
L13_2130if_f_id,
L27_38w_t_id,
L27_39w_d_id,
L27_36if_f_id,
L27_40w_t_id,
L27_41w_d_id,
L27_37if_d_id,
S_2151_UnchainedByteWrite_00000000_0000000e_00000001_id,
L13_2131if_f_id,
S_2152_UnchainedByteFill_00000000_0000000e_00000001_id,
L13_2132if_f_id,
L28_0if_f_id,
L28_1if_f_id,
L28_2if_f_id,
L28_3if_f_id,
S_2153_Unchained1PlaneByteFill_id,
L13_2133if_f_id,
L28_4w_t_id,
L28_5w_d_id,
S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000_id,
L13_2134if_f_id,
L28_6if_f_id,
L28_7if_d_id,
S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000_id,
L13_2135if_f_id,
L23_0if_f_id,
L23_1if_f_id,
L23_2if_f_id,
L23_3if_f_id,
S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000_id,
L13_2136if_f_id,
L23_6w_t_id,
L23_7w_d_id,
L23_4if_f_id,
L23_8w_t_id,
L23_9w_d_id,
L23_5if_d_id,
S_2157_UnchainedWordWrite_00000000_0000000e_00000001_id,
L13_2137if_f_id,
S_2158_UnchainedWordFill_00000000_0000000e_00000001_id,
L13_2138if_f_id,
L28_8if_f_id,
L28_9if_f_id,
L28_10if_f_id,
L28_11if_f_id,
S_2159_Unchained1PlaneWordFill_id,
L13_2139if_f_id,
L28_12w_t_id,
L28_13w_d_id,
S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000_id,
L13_2140if_f_id,
L28_14if_f_id,
L28_15if_d_id,
S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000_id,
L13_2141if_f_id,
L23_10if_f_id,
L23_11if_f_id,
L23_12if_f_id,
L23_13if_f_id,
S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000_id,
L13_2142if_f_id,
L23_16w_t_id,
L23_17w_d_id,
L23_14if_f_id,
L23_18w_t_id,
L23_19w_d_id,
L23_15if_d_id,
S_2163_UnchainedDwordWrite_00000000_0000000e_00000001_id,
L13_2143if_f_id,
S_2164_UnchainedDwordFill_00000000_0000000e_00000001_id,
L13_2144if_f_id,
S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000_id,
L13_2145if_f_id,
S_2166_UnchainedByteWrite_00000001_0000000e_00000001_id,
L13_2146if_f_id,
S_2167_UnchainedByteFill_00000001_0000000e_00000001_id,
L13_2147if_f_id,
L28_16if_f_id,
L28_17if_f_id,
L28_18if_f_id,
L28_19if_f_id,
S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000_id,
L13_2148if_f_id,
L28_20if_f_id,
L28_22if_f_id,
L28_23if_f_id,
L28_24if_f_id,
L28_25if_f_id,
L28_21if_d_id,
S_2169_CopyDirByte1Plane_00000000_id,
L13_2149if_f_id,
S_2170_CopyFwdByte1Plane_id,
L13_2150if_f_id,
L23_20w_t_id,
L23_21w_d_id,
S_2171_UnchainedWordWrite_00000001_0000000e_00000001_id,
L13_2151if_f_id,
S_2172_UnchainedWordFill_00000001_0000000e_00000001_id,
L13_2152if_f_id,
L28_26if_f_id,
L28_27if_f_id,
L28_28if_f_id,
L28_29if_f_id,
S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000_id,
L13_2153if_f_id,
L28_30if_f_id,
L28_32if_f_id,
L28_33if_f_id,
L28_34if_f_id,
L28_35if_f_id,
L28_31if_d_id,
S_2174_CopyDirWord1Plane_00000000_id,
L13_2154if_f_id,
S_2175_CopyFwdWord1Plane_id,
L13_2155if_f_id,
L23_22w_t_id,
L23_23w_d_id,
S_2176_UnchainedDwordWrite_00000001_0000000e_00000001_id,
L13_2156if_f_id,
S_2177_UnchainedDwordFill_00000001_0000000e_00000001_id,
L13_2157if_f_id,
S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000_id,
L13_2158if_f_id,
S_2179_UnchainedByteWrite_00000002_0000000e_00000001_id,
L13_2159if_f_id,
S_2180_UnchainedByteFill_00000002_0000000e_00000001_id,
L13_2160if_f_id,
L28_36if_f_id,
L28_37if_f_id,
L28_38if_f_id,
L28_39if_f_id,
S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000_id,
L13_2161if_f_id,
L28_40if_f_id,
L28_41if_d_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_2150_SimpleDwordMove_Bwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2150_SimpleDwordMove_Bwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2150_SimpleDwordMove_Bwd = (IHPE)S_2150_SimpleDwordMove_Bwd ;
LOCAL IUH L13_2130if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2130if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2130if_f = (IHPE)L13_2130if_f ;
LOCAL IUH L27_38w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_38w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_38w_t = (IHPE)L27_38w_t ;
LOCAL IUH L27_39w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_39w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_39w_d = (IHPE)L27_39w_d ;
LOCAL IUH L27_36if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_36if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_36if_f = (IHPE)L27_36if_f ;
LOCAL IUH L27_40w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_40w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_40w_t = (IHPE)L27_40w_t ;
LOCAL IUH L27_41w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_41w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_41w_d = (IHPE)L27_41w_d ;
LOCAL IUH L27_37if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_37if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_37if_d = (IHPE)L27_37if_d ;
GLOBAL IUH S_2151_UnchainedByteWrite_00000000_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2151_UnchainedByteWrite_00000000_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2151_UnchainedByteWrite_00000000_0000000e_00000001 = (IHPE)S_2151_UnchainedByteWrite_00000000_0000000e_00000001 ;
LOCAL IUH L13_2131if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2131if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2131if_f = (IHPE)L13_2131if_f ;
GLOBAL IUH S_2152_UnchainedByteFill_00000000_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2152_UnchainedByteFill_00000000_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2152_UnchainedByteFill_00000000_0000000e_00000001 = (IHPE)S_2152_UnchainedByteFill_00000000_0000000e_00000001 ;
LOCAL IUH L13_2132if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2132if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2132if_f = (IHPE)L13_2132if_f ;
LOCAL IUH L28_0if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_0if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_0if_f = (IHPE)L28_0if_f ;
LOCAL IUH L28_1if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_1if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_1if_f = (IHPE)L28_1if_f ;
LOCAL IUH L28_2if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_2if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_2if_f = (IHPE)L28_2if_f ;
LOCAL IUH L28_3if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_3if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_3if_f = (IHPE)L28_3if_f ;
GLOBAL IUH S_2153_Unchained1PlaneByteFill IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2153_Unchained1PlaneByteFill_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2153_Unchained1PlaneByteFill = (IHPE)S_2153_Unchained1PlaneByteFill ;
LOCAL IUH L13_2133if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2133if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2133if_f = (IHPE)L13_2133if_f ;
LOCAL IUH L28_4w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_4w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_4w_t = (IHPE)L28_4w_t ;
LOCAL IUH L28_5w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_5w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_5w_d = (IHPE)L28_5w_d ;
GLOBAL IUH S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000 = (IHPE)S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000 ;
LOCAL IUH L13_2134if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2134if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2134if_f = (IHPE)L13_2134if_f ;
LOCAL IUH L28_6if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_6if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_6if_f = (IHPE)L28_6if_f ;
LOCAL IUH L28_7if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_7if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_7if_d = (IHPE)L28_7if_d ;
GLOBAL IUH S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000 = (IHPE)S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000 ;
LOCAL IUH L13_2135if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2135if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2135if_f = (IHPE)L13_2135if_f ;
LOCAL IUH L23_0if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_0if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_0if_f = (IHPE)L23_0if_f ;
LOCAL IUH L23_1if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1if_f = (IHPE)L23_1if_f ;
LOCAL IUH L23_2if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_2if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_2if_f = (IHPE)L23_2if_f ;
LOCAL IUH L23_3if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_3if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_3if_f = (IHPE)L23_3if_f ;
GLOBAL IUH S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000 = (IHPE)S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000 ;
LOCAL IUH L13_2136if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2136if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2136if_f = (IHPE)L13_2136if_f ;
LOCAL IUH L23_6w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_6w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_6w_t = (IHPE)L23_6w_t ;
LOCAL IUH L23_7w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_7w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_7w_d = (IHPE)L23_7w_d ;
LOCAL IUH L23_4if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_4if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_4if_f = (IHPE)L23_4if_f ;
LOCAL IUH L23_8w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_8w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_8w_t = (IHPE)L23_8w_t ;
LOCAL IUH L23_9w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_9w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_9w_d = (IHPE)L23_9w_d ;
LOCAL IUH L23_5if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_5if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_5if_d = (IHPE)L23_5if_d ;
GLOBAL IUH S_2157_UnchainedWordWrite_00000000_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2157_UnchainedWordWrite_00000000_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2157_UnchainedWordWrite_00000000_0000000e_00000001 = (IHPE)S_2157_UnchainedWordWrite_00000000_0000000e_00000001 ;
LOCAL IUH L13_2137if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2137if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2137if_f = (IHPE)L13_2137if_f ;
GLOBAL IUH S_2158_UnchainedWordFill_00000000_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2158_UnchainedWordFill_00000000_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2158_UnchainedWordFill_00000000_0000000e_00000001 = (IHPE)S_2158_UnchainedWordFill_00000000_0000000e_00000001 ;
LOCAL IUH L13_2138if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2138if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2138if_f = (IHPE)L13_2138if_f ;
LOCAL IUH L28_8if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_8if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_8if_f = (IHPE)L28_8if_f ;
LOCAL IUH L28_9if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_9if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_9if_f = (IHPE)L28_9if_f ;
LOCAL IUH L28_10if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_10if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_10if_f = (IHPE)L28_10if_f ;
LOCAL IUH L28_11if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_11if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_11if_f = (IHPE)L28_11if_f ;
GLOBAL IUH S_2159_Unchained1PlaneWordFill IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2159_Unchained1PlaneWordFill_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2159_Unchained1PlaneWordFill = (IHPE)S_2159_Unchained1PlaneWordFill ;
LOCAL IUH L13_2139if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2139if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2139if_f = (IHPE)L13_2139if_f ;
LOCAL IUH L28_12w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_12w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_12w_t = (IHPE)L28_12w_t ;
LOCAL IUH L28_13w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_13w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_13w_d = (IHPE)L28_13w_d ;
GLOBAL IUH S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000 = (IHPE)S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000 ;
LOCAL IUH L13_2140if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2140if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2140if_f = (IHPE)L13_2140if_f ;
LOCAL IUH L28_14if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_14if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_14if_f = (IHPE)L28_14if_f ;
LOCAL IUH L28_15if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_15if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_15if_d = (IHPE)L28_15if_d ;
GLOBAL IUH S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000 = (IHPE)S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000 ;
LOCAL IUH L13_2141if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2141if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2141if_f = (IHPE)L13_2141if_f ;
LOCAL IUH L23_10if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_10if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_10if_f = (IHPE)L23_10if_f ;
LOCAL IUH L23_11if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_11if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_11if_f = (IHPE)L23_11if_f ;
LOCAL IUH L23_12if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_12if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_12if_f = (IHPE)L23_12if_f ;
LOCAL IUH L23_13if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_13if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_13if_f = (IHPE)L23_13if_f ;
GLOBAL IUH S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000 = (IHPE)S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000 ;
LOCAL IUH L13_2142if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2142if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2142if_f = (IHPE)L13_2142if_f ;
LOCAL IUH L23_16w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_16w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_16w_t = (IHPE)L23_16w_t ;
LOCAL IUH L23_17w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_17w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_17w_d = (IHPE)L23_17w_d ;
LOCAL IUH L23_14if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_14if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_14if_f = (IHPE)L23_14if_f ;
LOCAL IUH L23_18w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_18w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_18w_t = (IHPE)L23_18w_t ;
LOCAL IUH L23_19w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_19w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_19w_d = (IHPE)L23_19w_d ;
LOCAL IUH L23_15if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_15if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_15if_d = (IHPE)L23_15if_d ;
GLOBAL IUH S_2163_UnchainedDwordWrite_00000000_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2163_UnchainedDwordWrite_00000000_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2163_UnchainedDwordWrite_00000000_0000000e_00000001 = (IHPE)S_2163_UnchainedDwordWrite_00000000_0000000e_00000001 ;
LOCAL IUH L13_2143if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2143if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2143if_f = (IHPE)L13_2143if_f ;
GLOBAL IUH S_2164_UnchainedDwordFill_00000000_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2164_UnchainedDwordFill_00000000_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2164_UnchainedDwordFill_00000000_0000000e_00000001 = (IHPE)S_2164_UnchainedDwordFill_00000000_0000000e_00000001 ;
LOCAL IUH L13_2144if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2144if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2144if_f = (IHPE)L13_2144if_f ;
GLOBAL IUH S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000 = (IHPE)S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000 ;
LOCAL IUH L13_2145if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2145if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2145if_f = (IHPE)L13_2145if_f ;
GLOBAL IUH S_2166_UnchainedByteWrite_00000001_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2166_UnchainedByteWrite_00000001_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2166_UnchainedByteWrite_00000001_0000000e_00000001 = (IHPE)S_2166_UnchainedByteWrite_00000001_0000000e_00000001 ;
LOCAL IUH L13_2146if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2146if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2146if_f = (IHPE)L13_2146if_f ;
GLOBAL IUH S_2167_UnchainedByteFill_00000001_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2167_UnchainedByteFill_00000001_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2167_UnchainedByteFill_00000001_0000000e_00000001 = (IHPE)S_2167_UnchainedByteFill_00000001_0000000e_00000001 ;
LOCAL IUH L13_2147if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2147if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2147if_f = (IHPE)L13_2147if_f ;
LOCAL IUH L28_16if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_16if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_16if_f = (IHPE)L28_16if_f ;
LOCAL IUH L28_17if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_17if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_17if_f = (IHPE)L28_17if_f ;
LOCAL IUH L28_18if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_18if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_18if_f = (IHPE)L28_18if_f ;
LOCAL IUH L28_19if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_19if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_19if_f = (IHPE)L28_19if_f ;
GLOBAL IUH S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000 = (IHPE)S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000 ;
LOCAL IUH L13_2148if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2148if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2148if_f = (IHPE)L13_2148if_f ;
LOCAL IUH L28_20if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_20if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_20if_f = (IHPE)L28_20if_f ;
LOCAL IUH L28_22if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_22if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_22if_f = (IHPE)L28_22if_f ;
LOCAL IUH L28_23if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_23if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_23if_f = (IHPE)L28_23if_f ;
LOCAL IUH L28_24if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_24if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_24if_f = (IHPE)L28_24if_f ;
LOCAL IUH L28_25if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_25if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_25if_f = (IHPE)L28_25if_f ;
LOCAL IUH L28_21if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_21if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_21if_d = (IHPE)L28_21if_d ;
GLOBAL IUH S_2169_CopyDirByte1Plane_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2169_CopyDirByte1Plane_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2169_CopyDirByte1Plane_00000000 = (IHPE)S_2169_CopyDirByte1Plane_00000000 ;
LOCAL IUH L13_2149if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2149if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2149if_f = (IHPE)L13_2149if_f ;
GLOBAL IUH S_2170_CopyFwdByte1Plane IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2170_CopyFwdByte1Plane_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2170_CopyFwdByte1Plane = (IHPE)S_2170_CopyFwdByte1Plane ;
LOCAL IUH L13_2150if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2150if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2150if_f = (IHPE)L13_2150if_f ;
LOCAL IUH L23_20w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_20w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_20w_t = (IHPE)L23_20w_t ;
LOCAL IUH L23_21w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_21w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_21w_d = (IHPE)L23_21w_d ;
GLOBAL IUH S_2171_UnchainedWordWrite_00000001_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2171_UnchainedWordWrite_00000001_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2171_UnchainedWordWrite_00000001_0000000e_00000001 = (IHPE)S_2171_UnchainedWordWrite_00000001_0000000e_00000001 ;
LOCAL IUH L13_2151if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2151if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2151if_f = (IHPE)L13_2151if_f ;
GLOBAL IUH S_2172_UnchainedWordFill_00000001_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2172_UnchainedWordFill_00000001_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2172_UnchainedWordFill_00000001_0000000e_00000001 = (IHPE)S_2172_UnchainedWordFill_00000001_0000000e_00000001 ;
LOCAL IUH L13_2152if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2152if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2152if_f = (IHPE)L13_2152if_f ;
LOCAL IUH L28_26if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_26if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_26if_f = (IHPE)L28_26if_f ;
LOCAL IUH L28_27if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_27if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_27if_f = (IHPE)L28_27if_f ;
LOCAL IUH L28_28if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_28if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_28if_f = (IHPE)L28_28if_f ;
LOCAL IUH L28_29if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_29if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_29if_f = (IHPE)L28_29if_f ;
GLOBAL IUH S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000 = (IHPE)S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000 ;
LOCAL IUH L13_2153if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2153if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2153if_f = (IHPE)L13_2153if_f ;
LOCAL IUH L28_30if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_30if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_30if_f = (IHPE)L28_30if_f ;
LOCAL IUH L28_32if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_32if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_32if_f = (IHPE)L28_32if_f ;
LOCAL IUH L28_33if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_33if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_33if_f = (IHPE)L28_33if_f ;
LOCAL IUH L28_34if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_34if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_34if_f = (IHPE)L28_34if_f ;
LOCAL IUH L28_35if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_35if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_35if_f = (IHPE)L28_35if_f ;
LOCAL IUH L28_31if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_31if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_31if_d = (IHPE)L28_31if_d ;
GLOBAL IUH S_2174_CopyDirWord1Plane_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2174_CopyDirWord1Plane_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2174_CopyDirWord1Plane_00000000 = (IHPE)S_2174_CopyDirWord1Plane_00000000 ;
LOCAL IUH L13_2154if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2154if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2154if_f = (IHPE)L13_2154if_f ;
GLOBAL IUH S_2175_CopyFwdWord1Plane IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2175_CopyFwdWord1Plane_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2175_CopyFwdWord1Plane = (IHPE)S_2175_CopyFwdWord1Plane ;
LOCAL IUH L13_2155if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2155if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2155if_f = (IHPE)L13_2155if_f ;
LOCAL IUH L23_22w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_22w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_22w_t = (IHPE)L23_22w_t ;
LOCAL IUH L23_23w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_23w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_23w_d = (IHPE)L23_23w_d ;
GLOBAL IUH S_2176_UnchainedDwordWrite_00000001_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2176_UnchainedDwordWrite_00000001_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2176_UnchainedDwordWrite_00000001_0000000e_00000001 = (IHPE)S_2176_UnchainedDwordWrite_00000001_0000000e_00000001 ;
LOCAL IUH L13_2156if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2156if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2156if_f = (IHPE)L13_2156if_f ;
GLOBAL IUH S_2177_UnchainedDwordFill_00000001_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2177_UnchainedDwordFill_00000001_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2177_UnchainedDwordFill_00000001_0000000e_00000001 = (IHPE)S_2177_UnchainedDwordFill_00000001_0000000e_00000001 ;
LOCAL IUH L13_2157if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2157if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2157if_f = (IHPE)L13_2157if_f ;
GLOBAL IUH S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000 = (IHPE)S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000 ;
LOCAL IUH L13_2158if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2158if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2158if_f = (IHPE)L13_2158if_f ;
GLOBAL IUH S_2179_UnchainedByteWrite_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2179_UnchainedByteWrite_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2179_UnchainedByteWrite_00000002_0000000e_00000001 = (IHPE)S_2179_UnchainedByteWrite_00000002_0000000e_00000001 ;
LOCAL IUH L13_2159if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2159if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2159if_f = (IHPE)L13_2159if_f ;
GLOBAL IUH S_2180_UnchainedByteFill_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2180_UnchainedByteFill_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2180_UnchainedByteFill_00000002_0000000e_00000001 = (IHPE)S_2180_UnchainedByteFill_00000002_0000000e_00000001 ;
LOCAL IUH L13_2160if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2160if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2160if_f = (IHPE)L13_2160if_f ;
LOCAL IUH L28_36if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_36if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_36if_f = (IHPE)L28_36if_f ;
LOCAL IUH L28_37if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_37if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_37if_f = (IHPE)L28_37if_f ;
LOCAL IUH L28_38if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_38if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_38if_f = (IHPE)L28_38if_f ;
LOCAL IUH L28_39if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_39if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_39if_f = (IHPE)L28_39if_f ;
GLOBAL IUH S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000 = (IHPE)S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000 ;
LOCAL IUH L13_2161if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2161if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2161if_f = (IHPE)L13_2161if_f ;
LOCAL IUH L28_40if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_40if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_40if_f = (IHPE)L28_40if_f ;
LOCAL IUH L28_41if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_41if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_41if_d = (IHPE)L28_41if_d ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2150_SimpleDwordMove_Bwd_id	:
		S_2150_SimpleDwordMove_Bwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	28	>	0	)	LocalIUH	=	(IUH	*)malloc	(	28	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2150)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2130if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2130if_f_id	:
		L13_2130if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	*	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+1)	+	REGLONG);	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L27_36if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_39w_d;	
	case	L27_38w_t_id	:
		L27_38w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_38w_t;	
	case	L27_39w_d_id	:
		L27_39w_d:	;	
	{	extern	IUH	L27_37if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L27_37if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L27_36if_f_id	:
		L27_36if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_41w_d;	
	case	L27_40w_t_id	:
		L27_40w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_40w_t;	
	case	L27_41w_d_id	:
		L27_41w_d:	;	
	case	L27_37if_d_id	:
		L27_37if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2151_UnchainedByteWrite_00000000_0000000e_00000001_id	:
		S_2151_UnchainedByteWrite_00000000_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2151)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2131if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2131if_f_id	:
		L13_2131if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1356)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2152_UnchainedByteFill_00000000_0000000e_00000001_id	:
		S_2152_UnchainedByteFill_00000000_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2152)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2132if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2132if_f_id	:
		L13_2132if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_0if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_0if_f_id	:
		L28_0if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_1if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+4)	))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_1if_f_id	:
		L28_1if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_2if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_2if_f_id	:
		L28_2if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_3if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_3if_f_id	:
		L28_3if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2153_Unchained1PlaneByteFill_id	:
		S_2153_Unchained1PlaneByteFill	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2153)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2133if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2133if_f_id	:
		L13_2133if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L28_5w_d;	
	case	L28_4w_t_id	:
		L28_4w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+3))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+3))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+3))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L28_4w_t;	
	case	L28_5w_d_id	:
		L28_5w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000_id	:
		S_2154_UnchainedByteMove_00000000_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2154)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2134if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2134if_f_id	:
		L13_2134if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L28_6if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	{	extern	IUH	L28_7if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_7if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_6if_f_id	:
		L28_6if_f:	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	case	L28_7if_d_id	:
		L28_7if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000_id	:
		S_2155_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2155)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2135if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2135if_f_id	:
		L13_2135if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_0if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_0if_f_id	:
		L23_0if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_1if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_1if_f_id	:
		L23_1if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_2if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_2if_f_id	:
		L23_2if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_3if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_3if_f_id	:
		L23_3if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000_id	:
		S_2156_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2156)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2136if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2136if_f_id	:
		L13_2136if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_4if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_7w_d;	
	case	L23_6w_t_id	:
		L23_6w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_6w_t;	
	case	L23_7w_d_id	:
		L23_7w_d:	;	
	{	extern	IUH	L23_5if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_5if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_4if_f_id	:
		L23_4if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_9w_d;	
	case	L23_8w_t_id	:
		L23_8w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_8w_t;	
	case	L23_9w_d_id	:
		L23_9w_d:	;	
	case	L23_5if_d_id	:
		L23_5if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2157_UnchainedWordWrite_00000000_0000000e_00000001_id	:
		S_2157_UnchainedWordWrite_00000000_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2157)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2137if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2137if_f_id	:
		L13_2137if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1360)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(*((IHPE	*)&(r21)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2158_UnchainedWordFill_00000000_0000000e_00000001_id	:
		S_2158_UnchainedWordFill_00000000_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2158)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2138if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2138if_f_id	:
		L13_2138if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_8if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+5)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_8if_f_id	:
		L28_8if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_9if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+4)	))	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+5)	))	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_9if_f_id	:
		L28_9if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_10if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+5)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_10if_f_id	:
		L28_10if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_11if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+5)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_11if_f_id	:
		L28_11if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2159_Unchained1PlaneWordFill_id	:
		S_2159_Unchained1PlaneWordFill	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2159)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2139if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2139if_f_id	:
		L13_2139if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)&(r4)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L28_13w_d;	
	case	L28_12w_t_id	:
		L28_12w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L28_12w_t;	
	case	L28_13w_d_id	:
		L28_13w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000_id	:
		S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2160)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2140if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2140if_f_id	:
		L13_2140if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L28_14if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	{	extern	IUH	L28_15if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_15if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_14if_f_id	:
		L28_14if_f:	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	case	L28_15if_d_id	:
		L28_15if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000_id	:
		S_2161_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2161)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2141if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2141if_f_id	:
		L13_2141if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_10if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_10if_f_id	:
		L23_10if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_11if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_11if_f_id	:
		L23_11if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_12if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_12if_f_id	:
		L23_12if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_13if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_13if_f_id	:
		L23_13if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000_id	:
		S_2162_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2162)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2142if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2142if_f_id	:
		L13_2142if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_14if_f;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_17w_d;	
	case	L23_16w_t_id	:
		L23_16w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_16w_t;	
	case	L23_17w_d_id	:
		L23_17w_d:	;	
	{	extern	IUH	L23_15if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_15if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_14if_f_id	:
		L23_14if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_19w_d;	
	case	L23_18w_t_id	:
		L23_18w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_18w_t;	
	case	L23_19w_d_id	:
		L23_19w_d:	;	
	case	L23_15if_d_id	:
		L23_15if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2163_UnchainedDwordWrite_00000000_0000000e_00000001_id	:
		S_2163_UnchainedDwordWrite_00000000_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2163)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2143if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2143if_f_id	:
		L13_2143if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16388)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2157_UnchainedWordWrite_00000000_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2157_UnchainedWordWrite_00000000_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16389)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16388)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)&(r20)	+	REGWORD)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2157_UnchainedWordWrite_00000000_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2157_UnchainedWordWrite_00000000_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16389)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2164_UnchainedDwordFill_00000000_0000000e_00000001_id	:
		S_2164_UnchainedDwordFill_00000000_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2164)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2144if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2144if_f_id	:
		L13_2144if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2158_UnchainedWordFill_00000000_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2158_UnchainedWordFill_00000000_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)&(r20)	+	REGWORD)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2158_UnchainedWordFill_00000000_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2158_UnchainedWordFill_00000000_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000_id	:
		S_2165_UnchainedDwordMove_00000000_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2165)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2145if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2145if_f_id	:
		L13_2145if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16396)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2160_UnchainedWordMove_00000000_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16397)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2166_UnchainedByteWrite_00000001_0000000e_00000001_id	:
		S_2166_UnchainedByteWrite_00000001_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2166)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2146if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2146if_f_id	:
		L13_2146if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1356)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2167_UnchainedByteFill_00000001_0000000e_00000001_id	:
		S_2167_UnchainedByteFill_00000001_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2167)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2147if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2147if_f_id	:
		L13_2147if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_16if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_16if_f_id	:
		L28_16if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_17if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+4)	))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_17if_f_id	:
		L28_17if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_18if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_18if_f_id	:
		L28_18if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_19if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_19if_f_id	:
		L28_19if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000_id	:
		S_2168_UnchainedByteMove_00000001_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2168)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2148if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2148if_f_id	:
		L13_2148if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_20if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16398)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	(IS32)(-1)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2167_UnchainedByteFill_00000001_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2167_UnchainedByteFill_00000001_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16399)	;	
	{	extern	IUH	L28_21if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_21if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_20if_f_id	:
		L28_20if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_22if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16400)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2169_CopyDirByte1Plane_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2169_CopyDirByte1Plane_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16401)	;	
	case	L28_22if_f_id	:
		L28_22if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_23if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16400)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2169_CopyDirByte1Plane_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2169_CopyDirByte1Plane_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16401)	;	
	case	L28_23if_f_id	:
		L28_23if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_24if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16400)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2169_CopyDirByte1Plane_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2169_CopyDirByte1Plane_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16401)	;	
	case	L28_24if_f_id	:
		L28_24if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_25if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16400)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2169_CopyDirByte1Plane_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2169_CopyDirByte1Plane_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16401)	;	
	case	L28_25if_f_id	:
		L28_25if_f:	;	
	case	L28_21if_d_id	:
		L28_21if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2169_CopyDirByte1Plane_00000000_id	:
		S_2169_CopyDirByte1Plane_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2169)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2149if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2149if_f_id	:
		L13_2149if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16402)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2170_CopyFwdByte1Plane()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2170_CopyFwdByte1Plane(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16403)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2170_CopyFwdByte1Plane_id	:
		S_2170_CopyFwdByte1Plane	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2170)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2150if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2150if_f_id	:
		L13_2150if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_21w_d;	
	case	L23_20w_t_id	:
		L23_20w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_20w_t;	
	case	L23_21w_d_id	:
		L23_21w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2171_UnchainedWordWrite_00000001_0000000e_00000001_id	:
		S_2171_UnchainedWordWrite_00000001_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2171)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2151if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2151if_f_id	:
		L13_2151if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1360)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(*((IHPE	*)&(r21)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2172_UnchainedWordFill_00000001_0000000e_00000001_id	:
		S_2172_UnchainedWordFill_00000001_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2172)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2152if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2152if_f_id	:
		L13_2152if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_26if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+5)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_26if_f_id	:
		L28_26if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_27if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+4)	))	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+5)	))	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_27if_f_id	:
		L28_27if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_28if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+5)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_28if_f_id	:
		L28_28if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_29if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+5)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_29if_f_id	:
		L28_29if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000_id	:
		S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2173)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2153if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2153if_f_id	:
		L13_2153if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_30if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	(IS32)(-1)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2172_UnchainedWordFill_00000001_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2172_UnchainedWordFill_00000001_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
	{	extern	IUH	L28_31if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_31if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_30if_f_id	:
		L28_30if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_32if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2174_CopyDirWord1Plane_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2174_CopyDirWord1Plane_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L28_32if_f_id	:
		L28_32if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_33if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2174_CopyDirWord1Plane_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2174_CopyDirWord1Plane_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L28_33if_f_id	:
		L28_33if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_34if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2174_CopyDirWord1Plane_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2174_CopyDirWord1Plane_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L28_34if_f_id	:
		L28_34if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_35if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2174_CopyDirWord1Plane_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2174_CopyDirWord1Plane_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L28_35if_f_id	:
		L28_35if_f:	;	
	case	L28_31if_d_id	:
		L28_31if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2174_CopyDirWord1Plane_00000000_id	:
		S_2174_CopyDirWord1Plane_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2174)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2154if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2154if_f_id	:
		L13_2154if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16406)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2175_CopyFwdWord1Plane()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2175_CopyFwdWord1Plane(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16407)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2175_CopyFwdWord1Plane_id	:
		S_2175_CopyFwdWord1Plane	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2175)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2155if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2155if_f_id	:
		L13_2155if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_23w_d;	
	case	L23_22w_t_id	:
		L23_22w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_22w_t;	
	case	L23_23w_d_id	:
		L23_23w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2176_UnchainedDwordWrite_00000001_0000000e_00000001_id	:
		S_2176_UnchainedDwordWrite_00000001_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2176)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2156if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2156if_f_id	:
		L13_2156if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16388)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2171_UnchainedWordWrite_00000001_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2171_UnchainedWordWrite_00000001_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16389)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16388)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)&(r20)	+	REGWORD)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2171_UnchainedWordWrite_00000001_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2171_UnchainedWordWrite_00000001_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16389)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2177_UnchainedDwordFill_00000001_0000000e_00000001_id	:
		S_2177_UnchainedDwordFill_00000001_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2177)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2157if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2157if_f_id	:
		L13_2157if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2172_UnchainedWordFill_00000001_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2172_UnchainedWordFill_00000001_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)&(r20)	+	REGWORD)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2172_UnchainedWordFill_00000001_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2172_UnchainedWordFill_00000001_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000_id	:
		S_2178_UnchainedDwordMove_00000001_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2178)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2158if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2158if_f_id	:
		L13_2158if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16396)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2173_UnchainedWordMove_00000001_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16397)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2179_UnchainedByteWrite_00000002_0000000e_00000001_id	:
		S_2179_UnchainedByteWrite_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2179)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2159if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2159if_f_id	:
		L13_2159if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1356)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2180_UnchainedByteFill_00000002_0000000e_00000001_id	:
		S_2180_UnchainedByteFill_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2180)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2160if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2160if_f_id	:
		L13_2160if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_36if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_36if_f_id	:
		L28_36if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_37if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+4)	))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_37if_f_id	:
		L28_37if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_38if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_38if_f_id	:
		L28_38if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_39if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_39if_f_id	:
		L28_39if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000_id	:
		S_2181_UnchainedByteMove_00000002_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2181)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2161if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2161if_f_id	:
		L13_2161if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L28_40if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	{	extern	IUH	L28_41if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_41if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_40if_f_id	:
		L28_40if_f:	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	case	L28_41if_d_id	:
		L28_41if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\sevid001.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_2118_SimpleStringRead_id,
L13_2098if_f_id,
L26_53w_t_id,
L26_54w_d_id,
L26_51if_f_id,
L26_55w_t_id,
L26_56w_d_id,
L26_52if_d_id,
S_2119_RdMode0Chain2StringReadBwd_id,
L13_2099if_f_id,
L26_57if_f_id,
L26_58if_d_id,
L26_61w_t_id,
L26_62w_d_id,
L26_59if_f_id,
L26_63w_t_id,
L26_64w_d_id,
L26_60if_d_id,
S_2120_RdMode0Chain4StringReadBwd_id,
L13_2100if_f_id,
L26_67w_t_id,
L26_68w_d_id,
L26_65if_f_id,
L26_69w_t_id,
L26_70w_d_id,
L26_66if_d_id,
S_2121_RdMode0UnchainedStringReadBwd_id,
L13_2101if_f_id,
L26_73w_t_id,
L26_74w_d_id,
L26_71if_f_id,
L26_75w_t_id,
L26_76w_d_id,
L26_72if_d_id,
S_2122_RdMode1Chain2StringReadBwd_id,
L13_2102if_f_id,
L26_77if_f_id,
L26_78if_d_id,
L26_81w_t_id,
L26_82w_d_id,
L26_79if_f_id,
L26_83w_t_id,
L26_84w_d_id,
L26_80if_d_id,
S_2123_RdMode1Chain4StringReadBwd_id,
L13_2103if_f_id,
L26_87w_t_id,
L26_88w_d_id,
L26_85if_f_id,
L26_89w_t_id,
L26_90w_d_id,
L26_86if_d_id,
S_2124_RdMode1UnchainedStringReadBwd_id,
L13_2104if_f_id,
L26_93w_t_id,
L26_94w_d_id,
L26_91if_f_id,
L26_95w_t_id,
L26_96w_d_id,
L26_92if_d_id,
S_2125_DisabledRAMStringReadBwd_id,
L13_2105if_f_id,
L26_99w_t_id,
L26_100w_d_id,
L26_97if_f_id,
L26_101w_t_id,
L26_102w_d_id,
L26_98if_d_id,
S_2126_SimpleMark_id,
L13_2106if_f_id,
S_2127_CGAMarkByte_id,
L13_2107if_f_id,
L25_0if_f_id,
L25_1if_f_id,
S_2128_CGAMarkWord_id,
L13_2108if_f_id,
L25_2if_f_id,
L25_3if_f_id,
S_2129_CGAMarkDword_id,
L13_2109if_f_id,
L25_4if_f_id,
L25_5if_f_id,
S_2130_CGAMarkString_id,
L13_2110if_f_id,
L25_6if_f_id,
L25_7if_f_id,
S_2131_UnchainedMarkByte_id,
L13_2111if_f_id,
L25_8if_f_id,
L25_9if_f_id,
S_2132_UnchainedMarkWord_id,
L13_2112if_f_id,
L25_10if_f_id,
L25_11if_f_id,
S_2133_UnchainedMarkDword_id,
L13_2113if_f_id,
L25_12if_f_id,
L25_13if_f_id,
S_2134_UnchainedMarkString_id,
L13_2114if_f_id,
L25_14if_f_id,
L25_15if_f_id,
L25_16w_t_id,
L25_17w_d_id,
S_2135_Chain4MarkByte_id,
L13_2115if_f_id,
S_2136_Chain4MarkWord_id,
L13_2116if_f_id,
S_2137_Chain4MarkDword_id,
L13_2117if_f_id,
S_2138_Chain4MarkString_id,
L13_2118if_f_id,
S_2139_SimpleByteWrite_id,
L13_2119if_f_id,
S_2140_SimpleByteFill_id,
L13_2120if_f_id,
L27_0w_t_id,
L27_1w_d_id,
S_2141_SimpleByteMove_Fwd_id,
L13_2121if_f_id,
L27_4w_t_id,
L27_5w_d_id,
L27_2if_f_id,
L27_6w_t_id,
L27_7w_d_id,
L27_3if_d_id,
S_2142_SimpleWordWrite_id,
L13_2122if_f_id,
S_2143_SimpleWordFill_id,
L13_2123if_f_id,
L27_8w_t_id,
L27_9w_d_id,
S_2144_SimpleWordMove_Fwd_id,
L13_2124if_f_id,
L27_12w_t_id,
L27_13w_d_id,
L27_10if_f_id,
L27_14w_t_id,
L27_15w_d_id,
L27_11if_d_id,
S_2145_SimpleDwordWrite_id,
L13_2125if_f_id,
S_2146_SimpleDwordFill_id,
L13_2126if_f_id,
L27_16w_t_id,
L27_17w_d_id,
S_2147_SimpleDwordMove_Fwd_id,
L13_2127if_f_id,
L27_20w_t_id,
L27_21w_d_id,
L27_18if_f_id,
L27_22w_t_id,
L27_23w_d_id,
L27_19if_d_id,
S_2148_SimpleByteMove_Bwd_id,
L13_2128if_f_id,
L27_26w_t_id,
L27_27w_d_id,
L27_24if_f_id,
L27_28w_t_id,
L27_29w_d_id,
L27_25if_d_id,
S_2149_SimpleWordMove_Bwd_id,
L13_2129if_f_id,
L27_32w_t_id,
L27_33w_d_id,
L27_30if_f_id,
L27_34w_t_id,
L27_35w_d_id,
L27_31if_d_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_2118_SimpleStringRead IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2118_SimpleStringRead_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2118_SimpleStringRead = (IHPE)S_2118_SimpleStringRead ;
LOCAL IUH L13_2098if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2098if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2098if_f = (IHPE)L13_2098if_f ;
LOCAL IUH L26_53w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_53w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_53w_t = (IHPE)L26_53w_t ;
LOCAL IUH L26_54w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_54w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_54w_d = (IHPE)L26_54w_d ;
LOCAL IUH L26_51if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_51if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_51if_f = (IHPE)L26_51if_f ;
LOCAL IUH L26_55w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_55w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_55w_t = (IHPE)L26_55w_t ;
LOCAL IUH L26_56w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_56w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_56w_d = (IHPE)L26_56w_d ;
LOCAL IUH L26_52if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_52if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_52if_d = (IHPE)L26_52if_d ;
GLOBAL IUH S_2119_RdMode0Chain2StringReadBwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2119_RdMode0Chain2StringReadBwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2119_RdMode0Chain2StringReadBwd = (IHPE)S_2119_RdMode0Chain2StringReadBwd ;
LOCAL IUH L13_2099if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2099if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2099if_f = (IHPE)L13_2099if_f ;
LOCAL IUH L26_57if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_57if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_57if_f = (IHPE)L26_57if_f ;
LOCAL IUH L26_58if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_58if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_58if_d = (IHPE)L26_58if_d ;
LOCAL IUH L26_61w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_61w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_61w_t = (IHPE)L26_61w_t ;
LOCAL IUH L26_62w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_62w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_62w_d = (IHPE)L26_62w_d ;
LOCAL IUH L26_59if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_59if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_59if_f = (IHPE)L26_59if_f ;
LOCAL IUH L26_63w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_63w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_63w_t = (IHPE)L26_63w_t ;
LOCAL IUH L26_64w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_64w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_64w_d = (IHPE)L26_64w_d ;
LOCAL IUH L26_60if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_60if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_60if_d = (IHPE)L26_60if_d ;
GLOBAL IUH S_2120_RdMode0Chain4StringReadBwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2120_RdMode0Chain4StringReadBwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2120_RdMode0Chain4StringReadBwd = (IHPE)S_2120_RdMode0Chain4StringReadBwd ;
LOCAL IUH L13_2100if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2100if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2100if_f = (IHPE)L13_2100if_f ;
LOCAL IUH L26_67w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_67w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_67w_t = (IHPE)L26_67w_t ;
LOCAL IUH L26_68w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_68w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_68w_d = (IHPE)L26_68w_d ;
LOCAL IUH L26_65if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_65if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_65if_f = (IHPE)L26_65if_f ;
LOCAL IUH L26_69w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_69w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_69w_t = (IHPE)L26_69w_t ;
LOCAL IUH L26_70w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_70w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_70w_d = (IHPE)L26_70w_d ;
LOCAL IUH L26_66if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_66if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_66if_d = (IHPE)L26_66if_d ;
GLOBAL IUH S_2121_RdMode0UnchainedStringReadBwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2121_RdMode0UnchainedStringReadBwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2121_RdMode0UnchainedStringReadBwd = (IHPE)S_2121_RdMode0UnchainedStringReadBwd ;
LOCAL IUH L13_2101if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2101if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2101if_f = (IHPE)L13_2101if_f ;
LOCAL IUH L26_73w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_73w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_73w_t = (IHPE)L26_73w_t ;
LOCAL IUH L26_74w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_74w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_74w_d = (IHPE)L26_74w_d ;
LOCAL IUH L26_71if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_71if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_71if_f = (IHPE)L26_71if_f ;
LOCAL IUH L26_75w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_75w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_75w_t = (IHPE)L26_75w_t ;
LOCAL IUH L26_76w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_76w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_76w_d = (IHPE)L26_76w_d ;
LOCAL IUH L26_72if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_72if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_72if_d = (IHPE)L26_72if_d ;
GLOBAL IUH S_2122_RdMode1Chain2StringReadBwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2122_RdMode1Chain2StringReadBwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2122_RdMode1Chain2StringReadBwd = (IHPE)S_2122_RdMode1Chain2StringReadBwd ;
LOCAL IUH L13_2102if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2102if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2102if_f = (IHPE)L13_2102if_f ;
LOCAL IUH L26_77if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_77if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_77if_f = (IHPE)L26_77if_f ;
LOCAL IUH L26_78if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_78if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_78if_d = (IHPE)L26_78if_d ;
LOCAL IUH L26_81w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_81w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_81w_t = (IHPE)L26_81w_t ;
LOCAL IUH L26_82w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_82w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_82w_d = (IHPE)L26_82w_d ;
LOCAL IUH L26_79if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_79if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_79if_f = (IHPE)L26_79if_f ;
LOCAL IUH L26_83w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_83w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_83w_t = (IHPE)L26_83w_t ;
LOCAL IUH L26_84w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_84w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_84w_d = (IHPE)L26_84w_d ;
LOCAL IUH L26_80if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_80if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_80if_d = (IHPE)L26_80if_d ;
GLOBAL IUH S_2123_RdMode1Chain4StringReadBwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2123_RdMode1Chain4StringReadBwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2123_RdMode1Chain4StringReadBwd = (IHPE)S_2123_RdMode1Chain4StringReadBwd ;
LOCAL IUH L13_2103if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2103if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2103if_f = (IHPE)L13_2103if_f ;
LOCAL IUH L26_87w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_87w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_87w_t = (IHPE)L26_87w_t ;
LOCAL IUH L26_88w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_88w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_88w_d = (IHPE)L26_88w_d ;
LOCAL IUH L26_85if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_85if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_85if_f = (IHPE)L26_85if_f ;
LOCAL IUH L26_89w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_89w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_89w_t = (IHPE)L26_89w_t ;
LOCAL IUH L26_90w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_90w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_90w_d = (IHPE)L26_90w_d ;
LOCAL IUH L26_86if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_86if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_86if_d = (IHPE)L26_86if_d ;
GLOBAL IUH S_2124_RdMode1UnchainedStringReadBwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2124_RdMode1UnchainedStringReadBwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2124_RdMode1UnchainedStringReadBwd = (IHPE)S_2124_RdMode1UnchainedStringReadBwd ;
LOCAL IUH L13_2104if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2104if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2104if_f = (IHPE)L13_2104if_f ;
LOCAL IUH L26_93w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_93w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_93w_t = (IHPE)L26_93w_t ;
LOCAL IUH L26_94w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_94w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_94w_d = (IHPE)L26_94w_d ;
LOCAL IUH L26_91if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_91if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_91if_f = (IHPE)L26_91if_f ;
LOCAL IUH L26_95w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_95w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_95w_t = (IHPE)L26_95w_t ;
LOCAL IUH L26_96w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_96w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_96w_d = (IHPE)L26_96w_d ;
LOCAL IUH L26_92if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_92if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_92if_d = (IHPE)L26_92if_d ;
GLOBAL IUH S_2125_DisabledRAMStringReadBwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2125_DisabledRAMStringReadBwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2125_DisabledRAMStringReadBwd = (IHPE)S_2125_DisabledRAMStringReadBwd ;
LOCAL IUH L13_2105if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2105if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2105if_f = (IHPE)L13_2105if_f ;
LOCAL IUH L26_99w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_99w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_99w_t = (IHPE)L26_99w_t ;
LOCAL IUH L26_100w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_100w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_100w_d = (IHPE)L26_100w_d ;
LOCAL IUH L26_97if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_97if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_97if_f = (IHPE)L26_97if_f ;
LOCAL IUH L26_101w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_101w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_101w_t = (IHPE)L26_101w_t ;
LOCAL IUH L26_102w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_102w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_102w_d = (IHPE)L26_102w_d ;
LOCAL IUH L26_98if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L26_98if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L26_98if_d = (IHPE)L26_98if_d ;
GLOBAL IUH S_2126_SimpleMark IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2126_SimpleMark_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2126_SimpleMark = (IHPE)S_2126_SimpleMark ;
LOCAL IUH L13_2106if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2106if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2106if_f = (IHPE)L13_2106if_f ;
GLOBAL IUH S_2127_CGAMarkByte IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2127_CGAMarkByte_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2127_CGAMarkByte = (IHPE)S_2127_CGAMarkByte ;
LOCAL IUH L13_2107if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2107if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2107if_f = (IHPE)L13_2107if_f ;
LOCAL IUH L25_0if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_0if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_0if_f = (IHPE)L25_0if_f ;
LOCAL IUH L25_1if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_1if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_1if_f = (IHPE)L25_1if_f ;
GLOBAL IUH S_2128_CGAMarkWord IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2128_CGAMarkWord_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2128_CGAMarkWord = (IHPE)S_2128_CGAMarkWord ;
LOCAL IUH L13_2108if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2108if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2108if_f = (IHPE)L13_2108if_f ;
LOCAL IUH L25_2if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_2if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_2if_f = (IHPE)L25_2if_f ;
LOCAL IUH L25_3if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_3if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_3if_f = (IHPE)L25_3if_f ;
GLOBAL IUH S_2129_CGAMarkDword IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2129_CGAMarkDword_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2129_CGAMarkDword = (IHPE)S_2129_CGAMarkDword ;
LOCAL IUH L13_2109if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2109if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2109if_f = (IHPE)L13_2109if_f ;
LOCAL IUH L25_4if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_4if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_4if_f = (IHPE)L25_4if_f ;
LOCAL IUH L25_5if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_5if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_5if_f = (IHPE)L25_5if_f ;
GLOBAL IUH S_2130_CGAMarkString IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2130_CGAMarkString_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2130_CGAMarkString = (IHPE)S_2130_CGAMarkString ;
LOCAL IUH L13_2110if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2110if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2110if_f = (IHPE)L13_2110if_f ;
LOCAL IUH L25_6if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_6if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_6if_f = (IHPE)L25_6if_f ;
LOCAL IUH L25_7if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_7if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_7if_f = (IHPE)L25_7if_f ;
GLOBAL IUH S_2131_UnchainedMarkByte IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2131_UnchainedMarkByte_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2131_UnchainedMarkByte = (IHPE)S_2131_UnchainedMarkByte ;
LOCAL IUH L13_2111if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2111if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2111if_f = (IHPE)L13_2111if_f ;
LOCAL IUH L25_8if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_8if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_8if_f = (IHPE)L25_8if_f ;
LOCAL IUH L25_9if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_9if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_9if_f = (IHPE)L25_9if_f ;
GLOBAL IUH S_2132_UnchainedMarkWord IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2132_UnchainedMarkWord_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2132_UnchainedMarkWord = (IHPE)S_2132_UnchainedMarkWord ;
LOCAL IUH L13_2112if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2112if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2112if_f = (IHPE)L13_2112if_f ;
LOCAL IUH L25_10if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_10if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_10if_f = (IHPE)L25_10if_f ;
LOCAL IUH L25_11if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_11if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_11if_f = (IHPE)L25_11if_f ;
GLOBAL IUH S_2133_UnchainedMarkDword IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2133_UnchainedMarkDword_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2133_UnchainedMarkDword = (IHPE)S_2133_UnchainedMarkDword ;
LOCAL IUH L13_2113if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2113if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2113if_f = (IHPE)L13_2113if_f ;
LOCAL IUH L25_12if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_12if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_12if_f = (IHPE)L25_12if_f ;
LOCAL IUH L25_13if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_13if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_13if_f = (IHPE)L25_13if_f ;
GLOBAL IUH S_2134_UnchainedMarkString IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2134_UnchainedMarkString_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2134_UnchainedMarkString = (IHPE)S_2134_UnchainedMarkString ;
LOCAL IUH L13_2114if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2114if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2114if_f = (IHPE)L13_2114if_f ;
LOCAL IUH L25_14if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_14if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_14if_f = (IHPE)L25_14if_f ;
LOCAL IUH L25_15if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_15if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_15if_f = (IHPE)L25_15if_f ;
LOCAL IUH L25_16w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_16w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_16w_t = (IHPE)L25_16w_t ;
LOCAL IUH L25_17w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L25_17w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L25_17w_d = (IHPE)L25_17w_d ;
GLOBAL IUH S_2135_Chain4MarkByte IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2135_Chain4MarkByte_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2135_Chain4MarkByte = (IHPE)S_2135_Chain4MarkByte ;
LOCAL IUH L13_2115if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2115if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2115if_f = (IHPE)L13_2115if_f ;
GLOBAL IUH S_2136_Chain4MarkWord IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2136_Chain4MarkWord_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2136_Chain4MarkWord = (IHPE)S_2136_Chain4MarkWord ;
LOCAL IUH L13_2116if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2116if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2116if_f = (IHPE)L13_2116if_f ;
GLOBAL IUH S_2137_Chain4MarkDword IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2137_Chain4MarkDword_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2137_Chain4MarkDword = (IHPE)S_2137_Chain4MarkDword ;
LOCAL IUH L13_2117if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2117if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2117if_f = (IHPE)L13_2117if_f ;
GLOBAL IUH S_2138_Chain4MarkString IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2138_Chain4MarkString_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2138_Chain4MarkString = (IHPE)S_2138_Chain4MarkString ;
LOCAL IUH L13_2118if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2118if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2118if_f = (IHPE)L13_2118if_f ;
GLOBAL IUH S_2139_SimpleByteWrite IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2139_SimpleByteWrite_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2139_SimpleByteWrite = (IHPE)S_2139_SimpleByteWrite ;
LOCAL IUH L13_2119if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2119if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2119if_f = (IHPE)L13_2119if_f ;
GLOBAL IUH S_2140_SimpleByteFill IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2140_SimpleByteFill_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2140_SimpleByteFill = (IHPE)S_2140_SimpleByteFill ;
LOCAL IUH L13_2120if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2120if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2120if_f = (IHPE)L13_2120if_f ;
LOCAL IUH L27_0w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_0w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_0w_t = (IHPE)L27_0w_t ;
LOCAL IUH L27_1w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_1w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_1w_d = (IHPE)L27_1w_d ;
GLOBAL IUH S_2141_SimpleByteMove_Fwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2141_SimpleByteMove_Fwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2141_SimpleByteMove_Fwd = (IHPE)S_2141_SimpleByteMove_Fwd ;
LOCAL IUH L13_2121if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2121if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2121if_f = (IHPE)L13_2121if_f ;
LOCAL IUH L27_4w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_4w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_4w_t = (IHPE)L27_4w_t ;
LOCAL IUH L27_5w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_5w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_5w_d = (IHPE)L27_5w_d ;
LOCAL IUH L27_2if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_2if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_2if_f = (IHPE)L27_2if_f ;
LOCAL IUH L27_6w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_6w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_6w_t = (IHPE)L27_6w_t ;
LOCAL IUH L27_7w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_7w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_7w_d = (IHPE)L27_7w_d ;
LOCAL IUH L27_3if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_3if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_3if_d = (IHPE)L27_3if_d ;
GLOBAL IUH S_2142_SimpleWordWrite IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2142_SimpleWordWrite_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2142_SimpleWordWrite = (IHPE)S_2142_SimpleWordWrite ;
LOCAL IUH L13_2122if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2122if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2122if_f = (IHPE)L13_2122if_f ;
GLOBAL IUH S_2143_SimpleWordFill IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2143_SimpleWordFill_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2143_SimpleWordFill = (IHPE)S_2143_SimpleWordFill ;
LOCAL IUH L13_2123if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2123if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2123if_f = (IHPE)L13_2123if_f ;
LOCAL IUH L27_8w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_8w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_8w_t = (IHPE)L27_8w_t ;
LOCAL IUH L27_9w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_9w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_9w_d = (IHPE)L27_9w_d ;
GLOBAL IUH S_2144_SimpleWordMove_Fwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2144_SimpleWordMove_Fwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2144_SimpleWordMove_Fwd = (IHPE)S_2144_SimpleWordMove_Fwd ;
LOCAL IUH L13_2124if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2124if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2124if_f = (IHPE)L13_2124if_f ;
LOCAL IUH L27_12w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_12w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_12w_t = (IHPE)L27_12w_t ;
LOCAL IUH L27_13w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_13w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_13w_d = (IHPE)L27_13w_d ;
LOCAL IUH L27_10if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_10if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_10if_f = (IHPE)L27_10if_f ;
LOCAL IUH L27_14w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_14w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_14w_t = (IHPE)L27_14w_t ;
LOCAL IUH L27_15w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_15w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_15w_d = (IHPE)L27_15w_d ;
LOCAL IUH L27_11if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_11if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_11if_d = (IHPE)L27_11if_d ;
GLOBAL IUH S_2145_SimpleDwordWrite IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2145_SimpleDwordWrite_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2145_SimpleDwordWrite = (IHPE)S_2145_SimpleDwordWrite ;
LOCAL IUH L13_2125if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2125if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2125if_f = (IHPE)L13_2125if_f ;
GLOBAL IUH S_2146_SimpleDwordFill IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2146_SimpleDwordFill_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2146_SimpleDwordFill = (IHPE)S_2146_SimpleDwordFill ;
LOCAL IUH L13_2126if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2126if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2126if_f = (IHPE)L13_2126if_f ;
LOCAL IUH L27_16w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_16w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_16w_t = (IHPE)L27_16w_t ;
LOCAL IUH L27_17w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_17w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_17w_d = (IHPE)L27_17w_d ;
GLOBAL IUH S_2147_SimpleDwordMove_Fwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2147_SimpleDwordMove_Fwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2147_SimpleDwordMove_Fwd = (IHPE)S_2147_SimpleDwordMove_Fwd ;
LOCAL IUH L13_2127if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2127if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2127if_f = (IHPE)L13_2127if_f ;
LOCAL IUH L27_20w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_20w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_20w_t = (IHPE)L27_20w_t ;
LOCAL IUH L27_21w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_21w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_21w_d = (IHPE)L27_21w_d ;
LOCAL IUH L27_18if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_18if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_18if_f = (IHPE)L27_18if_f ;
LOCAL IUH L27_22w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_22w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_22w_t = (IHPE)L27_22w_t ;
LOCAL IUH L27_23w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_23w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_23w_d = (IHPE)L27_23w_d ;
LOCAL IUH L27_19if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_19if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_19if_d = (IHPE)L27_19if_d ;
GLOBAL IUH S_2148_SimpleByteMove_Bwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2148_SimpleByteMove_Bwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2148_SimpleByteMove_Bwd = (IHPE)S_2148_SimpleByteMove_Bwd ;
LOCAL IUH L13_2128if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2128if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2128if_f = (IHPE)L13_2128if_f ;
LOCAL IUH L27_26w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_26w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_26w_t = (IHPE)L27_26w_t ;
LOCAL IUH L27_27w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_27w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_27w_d = (IHPE)L27_27w_d ;
LOCAL IUH L27_24if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_24if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_24if_f = (IHPE)L27_24if_f ;
LOCAL IUH L27_28w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_28w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_28w_t = (IHPE)L27_28w_t ;
LOCAL IUH L27_29w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_29w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_29w_d = (IHPE)L27_29w_d ;
LOCAL IUH L27_25if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_25if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_25if_d = (IHPE)L27_25if_d ;
GLOBAL IUH S_2149_SimpleWordMove_Bwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2149_SimpleWordMove_Bwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2149_SimpleWordMove_Bwd = (IHPE)S_2149_SimpleWordMove_Bwd ;
LOCAL IUH L13_2129if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2129if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2129if_f = (IHPE)L13_2129if_f ;
LOCAL IUH L27_32w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_32w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_32w_t = (IHPE)L27_32w_t ;
LOCAL IUH L27_33w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_33w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_33w_d = (IHPE)L27_33w_d ;
LOCAL IUH L27_30if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_30if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_30if_f = (IHPE)L27_30if_f ;
LOCAL IUH L27_34w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_34w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_34w_t = (IHPE)L27_34w_t ;
LOCAL IUH L27_35w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_35w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_35w_d = (IHPE)L27_35w_d ;
LOCAL IUH L27_31if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L27_31if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L27_31if_d = (IHPE)L27_31if_d ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2118_SimpleStringRead_id	:
		S_2118_SimpleStringRead	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2118)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2098if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2098if_f_id	:
		L13_2098if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L26_51if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_54w_d;	
	case	L26_53w_t_id	:
		L26_53w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_53w_t;	
	case	L26_54w_d_id	:
		L26_54w_d:	;	
	{	extern	IUH	L26_52if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_52if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_51if_f_id	:
		L26_51if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_56w_d;	
	case	L26_55w_t_id	:
		L26_55w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_55w_t;	
	case	L26_56w_d_id	:
		L26_56w_d:	;	
	case	L26_52if_d_id	:
		L26_52if_d:	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2119_RdMode0Chain2StringReadBwd_id	:
		S_2119_RdMode0Chain2StringReadBwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	28	>	0	)	LocalIUH	=	(IUH	*)malloc	(	28	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2119)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2099if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2099if_f_id	:
		L13_2099if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	(1	<<	*((IU32	*)&(r21)	+	REGLONG)))	==	0)	goto	L26_57if_f;	
	*((IUH	*)(LocalIUH+4))	=	(IS32)(1)	;	
	{	extern	IUH	L26_58if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_58if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_57if_f_id	:
		L26_57if_f:	;	
	*((IUH	*)(LocalIUH+4))	=	(IS32)(3)	;	
	case	L26_58if_d_id	:
		L26_58if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L26_59if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_62w_d;	
	case	L26_61w_t_id	:
		L26_61w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	^	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_61w_t;	
	case	L26_62w_d_id	:
		L26_62w_d:	;	
	{	extern	IUH	L26_60if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_60if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_59if_f_id	:
		L26_59if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_64w_d;	
	case	L26_63w_t_id	:
		L26_63w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	^	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_63w_t;	
	case	L26_64w_d_id	:
		L26_64w_d:	;	
	case	L26_60if_d_id	:
		L26_60if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2120_RdMode0Chain4StringReadBwd_id	:
		S_2120_RdMode0Chain4StringReadBwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2120)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2100if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2100if_f_id	:
		L13_2100if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L26_65if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_68w_d;	
	case	L26_67w_t_id	:
		L26_67w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_67w_t;	
	case	L26_68w_d_id	:
		L26_68w_d:	;	
	{	extern	IUH	L26_66if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_66if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_65if_f_id	:
		L26_65if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_70w_d;	
	case	L26_69w_t_id	:
		L26_69w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_69w_t;	
	case	L26_70w_d_id	:
		L26_70w_d:	;	
	case	L26_66if_d_id	:
		L26_66if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2121_RdMode0UnchainedStringReadBwd_id	:
		S_2121_RdMode0UnchainedStringReadBwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2121)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2101if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2101if_f_id	:
		L13_2101if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L26_71if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_74w_d;	
	case	L26_73w_t_id	:
		L26_73w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_73w_t;	
	case	L26_74w_d_id	:
		L26_74w_d:	;	
	{	extern	IUH	L26_72if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_72if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_71if_f_id	:
		L26_71if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_76w_d;	
	case	L26_75w_t_id	:
		L26_75w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_75w_t;	
	case	L26_76w_d_id	:
		L26_76w_d:	;	
	case	L26_72if_d_id	:
		L26_72if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2122_RdMode1Chain2StringReadBwd_id	:
		S_2122_RdMode1Chain2StringReadBwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	32	>	0	)	LocalIUH	=	(IUH	*)malloc	(	32	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2122)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2102if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2102if_f_id	:
		L13_2102if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)(LocalIUH+1)	+	REGLONG)	&	(1	<<	*((IU32	*)&(r21)	+	REGLONG)))	==	0)	goto	L26_77if_f;	
	*((IUH	*)(LocalIUH+4))	=	(IS32)(1)	;	
	{	extern	IUH	L26_78if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_78if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_77if_f_id	:
		L26_77if_f:	;	
	*((IUH	*)(LocalIUH+4))	=	(IS32)(3)	;	
	case	L26_78if_d_id	:
		L26_78if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r22))	=	(IS32)(31)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;		
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L26_79if_f;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_82w_d;	
	case	L26_81w_t_id	:
		L26_81w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1383)	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)&(r22)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+7)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)(*((IHPE	*)&(r20)))	)	&	*((IU8	*)(LocalIUH+7)	+	REGBYTE);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	^	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_81w_t;	
	case	L26_82w_d_id	:
		L26_82w_d:	;	
	{	extern	IUH	L26_80if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_80if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_79if_f_id	:
		L26_79if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_84w_d;	
	case	L26_83w_t_id	:
		L26_83w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1383)	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)&(r22)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16230)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU8	*)(LocalIUH+7)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16231)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)(*((IHPE	*)&(r20)))	)	&	*((IU8	*)(LocalIUH+7)	+	REGBYTE);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	^	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_83w_t;	
	case	L26_84w_d_id	:
		L26_84w_d:	;	
	case	L26_80if_d_id	:
		L26_80if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2123_RdMode1Chain4StringReadBwd_id	:
		S_2123_RdMode1Chain4StringReadBwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2123)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2103if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2103if_f_id	:
		L13_2103if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L26_85if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_88w_d;	
	case	L26_87w_t_id	:
		L26_87w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1383)	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)&(r22)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_87w_t;	
	case	L26_88w_d_id	:
		L26_88w_d:	;	
	{	extern	IUH	L26_86if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_86if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_85if_f_id	:
		L26_85if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_90w_d;	
	case	L26_89w_t_id	:
		L26_89w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1383)	;	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)&(r22)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_89w_t;	
	case	L26_90w_d_id	:
		L26_90w_d:	;	
	case	L26_86if_d_id	:
		L26_86if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(-4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2124_RdMode1UnchainedStringReadBwd_id	:
		S_2124_RdMode1UnchainedStringReadBwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	36	>	0	)	LocalIUH	=	(IUH	*)malloc	(	36	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2124)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2104if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2104if_f_id	:
		L13_2104if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1372)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L26_91if_f;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_94w_d;	
	case	L26_93w_t_id	:
		L26_93w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)&(r21)	+	REGBYTE);	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r21)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r21)	+	REGLONG));	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+7)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_93w_t;	
	case	L26_94w_d_id	:
		L26_94w_d:	;	
	{	extern	IUH	L26_92if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_92if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_91if_f_id	:
		L26_91if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_96w_d;	
	case	L26_95w_t_id	:
		L26_95w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1379)	;	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1383)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	|	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)&(r21)	+	REGBYTE);	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16250)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r21)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r21)	+	REGLONG));	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+6)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16251)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_95w_t;	
	case	L26_96w_d_id	:
		L26_96w_d:	;	
	case	L26_92if_d_id	:
		L26_92if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2125_DisabledRAMStringReadBwd_id	:
		S_2125_DisabledRAMStringReadBwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2125)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2105if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2105if_f_id	:
		L13_2105if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L26_97if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_100w_d;	
	case	L26_99w_t_id	:
		L26_99w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	(IS32)(-1)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L26_99w_t;	
	case	L26_100w_d_id	:
		L26_100w_d:	;	
	{	extern	IUH	L26_98if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L26_98if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L26_97if_f_id	:
		L26_97if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_102w_d;	
	case	L26_101w_t_id	:
		L26_101w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	(IS32)(-1)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L26_101w_t;	
	case	L26_102w_d_id	:
		L26_102w_d:	;	
	case	L26_98if_d_id	:
		L26_98if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	(IS32)(-1)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004281),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2126_SimpleMark_id	:
		S_2126_SimpleMark	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2126)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2106if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2106if_f_id	:
		L13_2106if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2127_CGAMarkByte_id	:
		S_2127_CGAMarkByte	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2127)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2107if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2107if_f_id	:
		L13_2107if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)(r1+0))	=	(IS32)(16294)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16295)	;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1344)	;	
	if	(*((IS32	*)&(r21)	+	REGLONG)	>=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	goto	L25_0if_f;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)&(r22)	+	REGLONG)	;	
	case	L25_0if_f_id	:
		L25_0if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1348)	;	
	if	(*((IS32	*)&(r21)	+	REGLONG)	<=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	goto	L25_1if_f;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	case	L25_1if_f_id	:
		L25_1if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16296)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16297)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2128_CGAMarkWord_id	:
		S_2128_CGAMarkWord	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2128)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2108if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2108if_f_id	:
		L13_2108if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)(r1+0))	=	(IS32)(16294)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16295)	;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1344)	;	
	if	(*((IS32	*)&(r21)	+	REGLONG)	>=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	goto	L25_2if_f;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)&(r22)	+	REGLONG)	;	
	case	L25_2if_f_id	:
		L25_2if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1348)	;	
	if	(*((IS32	*)&(r21)	+	REGLONG)	<=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	goto	L25_3if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	case	L25_3if_f_id	:
		L25_3if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16296)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16297)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2129_CGAMarkDword_id	:
		S_2129_CGAMarkDword	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2129)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2109if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2109if_f_id	:
		L13_2109if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)(r1+0))	=	(IS32)(16294)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16295)	;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1344)	;	
	if	(*((IS32	*)&(r21)	+	REGLONG)	>=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	goto	L25_4if_f;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)&(r22)	+	REGLONG)	;	
	case	L25_4if_f_id	:
		L25_4if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1348)	;	
	if	(*((IS32	*)&(r21)	+	REGLONG)	<=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	goto	L25_5if_f;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	case	L25_5if_f_id	:
		L25_5if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16296)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16297)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2130_CGAMarkString_id	:
		S_2130_CGAMarkString	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2130)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2110if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2110if_f_id	:
		L13_2110if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;		
	*((IUH	*)(r1+0))	=	(IS32)(16294)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16295)	;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1344)	;	
	if	(*((IS32	*)&(r21)	+	REGLONG)	>=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	goto	L25_6if_f;	
	*((IUH	*)&(r20))	=	(IS32)(57343)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)&(r22)	+	REGLONG)	;	
	case	L25_6if_f_id	:
		L25_6if_f:	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(57343)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1348)	;	
	if	(*((IS32	*)&(r20)	+	REGLONG)	<=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	goto	L25_7if_f;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	(IS32)(57343)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	case	L25_7if_f_id	:
		L25_7if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16296)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16297)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2131_UnchainedMarkByte_id	:
		S_2131_UnchainedMarkByte	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2131)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2111if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2111if_f_id	:
		L13_2111if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	>>	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1384)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IUH	*)(r1+0))	=	(IS32)(16306)	;	
	*((IUH	*)&(r20))	=	(IS32)(1344)	;	
	if	(*((IS32	*)(LocalIUH+1)	+	REGLONG)	>=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	))	goto	L25_8if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	case	L25_8if_f_id	:
		L25_8if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	if	(*((IS32	*)(LocalIUH+1)	+	REGLONG)	<=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	))	goto	L25_9if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	case	L25_9if_f_id	:
		L25_9if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16307)	;	
	*((IUH	*)&(r20))	=	(IS32)(1352)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	=	(IS32)(1)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2132_UnchainedMarkWord_id	:
		S_2132_UnchainedMarkWord	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2132)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2112if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2112if_f_id	:
		L13_2112if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	>>	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1384)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;		
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	>>	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1384)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;		
	*((IUH	*)(r1+0))	=	(IS32)(16306)	;	
	*((IUH	*)&(r21))	=	(IS32)(1344)	;	
	if	(*((IS32	*)(LocalIUH+2)	+	REGLONG)	>=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	))	goto	L25_10if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	case	L25_10if_f_id	:
		L25_10if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1348)	;	
	if	(*((IS32	*)(LocalIUH+1)	+	REGLONG)	<=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	))	goto	L25_11if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	case	L25_11if_f_id	:
		L25_11if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16307)	;	
	*((IUH	*)&(r21))	=	(IS32)(1352)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+2))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	(IS32)(1352)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	=	(IS32)(1)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2133_UnchainedMarkDword_id	:
		S_2133_UnchainedMarkDword	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2133)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2113if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2113if_f_id	:
		L13_2113if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	>>	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1384)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;		
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	>>	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1384)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;		
	*((IUH	*)(r1+0))	=	(IS32)(16306)	;	
	*((IUH	*)&(r21))	=	(IS32)(1344)	;	
	if	(*((IS32	*)(LocalIUH+2)	+	REGLONG)	>=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	))	goto	L25_12if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	case	L25_12if_f_id	:
		L25_12if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1348)	;	
	if	(*((IS32	*)(LocalIUH+1)	+	REGLONG)	<=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	))	goto	L25_13if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	case	L25_13if_f_id	:
		L25_13if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16307)	;	
	*((IUH	*)&(r21))	=	(IS32)(1352)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+2))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1352)	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1352)	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1352)	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	=	(IS32)(1)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2134_UnchainedMarkString_id	:
		S_2134_UnchainedMarkString	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2134)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2114if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2114if_f_id	:
		L13_2114if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;		
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	>>	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	>>	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1384)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;		
	*((IUH	*)&(r20))	=	(IS32)(1384)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	+	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;		
	*((IUH	*)(r1+0))	=	(IS32)(16306)	;	
	*((IUH	*)&(r21))	=	(IS32)(1344)	;	
	if	(*((IS32	*)(LocalIUH+3)	+	REGLONG)	>=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	))	goto	L25_14if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	case	L25_14if_f_id	:
		L25_14if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1348)	;	
	if	(*((IS32	*)(LocalIUH+2)	+	REGLONG)	<=	*((IS32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	))	goto	L25_15if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	case	L25_15if_f_id	:
		L25_15if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16307)	;	
	if	(*((IS32	*)(LocalIUH+2)	+	REGLONG)	<	*((IS32	*)(LocalIUH+3)	+	REGLONG))	goto	L25_17w_d;	
	case	L25_16w_t_id	:
		L25_16w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1352)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+2))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	if	(*((IS32	*)(LocalIUH+2)	+	REGLONG)	>=	*((IS32	*)(LocalIUH+3)	+	REGLONG))	goto	L25_16w_t;	
	case	L25_17w_d_id	:
		L25_17w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2135_Chain4MarkByte_id	:
		S_2135_Chain4MarkByte	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2135)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2115if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2115if_f_id	:
		L13_2115if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16316)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2131_UnchainedMarkByte()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2131_UnchainedMarkByte(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16317)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2136_Chain4MarkWord_id	:
		S_2136_Chain4MarkWord	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2136)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2116if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2116if_f_id	:
		L13_2116if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16320)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2132_UnchainedMarkWord()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2132_UnchainedMarkWord(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16321)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2137_Chain4MarkDword_id	:
		S_2137_Chain4MarkDword	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2137)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2117if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2117if_f_id	:
		L13_2117if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16324)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2133_UnchainedMarkDword()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2133_UnchainedMarkDword(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16325)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2138_Chain4MarkString_id	:
		S_2138_Chain4MarkString	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2138)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2118if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2118if_f_id	:
		L13_2118if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16328)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2134_UnchainedMarkString()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2134_UnchainedMarkString(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16329)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2139_SimpleByteWrite_id	:
		S_2139_SimpleByteWrite	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2139)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2119if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2119if_f_id	:
		L13_2119if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2140_SimpleByteFill_id	:
		S_2140_SimpleByteFill	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2140)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2120if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2120if_f_id	:
		L13_2120if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_1w_d;	
	case	L27_0w_t_id	:
		L27_0w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_0w_t;	
	case	L27_1w_d_id	:
		L27_1w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2141_SimpleByteMove_Fwd_id	:
		S_2141_SimpleByteMove_Fwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	28	>	0	)	LocalIUH	=	(IUH	*)malloc	(	28	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2141)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2121if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2121if_f_id	:
		L13_2121if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L27_2if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_5w_d;	
	case	L27_4w_t_id	:
		L27_4w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r24))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)&(r23)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_4w_t;	
	case	L27_5w_d_id	:
		L27_5w_d:	;	
	{	extern	IUH	L27_3if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L27_3if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L27_2if_f_id	:
		L27_2if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_7w_d;	
	case	L27_6w_t_id	:
		L27_6w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_6w_t;	
	case	L27_7w_d_id	:
		L27_7w_d:	;	
	case	L27_3if_d_id	:
		L27_3if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2142_SimpleWordWrite_id	:
		S_2142_SimpleWordWrite	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2142)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2122if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2122if_f_id	:
		L13_2122if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	=	*(UOFF_15_8(	(LocalIUH+1)	))	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2143_SimpleWordFill_id	:
		S_2143_SimpleWordFill	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2143)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2123if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2123if_f_id	:
		L13_2123if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	*	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_9w_d;	
	case	L27_8w_t_id	:
		L27_8w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+4))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*(UOFF_15_8(	(LocalIUH+1)	))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_8w_t;	
	case	L27_9w_d_id	:
		L27_9w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2144_SimpleWordMove_Fwd_id	:
		S_2144_SimpleWordMove_Fwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	28	>	0	)	LocalIUH	=	(IUH	*)malloc	(	28	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2144)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2124if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2124if_f_id	:
		L13_2124if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	*	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L27_10if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_13w_d;	
	case	L27_12w_t_id	:
		L27_12w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r24))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)&(r23)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r24))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)&(r23)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_12w_t;	
	case	L27_13w_d_id	:
		L27_13w_d:	;	
	{	extern	IUH	L27_11if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L27_11if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L27_10if_f_id	:
		L27_10if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_15w_d;	
	case	L27_14w_t_id	:
		L27_14w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_14w_t;	
	case	L27_15w_d_id	:
		L27_15w_d:	;	
	case	L27_11if_d_id	:
		L27_11if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2145_SimpleDwordWrite_id	:
		S_2145_SimpleDwordWrite	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2145)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2125if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2125if_f_id	:
		L13_2125if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*(UOFF_15_8(	(LocalIUH+1)	))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r21)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r23)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r21)	+	REGLONG));	
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)&(r23)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(24)	;	
	*((IUH	*)&(r23))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r23)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r23)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r23)	+	REGLONG));	
	*((IUH	*)&(r20))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r21)))	)	=	*((IU8	*)&(r22)	+	REGBYTE)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2146_SimpleDwordFill_id	:
		S_2146_SimpleDwordFill	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2146)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2126if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2126if_f_id	:
		L13_2126if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	*	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)(LocalIUH+3)	+	REGWORD)	=	*((IU16	*)&(r20)	+	REGWORD	)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_17w_d;	
	case	L27_16w_t_id	:
		L27_16w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*(UOFF_15_8(	(LocalIUH+1)	))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*(UOFF_15_8(	(LocalIUH+3)	))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_16w_t;	
	case	L27_17w_d_id	:
		L27_17w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2147_SimpleDwordMove_Fwd_id	:
		S_2147_SimpleDwordMove_Fwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	28	>	0	)	LocalIUH	=	(IUH	*)malloc	(	28	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2147)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2127if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2127if_f_id	:
		L13_2127if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	*	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L27_18if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_21w_d;	
	case	L27_20w_t_id	:
		L27_20w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r24))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)&(r23)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r24))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)&(r23)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r24))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)&(r23)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r24))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)&(r23)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_20w_t;	
	case	L27_21w_d_id	:
		L27_21w_d:	;	
	{	extern	IUH	L27_19if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L27_19if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L27_18if_f_id	:
		L27_18if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_23w_d;	
	case	L27_22w_t_id	:
		L27_22w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(-1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_22w_t;	
	case	L27_23w_d_id	:
		L27_23w_d:	;	
	case	L27_19if_d_id	:
		L27_19if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2148_SimpleByteMove_Bwd_id	:
		S_2148_SimpleByteMove_Bwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	28	>	0	)	LocalIUH	=	(IUH	*)malloc	(	28	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2148)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2128if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2128if_f_id	:
		L13_2128if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L27_24if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_27w_d;	
	case	L27_26w_t_id	:
		L27_26w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_26w_t;	
	case	L27_27w_d_id	:
		L27_27w_d:	;	
	{	extern	IUH	L27_25if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L27_25if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L27_24if_f_id	:
		L27_24if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_29w_d;	
	case	L27_28w_t_id	:
		L27_28w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+5))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_28w_t;	
	case	L27_29w_d_id	:
		L27_29w_d:	;	
	case	L27_25if_d_id	:
		L27_25if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2149_SimpleWordMove_Bwd_id	:
		S_2149_SimpleWordMove_Bwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	32	>	0	)	LocalIUH	=	(IUH	*)malloc	(	32	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2149)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2129if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2129if_f_id	:
		L13_2129if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	*	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L27_30if_f;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_33w_d;	
	case	L27_32w_t_id	:
		L27_32w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_32w_t;	
	case	L27_33w_d_id	:
		L27_33w_d:	;	
	{	extern	IUH	L27_31if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L27_31if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L27_30if_f_id	:
		L27_30if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L27_35w_d;	
	case	L27_34w_t_id	:
		L27_34w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(1400)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22))))	)	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r24))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(1400)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23))))	)	+	*((IHPE	*)&(r24)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+5))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L27_34w_t;	
	case	L27_35w_d_id	:
		L27_35w_d:	;	
	case	L27_31if_d_id	:
		L27_31if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\sevid003.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000_id,
L13_2162if_f_id,
L23_24if_f_id,
L23_25if_f_id,
L23_26if_f_id,
L23_27if_f_id,
S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000_id,
L13_2163if_f_id,
L23_30w_t_id,
L23_31w_d_id,
L23_28if_f_id,
L23_32w_t_id,
L23_33w_d_id,
L23_29if_d_id,
S_2184_UnchainedWordWrite_00000002_0000000e_00000001_id,
L13_2164if_f_id,
S_2185_UnchainedWordFill_00000002_0000000e_00000001_id,
L13_2165if_f_id,
L28_42if_f_id,
L28_43if_f_id,
L28_44if_f_id,
L28_45if_f_id,
S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000_id,
L13_2166if_f_id,
L28_46if_f_id,
L28_47if_d_id,
S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000_id,
L13_2167if_f_id,
L23_34if_f_id,
L23_35if_f_id,
L23_36if_f_id,
L23_37if_f_id,
S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000_id,
L13_2168if_f_id,
L23_40w_t_id,
L23_41w_d_id,
L23_38if_f_id,
L23_42w_t_id,
L23_43w_d_id,
L23_39if_d_id,
S_2189_UnchainedDwordWrite_00000002_0000000e_00000001_id,
L13_2169if_f_id,
S_2190_UnchainedDwordFill_00000002_0000000e_00000001_id,
L13_2170if_f_id,
S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000_id,
L13_2171if_f_id,
S_2192_UnchainedByteWrite_00000003_0000000e_00000001_id,
L13_2172if_f_id,
S_2193_UnchainedByteFill_00000003_0000000e_00000001_id,
L13_2173if_f_id,
L28_48if_f_id,
L28_49if_f_id,
L28_50if_f_id,
L28_51if_f_id,
S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000_id,
L13_2174if_f_id,
L28_52if_f_id,
L28_53if_d_id,
S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000_id,
L13_2175if_f_id,
L23_44if_f_id,
L23_45if_f_id,
L23_46if_f_id,
L23_47if_f_id,
S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000_id,
L13_2176if_f_id,
L23_50w_t_id,
L23_51w_d_id,
L23_48if_f_id,
L23_52w_t_id,
L23_53w_d_id,
L23_49if_d_id,
S_2197_UnchainedWordWrite_00000003_0000000e_00000001_id,
L13_2177if_f_id,
S_2198_UnchainedWordFill_00000003_0000000e_00000001_id,
L13_2178if_f_id,
L28_54if_f_id,
L28_55if_f_id,
L28_56if_f_id,
L28_57if_f_id,
S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000_id,
L13_2179if_f_id,
L28_58if_f_id,
L28_59if_d_id,
S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000_id,
L13_2180if_f_id,
L23_54if_f_id,
L23_55if_f_id,
L23_56if_f_id,
L23_57if_f_id,
S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000_id,
L13_2181if_f_id,
L23_60w_t_id,
L23_61w_d_id,
L23_58if_f_id,
L23_62w_t_id,
L23_63w_d_id,
L23_59if_d_id,
S_2202_UnchainedDwordWrite_00000003_0000000e_00000001_id,
L13_2182if_f_id,
S_2203_UnchainedDwordFill_00000003_0000000e_00000001_id,
L13_2183if_f_id,
S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000_id,
L13_2184if_f_id,
S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001_id,
L13_2185if_f_id,
L28_60if_f_id,
L28_61if_d_id,
S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001_id,
L13_2186if_f_id,
L23_64if_f_id,
L23_65if_f_id,
L23_66if_f_id,
L23_67if_f_id,
S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001_id,
L13_2187if_f_id,
L23_70w_t_id,
L23_71w_d_id,
L23_68if_f_id,
L23_72w_t_id,
L23_73w_d_id,
L23_69if_d_id,
S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001_id,
L13_2188if_f_id,
L28_62if_f_id,
L28_63if_d_id,
S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001_id,
L13_2189if_f_id,
L23_74if_f_id,
L23_75if_f_id,
L23_76if_f_id,
L23_77if_f_id,
S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001_id,
L13_2190if_f_id,
L23_80w_t_id,
L23_81w_d_id,
L23_78if_f_id,
L23_82w_t_id,
L23_83w_d_id,
L23_79if_d_id,
S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001_id,
L13_2191if_f_id,
S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001_id,
L13_2192if_f_id,
L28_64if_f_id,
L28_66if_f_id,
L28_67if_f_id,
L28_68if_f_id,
L28_69if_f_id,
L28_65if_d_id,
S_2213_CopyDirByte1Plane_00000001_id,
L13_2193if_f_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000 = (IHPE)S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000 ;
LOCAL IUH L13_2162if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2162if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2162if_f = (IHPE)L13_2162if_f ;
LOCAL IUH L23_24if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_24if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_24if_f = (IHPE)L23_24if_f ;
LOCAL IUH L23_25if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_25if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_25if_f = (IHPE)L23_25if_f ;
LOCAL IUH L23_26if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_26if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_26if_f = (IHPE)L23_26if_f ;
LOCAL IUH L23_27if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_27if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_27if_f = (IHPE)L23_27if_f ;
GLOBAL IUH S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000 = (IHPE)S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000 ;
LOCAL IUH L13_2163if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2163if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2163if_f = (IHPE)L13_2163if_f ;
LOCAL IUH L23_30w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_30w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_30w_t = (IHPE)L23_30w_t ;
LOCAL IUH L23_31w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_31w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_31w_d = (IHPE)L23_31w_d ;
LOCAL IUH L23_28if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_28if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_28if_f = (IHPE)L23_28if_f ;
LOCAL IUH L23_32w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_32w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_32w_t = (IHPE)L23_32w_t ;
LOCAL IUH L23_33w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_33w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_33w_d = (IHPE)L23_33w_d ;
LOCAL IUH L23_29if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_29if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_29if_d = (IHPE)L23_29if_d ;
GLOBAL IUH S_2184_UnchainedWordWrite_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2184_UnchainedWordWrite_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2184_UnchainedWordWrite_00000002_0000000e_00000001 = (IHPE)S_2184_UnchainedWordWrite_00000002_0000000e_00000001 ;
LOCAL IUH L13_2164if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2164if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2164if_f = (IHPE)L13_2164if_f ;
GLOBAL IUH S_2185_UnchainedWordFill_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2185_UnchainedWordFill_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2185_UnchainedWordFill_00000002_0000000e_00000001 = (IHPE)S_2185_UnchainedWordFill_00000002_0000000e_00000001 ;
LOCAL IUH L13_2165if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2165if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2165if_f = (IHPE)L13_2165if_f ;
LOCAL IUH L28_42if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_42if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_42if_f = (IHPE)L28_42if_f ;
LOCAL IUH L28_43if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_43if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_43if_f = (IHPE)L28_43if_f ;
LOCAL IUH L28_44if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_44if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_44if_f = (IHPE)L28_44if_f ;
LOCAL IUH L28_45if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_45if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_45if_f = (IHPE)L28_45if_f ;
GLOBAL IUH S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000 = (IHPE)S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000 ;
LOCAL IUH L13_2166if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2166if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2166if_f = (IHPE)L13_2166if_f ;
LOCAL IUH L28_46if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_46if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_46if_f = (IHPE)L28_46if_f ;
LOCAL IUH L28_47if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_47if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_47if_d = (IHPE)L28_47if_d ;
GLOBAL IUH S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000 = (IHPE)S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000 ;
LOCAL IUH L13_2167if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2167if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2167if_f = (IHPE)L13_2167if_f ;
LOCAL IUH L23_34if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_34if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_34if_f = (IHPE)L23_34if_f ;
LOCAL IUH L23_35if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_35if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_35if_f = (IHPE)L23_35if_f ;
LOCAL IUH L23_36if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_36if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_36if_f = (IHPE)L23_36if_f ;
LOCAL IUH L23_37if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_37if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_37if_f = (IHPE)L23_37if_f ;
GLOBAL IUH S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000 = (IHPE)S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000 ;
LOCAL IUH L13_2168if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2168if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2168if_f = (IHPE)L13_2168if_f ;
LOCAL IUH L23_40w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_40w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_40w_t = (IHPE)L23_40w_t ;
LOCAL IUH L23_41w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_41w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_41w_d = (IHPE)L23_41w_d ;
LOCAL IUH L23_38if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_38if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_38if_f = (IHPE)L23_38if_f ;
LOCAL IUH L23_42w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_42w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_42w_t = (IHPE)L23_42w_t ;
LOCAL IUH L23_43w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_43w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_43w_d = (IHPE)L23_43w_d ;
LOCAL IUH L23_39if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_39if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_39if_d = (IHPE)L23_39if_d ;
GLOBAL IUH S_2189_UnchainedDwordWrite_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2189_UnchainedDwordWrite_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2189_UnchainedDwordWrite_00000002_0000000e_00000001 = (IHPE)S_2189_UnchainedDwordWrite_00000002_0000000e_00000001 ;
LOCAL IUH L13_2169if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2169if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2169if_f = (IHPE)L13_2169if_f ;
GLOBAL IUH S_2190_UnchainedDwordFill_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2190_UnchainedDwordFill_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2190_UnchainedDwordFill_00000002_0000000e_00000001 = (IHPE)S_2190_UnchainedDwordFill_00000002_0000000e_00000001 ;
LOCAL IUH L13_2170if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2170if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2170if_f = (IHPE)L13_2170if_f ;
GLOBAL IUH S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000 = (IHPE)S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000 ;
LOCAL IUH L13_2171if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2171if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2171if_f = (IHPE)L13_2171if_f ;
GLOBAL IUH S_2192_UnchainedByteWrite_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2192_UnchainedByteWrite_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2192_UnchainedByteWrite_00000003_0000000e_00000001 = (IHPE)S_2192_UnchainedByteWrite_00000003_0000000e_00000001 ;
LOCAL IUH L13_2172if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2172if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2172if_f = (IHPE)L13_2172if_f ;
GLOBAL IUH S_2193_UnchainedByteFill_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2193_UnchainedByteFill_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2193_UnchainedByteFill_00000003_0000000e_00000001 = (IHPE)S_2193_UnchainedByteFill_00000003_0000000e_00000001 ;
LOCAL IUH L13_2173if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2173if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2173if_f = (IHPE)L13_2173if_f ;
LOCAL IUH L28_48if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_48if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_48if_f = (IHPE)L28_48if_f ;
LOCAL IUH L28_49if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_49if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_49if_f = (IHPE)L28_49if_f ;
LOCAL IUH L28_50if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_50if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_50if_f = (IHPE)L28_50if_f ;
LOCAL IUH L28_51if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_51if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_51if_f = (IHPE)L28_51if_f ;
GLOBAL IUH S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000 = (IHPE)S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000 ;
LOCAL IUH L13_2174if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2174if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2174if_f = (IHPE)L13_2174if_f ;
LOCAL IUH L28_52if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_52if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_52if_f = (IHPE)L28_52if_f ;
LOCAL IUH L28_53if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_53if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_53if_d = (IHPE)L28_53if_d ;
GLOBAL IUH S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000 = (IHPE)S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000 ;
LOCAL IUH L13_2175if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2175if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2175if_f = (IHPE)L13_2175if_f ;
LOCAL IUH L23_44if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_44if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_44if_f = (IHPE)L23_44if_f ;
LOCAL IUH L23_45if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_45if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_45if_f = (IHPE)L23_45if_f ;
LOCAL IUH L23_46if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_46if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_46if_f = (IHPE)L23_46if_f ;
LOCAL IUH L23_47if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_47if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_47if_f = (IHPE)L23_47if_f ;
GLOBAL IUH S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000 = (IHPE)S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000 ;
LOCAL IUH L13_2176if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2176if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2176if_f = (IHPE)L13_2176if_f ;
LOCAL IUH L23_50w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_50w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_50w_t = (IHPE)L23_50w_t ;
LOCAL IUH L23_51w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_51w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_51w_d = (IHPE)L23_51w_d ;
LOCAL IUH L23_48if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_48if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_48if_f = (IHPE)L23_48if_f ;
LOCAL IUH L23_52w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_52w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_52w_t = (IHPE)L23_52w_t ;
LOCAL IUH L23_53w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_53w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_53w_d = (IHPE)L23_53w_d ;
LOCAL IUH L23_49if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_49if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_49if_d = (IHPE)L23_49if_d ;
GLOBAL IUH S_2197_UnchainedWordWrite_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2197_UnchainedWordWrite_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2197_UnchainedWordWrite_00000003_0000000e_00000001 = (IHPE)S_2197_UnchainedWordWrite_00000003_0000000e_00000001 ;
LOCAL IUH L13_2177if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2177if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2177if_f = (IHPE)L13_2177if_f ;
GLOBAL IUH S_2198_UnchainedWordFill_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2198_UnchainedWordFill_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2198_UnchainedWordFill_00000003_0000000e_00000001 = (IHPE)S_2198_UnchainedWordFill_00000003_0000000e_00000001 ;
LOCAL IUH L13_2178if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2178if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2178if_f = (IHPE)L13_2178if_f ;
LOCAL IUH L28_54if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_54if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_54if_f = (IHPE)L28_54if_f ;
LOCAL IUH L28_55if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_55if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_55if_f = (IHPE)L28_55if_f ;
LOCAL IUH L28_56if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_56if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_56if_f = (IHPE)L28_56if_f ;
LOCAL IUH L28_57if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_57if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_57if_f = (IHPE)L28_57if_f ;
GLOBAL IUH S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000 = (IHPE)S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000 ;
LOCAL IUH L13_2179if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2179if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2179if_f = (IHPE)L13_2179if_f ;
LOCAL IUH L28_58if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_58if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_58if_f = (IHPE)L28_58if_f ;
LOCAL IUH L28_59if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_59if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_59if_d = (IHPE)L28_59if_d ;
GLOBAL IUH S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000 = (IHPE)S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000 ;
LOCAL IUH L13_2180if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2180if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2180if_f = (IHPE)L13_2180if_f ;
LOCAL IUH L23_54if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_54if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_54if_f = (IHPE)L23_54if_f ;
LOCAL IUH L23_55if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_55if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_55if_f = (IHPE)L23_55if_f ;
LOCAL IUH L23_56if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_56if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_56if_f = (IHPE)L23_56if_f ;
LOCAL IUH L23_57if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_57if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_57if_f = (IHPE)L23_57if_f ;
GLOBAL IUH S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000 = (IHPE)S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000 ;
LOCAL IUH L13_2181if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2181if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2181if_f = (IHPE)L13_2181if_f ;
LOCAL IUH L23_60w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_60w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_60w_t = (IHPE)L23_60w_t ;
LOCAL IUH L23_61w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_61w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_61w_d = (IHPE)L23_61w_d ;
LOCAL IUH L23_58if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_58if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_58if_f = (IHPE)L23_58if_f ;
LOCAL IUH L23_62w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_62w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_62w_t = (IHPE)L23_62w_t ;
LOCAL IUH L23_63w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_63w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_63w_d = (IHPE)L23_63w_d ;
LOCAL IUH L23_59if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_59if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_59if_d = (IHPE)L23_59if_d ;
GLOBAL IUH S_2202_UnchainedDwordWrite_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2202_UnchainedDwordWrite_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2202_UnchainedDwordWrite_00000003_0000000e_00000001 = (IHPE)S_2202_UnchainedDwordWrite_00000003_0000000e_00000001 ;
LOCAL IUH L13_2182if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2182if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2182if_f = (IHPE)L13_2182if_f ;
GLOBAL IUH S_2203_UnchainedDwordFill_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2203_UnchainedDwordFill_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2203_UnchainedDwordFill_00000003_0000000e_00000001 = (IHPE)S_2203_UnchainedDwordFill_00000003_0000000e_00000001 ;
LOCAL IUH L13_2183if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2183if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2183if_f = (IHPE)L13_2183if_f ;
GLOBAL IUH S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000 = (IHPE)S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000 ;
LOCAL IUH L13_2184if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2184if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2184if_f = (IHPE)L13_2184if_f ;
GLOBAL IUH S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001 = (IHPE)S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001 ;
LOCAL IUH L13_2185if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2185if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2185if_f = (IHPE)L13_2185if_f ;
LOCAL IUH L28_60if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_60if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_60if_f = (IHPE)L28_60if_f ;
LOCAL IUH L28_61if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_61if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_61if_d = (IHPE)L28_61if_d ;
GLOBAL IUH S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001 = (IHPE)S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001 ;
LOCAL IUH L13_2186if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2186if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2186if_f = (IHPE)L13_2186if_f ;
LOCAL IUH L23_64if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_64if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_64if_f = (IHPE)L23_64if_f ;
LOCAL IUH L23_65if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_65if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_65if_f = (IHPE)L23_65if_f ;
LOCAL IUH L23_66if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_66if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_66if_f = (IHPE)L23_66if_f ;
LOCAL IUH L23_67if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_67if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_67if_f = (IHPE)L23_67if_f ;
GLOBAL IUH S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001 = (IHPE)S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001 ;
LOCAL IUH L13_2187if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2187if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2187if_f = (IHPE)L13_2187if_f ;
LOCAL IUH L23_70w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_70w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_70w_t = (IHPE)L23_70w_t ;
LOCAL IUH L23_71w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_71w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_71w_d = (IHPE)L23_71w_d ;
LOCAL IUH L23_68if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_68if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_68if_f = (IHPE)L23_68if_f ;
LOCAL IUH L23_72w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_72w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_72w_t = (IHPE)L23_72w_t ;
LOCAL IUH L23_73w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_73w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_73w_d = (IHPE)L23_73w_d ;
LOCAL IUH L23_69if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_69if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_69if_d = (IHPE)L23_69if_d ;
GLOBAL IUH S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001 = (IHPE)S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001 ;
LOCAL IUH L13_2188if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2188if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2188if_f = (IHPE)L13_2188if_f ;
LOCAL IUH L28_62if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_62if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_62if_f = (IHPE)L28_62if_f ;
LOCAL IUH L28_63if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_63if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_63if_d = (IHPE)L28_63if_d ;
GLOBAL IUH S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001 = (IHPE)S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001 ;
LOCAL IUH L13_2189if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2189if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2189if_f = (IHPE)L13_2189if_f ;
LOCAL IUH L23_74if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_74if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_74if_f = (IHPE)L23_74if_f ;
LOCAL IUH L23_75if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_75if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_75if_f = (IHPE)L23_75if_f ;
LOCAL IUH L23_76if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_76if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_76if_f = (IHPE)L23_76if_f ;
LOCAL IUH L23_77if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_77if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_77if_f = (IHPE)L23_77if_f ;
GLOBAL IUH S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001 = (IHPE)S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001 ;
LOCAL IUH L13_2190if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2190if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2190if_f = (IHPE)L13_2190if_f ;
LOCAL IUH L23_80w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_80w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_80w_t = (IHPE)L23_80w_t ;
LOCAL IUH L23_81w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_81w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_81w_d = (IHPE)L23_81w_d ;
LOCAL IUH L23_78if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_78if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_78if_f = (IHPE)L23_78if_f ;
LOCAL IUH L23_82w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_82w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_82w_t = (IHPE)L23_82w_t ;
LOCAL IUH L23_83w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_83w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_83w_d = (IHPE)L23_83w_d ;
LOCAL IUH L23_79if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_79if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_79if_d = (IHPE)L23_79if_d ;
GLOBAL IUH S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001 = (IHPE)S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001 ;
LOCAL IUH L13_2191if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2191if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2191if_f = (IHPE)L13_2191if_f ;
GLOBAL IUH S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001 = (IHPE)S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001 ;
LOCAL IUH L13_2192if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2192if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2192if_f = (IHPE)L13_2192if_f ;
LOCAL IUH L28_64if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_64if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_64if_f = (IHPE)L28_64if_f ;
LOCAL IUH L28_66if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_66if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_66if_f = (IHPE)L28_66if_f ;
LOCAL IUH L28_67if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_67if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_67if_f = (IHPE)L28_67if_f ;
LOCAL IUH L28_68if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_68if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_68if_f = (IHPE)L28_68if_f ;
LOCAL IUH L28_69if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_69if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_69if_f = (IHPE)L28_69if_f ;
LOCAL IUH L28_65if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_65if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_65if_d = (IHPE)L28_65if_d ;
GLOBAL IUH S_2213_CopyDirByte1Plane_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2213_CopyDirByte1Plane_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2213_CopyDirByte1Plane_00000001 = (IHPE)S_2213_CopyDirByte1Plane_00000001 ;
LOCAL IUH L13_2193if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2193if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2193if_f = (IHPE)L13_2193if_f ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	case	S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000_id	:
		S_2182_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2182)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2162if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2162if_f_id	:
		L13_2162if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_24if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_24if_f_id	:
		L23_24if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_25if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_25if_f_id	:
		L23_25if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_26if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_26if_f_id	:
		L23_26if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_27if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_27if_f_id	:
		L23_27if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000_id	:
		S_2183_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2183)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2163if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2163if_f_id	:
		L13_2163if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_28if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_31w_d;	
	case	L23_30w_t_id	:
		L23_30w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_30w_t;	
	case	L23_31w_d_id	:
		L23_31w_d:	;	
	{	extern	IUH	L23_29if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_29if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_28if_f_id	:
		L23_28if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_33w_d;	
	case	L23_32w_t_id	:
		L23_32w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_32w_t;	
	case	L23_33w_d_id	:
		L23_33w_d:	;	
	case	L23_29if_d_id	:
		L23_29if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2184_UnchainedWordWrite_00000002_0000000e_00000001_id	:
		S_2184_UnchainedWordWrite_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2184)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2164if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2164if_f_id	:
		L13_2164if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1360)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(*((IHPE	*)&(r21)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2185_UnchainedWordFill_00000002_0000000e_00000001_id	:
		S_2185_UnchainedWordFill_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2185)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2165if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2165if_f_id	:
		L13_2165if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_42if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+5)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_42if_f_id	:
		L28_42if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_43if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+4)	))	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+5)	))	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_43if_f_id	:
		L28_43if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_44if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+5)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_44if_f_id	:
		L28_44if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_45if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+5)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_45if_f_id	:
		L28_45if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000_id	:
		S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2186)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2166if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2166if_f_id	:
		L13_2166if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L28_46if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	{	extern	IUH	L28_47if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_47if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_46if_f_id	:
		L28_46if_f:	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	case	L28_47if_d_id	:
		L28_47if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000_id	:
		S_2187_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2187)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2167if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2167if_f_id	:
		L13_2167if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_34if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_34if_f_id	:
		L23_34if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_35if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_35if_f_id	:
		L23_35if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_36if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_36if_f_id	:
		L23_36if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_37if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_37if_f_id	:
		L23_37if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000_id	:
		S_2188_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2188)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2168if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2168if_f_id	:
		L13_2168if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_38if_f;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_41w_d;	
	case	L23_40w_t_id	:
		L23_40w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_40w_t;	
	case	L23_41w_d_id	:
		L23_41w_d:	;	
	{	extern	IUH	L23_39if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_39if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_38if_f_id	:
		L23_38if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_43w_d;	
	case	L23_42w_t_id	:
		L23_42w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_42w_t;	
	case	L23_43w_d_id	:
		L23_43w_d:	;	
	case	L23_39if_d_id	:
		L23_39if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2189_UnchainedDwordWrite_00000002_0000000e_00000001_id	:
		S_2189_UnchainedDwordWrite_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2189)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2169if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2169if_f_id	:
		L13_2169if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16388)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2184_UnchainedWordWrite_00000002_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2184_UnchainedWordWrite_00000002_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16389)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16388)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)&(r20)	+	REGWORD)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2184_UnchainedWordWrite_00000002_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2184_UnchainedWordWrite_00000002_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16389)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2190_UnchainedDwordFill_00000002_0000000e_00000001_id	:
		S_2190_UnchainedDwordFill_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2190)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2170if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2170if_f_id	:
		L13_2170if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2185_UnchainedWordFill_00000002_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2185_UnchainedWordFill_00000002_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)&(r20)	+	REGWORD)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2185_UnchainedWordFill_00000002_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2185_UnchainedWordFill_00000002_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000_id	:
		S_2191_UnchainedDwordMove_00000002_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2191)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2171if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2171if_f_id	:
		L13_2171if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16396)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2186_UnchainedWordMove_00000002_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16397)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2192_UnchainedByteWrite_00000003_0000000e_00000001_id	:
		S_2192_UnchainedByteWrite_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2192)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2172if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2172if_f_id	:
		L13_2172if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1356)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16408)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*(UOFF_15_8(	(LocalIUH+3)	))	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IU16	*)(LocalIUH+3)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)(r1+0))	=	(IS32)(16409)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+3)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2193_UnchainedByteFill_00000003_0000000e_00000001_id	:
		S_2193_UnchainedByteFill_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2193)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2173if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2173if_f_id	:
		L13_2173if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16408)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*(UOFF_15_8(	(LocalIUH+4)	))	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IU16	*)(LocalIUH+4)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)(r1+0))	=	(IS32)(16409)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+4)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_48if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_48if_f_id	:
		L28_48if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_49if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+4)	))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_49if_f_id	:
		L28_49if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_50if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_50if_f_id	:
		L28_50if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_51if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16366)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2153_Unchained1PlaneByteFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2153_Unchained1PlaneByteFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16367)	;	
	case	L28_51if_f_id	:
		L28_51if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000_id	:
		S_2194_UnchainedByteMove_00000003_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2194)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2174if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2174if_f_id	:
		L13_2174if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L28_52if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	{	extern	IUH	L28_53if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_53if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_52if_f_id	:
		L28_52if_f:	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	case	L28_53if_d_id	:
		L28_53if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000_id	:
		S_2195_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2195)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2175if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2175if_f_id	:
		L13_2175if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_44if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_44if_f_id	:
		L23_44if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_45if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_45if_f_id	:
		L23_45if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_46if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_46if_f_id	:
		L23_46if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_47if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_47if_f_id	:
		L23_47if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000_id	:
		S_2196_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2196)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2176if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2176if_f_id	:
		L13_2176if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_48if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_51w_d;	
	case	L23_50w_t_id	:
		L23_50w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_50w_t;	
	case	L23_51w_d_id	:
		L23_51w_d:	;	
	{	extern	IUH	L23_49if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_49if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_48if_f_id	:
		L23_48if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_53w_d;	
	case	L23_52w_t_id	:
		L23_52w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_52w_t;	
	case	L23_53w_d_id	:
		L23_53w_d:	;	
	case	L23_49if_d_id	:
		L23_49if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2197_UnchainedWordWrite_00000003_0000000e_00000001_id	:
		S_2197_UnchainedWordWrite_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2197)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2177if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2177if_f_id	:
		L13_2177if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1360)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16408)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*(UOFF_15_8(	(LocalIUH+3)	))	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IU16	*)(LocalIUH+3)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)(r1+0))	=	(IS32)(16409)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16408)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+1)	))	;	
	*(UOFF_15_8(	(LocalIUH+4)	))	=	*(UOFF_15_8(	(LocalIUH+1)	))	;	
	*((IUH	*)&(r20))	=	*((IU16	*)(LocalIUH+4)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)(r1+0))	=	(IS32)(16409)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+3)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+3)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+4)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(*((IHPE	*)&(r21)))	)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r22))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r22))	;		
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2198_UnchainedWordFill_00000003_0000000e_00000001_id	:
		S_2198_UnchainedWordFill_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2198)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2178if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2178if_f_id	:
		L13_2178if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16408)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*(UOFF_15_8(	(LocalIUH+4)	))	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IU16	*)(LocalIUH+4)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)(r1+0))	=	(IS32)(16409)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16408)	;	
	*((IU8	*)(LocalIUH+5)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+1)	))	;	
	*(UOFF_15_8(	(LocalIUH+5)	))	=	*(UOFF_15_8(	(LocalIUH+1)	))	;	
	*((IUH	*)&(r20))	=	*((IU16	*)(LocalIUH+5)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)(r1+0))	=	(IS32)(16409)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+4)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+4)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+5)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_54if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+5)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_54if_f_id	:
		L28_54if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_55if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+4)	))	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*(UOFF_15_8(	(LocalIUH+5)	))	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_55if_f_id	:
		L28_55if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_56if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+5)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_56if_f_id	:
		L28_56if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_57if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16378)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+4)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(24)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+5)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2159_Unchained1PlaneWordFill()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2159_Unchained1PlaneWordFill(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16379)	;	
	case	L28_57if_f_id	:
		L28_57if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000_id	:
		S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2199)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2179if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2179if_f_id	:
		L13_2179if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L28_58if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	{	extern	IUH	L28_59if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_59if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_58if_f_id	:
		L28_58if_f:	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	case	L28_59if_d_id	:
		L28_59if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000_id	:
		S_2200_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2200)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2180if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2180if_f_id	:
		L13_2180if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_54if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_54if_f_id	:
		L23_54if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_55if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_55if_f_id	:
		L23_55if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_56if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_56if_f_id	:
		L23_56if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_57if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_57if_f_id	:
		L23_57if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000_id	:
		S_2201_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2201)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2181if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2181if_f_id	:
		L13_2181if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_58if_f;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_61w_d;	
	case	L23_60w_t_id	:
		L23_60w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_60w_t;	
	case	L23_61w_d_id	:
		L23_61w_d:	;	
	{	extern	IUH	L23_59if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_59if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_58if_f_id	:
		L23_58if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_63w_d;	
	case	L23_62w_t_id	:
		L23_62w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_62w_t;	
	case	L23_63w_d_id	:
		L23_63w_d:	;	
	case	L23_59if_d_id	:
		L23_59if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2202_UnchainedDwordWrite_00000003_0000000e_00000001_id	:
		S_2202_UnchainedDwordWrite_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2202)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2182if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2182if_f_id	:
		L13_2182if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16388)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2197_UnchainedWordWrite_00000003_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2197_UnchainedWordWrite_00000003_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16389)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16388)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)&(r20)	+	REGWORD)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2197_UnchainedWordWrite_00000003_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2197_UnchainedWordWrite_00000003_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16389)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2203_UnchainedDwordFill_00000003_0000000e_00000001_id	:
		S_2203_UnchainedDwordFill_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2203)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2183if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2183if_f_id	:
		L13_2183if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2198_UnchainedWordFill_00000003_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2198_UnchainedWordFill_00000003_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)&(r20)	+	REGWORD)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2198_UnchainedWordFill_00000003_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2198_UnchainedWordFill_00000003_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000_id	:
		S_2204_UnchainedDwordMove_00000003_0000000e_00000001_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2204)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2184if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2184if_f_id	:
		L13_2184if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16396)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2199_UnchainedWordMove_00000003_0000000e_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16397)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001_id	:
		S_2205_UnchainedByteMove_00000000_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2205)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2185if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2185if_f_id	:
		L13_2185if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_60if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	{	extern	IUH	L28_61if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_61if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_60if_f_id	:
		L28_60if_f:	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	-	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	case	L28_61if_d_id	:
		L28_61if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001_id	:
		S_2206_CopyBytePlnByPlnUnchained_00000000_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2206)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2186if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2186if_f_id	:
		L13_2186if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_64if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_64if_f_id	:
		L23_64if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_65if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_65if_f_id	:
		L23_65if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_66if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_66if_f_id	:
		L23_66if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_67if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_67if_f_id	:
		L23_67if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001_id	:
		S_2207_CopyByte1PlaneUnchained_00000000_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2207)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2187if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2187if_f_id	:
		L13_2187if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_68if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_71w_d;	
	case	L23_70w_t_id	:
		L23_70w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_70w_t;	
	case	L23_71w_d_id	:
		L23_71w_d:	;	
	{	extern	IUH	L23_69if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_69if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_68if_f_id	:
		L23_68if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_73w_d;	
	case	L23_72w_t_id	:
		L23_72w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_72w_t;	
	case	L23_73w_d_id	:
		L23_73w_d:	;	
	case	L23_69if_d_id	:
		L23_69if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001_id	:
		S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2208)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2188if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2188if_f_id	:
		L13_2188if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_62if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	{	extern	IUH	L28_63if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_63if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_62if_f_id	:
		L28_62if_f:	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	-	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	case	L28_63if_d_id	:
		L28_63if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001_id	:
		S_2209_CopyWordPlnByPlnUnchained_00000000_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2209)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2189if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2189if_f_id	:
		L13_2189if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_74if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_74if_f_id	:
		L23_74if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_75if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_75if_f_id	:
		L23_75if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_76if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_76if_f_id	:
		L23_76if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_77if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_77if_f_id	:
		L23_77if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001_id	:
		S_2210_CopyWord1PlaneUnchained_00000000_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2210)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2190if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2190if_f_id	:
		L13_2190if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_78if_f;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_81w_d;	
	case	L23_80w_t_id	:
		L23_80w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_80w_t;	
	case	L23_81w_d_id	:
		L23_81w_d:	;	
	{	extern	IUH	L23_79if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_79if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_78if_f_id	:
		L23_78if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_83w_d;	
	case	L23_82w_t_id	:
		L23_82w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	<<	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_82w_t;	
	case	L23_83w_d_id	:
		L23_83w_d:	;	
	case	L23_79if_d_id	:
		L23_79if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001_id	:
		S_2211_UnchainedDwordMove_00000000_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2211)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2191if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2191if_f_id	:
		L13_2191if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16396)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2208_UnchainedWordMove_00000000_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16397)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001_id	:
		S_2212_UnchainedByteMove_00000001_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2212)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2192if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2192if_f_id	:
		L13_2192if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_64if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16398)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	(IS32)(-1)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2167_UnchainedByteFill_00000001_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2167_UnchainedByteFill_00000001_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16399)	;	
	{	extern	IUH	L28_65if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_65if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_64if_f_id	:
		L28_64if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_66if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16400)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2213_CopyDirByte1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2213_CopyDirByte1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16401)	;	
	case	L28_66if_f_id	:
		L28_66if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_67if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16400)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2213_CopyDirByte1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2213_CopyDirByte1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16401)	;	
	case	L28_67if_f_id	:
		L28_67if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_68if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16400)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2213_CopyDirByte1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2213_CopyDirByte1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16401)	;	
	case	L28_68if_f_id	:
		L28_68if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_69if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16400)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2213_CopyDirByte1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2213_CopyDirByte1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16401)	;	
	case	L28_69if_f_id	:
		L28_69if_f:	;	
	case	L28_65if_d_id	:
		L28_65if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2213_CopyDirByte1Plane_00000001_id	:
		S_2213_CopyDirByte1Plane_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2213)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2193if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2193if_f_id	:
		L13_2193if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16410)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2214_CopyBwdByte1Plane()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2214_CopyBwdByte1Plane(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16411)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\cvidc\sevid004.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_2214_CopyBwdByte1Plane_id,
L13_2194if_f_id,
L23_84w_t_id,
L23_85w_d_id,
S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001_id,
L13_2195if_f_id,
L28_70if_f_id,
L28_72if_f_id,
L28_73if_f_id,
L28_74if_f_id,
L28_75if_f_id,
L28_71if_d_id,
S_2216_CopyDirWord1Plane_00000001_id,
L13_2196if_f_id,
S_2217_CopyBwdWord1Plane_id,
L13_2197if_f_id,
L23_86w_t_id,
L23_87w_d_id,
S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001_id,
L13_2198if_f_id,
S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001_id,
L13_2199if_f_id,
L28_76if_f_id,
L28_77if_d_id,
S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001_id,
L13_2200if_f_id,
L23_88if_f_id,
L23_89if_f_id,
L23_90if_f_id,
L23_91if_f_id,
S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001_id,
L13_2201if_f_id,
L23_94w_t_id,
L23_95w_d_id,
L23_92if_f_id,
L23_96w_t_id,
L23_97w_d_id,
L23_93if_d_id,
S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001_id,
L13_2202if_f_id,
L28_78if_f_id,
L28_79if_d_id,
S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001_id,
L13_2203if_f_id,
L23_98if_f_id,
L23_99if_f_id,
L23_100if_f_id,
L23_101if_f_id,
S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001_id,
L13_2204if_f_id,
L23_104w_t_id,
L23_105w_d_id,
L23_102if_f_id,
L23_106w_t_id,
L23_107w_d_id,
L23_103if_d_id,
S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001_id,
L13_2205if_f_id,
S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001_id,
L13_2206if_f_id,
L28_80if_f_id,
L28_81if_d_id,
S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001_id,
L13_2207if_f_id,
L23_108if_f_id,
L23_109if_f_id,
L23_110if_f_id,
L23_111if_f_id,
S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001_id,
L13_2208if_f_id,
L23_114w_t_id,
L23_115w_d_id,
L23_112if_f_id,
L23_116w_t_id,
L23_117w_d_id,
L23_113if_d_id,
S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001_id,
L13_2209if_f_id,
L28_82if_f_id,
L28_83if_d_id,
S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001_id,
L13_2210if_f_id,
L23_118if_f_id,
L23_119if_f_id,
L23_120if_f_id,
L23_121if_f_id,
S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001_id,
L13_2211if_f_id,
L23_124w_t_id,
L23_125w_d_id,
L23_122if_f_id,
L23_126w_t_id,
L23_127w_d_id,
L23_123if_d_id,
S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001_id,
L13_2212if_f_id,
S_2233_EGAGCIndexOutb_id,
L13_2213if_f_id,
S_2234_VGAGCIndexOutb_id,
L13_2214if_f_id,
L29_1if_f_id,
L29_2if_d_id,
L29_0if_f_id,
S_2235_VGAGCMaskRegOutb_id,
L13_2215if_f_id,
L29_3if_f_id,
S_2236_AdapCOutb_id,
L13_2216if_f_id,
S_2237_VGAGCMaskFFRegOutb_id,
L13_2217if_f_id,
L29_4if_f_id,
S_2238_GenericByteWrite_id,
L13_2218if_f_id,
L24_0if_f_id,
L24_2if_f_id,
L24_3if_d_id,
L24_8if_f_id,
L24_9if_d_id,
L24_6if_f_id,
L24_10if_f_id,
L24_11if_d_id,
L24_7if_d_id,
L24_4if_f_id,
L24_12if_f_id,
L24_5if_d_id,
L24_15if_f_id,
L24_13if_f_id,
L24_16if_f_id,
L24_18if_f_id,
L24_19if_d_id,
L24_21if_f_id,
L24_23if_f_id,
L24_24if_d_id,
L24_22if_d_id,
L24_20if_f_id,
L24_25if_f_id,
L24_17if_d_id,
L24_14if_d_id,
L24_1if_d_id,
L24_26if_f_id,
L24_28if_f_id,
L24_27if_d_id,
S_2239_GenericByteFill_id,
L13_2219if_f_id,
L24_31w_t_id,
L24_32w_d_id,
L24_29if_f_id,
L24_33w_t_id,
L24_34w_d_id,
L24_30if_d_id,
S_2240_GenericByteMove_Fwd_id,
L13_2220if_f_id,
L24_35if_f_id,
L24_36if_d_id,
L24_39w_t_id,
L24_40w_d_id,
L24_37if_f_id,
L24_41w_t_id,
L24_42w_d_id,
L24_38if_d_id,
S_2241_GenericWordWrite_id,
L13_2221if_f_id,
L24_43if_f_id,
L24_45if_f_id,
L24_46if_d_id,
L24_51if_f_id,
L24_52if_d_id,
L24_49if_f_id,
L24_53if_f_id,
L24_54if_d_id,
L24_50if_d_id,
L24_47if_f_id,
L24_55if_f_id,
L24_48if_d_id,
L24_58if_f_id,
L24_56if_f_id,
L24_59if_f_id,
L24_61if_f_id,
L24_62if_d_id,
L24_64if_f_id,
L24_66if_f_id,
L24_67if_d_id,
L24_65if_d_id,
L24_63if_f_id,
L24_68if_f_id,
L24_60if_d_id,
L24_57if_d_id,
L24_44if_d_id,
L24_69if_f_id,
L24_71if_f_id,
L24_72if_f_id,
L24_70if_d_id,
S_2242_GenericWordFill_id,
L13_2222if_f_id,
L24_75w_t_id,
L24_76w_d_id,
L24_73if_f_id,
L24_77w_t_id,
L24_78w_d_id,
L24_74if_d_id,
S_2243_GenericWordMove_Fwd_id,
L13_2223if_f_id,
L24_79if_f_id,
L24_80if_d_id,
L24_83w_t_id,
L24_84w_d_id,
L24_81if_f_id,
L24_85w_t_id,
L24_86w_d_id,
L24_82if_d_id,
S_2244_GenericDwordWrite_id,
L13_2224if_f_id,
L24_87if_f_id,
L24_88if_d_id,
S_2245_GenericDwordFill_id,
L13_2225if_f_id,
L24_91w_t_id,
L24_92w_d_id,
L24_89if_f_id,
L24_93w_t_id,
L24_94w_d_id,
L24_90if_d_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_2214_CopyBwdByte1Plane IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2214_CopyBwdByte1Plane_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2214_CopyBwdByte1Plane = (IHPE)S_2214_CopyBwdByte1Plane ;
LOCAL IUH L13_2194if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2194if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2194if_f = (IHPE)L13_2194if_f ;
LOCAL IUH L23_84w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_84w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_84w_t = (IHPE)L23_84w_t ;
LOCAL IUH L23_85w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_85w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_85w_d = (IHPE)L23_85w_d ;
GLOBAL IUH S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001 = (IHPE)S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001 ;
LOCAL IUH L13_2195if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2195if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2195if_f = (IHPE)L13_2195if_f ;
LOCAL IUH L28_70if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_70if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_70if_f = (IHPE)L28_70if_f ;
LOCAL IUH L28_72if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_72if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_72if_f = (IHPE)L28_72if_f ;
LOCAL IUH L28_73if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_73if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_73if_f = (IHPE)L28_73if_f ;
LOCAL IUH L28_74if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_74if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_74if_f = (IHPE)L28_74if_f ;
LOCAL IUH L28_75if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_75if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_75if_f = (IHPE)L28_75if_f ;
LOCAL IUH L28_71if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_71if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_71if_d = (IHPE)L28_71if_d ;
GLOBAL IUH S_2216_CopyDirWord1Plane_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2216_CopyDirWord1Plane_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2216_CopyDirWord1Plane_00000001 = (IHPE)S_2216_CopyDirWord1Plane_00000001 ;
LOCAL IUH L13_2196if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2196if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2196if_f = (IHPE)L13_2196if_f ;
GLOBAL IUH S_2217_CopyBwdWord1Plane IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2217_CopyBwdWord1Plane_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2217_CopyBwdWord1Plane = (IHPE)S_2217_CopyBwdWord1Plane ;
LOCAL IUH L13_2197if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2197if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2197if_f = (IHPE)L13_2197if_f ;
LOCAL IUH L23_86w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_86w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_86w_t = (IHPE)L23_86w_t ;
LOCAL IUH L23_87w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_87w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_87w_d = (IHPE)L23_87w_d ;
GLOBAL IUH S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001 = (IHPE)S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001 ;
LOCAL IUH L13_2198if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2198if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2198if_f = (IHPE)L13_2198if_f ;
GLOBAL IUH S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001 = (IHPE)S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001 ;
LOCAL IUH L13_2199if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2199if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2199if_f = (IHPE)L13_2199if_f ;
LOCAL IUH L28_76if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_76if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_76if_f = (IHPE)L28_76if_f ;
LOCAL IUH L28_77if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_77if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_77if_d = (IHPE)L28_77if_d ;
GLOBAL IUH S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001 = (IHPE)S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001 ;
LOCAL IUH L13_2200if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2200if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2200if_f = (IHPE)L13_2200if_f ;
LOCAL IUH L23_88if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_88if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_88if_f = (IHPE)L23_88if_f ;
LOCAL IUH L23_89if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_89if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_89if_f = (IHPE)L23_89if_f ;
LOCAL IUH L23_90if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_90if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_90if_f = (IHPE)L23_90if_f ;
LOCAL IUH L23_91if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_91if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_91if_f = (IHPE)L23_91if_f ;
GLOBAL IUH S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001 = (IHPE)S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001 ;
LOCAL IUH L13_2201if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2201if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2201if_f = (IHPE)L13_2201if_f ;
LOCAL IUH L23_94w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_94w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_94w_t = (IHPE)L23_94w_t ;
LOCAL IUH L23_95w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_95w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_95w_d = (IHPE)L23_95w_d ;
LOCAL IUH L23_92if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_92if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_92if_f = (IHPE)L23_92if_f ;
LOCAL IUH L23_96w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_96w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_96w_t = (IHPE)L23_96w_t ;
LOCAL IUH L23_97w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_97w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_97w_d = (IHPE)L23_97w_d ;
LOCAL IUH L23_93if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_93if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_93if_d = (IHPE)L23_93if_d ;
GLOBAL IUH S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001 = (IHPE)S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001 ;
LOCAL IUH L13_2202if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2202if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2202if_f = (IHPE)L13_2202if_f ;
LOCAL IUH L28_78if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_78if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_78if_f = (IHPE)L28_78if_f ;
LOCAL IUH L28_79if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_79if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_79if_d = (IHPE)L28_79if_d ;
GLOBAL IUH S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001 = (IHPE)S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001 ;
LOCAL IUH L13_2203if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2203if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2203if_f = (IHPE)L13_2203if_f ;
LOCAL IUH L23_98if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_98if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_98if_f = (IHPE)L23_98if_f ;
LOCAL IUH L23_99if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_99if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_99if_f = (IHPE)L23_99if_f ;
LOCAL IUH L23_100if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_100if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_100if_f = (IHPE)L23_100if_f ;
LOCAL IUH L23_101if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_101if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_101if_f = (IHPE)L23_101if_f ;
GLOBAL IUH S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001 = (IHPE)S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001 ;
LOCAL IUH L13_2204if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2204if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2204if_f = (IHPE)L13_2204if_f ;
LOCAL IUH L23_104w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_104w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_104w_t = (IHPE)L23_104w_t ;
LOCAL IUH L23_105w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_105w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_105w_d = (IHPE)L23_105w_d ;
LOCAL IUH L23_102if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_102if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_102if_f = (IHPE)L23_102if_f ;
LOCAL IUH L23_106w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_106w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_106w_t = (IHPE)L23_106w_t ;
LOCAL IUH L23_107w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_107w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_107w_d = (IHPE)L23_107w_d ;
LOCAL IUH L23_103if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_103if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_103if_d = (IHPE)L23_103if_d ;
GLOBAL IUH S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001 = (IHPE)S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001 ;
LOCAL IUH L13_2205if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2205if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2205if_f = (IHPE)L13_2205if_f ;
GLOBAL IUH S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001 = (IHPE)S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001 ;
LOCAL IUH L13_2206if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2206if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2206if_f = (IHPE)L13_2206if_f ;
LOCAL IUH L28_80if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_80if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_80if_f = (IHPE)L28_80if_f ;
LOCAL IUH L28_81if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_81if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_81if_d = (IHPE)L28_81if_d ;
GLOBAL IUH S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001 = (IHPE)S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001 ;
LOCAL IUH L13_2207if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2207if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2207if_f = (IHPE)L13_2207if_f ;
LOCAL IUH L23_108if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_108if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_108if_f = (IHPE)L23_108if_f ;
LOCAL IUH L23_109if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_109if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_109if_f = (IHPE)L23_109if_f ;
LOCAL IUH L23_110if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_110if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_110if_f = (IHPE)L23_110if_f ;
LOCAL IUH L23_111if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_111if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_111if_f = (IHPE)L23_111if_f ;
GLOBAL IUH S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001 = (IHPE)S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001 ;
LOCAL IUH L13_2208if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2208if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2208if_f = (IHPE)L13_2208if_f ;
LOCAL IUH L23_114w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_114w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_114w_t = (IHPE)L23_114w_t ;
LOCAL IUH L23_115w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_115w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_115w_d = (IHPE)L23_115w_d ;
LOCAL IUH L23_112if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_112if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_112if_f = (IHPE)L23_112if_f ;
LOCAL IUH L23_116w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_116w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_116w_t = (IHPE)L23_116w_t ;
LOCAL IUH L23_117w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_117w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_117w_d = (IHPE)L23_117w_d ;
LOCAL IUH L23_113if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_113if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_113if_d = (IHPE)L23_113if_d ;
GLOBAL IUH S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001 = (IHPE)S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001 ;
LOCAL IUH L13_2209if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2209if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2209if_f = (IHPE)L13_2209if_f ;
LOCAL IUH L28_82if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_82if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_82if_f = (IHPE)L28_82if_f ;
LOCAL IUH L28_83if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L28_83if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L28_83if_d = (IHPE)L28_83if_d ;
GLOBAL IUH S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001 = (IHPE)S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001 ;
LOCAL IUH L13_2210if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2210if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2210if_f = (IHPE)L13_2210if_f ;
LOCAL IUH L23_118if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_118if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_118if_f = (IHPE)L23_118if_f ;
LOCAL IUH L23_119if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_119if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_119if_f = (IHPE)L23_119if_f ;
LOCAL IUH L23_120if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_120if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_120if_f = (IHPE)L23_120if_f ;
LOCAL IUH L23_121if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_121if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_121if_f = (IHPE)L23_121if_f ;
GLOBAL IUH S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001 = (IHPE)S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001 ;
LOCAL IUH L13_2211if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2211if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2211if_f = (IHPE)L13_2211if_f ;
LOCAL IUH L23_124w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_124w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_124w_t = (IHPE)L23_124w_t ;
LOCAL IUH L23_125w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_125w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_125w_d = (IHPE)L23_125w_d ;
LOCAL IUH L23_122if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_122if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_122if_f = (IHPE)L23_122if_f ;
LOCAL IUH L23_126w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_126w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_126w_t = (IHPE)L23_126w_t ;
LOCAL IUH L23_127w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_127w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_127w_d = (IHPE)L23_127w_d ;
LOCAL IUH L23_123if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_123if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_123if_d = (IHPE)L23_123if_d ;
GLOBAL IUH S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001 = (IHPE)S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001 ;
LOCAL IUH L13_2212if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2212if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2212if_f = (IHPE)L13_2212if_f ;
GLOBAL IUH S_2233_EGAGCIndexOutb IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2233_EGAGCIndexOutb_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2233_EGAGCIndexOutb = (IHPE)S_2233_EGAGCIndexOutb ;
LOCAL IUH L13_2213if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2213if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2213if_f = (IHPE)L13_2213if_f ;
GLOBAL IUH S_2234_VGAGCIndexOutb IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2234_VGAGCIndexOutb_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2234_VGAGCIndexOutb = (IHPE)S_2234_VGAGCIndexOutb ;
LOCAL IUH L13_2214if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2214if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2214if_f = (IHPE)L13_2214if_f ;
LOCAL IUH L29_1if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L29_1if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L29_1if_f = (IHPE)L29_1if_f ;
LOCAL IUH L29_2if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L29_2if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L29_2if_d = (IHPE)L29_2if_d ;
LOCAL IUH L29_0if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L29_0if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L29_0if_f = (IHPE)L29_0if_f ;
GLOBAL IUH S_2235_VGAGCMaskRegOutb IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2235_VGAGCMaskRegOutb_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2235_VGAGCMaskRegOutb = (IHPE)S_2235_VGAGCMaskRegOutb ;
LOCAL IUH L13_2215if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2215if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2215if_f = (IHPE)L13_2215if_f ;
LOCAL IUH L29_3if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L29_3if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L29_3if_f = (IHPE)L29_3if_f ;
GLOBAL IUH S_2236_AdapCOutb IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2236_AdapCOutb_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2236_AdapCOutb = (IHPE)S_2236_AdapCOutb ;
LOCAL IUH L13_2216if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2216if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2216if_f = (IHPE)L13_2216if_f ;
GLOBAL IUH S_2237_VGAGCMaskFFRegOutb IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2237_VGAGCMaskFFRegOutb_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2237_VGAGCMaskFFRegOutb = (IHPE)S_2237_VGAGCMaskFFRegOutb ;
LOCAL IUH L13_2217if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2217if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2217if_f = (IHPE)L13_2217if_f ;
LOCAL IUH L29_4if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L29_4if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L29_4if_f = (IHPE)L29_4if_f ;
GLOBAL IUH S_2238_GenericByteWrite IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2238_GenericByteWrite_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2238_GenericByteWrite = (IHPE)S_2238_GenericByteWrite ;
LOCAL IUH L13_2218if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2218if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2218if_f = (IHPE)L13_2218if_f ;
LOCAL IUH L24_0if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_0if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_0if_f = (IHPE)L24_0if_f ;
LOCAL IUH L24_2if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_2if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_2if_f = (IHPE)L24_2if_f ;
LOCAL IUH L24_3if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_3if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_3if_d = (IHPE)L24_3if_d ;
LOCAL IUH L24_8if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_8if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_8if_f = (IHPE)L24_8if_f ;
LOCAL IUH L24_9if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_9if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_9if_d = (IHPE)L24_9if_d ;
LOCAL IUH L24_6if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_6if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_6if_f = (IHPE)L24_6if_f ;
LOCAL IUH L24_10if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_10if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_10if_f = (IHPE)L24_10if_f ;
LOCAL IUH L24_11if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_11if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_11if_d = (IHPE)L24_11if_d ;
LOCAL IUH L24_7if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_7if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_7if_d = (IHPE)L24_7if_d ;
LOCAL IUH L24_4if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_4if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_4if_f = (IHPE)L24_4if_f ;
LOCAL IUH L24_12if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_12if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_12if_f = (IHPE)L24_12if_f ;
LOCAL IUH L24_5if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_5if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_5if_d = (IHPE)L24_5if_d ;
LOCAL IUH L24_15if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_15if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_15if_f = (IHPE)L24_15if_f ;
LOCAL IUH L24_13if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_13if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_13if_f = (IHPE)L24_13if_f ;
LOCAL IUH L24_16if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_16if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_16if_f = (IHPE)L24_16if_f ;
LOCAL IUH L24_18if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_18if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_18if_f = (IHPE)L24_18if_f ;
LOCAL IUH L24_19if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_19if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_19if_d = (IHPE)L24_19if_d ;
LOCAL IUH L24_21if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_21if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_21if_f = (IHPE)L24_21if_f ;
LOCAL IUH L24_23if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_23if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_23if_f = (IHPE)L24_23if_f ;
LOCAL IUH L24_24if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_24if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_24if_d = (IHPE)L24_24if_d ;
LOCAL IUH L24_22if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_22if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_22if_d = (IHPE)L24_22if_d ;
LOCAL IUH L24_20if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_20if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_20if_f = (IHPE)L24_20if_f ;
LOCAL IUH L24_25if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_25if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_25if_f = (IHPE)L24_25if_f ;
LOCAL IUH L24_17if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_17if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_17if_d = (IHPE)L24_17if_d ;
LOCAL IUH L24_14if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_14if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_14if_d = (IHPE)L24_14if_d ;
LOCAL IUH L24_1if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_1if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_1if_d = (IHPE)L24_1if_d ;
LOCAL IUH L24_26if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_26if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_26if_f = (IHPE)L24_26if_f ;
LOCAL IUH L24_28if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_28if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_28if_f = (IHPE)L24_28if_f ;
LOCAL IUH L24_27if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_27if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_27if_d = (IHPE)L24_27if_d ;
GLOBAL IUH S_2239_GenericByteFill IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2239_GenericByteFill_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2239_GenericByteFill = (IHPE)S_2239_GenericByteFill ;
LOCAL IUH L13_2219if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2219if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2219if_f = (IHPE)L13_2219if_f ;
LOCAL IUH L24_31w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_31w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_31w_t = (IHPE)L24_31w_t ;
LOCAL IUH L24_32w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_32w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_32w_d = (IHPE)L24_32w_d ;
LOCAL IUH L24_29if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_29if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_29if_f = (IHPE)L24_29if_f ;
LOCAL IUH L24_33w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_33w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_33w_t = (IHPE)L24_33w_t ;
LOCAL IUH L24_34w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_34w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_34w_d = (IHPE)L24_34w_d ;
LOCAL IUH L24_30if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_30if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_30if_d = (IHPE)L24_30if_d ;
GLOBAL IUH S_2240_GenericByteMove_Fwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2240_GenericByteMove_Fwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2240_GenericByteMove_Fwd = (IHPE)S_2240_GenericByteMove_Fwd ;
LOCAL IUH L13_2220if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2220if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2220if_f = (IHPE)L13_2220if_f ;
LOCAL IUH L24_35if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_35if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_35if_f = (IHPE)L24_35if_f ;
LOCAL IUH L24_36if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_36if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_36if_d = (IHPE)L24_36if_d ;
LOCAL IUH L24_39w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_39w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_39w_t = (IHPE)L24_39w_t ;
LOCAL IUH L24_40w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_40w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_40w_d = (IHPE)L24_40w_d ;
LOCAL IUH L24_37if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_37if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_37if_f = (IHPE)L24_37if_f ;
LOCAL IUH L24_41w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_41w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_41w_t = (IHPE)L24_41w_t ;
LOCAL IUH L24_42w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_42w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_42w_d = (IHPE)L24_42w_d ;
LOCAL IUH L24_38if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_38if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_38if_d = (IHPE)L24_38if_d ;
GLOBAL IUH S_2241_GenericWordWrite IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2241_GenericWordWrite_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2241_GenericWordWrite = (IHPE)S_2241_GenericWordWrite ;
LOCAL IUH L13_2221if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2221if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2221if_f = (IHPE)L13_2221if_f ;
LOCAL IUH L24_43if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_43if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_43if_f = (IHPE)L24_43if_f ;
LOCAL IUH L24_45if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_45if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_45if_f = (IHPE)L24_45if_f ;
LOCAL IUH L24_46if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_46if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_46if_d = (IHPE)L24_46if_d ;
LOCAL IUH L24_51if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_51if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_51if_f = (IHPE)L24_51if_f ;
LOCAL IUH L24_52if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_52if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_52if_d = (IHPE)L24_52if_d ;
LOCAL IUH L24_49if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_49if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_49if_f = (IHPE)L24_49if_f ;
LOCAL IUH L24_53if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_53if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_53if_f = (IHPE)L24_53if_f ;
LOCAL IUH L24_54if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_54if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_54if_d = (IHPE)L24_54if_d ;
LOCAL IUH L24_50if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_50if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_50if_d = (IHPE)L24_50if_d ;
LOCAL IUH L24_47if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_47if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_47if_f = (IHPE)L24_47if_f ;
LOCAL IUH L24_55if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_55if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_55if_f = (IHPE)L24_55if_f ;
LOCAL IUH L24_48if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_48if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_48if_d = (IHPE)L24_48if_d ;
LOCAL IUH L24_58if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_58if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_58if_f = (IHPE)L24_58if_f ;
LOCAL IUH L24_56if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_56if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_56if_f = (IHPE)L24_56if_f ;
LOCAL IUH L24_59if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_59if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_59if_f = (IHPE)L24_59if_f ;
LOCAL IUH L24_61if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_61if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_61if_f = (IHPE)L24_61if_f ;
LOCAL IUH L24_62if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_62if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_62if_d = (IHPE)L24_62if_d ;
LOCAL IUH L24_64if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_64if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_64if_f = (IHPE)L24_64if_f ;
LOCAL IUH L24_66if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_66if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_66if_f = (IHPE)L24_66if_f ;
LOCAL IUH L24_67if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_67if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_67if_d = (IHPE)L24_67if_d ;
LOCAL IUH L24_65if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_65if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_65if_d = (IHPE)L24_65if_d ;
LOCAL IUH L24_63if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_63if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_63if_f = (IHPE)L24_63if_f ;
LOCAL IUH L24_68if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_68if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_68if_f = (IHPE)L24_68if_f ;
LOCAL IUH L24_60if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_60if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_60if_d = (IHPE)L24_60if_d ;
LOCAL IUH L24_57if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_57if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_57if_d = (IHPE)L24_57if_d ;
LOCAL IUH L24_44if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_44if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_44if_d = (IHPE)L24_44if_d ;
LOCAL IUH L24_69if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_69if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_69if_f = (IHPE)L24_69if_f ;
LOCAL IUH L24_71if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_71if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_71if_f = (IHPE)L24_71if_f ;
LOCAL IUH L24_72if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_72if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_72if_f = (IHPE)L24_72if_f ;
LOCAL IUH L24_70if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_70if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_70if_d = (IHPE)L24_70if_d ;
GLOBAL IUH S_2242_GenericWordFill IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2242_GenericWordFill_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2242_GenericWordFill = (IHPE)S_2242_GenericWordFill ;
LOCAL IUH L13_2222if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2222if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2222if_f = (IHPE)L13_2222if_f ;
LOCAL IUH L24_75w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_75w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_75w_t = (IHPE)L24_75w_t ;
LOCAL IUH L24_76w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_76w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_76w_d = (IHPE)L24_76w_d ;
LOCAL IUH L24_73if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_73if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_73if_f = (IHPE)L24_73if_f ;
LOCAL IUH L24_77w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_77w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_77w_t = (IHPE)L24_77w_t ;
LOCAL IUH L24_78w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_78w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_78w_d = (IHPE)L24_78w_d ;
LOCAL IUH L24_74if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_74if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_74if_d = (IHPE)L24_74if_d ;
GLOBAL IUH S_2243_GenericWordMove_Fwd IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2243_GenericWordMove_Fwd_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2243_GenericWordMove_Fwd = (IHPE)S_2243_GenericWordMove_Fwd ;
LOCAL IUH L13_2223if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2223if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2223if_f = (IHPE)L13_2223if_f ;
LOCAL IUH L24_79if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_79if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_79if_f = (IHPE)L24_79if_f ;
LOCAL IUH L24_80if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_80if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_80if_d = (IHPE)L24_80if_d ;
LOCAL IUH L24_83w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_83w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_83w_t = (IHPE)L24_83w_t ;
LOCAL IUH L24_84w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_84w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_84w_d = (IHPE)L24_84w_d ;
LOCAL IUH L24_81if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_81if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_81if_f = (IHPE)L24_81if_f ;
LOCAL IUH L24_85w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_85w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_85w_t = (IHPE)L24_85w_t ;
LOCAL IUH L24_86w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_86w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_86w_d = (IHPE)L24_86w_d ;
LOCAL IUH L24_82if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_82if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_82if_d = (IHPE)L24_82if_d ;
GLOBAL IUH S_2244_GenericDwordWrite IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2244_GenericDwordWrite_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2244_GenericDwordWrite = (IHPE)S_2244_GenericDwordWrite ;
LOCAL IUH L13_2224if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2224if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2224if_f = (IHPE)L13_2224if_f ;
LOCAL IUH L24_87if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_87if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_87if_f = (IHPE)L24_87if_f ;
LOCAL IUH L24_88if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_88if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_88if_d = (IHPE)L24_88if_d ;
GLOBAL IUH S_2245_GenericDwordFill IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2245_GenericDwordFill_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2245_GenericDwordFill = (IHPE)S_2245_GenericDwordFill ;
LOCAL IUH L13_2225if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2225if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2225if_f = (IHPE)L13_2225if_f ;
LOCAL IUH L24_91w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_91w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_91w_t = (IHPE)L24_91w_t ;
LOCAL IUH L24_92w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_92w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_92w_d = (IHPE)L24_92w_d ;
LOCAL IUH L24_89if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_89if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_89if_f = (IHPE)L24_89if_f ;
LOCAL IUH L24_93w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_93w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_93w_t = (IHPE)L24_93w_t ;
LOCAL IUH L24_94w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_94w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_94w_d = (IHPE)L24_94w_d ;
LOCAL IUH L24_90if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L24_90if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L24_90if_d = (IHPE)L24_90if_d ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	case	S_2214_CopyBwdByte1Plane_id	:
		S_2214_CopyBwdByte1Plane	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2214)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2194if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2194if_f_id	:
		L13_2194if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_85w_d;	
	case	L23_84w_t_id	:
		L23_84w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_84w_t;	
	case	L23_85w_d_id	:
		L23_85w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001_id	:
		S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2215)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2195if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2195if_f_id	:
		L13_2195if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_70if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16392)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	*	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	(IS32)(-1)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2172_UnchainedWordFill_00000001_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2172_UnchainedWordFill_00000001_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16393)	;	
	{	extern	IUH	L28_71if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_71if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_70if_f_id	:
		L28_70if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_72if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2216_CopyDirWord1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2216_CopyDirWord1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L28_72if_f_id	:
		L28_72if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_73if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2216_CopyDirWord1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2216_CopyDirWord1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L28_73if_f_id	:
		L28_73if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_74if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2216_CopyDirWord1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2216_CopyDirWord1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L28_74if_f_id	:
		L28_74if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L28_75if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2216_CopyDirWord1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2216_CopyDirWord1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L28_75if_f_id	:
		L28_75if_f:	;	
	case	L28_71if_d_id	:
		L28_71if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2216_CopyDirWord1Plane_00000001_id	:
		S_2216_CopyDirWord1Plane_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2216)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2196if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2196if_f_id	:
		L13_2196if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16412)	;	
	*((IUH	*)&(r2))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2217_CopyBwdWord1Plane()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2217_CopyBwdWord1Plane(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16413)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2217_CopyBwdWord1Plane_id	:
		S_2217_CopyBwdWord1Plane	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2217)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2197if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2197if_f_id	:
		L13_2197if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_87w_d;	
	case	L23_86w_t_id	:
		L23_86w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(*((IHPE	*)&(r22)))	)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+5))	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+4))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+4))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+5))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_86w_t;	
	case	L23_87w_d_id	:
		L23_87w_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001_id	:
		S_2218_UnchainedDwordMove_00000001_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2218)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2198if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2198if_f_id	:
		L13_2198if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16396)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2215_UnchainedWordMove_00000001_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16397)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001_id	:
		S_2219_UnchainedByteMove_00000002_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2219)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2199if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2199if_f_id	:
		L13_2199if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_76if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	{	extern	IUH	L28_77if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_77if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_76if_f_id	:
		L28_76if_f:	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	-	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	case	L28_77if_d_id	:
		L28_77if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001_id	:
		S_2220_CopyBytePlnByPlnUnchained_00000002_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2220)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2200if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2200if_f_id	:
		L13_2200if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_88if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_88if_f_id	:
		L23_88if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_89if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_89if_f_id	:
		L23_89if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_90if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_90if_f_id	:
		L23_90if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_91if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_91if_f_id	:
		L23_91if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001_id	:
		S_2221_CopyByte1PlaneUnchained_00000002_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2221)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2201if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2201if_f_id	:
		L13_2201if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_92if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_95w_d;	
	case	L23_94w_t_id	:
		L23_94w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_94w_t;	
	case	L23_95w_d_id	:
		L23_95w_d:	;	
	{	extern	IUH	L23_93if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_93if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_92if_f_id	:
		L23_92if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_97w_d;	
	case	L23_96w_t_id	:
		L23_96w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_96w_t;	
	case	L23_97w_d_id	:
		L23_97w_d:	;	
	case	L23_93if_d_id	:
		L23_93if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001_id	:
		S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2222)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2202if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2202if_f_id	:
		L13_2202if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_78if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	{	extern	IUH	L28_79if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_79if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_78if_f_id	:
		L28_78if_f:	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	-	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	case	L28_79if_d_id	:
		L28_79if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001_id	:
		S_2223_CopyWordPlnByPlnUnchained_00000002_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2223)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2203if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2203if_f_id	:
		L13_2203if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_98if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_98if_f_id	:
		L23_98if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_99if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_99if_f_id	:
		L23_99if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_100if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_100if_f_id	:
		L23_100if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_101if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_101if_f_id	:
		L23_101if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001_id	:
		S_2224_CopyWord1PlaneUnchained_00000002_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2224)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2204if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2204if_f_id	:
		L13_2204if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_102if_f;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_105w_d;	
	case	L23_104w_t_id	:
		L23_104w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_104w_t;	
	case	L23_105w_d_id	:
		L23_105w_d:	;	
	{	extern	IUH	L23_103if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_103if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_102if_f_id	:
		L23_102if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_107w_d;	
	case	L23_106w_t_id	:
		L23_106w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_106w_t;	
	case	L23_107w_d_id	:
		L23_107w_d:	;	
	case	L23_103if_d_id	:
		L23_103if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001_id	:
		S_2225_UnchainedDwordMove_00000002_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2225)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2205if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2205if_f_id	:
		L13_2205if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16396)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2222_UnchainedWordMove_00000002_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16397)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001_id	:
		S_2226_UnchainedByteMove_00000003_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2226)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2206if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2206if_f_id	:
		L13_2206if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_80if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	{	extern	IUH	L28_81if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_81if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_80if_f_id	:
		L28_80if_f:	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	-	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16370)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16371)	;	
	case	L28_81if_d_id	:
		L28_81if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001_id	:
		S_2227_CopyBytePlnByPlnUnchained_00000003_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2227)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2207if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2207if_f_id	:
		L13_2207if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_108if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_108if_f_id	:
		L23_108if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_109if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_109if_f_id	:
		L23_109if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_110if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_110if_f_id	:
		L23_110if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_111if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16372)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16373)	;	
	case	L23_111if_f_id	:
		L23_111if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001_id	:
		S_2228_CopyByte1PlaneUnchained_00000003_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2228)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2208if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2208if_f_id	:
		L13_2208if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_112if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_115w_d;	
	case	L23_114w_t_id	:
		L23_114w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_114w_t;	
	case	L23_115w_d_id	:
		L23_115w_d:	;	
	{	extern	IUH	L23_113if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_113if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_112if_f_id	:
		L23_112if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_117w_d;	
	case	L23_116w_t_id	:
		L23_116w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_116w_t;	
	case	L23_117w_d_id	:
		L23_117w_d:	;	
	case	L23_113if_d_id	:
		L23_113if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001_id	:
		S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2229)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2209if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2209if_f_id	:
		L13_2209if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L28_82if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	{	extern	IUH	L28_83if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L28_83if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L28_82if_f_id	:
		L28_82if_f:	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	-	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16382)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16383)	;	
	case	L28_83if_d_id	:
		L28_83if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001_id	:
		S_2230_CopyWordPlnByPlnUnchained_00000003_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2230)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2210if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2210if_f_id	:
		L13_2210if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_118if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(0)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_118if_f_id	:
		L23_118if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_119if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(8)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_119if_f_id	:
		L23_119if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_120if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(16)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_120if_f_id	:
		L23_120if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L23_121if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16384)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r7))	=	(IS32)(24)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004033),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16385)	;	
	case	L23_121if_f_id	:
		L23_121if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001_id	:
		S_2231_CopyWord1PlaneUnchained_00000003_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	48	>	0	)	LocalIUH	=	(IUH	*)malloc	(	48	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2231)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2211if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2211if_f_id	:
		L13_2211if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(LocalIUH+5))	=	*((IUH	*)&(r7))	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_122if_f;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_125w_d;	
	case	L23_124w_t_id	:
		L23_124w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(8)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_124w_t;	
	case	L23_125w_d_id	:
		L23_125w_d:	;	
	{	extern	IUH	L23_123if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_123if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_122if_f_id	:
		L23_122if_f:	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_127w_d;	
	case	L23_126w_t_id	:
		L23_126w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+6)	+	REGLONG)	=	*((IU32	*)(LocalIUH+6)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IUH	*)&(r22))	=	(IS32)(1420)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+9)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+9)	+	REGLONG));	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+11))	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	if(*((IU32	*)(LocalIUH+5)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)(LocalIUH+9)	+	REGLONG)	=	*((IU32	*)(LocalIUH+9)	+	REGLONG)	>>	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+9)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+11))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+11))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+8))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+8))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+6)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_126w_t;	
	case	L23_127w_d_id	:
		L23_127w_d:	;	
	case	L23_123if_d_id	:
		L23_123if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001_id	:
		S_2232_UnchainedDwordMove_00000003_0000000e_00000001_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2232)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2212if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2212if_f_id	:
		L13_2212if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+1)	+	REGLONG)	=	*((IU32	*)&(r3)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16396)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2229_UnchainedWordMove_00000003_0000000e_00000001_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16397)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2233_EGAGCIndexOutb_id	:
		S_2233_EGAGCIndexOutb	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r21))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	(IS32)(2233)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2213if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2213if_f_id	:
		L13_2213if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU16	*)(LocalIUH+0)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16418)	;	
	*((IU16	*)&(r2)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+0)	+	REGWORD)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2234_VGAGCIndexOutb()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2234_VGAGCIndexOutb(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16419)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2234_VGAGCIndexOutb_id	:
		S_2234_VGAGCIndexOutb	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2234)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2214if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2214if_f_id	:
		L13_2214if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU16	*)(LocalIUH+0)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU8	*)&(r22)	+	REGBYTE)	+	*((IU8	*)&(r21)	+	REGBYTE)	>	8	||	*((IU8	*)&(r22)	+	REGBYTE)	==	0)
	CrulesRuntimeError("Bad	byte	bitfield");
	else
	*((IU8	*)&(r20)	+	REGBYTE)	=	(IU8)((*((IU8	*)(LocalIUH+1)	+	REGBYTE)	<<	(	8-(*((IU8	*)&(r21)	+	REGBYTE)	+	*((IU8	*)&(r22)	+	REGBYTE)))))	>>	(	8	-	*((IU8	*)&(r22)	+	REGBYTE));	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)&(r20)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1428)	;	
	if	(*((IU8	*)(LocalIUH+2)	+	REGBYTE)	==	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	))	goto	L29_0if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1428)	;	
	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16420)	;	
	*((IUH	*)&(r23))	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE);	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)&(r23))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1424)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)&(r23))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+2928))	;	
	*((IUH	*)&(r22))	=	(IS32)(72)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IUH	*)(*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16421)	;	
	*((IUH	*)&(r20))	=	(IS32)(8)	;	
	if	(*((IS8	*)(LocalIUH+2)	+	REGBYTE)	!=		*((IS8	*)&(r20)	+	REGBYTE))	goto	L29_1if_f;	
	{	extern	IHPE	j_EvidPortFuncs;	*((IUH	*)&(r21))	=	j_EvidPortFuncs;	}	
	*((IUH	*)(LocalIUH+3))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(r1+0))	=	(IS32)(711)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+2960))	;	
	*((IUH	*)&(r21))	=	(IS32)(72)	;	
	*((IUH	*)&(r23))	=	*((IUH	*)(LocalIUH+3))	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)(*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(712)	;	
	{	extern	IUH	L29_2if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L29_2if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L29_1if_f_id	:
		L29_1if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(711)	;	
	{	extern	IHPE	j_AdapCOutb;	*((IUH	*)&(r22))	=	j_AdapCOutb;	}	
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+2960))	;	
	*((IUH	*)&(r21))	=	(IS32)(72)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r22))	;	
	*((IUH	*)(r1+0))	=	(IS32)(712)	;	
	case	L29_2if_d_id	:
		L29_2if_d:	;	
	case	L29_0if_f_id	:
		L29_0if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2235_VGAGCMaskRegOutb_id	:
		S_2235_VGAGCMaskRegOutb	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2235)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2215if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2215if_f_id	:
		L13_2215if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU16	*)(LocalIUH+0)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IU16	*)(LocalIUH+2)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+2)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1408)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)&(r20)	+	REGLONG));	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1412)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1312)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(255)	;	
	if	(*((IS8	*)(LocalIUH+1)	+	REGBYTE)	!=		*((IS8	*)&(r20)	+	REGBYTE))	goto	L29_3if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16426)	;	
	*((IUH	*)&(r2))	=	(IS32)(18)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+0)	+	REGWORD)	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2236_AdapCOutb()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2236_AdapCOutb(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16427)	;	
	case	L29_3if_f_id	:
		L29_3if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2236_AdapCOutb_id	:
		S_2236_AdapCOutb	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	16	>	0	)	LocalIUH	=	(IUH	*)malloc	(	16	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2236)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2216if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2216if_f_id	:
		L13_2216if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IU16	*)(LocalIUH+1)	+	REGWORD)	=	*((IU16	*)&(r3)	+	REGWORD	)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)&(r4)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(7381)	;	
	*((IU8	*)(r1+980)	+	REGBYTE)	=	(IS32)(0)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+2928))	+	*((IUH	*)&(r20))	;		
	*((IU16	*)&(r21)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+1)	+	REGWORD)	;	
	*((IUH	*)&(r21))	=	*((IU16	*)&(r21)	+	REGWORD);	
	*((IU8	*)&(r22)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	;	
	*((IUH	*)&(r22))	=	*((IU8	*)&(r22)	+	REGBYTE);	
	*(&rnull)	=	((IUH	(*)())(IHP)(*((IHPE	*)(*((IHPE	*)&(r20)))	))	)(*((IUH	*)&(r21)),*((IUH	*)&(r22)))	;
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IU8	*)(r1+980)	+	REGBYTE)	=	(IS32)(1)	;	
	*((IUH	*)(r1+0))	=	(IS32)(7382)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2237_VGAGCMaskFFRegOutb_id	:
		S_2237_VGAGCMaskFFRegOutb	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	12	>	0	)	LocalIUH	=	(IUH	*)malloc	(	12	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2237)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2217if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2217if_f_id	:
		L13_2217if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU16	*)(LocalIUH+0)	+	REGWORD)	=	*((IU16	*)&(r2)	+	REGWORD	)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(255)	;	
	if	(*((IU8	*)(LocalIUH+1)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L29_4if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16426)	;	
	*((IUH	*)&(r2))	=	(IS32)(18)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	*((IU16	*)(LocalIUH+0)	+	REGWORD)	;	
	*((IU8	*)&(r4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2236_AdapCOutb()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2236_AdapCOutb(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16427)	;	
	case	L29_4if_f_id	:
		L29_4if_f:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2238_GenericByteWrite_id	:
		S_2238_GenericByteWrite	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	28	>	0	)	LocalIUH	=	(IUH	*)malloc	(	28	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2238)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2218if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2218if_f_id	:
		L13_2218if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_0if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	{	extern	IUH	L24_1if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_1if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_0if_f_id	:
		L24_0if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if	(*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L24_2if_f;	
	*((IUH	*)&(r22))	=	(IS32)(1407)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
if(*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)>=8)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if(*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)!=0)
		*((IU8	*)&(r21)	+	REGBYTE)	=	(*((IU8	*)(LocalIUH+1)	+	REGBYTE)	<<	((8)	-	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	))	)		|	(*((IU8	*)&(r21)	+	REGBYTE)	>>	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	));
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)&(r20)	+	REGBYTE);	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	{	extern	IUH	L24_3if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_3if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_2if_f_id	:
		L24_2if_f:	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE);	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	case	L24_3if_d_id	:
		L24_3if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_4if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1429)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	==	*((IU8	*)&(r22)	+	REGBYTE))	goto	L24_6if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_8if_f;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16408)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IU16	*)(LocalIUH+2)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+2)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r21)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)(r1+0))	=	(IS32)(16409)	;	
	{	extern	IUH	L24_9if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_9if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_8if_f_id	:
		L24_8if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	case	L24_9if_d_id	:
		L24_9if_d:	;	
	{	extern	IUH	L24_7if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_7if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_6if_f_id	:
		L24_6if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if	(*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	==	*((IU8	*)&(r22)	+	REGBYTE))	goto	L24_10if_f;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16408)	;	
	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*(UOFF_15_8(	(LocalIUH+2)	))	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IU16	*)(LocalIUH+2)	+	REGWORD);	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IUH	*)&(r23))	=	(IS32)(16)	;	
	if	(*((IU32	*)&(r23)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)	>	32)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	(*((IU32	*)(LocalIUH+2)	+	REGLONG)	&	~mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))	))	|	((*((IU32	*)&(r20)	+	REGLONG)	<<	*((IU32	*)&(r22)	+	REGLONG))	&	mask((IUH)(*((IU32	*)&(r22)	+	REGLONG)),	(IUH)(*((IU32	*)&(r23)	+	REGLONG))))	;
	*((IUH	*)(r1+0))	=	(IS32)(16409)	;	
	{	extern	IUH	L24_11if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_11if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_10if_f_id	:
		L24_10if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	;	
	case	L24_11if_d_id	:
		L24_11if_d:	;	
	case	L24_7if_d_id	:
		L24_7if_d:	;	
	{	extern	IUH	L24_5if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_5if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_4if_f_id	:
		L24_4if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_12if_f;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	case	L24_12if_f_id	:
		L24_12if_f:	;	
	case	L24_5if_d_id	:
		L24_5if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_13if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1432)	;	
	*((IUH	*)&(r22))	=	(IS32)(16)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU8	*)&(r22)	+	REGBYTE);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU8	*)&(r20)	+	REGBYTE)	==	*((IU8	*)&(r22)	+	REGBYTE))	goto	L24_15if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	case	L24_15if_f_id	:
		L24_15if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16434)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16435)	;	
	{	extern	IUH	L24_14if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_14if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_13if_f_id	:
		L24_13if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_16if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16434)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16435)	;	
	{	extern	IUH	L24_17if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_17if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_16if_f_id	:
		L24_16if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1429)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_18if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	{	extern	IUH	L24_19if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_19if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_18if_f_id	:
		L24_18if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	case	L24_19if_d_id	:
		L24_19if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(1432)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(2)	;	
	if	(*((IU8	*)&(r23)	+	REGBYTE)	+	*((IU8	*)&(r22)	+	REGBYTE)	>	8	||	*((IU8	*)&(r23)	+	REGBYTE)	==	0)
	CrulesRuntimeError("Bad	byte	bitfield");
	else
	*((IU8	*)&(r20)	+	REGBYTE)	=	(IU8)((*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	<<	(	8-(*((IU8	*)&(r22)	+	REGBYTE)	+	*((IU8	*)&(r23)	+	REGBYTE)))))	>>	(	8	-	*((IU8	*)&(r23)	+	REGBYTE));	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU8	*)&(r20)	+	REGBYTE)	==	*((IU8	*)&(r22)	+	REGBYTE))	goto	L24_20if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1432)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(2)	;	
	if	(*((IU8	*)&(r23)	+	REGBYTE)	+	*((IU8	*)&(r22)	+	REGBYTE)	>	8	||	*((IU8	*)&(r23)	+	REGBYTE)	==	0)
	CrulesRuntimeError("Bad	byte	bitfield");
	else
	*((IU8	*)&(r20)	+	REGBYTE)	=	(IU8)((*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	<<	(	8-(*((IU8	*)&(r22)	+	REGBYTE)	+	*((IU8	*)&(r23)	+	REGBYTE)))))	>>	(	8	-	*((IU8	*)&(r23)	+	REGBYTE));	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if	(*((IS8	*)&(r20)	+	REGBYTE)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_21if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	{	extern	IUH	L24_22if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_22if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_21if_f_id	:
		L24_21if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1432)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r23))	=	(IS32)(2)	;	
	if	(*((IU8	*)&(r23)	+	REGBYTE)	+	*((IU8	*)&(r22)	+	REGBYTE)	>	8	||	*((IU8	*)&(r23)	+	REGBYTE)	==	0)
	CrulesRuntimeError("Bad	byte	bitfield");
	else
	*((IU8	*)&(r21)	+	REGBYTE)	=	(IU8)((*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	<<	(	8-(*((IU8	*)&(r22)	+	REGBYTE)	+	*((IU8	*)&(r23)	+	REGBYTE)))))	>>	(	8	-	*((IU8	*)&(r23)	+	REGBYTE));	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if	(*((IS8	*)&(r21)	+	REGBYTE)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_23if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	{	extern	IUH	L24_24if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_24if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_23if_f_id	:
		L24_23if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	case	L24_24if_d_id	:
		L24_24if_d:	;	
	case	L24_22if_d_id	:
		L24_22if_d:	;	
	case	L24_20if_f_id	:
		L24_20if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1432)	;	
	*((IUH	*)&(r22))	=	(IS32)(8)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU8	*)&(r22)	+	REGBYTE);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU8	*)&(r21)	+	REGBYTE)	==	*((IU8	*)&(r22)	+	REGBYTE))	goto	L24_25if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	case	L24_25if_f_id	:
		L24_25if_f:	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+2)	+	REGLONG));	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	&	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	case	L24_17if_d_id	:
		L24_17if_d:	;	
	case	L24_14if_d_id	:
		L24_14if_d:	;	
	case	L24_1if_d_id	:
		L24_1if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_26if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+5)	+	REGLONG);	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1356)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	{	extern	IUH	L24_27if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_27if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_26if_f_id	:
		L24_26if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r20)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L24_28if_f;	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+2)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1356)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004281),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	case	L24_28if_f_id	:
		L24_28if_f:	;	
	case	L24_27if_d_id	:
		L24_27if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2239_GenericByteFill_id	:
		S_2239_GenericByteFill	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2239)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2219if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2219if_f_id	:
		L13_2219if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	=	*((IU8	*)&(r3)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_29if_f;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L24_32w_d;	
	case	L24_31w_t_id	:
		L24_31w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16438)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2238_GenericByteWrite()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2238_GenericByteWrite(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16439)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L24_31w_t;	
	case	L24_32w_d_id	:
		L24_32w_d:	;	
	{	extern	IUH	L24_30if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_30if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_29if_f_id	:
		L24_29if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L24_34w_d;	
	case	L24_33w_t_id	:
		L24_33w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16438)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+1)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2238_GenericByteWrite()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2238_GenericByteWrite(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16439)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+3)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L24_33w_t;	
	case	L24_34w_d_id	:
		L24_34w_d:	;	
	case	L24_30if_d_id	:
		L24_30if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2240_GenericByteMove_Fwd_id	:
		S_2240_GenericByteMove_Fwd	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2240)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2220if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2220if_f_id	:
		L13_2220if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L24_35if_f;	
	*((IUH	*)(LocalIUH+6))	=	(IS32)(4)	;	
	{	extern	IUH	L24_36if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_36if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_35if_f_id	:
		L24_35if_f:	;	
	*((IUH	*)(LocalIUH+6))	=	(IS32)(1)	;	
	case	L24_36if_d_id	:
		L24_36if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L24_37if_f;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L24_40w_d;	
	case	L24_39w_t_id	:
		L24_39w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16438)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(*((IHPE	*)&(r21)))	)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2238_GenericByteWrite()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2238_GenericByteWrite(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16439)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)(LocalIUH+6)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L24_39w_t;	
	case	L24_40w_d_id	:
		L24_40w_d:	;	
	{	extern	IUH	L24_38if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L24_38if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L24_37if_f_id	:
		L24_37if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L24_42w_d;	
	case	L24_41w_t_id	:
		L24_41w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+4)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+9))	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1416)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004277),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IU8	*)(LocalIUH+10)	+	REGBYTE)	=	*((IU8	*)&(r2)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16438)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+10)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2238_GenericByteWrite()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2238_GenericByteWrite(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16439)	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+9))	+	*((IUH	*)(LocalIUH+6))	;		
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	+	*((IU32	*)(LocalIUH+6)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+4)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L24_41w_t;	
	case	L24_42w_d_id	:
		L24_42w_d:	;	
	case	L24_38if_d_id	:
		L24_38if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2241_GenericWordWrite_id	:
		S_2241_GenericWordWrite	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	40	>	0	)	LocalIUH	=	(IUH	*)malloc	(	40	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2241)	;	